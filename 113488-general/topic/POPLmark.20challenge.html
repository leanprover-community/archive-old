---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/POPLmark.20challenge.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/POPLmark.20challenge.html">POPLmark challenge</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="186924030"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/186924030" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tim Daly <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/POPLmark.20challenge.html#186924030">(Jan 29 2020 at 20:11)</a>:</h4>
<p>(<a href="https://blog.sigplan.org/2020/01/29/mechanized-proofs-for-pl-past-present-and-future" target="_blank" title="https://blog.sigplan.org/2020/01/29/mechanized-proofs-for-pl-past-present-and-future">https://blog.sigplan.org/2020/01/29/mechanized-proofs-for-pl-past-present-and-future</a>) POPLmark challenge is about Mechanized Proofs for Programming Languages. Lean is not just about mechanizing formal mathematics. It is also about mechanizing computational mathematics (at least from my opinionated viewpoint).   So besides pushing into the Math dept. we need to push into CS departments.</p>



<a name="186924244"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/186924244" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tim Daly <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/POPLmark.20challenge.html#186924244">(Jan 29 2020 at 20:13)</a>:</h4>
<p>CMU has Frank Pfenning, Bob Harper, and Karl Crary, all in CS and all doing related work, just not in Lean. What would it take to "Buzzard" the CS community?</p>



<a name="186924317"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/186924317" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/POPLmark.20challenge.html#186924317">(Jan 29 2020 at 20:14)</a>:</h4>
<p>It would take a buzzard...</p>



<a name="186924969"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/186924969" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tim Daly <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/POPLmark.20challenge.html#186924969">(Jan 29 2020 at 20:22)</a>:</h4>
<p>We have mathlib for the formal crowd. Perhaps we can import the Standard ML kinds of support into a proglib, which would contain definitions, axioms, and theorems related to code.</p>



<a name="186925427"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/186925427" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tim Daly <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/POPLmark.20challenge.html#186925427">(Jan 29 2020 at 20:28)</a>:</h4>
<p>From the talk... The paper abstract reads:<br>
How close are we to a world where every paper on progamming languages is accompanied by an electronic appendix with machine-checked proofs?<br>
We propose an initial set of benchmarks for measuring progress in this area. Based on the metatheory of System $F_&lt;$, a typed lambda-calculus with second-order polymorphism, subtyping, and records, these benchmarks embody many aspects of programming languages that are challenging to formalize: variable binding at both the term and type levels, syntactic forms with variable numbers of components (including binders), and proofs demanding complex induction principles. We hopt that these benchmarks will help clarify the current state of the art, provide a basis for comparing competing technologies, and motivate further research.</p>



<a name="186928605"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/186928605" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tim Daly <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/POPLmark.20challenge.html#186928605">(Jan 29 2020 at 21:05)</a>:</h4>
<p>One of the likely side-effects of a proglib (vs mathlib) would be developing program generation from Lean proofs. This isn't of much interest to the formal math approach but would be to the computational math crowd (aka me :-) )</p>



<a name="186934837"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/186934837" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/POPLmark.20challenge.html#186934837">(Jan 29 2020 at 22:18)</a>:</h4>
<blockquote>
<p>CMU has Frank Pfenning, Bob Harper, and Karl Crary, all in CS and all doing related work, just not in Lean. What would it take to "Buzzard" the CS community?</p>
</blockquote>
<p>I don't want to minimize Kevin's work, but it looks like this forum gives you a very distorted view of the reality of maths departments. To finite order, nothing changed. Any effect is beyond what Taylor expansions can see. The number of mathematicians using a proof assistant may have been multiplied by 20 in the last two years, but it is still very very very close to zero in proportion.</p>



<a name="186935818"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/186935818" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tim Daly <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/POPLmark.20challenge.html#186935818">(Jan 29 2020 at 22:31)</a>:</h4>
<p>I did a survey of the connection between ITP and Computer Algebra. I can only name one person (James Davenport) who appears in both bibliographies. So I know that this is at the "not even noise" level. But I have a "30 Year Horizon" view and I believe the connection must arrive in the long term. In particular, the subset of programming that involves computer algebra seems most likely to be automated since the specifications of the algorithms are already (reasonably well) known.</p>
<p>I'm spending the evening digging up information on TWELF and Standard ML, looking for something that could serve as a kernel of "proglib" in Lean. If Lean could produce ML programs from proofs that would be a major advance for Lean.</p>
<p>The fact that nobody knows how to do this is what makes it research.</p>



<a name="186935971"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/186935971" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Cruanes <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/POPLmark.20challenge.html#186935971">(Jan 29 2020 at 22:33)</a>:</h4>
<p>By producing ML programs from proofs, are you referring to something similar to Coq's extraction to OCaml?</p>



<a name="186936005"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/186936005" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Cruanes <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/POPLmark.20challenge.html#186936005">(Jan 29 2020 at 22:33)</a>:</h4>
<p>(extracting programs from proof assistants seem relatively common to me, Isabelle/HOL even has components to extract imperative programs)</p>



<a name="186936123"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/186936123" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tim Daly <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/POPLmark.20challenge.html#186936123">(Jan 29 2020 at 22:34)</a>:</h4>
<p>Yes. Lean should be able to extract a program from a proof. I'd rather it could extract SPAD (Axiom's language) programs as SPAD is dependently typed but ML might be easier as some of the other systems could provide validation.</p>



<a name="186936287"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/186936287" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tim Daly <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/POPLmark.20challenge.html#186936287">(Jan 29 2020 at 22:37)</a>:</h4>
<p>One interesting thought would be to try to build 'proglib' so that everything has a programming language representation. Sort of "designed to be executed". I'm not sure yet how this can be done, of course.</p>



<a name="186936382"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/186936382" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/POPLmark.20challenge.html#186936382">(Jan 29 2020 at 22:38)</a>:</h4>
<p>Lean is already a programming language, so you can take the program extraction to be the identity.</p>



<a name="186936431"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/186936431" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tim Daly <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/POPLmark.20challenge.html#186936431">(Jan 29 2020 at 22:39)</a>:</h4>
<p>I'm not sure what the execution semantics are for the proofs I've read.</p>



<a name="186936439"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/186936439" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/POPLmark.20challenge.html#186936439">(Jan 29 2020 at 22:40)</a>:</h4>
<p>In Lean 4, this will sometimes even be a sensible thing to do. But a lot depends on the original proof. For example, if it is nonconstructive, then it has no computational meaning.</p>



<a name="186936486"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/186936486" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/POPLmark.20challenge.html#186936486">(Jan 29 2020 at 22:40)</a>:</h4>
<p>Because those proofs were not intended to be executed, most likely</p>



<a name="186936551"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/186936551" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Cruanes <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/POPLmark.20challenge.html#186936551">(Jan 29 2020 at 22:41)</a>:</h4>
<p>If you want to write verified programs, why consider them as proofs and not as normal values? This way you can write programs in a readable way, and prove properties about them separately (which is done in CFML, CompCert, etc. afaik)</p>



<a name="186936598"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/186936598" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tim Daly <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/POPLmark.20challenge.html#186936598">(Jan 29 2020 at 22:42)</a>:</h4>
<p>My thought (and what I'm using as a basis for reading) is that I'm looking for a translation from program -&gt; Lean -&gt; program that is 1-1 (or some near approach). I've found some ML and TWELF papers so I'm reading.</p>



<a name="186937441"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/186937441" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tim Daly <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/POPLmark.20challenge.html#186937441">(Jan 29 2020 at 22:55)</a>:</h4>
<p><span class="user-mention" data-user-id="132878">@Simon Cruanes</span>  I have programs written in a reasonable way (e.g. GCD, Groebner, etc) and specifications for them. But there needs to be some deeper, automated connection from these programs to Lean and back so they can be trusted. Otherwise it feels like "hand waving" (at least to me).</p>



<a name="186941949"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/186941949" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tim Daly <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/POPLmark.20challenge.html#186941949">(Jan 29 2020 at 23:59)</a>:</h4>
<p>There is an interesting split I've come to recognize between the ITP approach and the Type-Theory approach to things, despite the fact that they both seem to use the same judgments. ITP systems tend toward "tactics" whereas the Type-Theory approach tends to use unification.</p>



<a name="186946526"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/186946526" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Cruanes <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/POPLmark.20challenge.html#186946526">(Jan 30 2020 at 01:16)</a>:</h4>
<p>In my (limited) view of the field, it seems like most big programs that are verified in ITPs are all based on the separation of the program to prove and the properties on the program (even CompCert, and of course, SEL4, CakeML, etc.).<br>
I'm not aware of any actual big program written as a proof following the CH correspondence. I'd love be to proven wrong though!</p>



<a name="186947152"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/186947152" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tim Daly <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/POPLmark.20challenge.html#186947152">(Jan 30 2020 at 01:27)</a>:</h4>
<p>Axiom is a collection of mathematical algorithms. Rather than prove a large program, my effort is to prove the individual algorithms. So, for instance, GCD has a specification and an implementation. There are several interesting questions that arise. Axiom actually has 22 different GCD algorithms (e.g. GCD for polynomials, Nats, etc). How can these algorithms be proven correct. How can they be proven correct in such a way that Lean can verify the proof, allowing Lean to use Axiom as an Oracle for a GCD computation.</p>



<a name="186947505"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/186947505" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tim Daly <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/POPLmark.20challenge.html#186947505">(Jan 30 2020 at 01:32)</a>:</h4>
<p>Nat in Axiom is called NonNegativeInteger (NNI). The definitions, axioms, and theorems available to the NNI Domain (an Axiom term for an implementation) are all inherited. The NNI Domain also includes a "carrier" (called a REP) which specifies how elements are implemented. So, given group theory axioms (e.g. associativity), a representation, a specification, and an algorithm... use Lean's group theory and Nat, as well as pre- and post-conditions and loop invariants to prove the GCD correct in Lean.</p>



<a name="186947534"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/186947534" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Cruanes <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/POPLmark.20challenge.html#186947534">(Jan 30 2020 at 01:33)</a>:</h4>
<p>So what language is the algorithm expressed in?</p>



<a name="186947615"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/186947615" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tim Daly <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/POPLmark.20challenge.html#186947615">(Jan 30 2020 at 01:34)</a>:</h4>
<p>SPAD, a dependently typed language built on Common Lisp. (See <a href="https://github.com/daly/PDFS/blob/master/bookvol0.pdf" target="_blank" title="https://github.com/daly/PDFS/blob/master/bookvol0.pdf">https://github.com/daly/PDFS/blob/master/bookvol0.pdf</a>)</p>



<a name="186947718"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/186947718" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tim Daly <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/POPLmark.20challenge.html#186947718">(Jan 30 2020 at 01:36)</a>:</h4>
<p>In an ideal world a GCD algorithm would be transformed into a Lean proof object, proven, and then re-generated from the proof object. The proof then becomes a certificate you can hand to a proof-checker.</p>



<a name="186947833"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/186947833" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Cruanes <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/POPLmark.20challenge.html#186947833">(Jan 30 2020 at 01:39)</a>:</h4>
<p>Oh damn, I didn't realize it was <em>that</em> axiom, the CAS… :o</p>



<a name="186947904"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/186947904" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tim Daly <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/POPLmark.20challenge.html#186947904">(Jan 30 2020 at 01:40)</a>:</h4>
<p>There are a lot of "Axiom" things around, including the new Axiom that is working on space ships. But, yes, this is the Axiom originally from IBM Research and I'm one of the original people to blame. :-)</p>



<a name="186948018"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/186948018" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Cruanes <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/POPLmark.20challenge.html#186948018">(Jan 30 2020 at 01:43)</a>:</h4>
<blockquote>
<p>There are a lot of "Axiom" things around</p>
</blockquote>
<p>well of course, that's why we have the Axiom of choice!</p>



<a name="186948041"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/186948041" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tim Daly <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/POPLmark.20challenge.html#186948041">(Jan 30 2020 at 01:43)</a>:</h4>
<p>2 points on that one. I am SO stealing that.</p>



<a name="186948534"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/186948534" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tim Daly <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/POPLmark.20challenge.html#186948534">(Jan 30 2020 at 01:53)</a>:</h4>
<p>Axiom's byline is "The 30 Year Horizon" but I think you just came up with a "near miss".</p>



<a name="186948614"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/186948614" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Cruanes <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/POPLmark.20challenge.html#186948614">(Jan 30 2020 at 01:56)</a>:</h4>
<p>you can display a catchphrase randomly sampled on the website :)</p>



<a name="186980385"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/186980385" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anton Lorenzen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/POPLmark.20challenge.html#186980385">(Jan 30 2020 at 12:30)</a>:</h4>
<blockquote>
<p>CMU has Frank Pfenning, Bob Harper, and Karl Crary, all in CS and all doing related work, just not in Lean. What would it take to "Buzzard" the CS community?</p>
</blockquote>
<p>I think since Lean already has decent category theory support it would make sense to formalize the categorical view of programming languages (at least Haskell folks seem to be interested in that). I have an 80%-finished experiment showing that SystemFw types form a category on my hard drive.. but to really draw attention it would probably need to formalize something like lenses which requires both type theory work (like a type inference so one can avoid invoking the axioms everywhere) and more category theory than mathlib currently has (mostly profunctors and (co)ends)</p>



<a name="186981407"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/186981407" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/POPLmark.20challenge.html#186981407">(Jan 30 2020 at 12:45)</a>:</h4>
<p>I'm not sure the categorical view espoused by Haskellites is actually coherent, compelling though it is. See <a href="http://math.andrej.com/2016/08/06/hask-is-not-a-category/" target="_blank" title="http://math.andrej.com/2016/08/06/hask-is-not-a-category/">http://math.andrej.com/2016/08/06/hask-is-not-a-category/</a></p>



<a name="186982590"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/186982590" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anton Lorenzen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/POPLmark.20challenge.html#186982590">(Jan 30 2020 at 12:59)</a>:</h4>
<p>I haven't finished my project yet, so I can't be 100% sure that it works, but I would be surprised if it didn't.. Mostly because SystemFw isn't Haskell and doesn't have laziness or infinite loops. I agree that most Haskellers use category theory a bit loosely, but then it actually makes some sense to assume that a Haskell program doesn't contain bottom since if it did it wouldn't run/finish :)</p>



<a name="186983277"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/186983277" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/POPLmark.20challenge.html#186983277">(Jan 30 2020 at 13:05)</a>:</h4>
<p>haskell programs often contain bottom in places other than where the program actually goes. It seems difficult to me to deliver a denotational semantics for lazy haskell programs that does not contain bottom</p>



<a name="186983406"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/186983406" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/POPLmark.20challenge.html#186983406">(Jan 30 2020 at 13:06)</a>:</h4>
<p>For example you can define <code>prime :: [Integer]</code> and then <code>show (take 10 prime)</code> is just fine but <code>show prime</code> is not</p>



<a name="186983551"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/186983551" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/POPLmark.20challenge.html#186983551">(Jan 30 2020 at 13:07)</a>:</h4>
<p>You can't cleanly separate the good programs from bad without solving the halting problem</p>



<a name="186984240"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/186984240" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anton Lorenzen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/POPLmark.20challenge.html#186984240">(Jan 30 2020 at 13:13)</a>:</h4>
<p>Yeah, that's true. And even when you make extra sure to only write halting functions you still have stuff like 'head' in the Prelude :( But still, if the goal is to "buzzard" Haskellers, category theory could be a good choice.</p>



<a name="187034356"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/187034356" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tim Daly <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/POPLmark.20challenge.html#187034356">(Jan 30 2020 at 21:42)</a>:</h4>
<p>A reasonably sound start for a 'proglib' would be to look at The (Revised) Definition of Standard ML (<a href="http://sml-family.org/sml97-defn.pdf" target="_blank" title="http://sml-family.org/sml97-defn.pdf">http://sml-family.org/sml97-defn.pdf</a>).  Constructed properly, it should be possible to write in ML, grind it into a proof expression, and output ML. Since ML has a full formal definition this should cover a reasonable range of "proofs with execution semantics".</p>



<a name="187037175"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/187037175" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tim Carstens <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/POPLmark.20challenge.html#187037175">(Jan 30 2020 at 22:14)</a>:</h4>
<p>Heh I was doing CS (separation logic) in Lean 2 ... then Lean 3</p>



<a name="187037182"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/187037182" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tim Carstens <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/POPLmark.20challenge.html#187037182">(Jan 30 2020 at 22:14)</a>:</h4>
<p>Lean was awesome for it</p>



<a name="187037219"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/187037219" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tim Daly <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/POPLmark.20challenge.html#187037219">(Jan 30 2020 at 22:15)</a>:</h4>
<p>Is your source code available?</p>



<a name="187037245"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/187037245" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tim Carstens <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/POPLmark.20challenge.html#187037245">(Jan 30 2020 at 22:16)</a>:</h4>
<p>No; it was a commercial investment by a client</p>



<a name="187037285"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/187037285" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tim Carstens <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/POPLmark.20challenge.html#187037285">(Jan 30 2020 at 22:16)</a>:</h4>
<p>The AST for C++11 was epic</p>



<a name="187037317"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/187037317" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tim Carstens <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/POPLmark.20challenge.html#187037317">(Jan 30 2020 at 22:16)</a>:</h4>
<p>Lean 2 took 45 minutes to convince itself the mutual inductive was <span aria-label="+1" class="emoji emoji-1f44d" role="img" title="+1">:+1:</span> but everything else was instantaneous <span aria-label="joy" class="emoji emoji-1f602" role="img" title="joy">:joy:</span></p>



<a name="187037364"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/187037364" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tim Carstens <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/POPLmark.20challenge.html#187037364">(Jan 30 2020 at 22:17)</a>:</h4>
<p>My buddy got so tired of the checking times for the AST def that he wrote a DSL and a tool that converted the DSL to lean syntax - he called it VasoLean</p>



<a name="187037580"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/187037580" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tim Carstens <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/POPLmark.20challenge.html#187037580">(Jan 30 2020 at 22:20)</a>:</h4>
<p><a href="http://adam.chlipala.net/frap/" target="_blank" title="http://adam.chlipala.net/frap/">http://adam.chlipala.net/frap/</a></p>



<a name="187037641"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/187037641" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tim Daly <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/POPLmark.20challenge.html#187037641">(Jan 30 2020 at 22:21)</a>:</h4>
<p>I'm attracted to ML as an initial basis for a 'proglib' for several reasons. (1) it has an ITP history, (2) it has a semantics definition, (3) it has been used as a programming language for other things, (4) it is sort-of implemented in other ITP systems and OCaml. </p>
<p>My problem with it is that while functions are first class, types are not. Axiom has first class dependent types so it isn't quite the full basis I need but it is pretty close and, honestly, will keep me busy for a long time anyway :-)</p>



<a name="187037976"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/187037976" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tim Daly <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/POPLmark.20challenge.html#187037976">(Jan 30 2020 at 22:25)</a>:</h4>
<p>I am currently (re)-reading the Definition of Standard ML with an eye toward figuring out how to write Lean code. Clearly this is going to take a while.</p>



<a name="187039792"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/187039792" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tim Carstens <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/POPLmark.20challenge.html#187039792">(Jan 30 2020 at 22:49)</a>:</h4>
<p>Imho, there’s two big schools of thought for applying mechanized logic to software engineering</p>



<a name="187039814"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/187039814" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tim Carstens <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/POPLmark.20challenge.html#187039814">(Jan 30 2020 at 22:50)</a>:</h4>
<p>Naive way: just write your code in Lean or Coq and extract to ocaml or Haskell or C or whatever</p>



<a name="187039885"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/187039885" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tim Carstens <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/POPLmark.20challenge.html#187039885">(Jan 30 2020 at 22:50)</a>:</h4>
<p>Imho that’s a weak idea, basically just saying “the problem with Ada was that it wasn’t pure functional” - just offering yet another programming language</p>



<a name="187039926"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/187039926" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tim Carstens <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/POPLmark.20challenge.html#187039926">(Jan 30 2020 at 22:51)</a>:</h4>
<p>Smart way: use your logic as a logic, build models about other languages, use those models to do proofs. Flexible, language agnostic, extensible, modular, just overall faaaaaar more powerful</p>



<a name="187040044"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/187040044" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tim Carstens <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/POPLmark.20challenge.html#187040044">(Jan 30 2020 at 22:52)</a>:</h4>
<p>Tldr: dont compete with small fish like Dafny and Spark Ada. Go for the jugular: let’s eradicate prose specs. Compete with PDF!!!</p>



<a name="187040080"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/187040080" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tim Carstens <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/POPLmark.20challenge.html#187040080">(Jan 30 2020 at 22:53)</a>:</h4>
<p>Offer Lean as a foundation for <em>all</em> comp sci</p>



<a name="187040175"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/187040175" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tim Carstens <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/POPLmark.20challenge.html#187040175">(Jan 30 2020 at 22:54)</a>:</h4>
<p>For this purpose, foundational axioms &amp; other stuff that makes the math ppl hard to sway are more or less bike-shedding</p>



<a name="187042670"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/187042670" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tim Daly <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/POPLmark.20challenge.html#187042670">(Jan 30 2020 at 23:26)</a>:</h4>
<p>I'm only going after specification and proofs of mathematical algorithms. They already work but are not yet proven in Lean so Lean cannot use them as Oracles. So 'proglib' would not be a naive approach as the algorithms already exist. Nor would it be a Smart way as the goal is not "all" programming language, just one that is a respected implementation of computational mathematics. 'Proglib' would provide a way to communicate soundly and with execution semantics (lacking in a lot of proofs I've looked at so far).</p>
<p>Axiom is the result of an estimated 42 million dollars and 300+ person years of work, some of it as PhD research. We don't have the funding or organization to repeat the effort from scratch. However, putting Axiom on a formal footing is possible but it requires automation and intimate interaction between Lean and Axiom. It is not a question of (Naive) accepting algorithms generated from Lean. It is a question of constructing a sound basis for cooperation.</p>



<a name="187043051"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/187043051" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tim Carstens <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/POPLmark.20challenge.html#187043051">(Jan 30 2020 at 23:32)</a>:</h4>
<p>Agree on that</p>



<a name="187043110"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/187043110" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tim Carstens <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/POPLmark.20challenge.html#187043110">(Jan 30 2020 at 23:33)</a>:</h4>
<p>I wasn’t replying directly to that idea, but rather, expressing my opinion on the big Q of what the right way is to do formal methods + comp sci in dependent type theory</p>



<a name="187043198"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/187043198" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tim Carstens <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/POPLmark.20challenge.html#187043198">(Jan 30 2020 at 23:34)</a>:</h4>
<p>I’m excited about the idea of having a popular, widely accepted meta logic for CS stuff - think it’ll be a huge boon for the field</p>



<a name="187043213"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/187043213" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tim Carstens <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/POPLmark.20challenge.html#187043213">(Jan 30 2020 at 23:34)</a>:</h4>
<p>There’s a battle for mindshare right now among the mechanized logics</p>



<a name="187043288"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/187043288" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tim Carstens <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/POPLmark.20challenge.html#187043288">(Jan 30 2020 at 23:36)</a>:</h4>
<p>It’d be a shame for pure math to converge on one system and for CS another - right now the CS ppl in USA kinda hate pure math but I think anyone who things the two fields are headed in separate directions is stuck in the past</p>



<a name="187043355"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/187043355" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tim Carstens <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/POPLmark.20challenge.html#187043355">(Jan 30 2020 at 23:36)</a>:</h4>
<p>Sadly I heard a lot of “lean for math, Coq for CS” talk at POPL</p>



<a name="187043392"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/187043392" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tim Carstens <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/POPLmark.20challenge.html#187043392">(Jan 30 2020 at 23:37)</a>:</h4>
<p>Disputes about foundations and stuff - legit I’m sure to the experts in logic, but I’ve done pure math in both envs and tbh I never noticed the difference</p>



<a name="187043457"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/187043457" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tim Carstens <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/POPLmark.20challenge.html#187043457">(Jan 30 2020 at 23:38)</a>:</h4>
<p>Maybe some stuff is super sensitive to those issues but I don’t personally know an example</p>



<a name="187044128"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/187044128" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/POPLmark.20challenge.html#187044128">(Jan 30 2020 at 23:48)</a>:</h4>
<blockquote>
<p>Sadly I heard a lot of “lean for math, Coq for CS” talk at POPL</p>
</blockquote>
<p>I am by no means an expert in this sort of thing, but I know for sure that Leo is targetting computer scientists with Lean 4.</p>



<a name="187046009"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/187046009" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tim Carstens <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/POPLmark.20challenge.html#187046009">(Jan 31 2020 at 00:17)</a>:</h4>
<p>That’s consistent with the conversations I’ve had with him in the past</p>



<a name="187046023"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/187046023" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tim Carstens <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/POPLmark.20challenge.html#187046023">(Jan 31 2020 at 00:17)</a>:</h4>
<p>And I am definitely a fan of that - I absolutely love Lean for a variety of reasons</p>



<a name="187046046"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/187046046" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tim Carstens <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/POPLmark.20challenge.html#187046046">(Jan 31 2020 at 00:17)</a>:</h4>
<p>Lots of tiny little decisions made right; adds up to a very nice experience imho</p>



<a name="187046244"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/187046244" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tim Daly <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/POPLmark.20challenge.html#187046244">(Jan 31 2020 at 00:21)</a>:</h4>
<p>The computer scientist camp (of which I'm one) tends to do Type Checking, Unification (ala prolog), and forward/backward typing. There is the idea of "judgments-as-type", which I don't see in the ITP literature. Ideas are expressed as code.</p>
<p>Having spent the last few years wandering in the ITP side I see mathematical notation. (I really wish <span class="user-mention" data-user-id="110865">@Jeremy Avigad</span> "natural language idea would catch on as it is much more readable). I find the notation a really steep hill to climb (despite having a math degree) as it seems to be "write only", that is, if you understand what the statement says, then you understand it. But until you do, you don't.<br>
Plus there isn't nearly as much emphasis on Types, except the constant bike-shedding on Universes.</p>
<p>There is also a dependence on "funky names" in Lean. If you need more than 1 word for a function there should be an inheritance hierarchy, as usually found in programming. I've been paid to program in 60 languages and I'm still struggling with Lean syntax.</p>



<a name="187046351"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/187046351" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tim Daly <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/POPLmark.20challenge.html#187046351">(Jan 31 2020 at 00:23)</a>:</h4>
<p>My usual approach to a new programming language is to write a chess playing program (simple rules, simple alpha-beta tree search, simple I/O) but I'm not sure where to begin in Lean.</p>



<a name="187046683"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/187046683" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tim Daly <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/POPLmark.20challenge.html#187046683">(Jan 31 2020 at 00:30)</a>:</h4>
<p>I am looking forward to Lean 4 as I understand that the kernel will be small and the rest of the language is in Lean. That gives me the opportunity to re-implement the kernel in Lisp and have Lean "be native". That assumes, of course, that there is some natural language documentation of the kernel. I've read the Lean 3 source code and have very little idea what is going on, what rules are implemented, what data structures correspond to (e.g. what is the theorem data structure, the proof data structure, the judgment data structure, and all of the other things you'd expect to find in the kernel).</p>



<a name="187050298"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/187050298" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris B <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/POPLmark.20challenge.html#187050298">(Jan 31 2020 at 01:41)</a>:</h4>
<blockquote>
<p>I am looking forward to Lean 4 as I understand that the kernel will be small and the rest of the language is in Lean. </p>
</blockquote>
<p>The kernel is roughly the same size in 4 as it was in 3 (~5000 loc in .cpp files, ~2200 in .h files). I'll eventually re-do the documentation for the Rust one when the v4 branch is more stable. FWIW, reimplementing the kernel might end up becoming a long-cut if your goal is mostly to learn Lean as a programming language though, the gap between what you see in your editor and the kernel representation is pretty big.</p>



<a name="187052885"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/187052885" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tim Daly <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/POPLmark.20challenge.html#187052885">(Jan 31 2020 at 02:50)</a>:</h4>
<p>well I obviously have a lot more to learn about Lean. That said, the idea that the Lean kernel could be implemented in Lisp means that Lean could share data structures directly with Axiom, removing the need for</p>



<a name="187053072"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/187053072" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tim Daly <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/POPLmark.20challenge.html#187053072">(Jan 31 2020 at 02:55)</a>:</h4>
<p>I obviously have a lot more to learn about Lean. The idea of having the Lean kernel in Lisp is that they can share data structures directly, which removes the need to communicate. Further, it means that Lean can share Axiom's type hierarchy  and it can show up in output.</p>
<p>In the new version of Axiom (the Sane branch), I want to add "provisos" to output. For example, I want to know that the result as presented provided certain conditions apply. For example, a result might only be valid if its argument is greater than zero, giving<br>
    foo(x)  suchthat x&gt;0<br>
That requires a fair bit of machinery, some of which Lean can assist.</p>



<a name="187053385"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/187053385" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris B <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/POPLmark.20challenge.html#187053385">(Jan 31 2020 at 03:04)</a>:</h4>
<blockquote>
<p>well I obviously have a lot more to learn about Lean.</p>
</blockquote>
<p>You and me both brother. It would be interesting to see whether a Lisp implementation could take the title for smallest Lean type checker, Trepplein currently has the crown at ~2.1k.</p>



<a name="187053489"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/187053489" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tim Daly <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/POPLmark.20challenge.html#187053489">(Jan 31 2020 at 03:08)</a>:</h4>
<p>I'd be happy to have it work correctly.</p>



<a name="187060911"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/187060911" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Cruanes <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/POPLmark.20challenge.html#187060911">(Jan 31 2020 at 06:50)</a>:</h4>
<p>The rust one? Are you redoing a lean4 kernel in rust? ö</p>



<a name="187060922"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/187060922" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Huisinga <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/POPLmark.20challenge.html#187060922">(Jan 31 2020 at 06:50)</a>:</h4>
<blockquote>
<p>Smart way: use your logic as a logic, build models about other languages, use those models to do proofs. Flexible, language agnostic, extensible, modular, just overall faaaaaar more powerful</p>
</blockquote>
<p>my worry is that reasoning in the model and ensuring that the translation between the the model and the programming language is correct would be significantly more difficult than just using lean itself. <br>
i agree that there are many compelling reasons to do this, especially since programmers surely also care about ensuring non-functional properties like time complexity.</p>
<p>perhaps tactics can bridge the gap for reasoning in the model?</p>



<a name="187072153"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/187072153" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/POPLmark.20challenge.html#187072153">(Jan 31 2020 at 10:36)</a>:</h4>
<p><span class="user-mention" data-user-id="132878">@Simon Cruanes</span> Chris wrote a <a href="https://github.com/ammkrn/nanoda/" target="_blank" title="https://github.com/ammkrn/nanoda/">typechecker</a> for the lean 3 kernel in rust, and he's been updating it for the new lean 4 features</p>



<a name="187072392"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/187072392" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/POPLmark.20challenge.html#187072392">(Jan 31 2020 at 10:39)</a>:</h4>
<p><span class="user-mention" data-user-id="221921">@Marc Huisinga</span> </p>
<blockquote>
<p>my worry is that reasoning in the model and ensuring that the translation between the the model and the programming language is correct would be significantly more difficult than just using lean itself. <br>
i agree that there are many compelling reasons to do this, especially since programmers surely also care about ensuring non-functional properties like time complexity.</p>
<p>perhaps tactics can bridge the gap for reasoning in the model?</p>
</blockquote>
<p>(I completely agree with Tim Carsten's point here.) You don't have any translation gap if the "model" is not a model so much as a specification for the language itself. Depending on how your formalization relates to the language itself, it might be authoritative as a spec, or it could be a transcription of some natural language spec (in which case effort is needed to ensure these cohere). But if the language itself when executed has a different behavior, the presence of the spec ensures that this can be categorized as a compilation bug and not a modeling bug</p>



<a name="187072734"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/187072734" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bas Spitters <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/POPLmark.20challenge.html#187072734">(Jan 31 2020 at 10:45)</a>:</h4>
<p>We've done quite a bit of work connecting with the computer algebraist and people in numerics in workshops like MAP, CICM, and in the formath project. It's a slow process in which lean is just another step.<br>
<a href="https://wiki.portal.chalmers.se/cse/pmwiki.php/ForMath/ForMath" target="_blank" title="https://wiki.portal.chalmers.se/cse/pmwiki.php/ForMath/ForMath">https://wiki.portal.chalmers.se/cse/pmwiki.php/ForMath/ForMath</a><br>
<a href="https://www.cs.au.dk/~spitters/typesreal.html" target="_blank" title="https://www.cs.au.dk/~spitters/typesreal.html">https://www.cs.au.dk/~spitters/typesreal.html</a><br>
<a href="https://www.cicm-conference.org/cicm.php" target="_blank" title="https://www.cicm-conference.org/cicm.php">https://www.cicm-conference.org/cicm.php</a><br>
<a href="https://perso.crans.org/cohen/map2014/program/" target="_blank" title="https://perso.crans.org/cohen/map2014/program/">https://perso.crans.org/cohen/map2014/program/</a><br>
<a href="https://www.newton.ac.uk/event/bpr" target="_blank" title="https://www.newton.ac.uk/event/bpr">https://www.newton.ac.uk/event/bpr</a></p>



<a name="187076220"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/187076220" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Huisinga <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/POPLmark.20challenge.html#187076220">(Jan 31 2020 at 11:47)</a>:</h4>
<blockquote>
<p>You don't have any translation gap if the "model" is not a model so much as a specification for the language itself. Depending on how your formalization relates to the language itself, it might be authoritative as a spec, or it could be a transcription of some natural language spec (in which case effort is needed to ensure these cohere). But if the language itself when executed has a different behavior, the presence of the spec ensures that this can be categorized as a compilation bug and not a modeling bug</p>
</blockquote>
<p>ah, i see what you mean! </p>
<p>but what about the effort of reasoning about the model/spec compared to plain lean? specifically, i imagine that one would work directly with some kind of formal semantics. my gut feeling tells me that dealing with denotational semantics should be easier than dealing with operational semantics in lean, but it also tells me that keeping track of stuff like time complexity is easier with operational semantics :)</p>
<p>i think it's also important that one would be able to translate ("some"?) theorems between different models to cut down on the duplication. this isn't just important for programming in different programming languages, but also for cs (for instance, both my algorithm and computational complexity theory lectures regularly switched or extended the machine model, carrying over theorems where sensible). this roughly sounds a bit like the transport stuff that has been discussed here before.</p>



<a name="187097594"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/187097594" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tim Daly <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/POPLmark.20challenge.html#187097594">(Jan 31 2020 at 16:18)</a>:</h4>
<p><span class="user-mention" data-user-id="259452">@Bas Spitters</span> re: The ForMath project whose definition is:<br>
Concretely, the objective of this project is to develop libraries of formalised mathematics concerning algebra, linear algebra, real number computation, and algebraic topology. The libraries that we plan to develop in this proposal are especially chosen to have long-term applications in areas where software interacts with the physical world. The main originality of the work is to structure these libraries as a software development, relying on a basis that has already shown its power in the formal proof of the four-colour theorem, and to address topics that were mostly left untouched by previous research in formal proof or formal methods.</p>
<p>Proof of the four-colour theorem is very interesting as is other examples of formal proof. Certainly these formal mathematics libraries are valuable. My goal differs from the ForMath project in that I emphasis executable semantics of proofs. This merges proofs and computer algebra into "computational mathematics". Rather than stand-alone libraries, we need trusted computations of "college mathematics".</p>



<a name="187098049"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/187098049" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tim Daly <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/POPLmark.20challenge.html#187098049">(Jan 31 2020 at 16:23)</a>:</h4>
<p>For the Small Types workshop, there appear to be two streams of interest,<br>
 exact real number computation<br>
semantics for real computations (e.g. domain theory, formal topology)</p>
<p>The exact real number work is of deep interest and I will do some follow-up research on the papers.<br>
The semantics of real computations sounds interesting but seems to far on the "theory" side rather than execution.</p>



<a name="187098605"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/187098605" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tim Daly <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/POPLmark.20challenge.html#187098605">(Jan 31 2020 at 16:29)</a>:</h4>
<p>The Digital Mathematics Library seems oriented toward document handling, which is interesting for a different reason.</p>
<p>Axiom uses Knuth's Literate Programming so the actual source code is available in Latex documents which produce both PDFs and executable code. The hope is that, when distributing an electronic paper to a conference, one could download and execute "the paper" while the talk is in progress. That way the research can be "reproduced" and used immediately.</p>



<a name="187099223"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/187099223" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tim Daly <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/POPLmark.20challenge.html#187099223">(Jan 31 2020 at 16:36)</a>:</h4>
<p>The Mathematical Knowledge Management, seems designed to send something like a polynomial out of one system, through an "island" of mathematics doing semantics translation, and on to a target system.</p>
<p>Unfortunately I don't see how this can work. Consider the case of sending an Axiom polynomial to the island and back to the original Axiom system. Axiom polynomials have many representations (sparse, dense, recursive, etc.). They live over many different fields. In other words, there are whole towers of code associated with the "surface version" of a polynomial.</p>



<a name="187099600"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/187099600" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tim Daly <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/POPLmark.20challenge.html#187099600">(Jan 31 2020 at 16:40)</a>:</h4>
<p>The Map 2014 link has some interesting papers, such as Grenet's Computing low-degree factors of lacunary polynomials: a Newton-Puiseux approach. This may be an implementable algorithm. I will follow up on these papers. But the question for this forum is whether Grenet's algorithm includes a proof.</p>



<a name="187099783"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/187099783" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tim Daly <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/POPLmark.20challenge.html#187099783">(Jan 31 2020 at 16:42)</a>:</h4>
<p>Big Proof, which " brings together mathematicians interested in employing proof technology in their research, logicians exploring pragmatic and foundational issues in the formalisation of mathematics, and computer scientists engaged in developing and applying proof technology" is wildly interesting to me.</p>



<a name="187102304"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/187102304" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/POPLmark.20challenge.html#187102304">(Jan 31 2020 at 17:06)</a>:</h4>
<p>The next sentence from the ForMath project summary after the paragraph you quoted is "The main milestones of this work will concern formally proved algorithms for solving problems in real arithmetics and in algebraic topology." I haven't looked at the project myself, but it sounds like the goal is to produce verified algorithms that one would actually run.</p>



<a name="187150482"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/187150482" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tim Carstens <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/POPLmark.20challenge.html#187150482">(Feb 01 2020 at 06:50)</a>:</h4>
<p><span class="user-mention" data-user-id="221921">@Marc Huisinga</span> - I think both approaches have their place overall; they offer different benefits and I’m a big believer in picking the right tech for the project. This is why I like to call out the “big opportunity” that I see in the model approach.</p>
<p>Though that approach requires more work to construct, it supports more diverse technologies. Importantly, this capability is unique to mechanized logic: while there are other programming languages for formal verification (such as Dafny), Lean (and others) stand alone in being able to unite different technologies from different parts of the computing stack. The CompCert project, augmented with Andrew Appel’s Verifiable C, as well as the work SiFive is doing with Kami, are both good examples of this versatility paying off.</p>
<p>I agree, though, that sometimes it’s easiest to just write it in Lean (or Coq). And that’s ok too, as long as I’m not boo’d when I dream about a unified meta-logic for comp sci 🥰</p>



<a name="187150553"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/187150553" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tim Carstens <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/POPLmark.20challenge.html#187150553">(Feb 01 2020 at 06:51)</a>:</h4>
<p>(And indeed, nobody is booing me, which is nice!)</p>



<a name="187150728"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/187150728" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tim Carstens <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/POPLmark.20challenge.html#187150728">(Feb 01 2020 at 06:57)</a>:</h4>
<p>I will say, I do think Lean has made many decisions which are well-suited to programming, in a way that perhaps Coq has not. And I admire Lean’s patient approach to getting it right. Imho, that’s the right way to respond to the state of the art.</p>



<a name="187150768"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/187150768" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tim Carstens <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/POPLmark.20challenge.html#187150768">(Feb 01 2020 at 06:58)</a>:</h4>
<p>There’s a modernity to the tools, language, and design philosophy that I think is a real asset</p>



<a name="187151833"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/187151833" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bas Spitters <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/POPLmark.20challenge.html#187151833">(Feb 01 2020 at 07:35)</a>:</h4>
<p>There's a (hopefully temporary) problem with the MAP homepage, but it can still be found here:<br>
<a href="https://web.archive.org/web/20181228171600/http://map.disi.unige.it/" target="_blank" title="https://web.archive.org/web/20181228171600/http://map.disi.unige.it/">https://web.archive.org/web/20181228171600/http://map.disi.unige.it/</a><br>
We've been having meetings since Dagstuhl 2003.</p>



<a name="187151892"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/187151892" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bas Spitters <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/POPLmark.20challenge.html#187151892">(Feb 01 2020 at 07:37)</a>:</h4>
<p>Here's a concrete concrete project, you may be interested in:<br>
<a href="https://github.com/CoqEAL/CoqEAL" target="_blank" title="https://github.com/CoqEAL/CoqEAL">https://github.com/CoqEAL/CoqEAL</a></p>



<a name="187932033"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/187932033" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bas Spitters <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/POPLmark.20challenge.html#187932033">(Feb 11 2020 at 17:15)</a>:</h4>
<p>The website of the MAP community is mostly working again. It brings together people from computer algebra, formalization in type theory and constructive algebra.<br>
<a href="https://mapcommunity.github.io/index.html" target="_blank" title="https://mapcommunity.github.io/index.html">https://mapcommunity.github.io/index.html</a></p>



<a name="187932375"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/187932375" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/POPLmark.20challenge.html#187932375">(Feb 11 2020 at 17:19)</a>:</h4>
<div class="codehilite"><pre><span></span>Mathematics = Algorithms + Proofs
MAP = Mathematics + Algorithms + Proofs
</pre></div>


<p>So <code>Map = 2 * Mathematics</code>?</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
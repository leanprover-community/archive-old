---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/Why.20is.20type.20assertion.20needed.20here.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Why.20is.20type.20assertion.20needed.20here.html">Why is type assertion needed here</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="265621763"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Why%20is%20type%20assertion%20needed%20here/near/265621763" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bolton Bailey <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Why.20is.20type.20assertion.20needed.20here.html#265621763">(Dec 20 2021 at 22:13)</a>:</h4>
<p>Sorry if this is a beginner question. The following throws a error "invalid field notation", and complains on the fourth line that  <code>ps has type ?m_1</code>. But if I mouse over <code>ps</code> on the third line, it correctly says <code>ps : ℕ × ℕ</code>. </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">bertrand_interval</span> <span class="o">(</span><span class="n">n_low</span> <span class="n">n_high</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">plist</span> <span class="o">:</span> <span class="n">list</span> <span class="n">ℕ</span><span class="o">)</span>
  <span class="o">(</span><span class="n">primeplist</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">p</span> <span class="bp">∈</span> <span class="n">plist</span><span class="o">,</span> <span class="n">prime</span> <span class="n">p</span><span class="o">)</span>
  <span class="o">(</span><span class="n">covering</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">ps</span> <span class="bp">∈</span> <span class="n">list.zip</span> <span class="n">plist</span> <span class="o">(</span><span class="n">list.tail</span> <span class="n">plist</span><span class="o">),</span>
        <span class="o">(</span><span class="n">ps</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span> <span class="bp">≤</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">ps.1</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">plist.head</span> <span class="bp">≤</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">n</span> <span class="bp">≤</span> <span class="n">plist.reverse.head</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">p</span><span class="o">,</span> <span class="n">nat.prime</span> <span class="n">p</span> <span class="bp">∧</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="n">p</span> <span class="bp">∧</span> <span class="n">p</span> <span class="bp">≤</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">n</span><span class="o">)</span>
</code></pre></div>
<p>If I add a type ascription, it's fine:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">bertrand_interval</span> <span class="o">(</span><span class="n">n_low</span> <span class="n">n_high</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">plist</span> <span class="o">:</span> <span class="n">list</span> <span class="n">ℕ</span><span class="o">)</span>
  <span class="o">(</span><span class="n">primeplist</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">p</span> <span class="bp">∈</span> <span class="n">plist</span><span class="o">,</span> <span class="n">prime</span> <span class="n">p</span><span class="o">)</span>
  <span class="o">(</span><span class="n">covering</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">ps</span> <span class="bp">∈</span> <span class="n">list.zip</span> <span class="n">plist</span> <span class="o">(</span><span class="n">list.tail</span> <span class="n">plist</span><span class="o">),</span>
        <span class="o">(</span><span class="n">ps</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">×</span> <span class="n">ℕ</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span> <span class="bp">≤</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">ps.1</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">plist.head</span> <span class="bp">≤</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">n</span> <span class="bp">≤</span> <span class="n">plist.reverse.head</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">p</span><span class="o">,</span> <span class="n">nat.prime</span> <span class="n">p</span> <span class="bp">∧</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="n">p</span> <span class="bp">∧</span> <span class="n">p</span> <span class="bp">≤</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">n</span><span class="o">)</span>
</code></pre></div>
<p>Why is this type ascription necessary?</p>



<a name="265622301"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Why%20is%20type%20assertion%20needed%20here/near/265622301" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bolton Bailey <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Why.20is.20type.20assertion.20needed.20here.html#265622301">(Dec 20 2021 at 22:15)</a>:</h4>
<p>I guess I understand that there might in theory be multiple types that can implement has_mem of a list of ℕ × ℕ, even if in practice only ℕ × ℕ does. But then how does the mouseover know the type!?</p>



<a name="265623715"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Why%20is%20type%20assertion%20needed%20here/near/265623715" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Why.20is.20type.20assertion.20needed.20here.html#265623715">(Dec 20 2021 at 22:32)</a>:</h4>
<p>Yes that's exactly it -- <code>has_mem</code> only knows that <code>ps</code> has type <code>?m_1 : Type</code> and the unifier isn't going to tell it any more information.</p>



<a name="265627104"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Why%20is%20type%20assertion%20needed%20here/near/265627104" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bolton Bailey <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Why.20is.20type.20assertion.20needed.20here.html#265627104">(Dec 20 2021 at 23:11)</a>:</h4>
<p>But then the mouseover thing is almost magical. How can it possibly know the type <code>ℕ × ℕ</code> when that's possibly not even the correct type?</p>



<a name="265627376"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Why%20is%20type%20assertion%20needed%20here/near/265627376" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bolton Bailey <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Why.20is.20type.20assertion.20needed.20here.html#265627376">(Dec 20 2021 at 23:15)</a>:</h4>
<p>Is it indeed possible to implement two <code>has_mem</code> instances with the same second type argument? Does that happen anywhere in mathlib?</p>



<a name="265628685"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Why%20is%20type%20assertion%20needed%20here/near/265628685" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Why.20is.20type.20assertion.20needed.20here.html#265628685">(Dec 20 2021 at 23:32)</a>:</h4>
<p>It is possible to do (in the sense that lean won't stop you), but it's about as good an idea as defining a second instance of <code>semiring nat</code></p>



<a name="265628791"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Why%20is%20type%20assertion%20needed%20here/near/265628791" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Why.20is.20type.20assertion.20needed.20here.html#265628791">(Dec 20 2021 at 23:34)</a>:</h4>
<p>What's happening is that field notation has to be resolved relatively early in the elaboration process, such that it essentially can't see any text that comes after the field projection, but the error doesn't actually stop elaboration, and the hover reports type information coming from later in the term</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/Proving.20equality.20of.20sigma.20types.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proving.20equality.20of.20sigma.20types.html">Proving equality of sigma types</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="320013073"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proving%20equality%20of%20sigma%20types/near/320013073" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sabrina Jewson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proving.20equality.20of.20sigma.20types.html#320013073">(Jan 07 2023 at 22:46)</a>:</h4>
<p>Hi, so I’m still trying to implement <code>finmap β ≃ Σ (keys : finset α), (Π (key ∈ keys), β key)</code>, and I’ve made some progress but now I’m completely stuck in heq hell. I need to prove equality of two sigma types to show that pair →  map → pair is an identity (my goal is roughly of the form <code>f (g x) = x</code> where <code>x : sigma β</code>) — the trouble is that nearly every attempt to break apart that equality to prove it results in <code>heq</code> because of the nature of the sigma type. My code so far looks like this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.finmap</span>
<span class="kn">import</span> <span class="n">data.finset.image</span>
<span class="kn">import</span> <span class="n">data.fintype.basic</span>
<span class="kn">import</span> <span class="n">data.list.sigma</span>

<span class="kd">universes</span> <span class="n">u</span> <span class="n">v</span>

<span class="kn">private</span> <span class="kd">lemma</span> <span class="n">option.heq_some_iff_get_heq</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">o</span> <span class="o">:</span> <span class="n">option</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">β</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">o</span> <span class="bp">==</span> <span class="n">some</span> <span class="n">a</span> <span class="bp">↔</span> <span class="bp">∃</span> <span class="n">h</span> <span class="o">:</span> <span class="n">o.is_some</span><span class="o">,</span> <span class="n">option.get</span> <span class="n">h</span> <span class="bp">==</span> <span class="n">a</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="gr">sorry</span>
<span class="kd">end</span>

<span class="kn">private</span> <span class="kd">def</span> <span class="n">list.pmap_eq_self</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span>
  <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">a</span><span class="o">,</span> <span class="n">p</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">prover</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="bp">∈</span> <span class="n">l</span><span class="o">),</span> <span class="n">p</span> <span class="n">a</span><span class="o">}</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="bp">∈</span> <span class="n">l</span><span class="o">),</span> <span class="n">f</span> <span class="n">x</span> <span class="o">(</span><span class="n">prover</span> <span class="n">x</span> <span class="n">H</span><span class="o">)</span> <span class="bp">=</span> <span class="n">x</span><span class="o">)</span>
  <span class="o">:</span> <span class="n">list.pmap</span> <span class="n">f</span> <span class="n">l</span> <span class="n">prover</span> <span class="bp">=</span> <span class="n">l</span>
<span class="o">:=</span> <span class="kd">begin</span>
  <span class="n">induction</span> <span class="n">l</span><span class="o">,</span>
  <span class="n">refl</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">list.pmap</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">h</span> <span class="n">l_hd</span> <span class="o">(</span><span class="n">or.inl</span> <span class="n">rfl</span><span class="o">),</span>
  <span class="n">rw</span> <span class="n">l_ih</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="n">H</span><span class="o">,</span> <span class="n">h</span> <span class="n">x</span> <span class="o">(</span><span class="n">or.inr</span> <span class="n">H</span><span class="o">)),</span>
<span class="kd">end</span>

<span class="kn">private</span> <span class="kd">def</span> <span class="n">make_entries</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span>
  <span class="o">(</span><span class="n">keys</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">value</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">key</span> <span class="bp">∈</span> <span class="n">keys</span><span class="o">),</span> <span class="n">β</span> <span class="n">key</span><span class="o">)</span>
  <span class="o">:</span> <span class="n">multiset</span> <span class="o">(</span><span class="n">sigma</span> <span class="n">β</span><span class="o">)</span>
<span class="o">:=</span> <span class="n">keys.val.pmap</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">elem</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">elem_mem</span> <span class="o">:</span> <span class="n">elem</span> <span class="bp">∈</span> <span class="n">keys.val</span><span class="o">),</span> <span class="o">⟨</span><span class="n">elem</span><span class="o">,</span> <span class="n">value</span> <span class="n">elem</span> <span class="n">elem_mem</span><span class="o">⟩)</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">elem</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">id</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">finmap.equiv_finset_fun</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">finmap</span> <span class="n">β</span> <span class="bp">≃</span> <span class="bp">Σ</span> <span class="o">(</span><span class="n">keys</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">),</span> <span class="o">(</span><span class="bp">Π</span> <span class="o">(</span><span class="n">key</span> <span class="bp">∈</span> <span class="n">keys</span><span class="o">),</span> <span class="n">β</span> <span class="n">key</span><span class="o">)</span>
<span class="o">:=</span> <span class="o">{</span>
  <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">map</span><span class="o">,</span> <span class="o">{</span>
    <span class="n">fst</span> <span class="o">:=</span> <span class="n">map.keys</span><span class="o">,</span>
    <span class="n">snd</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">x_mem</span><span class="o">,</span> <span class="n">option.get</span> <span class="o">(</span><span class="n">finmap.lookup_is_some.mpr</span> <span class="n">x_mem</span><span class="o">),</span>
  <span class="o">},</span>
  <span class="n">inv_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">pair</span><span class="o">,</span> <span class="o">{</span>
    <span class="n">entries</span> <span class="o">:=</span> <span class="n">make_entries</span> <span class="n">pair.1</span> <span class="n">pair.2</span><span class="o">,</span>
    <span class="n">nodupkeys</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">quot.ind</span> <span class="n">_</span> <span class="n">_</span>
      <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">keys</span> <span class="o">:</span> <span class="n">multiset</span> <span class="n">α</span><span class="o">),</span>
        <span class="bp">Π</span> <span class="o">(</span><span class="n">keys_nodup</span> <span class="o">:</span> <span class="n">keys.nodup</span><span class="o">)</span> <span class="o">(</span><span class="n">value</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">key</span> <span class="bp">∈</span> <span class="n">keys</span><span class="o">),</span> <span class="n">β</span> <span class="n">key</span><span class="o">),</span>
          <span class="o">(</span><span class="n">make_entries</span> <span class="o">⟨</span><span class="n">keys</span><span class="o">,</span> <span class="n">keys_nodup</span><span class="o">⟩</span> <span class="n">value</span><span class="o">)</span><span class="bp">.</span><span class="n">nodupkeys</span><span class="o">)</span>
      <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">keys</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">keys_nodup</span> <span class="o">:</span> <span class="n">keys.nodup</span><span class="o">)</span> <span class="n">value</span><span class="o">,</span>
        <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">make_entries</span><span class="o">,</span> <span class="n">list.nodupkeys</span><span class="o">,</span> <span class="n">list.keys</span><span class="o">,</span> <span class="n">list.map_pmap</span><span class="o">,</span> <span class="n">keys_nodup</span><span class="o">])</span>
      <span class="n">pair.1.val</span>
      <span class="n">pair.1.nodup</span>
      <span class="n">pair.2</span><span class="o">,</span>
  <span class="o">},</span>
  <span class="c1">-- map → pair → map is an identity (not a pretty proof but I’ll come back to this later)</span>
  <span class="n">left_inv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">map</span><span class="o">,</span> <span class="kd">begin</span>
    <span class="n">cases</span> <span class="n">map</span><span class="o">,</span>
    <span class="n">dsimp</span> <span class="n">only</span> <span class="o">[</span><span class="n">finmap.keys</span><span class="o">],</span>
    <span class="n">apply</span> <span class="n">finmap.ext</span><span class="o">,</span>
    <span class="n">dsimp</span> <span class="n">only</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">make_entries</span><span class="o">,</span>
    <span class="n">dsimp</span> <span class="n">only</span><span class="o">,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">multiset.keys</span><span class="o">],</span>
    <span class="n">induction</span> <span class="n">map_entries</span><span class="o">,</span>
    <span class="n">simp</span><span class="o">,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">list.pmap_map</span><span class="o">],</span>
    <span class="n">convert</span> <span class="bp">←</span> <span class="n">list.perm.refl</span> <span class="n">_</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">list.pmap_eq_self</span><span class="o">,</span>
    <span class="n">intros</span> <span class="n">x</span> <span class="n">x_mem</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">x</span><span class="o">,</span>
    <span class="n">simp</span><span class="o">,</span>
    <span class="n">dsimp</span> <span class="n">at</span> <span class="n">map_nodupkeys</span><span class="o">,</span>
    <span class="n">apply</span> <span class="o">(</span><span class="bp">@</span><span class="n">exists_prop_of_true</span> <span class="n">_</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">option.get</span> <span class="n">h</span> <span class="bp">=</span> <span class="n">x_snd</span><span class="o">)</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">mp</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">option.eq_some_iff_get_eq.mp</span><span class="o">,</span>
    <span class="n">dsimp</span> <span class="n">only</span><span class="o">,</span>
    <span class="n">apply</span> <span class="bp">@</span><span class="n">finmap.induction_on</span> <span class="n">_</span> <span class="n">_</span>
      <span class="o">(</span><span class="bp">λ</span> <span class="n">f</span><span class="o">,</span> <span class="n">sigma.mk</span> <span class="n">x_fst</span> <span class="n">x_snd</span> <span class="bp">∈</span> <span class="n">f.entries</span> <span class="bp">→</span> <span class="n">finmap.lookup</span> <span class="n">x_fst</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">some</span> <span class="n">x_snd</span><span class="o">)</span> <span class="n">_</span>
      <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">alist.mem_lookup_iff.mpr</span><span class="o">),</span>
    <span class="n">exact</span> <span class="n">x_mem</span><span class="o">,</span>
    <span class="n">refl</span><span class="o">,</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="c1">-- pair → map → pair is an identity</span>
  <span class="n">right_inv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">pair</span><span class="o">,</span> <span class="kd">begin</span>
    <span class="n">cases</span> <span class="n">pair</span> <span class="k">with</span> <span class="n">keys</span> <span class="n">val</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">keys</span><span class="o">,</span>
    <span class="n">induction</span> <span class="n">keys_val</span><span class="o">,</span>

    <span class="c1">-- STRATEGY 1: Don’t break the sigma</span>
    <span class="n">dsimp</span> <span class="n">only</span><span class="o">,</span>
    <span class="n">dsimp</span> <span class="n">only</span> <span class="o">[</span><span class="n">make_entries</span><span class="o">],</span>
    <span class="n">dsimp</span> <span class="n">only</span> <span class="o">[</span><span class="n">multiset.quot_mk_to_coe''</span><span class="o">],</span>
    <span class="n">dsimp</span> <span class="n">only</span> <span class="o">[</span><span class="n">multiset.coe_pmap</span><span class="o">],</span>
    <span class="n">dsimp</span> <span class="n">only</span> <span class="o">[</span><span class="n">finmap.keys</span><span class="o">],</span>
    <span class="n">dsimp</span> <span class="n">only</span> <span class="o">[</span><span class="n">multiset.coe_keys</span><span class="o">],</span>
    <span class="n">dsimp</span> <span class="n">only</span> <span class="o">[</span><span class="n">list.keys</span><span class="o">],</span>
    <span class="k">have</span> <span class="n">h</span> <span class="o">:</span>
      <span class="n">list.map</span> <span class="n">sigma.fst</span> <span class="o">(</span><span class="n">list.pmap</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">elem</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">elem_mem</span> <span class="o">:</span> <span class="n">elem</span> <span class="bp">∈</span> <span class="bp">↑</span><span class="n">keys_val</span><span class="o">),</span> <span class="o">⟨</span> <span class="n">elem</span><span class="o">,</span> <span class="n">val</span> <span class="n">elem</span> <span class="n">elem_mem</span> <span class="o">⟩)</span> <span class="n">keys_val</span> <span class="n">_</span><span class="o">)</span>
      <span class="bp">=</span> <span class="n">list.pmap</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">elem</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">elem_mem</span> <span class="o">:</span> <span class="n">elem</span> <span class="bp">∈</span> <span class="bp">↑</span><span class="n">keys_val</span><span class="o">),</span> <span class="n">sigma.fst</span> <span class="o">⟨</span> <span class="n">elem</span><span class="o">,</span> <span class="n">val</span> <span class="n">elem</span> <span class="n">elem_mem</span> <span class="o">⟩)</span> <span class="n">keys_val</span> <span class="n">_</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">apply</span> <span class="n">list.map_pmap</span> <span class="o">},</span>
    <span class="n">dsimp</span> <span class="n">only</span> <span class="o">[</span><span class="n">h</span><span class="o">],</span>
    <span class="c1">-- ^ errors, for some reason; `rw` and `simp` also fail, hence all the dsimps</span>

    <span class="c1">-- STRATEGY 2: Break the sigma</span>
    <span class="n">fapply</span> <span class="n">sigma.eq</span><span class="o">,</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">finmap.keys</span><span class="o">,</span> <span class="n">make_entries</span><span class="o">,</span> <span class="n">multiset.keys</span><span class="o">,</span> <span class="n">list.map_pmap</span><span class="o">,</span> <span class="n">list.map_id''</span><span class="o">],</span>
    <span class="c1">-- What now? How do I prove a goal of the form `_.rec_on (…) = …`?</span>

    <span class="c1">-- STRATEGY 3: Embrace the heq</span>
    <span class="n">simp</span><span class="o">,</span>
    <span class="n">constructor</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">finmap.keys</span><span class="o">,</span> <span class="n">make_entries</span><span class="o">,</span> <span class="n">multiset.keys</span><span class="o">,</span> <span class="n">list.map_pmap</span><span class="o">,</span> <span class="n">list.map_id''</span><span class="o">],</span> <span class="o">},</span>
    <span class="n">dsimp</span> <span class="n">only</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">function.hfunext</span><span class="o">,</span> <span class="n">refl</span><span class="o">,</span> <span class="n">intros</span> <span class="n">a</span> <span class="n">b</span> <span class="n">a_heq_b</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">a_eq_b</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span><span class="o">,</span> <span class="k">from</span> <span class="n">eq_of_heq</span> <span class="n">a_heq_b</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">function.hfunext</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">finmap.keys</span><span class="o">,</span> <span class="n">make_entries</span><span class="o">,</span> <span class="n">multiset.keys</span><span class="o">,</span> <span class="n">a_eq_b</span><span class="o">],</span> <span class="o">},</span>
    <span class="n">intros</span> <span class="n">a_mem</span> <span class="n">b_mem</span> <span class="n">a_mem_eq_b_mem</span><span class="o">,</span>
    <span class="n">apply</span> <span class="o">(</span><span class="bp">@</span><span class="n">exists_prop_of_true</span> <span class="n">_</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">option.get</span> <span class="n">h</span> <span class="bp">==</span> <span class="n">val</span> <span class="n">b</span> <span class="n">b_mem</span><span class="o">)</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">mp</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">option.heq_some_iff_get_heq.mp</span><span class="o">,</span>
    <span class="n">dsimp</span> <span class="n">only</span> <span class="o">[</span><span class="n">make_entries</span><span class="o">,</span> <span class="n">multiset.quot_mk_to_coe''</span><span class="o">,</span> <span class="n">multiset.coe_pmap</span><span class="o">],</span>
    <span class="c1">-- What now? I have no ideä how to simplify or prove this goal because it uses `heq`…</span>
  <span class="kd">end</span><span class="o">,</span>
<span class="o">}</span>
</code></pre></div>
<p>You can see the three different strategies I’ve tried, but with each one I encountered a dead end somehow. Any ideäs on this?</p>



<a name="320013932"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proving%20equality%20of%20sigma%20types/near/320013932" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proving.20equality.20of.20sigma.20types.html#320013932">(Jan 07 2023 at 22:59)</a>:</h4>
<p>Do you mean "equality of 2 elements of a sigma type"? Because equality of types is something different.</p>



<a name="320024349"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proving%20equality%20of%20sigma%20types/near/320024349" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proving.20equality.20of.20sigma.20types.html#320024349">(Jan 08 2023 at 01:28)</a>:</h4>
<p>Here is a complete proof with some auxiliary lemmas that should go to other files. The main trick I used was to use a subtype of a product type as an intermediate type. Probably, one can golf the last equivalence using existing equiv.*_congr constructions.</p>
<div class="spoiler-block"><div class="spoiler-header">
<p>Code</p>
</div><div class="spoiler-content" aria-hidden="true">
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.finmap</span>
<span class="kn">import</span> <span class="n">data.finset.sigma</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>

<span class="kn">namespace</span> <span class="n">multiset</span>

<span class="kd">instance</span> <span class="n">can_lift_finset</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="n">can_lift</span> <span class="o">(</span><span class="n">multiset</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">finset</span> <span class="n">α</span><span class="o">)</span> <span class="n">finset.val</span> <span class="n">multiset.nodup</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="bp">λ</span> <span class="n">m</span> <span class="n">hm</span><span class="o">,</span> <span class="o">⟨⟨</span><span class="n">m</span><span class="o">,</span> <span class="n">hm</span><span class="o">⟩,</span> <span class="n">rfl</span><span class="o">⟩⟩</span>

<span class="kd">lemma</span> <span class="n">nodup_keys</span> <span class="o">{</span><span class="n">m</span> <span class="o">:</span> <span class="n">multiset</span> <span class="o">(</span><span class="bp">Σ</span> <span class="n">i</span><span class="o">,</span> <span class="n">α</span> <span class="n">i</span><span class="o">)}</span> <span class="o">:</span> <span class="n">m.keys.nodup</span> <span class="bp">↔</span> <span class="n">m.nodupkeys</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">rcases</span> <span class="n">m</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">l</span><span class="o">⟩,</span> <span class="n">refl</span> <span class="o">}</span>

<span class="kd">lemma</span> <span class="n">nodupkeys.nodup</span> <span class="o">{</span><span class="n">m</span> <span class="o">:</span> <span class="n">multiset</span> <span class="o">(</span><span class="bp">Σ</span> <span class="n">i</span><span class="o">,</span> <span class="n">α</span> <span class="n">i</span><span class="o">)}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">m.nodupkeys</span><span class="o">)</span> <span class="o">:</span> <span class="n">m.nodup</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">nodup_keys.2</span> <span class="n">h</span><span class="o">)</span><span class="bp">.</span><span class="n">of_map</span> <span class="n">_</span>

<span class="kd">end</span> <span class="n">multiset</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">part.to_option_is_some</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">o</span> <span class="o">:</span> <span class="n">part</span> <span class="n">α</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable</span> <span class="n">o.dom</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">o.to_option.is_some</span> <span class="bp">↔</span> <span class="n">o.dom</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">by_cases</span> <span class="n">o.dom</span><span class="bp">;</span> <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">,</span> <span class="n">part.to_option</span><span class="o">]</span>

<span class="kn">namespace</span> <span class="n">option</span>

<span class="kd">lemma</span> <span class="n">get_eq_iff</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">o</span> <span class="o">:</span> <span class="n">option</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">o.is_some</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">get</span> <span class="n">h</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">↔</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">o</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">rcases</span> <span class="n">is_some_iff_exists.1</span> <span class="n">h</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">b</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span> <span class="n">rw</span> <span class="o">[</span><span class="n">mem_def</span><span class="o">,</span> <span class="n">get_some</span><span class="o">,</span> <span class="n">some_inj</span><span class="o">]</span> <span class="o">}</span>

<span class="kd">end</span> <span class="n">option</span>

<span class="kn">namespace</span> <span class="n">finmap</span>

<span class="kd">lemma</span> <span class="n">lookup_eq_some_iff</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">ι</span><span class="o">]</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">finmap</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">i</span> <span class="o">:</span> <span class="n">ι</span><span class="o">}</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span> <span class="n">i</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">f.lookup</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">some</span> <span class="n">x</span> <span class="bp">↔</span> <span class="n">sigma.mk</span> <span class="n">i</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">f.entries</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">rcases</span> <span class="n">f</span> <span class="k">with</span> <span class="o">⟨⟨</span><span class="n">l</span><span class="o">⟩,</span> <span class="n">hl</span><span class="o">⟩,</span> <span class="n">exact</span> <span class="n">list.mem_lookup_iff</span> <span class="n">hl</span> <span class="o">}</span>

<span class="kn">protected</span> <span class="kd">lemma</span> <span class="n">nodup</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">finmap</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">f.entries.nodup</span> <span class="o">:=</span> <span class="n">f.nodupkeys.nodup</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">sigma_keys_lookup</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">ι</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">finmap</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">f.keys.sigma</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="o">(</span><span class="n">f.lookup</span> <span class="n">i</span><span class="o">)</span><span class="bp">.</span><span class="n">to_finset</span><span class="o">)</span> <span class="bp">=</span> <span class="o">⟨</span><span class="n">f.entries</span><span class="o">,</span> <span class="n">f.nodup</span><span class="o">⟩</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">ext</span> <span class="n">x</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">f.entries</span> <span class="bp">→</span> <span class="n">x.fst</span> <span class="bp">∈</span> <span class="n">f.keys</span><span class="o">,</span> <span class="k">from</span> <span class="n">multiset.mem_map_of_mem</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">simpa</span> <span class="o">[</span><span class="n">lookup_eq_some_iff</span><span class="o">]</span>
<span class="kd">end</span>

<span class="kd">variables</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">ι</span><span class="o">]</span>

<span class="kd">def</span> <span class="n">keys_lookup_equiv</span> <span class="o">:</span>
  <span class="n">finmap</span> <span class="n">α</span> <span class="bp">≃</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">ι</span> <span class="bp">×</span> <span class="o">(</span><span class="bp">Π</span> <span class="n">i</span><span class="o">,</span> <span class="n">option</span> <span class="o">(</span><span class="n">α</span> <span class="n">i</span><span class="o">))</span> <span class="bp">//</span> <span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="o">(</span><span class="n">f.2</span> <span class="n">i</span><span class="o">)</span><span class="bp">.</span><span class="n">is_some</span> <span class="bp">↔</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">f.1</span><span class="o">}</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">f</span><span class="o">,</span> <span class="o">⟨(</span><span class="n">f.keys</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">f.lookup</span> <span class="n">i</span><span class="o">),</span> <span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">lookup_is_some</span><span class="o">⟩,</span>
  <span class="n">inv_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">f</span><span class="o">,</span> <span class="o">⟨(</span><span class="n">f.1.1.sigma</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="o">(</span><span class="n">f.1.2</span> <span class="n">i</span><span class="o">)</span><span class="bp">.</span><span class="n">to_finset</span><span class="o">)</span><span class="bp">.</span><span class="n">val</span><span class="o">,</span>
    <span class="kd">begin</span>
      <span class="n">refine</span> <span class="n">multiset.nodup_keys.1</span> <span class="o">((</span><span class="n">finset.nodup</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">map_on</span> <span class="n">_</span><span class="o">),</span>
      <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">finset.mem_val</span><span class="o">,</span> <span class="n">finset.mem_sigma</span><span class="o">,</span> <span class="n">option.mem_to_finset</span><span class="o">,</span> <span class="n">option.mem_def</span><span class="o">],</span>
      <span class="n">rintro</span> <span class="o">⟨</span><span class="n">i</span><span class="o">,</span> <span class="n">x</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">hi</span><span class="o">,</span> <span class="n">hx</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">j</span><span class="o">,</span> <span class="n">y</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">hj</span><span class="o">,</span> <span class="n">hy</span><span class="o">⟩</span> <span class="o">(</span><span class="n">rfl</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">j</span><span class="o">),</span>
      <span class="n">obtain</span> <span class="n">rfl</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span><span class="o">,</span> <span class="k">from</span> <span class="n">option.some.inj</span> <span class="o">(</span><span class="n">hx.symm.trans</span> <span class="n">hy</span><span class="o">),</span>
      <span class="n">refl</span>
    <span class="kd">end</span><span class="o">⟩,</span>
  <span class="n">left_inv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">f</span><span class="o">,</span> <span class="n">ext</span> <span class="bp">$</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">,</span>
  <span class="n">right_inv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="o">⟨⟨</span><span class="n">s</span><span class="o">,</span> <span class="n">f</span><span class="o">⟩,</span> <span class="n">hf</span><span class="o">⟩,</span>
    <span class="kd">begin</span>
      <span class="n">ext</span> <span class="o">:</span> <span class="mi">2</span><span class="bp">;</span> <span class="n">dsimp</span> <span class="o">[</span><span class="n">keys</span><span class="o">],</span>
      <span class="o">{</span> <span class="n">ext1</span> <span class="n">i</span><span class="o">,</span>
        <span class="k">have</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">s</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">some</span> <span class="n">x</span><span class="o">),</span>
          <span class="k">from</span> <span class="bp">λ</span> <span class="n">hi</span><span class="o">,</span> <span class="o">⟨</span><span class="n">option.get</span> <span class="n">_</span><span class="o">,</span> <span class="n">option.get_mem</span> <span class="bp">$</span> <span class="o">(</span><span class="n">hf</span> <span class="n">i</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span> <span class="n">hi</span><span class="o">⟩,</span>
        <span class="n">simpa</span> <span class="o">[</span><span class="n">multiset.keys</span><span class="o">]</span> <span class="o">},</span>
      <span class="o">{</span> <span class="n">ext</span> <span class="n">i</span> <span class="n">x</span> <span class="o">:</span> <span class="mi">2</span><span class="o">,</span>
        <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">option.mem_def</span><span class="o">,</span> <span class="n">lookup_eq_some_iff</span><span class="o">,</span> <span class="n">finset.mem_val</span><span class="o">,</span> <span class="n">finset.mem_sigma</span><span class="o">,</span>
          <span class="n">option.mem_to_finset</span><span class="o">,</span> <span class="n">and_iff_right_iff_imp</span><span class="o">,</span> <span class="bp">←</span> <span class="n">hf</span><span class="o">],</span>
        <span class="n">exact</span> <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">option.is_some_iff_exists.2</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩</span> <span class="o">}</span>
    <span class="kd">end</span> <span class="o">}</span>

<span class="kd">def</span> <span class="n">finmap_equiv_sigma</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">ι</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">finmap</span> <span class="n">α</span> <span class="bp">≃</span> <span class="bp">Σ</span> <span class="n">keys</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">ι</span><span class="o">,</span> <span class="bp">Π</span> <span class="n">k</span> <span class="bp">∈</span> <span class="n">keys</span><span class="o">,</span> <span class="n">α</span> <span class="n">k</span> <span class="o">:=</span>
<span class="n">keys_lookup_equiv.trans</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">f</span><span class="o">,</span> <span class="o">⟨</span><span class="n">f.1.1</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">i</span> <span class="n">hi</span><span class="o">,</span> <span class="n">option.get</span> <span class="bp">$</span> <span class="o">(</span><span class="n">f.2</span> <span class="n">i</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span> <span class="n">hi</span><span class="o">⟩,</span>
  <span class="n">inv_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">f</span><span class="o">,</span> <span class="o">⟨(</span><span class="n">f.1</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">part.to_option</span> <span class="o">⟨</span><span class="n">i</span> <span class="bp">∈</span> <span class="n">f.1</span><span class="o">,</span> <span class="n">f.2</span> <span class="n">i</span><span class="o">⟩),</span>
    <span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">⟩,</span>
  <span class="n">left_inv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="o">⟨⟨</span><span class="n">s</span><span class="o">,</span> <span class="n">f</span><span class="o">⟩,</span> <span class="n">hf</span><span class="o">⟩,</span>
    <span class="kd">begin</span>
      <span class="n">dsimp</span><span class="o">,</span>
      <span class="n">congr'</span> <span class="k">with</span> <span class="n">i</span> <span class="n">x</span><span class="o">,</span>
      <span class="k">have</span> <span class="o">:</span> <span class="n">f</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">some</span> <span class="n">x</span> <span class="bp">→</span> <span class="o">(</span><span class="n">f</span> <span class="n">i</span><span class="o">)</span><span class="bp">.</span><span class="n">is_some</span><span class="o">,</span> <span class="k">from</span> <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">option.is_some_iff_exists.2</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩,</span>
      <span class="n">simpa</span> <span class="o">[</span><span class="n">option.get_eq_iff</span><span class="o">,</span> <span class="bp">←</span> <span class="n">hf</span><span class="o">]</span>
    <span class="kd">end</span><span class="o">,</span>
  <span class="n">right_inv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="o">⟨</span><span class="n">s</span><span class="o">,</span> <span class="n">f</span><span class="o">⟩,</span>
    <span class="kd">begin</span>
      <span class="n">dsimp</span><span class="o">,</span>
      <span class="n">congr'</span> <span class="k">with</span> <span class="n">i</span> <span class="n">hi</span><span class="o">,</span>
      <span class="n">rw</span> <span class="o">[</span><span class="n">option.get_eq_iff</span><span class="o">,</span> <span class="n">part.mem_to_option</span><span class="o">],</span>
      <span class="n">exact</span> <span class="o">⟨</span><span class="n">hi</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span>
    <span class="kd">end</span> <span class="o">}</span>

<span class="kd">end</span> <span class="n">finmap</span>
</code></pre></div>
</div></div>



<a name="320046331"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proving%20equality%20of%20sigma%20types/near/320046331" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sabrina Jewson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proving.20equality.20of.20sigma.20types.html#320046331">(Jan 08 2023 at 07:46)</a>:</h4>
<p>Thank you very much! I’ll have to spend a while studying that :D</p>



<a name="320047800"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proving%20equality%20of%20sigma%20types/near/320047800" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proving.20equality.20of.20sigma.20types.html#320047800">(Jan 08 2023 at 08:09)</a>:</h4>
<p>It's hard to work with equality of <code>x y : Σ i, α i</code> unless <code>x.1 = y.1</code> is a definitional equality. So, it helps to isolate "actual work" from wrapping in convenient types.</p>



<a name="320047818"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proving%20equality%20of%20sigma%20types/near/320047818" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proving.20equality.20of.20sigma.20types.html#320047818">(Jan 08 2023 at 08:09)</a>:</h4>
<p>BTW, I don't know which of the equivalences is more useful in practice.</p>



<a name="320048238"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proving%20equality%20of%20sigma%20types/near/320048238" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proving.20equality.20of.20sigma.20types.html#320048238">(Jan 08 2023 at 08:17)</a>:</h4>
<p>The trick to work with sigma types is to make <code>x.1 = y.1</code> an equality of at least one free variable, then <code>subst</code> it. Then <code>x.2 == y.2</code> becomes <code>x.2 = y.2</code>.</p>



<a name="321028654"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proving%20equality%20of%20sigma%20types/near/321028654" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proving.20equality.20of.20sigma.20types.html#321028654">(Jan 12 2023 at 20:31)</a>:</h4>
<p>PRd non-sigma version: <a href="https://github.com/leanprover-community/mathlib/pull/18151">#18151</a>. I'm not sure that we need the sigma version in <code>mathlib</code> because the math content is there but it's easier to deal with a subtype of a product than with a sigma type.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
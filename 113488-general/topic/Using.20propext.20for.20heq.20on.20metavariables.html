---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/Using.20propext.20for.20heq.20on.20metavariables.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Using.20propext.20for.20heq.20on.20metavariables.html">Using propext for heq on metavariables</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="198493009"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Using%20propext%20for%20heq%20on%20metavariables/near/198493009" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Izzy Meckler <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Using.20propext.20for.20heq.20on.20metavariables.html#198493009">(May 22 2020 at 20:46)</a>:</h4>
<p>I am in the following proof state in lean (as part of proving a group decomposes into cosets)</p>
<div class="codehilite"><pre><span></span><code><span class="n">G</span> <span class="o">:</span> <span class="n">Group</span><span class="o">,</span>
<span class="n">H</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">G</span><span class="o">,</span>
<span class="n">X</span> <span class="o">:</span> <span class="n">coset</span> <span class="n">H</span><span class="o">,</span>
<span class="n">x</span> <span class="o">:</span> <span class="err">↥</span><span class="n">G</span><span class="o">,</span>
<span class="n">x_in_X</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">X</span><span class="bp">.</span><span class="n">val</span>
<span class="err">⊢</span> <span class="bp">⟨</span><span class="n">x</span><span class="o">,</span> <span class="bp">_⟩</span> <span class="bp">==</span> <span class="bp">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">x_in_X</span><span class="bp">⟩</span>
</code></pre></div>


<p>and this should be true by the fact that membership is a Prop, but I can't figure out how to get that to work. i wrote a lemme analogous to subtype.eq for heterogeneous equality but it didn't unify when i applied it:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">lemma</span> <span class="n">subtype_triviality</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span>
    <span class="o">{</span> <span class="n">P</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">→</span> <span class="kt">Prop</span> <span class="o">}</span>
    <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">A</span><span class="o">}</span>
    <span class="o">{</span><span class="n">w1</span> <span class="n">w2</span> <span class="o">:</span> <span class="n">P</span> <span class="n">x</span><span class="o">}</span>
    <span class="o">:</span> <span class="bp">@</span><span class="n">heq</span> <span class="o">{</span> <span class="n">a</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">//</span> <span class="n">P</span> <span class="n">a</span> <span class="o">}</span> <span class="bp">⟨</span> <span class="n">x</span><span class="o">,</span> <span class="n">w1</span> <span class="bp">⟩</span> <span class="o">{</span> <span class="n">a</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">//</span> <span class="n">P</span> <span class="n">a</span> <span class="o">}</span> <span class="bp">⟨</span> <span class="n">x</span><span class="o">,</span> <span class="n">w2</span> <span class="bp">⟩</span>
    <span class="o">:=</span> <span class="bp">...</span>
</code></pre></div>


<p><code>apply</code>ing this gives the error</p>
<div class="codehilite"><pre><span></span><code><span class="n">invalid</span> <span class="n">apply</span> <span class="n">tactic</span><span class="o">,</span> <span class="n">failed</span> <span class="n">to</span> <span class="n">unify</span>
  <span class="bp">⟨</span><span class="n">x</span><span class="o">,</span> <span class="bp">_⟩</span> <span class="bp">==</span> <span class="bp">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">x_in_X</span><span class="bp">⟩</span>
<span class="k">with</span>
  <span class="bp">⟨</span><span class="err">?</span><span class="n">m_3</span><span class="o">,</span> <span class="err">?</span><span class="n">m_4</span><span class="bp">⟩</span> <span class="bp">==</span> <span class="bp">⟨</span><span class="err">?</span><span class="n">m_3</span><span class="o">,</span> <span class="err">?</span><span class="n">m_5</span><span class="bp">⟩</span>
</code></pre></div>



<a name="198493065"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Using%20propext%20for%20heq%20on%20metavariables/near/198493065" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Using.20propext.20for.20heq.20on.20metavariables.html#198493065">(May 22 2020 at 20:47)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mwe.html">#mwe</a></p>



<a name="198493114"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Using%20propext%20for%20heq%20on%20metavariables/near/198493114" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Using.20propext.20for.20heq.20on.20metavariables.html#198493114">(May 22 2020 at 20:47)</a>:</h4>
<p>Try using <code>congr</code> (or <code>hcongr</code>?) on your goal, maybe</p>



<a name="198493193"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Using%20propext%20for%20heq%20on%20metavariables/near/198493193" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Izzy Meckler <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Using.20propext.20for.20heq.20on.20metavariables.html#198493193">(May 22 2020 at 20:48)</a>:</h4>
<p><span class="user-mention silent" data-user-id="123965">Bryan Gin-ge Chen</span> <a href="#narrow/stream/113488-general/topic/Using.20propext.20for.20heq.20on.20metavariables/near/198493065">said</a>:</p>
<blockquote>
<p><a href="https://leanprover-community.github.io/mwe.html">#mwe</a></p>
</blockquote>
<p>the development is a few hundred lines... should i just post it here?</p>



<a name="198493321"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Using%20propext%20for%20heq%20on%20metavariables/near/198493321" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Using.20propext.20for.20heq.20on.20metavariables.html#198493321">(May 22 2020 at 20:49)</a>:</h4>
<p>At a guess, you have two different <code>subtype</code>s</p>



<a name="198493531"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Using%20propext%20for%20heq%20on%20metavariables/near/198493531" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Using.20propext.20for.20heq.20on.20metavariables.html#198493531">(May 22 2020 at 20:51)</a>:</h4>
<p>You should minimize the code so that the same issue appears. I doubt that every single one of those lines is necessary to reproduce this.</p>



<a name="198493619"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Using%20propext%20for%20heq%20on%20metavariables/near/198493619" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Using.20propext.20for.20heq.20on.20metavariables.html#198493619">(May 22 2020 at 20:52)</a>:</h4>
<p>Also, it seems likely that you should not have done whatever caused <code>==</code> to appear</p>



<a name="198493893"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Using%20propext%20for%20heq%20on%20metavariables/near/198493893" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Izzy Meckler <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Using.20propext.20for.20heq.20on.20metavariables.html#198493893">(May 22 2020 at 20:55)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/113488-general/topic/Using.20propext.20for.20heq.20on.20metavariables/near/198493619">said</a>:</p>
<blockquote>
<p>Also, it seems likely that you should not have done whatever caused <code>==</code> to appear</p>
</blockquote>
<p>it appeared as a result of <code>simp</code>ing an equality in a sigma type... in any case, is it not possible to just give a name to the underscore variable and then just use propext to finish this off?</p>



<a name="198494187"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Using%20propext%20for%20heq%20on%20metavariables/near/198494187" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Izzy Meckler <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Using.20propext.20for.20heq.20on.20metavariables.html#198494187">(May 22 2020 at 20:58)</a>:</h4>
<p><span class="user-mention silent" data-user-id="304540">Izzy Meckler</span> <a href="#narrow/stream/113488-general/topic/Using.20propext.20for.20heq.20on.20metavariables/near/198493193">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="123965">Bryan Gin-ge Chen</span> <a href="#narrow/stream/113488-general/topic/Using.20propext.20for.20heq.20on.20metavariables/near/198493065">said</a>:</p>
<blockquote>
<p><a href="https://leanprover-community.github.io/mwe.html">#mwe</a></p>
</blockquote>
<p>the development is a few hundred lines... should i just post it here?</p>
</blockquote>
<p>I am a Lean novice, so my apologies if there is stuff that could be done more nicely</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">set</span><span class="bp">.</span><span class="n">basic</span>
<span class="kn">import</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">category</span><span class="bp">.</span><span class="n">Group</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">subtype</span>
<span class="kn">import</span> <span class="n">category_theory</span><span class="bp">.</span><span class="n">isomorphism</span>
<span class="kn">open</span> <span class="n">set</span>

<span class="n">def</span> <span class="n">subgroup</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">Group</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">H</span> <span class="o">:</span> <span class="n">set</span> <span class="n">G</span> <span class="bp">//</span> <span class="n">is_subgroup</span> <span class="n">H</span> <span class="o">}</span>

<span class="n">def</span> <span class="n">shift</span> <span class="o">{</span> <span class="n">G</span> <span class="o">:</span> <span class="n">Group</span> <span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">set</span> <span class="n">G</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="n">G</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">g</span> <span class="bp">|</span> <span class="n">H</span> <span class="o">(</span><span class="n">x</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="n">g</span><span class="o">)</span> <span class="o">}</span>

<span class="n">def</span> <span class="n">is_coset_of</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="n">Group</span><span class="o">}</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">G</span><span class="o">)</span> <span class="o">(</span><span class="n">K</span> <span class="o">:</span> <span class="n">set</span> <span class="n">G</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
    <span class="n">exists</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">G</span><span class="o">),</span> <span class="n">K</span> <span class="bp">=</span> <span class="n">shift</span> <span class="n">x</span> <span class="n">H</span><span class="bp">.</span><span class="n">val</span>

<span class="n">def</span> <span class="n">coset</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="n">Group</span><span class="o">}</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">G</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">K</span> <span class="o">:</span> <span class="n">set</span> <span class="n">G</span> <span class="bp">//</span> <span class="n">is_coset_of</span> <span class="n">H</span> <span class="n">K</span> <span class="o">}</span>

<span class="n">def</span> <span class="n">shift_coset</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="n">Group</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">G</span><span class="o">)</span> <span class="o">:</span> <span class="n">coset</span> <span class="n">H</span> <span class="o">:=</span>
    <span class="bp">⟨</span> <span class="n">shift</span> <span class="n">x</span> <span class="n">H</span><span class="bp">.</span><span class="n">val</span> <span class="o">,</span> <span class="n">exists</span><span class="bp">.</span><span class="n">intro</span> <span class="n">x</span> <span class="k">begin</span> <span class="n">trivial</span> <span class="kn">end</span> <span class="bp">⟩</span>

<span class="n">def</span> <span class="n">subgroup_property&#39;</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="n">Group</span><span class="o">}</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">G</span><span class="o">)</span>
    <span class="o">:</span> <span class="k">forall</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">H</span><span class="bp">.</span><span class="n">val</span> <span class="bp">→</span> <span class="o">((</span><span class="n">y</span> <span class="err">∈</span> <span class="n">H</span><span class="bp">.</span><span class="n">val</span><span class="o">)</span> <span class="bp">↔</span> <span class="o">((</span><span class="n">x</span><span class="bp">*</span><span class="n">y</span><span class="o">)</span> <span class="err">∈</span> <span class="n">H</span><span class="bp">.</span><span class="n">val</span><span class="o">))</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">intros</span><span class="o">,</span>
<span class="n">induction</span> <span class="n">H</span><span class="o">,</span>
<span class="n">apply</span> <span class="n">iff</span><span class="bp">.</span><span class="n">intro</span><span class="o">,</span>
<span class="n">apply</span> <span class="n">H_property</span><span class="bp">.</span><span class="n">mul_mem</span><span class="o">,</span>
<span class="n">apply</span> <span class="n">a</span><span class="o">,</span>
<span class="n">intros</span><span class="o">,</span>
<span class="k">have</span> <span class="n">h</span> <span class="o">:</span> <span class="n">x</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span> <span class="err">∈</span> <span class="n">H_val</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">H_property</span><span class="bp">.</span><span class="n">mul_mem</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">H_property</span><span class="bp">.</span><span class="n">inv_mem</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">a</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">a_1</span><span class="o">,</span>
<span class="k">have</span> <span class="n">e</span> <span class="o">:</span> <span class="n">x</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">y</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">inv_mul_cancel_left</span><span class="o">,</span>
    <span class="n">rewrite</span> <span class="bp">&lt;-</span> <span class="n">e</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">h</span><span class="o">,</span>
<span class="kn">end</span>

<span class="n">def</span> <span class="n">subgroup_property</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="n">Group</span><span class="o">}</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">G</span><span class="o">)</span>
    <span class="o">:</span> <span class="k">forall</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">H</span><span class="bp">.</span><span class="n">val</span> <span class="bp">→</span> <span class="o">((</span><span class="n">y</span> <span class="err">∈</span> <span class="n">H</span><span class="bp">.</span><span class="n">val</span><span class="o">)</span> <span class="bp">=</span> <span class="o">((</span><span class="n">x</span><span class="bp">*</span><span class="n">y</span><span class="o">)</span> <span class="err">∈</span> <span class="n">H</span><span class="bp">.</span><span class="n">val</span><span class="o">))</span> <span class="o">:=</span>
    <span class="k">begin</span>
    <span class="n">intros</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">propext</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">subgroup_property&#39;</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">a</span><span class="o">,</span>
<span class="kn">end</span>

<span class="kn">lemma</span> <span class="n">mul_subgroup_property</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="n">Group</span><span class="o">}</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">G</span><span class="o">)</span>
    <span class="o">:</span> <span class="k">forall</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">H</span><span class="bp">.</span><span class="n">val</span> <span class="n">x</span> <span class="bp">→</span> <span class="o">(</span><span class="n">H</span><span class="bp">.</span><span class="n">val</span> <span class="n">y</span> <span class="bp">↔</span> <span class="n">H</span><span class="bp">.</span><span class="n">val</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">))</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">intros</span><span class="o">,</span>
<span class="k">have</span> <span class="n">h0</span> <span class="o">:</span> <span class="o">(</span><span class="n">x</span> <span class="err">∈</span> <span class="n">H</span><span class="bp">.</span><span class="n">val</span> <span class="bp">↔</span> <span class="n">H</span><span class="bp">.</span><span class="n">val</span> <span class="n">x</span><span class="o">),</span> <span class="n">apply</span> <span class="n">mem_def</span><span class="o">,</span>
<span class="n">rewrite</span> <span class="bp">&lt;-</span> <span class="n">h0</span> <span class="n">at</span> <span class="n">a</span><span class="o">,</span>
<span class="n">apply</span> <span class="n">iff</span><span class="bp">.</span><span class="n">intro</span><span class="o">,</span>
<span class="n">intros</span><span class="o">,</span>
<span class="k">have</span> <span class="n">h1</span> <span class="o">:</span> <span class="o">(</span><span class="n">y</span> <span class="err">∈</span> <span class="n">H</span><span class="bp">.</span><span class="n">val</span> <span class="bp">↔</span> <span class="n">H</span><span class="bp">.</span><span class="n">val</span> <span class="n">y</span><span class="o">),</span> <span class="n">apply</span> <span class="n">mem_def</span><span class="o">,</span>
<span class="n">rewrite</span> <span class="bp">&lt;-</span> <span class="n">h1</span> <span class="n">at</span> <span class="n">a_1</span><span class="o">,</span>
<span class="n">apply</span> <span class="n">H</span><span class="bp">.</span><span class="n">property</span><span class="bp">.</span><span class="n">mul_mem</span><span class="o">,</span>
<span class="n">apply</span> <span class="n">a</span><span class="o">,</span> <span class="n">apply</span> <span class="n">a_1</span><span class="o">,</span>

<span class="n">intros</span><span class="o">,</span>
<span class="k">have</span> <span class="n">ai</span> <span class="o">:</span> <span class="n">x</span><span class="bp">⁻¹</span> <span class="err">∈</span> <span class="n">H</span><span class="bp">.</span><span class="n">val</span><span class="o">,</span>
<span class="n">apply</span> <span class="n">H</span><span class="bp">.</span><span class="n">property</span><span class="bp">.</span><span class="n">inv_mem</span><span class="o">,</span> <span class="n">apply</span> <span class="n">a</span><span class="o">,</span>
<span class="n">rewrite</span> <span class="bp">&lt;-</span> <span class="n">inv_mul_cancel_left</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span>
<span class="k">have</span> <span class="n">m</span> <span class="o">:</span> <span class="n">x</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span> <span class="err">∈</span> <span class="n">H</span><span class="bp">.</span><span class="n">val</span><span class="o">,</span>
<span class="n">apply</span> <span class="n">H</span><span class="bp">.</span><span class="n">property</span><span class="bp">.</span><span class="n">mul_mem</span><span class="o">,</span> <span class="n">apply</span> <span class="n">ai</span><span class="o">,</span>
<span class="n">rewrite</span> <span class="n">mem_def</span><span class="o">,</span> <span class="n">apply</span> <span class="n">a_1</span><span class="o">,</span>
<span class="n">rewrite</span> <span class="n">mem_def</span> <span class="n">at</span> <span class="n">m</span><span class="o">,</span>
<span class="n">apply</span> <span class="n">m</span><span class="o">,</span>
<span class="kn">end</span>

<span class="kn">lemma</span> <span class="n">inv_subgroup_property</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="n">Group</span><span class="o">}</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">G</span><span class="o">)</span>
    <span class="o">:</span> <span class="k">forall</span> <span class="n">x</span><span class="o">,</span> <span class="n">H</span><span class="bp">.</span><span class="n">val</span> <span class="n">x</span> <span class="bp">↔</span> <span class="n">H</span><span class="bp">.</span><span class="n">val</span> <span class="o">(</span><span class="n">x</span><span class="bp">⁻¹</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">intros</span><span class="o">,</span>
<span class="k">have</span> <span class="n">h</span> <span class="o">:</span> <span class="o">(</span><span class="n">x</span> <span class="err">∈</span> <span class="n">H</span><span class="bp">.</span><span class="n">val</span> <span class="bp">↔</span> <span class="n">H</span><span class="bp">.</span><span class="n">val</span> <span class="n">x</span><span class="o">),</span>
<span class="n">apply</span> <span class="n">mem_def</span><span class="o">,</span>
<span class="n">rewrite</span> <span class="bp">&lt;-</span> <span class="n">h</span><span class="o">,</span>
<span class="k">have</span> <span class="n">h</span> <span class="o">:</span> <span class="o">(</span><span class="n">x</span><span class="bp">⁻¹</span> <span class="err">∈</span> <span class="n">H</span><span class="bp">.</span><span class="n">val</span> <span class="bp">↔</span> <span class="n">H</span><span class="bp">.</span><span class="n">val</span> <span class="n">x</span><span class="bp">⁻¹</span> <span class="o">),</span>
<span class="n">apply</span> <span class="n">mem_def</span><span class="o">,</span>
<span class="n">rewrite</span> <span class="bp">&lt;-</span> <span class="n">h</span><span class="o">,</span>
<span class="n">apply</span> <span class="n">iff</span><span class="bp">.</span><span class="n">intro</span><span class="o">,</span>
<span class="n">intros</span><span class="o">,</span>
<span class="n">apply</span> <span class="n">H</span><span class="bp">.</span><span class="n">property</span><span class="bp">.</span><span class="n">inv_mem</span><span class="o">,</span> <span class="n">apply</span> <span class="n">a</span><span class="o">,</span>
<span class="n">intros</span><span class="o">,</span>
<span class="k">have</span> <span class="n">e</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span><span class="bp">⁻¹⁻¹</span><span class="o">,</span> <span class="n">rewrite</span> <span class="n">inv_inv</span><span class="o">,</span>
<span class="n">rewrite</span> <span class="n">e</span><span class="o">,</span>
<span class="n">apply</span> <span class="n">H</span><span class="bp">.</span><span class="n">property</span><span class="bp">.</span><span class="n">inv_mem</span><span class="o">,</span>
<span class="n">apply</span> <span class="n">a</span><span class="o">,</span>
<span class="kn">end</span>

<span class="kn">lemma</span> <span class="n">coset_characterization</span>
<span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="n">Group</span><span class="o">}</span> <span class="o">{</span><span class="n">H</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">G</span><span class="o">}</span>
    <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">coset</span> <span class="n">H</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span>
    <span class="o">:</span> <span class="n">g</span> <span class="err">∈</span> <span class="n">X</span><span class="bp">.</span><span class="n">val</span> <span class="bp">→</span>  <span class="n">X</span><span class="bp">.</span><span class="n">val</span> <span class="bp">=</span> <span class="n">shift</span> <span class="n">g</span> <span class="n">H</span><span class="bp">.</span><span class="n">val</span>
    <span class="o">:=</span>
<span class="k">begin</span>
<span class="k">let</span> <span class="n">H_val</span> <span class="o">:=</span> <span class="n">H</span><span class="bp">.</span><span class="n">val</span><span class="o">,</span>
<span class="n">intros</span><span class="o">,</span>
<span class="n">induction</span> <span class="n">X</span><span class="o">,</span>
<span class="n">apply</span> <span class="n">ext</span><span class="o">,</span>
<span class="n">intro</span> <span class="n">y</span><span class="o">,</span>
<span class="n">simp</span><span class="o">,</span>
<span class="n">induction</span> <span class="n">X_property</span><span class="o">,</span>
<span class="n">rename</span> <span class="n">X_property_w</span> <span class="n">x</span><span class="o">,</span>
<span class="n">simp</span> <span class="n">at</span> <span class="n">a</span><span class="o">,</span>
<span class="n">rewrite</span> <span class="n">X_property_h</span> <span class="n">at</span> <span class="n">a</span><span class="o">,</span>
<span class="n">rewrite</span> <span class="n">X_property_h</span><span class="o">,</span>
<span class="n">rewrite</span> <span class="n">mem_def</span><span class="o">,</span> <span class="n">rewrite</span> <span class="n">mem_def</span><span class="o">,</span>
<span class="n">unfold</span> <span class="n">shift</span><span class="o">,</span>
<span class="n">rewrite</span> <span class="n">set_of_app_iff</span><span class="o">,</span>
<span class="n">rewrite</span> <span class="n">set_of_app_iff</span><span class="o">,</span>
<span class="n">unfold</span> <span class="n">shift</span> <span class="n">at</span> <span class="n">a</span><span class="o">,</span>
<span class="k">have</span> <span class="n">h</span> <span class="o">:</span> <span class="o">(</span><span class="n">g</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="n">x</span><span class="o">)</span> <span class="err">∈</span> <span class="n">H</span><span class="bp">.</span><span class="n">val</span><span class="o">,</span> <span class="n">rewrite</span> <span class="n">mem_def</span> <span class="n">at</span> <span class="n">a</span><span class="o">,</span>
<span class="n">rewrite</span> <span class="n">set_of_app_iff</span> <span class="n">at</span> <span class="n">a</span><span class="o">,</span>
<span class="n">rewrite</span> <span class="n">mem_def</span><span class="o">,</span>
<span class="n">rewrite</span> <span class="n">inv_subgroup_property</span><span class="o">,</span>
<span class="n">rewrite</span> <span class="n">mul_inv_rev</span><span class="o">,</span>
<span class="n">rewrite</span> <span class="n">inv_inv</span><span class="o">,</span>
<span class="n">apply</span> <span class="n">a</span><span class="o">,</span>
<span class="k">have</span> <span class="n">i</span> <span class="o">:</span> <span class="n">H</span><span class="bp">.</span><span class="n">val</span> <span class="o">(</span><span class="n">x</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span> <span class="bp">↔</span> <span class="n">H</span><span class="bp">.</span><span class="n">val</span> <span class="o">((</span><span class="n">g</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="n">x</span> <span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">x</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)),</span>
<span class="n">rewrite</span> <span class="n">mul_subgroup_property</span><span class="o">,</span> <span class="n">rewrite</span> <span class="n">mem_def</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span> <span class="n">apply</span> <span class="n">h</span><span class="o">,</span>
<span class="n">rewrite</span> <span class="n">i</span><span class="o">,</span>  <span class="n">rewrite</span> <span class="n">mul_assoc</span><span class="o">,</span>
<span class="n">rewrite</span> <span class="n">mul_inv_cancel_left</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span>
<span class="kn">end</span>

<span class="n">def</span> <span class="n">cosets_disjoint</span> <span class="o">{</span><span class="n">G</span><span class="o">:</span> <span class="n">Group</span><span class="o">}</span> <span class="o">{</span><span class="n">H</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">G</span><span class="o">}</span>
    <span class="o">(</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">coset</span> <span class="n">H</span><span class="o">)</span>
    <span class="o">:</span> <span class="bp">∀</span> <span class="n">g</span><span class="o">,</span> <span class="o">(</span><span class="n">g</span> <span class="err">∈</span> <span class="n">X</span><span class="bp">.</span><span class="n">val</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span><span class="n">g</span> <span class="err">∈</span> <span class="n">Y</span><span class="bp">.</span><span class="n">val</span><span class="o">)</span> <span class="bp">→</span> <span class="n">X</span> <span class="bp">=</span> <span class="n">Y</span> <span class="o">:=</span>
<span class="k">begin</span>
    <span class="n">intros</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">subtype</span><span class="bp">.</span><span class="n">eq&#39;</span><span class="o">,</span>
    <span class="n">induction</span> <span class="n">a</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">eX</span> <span class="o">:</span> <span class="o">(</span><span class="n">X</span><span class="bp">.</span><span class="n">val</span> <span class="bp">=</span> <span class="n">shift</span> <span class="n">g</span> <span class="n">H</span><span class="bp">.</span><span class="n">val</span><span class="o">),</span>
    <span class="n">apply</span> <span class="n">coset_characterization</span><span class="o">,</span> <span class="n">apply</span> <span class="n">a_left</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">eY</span> <span class="o">:</span> <span class="o">(</span><span class="n">Y</span><span class="bp">.</span><span class="n">val</span> <span class="bp">=</span> <span class="n">shift</span> <span class="n">g</span> <span class="n">H</span><span class="bp">.</span><span class="n">val</span><span class="o">),</span>
    <span class="n">apply</span> <span class="n">coset_characterization</span><span class="o">,</span> <span class="n">apply</span> <span class="n">a_right</span><span class="o">,</span>
    <span class="n">rewrite</span> <span class="n">eX</span><span class="o">,</span> <span class="n">rewrite</span> <span class="n">eY</span><span class="o">,</span>
<span class="kn">end</span>

<span class="n">def</span> <span class="n">underlying_type</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">Group</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="n">G</span>

<span class="kn">universe</span> <span class="n">u</span>
<span class="kn">universe</span> <span class="n">v</span>

<span class="n">def</span> <span class="n">mem_def&#39;</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">set</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">a</span><span class="o">)</span>
    <span class="o">:</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">X</span> <span class="bp">↔</span> <span class="n">X</span> <span class="n">x</span> <span class="o">:=</span> <span class="k">begin</span>
    <span class="n">intros</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">mem_def</span>
<span class="kn">end</span>

<span class="kn">lemma</span> <span class="n">g_in_gH</span> <span class="o">{</span><span class="n">G</span><span class="o">:</span> <span class="n">Group</span><span class="o">}</span> <span class="o">{</span><span class="n">H</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">G</span><span class="o">}</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span>
    <span class="o">:</span> <span class="n">g</span> <span class="err">∈</span> <span class="o">(</span><span class="n">shift_coset</span> <span class="n">g</span> <span class="n">H</span><span class="o">)</span><span class="bp">.</span><span class="n">val</span> <span class="o">:=</span>
<span class="k">begin</span>
    <span class="n">intros</span><span class="o">,</span>
    <span class="n">rewrite</span> <span class="n">mem_def</span><span class="o">,</span>
    <span class="n">unfold</span> <span class="n">shift_coset</span><span class="o">,</span>
    <span class="n">simp</span><span class="o">,</span> <span class="n">unfold</span> <span class="n">shift</span><span class="o">,</span>
    <span class="n">rewrite</span> <span class="n">set_of_app_iff</span><span class="o">,</span>
    <span class="n">rewrite</span> <span class="n">inv_mul_self</span><span class="o">,</span>
    <span class="n">rewrite</span> <span class="bp">&lt;-</span> <span class="o">(</span><span class="n">mem_def&#39;</span> <span class="n">H</span><span class="bp">.</span><span class="n">val</span> <span class="mi">1</span><span class="o">),</span>
    <span class="n">apply</span> <span class="n">H</span><span class="bp">.</span><span class="n">property</span><span class="bp">.</span><span class="n">one_mem</span>
<span class="kn">end</span>

<span class="kn">lemma</span> <span class="n">subtype_triviality</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span>
    <span class="o">{</span> <span class="n">P</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">→</span> <span class="kt">Prop</span> <span class="o">}</span>
    <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">A</span><span class="o">}</span>
    <span class="o">{</span><span class="n">w1</span> <span class="n">w2</span> <span class="o">:</span> <span class="n">P</span> <span class="n">x</span><span class="o">}</span>
    <span class="o">:</span> <span class="bp">@</span><span class="n">heq</span> <span class="o">{</span> <span class="n">a</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">//</span> <span class="n">P</span> <span class="n">a</span> <span class="o">}</span> <span class="bp">⟨</span> <span class="n">x</span><span class="o">,</span> <span class="n">w1</span> <span class="bp">⟩</span> <span class="o">{</span> <span class="n">a</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">//</span> <span class="n">P</span> <span class="n">a</span> <span class="o">}</span> <span class="bp">⟨</span> <span class="n">x</span><span class="o">,</span> <span class="n">w2</span> <span class="bp">⟩</span>
    <span class="o">:=</span> <span class="k">begin</span>
    <span class="n">intros</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">e</span> <span class="o">:</span> <span class="n">w1</span> <span class="bp">=</span> <span class="n">w2</span><span class="o">,</span>
    <span class="n">trivial</span><span class="o">,</span>
    <span class="n">rewrite</span> <span class="n">e</span><span class="o">,</span>
<span class="kn">end</span>

<span class="n">def</span> <span class="n">coset_decomposition</span> <span class="o">{</span><span class="n">G</span><span class="o">:</span> <span class="n">Group</span><span class="o">}</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">G</span><span class="o">)</span>
<span class="o">:</span> <span class="n">underlying_type</span> <span class="n">G</span> <span class="err">≅</span> <span class="err">Σ</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">coset</span> <span class="n">H</span><span class="o">),</span> <span class="o">{</span> <span class="n">x</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">//</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">X</span><span class="bp">.</span><span class="n">val</span> <span class="o">}</span>
<span class="o">:=</span>
    <span class="o">{</span> <span class="n">hom</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">g</span><span class="o">,</span> <span class="n">sigma</span><span class="bp">.</span><span class="n">mk</span> <span class="o">(</span><span class="n">shift_coset</span> <span class="n">g</span> <span class="n">H</span><span class="o">)</span> <span class="bp">⟨</span> <span class="n">g</span> <span class="o">,</span> <span class="n">g_in_gH</span> <span class="n">g</span><span class="bp">⟩</span>
    <span class="o">,</span> <span class="n">inv</span><span class="o">:=</span> <span class="o">(</span><span class="bp">λ</span> <span class="bp">⟨</span> <span class="n">X</span><span class="o">,</span> <span class="bp">⟨</span> <span class="n">g</span><span class="o">,</span> <span class="bp">_</span> <span class="bp">⟩</span> <span class="bp">⟩</span><span class="o">,</span> <span class="n">g</span><span class="o">)</span>
    <span class="o">,</span> <span class="n">hom_inv_id&#39;</span> <span class="o">:=</span> <span class="k">begin</span>
        <span class="n">apply</span> <span class="n">funext</span><span class="o">,</span>
        <span class="n">intros</span><span class="o">,</span>
        <span class="n">simp</span><span class="o">,</span> <span class="n">unfold</span> <span class="n">coset_decomposition</span><span class="bp">._</span><span class="n">match_1</span><span class="o">,</span>
      <span class="kn">end</span>
    <span class="o">,</span> <span class="n">inv_hom_id&#39;</span> <span class="o">:=</span> <span class="k">begin</span>
        <span class="n">apply</span> <span class="n">funext</span><span class="o">,</span> <span class="n">intros</span><span class="o">,</span> <span class="n">induction</span> <span class="n">x</span><span class="o">,</span>
        <span class="n">rename</span> <span class="n">x_fst</span> <span class="n">X</span><span class="o">,</span>
        <span class="n">induction</span> <span class="n">x_snd</span> <span class="k">with</span> <span class="n">x</span> <span class="n">x_in_X</span><span class="o">,</span>
        <span class="n">simp</span><span class="o">,</span>
        <span class="n">unfold</span> <span class="n">coset_decomposition</span><span class="bp">._</span><span class="n">match_1</span><span class="o">,</span>
        <span class="n">split</span><span class="o">,</span> <span class="n">unfold</span> <span class="n">shift_coset</span><span class="o">,</span>
        <span class="k">have</span> <span class="n">e</span> <span class="o">:</span> <span class="n">shift</span> <span class="n">x</span> <span class="n">H</span><span class="bp">.</span><span class="n">val</span> <span class="bp">=</span> <span class="n">X</span><span class="bp">.</span><span class="n">val</span><span class="o">,</span>
        <span class="n">rewrite</span> <span class="bp">&lt;-</span> <span class="n">coset_characterization</span><span class="o">,</span> <span class="n">apply</span> <span class="n">x_in_X</span><span class="o">,</span>
        <span class="n">apply</span> <span class="n">subtype</span><span class="bp">.</span><span class="n">eq</span><span class="o">,</span> <span class="n">simp</span><span class="o">,</span> <span class="n">apply</span> <span class="n">e</span><span class="o">,</span>
        <span class="n">sorry</span><span class="o">,</span> <span class="c1">-- Here is where the goal is</span>
    <span class="kn">end</span>
    <span class="o">}</span>
</code></pre></div>



<a name="198495131"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Using%20propext%20for%20heq%20on%20metavariables/near/198495131" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Using.20propext.20for.20heq.20on.20metavariables.html#198495131">(May 22 2020 at 21:07)</a>:</h4>
<p>You had a bunch of <code>def</code>s which should be <code>theorem</code> or <code>lemma</code> instead. All proofs of <code>lemma</code>s can be replaced with <code>sorry</code> when making a MWE. Then you can remove lemmas and defs which aren't referenced:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">set</span><span class="bp">.</span><span class="n">basic</span>
<span class="kn">import</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">category</span><span class="bp">.</span><span class="n">Group</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">subtype</span>
<span class="kn">import</span> <span class="n">category_theory</span><span class="bp">.</span><span class="n">isomorphism</span>
<span class="kn">open</span> <span class="n">set</span>

<span class="n">def</span> <span class="n">subgroup</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">Group</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">H</span> <span class="o">:</span> <span class="n">set</span> <span class="n">G</span> <span class="bp">//</span> <span class="n">is_subgroup</span> <span class="n">H</span> <span class="o">}</span>
<span class="n">def</span> <span class="n">shift</span> <span class="o">{</span> <span class="n">G</span> <span class="o">:</span> <span class="n">Group</span> <span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">set</span> <span class="n">G</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="n">G</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">g</span> <span class="bp">|</span> <span class="n">H</span> <span class="o">(</span><span class="n">x</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="n">g</span><span class="o">)</span> <span class="o">}</span>
<span class="n">def</span> <span class="n">is_coset_of</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="n">Group</span><span class="o">}</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">G</span><span class="o">)</span> <span class="o">(</span><span class="n">K</span> <span class="o">:</span> <span class="n">set</span> <span class="n">G</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
    <span class="n">exists</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">G</span><span class="o">),</span> <span class="n">K</span> <span class="bp">=</span> <span class="n">shift</span> <span class="n">x</span> <span class="n">H</span><span class="bp">.</span><span class="n">val</span>
<span class="n">def</span> <span class="n">coset</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="n">Group</span><span class="o">}</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">G</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">K</span> <span class="o">:</span> <span class="n">set</span> <span class="n">G</span> <span class="bp">//</span> <span class="n">is_coset_of</span> <span class="n">H</span> <span class="n">K</span> <span class="o">}</span>
<span class="n">def</span> <span class="n">shift_coset</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="n">Group</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">G</span><span class="o">)</span> <span class="o">:</span> <span class="n">coset</span> <span class="n">H</span> <span class="o">:=</span>
    <span class="bp">⟨</span> <span class="n">shift</span> <span class="n">x</span> <span class="n">H</span><span class="bp">.</span><span class="n">val</span> <span class="o">,</span> <span class="n">exists</span><span class="bp">.</span><span class="n">intro</span> <span class="n">x</span> <span class="k">begin</span> <span class="n">trivial</span> <span class="kn">end</span> <span class="bp">⟩</span>

<span class="kn">lemma</span> <span class="n">coset_characterization</span>
<span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="n">Group</span><span class="o">}</span> <span class="o">{</span><span class="n">H</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">G</span><span class="o">}</span>
    <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">coset</span> <span class="n">H</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span>
    <span class="o">:</span> <span class="n">g</span> <span class="err">∈</span> <span class="n">X</span><span class="bp">.</span><span class="n">val</span> <span class="bp">→</span>  <span class="n">X</span><span class="bp">.</span><span class="n">val</span> <span class="bp">=</span> <span class="n">shift</span> <span class="n">g</span> <span class="n">H</span><span class="bp">.</span><span class="n">val</span>
    <span class="o">:=</span>
<span class="n">sorry</span>

<span class="n">def</span> <span class="n">underlying_type</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">Group</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="n">G</span>

<span class="kn">universe</span> <span class="n">u</span>
<span class="kn">universe</span> <span class="n">v</span>

<span class="kn">lemma</span> <span class="n">mem_def&#39;</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">set</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">a</span><span class="o">)</span>
    <span class="o">:</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">X</span> <span class="bp">↔</span> <span class="n">X</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="kn">lemma</span> <span class="n">g_in_gH</span> <span class="o">{</span><span class="n">G</span><span class="o">:</span> <span class="n">Group</span><span class="o">}</span> <span class="o">{</span><span class="n">H</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">G</span><span class="o">}</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span>
    <span class="o">:</span> <span class="n">g</span> <span class="err">∈</span> <span class="o">(</span><span class="n">shift_coset</span> <span class="n">g</span> <span class="n">H</span><span class="o">)</span><span class="bp">.</span><span class="n">val</span> <span class="o">:=</span>
<span class="n">sorry</span>

<span class="n">def</span> <span class="n">coset_decomposition</span> <span class="o">{</span><span class="n">G</span><span class="o">:</span> <span class="n">Group</span><span class="o">}</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">G</span><span class="o">)</span>
<span class="o">:</span> <span class="n">underlying_type</span> <span class="n">G</span> <span class="err">≅</span> <span class="err">Σ</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">coset</span> <span class="n">H</span><span class="o">),</span> <span class="o">{</span> <span class="n">x</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">//</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">X</span><span class="bp">.</span><span class="n">val</span> <span class="o">}</span>
<span class="o">:=</span>
    <span class="o">{</span> <span class="n">hom</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">g</span><span class="o">,</span> <span class="n">sigma</span><span class="bp">.</span><span class="n">mk</span> <span class="o">(</span><span class="n">shift_coset</span> <span class="n">g</span> <span class="n">H</span><span class="o">)</span> <span class="bp">⟨</span> <span class="n">g</span> <span class="o">,</span> <span class="n">g_in_gH</span> <span class="n">g</span><span class="bp">⟩</span>
    <span class="o">,</span> <span class="n">inv</span><span class="o">:=</span> <span class="o">(</span><span class="bp">λ</span> <span class="bp">⟨</span> <span class="n">X</span><span class="o">,</span> <span class="bp">⟨</span> <span class="n">g</span><span class="o">,</span> <span class="bp">_</span> <span class="bp">⟩</span> <span class="bp">⟩</span><span class="o">,</span> <span class="n">g</span><span class="o">)</span>
    <span class="o">,</span> <span class="n">hom_inv_id&#39;</span> <span class="o">:=</span> <span class="k">begin</span>
        <span class="n">apply</span> <span class="n">funext</span><span class="o">,</span>
        <span class="n">intros</span><span class="o">,</span>
        <span class="n">simp</span><span class="o">,</span> <span class="n">unfold</span> <span class="n">coset_decomposition</span><span class="bp">._</span><span class="n">match_1</span><span class="o">,</span>
      <span class="kn">end</span>
    <span class="o">,</span> <span class="n">inv_hom_id&#39;</span> <span class="o">:=</span> <span class="k">begin</span>
        <span class="n">apply</span> <span class="n">funext</span><span class="o">,</span> <span class="n">intros</span><span class="o">,</span> <span class="n">induction</span> <span class="n">x</span><span class="o">,</span>
        <span class="n">rename</span> <span class="n">x_fst</span> <span class="n">X</span><span class="o">,</span>
        <span class="n">induction</span> <span class="n">x_snd</span> <span class="k">with</span> <span class="n">x</span> <span class="n">x_in_X</span><span class="o">,</span>
        <span class="n">simp</span><span class="o">,</span>
        <span class="n">unfold</span> <span class="n">coset_decomposition</span><span class="bp">._</span><span class="n">match_1</span><span class="o">,</span>
        <span class="n">split</span><span class="o">,</span> <span class="n">unfold</span> <span class="n">shift_coset</span><span class="o">,</span>
        <span class="k">have</span> <span class="n">e</span> <span class="o">:</span> <span class="n">shift</span> <span class="n">x</span> <span class="n">H</span><span class="bp">.</span><span class="n">val</span> <span class="bp">=</span> <span class="n">X</span><span class="bp">.</span><span class="n">val</span><span class="o">,</span>
        <span class="n">rewrite</span> <span class="bp">&lt;-</span> <span class="n">coset_characterization</span><span class="o">,</span> <span class="n">apply</span> <span class="n">x_in_X</span><span class="o">,</span>
        <span class="n">apply</span> <span class="n">subtype</span><span class="bp">.</span><span class="n">eq</span><span class="o">,</span> <span class="n">simp</span><span class="o">,</span> <span class="n">apply</span> <span class="n">e</span><span class="o">,</span>
        <span class="n">sorry</span><span class="o">,</span> <span class="c1">-- Here is where the goal is</span>
    <span class="kn">end</span>
    <span class="o">}</span>
</code></pre></div>



<a name="198495281"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Using%20propext%20for%20heq%20on%20metavariables/near/198495281" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Using.20propext.20for.20heq.20on.20metavariables.html#198495281">(May 22 2020 at 21:09)</a>:</h4>
<p>You can prove the lemma if you replace the <code>apply subtype.eq</code> line with <code>cases X, cases e, refl,</code></p>



<a name="198495306"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Using%20propext%20for%20heq%20on%20metavariables/near/198495306" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Using.20propext.20for.20heq.20on.20metavariables.html#198495306">(May 22 2020 at 21:09)</a>:</h4>
<p>I'm sure others can tell you better than I how to improve your code, but the immediate thing which stands out to me is that you're showing isomorphism between two types, so it's easier to use <code>equiv</code> instead. I finished your goal in this context:</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">coset_decomposition</span> <span class="o">{</span><span class="n">G</span><span class="o">:</span> <span class="n">Group</span><span class="o">}</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">G</span><span class="o">)</span>
<span class="o">:</span> <span class="n">underlying_type</span> <span class="n">G</span> <span class="err">≃</span> <span class="err">Σ</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">coset</span> <span class="n">H</span><span class="o">),</span> <span class="o">{</span> <span class="n">x</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">//</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">X</span><span class="bp">.</span><span class="n">val</span> <span class="o">}</span>
<span class="o">:=</span>
    <span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">g</span><span class="o">,</span> <span class="n">sigma</span><span class="bp">.</span><span class="n">mk</span> <span class="o">(</span><span class="n">shift_coset</span> <span class="n">g</span> <span class="n">H</span><span class="o">)</span> <span class="bp">⟨</span> <span class="n">g</span> <span class="o">,</span> <span class="n">g_in_gH</span> <span class="n">g</span><span class="bp">⟩</span>
    <span class="o">,</span> <span class="n">inv_fun</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">λ</span> <span class="bp">⟨</span> <span class="n">X</span><span class="o">,</span> <span class="bp">⟨</span> <span class="n">g</span><span class="o">,</span> <span class="bp">_</span> <span class="bp">⟩</span> <span class="bp">⟩</span><span class="o">,</span> <span class="n">g</span><span class="o">)</span>
    <span class="o">,</span> <span class="n">left_inv</span> <span class="o">:=</span> <span class="k">begin</span>
        <span class="n">intro</span> <span class="n">x</span><span class="o">,</span>
        <span class="n">intros</span><span class="o">,</span>
        <span class="n">simp</span><span class="o">,</span> <span class="n">unfold</span> <span class="n">coset_decomposition</span><span class="bp">._</span><span class="n">match_1</span><span class="o">,</span>
      <span class="kn">end</span>
    <span class="o">,</span> <span class="n">right_inv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="k">begin</span>
        <span class="n">intros</span><span class="o">,</span> <span class="n">induction</span> <span class="n">x</span><span class="o">,</span>
        <span class="n">induction</span> <span class="n">x_snd</span> <span class="k">with</span> <span class="n">x</span> <span class="n">x_in_X</span><span class="o">,</span>
        <span class="n">dsimp</span><span class="o">,</span>
        <span class="n">congr</span><span class="o">,</span>
        <span class="n">unfold</span> <span class="n">coset_decomposition</span><span class="bp">._</span><span class="n">match_1</span><span class="o">,</span>
        <span class="n">unfold</span> <span class="n">shift_coset</span><span class="o">,</span>
        <span class="n">apply</span> <span class="n">subtype</span><span class="bp">.</span><span class="n">eq</span><span class="o">,</span>
        <span class="n">exact</span> <span class="o">(</span><span class="n">coset_characterization</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">x_in_X</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="o">,</span>
        <span class="n">funext</span> <span class="n">t</span><span class="o">,</span>
        <span class="n">dsimp</span> <span class="o">[</span><span class="n">shift_coset</span><span class="o">,</span> <span class="n">coset_decomposition</span><span class="bp">._</span><span class="n">match_1</span><span class="o">],</span>
        <span class="n">rw</span> <span class="err">←</span> <span class="o">(</span><span class="n">coset_characterization</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">x_in_X</span><span class="o">),</span>
        <span class="n">apply</span> <span class="n">proof_irrel_heq</span><span class="o">,</span>
    <span class="kn">end</span>
    <span class="o">}</span>
</code></pre></div>



<a name="198495437"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Using%20propext%20for%20heq%20on%20metavariables/near/198495437" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Using.20propext.20for.20heq.20on.20metavariables.html#198495437">(May 22 2020 at 21:09)</a>:</h4>
<p>oh, there is another heq goal after that</p>



<a name="198495563"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Using%20propext%20for%20heq%20on%20metavariables/near/198495563" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Using.20propext.20for.20heq.20on.20metavariables.html#198495563">(May 22 2020 at 21:11)</a>:</h4>
<p>The key thing I did which made it work here was to use <code>congr</code> which broke up the constructor into nicer things, and then <code>proof_irrel_heq</code> to take care of the _. That said, I still agree that some design thing has gone wrong which is leading to this - the most obvious to me is that you want to define an extensionality property for cosets</p>



<a name="198495854"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Using%20propext%20for%20heq%20on%20metavariables/near/198495854" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Izzy Meckler <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Using.20propext.20for.20heq.20on.20metavariables.html#198495854">(May 22 2020 at 21:14)</a>:</h4>
<p>Thanks everyone for all the tips! Still confused what exactly what is going wrong or even why the heterogeneous equality goal appears</p>



<a name="198495879"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Using%20propext%20for%20heq%20on%20metavariables/near/198495879" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Using.20propext.20for.20heq.20on.20metavariables.html#198495879">(May 22 2020 at 21:14)</a>:</h4>
<p>This is a cleaned up version of Bhavik's proof</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">coset_decomposition</span> <span class="o">{</span><span class="n">G</span><span class="o">:</span> <span class="n">Group</span><span class="o">}</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">G</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">underlying_type</span> <span class="n">G</span> <span class="err">≃</span> <span class="err">Σ</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">coset</span> <span class="n">H</span><span class="o">),</span> <span class="o">{</span> <span class="n">x</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">//</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">X</span><span class="bp">.</span><span class="n">val</span> <span class="o">}</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">g</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">shift_coset</span> <span class="n">g</span> <span class="n">H</span><span class="o">,</span> <span class="n">g</span><span class="o">,</span> <span class="n">g_in_gH</span> <span class="n">g</span><span class="bp">⟩</span><span class="o">,</span>
  <span class="n">inv_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span><span class="bp">.</span><span class="mi">2</span><span class="bp">.</span><span class="mi">1</span><span class="o">,</span>
  <span class="n">left_inv</span> <span class="o">:=</span> <span class="k">begin</span>
    <span class="n">intro</span> <span class="n">x</span><span class="o">,</span>
    <span class="n">intros</span><span class="o">,</span>
    <span class="n">simp</span><span class="o">,</span>
  <span class="kn">end</span><span class="o">,</span>
  <span class="n">right_inv</span> <span class="o">:=</span> <span class="k">begin</span>
    <span class="n">rintro</span> <span class="bp">⟨</span><span class="n">X</span><span class="o">,</span> <span class="n">g</span><span class="o">,</span> <span class="n">x_in_X</span><span class="bp">⟩</span><span class="o">,</span>
    <span class="n">dsimp</span><span class="o">,</span>
    <span class="k">have</span> <span class="o">:</span> <span class="n">shift_coset</span> <span class="n">g</span> <span class="n">H</span> <span class="bp">=</span> <span class="n">X</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">unfold</span> <span class="n">shift_coset</span><span class="o">,</span>
      <span class="n">apply</span> <span class="n">subtype</span><span class="bp">.</span><span class="n">eq</span><span class="o">,</span>
      <span class="n">exact</span> <span class="o">(</span><span class="n">coset_characterization</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">x_in_X</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span> <span class="o">},</span>
    <span class="n">subst</span> <span class="n">X</span><span class="o">,</span>
  <span class="kn">end</span> <span class="o">}</span>
</code></pre></div>



<a name="198495917"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Using%20propext%20for%20heq%20on%20metavariables/near/198495917" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Using.20propext.20for.20heq.20on.20metavariables.html#198495917">(May 22 2020 at 21:15)</a>:</h4>
<p>The heq goal appears because you're trying to show two cosets are equal, and the second argument of a <code>coset</code> depends on the first (and the second argument is a prop)</p>



<a name="198495955"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Using%20propext%20for%20heq%20on%20metavariables/near/198495955" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Using.20propext.20for.20heq.20on.20metavariables.html#198495955">(May 22 2020 at 21:16)</a>:</h4>
<p>The key step here is to replace the step that produced the heq, the congr on a dependent pair, with a <code>have</code> that the first components are equal followed by a <code>subst</code></p>



<a name="198496000"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Using%20propext%20for%20heq%20on%20metavariables/near/198496000" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Izzy Meckler <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Using.20propext.20for.20heq.20on.20metavariables.html#198496000">(May 22 2020 at 21:16)</a>:</h4>
<p>right, makes sense -- but is <code>=</code> on sigma types defined in terms of heq?</p>



<a name="198496013"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Using%20propext%20for%20heq%20on%20metavariables/near/198496013" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Using.20propext.20for.20heq.20on.20metavariables.html#198496013">(May 22 2020 at 21:16)</a>:</h4>
<p>in this case, that's actually the end of the proof, but usually you would have to then follow up with a proof that the second components are equal (but since the first types are now the same this is a regular equal)</p>



<a name="198496033"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Using%20propext%20for%20heq%20on%20metavariables/near/198496033" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Izzy Meckler <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Using.20propext.20for.20heq.20on.20metavariables.html#198496033">(May 22 2020 at 21:17)</a>:</h4>
<p>my understanding was that <code>simp</code> just computes using the definitional equality, is this not the case?</p>



<a name="198496036"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Using%20propext%20for%20heq%20on%20metavariables/near/198496036" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Using.20propext.20for.20heq.20on.20metavariables.html#198496036">(May 22 2020 at 21:17)</a>:</h4>
<p><code>=</code> is not defined specially on any type</p>



<a name="198496080"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Using%20propext%20for%20heq%20on%20metavariables/near/198496080" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Using.20propext.20for.20heq.20on.20metavariables.html#198496080">(May 22 2020 at 21:17)</a>:</h4>
<p><code>congr</code> knows how to prove equality of sigma types (or more generally, dependent functions) by reducing to heq, but this is usually the wrong move</p>



<a name="198496098"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Using%20propext%20for%20heq%20on%20metavariables/near/198496098" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Using.20propext.20for.20heq.20on.20metavariables.html#198496098">(May 22 2020 at 21:17)</a>:</h4>
<p><code>simp</code> does not use only defeq, that would be <code>dsimp</code></p>



<a name="198496145"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Using%20propext%20for%20heq%20on%20metavariables/near/198496145" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Izzy Meckler <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Using.20propext.20for.20heq.20on.20metavariables.html#198496145">(May 22 2020 at 21:18)</a>:</h4>
<p>ah! thank you mario</p>



<a name="198496180"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Using%20propext%20for%20heq%20on%20metavariables/near/198496180" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Using.20propext.20for.20heq.20on.20metavariables.html#198496180">(May 22 2020 at 21:18)</a>:</h4>
<p>in particular <code>simp</code> has a rule that will rewrite <code>&lt;x, y&gt; = &lt;z, w&gt; &lt;-&gt; x = y /\ z == w</code></p>



<a name="198502869"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Using%20propext%20for%20heq%20on%20metavariables/near/198502869" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Using.20propext.20for.20heq.20on.20metavariables.html#198502869">(May 22 2020 at 22:39)</a>:</h4>
<p>Equality of dependent types is a bit of a thorny issue in dependent type theory. Equality of types in general is a bit weird. You apparently can't disprove <code>nat = int</code> in lean</p>



<a name="198506438"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Using%20propext%20for%20heq%20on%20metavariables/near/198506438" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Using.20propext.20for.20heq.20on.20metavariables.html#198506438">(May 22 2020 at 23:32)</a>:</h4>
<p>and you can even prove it in HoTT</p>



<a name="198506600"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Using%20propext%20for%20heq%20on%20metavariables/near/198506600" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Using.20propext.20for.20heq.20on.20metavariables.html#198506600">(May 22 2020 at 23:35)</a>:</h4>
<p><a href="https://twitter.com/XenaProject/status/1263841150009475073">https://twitter.com/XenaProject/status/1263841150009475073</a></p>
<div class="inline-preview-twitter"><div class="twitter-tweet"><a href="https://twitter.com/XenaProject/status/1263841150009475073"><img class="twitter-avatar" src="https://pbs.twimg.com/profile_images/1263810297560735744/gMianQ_V_normal.jpg"></a><p>"Mathematics is the art of giving the same name to different things." - Henri Poincaré. Dependent type theory's `=` doesn't prove R[1/fg]=R[1/f][1/g] and Homotopy Type Theory's = lets things be equal even if they're non-canonically isomorphic. Computers haven't mastered this art.</p><span>- The Xena Project (@XenaProject)</span></div></div>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
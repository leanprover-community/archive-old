---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/transfinite.20induction.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transfinite.20induction.html">transfinite induction</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="123268706"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transfinite%20induction/near/123268706" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transfinite.20induction.html#123268706">(Mar 04 2018 at 17:23)</a>:</h4>
<p>Just for curiosity, is this a thing in Lean?</p>



<a name="123269021"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transfinite%20induction/near/123269021" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transfinite.20induction.html#123269021">(Mar 04 2018 at 17:35)</a>:</h4>
<p><a href="https://gitter.im/leanprover_public/Lobby?at=5a4a3b7a232e79134db2c204" target="_blank" title="https://gitter.im/leanprover_public/Lobby?at=5a4a3b7a232e79134db2c204">https://gitter.im/leanprover_public/Lobby?at=5a4a3b7a232e79134db2c204</a></p>



<a name="237813339"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transfinite%20induction/near/237813339" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transfinite.20induction.html#237813339">(May 07 2021 at 12:23)</a>:</h4>
<p>I would like to make a transfinite induction on a type, with respect to a minimal well-order (for which the initial segments are shorter than the whole type). So, I would need something like the next lemma.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">exists_small_well_order</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">rel</span> <span class="n">α</span> <span class="n">α</span><span class="o">),</span> <span class="n">is_well_order</span> <span class="n">α</span> <span class="n">r</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span>
  <span class="bp">#</span><span class="o">{</span><span class="n">y</span> <span class="bp">//</span> <span class="n">r</span> <span class="n">y</span> <span class="n">x</span><span class="o">}</span> <span class="bp">&lt;</span> <span class="bp">#</span><span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>
<p>What we have on ordinals and cardinals contains this and much more, for sure, but I found the API hard to work with, and I could not locate this specific lemma (or a suitable variant). <span class="user-mention" data-user-id="110049">@Mario Carneiro</span> , do you have a hint on where I should look?</p>



<a name="237813412"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transfinite%20induction/near/237813412" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transfinite.20induction.html#237813412">(May 07 2021 at 12:24)</a>:</h4>
<p>That is the defining property of <code>ord</code></p>



<a name="237813468"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transfinite%20induction/near/237813468" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transfinite.20induction.html#237813468">(May 07 2021 at 12:24)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/cardinal.ord">docs#cardinal.ord</a></p>



<a name="237813589"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transfinite%20induction/near/237813589" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transfinite.20induction.html#237813589">(May 07 2021 at 12:25)</a>:</h4>
<p>especially see <a href="https://leanprover-community.github.io/mathlib_docs/find/cardinal.card_typein_lt">docs#cardinal.card_typein_lt</a></p>



<a name="237814529"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transfinite%20induction/near/237814529" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transfinite.20induction.html#237814529">(May 07 2021 at 12:33)</a>:</h4>
<p>That's what I am trying to play with, but as far as I can tell these functions don't give me an order on my original type (only on <code>(cardinal.ord (#α)).out.α</code>), so I would need to transport my order through some equiv, but I don't find the lemmas saying that the image of a well-order under an equiv is a well-order.</p>



<a name="237814540"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transfinite%20induction/near/237814540" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transfinite.20induction.html#237814540">(May 07 2021 at 12:33)</a>:</h4>
<p><span class="user-mention" data-user-id="302826">@Aaron Anderson</span> has done a lot of thing with well-orders recently. Maybe he can help.</p>



<a name="237816176"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transfinite%20induction/near/237816176" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transfinite.20induction.html#237816176">(May 07 2021 at 12:46)</a>:</h4>
<p>The reason for the equality hypothesis in <code>card_typein_lt</code> is exactly so that you can use your original type alpha instead of the out type</p>



<a name="237816393"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transfinite%20induction/near/237816393" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transfinite.20induction.html#237816393">(May 07 2021 at 12:47)</a>:</h4>
<p>Sure, this lemma is perfect once I know how to construct my well-order on <code>α</code> with the right ordinal type, and this is what I can't see how to do with the current API.</p>



<a name="237816440"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transfinite%20induction/near/237816440" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transfinite.20induction.html#237816440">(May 07 2021 at 12:47)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/ord_eq">docs#ord_eq</a>?</p>



<a name="237816678"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transfinite%20induction/near/237816678" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transfinite.20induction.html#237816678">(May 07 2021 at 12:49)</a>:</h4>
<p>Thanks!</p>



<a name="237828147"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transfinite%20induction/near/237828147" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transfinite.20induction.html#237828147">(May 07 2021 at 14:05)</a>:</h4>
<p>I struggled to get this one (this is so much harder to use a part of the library one doesn't know), but in the end it comes out pretty cleanly. Did you know that, assuming the continuum hypothesis, you can find a subset of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="double-struck">R</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">\mathbb{R}^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span> which is very large if you see it through vertical lines (i.e., along each vertical line, it misses only a countable set), but it is very small if you see it through horizontal lines (i.e., along each horizontal line, it is countable)? This may seem to contradict Fubini (the set has full measure when integrated in one direction, zero measure in the other direction), but of course it is non-measurable.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">analysis.normed_space.hahn_banach</span>
<span class="kn">import</span> <span class="n">set_theory.cardinal_ordinal</span>

<span class="kd">universe</span> <span class="n">u</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span>
<span class="kn">open</span> <span class="n">set</span> <span class="n">cardinal</span>
<span class="n">open_locale</span> <span class="n">cardinal</span>

<span class="kd">lemma</span> <span class="n">countable_iff_lt_aleph_one</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">countable</span> <span class="n">s</span> <span class="bp">↔</span> <span class="bp">#</span><span class="n">s</span> <span class="bp">&lt;</span> <span class="n">aleph</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">have</span> <span class="o">:</span> <span class="n">aleph</span> <span class="mi">1</span> <span class="bp">=</span> <span class="o">(</span><span class="n">aleph</span> <span class="mi">0</span><span class="o">)</span><span class="bp">.</span><span class="n">succ</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="bp">←</span> <span class="n">aleph_succ</span><span class="o">,</span> <span class="n">ordinal.succ_zero</span><span class="o">],</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">countable_iff</span><span class="o">,</span> <span class="bp">←</span> <span class="n">aleph_zero</span><span class="o">,</span> <span class="n">this</span><span class="o">,</span> <span class="n">lt_succ</span><span class="o">],</span>
<span class="kd">end</span>

<span class="kd">theorem</span> <span class="n">sierpinski_pathological_family</span> <span class="o">(</span><span class="n">Hcont</span> <span class="o">:</span> <span class="bp">#</span><span class="n">ℝ</span> <span class="bp">=</span> <span class="n">aleph</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">),</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">countable</span> <span class="o">(</span><span class="n">univ</span> <span class="bp">\</span> <span class="n">f</span> <span class="n">x</span><span class="o">))</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">y</span><span class="o">,</span> <span class="n">countable</span> <span class="o">{</span><span class="n">x</span> <span class="bp">|</span> <span class="n">y</span> <span class="bp">∈</span> <span class="n">f</span> <span class="n">x</span><span class="o">})</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rcases</span> <span class="n">ord_eq</span> <span class="n">ℝ</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">r</span><span class="o">,</span> <span class="n">hr</span><span class="o">,</span> <span class="n">H</span><span class="o">⟩,</span>
  <span class="n">resetI</span><span class="o">,</span>
  <span class="n">refine</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="o">{</span><span class="n">y</span> <span class="bp">|</span> <span class="n">r</span> <span class="n">x</span> <span class="n">y</span><span class="o">},</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
  <span class="o">{</span> <span class="k">have</span> <span class="o">:</span> <span class="n">univ</span> <span class="bp">\</span> <span class="o">{</span><span class="n">y</span> <span class="bp">|</span> <span class="n">r</span> <span class="n">x</span> <span class="n">y</span><span class="o">}</span> <span class="bp">=</span> <span class="o">{</span><span class="n">y</span> <span class="bp">|</span> <span class="n">r</span> <span class="n">y</span> <span class="n">x</span><span class="o">}</span> <span class="bp">∪</span> <span class="o">{</span><span class="n">x</span><span class="o">},</span>
    <span class="o">{</span> <span class="n">ext</span> <span class="n">y</span><span class="o">,</span>
      <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">true_and</span><span class="o">,</span> <span class="n">mem_univ</span><span class="o">,</span> <span class="n">mem_set_of_eq</span><span class="o">,</span> <span class="n">mem_insert_iff</span><span class="o">,</span> <span class="n">union_singleton</span><span class="o">,</span> <span class="n">mem_diff</span><span class="o">],</span>
      <span class="n">rcases</span> <span class="n">trichotomous_of</span> <span class="n">r</span> <span class="n">x</span> <span class="n">y</span> <span class="k">with</span> <span class="n">h</span><span class="bp">|</span><span class="n">rfl</span><span class="bp">|</span><span class="n">h</span><span class="o">,</span>
      <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">h</span><span class="o">,</span> <span class="n">not_or_distrib</span><span class="o">,</span> <span class="n">false_iff</span><span class="o">,</span> <span class="n">not_true</span><span class="o">],</span>
        <span class="n">split</span><span class="o">,</span>
        <span class="o">{</span> <span class="n">rintros</span> <span class="n">rfl</span><span class="o">,</span> <span class="n">exact</span> <span class="n">irrefl_of</span> <span class="n">r</span> <span class="n">y</span> <span class="n">h</span> <span class="o">},</span>
        <span class="o">{</span> <span class="n">exact</span> <span class="n">asymm</span> <span class="n">h</span> <span class="o">}</span> <span class="o">},</span>
      <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">true_or</span><span class="o">,</span> <span class="n">eq_self_iff_true</span><span class="o">,</span> <span class="n">iff_true</span><span class="o">],</span> <span class="n">exact</span> <span class="n">irrefl</span> <span class="n">x</span> <span class="o">},</span>
      <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">h</span><span class="o">,</span> <span class="n">iff_true</span><span class="o">,</span> <span class="n">or_true</span><span class="o">],</span> <span class="n">exact</span> <span class="n">asymm</span> <span class="n">h</span> <span class="o">}</span> <span class="o">},</span>
    <span class="n">rw</span> <span class="n">this</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">countable.union</span> <span class="n">_</span> <span class="o">(</span><span class="n">countable_singleton</span> <span class="n">_</span><span class="o">),</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">countable_iff_lt_aleph_one</span><span class="o">,</span> <span class="bp">←</span> <span class="n">Hcont</span><span class="o">],</span>
    <span class="n">exact</span> <span class="n">card_typein_lt</span> <span class="n">r</span> <span class="n">x</span> <span class="n">H</span> <span class="o">},</span>
  <span class="o">{</span> <span class="k">assume</span> <span class="n">y</span><span class="o">,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">countable_iff_lt_aleph_one</span><span class="o">,</span> <span class="bp">←</span> <span class="n">Hcont</span><span class="o">],</span>
    <span class="n">exact</span> <span class="n">card_typein_lt</span> <span class="n">r</span> <span class="n">y</span> <span class="n">H</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>
<p>The part using well-orders can certainly be golfed a lot (why isn't <code>linarith</code> able to close this right away?), but the cardinal API is perfect here.</p>



<a name="237844128"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transfinite%20induction/near/237844128" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transfinite.20induction.html#237844128">(May 07 2021 at 15:44)</a>:</h4>
<p>This is a nice example! FWIW, a while ago I thought a little about creating an API for transfinite recursion, to show things like "there's a function <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">R</mi><mo>→</mo><mi mathvariant="double-struck">R</mi></mrow><annotation encoding="application/x-tex">\mathbb R \to \mathbb R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord mathbb">R</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord mathbb">R</span></span></span></span> which is locally surjective", where the end-user wouldn't have to think about recursion. For countable recursion, the Rasiowa-Sikorski lemma provides this sort of API, and I used it in <code>order/countable_dense_linear_order</code> to do the back-and-forth method without mentioning recursion. But the story with general transfinite recursion is a little more complicated. Returning to the local surjection example, you can imagine a partial order <code>P</code> of "states" for the recursion, where an element of <code>P</code> is a partial function R -&gt; R defined on less than continuum many points. Then you have continuum many "desired properties", of the form "some element in (a,b) should map to x". Crucially these are all individually "easy to satisfy", in the sense that they determine dense subsets of <code>P</code>. But you also need to able to take upper bounds of certain chains in <code>P</code>. Here you need to be careful: it's true that a countable chain in <code>P</code> has an upper bound, but it's possible that a chain of size <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>κ</mi><mo>&lt;</mo><msup><mn>2</mn><msub><mi mathvariant="normal">ℵ</mi><mn>0</mn></msub></msup></mrow><annotation encoding="application/x-tex">\kappa &lt; 2^{\aleph_0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">κ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight">ℵ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span> has no upper bound. One way of rescuing this is to note that <code>P</code> has a sort of 'rank' function,  sending a partial function to the cardinality of its domain. Then you can say that each "desired property" can be satisfied without increasing the rank, and you can take upper bounds of chains given some condition on the ranks (and you get some condition on the rank of the upper bound)</p>



<a name="237844473"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transfinite%20induction/near/237844473" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transfinite.20induction.html#237844473">(May 07 2021 at 15:46)</a>:</h4>
<p>You don't really need the continuum hypothesis for this, you could just prove it on any set of cardinality aleph 1</p>



<a name="237847424"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transfinite%20induction/near/237847424" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transfinite.20induction.html#237847424">(May 07 2021 at 16:03)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113488-general/topic/transfinite.20induction/near/237844473">said</a>:</p>
<blockquote>
<p>You don't really need the continuum hypothesis for this, you could just prove it on any set of cardinality aleph 1</p>
</blockquote>
<p>Sure. But the goal is to use this in another proof, and that's the form I need.</p>



<a name="237875380"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transfinite%20induction/near/237875380" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transfinite.20induction.html#237875380">(May 07 2021 at 19:12)</a>:</h4>
<p>Martin's axiom is designed to solve this kind of problem</p>



<a name="237875423"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transfinite%20induction/near/237875423" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transfinite.20induction.html#237875423">(May 07 2021 at 19:12)</a>:</h4>
<p>Unfortunately, it's an axiom as opposed to a theorem</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
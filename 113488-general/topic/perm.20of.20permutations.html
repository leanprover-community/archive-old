---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/perm.20of.20permutations.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/perm.20of.20permutations.html">perm of permutations</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="244818953"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/perm%20of%20permutations/near/244818953" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/perm.20of.20permutations.html#244818953">(Jul 03 2021 at 18:47)</a>:</h4>
<p>This statement handwaves to "it's obvious", but the implementation of <a href="https://leanprover-community.github.io/mathlib_docs/find/list.permutations">docs#list.permutations</a> is so inscrutable to me (how are the permutations even ordered?), that I have no idea how to begin to prove it.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.list.perm</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">l₁</span> <span class="n">l₂</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">}</span>

<span class="sd">/-- Two lists equivalent up to permutations have a list of permutations that are</span>
<span class="sd">equivalent up to permutation -/</span>
<span class="kd">lemma</span> <span class="n">list.perm_permutations</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">l₁</span> <span class="bp">~</span> <span class="n">l₂</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">l₁.permutations</span> <span class="bp">~</span> <span class="n">l₂.permutations</span> <span class="o">:=</span>
<span class="gr">sorry</span>
</code></pre></div>



<a name="244819003"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/perm%20of%20permutations/near/244819003" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/perm.20of.20permutations.html#244819003">(Jul 03 2021 at 18:48)</a>:</h4>
<p>(I already asked this on the Discord, but figured I might have more luck here since the authors of <code>perm.lean</code>, Leo, Jeremy, and Mario aren't all on discord)</p>



<a name="244819219"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/perm%20of%20permutations/near/244819219" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/perm.20of.20permutations.html#244819219">(Jul 03 2021 at 18:54)</a>:</h4>
<p>Regarding ordering, the python order looks much more obvious at a glance:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#eval</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">]</span><span class="bp">.</span><span class="n">permutations</span>
<span class="c1">-- [[1, 2, 3], [2, 1, 3], [3, 2, 1], [2, 3, 1], [3, 1, 2], [1, 3, 2]]</span>
</code></pre></div>
<div class="codehilite" data-code-language="Python"><pre><span></span><code><span class="kn">import</span> <span class="nn">itertools</span>
<span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">permutations</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]))</span>
<span class="c1"># [(1, 2, 3), (1, 3, 2), (2, 1, 3), (2, 3, 1), (3, 1, 2), (3, 2, 1)]</span>
</code></pre></div>



<a name="244819576"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/perm%20of%20permutations/near/244819576" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/perm.20of.20permutations.html#244819576">(Jul 03 2021 at 19:02)</a>:</h4>
<p>It looks to me like it's implemented like the Haskell version: <a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Data-List.html#v:permutations">https://hackage.haskell.org/package/base-4.15.0.0/docs/Data-List.html#v:permutations</a></p>



<a name="244819650"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/perm%20of%20permutations/near/244819650" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/perm.20of.20permutations.html#244819650">(Jul 03 2021 at 19:04)</a>:</h4>
<p>And it's implemented like that in Haskell to take full advantage of laziness: <a href="https://stackoverflow.com/questions/24484348/what-does-this-list-permutations-implementation-in-haskell-exactly-do">https://stackoverflow.com/questions/24484348/what-does-this-list-permutations-implementation-in-haskell-exactly-do</a></p>



<a name="244820390"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/perm%20of%20permutations/near/244820390" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/perm.20of.20permutations.html#244820390">(Jul 03 2021 at 19:24)</a>:</h4>
<p>It doesn't need to be redefined but it does need more lemmas about it. The trouble is that the permutations seem to be in a strange order so there's no nice statement of <code>permuations_cons</code>. Maybe it's best to basically treat it like a multiset, and not prove any lemmas about the order.</p>



<a name="244820673"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/perm%20of%20permutations/near/244820673" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/perm.20of.20permutations.html#244820673">(Jul 03 2021 at 19:32)</a>:</h4>
<p>Is laziness relevant to lean?</p>



<a name="244820823"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/perm%20of%20permutations/near/244820823" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/perm.20of.20permutations.html#244820823">(Jul 03 2021 at 19:36)</a>:</h4>
<p>I don't think so, but there are also properties of this implementation which are nice though they're not proved in Lean</p>



<a name="244820854"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/perm%20of%20permutations/near/244820854" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/perm.20of.20permutations.html#244820854">(Jul 03 2021 at 19:37)</a>:</h4>
<p>I guess in principle we could have a <code>list.lexicographic_permutations</code> function</p>



<a name="244820866"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/perm%20of%20permutations/near/244820866" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/perm.20of.20permutations.html#244820866">(Jul 03 2021 at 19:37)</a>:</h4>
<p>But proving its equivalence modulo permutation to the current implementation seems every bit as hard as my original lemma statement</p>



<a name="244820925"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/perm%20of%20permutations/near/244820925" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/perm.20of.20permutations.html#244820925">(Jul 03 2021 at 19:38)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/113488-general/topic/perm.20of.20permutations/near/244820854">said</a>:</p>
<blockquote>
<p>I guess in principle we could have a <code>list.lexicographic_permutations</code> function</p>
</blockquote>
<p>We have something similar for list.sublists and list.sublists' so there is precedent for this kind of duplication</p>



<a name="244820953"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/perm%20of%20permutations/near/244820953" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/perm.20of.20permutations.html#244820953">(Jul 03 2021 at 19:39)</a>:</h4>
<p>Chris, we have <a href="https://leanprover-community.github.io/mathlib_docs/find/list.permutations_aux_cons">docs#list.permutations_aux_cons</a>; I think the API of permutations is "unfold it first, then use the API of permutations_aux".</p>



<a name="244821779"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/perm%20of%20permutations/near/244821779" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/perm.20of.20permutations.html#244821779">(Jul 03 2021 at 20:00)</a>:</h4>
<p>Do we have any of these?</p>
<ul>
<li>every permutation of <code>l</code> occurs in <code>l.permutations</code></li>
<li><code>l.permutations</code> has length <code>l.length!</code></li>
<li><code>l.permutations</code> is natural in functions <code>\a -&gt; \b</code><br>
At least in principle these 3 should be enough to prove the result at the top of this thread</li>
</ul>



<a name="244821796"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/perm%20of%20permutations/near/244821796" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/perm.20of.20permutations.html#244821796">(Jul 03 2021 at 20:01)</a>:</h4>
<p>We have your first and second points certainly, at the bottom of data/list/perm</p>



<a name="244821920"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/perm%20of%20permutations/near/244821920" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/perm.20of.20permutations.html#244821920">(Jul 03 2021 at 20:04)</a>:</h4>
<p>What does "is natural" mean there?</p>



<a name="244821923"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/perm%20of%20permutations/near/244821923" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/perm.20of.20permutations.html#244821923">(Jul 03 2021 at 20:04)</a>:</h4>
<p><code>(l.map f).permutations = ...</code></p>



<a name="244821941"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/perm%20of%20permutations/near/244821941" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/perm.20of.20permutations.html#244821941">(Jul 03 2021 at 20:05)</a>:</h4>
<p>You should be able to use this to reduce to the universal case where <code>l1</code> and <code>l2</code> are permutations of <code>[1, 2, ... n]</code></p>



<a name="244821942"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/perm%20of%20permutations/near/244821942" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/perm.20of.20permutations.html#244821942">(Jul 03 2021 at 20:05)</a>:</h4>
<p>Where the <code>...</code> is <code>l.permutations.map (\lam l, l.map f)</code>?</p>



<a name="244821961"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/perm%20of%20permutations/near/244821961" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/perm.20of.20permutations.html#244821961">(Jul 03 2021 at 20:05)</a>:</h4>
<p>That does seem like an easier result to prove</p>



<a name="244823358"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/perm%20of%20permutations/near/244823358" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/perm.20of.20permutations.html#244823358">(Jul 03 2021 at 20:44)</a>:</h4>
<p>Even proving that seems challenging, although my approach was just to hope that guessing the right induction would get me where I need to be:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">list.permutations_aux_map</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">l</span> <span class="n">is</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">l.map</span> <span class="n">f</span><span class="o">)</span><span class="bp">.</span><span class="n">permutations_aux</span> <span class="o">(</span><span class="n">is.map</span> <span class="n">f</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">l.permutations_aux</span> <span class="n">is</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="o">(</span><span class="n">list.map</span> <span class="n">f</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">apply</span> <span class="bp">@</span><span class="n">list.permutations_aux.rec</span> <span class="n">_</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">l</span> <span class="n">is</span><span class="o">,</span> <span class="o">(</span><span class="n">l.map</span> <span class="n">f</span><span class="o">)</span><span class="bp">.</span><span class="n">permutations_aux</span> <span class="o">(</span><span class="n">is.map</span> <span class="n">f</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">l.permutations_aux</span> <span class="n">is</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="o">(</span><span class="n">list.map</span> <span class="n">f</span><span class="o">)),</span>
  <span class="o">{</span> <span class="n">dsimp</span><span class="o">,</span>
    <span class="n">intros</span> <span class="n">is</span><span class="o">,</span>
    <span class="n">simp</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">dsimp</span><span class="o">,</span>
    <span class="n">intros</span> <span class="n">t</span> <span class="n">ts</span> <span class="n">is</span> <span class="n">h₁</span> <span class="n">h₂</span><span class="o">,</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">h₁</span><span class="o">,</span> <span class="n">list.permutations</span><span class="o">,</span> <span class="n">h₂</span><span class="o">],</span>
    <span class="n">clear</span> <span class="n">h₁</span> <span class="n">h₂</span><span class="o">,</span>
    <span class="n">induction</span> <span class="n">is</span> <span class="k">with</span> <span class="n">h_is</span> <span class="n">t_is</span> <span class="n">ih_is</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">simp</span> <span class="o">},</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">list.map_cons</span><span class="o">,</span>
      <span class="n">list.permutations_aux2_snd_cons</span><span class="o">],</span>
    <span class="n">refine</span> <span class="o">⟨</span><span class="kd">by</span> <span class="n">simp</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
    <span class="gr">sorry</span>
    <span class="o">}</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">list.permutations_map</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">l.map</span> <span class="n">f</span><span class="o">)</span><span class="bp">.</span><span class="n">permutations</span> <span class="bp">=</span> <span class="n">l.permutations.map</span> <span class="o">(</span><span class="n">list.map</span> <span class="n">f</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">unfold</span> <span class="n">list.permutations</span><span class="o">,</span>
  <span class="n">dsimp</span><span class="o">,</span>
  <span class="n">congr</span><span class="o">,</span>
  <span class="n">convert</span> <span class="n">list.permutations_aux_map</span> <span class="n">l</span> <span class="o">[]</span> <span class="n">f</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="244824218"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/perm%20of%20permutations/near/244824218" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/perm.20of.20permutations.html#244824218">(Jul 03 2021 at 21:05)</a>:</h4>
<p>The definition of <code>permutations</code> is definitely not supposed to be observable beyond the API, because it's a very messy definition</p>



<a name="244824264"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/perm%20of%20permutations/near/244824264" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/perm.20of.20permutations.html#244824264">(Jul 03 2021 at 21:06)</a>:</h4>
<p>While lean doesn't have to worry about laziness, it does have to worry about blowing the stack, so something like the haskell definition is still required</p>



<a name="244824366"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/perm%20of%20permutations/near/244824366" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/perm.20of.20permutations.html#244824366">(Jul 03 2021 at 21:08)</a>:</h4>
<p>all the key lemmas about <code>permutations_aux</code> are proven at the end of <code>data.list.perm</code></p>



<a name="244824582"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/perm%20of%20permutations/near/244824582" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/perm.20of.20permutations.html#244824582">(Jul 03 2021 at 21:14)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110044">Chris Hughes</span> <a href="#narrow/stream/113488-general/topic/perm.20of.20permutations/near/244820390">said</a>:</p>
<blockquote>
<p>It doesn't need to be redefined but it does need more lemmas about it. The trouble is that the permutations seem to be in a strange order so there's no nice statement of <code>permuations_cons</code>. Maybe it's best to basically treat it like a multiset, and not prove any lemmas about the order.</p>
</blockquote>
<p>Indeed, although it doesn't have  <code>permutations_cons</code>, it is possible to state <code>permutations_cons</code> using <code>~</code> instead of equality</p>



<a name="244826768"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/perm%20of%20permutations/near/244826768" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/perm.20of.20permutations.html#244826768">(Jul 03 2021 at 22:12)</a>:</h4>
<p>I have a proof of <code>map_permutations</code> in <a href="https://github.com/leanprover-community/mathlib/issues/8188">#8188</a>, but I'm not sure how <span class="user-mention" data-user-id="130377">@David Wärn</span> was thinking of using it to prove the perm permutation theorem</p>



<a name="244828280"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/perm%20of%20permutations/near/244828280" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/perm.20of.20permutations.html#244828280">(Jul 03 2021 at 22:57)</a>:</h4>
<p>Those proofs are gnarly, pattern matching on <code>_match_1</code></p>



<a name="244828330"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/perm%20of%20permutations/near/244828330" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/perm.20of.20permutations.html#244828330">(Jul 03 2021 at 22:58)</a>:</h4>
<p>Are those just golfed to oblivion, or is there something going on that makes more conventional approaches tricky?</p>



<a name="244834929"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/perm%20of%20permutations/near/244834929" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/perm.20of.20permutations.html#244834929">(Jul 04 2021 at 02:05)</a>:</h4>
<p>You can form an iso between members of list.permutations l and equiv.perm of the subtype of members of l, when nodup l. Then, by a cardinality argument, l.permutations must be nodup too. Then the result at the top of this thread follows. To form the iso, one needs the cycle.form_perm that I've been working on.</p>



<a name="244849803"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/perm%20of%20permutations/near/244849803" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/perm.20of.20permutations.html#244849803">(Jul 04 2021 at 09:00)</a>:</h4>
<p>I had in mind something along the lines of</p>
<ul>
<li>prove that if <code>l.nodup</code> then <code>l.permutations.nodup</code> using a cardinality argument, like Yakov said. I think here you just need the fact that each <code>e : equiv.perm (fin l.length)</code> defines a distinct permutation of <code>l</code>.</li>
<li>If <code>l1 ~ l2</code>, then <code>l1.permutations</code> and <code>l2.permutations</code> have the same elements, not counting multiplicity. So if <code>l1.nodup</code>, then everything is <code>nodup</code>, and so <code>l1.permutations ~ l2.permutations</code>.</li>
<li>If <code>l.map f ~ t</code>, then there exists <code>l'</code> such that <code>l ~ l'</code> and <code>t = l'.map f</code>. Using this (or something else, I don't know what's in mathlib), you can prove that if <code>l1 ~ l2</code>, with <code>l1 : list \a</code>, then there exists <code>\b</code> and <code>f : \b -&gt; \a</code> and <code>l1', l2' : list \b</code> such that <code>l1 = l1'.map f</code>, <code>l2 = l2'.map f</code>, and <code>l1'.nodup</code>. Concretely you can take <code>\b = fin l1.length</code>, <code>f  i = l1.nth i</code>, <code>l1 = [0, 1, ...]</code>.</li>
<li>Deduce the original result, using <code>map_permutations</code></li>
</ul>



<a name="244856278"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/perm%20of%20permutations/near/244856278" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/perm.20of.20permutations.html#244856278">(Jul 04 2021 at 12:00)</a>:</h4>
<p>I had another stab at proving it from induction alone, but I'm running into a total lack of understanding about the semantics of <code>permutations_aux</code>, and can't work out any of the properties it has. Is this true?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">list.perm.permutations_aux</span> <span class="o">:</span>
  <span class="bp">∀</span> <span class="o">(</span><span class="n">l</span> <span class="n">i₁</span> <span class="n">i₂</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">i₁</span> <span class="bp">~</span> <span class="n">i₂</span><span class="o">),</span>
  <span class="n">l.permutations_aux</span> <span class="n">i₁</span> <span class="bp">~</span> <span class="n">l.permutations_aux</span> <span class="n">i₂</span> <span class="o">:=</span>
</code></pre></div>



<a name="244856296"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/perm%20of%20permutations/near/244856296" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/perm.20of.20permutations.html#244856296">(Jul 04 2021 at 12:01)</a>:</h4>
<p>(if anyone who does  understand <code>permutations_aux</code> could write a docstring for it, that would be amazing! Otherwise I guess I should read the thorough explanation of the haskell code that Bhavik linked to...)</p>



<a name="244857148"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/perm%20of%20permutations/near/244857148" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/perm.20of.20permutations.html#244857148">(Jul 04 2021 at 12:23)</a>:</h4>
<p>I wrote <code>permutations</code> and all the lemmas, but I can't say I have a deep understanding of what it does. For the most part, my understanding is already encoded in lemmas like <a href="https://leanprover-community.github.io/mathlib_docs/find/list.mem_foldr_permutations_aux2">docs#list.mem_foldr_permutations_aux2</a> and <a href="https://leanprover-community.github.io/mathlib_docs/find/list.mem_permutations_aux_of_perm">docs#list.mem_permutations_aux_of_perm</a> that give a sense of what the inductive invariant is</p>



<a name="244857214"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/perm%20of%20permutations/near/244857214" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/perm.20of.20permutations.html#244857214">(Jul 04 2021 at 12:25)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/113488-general/topic/perm.20of.20permutations/near/244828280">said</a>:</p>
<blockquote>
<p>Those proofs are gnarly, pattern matching on <code>_match_1</code></p>
</blockquote>
<p>What is this a reference to? I didn't do any match like that in that PR</p>



<a name="244857282"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/perm%20of%20permutations/near/244857282" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/perm.20of.20permutations.html#244857282">(Jul 04 2021 at 12:26)</a>:</h4>
<p>Oh, you are talking about <code>permutations_aux2_fst</code> et al. I didn't write those for the PR, they were just moved from data.list.perm to data.list.basic</p>



<a name="244857287"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/perm%20of%20permutations/near/244857287" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/perm.20of.20permutations.html#244857287">(Jul 04 2021 at 12:27)</a>:</h4>
<p>That kind of dependent matching is a rather old style, I think we have better tactics for doing that today but I don't feel like rewriting the proofs</p>



<a name="244857437"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/perm%20of%20permutations/near/244857437" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/perm.20of.20permutations.html#244857437">(Jul 04 2021 at 12:31)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/113488-general/topic/perm.20of.20permutations/near/244856278">said</a>:</p>
<blockquote>
<p>I had another stab at proving it from induction alone, but I'm running into a total lack of understanding about the semantics of <code>permutations_aux</code>, and can't work out any of the properties it has. Is this true?</p>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">list.perm.permutations_aux</span> <span class="o">:</span>
  <span class="bp">∀</span> <span class="o">(</span><span class="n">l</span> <span class="n">i₁</span> <span class="n">i₂</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">i₁</span> <span class="bp">~</span> <span class="n">i₂</span><span class="o">),</span>
  <span class="n">l.permutations_aux</span> <span class="n">i₁</span> <span class="bp">~</span> <span class="n">l.permutations_aux</span> <span class="n">i₂</span> <span class="o">:=</span>
</code></pre></div><br>
</p>
</blockquote>
<p>That looks like a good job for <code>slim_check</code></p>



<a name="244859296"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/perm%20of%20permutations/near/244859296" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/perm.20of.20permutations.html#244859296">(Jul 04 2021 at 13:19)</a>:</h4>
<p>I take it that means it is false</p>



<a name="244859437"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/perm%20of%20permutations/near/244859437" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/perm.20of.20permutations.html#244859437">(Jul 04 2021 at 13:23)</a>:</h4>
<p><code>slim_check</code> hangs on this because checking that two lists are <code>perm</code> works by enumerating over all appendings:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic.slim_check</span>
<span class="kn">import</span> <span class="n">data.list.perm</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">l</span> <span class="n">l'</span> <span class="o">:</span> <span class="n">list</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">l.permutations_aux</span> <span class="n">l'</span> <span class="bp">~</span> <span class="n">l.permutations_aux</span> <span class="o">(</span><span class="n">l'.rotate</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">slim_check</span>
</code></pre></div>



<a name="244859842"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/perm%20of%20permutations/near/244859842" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/perm.20of.20permutations.html#244859842">(Jul 04 2021 at 13:34)</a>:</h4>
<p>Here's a reconstruction of the argument as a literate lean file:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.list.perm</span>

<span class="kn">open</span> <span class="n">list</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span>
<span class="kd">def</span> <span class="n">foo</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">ts</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">ys</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">permutations_aux2</span> <span class="n">t</span> <span class="n">ts</span> <span class="o">[]</span> <span class="n">ys</span> <span class="n">id</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span>

<span class="c1">-- permutations_aux2 is a bunch of functorial nonsense over the foo function:</span>
<span class="kd">example</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">ts</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">ys</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">list</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">ys</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">permutations_aux2</span> <span class="n">t</span> <span class="n">ts</span> <span class="n">r</span> <span class="n">ys</span> <span class="n">f</span> <span class="bp">=</span> <span class="o">(</span><span class="n">ys</span> <span class="bp">++</span> <span class="n">ts</span><span class="o">,</span> <span class="o">(</span><span class="n">foo</span> <span class="n">t</span> <span class="n">ts</span> <span class="n">ys</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="n">f</span> <span class="bp">++</span> <span class="n">r</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">def</span> <span class="n">bar</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">ys</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="n">foo</span> <span class="n">t</span> <span class="o">[]</span> <span class="n">ys</span>

<span class="c1">-- foo is also a simple mapping of bar:</span>
<span class="kd">example</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">ts</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">ys</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">foo</span> <span class="n">t</span> <span class="n">ts</span> <span class="n">ys</span> <span class="bp">=</span> <span class="o">(</span><span class="n">bar</span> <span class="n">t</span> <span class="n">ys</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">l</span><span class="o">,</span> <span class="n">l</span> <span class="bp">++</span> <span class="n">ts</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="c1">-- bar inserts x into every position of xs except the last:</span>
<span class="k">#eval</span> <span class="n">bar</span> <span class="mi">10</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">]</span>
<span class="c1">-- [[10, 1, 2, 3], [1, 10, 2, 3], [1, 2, 10, 3]]</span>

<span class="c1">-- permutations_aux is defined using the following recursion,</span>
<span class="c1">--  where I've moved the contribution of each iteration into a separate definition:</span>
<span class="kd">def</span> <span class="n">grouping</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">ts</span> <span class="n">is</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">permutations</span> <span class="n">is</span><span class="o">)</span><span class="bp">.</span><span class="n">bind</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">ys</span><span class="o">,</span> <span class="n">foo</span> <span class="n">t</span> <span class="n">ts</span> <span class="n">ys</span><span class="o">)</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">ts</span> <span class="n">is</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">permutations_aux</span> <span class="o">(</span><span class="n">t</span> <span class="o">::</span> <span class="n">ts</span><span class="o">)</span> <span class="n">is</span> <span class="bp">=</span> <span class="n">grouping</span> <span class="n">t</span> <span class="n">ts</span> <span class="n">is</span> <span class="bp">++</span> <span class="n">permutations_aux</span> <span class="n">ts</span> <span class="o">(</span><span class="n">t</span> <span class="o">::</span> <span class="n">is</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="c1">-- You should think of `is` as a side parameter here;</span>
<span class="c1">-- just pretend `permutations is` is already defined earlier so that this</span>
<span class="c1">-- is a simple recursion on `ts`.</span>

<span class="c1">-- The one other oddity here is the definition of `permutations` itself:</span>
<span class="kd">example</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>  <span class="n">permutations</span> <span class="n">l</span> <span class="bp">=</span> <span class="n">l</span> <span class="o">::</span> <span class="n">permutations_aux</span> <span class="n">l</span> <span class="o">[]</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="c1">-- We're handling the identity permutation separately, so `permutations_aux` only deals with</span>
<span class="c1">-- the non-identity permutations. It's something like decomposing integers by powers of 10;</span>
<span class="c1">-- zero requires special handling.</span>

<span class="c1">-- So what's the big idea? We are going to partition the (non-identity) permutations</span>
<span class="c1">-- according to the longest fixed suffix. You can see that here:</span>
<span class="k">#eval</span> <span class="n">permutations</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">]</span>
<span class="c1">-- [[1, 2, 3, 4], [2, 1, 3, 4], [3, 2, 1, 4], [2, 3, 1, 4], [3, 1, 2, 4], [1, 3, 2, 4],</span>
<span class="c1">--  [4, 3, 2, 1], [3, 4, 2, 1], [3, 2, 4, 1], [4, 2, 3, 1], [2, 4, 3, 1], [2, 3, 4, 1],</span>
<span class="c1">--  [4, 1, 2, 3], [1, 4, 2, 3], [1, 2, 4, 3], [4, 2, 1, 3], [2, 4, 1, 3], [2, 1, 4, 3],</span>
<span class="c1">--  [4, 1, 3, 2], [1, 4, 3, 2], [1, 3, 4, 2], [4, 3, 1, 2], [3, 4, 1, 2], [3, 1, 4, 2]]</span>

<span class="c1">-- is partitioned like so:</span>
<span class="k">#eval</span> <span class="n">grouping</span> <span class="mi">1</span> <span class="o">[</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">]</span> <span class="o">[]</span> <span class="c1">-- []</span>
<span class="k">#eval</span> <span class="n">grouping</span> <span class="mi">2</span> <span class="o">[</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">]</span> <span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="c1">-- [[2, 1, 3, 4]]</span>
<span class="k">#eval</span> <span class="n">grouping</span> <span class="mi">3</span> <span class="o">[</span><span class="mi">4</span><span class="o">]</span> <span class="o">[</span><span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">]</span> <span class="c1">-- [[3, 2, 1, 4], [2, 3, 1, 4], [3, 1, 2, 4], [1, 3, 2, 4]]</span>
<span class="k">#eval</span> <span class="n">grouping</span> <span class="mi">4</span> <span class="o">[]</span> <span class="o">[</span><span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">]</span>
<span class="c1">-- [[4, 3, 2, 1], [3, 4, 2, 1], [3, 2, 4, 1], [4, 2, 3, 1], [2, 4, 3, 1], [2, 3, 4, 1],</span>
<span class="c1">--  [4, 1, 2, 3], [1, 4, 2, 3], [1, 2, 4, 3], [4, 2, 1, 3], [2, 4, 1, 3], [2, 1, 4, 3],</span>
<span class="c1">--  [4, 1, 3, 2], [1, 4, 3, 2], [1, 3, 4, 2], [4, 3, 1, 2], [3, 4, 1, 2], [3, 1, 4, 2]]</span>

<span class="c1">-- There no nonidentity permutations that fix 2,3,4, one permutation that fixes 3,4,</span>
<span class="c1">-- 4 permutations that fix 4, and the remaining 18 permutations don't fix 4.</span>

<span class="c1">-- So how does `grouping` accomplish this? It is defined like so:</span>
<span class="kd">example</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">ts</span> <span class="n">is</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">grouping</span> <span class="n">t</span> <span class="n">ts</span> <span class="n">is</span> <span class="bp">=</span> <span class="o">(</span><span class="n">permutations</span> <span class="n">is</span><span class="o">)</span><span class="bp">.</span><span class="n">bind</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">ys</span><span class="o">,</span> <span class="o">(</span><span class="n">bar</span> <span class="n">t</span> <span class="n">ys</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">l</span><span class="o">,</span> <span class="n">l</span> <span class="bp">++</span> <span class="n">ts</span><span class="o">))</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="c1">-- We know that `ts` is the fixed suffix, and also that `t::ts` is *not* fixed,</span>
<span class="c1">-- or else we would be in the next group. Given a permutation of `is++t::ts` that fixes `ts`</span>
<span class="c1">-- and does not fix `t::ts`, we know that `t` and `is` are mixed in some way, which we</span>
<span class="c1">-- express as a permutation of `is` with `t` inserted anywhere except the last position.</span>
<span class="c1">-- We then append `ts` at the end as required, and that's what `grouping` does.</span>

<span class="c1">-- Appending all these lists for different suffixes produces all permutations except the</span>
<span class="c1">-- identity, because we assumed that `t::ts` was not fixed so the identity permutation is</span>
<span class="c1">-- never in any of the groups. So `permutations` has to do one final fixup to put it in.</span>
</code></pre></div>



<a name="244860206"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/perm%20of%20permutations/near/244860206" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/perm.20of.20permutations.html#244860206">(Jul 04 2021 at 13:44)</a>:</h4>
<p><span class="user-mention silent" data-user-id="308899">Yakov Pechersky</span> <a href="#narrow/stream/113488-general/topic/perm.20of.20permutations/near/244859437">said</a>:</p>
<blockquote>
<p><code>slim_check</code> hangs on this because checking that two lists are <code>perm</code> works by enumerating over all appendings:</p>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic.slim_check</span>
<span class="kn">import</span> <span class="n">data.list.perm</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">l</span> <span class="n">l'</span> <span class="o">:</span> <span class="n">list</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">l.permutations_aux</span> <span class="n">l'</span> <span class="bp">~</span> <span class="n">l.permutations_aux</span> <span class="o">(</span><span class="n">l'.rotate</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">slim_check</span>
</code></pre></div><br>
</p>
</blockquote>
<p>Ooh, that's probably kernel computation coming to bite us</p>



<a name="244860210"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/perm%20of%20permutations/near/244860210" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/perm.20of.20permutations.html#244860210">(Jul 04 2021 at 13:44)</a>:</h4>
<p><code>slim_check</code> doesn't use <code>#eval</code></p>



<a name="244860422"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/perm%20of%20permutations/near/244860422" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/perm.20of.20permutations.html#244860422">(Jul 04 2021 at 13:50)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/113488-general/topic/perm.20of.20permutations/near/244859296">said</a>:</p>
<blockquote>
<p>I take it that means it is false</p>
</blockquote>
<p>Having written all that, I think that it is true. Anything that goes into the <code>is</code> argument is either an input of <code>permutations is</code> for the current group or is passed to the next iteration as <code>t::is</code>, so it will only ever be scrambled. Therefore permuting the <code>is</code> should result in a permutation of the output, and moreover it will be a permutation individually in the groups, that is, you can prove each group is separately a permutation</p>



<a name="244877618"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/perm%20of%20permutations/near/244877618" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/perm.20of.20permutations.html#244877618">(Jul 04 2021 at 21:07)</a>:</h4>
<p>Thanks for that thorough explanation <span class="user-mention" data-user-id="110049">@Mario Carneiro</span>, it was enough for me to spot the pattern!</p>
<p>I guess this statement is true then?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">permutations_concat</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">l</span> <span class="bp">++</span> <span class="o">[</span><span class="n">x</span><span class="o">])</span><span class="bp">.</span><span class="n">permutations</span> <span class="bp">=</span>
    <span class="n">l.permutations.map</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">p</span><span class="o">,</span> <span class="n">p</span> <span class="bp">++</span> <span class="o">[</span><span class="n">x</span><span class="o">])</span> <span class="bp">++</span> <span class="n">l.permutations.bind</span> <span class="o">(</span><span class="n">bar</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>



<a name="244877698"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/perm%20of%20permutations/near/244877698" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/perm.20of.20permutations.html#244877698">(Jul 04 2021 at 21:09)</a>:</h4>
<p>Edit: no, #eval tells me its false</p>



<a name="244877845"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/perm%20of%20permutations/near/244877845" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/perm.20of.20permutations.html#244877845">(Jul 04 2021 at 21:12)</a>:</h4>
<p>In which case, I'm still confused by how the order of the elements in <code>grouping 3 [4] [2, 1]</code> is determined.</p>



<a name="244882631"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/perm%20of%20permutations/near/244882631" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/perm.20of.20permutations.html#244882631">(Jul 04 2021 at 23:33)</a>:</h4>
<p><code>grouping 3 [4] [2, 1]</code> is <code>[[3, 2, 1, 4], [2, 3, 1, 4], [3, 1, 2, 4], [1, 3, 2, 4]]</code>. It is defined as:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">grouping</span> <span class="n">t</span> <span class="n">ts</span> <span class="n">is</span> <span class="bp">=</span> <span class="o">((</span><span class="n">permutations</span> <span class="n">is</span><span class="o">)</span><span class="bp">.</span><span class="n">bind</span> <span class="o">(</span><span class="n">bar</span> <span class="n">t</span><span class="o">))</span><span class="bp">.</span><span class="n">map</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">l</span><span class="o">,</span> <span class="n">l</span> <span class="bp">++</span> <span class="n">ts</span><span class="o">)</span>
</code></pre></div>
<p>So we're putting <code>[4]</code> on the end of each list, without that it's <code>[[3, 2, 1], [2, 3, 1], [3, 1, 2], [1, 3, 2]]</code>. These are obtained by taking <code>permutations [2, 1] = [[2, 1], [1, 2]]</code>, and then inserting <code>3</code>  at the first and second positions of each. Inserting <code>3</code> in <code>[2, 1]</code> yields <code>[3, 2, 1], [2, 3, 1]</code>, and inserting <code>3</code> in <code>[1, 2]</code> yields  <code>[3, 1, 2], [1, 3, 2]</code>.</p>
<p>Now the particular ordering of <code>permutations [2, 1] = [[2, 1], [1, 2]]</code> depends on a recursive call, so we're back to stage one here. This is why <code>permutations_aux</code> has such a convoluted recursor. But your inductive hypothesis should supply whatever you need to know about this function.</p>



<a name="244915158"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/perm%20of%20permutations/near/244915158" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/perm.20of.20permutations.html#244915158">(Jul 05 2021 at 09:48)</a>:</h4>
<p>Ah, it's the fact that the second argument to <code>grouping</code> is reversed that threw me off</p>



<a name="244915199"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/perm%20of%20permutations/near/244915199" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/perm.20of.20permutations.html#244915199">(Jul 05 2021 at 09:48)</a>:</h4>
<p>The true version of my statement appears to be</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">abbreviation</span> <span class="n">permutations_concat_statement</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
  <span class="o">(</span><span class="n">l</span> <span class="bp">++</span> <span class="o">[</span><span class="n">x</span><span class="o">])</span><span class="bp">.</span><span class="n">permutations</span> <span class="bp">=</span>
    <span class="n">l.permutations.map</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">p</span><span class="o">,</span> <span class="n">p</span> <span class="bp">++</span> <span class="o">[</span><span class="n">x</span><span class="o">])</span> <span class="bp">++</span> <span class="n">l.reverse.permutations.bind</span> <span class="o">(</span><span class="n">bar</span> <span class="n">x</span><span class="o">)</span>

<span class="k">#eval</span> <span class="o">(</span><span class="n">permutations_concat_statement</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">]</span> <span class="mi">4</span> <span class="o">:</span> <span class="n">bool</span><span class="o">)</span>
<span class="k">#eval</span> <span class="o">(</span><span class="n">permutations_concat_statement</span> <span class="o">[]</span> <span class="mi">4</span> <span class="o">:</span> <span class="n">bool</span><span class="o">)</span>
</code></pre></div>



<a name="244915245"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/perm%20of%20permutations/near/244915245" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/perm.20of.20permutations.html#244915245">(Jul 05 2021 at 09:49)</a>:</h4>
<p>I assume the <code>.reverse</code> in there for some efficiency reason regarding assembling lists</p>



<a name="244921780"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/perm%20of%20permutations/near/244921780" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/perm.20of.20permutations.html#244921780">(Jul 05 2021 at 11:01)</a>:</h4>
<p>This looks like it will probably help with <code>permutations_aux2</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/-- The `ts`, `r`, and `f` arguments of `permutations_aux2` are just post-processing. -/</span>
<span class="kd">lemma</span> <span class="n">permutations_aux2_snd_f</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">ts</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">ys</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">list</span> <span class="n">β</span><span class="o">)</span>
  <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span>
    <span class="o">(</span><span class="n">permutations_aux2</span> <span class="n">t</span> <span class="n">ts</span> <span class="n">r</span> <span class="n">ys</span> <span class="n">f</span><span class="o">)</span><span class="bp">.</span><span class="n">snd</span> <span class="bp">=</span>
      <span class="o">(</span><span class="n">permutations_aux2</span> <span class="n">t</span> <span class="o">[]</span> <span class="o">[]</span> <span class="n">ys</span> <span class="n">id</span><span class="o">)</span><span class="bp">.</span><span class="n">snd.map</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">xs</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">xs</span> <span class="bp">++</span> <span class="n">ts</span><span class="o">))</span> <span class="bp">++</span> <span class="n">r</span> <span class="o">:=</span>
<span class="k">calc</span> <span class="o">(</span><span class="n">permutations_aux2</span> <span class="n">t</span> <span class="n">ts</span> <span class="n">r</span> <span class="n">ys</span> <span class="n">f</span><span class="o">)</span><span class="bp">.</span><span class="n">snd</span>
     <span class="bp">=</span> <span class="o">(</span><span class="n">permutations_aux2</span> <span class="n">t</span> <span class="n">ts</span> <span class="o">[]</span> <span class="n">ys</span> <span class="n">f</span><span class="o">)</span><span class="bp">.</span><span class="n">snd</span> <span class="bp">++</span> <span class="n">r</span> <span class="o">:</span> <span class="kd">begin</span>
       <span class="n">induction</span> <span class="n">ys</span> <span class="k">with</span> <span class="n">y</span> <span class="n">ys</span> <span class="n">generalizing</span> <span class="n">f</span><span class="o">,</span>
       <span class="o">{</span> <span class="n">simp</span> <span class="o">},</span>
       <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">ys_ih</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">xs</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">y</span> <span class="o">::</span> <span class="n">xs</span><span class="o">))]</span> <span class="o">}</span>
     <span class="kd">end</span>
 <span class="bp">...</span> <span class="bp">=</span> <span class="o">(</span><span class="n">permutations_aux2</span> <span class="n">t</span> <span class="n">ts</span> <span class="o">[]</span> <span class="n">ys</span> <span class="n">id</span><span class="o">)</span><span class="bp">.</span><span class="n">snd.map</span> <span class="n">f</span> <span class="bp">++</span> <span class="n">r</span> <span class="o">:</span> <span class="kd">begin</span>
       <span class="n">congr'</span> <span class="mi">1</span><span class="o">,</span>
       <span class="n">convert</span> <span class="o">(</span><span class="n">map_permutations_aux2'</span> <span class="n">id</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="bp">;</span> <span class="n">simp</span><span class="o">,</span>
     <span class="kd">end</span>
 <span class="bp">...</span> <span class="bp">=</span> <span class="o">(</span><span class="n">permutations_aux2</span> <span class="n">t</span> <span class="o">[]</span> <span class="o">[]</span> <span class="n">ys</span> <span class="n">id</span><span class="o">)</span><span class="bp">.</span><span class="n">snd.map</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">xs</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">xs</span> <span class="bp">++</span> <span class="n">ts</span><span class="o">))</span> <span class="bp">++</span> <span class="n">r</span> <span class="o">:</span> <span class="kd">begin</span>
       <span class="n">rw</span> <span class="bp">←</span><span class="n">map_map</span> <span class="n">f</span> <span class="o">(</span><span class="bp">++</span> <span class="n">ts</span><span class="o">),</span>
       <span class="n">congr'</span> <span class="mi">2</span><span class="o">,</span>
       <span class="n">induction</span> <span class="n">ys</span><span class="o">,</span>
       <span class="o">{</span> <span class="n">simp</span> <span class="o">},</span>
       <span class="n">simp</span><span class="o">,</span>
       <span class="gr">sorry</span><span class="o">,</span>
      <span class="c1">--  convert (map_permutations_aux2' _ _ _ _ _ _ _ _ _).symm,</span>
     <span class="kd">end</span>
</code></pre></div>
<p>Unfortunately I'm not sure how to show the <code>sorry</code>.</p>



<a name="244923400"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/perm%20of%20permutations/near/244923400" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/perm.20of.20permutations.html#244923400">(Jul 05 2021 at 11:19)</a>:</h4>
<p>does</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>       <span class="n">induction</span> <span class="n">ts</span><span class="o">,</span>
       <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">append_nil</span><span class="o">],</span>
       <span class="n">rw</span> <span class="n">map_permutations_aux2'</span> <span class="n">id</span><span class="o">,</span>
       <span class="n">simp</span><span class="o">,</span>
       <span class="n">intro</span><span class="o">,</span> <span class="n">rw</span> <span class="n">map_id</span><span class="o">,</span>
</code></pre></div>
<p>make any useful progress? I don't really understand <code>permutations_aux2</code> so I went for "goal-driven development"</p>



<a name="244927630"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/perm%20of%20permutations/near/244927630" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/perm.20of.20permutations.html#244927630">(Jul 05 2021 at 12:04)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">{</span><span class="n">t</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">ts</span> <span class="n">ys</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hg</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">l₁</span> <span class="n">l₂</span><span class="o">,</span> <span class="n">g</span> <span class="o">(</span><span class="n">l₁</span> <span class="bp">++</span> <span class="n">l₂</span><span class="o">)</span> <span class="bp">=</span> <span class="n">g</span> <span class="n">l₁</span> <span class="bp">++</span> <span class="n">l₂</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">permutations_aux2</span> <span class="n">t</span> <span class="n">ts</span> <span class="o">[]</span> <span class="n">ys</span> <span class="n">g</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span><span class="bp">.</span><span class="n">map</span> <span class="n">f</span> <span class="bp">=</span>
    <span class="o">(</span><span class="n">permutations_aux2</span> <span class="n">t</span> <span class="o">[]</span> <span class="o">[]</span> <span class="n">ys</span> <span class="n">g</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span><span class="bp">.</span><span class="n">map</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">xs</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">xs</span> <span class="bp">++</span> <span class="n">ts</span><span class="o">))</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">induction</span> <span class="n">ys</span> <span class="n">generalizing</span> <span class="n">g</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="o">},</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">true_and</span><span class="o">,</span> <span class="n">id.def</span><span class="o">,</span> <span class="n">map</span><span class="o">,</span> <span class="n">eq_self_iff_true</span><span class="o">,</span> <span class="n">permutations_aux2_snd_cons</span><span class="o">,</span> <span class="n">append_nil</span><span class="o">],</span>
  <span class="n">refine</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="n">hg</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="n">ys_ih</span><span class="o">,</span>
    <span class="n">intros</span> <span class="n">l₁</span> <span class="n">l₂</span><span class="o">,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span><span class="n">cons_append</span><span class="o">,</span> <span class="n">hg</span><span class="o">]</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>
<p>Solves your sorry Eric! By the way, your first begin/end in the calc is already in mathlib: <code>permutations_aux2_append</code></p>



<a name="244931090"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/perm%20of%20permutations/near/244931090" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/perm.20of.20permutations.html#244931090">(Jul 05 2021 at 12:40)</a>:</h4>
<p>There are already lemmas which eliminate the <code>f</code> and <code>r</code> parameters of <code>permutations_aux2</code>, so you don't need them in the lemma statement. It's a lot easier to tackle these arguments one at a time</p>



<a name="244931322"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/perm%20of%20permutations/near/244931322" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/perm.20of.20permutations.html#244931322">(Jul 05 2021 at 12:42)</a>:</h4>
<p>Actually, I don't think it's worth eliminating the <code>ts</code> argument. In the context of <code>grouping</code>, the <code>foo</code> function makes a bit more sense than <code>bar</code>: we have a list <code>is ++ t :: ts</code> and are permuting the left half of it and moving <code>t</code> out of place</p>



<a name="244932055"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/perm%20of%20permutations/near/244932055" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/perm.20of.20permutations.html#244932055">(Jul 05 2021 at 12:51)</a>:</h4>
<p>Perhaps this is the lemma that's missing then?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/-- The `ts` argument to `permutations_aux2` can be folded into the `f` argument. -/</span>
<span class="kd">lemma</span> <span class="n">permutations_aux2_comp_append</span> <span class="o">{</span><span class="n">t</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">ts</span> <span class="n">ys</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">r</span> <span class="o">:</span> <span class="n">list</span> <span class="n">β</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">permutations_aux2</span> <span class="n">t</span> <span class="o">[]</span> <span class="n">r</span> <span class="n">ys</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">x</span> <span class="bp">++</span> <span class="n">ts</span><span class="o">))</span><span class="bp">.</span><span class="mi">2</span> <span class="bp">=</span> <span class="o">(</span><span class="n">permutations_aux2</span> <span class="n">t</span> <span class="n">ts</span> <span class="n">r</span> <span class="n">ys</span> <span class="n">f</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">symmetry</span><span class="o">,</span>
  <span class="n">induction</span> <span class="n">ys</span> <span class="n">generalizing</span> <span class="n">f</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="o">},</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">true_and</span><span class="o">,</span> <span class="n">id.def</span><span class="o">,</span> <span class="n">map</span><span class="o">,</span> <span class="n">eq_self_iff_true</span><span class="o">,</span> <span class="n">permutations_aux2_snd_cons</span><span class="o">,</span> <span class="n">append_nil</span><span class="o">],</span>
  <span class="n">refine</span> <span class="n">ys_ih</span> <span class="n">_</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="244932209"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/perm%20of%20permutations/near/244932209" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/perm.20of.20permutations.html#244932209">(Jul 05 2021 at 12:52)</a>:</h4>
<p>Stated backwards to match <a href="https://leanprover-community.github.io/mathlib_docs/find/list.permutations_aux2_append">docs#list.permutations_aux2_append</a></p>



<a name="244933101"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/perm%20of%20permutations/near/244933101" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/perm.20of.20permutations.html#244933101">(Jul 05 2021 at 13:01)</a>:</h4>
<p>Looking again, I actually don't see a lemma that says that <code>f</code> can be eliminated, but most of the lemmas are about <code>f = id</code> so apparently they (that is, past me) managed to get around it</p>



<a name="244933253"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/perm%20of%20permutations/near/244933253" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/perm.20of.20permutations.html#244933253">(Jul 05 2021 at 13:03)</a>:</h4>
<p>I'll add the lemma that eliminates <code>f</code> too, even if it doesn't get used - it's good for explaining what the function does</p>



<a name="244933586"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/perm%20of%20permutations/near/244933586" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/perm.20of.20permutations.html#244933586">(Jul 05 2021 at 13:06)</a>:</h4>
<p>Isn't <code>map_permutations_aux2'</code> the one that eliminates <code>f</code>?</p>



<a name="244933604"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/perm%20of%20permutations/near/244933604" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/perm.20of.20permutations.html#244933604">(Jul 05 2021 at 13:06)</a>:</h4>
<p>Yes, but it's stated very generally which makes it hard to apply</p>



<a name="244935549"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/perm%20of%20permutations/near/244935549" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/perm.20of.20permutations.html#244935549">(Jul 05 2021 at 13:26)</a>:</h4>
<p>The yellow bars are stuck in "refresh every time I hit a key" mode so this is taking forever</p>



<a name="244935684"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/perm%20of%20permutations/near/244935684" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/perm.20of.20permutations.html#244935684">(Jul 05 2021 at 13:27)</a>:</h4>
<p>Do you have any other open files?</p>



<a name="244935702"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/perm%20of%20permutations/near/244935702" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/perm.20of.20permutations.html#244935702">(Jul 05 2021 at 13:27)</a>:</h4>
<p>They're all "plaintext" files</p>



<a name="244935724"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/perm%20of%20permutations/near/244935724" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/perm.20of.20permutations.html#244935724">(Jul 05 2021 at 13:27)</a>:</h4>
<p>Although only because I told Vscode to not process them as lean any more</p>



<a name="244935735"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/perm%20of%20permutations/near/244935735" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/perm.20of.20permutations.html#244935735">(Jul 05 2021 at 13:27)</a>:</h4>
<p>They're also all unsaved anonymous buffers</p>



<a name="244935788"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/perm%20of%20permutations/near/244935788" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/perm.20of.20permutations.html#244935788">(Jul 05 2021 at 13:28)</a>:</h4>
<p>Aha</p>



<a name="244935819"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/perm%20of%20permutations/near/244935819" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/perm.20of.20permutations.html#244935819">(Jul 05 2021 at 13:28)</a>:</h4>
<p>For me, it usually worked to restart VScode with only 1 file open.</p>



<a name="244935893"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/perm%20of%20permutations/near/244935893" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/perm.20of.20permutations.html#244935893">(Jul 05 2021 at 13:29)</a>:</h4>
<p>I restarted vscode, reopening to 1 lean file + 5 plaintext buffers and it still behaves poorly.</p>



<a name="244935946"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/perm%20of%20permutations/near/244935946" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/perm.20of.20permutations.html#244935946">(Jul 05 2021 at 13:29)</a>:</h4>
<p>Maybe CI can build for me: <a href="https://github.com/leanprover-community/mathlib/issues/8198">#8198</a></p>



<a name="248824767"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/perm%20of%20permutations/near/248824767" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/perm.20of.20permutations.html#248824767">(Aug 09 2021 at 09:49)</a>:</h4>
<p>Done in <a href="https://github.com/leanprover-community/mathlib/issues/8587">#8587</a> <span aria-label="tada" class="emoji emoji-1f389" role="img" title="tada">:tada:</span></p>



<a name="248824915"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/perm%20of%20permutations/near/248824915" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/perm.20of.20permutations.html#248824915">(Aug 09 2021 at 09:51)</a>:</h4>
<p>That PR also introduces <code>list.permutations'</code> which has much more straightforward equations:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[simp]</span> <span class="kd">def</span> <span class="n">permutations'_aux</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">list</span> <span class="o">(</span><span class="n">list</span> <span class="n">α</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">[]</span>      <span class="o">:=</span> <span class="o">[[</span><span class="n">t</span><span class="o">]]</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">y</span><span class="o">::</span><span class="n">ys</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">t</span> <span class="o">::</span> <span class="n">y</span> <span class="o">::</span> <span class="n">ys</span><span class="o">)</span> <span class="o">::</span> <span class="o">(</span><span class="n">permutations'_aux</span> <span class="n">ys</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="o">(</span><span class="n">cons</span> <span class="n">y</span><span class="o">)</span>

<span class="kd">@[simp]</span> <span class="kd">def</span> <span class="n">permutations'</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">list</span> <span class="o">(</span><span class="n">list</span> <span class="n">α</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="o">:=</span> <span class="o">[[]]</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">t</span><span class="o">::</span><span class="n">ts</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">permutations'</span> <span class="n">ts</span><span class="o">)</span><span class="bp">.</span><span class="n">bind</span> <span class="bp">$</span> <span class="n">permutations'_aux</span> <span class="n">t</span>
</code></pre></div>



<a name="248826611"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/perm%20of%20permutations/near/248826611" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/perm.20of.20permutations.html#248826611">(Aug 09 2021 at 10:13)</a>:</h4>
<p>Oh wow! I was genuinely banging my hand against this problem.</p>



<a name="248826714"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/perm%20of%20permutations/near/248826714" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/perm.20of.20permutations.html#248826714">(Aug 09 2021 at 10:14)</a>:</h4>
<p><span class="user-mention" data-user-id="308899">@Yakov Pechersky</span>, it's Christmas before December!</p>



<a name="248826830"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/perm%20of%20permutations/near/248826830" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/perm.20of.20permutations.html#248826830">(Aug 09 2021 at 10:16)</a>:</h4>
<p>I was wondering, what's the difference in practice between a new inductive definition and a new recursor? Could you have proven <code>perm.permutations</code> with just the new recursor?</p>



<a name="248826896"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/perm%20of%20permutations/near/248826896" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/perm.20of.20permutations.html#248826896">(Aug 09 2021 at 10:17)</a>:</h4>
<p>no, because <code>list.permutations'</code> is not equal to <code>list.permutations</code></p>



<a name="248826950"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/perm%20of%20permutations/near/248826950" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/perm.20of.20permutations.html#248826950">(Aug 09 2021 at 10:18)</a>:</h4>
<p>it is a complicated permutation thereof</p>



<a name="248827025"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/perm%20of%20permutations/near/248827025" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/perm.20of.20permutations.html#248827025">(Aug 09 2021 at 10:20)</a>:</h4>
<p>If you replaced <code>=</code> with <code>~</code> everywhere, then possibly, however all of the theorems expressing list.permutation in terms of permutations of pieces of itself only come after all the main lemmas are proven, so it's no good for proving the theorem itself</p>



<a name="248827124"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/perm%20of%20permutations/near/248827124" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/perm.20of.20permutations.html#248827124">(Aug 09 2021 at 10:20)</a>:</h4>
<p>I think the key lemma that is actually true about <code>list.permutations</code> and doesn't need <code>~</code> is this one:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">permutations_append</span> <span class="o">(</span><span class="n">is</span> <span class="n">ts</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">permutations</span> <span class="o">(</span><span class="n">is</span> <span class="bp">++</span> <span class="n">ts</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">permutations</span> <span class="n">is</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="o">(</span><span class="bp">++</span> <span class="n">ts</span><span class="o">)</span> <span class="bp">++</span> <span class="n">permutations_aux</span> <span class="n">ts</span> <span class="n">is.reverse</span> <span class="o">:=</span>
</code></pre></div>



<a name="248827600"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/perm%20of%20permutations/near/248827600" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/perm.20of.20permutations.html#248827600">(Aug 09 2021 at 10:27)</a>:</h4>
<p>In terms of the description up thread, <code>permutations_aux</code> is defined as an append of a bunch of <code>grouping</code>s, satisfying the recursion <code>permutations_aux (t :: ts) is = grouping ts t is ++ permutations_aux ts (t :: is)</code>, so this suggests that you can also collect the groupings from the left, to define <code>permutations_left (t :: is) ts = permutations_left is (t :: ts) ++ grouping ts t is</code> such that <code>permutations_left ts is ++ permutations_aux ts is = permutations (ts ++ is.reverse)</code>. Then observe that every element of <code>permutations_left</code> is supposed to fix <code>ts</code>, so it can be factored as <code>permutations_left is ts = (???).map (++ ts)</code>, and by great good luck (or simple consideration of the defining equation) <code>???</code> turns out to be <code>permutations is</code> itself, so you get this lovely equation</p>



<a name="248827961"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/perm%20of%20permutations/near/248827961" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/perm.20of.20permutations.html#248827961">(Aug 09 2021 at 10:31)</a>:</h4>
<p>If you plug in <code>ts = [t]</code>, it simplifies to this slightly awkward theorem (cut from the final version):</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">permutations_concat</span> <span class="o">(</span><span class="n">t</span><span class="o">)</span> <span class="o">(</span><span class="n">ts</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">permutations</span> <span class="o">(</span><span class="n">ts</span> <span class="bp">++</span> <span class="o">[</span><span class="n">t</span><span class="o">])</span> <span class="bp">=</span> <span class="o">(</span><span class="n">permutations</span> <span class="n">ts</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="o">(</span><span class="bp">++</span> <span class="o">[</span><span class="n">t</span><span class="o">])</span> <span class="bp">++</span>
  <span class="n">ts.reverse.permutations.bind</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">ys</span><span class="o">,</span> <span class="o">(</span><span class="n">permutations_aux2</span> <span class="n">t</span> <span class="o">[]</span> <span class="o">[]</span> <span class="n">ys</span> <span class="n">id</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span><span class="o">)</span> <span class="o">:=</span>
</code></pre></div>
<p>The <code>ts.reverse.permutations</code> that occurs here is why <code>list.permutations</code> has such terrible equations, because it's reversing the permutations for some of it and not for other parts, so it's hard to see what this does until you already have <code>perm.permutations</code></p>



<a name="248828280"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/perm%20of%20permutations/near/248828280" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/perm.20of.20permutations.html#248828280">(Aug 09 2021 at 10:35)</a>:</h4>
<p>but if you assume that <code>ts.reverse.permutations</code> is a permutation of <code>ts.permutations</code> then this simplifies to</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">permutations_perm_lem1</span> <span class="o">(</span><span class="n">t</span><span class="o">)</span> <span class="o">(</span><span class="n">ts</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">permutations</span> <span class="n">ts</span> <span class="bp">~</span> <span class="n">ts.reverse.permutations</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">permutations</span> <span class="o">(</span><span class="n">ts</span> <span class="bp">++</span> <span class="o">[</span><span class="n">t</span><span class="o">])</span> <span class="bp">~</span> <span class="n">ts.permutations.bind</span> <span class="o">(</span><span class="n">permutations'_aux</span> <span class="n">t</span><span class="o">)</span> <span class="o">:=</span>
</code></pre></div>
<p>because <code>permutations'_aux t ys = (permutations_aux2 t [] [] ys id).2 ++ [ys ++ [t]]</code>, and at this point we are basically done because this is the defining equation for <code>permutations'</code> (and we can prove <code>perm.permutations'</code> directly without too much trouble)</p>



<a name="248828558"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/perm%20of%20permutations/near/248828558" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/perm.20of.20permutations.html#248828558">(Aug 09 2021 at 10:39)</a>:</h4>
<p>This is excellent, thanks Mario!</p>



<a name="248832890"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/perm%20of%20permutations/near/248832890" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/perm.20of.20permutations.html#248832890">(Aug 09 2021 at 11:31)</a>:</h4>
<p>Wonderful, thanks Mario! In particular I like the double induction on the length of ts and then the reverse induction.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
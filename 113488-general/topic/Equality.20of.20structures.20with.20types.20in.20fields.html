---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/Equality.20of.20structures.20with.20types.20in.20fields.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Equality.20of.20structures.20with.20types.20in.20fields.html">Equality of structures with types in fields</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="217501642"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Equality%20of%20structures%20with%20types%20in%20fields/near/217501642" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Peter Nelson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Equality.20of.20structures.20with.20types.20in.20fields.html#217501642">(Nov 21 2020 at 13:21)</a>:</h4>
<p>I'm having problems proving equality of somewhat simple structures without heq rearing its ugly head. To encapsulate some of them in a concrete question, how do I prove the following? </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code> <span class="kd">structure</span> <span class="n">test</span> <span class="o">:=</span>
  <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span>
  <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">t</span> <span class="bp">→</span> <span class="n">ℤ</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">shift</span> <span class="o">(</span><span class="n">T</span> <span class="o">:</span> <span class="n">test</span><span class="o">)</span> <span class="o">:</span> <span class="n">test</span> <span class="o">:=</span> <span class="o">{</span>
  <span class="n">t</span> <span class="o">:=</span> <span class="n">T.t</span><span class="o">,</span>
  <span class="n">f</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">T.f</span> <span class="n">x</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">,</span>
<span class="o">}</span>

<span class="kd">lemma</span> <span class="n">shift_inj</span> <span class="o">(</span><span class="n">T₁</span> <span class="n">T₂</span> <span class="o">:</span> <span class="n">test</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">shift</span> <span class="n">T₁</span> <span class="bp">=</span> <span class="n">shift</span> <span class="n">T₂</span> <span class="bp">→</span> <span class="n">T₁</span> <span class="bp">=</span> <span class="n">T₂</span> <span class="o">:=</span>
  <span class="kd">begin</span>
    <span class="n">sorry</span><span class="o">,</span>
  <span class="kd">end</span>
</code></pre></div>



<a name="217502177"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Equality%20of%20structures%20with%20types%20in%20fields/near/217502177" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Equality.20of.20structures.20with.20types.20in.20fields.html#217502177">(Nov 21 2020 at 13:39)</a>:</h4>
<p>The standard answer is to try to avoid type equality. </p>
<p>A better option is to define morphisms for your structure, and construct isomorphisms instead of equalities.</p>



<a name="217502247"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Equality%20of%20structures%20with%20types%20in%20fields/near/217502247" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Equality.20of.20structures.20with.20types.20in.20fields.html#217502247">(Nov 21 2020 at 13:41)</a>:</h4>
<p>In this particular case, you can probably use <code>subst</code> to prove your lemma</p>



<a name="217504071"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Equality%20of%20structures%20with%20types%20in%20fields/near/217504071" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Equality.20of.20structures.20with.20types.20in.20fields.html#217504071">(Nov 21 2020 at 14:31)</a>:</h4>
<p>[not recommended]</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span> <span class="n">data.int.basic</span>

<span class="kd">structure</span> <span class="n">test</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span>
<span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">t</span> <span class="bp">→</span> <span class="n">ℤ</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">shift</span> <span class="o">(</span><span class="n">T</span> <span class="o">:</span> <span class="n">test</span><span class="o">)</span> <span class="o">:</span> <span class="n">test</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">t</span> <span class="o">:=</span> <span class="n">T.t</span><span class="o">,</span>
  <span class="n">f</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">T.f</span> <span class="n">x</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">}</span>

<span class="kd">lemma</span> <span class="n">shift_inj</span> <span class="o">(</span><span class="n">T₁</span> <span class="n">T₂</span> <span class="o">:</span> <span class="n">test</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">shift</span> <span class="n">T₁</span> <span class="bp">=</span> <span class="n">shift</span> <span class="n">T₂</span><span class="o">)</span> <span class="o">:</span> <span class="n">T₁</span> <span class="bp">=</span> <span class="n">T₂</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">cases</span> <span class="n">T₁</span><span class="o">,</span> <span class="n">cases</span> <span class="n">T₂</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">:</span> <span class="n">T₁_t</span> <span class="bp">=</span> <span class="n">T₂_t</span> <span class="o">:=</span> <span class="n">congr_arg</span> <span class="n">test.t</span> <span class="n">h</span><span class="o">,</span> <span class="n">subst</span> <span class="n">this</span><span class="o">,</span>
  <span class="n">congr'</span> <span class="mi">1</span><span class="o">,</span>
  <span class="n">ext</span><span class="o">,</span>
  <span class="n">refine</span> <span class="n">add_right_cancel</span> <span class="o">(</span><span class="n">_</span> <span class="o">:</span> <span class="n">_</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">_</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">),</span>
  <span class="n">change</span> <span class="o">(</span><span class="n">shift</span> <span class="o">⟨</span><span class="n">T₁_t</span><span class="o">,</span> <span class="n">T₁_f</span><span class="o">⟩)</span><span class="bp">.</span><span class="n">f</span> <span class="n">x</span> <span class="bp">=</span> <span class="o">(</span><span class="n">shift</span> <span class="o">⟨</span><span class="n">T₁_t</span><span class="o">,</span> <span class="n">T₂_f</span><span class="o">⟩)</span><span class="bp">.</span><span class="n">f</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">congr_fun</span> <span class="o">(</span><span class="n">eq_of_heq</span> <span class="bp">$</span> <span class="n">congr_arg_heq</span> <span class="n">test.f</span> <span class="n">h</span><span class="o">)</span> <span class="n">x</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="217504277"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Equality%20of%20structures%20with%20types%20in%20fields/near/217504277" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Peter Nelson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Equality.20of.20structures.20with.20types.20in.20fields.html#217504277">(Nov 21 2020 at 14:36)</a>:</h4>
<p>Thanks! I take it from your answers that there is no idiomatic way to do such a thing. </p>
<p>I've certainly tried to avoid type equality - where I am is the result of a lot of agonising. This is part of a setting where 'equal' and 'isomorphic' are different, and being unable to <code>rw</code> with equal objects will be a serious problem for even the simplest things. My hope is that this ugliness will be confined to the proofs in an API.</p>



<a name="217504302"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Equality%20of%20structures%20with%20types%20in%20fields/near/217504302" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Equality.20of.20structures.20with.20types.20in.20fields.html#217504302">(Nov 21 2020 at 14:37)</a>:</h4>
<p>what is the context?</p>



<a name="217504306"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Equality%20of%20structures%20with%20types%20in%20fields/near/217504306" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Equality.20of.20structures.20with.20types.20in.20fields.html#217504306">(Nov 21 2020 at 14:37)</a>:</h4>
<p>If you don't bundle the type <code>t</code> then it's perfectly nice and easy to speak about equality of the associated <code>f</code></p>



<a name="217504541"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Equality%20of%20structures%20with%20types%20in%20fields/near/217504541" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Peter Nelson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Equality.20of.20structures.20with.20types.20in.20fields.html#217504541">(Nov 21 2020 at 14:45)</a>:</h4>
<p>The context is matroids. A matroid is a finite set E bundled with some extra structure, and a matroid M has minors, which are structures on subsets of E. </p>
<p>Two minors are equal if they are propeq structures on propeq subsets of E.  </p>
<p>Two minors on different subsets F,F' of E might be isomorphic, while not being equal, if there is a structure-preserving bijection between F and F'. </p>
<p>Both isomorphism and equality are important concepts, but they aren't the same.</p>



<a name="217504651"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Equality%20of%20structures%20with%20types%20in%20fields/near/217504651" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Equality.20of.20structures.20with.20types.20in.20fields.html#217504651">(Nov 21 2020 at 14:48)</a>:</h4>
<p>And the bundled type is the <code>subtype</code> of the subset of E?</p>



<a name="217504657"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Equality%20of%20structures%20with%20types%20in%20fields/near/217504657" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Equality.20of.20structures.20with.20types.20in.20fields.html#217504657">(Nov 21 2020 at 14:48)</a>:</h4>
<p>If so this isn't going to work because you can't prove that different subsets of E yield unequal types</p>



<a name="217504788"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Equality%20of%20structures%20with%20types%20in%20fields/near/217504788" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Equality.20of.20structures.20with.20types.20in.20fields.html#217504788">(Nov 21 2020 at 14:53)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/113488-general/topic/Equality.20of.20structures.20with.20types.20in.20fields/near/217504657">said</a>:</p>
<blockquote>
<p>If so this isn't going to work because you can't prove that different subsets of E yield unequal types</p>
</blockquote>
<p>I'm not very sure about that</p>



<a name="217504795"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Equality%20of%20structures%20with%20types%20in%20fields/near/217504795" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Equality.20of.20structures.20with.20types.20in.20fields.html#217504795">(Nov 21 2020 at 14:53)</a>:</h4>
<p>edit: never mind</p>



<a name="217504803"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Equality%20of%20structures%20with%20types%20in%20fields/near/217504803" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Peter Nelson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Equality.20of.20structures.20with.20types.20in.20fields.html#217504803">(Nov 21 2020 at 14:53)</a>:</h4>
<p>We're implementing this differently, using a bespoke boolean algebra type that suits the structure. I don't know if the same issue holds there - I will need to discuss this with my coauthors. </p>
<p>In any case, I don't think one can argue that what I want is mathematically unnatural. If there is a better way to implement it I'd be happy to know it.</p>



<a name="217504848"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Equality%20of%20structures%20with%20types%20in%20fields/near/217504848" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Equality.20of.20structures.20with.20types.20in.20fields.html#217504848">(Nov 21 2020 at 14:54)</a>:</h4>
<p>It's unnatural to record a subset of E as a type</p>



<a name="217504856"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Equality%20of%20structures%20with%20types%20in%20fields/near/217504856" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Equality.20of.20structures.20with.20types.20in.20fields.html#217504856">(Nov 21 2020 at 14:54)</a>:</h4>
<p>because that "forgets the embedding into E"</p>



<a name="217504865"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Equality%20of%20structures%20with%20types%20in%20fields/near/217504865" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Equality.20of.20structures.20with.20types.20in.20fields.html#217504865">(Nov 21 2020 at 14:55)</a>:</h4>
<p>you can record it as a <code>set E</code>, or as a type with an injection to E (in which case isomorphism of the type+injection is what you call "equality")</p>



<a name="217504990"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Equality%20of%20structures%20with%20types%20in%20fields/near/217504990" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Peter Nelson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Equality.20of.20structures.20with.20types.20in.20fields.html#217504990">(Nov 21 2020 at 14:59)</a>:</h4>
<p>We are using a type with injection. </p>
<p>If we use isomorphism to encode mathematical equality, then I anticipate very simple things (if a complicated theorem statement applies to one minor N, it applies to a minor N' with N = N') being unwieldy. </p>
<p>Also, how does one implement isomorphism in the mathematical sense, if isomorphism in lean is a stronger notion that corresponds to mathematical equality ? </p>
<p>(I'm certainly not arguing that my implementation is natural, by the way - just that what I want out of 'equal' is).</p>



<a name="217505041"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Equality%20of%20structures%20with%20types%20in%20fields/near/217505041" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Equality.20of.20structures.20with.20types.20in.20fields.html#217505041">(Nov 21 2020 at 15:00)</a>:</h4>
<p>I think you found that things became even more unwieldy when you tried to use equality of types <span aria-label="upside down" class="emoji emoji-1f643" role="img" title="upside down">:upside_down:</span></p>



<a name="217505055"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Equality%20of%20structures%20with%20types%20in%20fields/near/217505055" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Equality.20of.20structures.20with.20types.20in.20fields.html#217505055">(Nov 21 2020 at 15:01)</a>:</h4>
<p>There's isomorphism over E as well as isomorphism over an isomorphism of E.</p>



<a name="217505070"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Equality%20of%20structures%20with%20types%20in%20fields/near/217505070" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Peter Nelson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Equality.20of.20structures.20with.20types.20in.20fields.html#217505070">(Nov 21 2020 at 15:02)</a>:</h4>
<p>Hard to argue with that. Again, I'm (perhaps naively) hoping to hide this in an API and leave a reasonable user-facing interface.</p>



<a name="217505264"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Equality%20of%20structures%20with%20types%20in%20fields/near/217505264" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Equality.20of.20structures.20with.20types.20in.20fields.html#217505264">(Nov 21 2020 at 15:06)</a>:</h4>
<p>IMO the natural thing to do is to mimic the way, e.g., groups and bundled subgroups are defined in mathlib. This should certainly work for the mathematical definition of matroids that I know...</p>



<a name="217505669"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Equality%20of%20structures%20with%20types%20in%20fields/near/217505669" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Equality.20of.20structures.20with.20types.20in.20fields.html#217505669">(Nov 21 2020 at 15:18)</a>:</h4>
<p>Oh sorry, I see it's more complicated since there is some localization going on when defining a "minor" of a matroid. But it can still be done using some inductive type, I guess.</p>



<a name="217505766"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Equality%20of%20structures%20with%20types%20in%20fields/near/217505766" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Equality.20of.20structures.20with.20types.20in.20fields.html#217505766">(Nov 21 2020 at 15:21)</a>:</h4>
<p>Assuming that what you want to express is indeed mathematically reasonable, then it isn't equality of types.</p>



<a name="217505850"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Equality%20of%20structures%20with%20types%20in%20fields/near/217505850" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Equality.20of.20structures.20with.20types.20in.20fields.html#217505850">(Nov 21 2020 at 15:23)</a>:</h4>
<p>"Two subsets of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span> are equal if they have the same elements" and "two subobjects <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>A</mi><mo>↪</mo><mi>E</mi></mrow><annotation encoding="application/x-tex">f : A \hookrightarrow E</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69433em;vertical-align:-0.011em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">↪</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo>:</mo><mi>B</mi><mo>↪</mo><mi>E</mi></mrow><annotation encoding="application/x-tex">g : B \hookrightarrow E</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69433em;vertical-align:-0.011em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">↪</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span> are 'equal' if they have the same image / (equivalently) there is an isomorphism <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>:</mo><mi>A</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">i : A \to B</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> which commutes with <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span>" are reasonable. "Two subobjects <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>A</mi><mo>↪</mo><mi>E</mi></mrow><annotation encoding="application/x-tex">f : A \hookrightarrow E</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69433em;vertical-align:-0.011em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">↪</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo>:</mo><mi>B</mi><mo>↪</mo><mi>E</mi></mrow><annotation encoding="application/x-tex">g : B \hookrightarrow E</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69433em;vertical-align:-0.011em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">↪</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span> are equal if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>=</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A = B</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>=</mo><mi>g</mi></mrow><annotation encoding="application/x-tex">f = g</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span>" is not.</p>



<a name="217505968"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Equality%20of%20structures%20with%20types%20in%20fields/near/217505968" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Equality.20of.20structures.20with.20types.20in.20fields.html#217505968">(Nov 21 2020 at 15:27)</a>:</h4>
<p>In particular, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>=</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A = B</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> will frequently be independent of Lean.</p>



<a name="217506023"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Equality%20of%20structures%20with%20types%20in%20fields/near/217506023" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Equality.20of.20structures.20with.20types.20in.20fields.html#217506023">(Nov 21 2020 at 15:29)</a>:</h4>
<p>What we've learned from the category library is that usually the best way to deal with an equality of objects (containing types) is to turn it into an isomorphism</p>



<a name="217506719"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Equality%20of%20structures%20with%20types%20in%20fields/near/217506719" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Equality.20of.20structures.20with.20types.20in.20fields.html#217506719">(Nov 21 2020 at 15:49)</a>:</h4>
<p>Just to give some idea of what lean can't do, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">N</mi><mo>=</mo><mi mathvariant="double-struck">Z</mi></mrow><annotation encoding="application/x-tex">\mathbb{N}=\mathbb{Z}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">N</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">Z</span></span></span></span></span> can neither be proved nor disproved in Lean. Equality of types is a strange thing in dependent type theory. The moment a subobject turns into a type of its own, the naive idea of equality becomes much more intractable.</p>



<a name="217507158"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Equality%20of%20structures%20with%20types%20in%20fields/near/217507158" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Equality.20of.20structures.20with.20types.20in.20fields.html#217507158">(Nov 21 2020 at 16:00)</a>:</h4>
<p>But we can prove that they are not isomorphic as semirings (or ordered sets or whatever structure we care about), right?</p>



<a name="217507230"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Equality%20of%20structures%20with%20types%20in%20fields/near/217507230" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Equality.20of.20structures.20with.20types.20in.20fields.html#217507230">(Nov 21 2020 at 16:02)</a>:</h4>
<p>Isomorphism is not a problem</p>



<a name="217507239"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Equality%20of%20structures%20with%20types%20in%20fields/near/217507239" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Equality.20of.20structures.20with.20types.20in.20fields.html#217507239">(Nov 21 2020 at 16:02)</a>:</h4>
<p>The problem is if two structures are isomorphic, but not obviously equal--then whether they are actually equal will be undecidable</p>



<a name="217507527"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Equality%20of%20structures%20with%20types%20in%20fields/near/217507527" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Equality.20of.20structures.20with.20types.20in.20fields.html#217507527">(Nov 21 2020 at 16:11)</a>:</h4>
<p>But it is something we usually don't care that much doing mathematics, right? Like if its true that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi><mo>=</mo><mi>exp</mi><mo>⁡</mo><mspace></mspace><mspace width="0.1111111111111111em"></mspace><mo lspace="0em" rspace="0.17em"></mo><mtext> ⁣</mtext><mo lspace="0em" rspace="0em">:</mo><mspace width="0.3333333333333333em"></mspace><mi mathvariant="bold">C</mi><mo>→</mo><mi mathvariant="bold">C</mi></mrow><annotation encoding="application/x-tex">\pi = \exp \colon \mathbf{C} \to \mathbf{C}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8805499999999999em;vertical-align:-0.19444em;"></span><span class="mop">exp</span><span class="mspace nobreak"></span><span class="mspace" style="margin-right:0.1111111111111111em;"></span><span class="mpunct"></span><span class="mspace" style="margin-right:-0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mrel">:</span></span><span class="mspace" style="margin-right:0.3333333333333333em;"></span><span class="mord"><span class="mord mathbf">C</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68611em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbf">C</span></span></span></span></span> in usual set theory? I mean, both objects are sets, so the statement is meaningful (but false I think...). I apologize if what I am sating is nonsense, I have a very naive understanding of foundations.</p>



<a name="217508055"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Equality%20of%20structures%20with%20types%20in%20fields/near/217508055" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Equality.20of.20structures.20with.20types.20in.20fields.html#217508055">(Nov 21 2020 at 16:25)</a>:</h4>
<p>This is type theory but it's the same sort of thing, yes. There are "weird" questions which don't make any mathematical sense but which you happen to be able to ask anyway. You could imagine that there could in theory be a way of setting up mathematics in set theory such that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi><mo>=</mo><mi>exp</mi><mo>⁡</mo></mrow><annotation encoding="application/x-tex">\pi=\exp</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mop">exp</span></span></span></span> as sets. Similarly there is a way of setting up maths in type theory such that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">N</mi><mo>=</mo><mi mathvariant="double-struck">Z</mi></mrow><annotation encoding="application/x-tex">\mathbb{N}=\mathbb{Z}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">N</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">Z</span></span></span></span></span> as types, but that one would only discover this by "unfolding too much".</p>



<a name="217524422"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Equality%20of%20structures%20with%20types%20in%20fields/near/217524422" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Equality.20of.20structures.20with.20types.20in.20fields.html#217524422">(Nov 21 2020 at 23:28)</a>:</h4>
<p>I think <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi><mo mathvariant="normal">≠</mo><mi>exp</mi><mo>⁡</mo></mrow><annotation encoding="application/x-tex">\pi\ne\exp</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mop">exp</span></span></span></span> because <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi><mo>∈</mo><mo stretchy="false">{</mo><mi>π</mi><mo stretchy="false">}</mo><mo>∈</mo><mo stretchy="false">(</mo><mi>π</mi><mo separator="true">,</mo><msup><mi>e</mi><mi>π</mi></msup><mo stretchy="false">)</mo><mo>∈</mo><mi>exp</mi><mo>⁡</mo></mrow><annotation encoding="application/x-tex">\pi\in\{\pi\}\in(\pi,e^\pi)\in\exp</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mclose">}</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">π</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mop">exp</span></span></span></span></p>



<a name="217524546"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Equality%20of%20structures%20with%20types%20in%20fields/near/217524546" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Equality.20of.20structures.20with.20types.20in.20fields.html#217524546">(Nov 21 2020 at 23:32)</a>:</h4>
<p>oh, unless <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi><mo>∈</mo><mi mathvariant="double-struck">R</mi></mrow><annotation encoding="application/x-tex">\pi\in\mathbb{R}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">R</span></span></span></span></span> where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">C</mi><mo>=</mo><mi mathvariant="double-struck">R</mi><mo>×</mo><mi mathvariant="double-struck">R</mi></mrow><annotation encoding="application/x-tex">\mathbb{C}=\mathbb{R}\times\mathbb{R}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">C</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77222em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathbb">R</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">R</span></span></span></span></span>, but in that case <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mi mathvariant="double-struck">R</mi></msub><mo>∈</mo><mo stretchy="false">{</mo><msub><mi>π</mi><mi mathvariant="double-struck">R</mi></msub><mo stretchy="false">}</mo><mo>∈</mo><mo stretchy="false">(</mo><msub><mi>π</mi><mi mathvariant="double-struck">R</mi></msub><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo><mo>=</mo><mi>π</mi></mrow><annotation encoding="application/x-tex">\pi_\mathbb{R}\in\{\pi_\mathbb{R}\}\in(\pi_\mathbb{R},0)=\pi</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.6891em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33222299999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathbb mtight">R</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33222299999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathbb mtight">R</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33222299999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathbb mtight">R</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span></span></span></span> and the rest is as before</p>



<a name="217544342"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Equality%20of%20structures%20with%20types%20in%20fields/near/217544342" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Equality.20of.20structures.20with.20types.20in.20fields.html#217544342">(Nov 22 2020 at 10:10)</a>:</h4>
<p>Except that a function <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mspace></mspace><mspace width="0.1111111111111111em"></mspace><mo lspace="0em" rspace="0.17em"></mo><mtext> ⁣</mtext><mo lspace="0em" rspace="0em">:</mo><mspace width="0.3333333333333333em"></mspace><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">f \colon X \to Y</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace nobreak"></span><span class="mspace" style="margin-right:0.1111111111111111em;"></span><span class="mpunct"></span><span class="mspace" style="margin-right:-0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mrel">:</span></span><span class="mspace" style="margin-right:0.3333333333333333em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span> is more than a subset <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>⊂</mo><mi>X</mi><mo>×</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">S \subset X \times Y</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊂</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span> such that blah blah I think: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> must "know" its codomain, and if I just give you <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>=</mo><mrow><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mo>…</mo></mrow></mrow><annotation encoding="application/x-tex">S = {(0,1), (1,2), \ldots}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span></span></span></span></span> how can you know whether I am talking about <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mspace></mspace><mspace width="0.1111111111111111em"></mspace><mo lspace="0em" rspace="0.17em"></mo><mtext> ⁣</mtext><mo lspace="0em" rspace="0em">:</mo><mspace width="0.3333333333333333em"></mspace><mi mathvariant="bold">N</mi><mo>→</mo><mi mathvariant="bold">N</mi></mrow><annotation encoding="application/x-tex">f \colon \mathbf{N} \to \mathbf{N}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace nobreak"></span><span class="mspace" style="margin-right:0.1111111111111111em;"></span><span class="mpunct"></span><span class="mspace" style="margin-right:-0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mrel">:</span></span><span class="mspace" style="margin-right:0.3333333333333333em;"></span><span class="mord"><span class="mord mathbf">N</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68611em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbf">N</span></span></span></span></span> or <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mspace></mspace><mspace width="0.1111111111111111em"></mspace><mo lspace="0em" rspace="0.17em"></mo><mtext> ⁣</mtext><mo lspace="0em" rspace="0em">:</mo><mspace width="0.3333333333333333em"></mspace><mi mathvariant="bold">N</mi><mo>→</mo><msup><mi mathvariant="bold">N</mi><mo>+</mo></msup></mrow><annotation encoding="application/x-tex">f \colon \mathbf{N} \to \mathbf{N}^+</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace nobreak"></span><span class="mspace" style="margin-right:0.1111111111111111em;"></span><span class="mpunct"></span><span class="mspace" style="margin-right:-0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mrel">:</span></span><span class="mspace" style="margin-right:0.3333333333333333em;"></span><span class="mord"><span class="mord mathbf">N</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.771331em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbf">N</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.771331em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span></span></span></span>? So probably <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> is the inclusion <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>↪</mo><mi>X</mi><mo>×</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">S \hookrightarrow X \times Y</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.69433em;vertical-align:-0.011em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">↪</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span>.</p>



<a name="217544352"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Equality%20of%20structures%20with%20types%20in%20fields/near/217544352" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Equality.20of.20structures.20with.20types.20in.20fields.html#217544352">(Nov 22 2020 at 10:10)</a>:</h4>
<p>OK, time to find something more interesting for a Sunday morning...</p>



<a name="217544549"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Equality%20of%20structures%20with%20types%20in%20fields/near/217544549" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Equality.20of.20structures.20with.20types.20in.20fields.html#217544549">(Nov 22 2020 at 10:16)</a>:</h4>
<p>Nice proof BTW!</p>



<a name="217545627"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Equality%20of%20structures%20with%20types%20in%20fields/near/217545627" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Equality.20of.20structures.20with.20types.20in.20fields.html#217545627">(Nov 22 2020 at 10:46)</a>:</h4>
<p>Yeah, get back to commutative algebra :-)</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
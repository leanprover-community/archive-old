---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/Slow.20definition.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Slow.20definition.html">Slow definition</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="233614772"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Slow%20definition/near/233614772" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Slow.20definition.html#233614772">(Apr 08 2021 at 07:47)</a>:</h4>
<p>I have a little riddle, from the file <code>exterior_algebra</code>. Consider the following two definitions:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">linear_algebra.exterior_algebra</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">R</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span>

<span class="kd">set_option</span> <span class="n">profiler</span> <span class="n">true</span>

<span class="kd">def</span> <span class="n">foo1</span> <span class="o">{</span><span class="n">S</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">S</span><span class="o">]</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">S</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span> <span class="n">semiring</span> <span class="o">(</span><span class="n">exterior_algebra</span> <span class="n">S</span> <span class="n">M</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">let</span> <span class="n">i</span> <span class="o">:</span> <span class="n">semiring</span> <span class="o">(</span><span class="n">tensor_algebra</span> <span class="n">S</span> <span class="n">M</span><span class="o">)</span> <span class="o">:=</span> <span class="n">infer_instance</span> <span class="k">in</span>
<span class="bp">@</span><span class="n">ring_quot.semiring</span> <span class="o">(</span><span class="n">tensor_algebra</span> <span class="n">S</span> <span class="n">M</span><span class="o">)</span> <span class="n">i</span> <span class="o">(</span><span class="n">exterior_algebra.rel</span> <span class="n">S</span> <span class="n">M</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">foo2</span> <span class="o">{</span><span class="n">S</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">S</span><span class="o">]</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">S</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span> <span class="n">ring</span> <span class="o">(</span><span class="n">exterior_algebra</span> <span class="n">S</span> <span class="n">M</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">let</span> <span class="n">i</span> <span class="o">:</span> <span class="n">ring</span> <span class="o">(</span><span class="n">tensor_algebra</span> <span class="n">S</span> <span class="n">M</span><span class="o">)</span> <span class="o">:=</span> <span class="n">infer_instance</span> <span class="k">in</span>
<span class="bp">@</span><span class="n">ring_quot.ring</span> <span class="o">(</span><span class="n">tensor_algebra</span> <span class="n">S</span> <span class="n">M</span><span class="o">)</span> <span class="n">i</span> <span class="o">(</span><span class="n">exterior_algebra.rel</span> <span class="n">S</span> <span class="n">M</span><span class="o">)</span>
</code></pre></div>
<p>Here <code>foo1</code> elaborates in 18ms on my computer, and <code>foo2</code> in 18s. So a ratio of 1 to 1000...</p>



<a name="233615083"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Slow%20definition/near/233615083" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Slow.20definition.html#233615083">(Apr 08 2021 at 07:49)</a>:</h4>
<p>This one was a mystery to me too</p>



<a name="233615226"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Slow%20definition/near/233615226" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Slow.20definition.html#233615226">(Apr 08 2021 at 07:50)</a>:</h4>
<p>I was kinda fed up with not having a ring structure at all, and had such a hard time adding one that I lost interest in making it fast too!</p>



<a name="233615285"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Slow%20definition/near/233615285" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Slow.20definition.html#233615285">(Apr 08 2021 at 07:51)</a>:</h4>
<p><del>src#exterior_algebra.ring has a few more <code>let</code>s than that, doesn't it?</del></p>



<a name="233615303"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Slow%20definition/near/233615303" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Slow.20definition.html#233615303">(Apr 08 2021 at 07:51)</a>:</h4>
<p>I noticed it because it gets even slower in <a href="https://github.com/leanprover-community/mathlib/issues/7084">#7084</a></p>



<a name="233615336"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Slow%20definition/near/233615336" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Slow.20definition.html#233615336">(Apr 08 2021 at 07:52)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/113488-general/topic/Slow.20definition/near/233615285">said</a>:</p>
<blockquote>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/exterior_algebra.ring/src">src#exterior_algebra.ring</a> has a few more <code>let</code>s than that, doesn't it?</p>
</blockquote>
<p>No, I copied the exact definition.</p>



<a name="233615431"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Slow%20definition/near/233615431" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Slow.20definition.html#233615431">(Apr 08 2021 at 07:52)</a>:</h4>
<p>I thought that might be where this was going</p>



<a name="233615505"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Slow%20definition/near/233615505" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Slow.20definition.html#233615505">(Apr 08 2021 at 07:53)</a>:</h4>
<p>Does <a href="https://github.com/leanprover-community/mathlib/issues/7084">#7084</a> change <code>ring_quot</code> (<a href="https://leanprover-community.github.io/mathlib_docs/find/ring_quot.semiring">docs#ring_quot.semiring</a>?) to add a non-auto_param nsmul?</p>



<a name="233615736"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Slow%20definition/near/233615736" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Slow.20definition.html#233615736">(Apr 08 2021 at 07:56)</a>:</h4>
<p>I just noticed that ring_quot.ring uses the automatic <code>has_sub</code> - I'll see if changing that makes things better.</p>



<a name="233615777"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Slow%20definition/near/233615777" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Slow.20definition.html#233615777">(Apr 08 2021 at 07:56)</a>:</h4>
<p>It didn't initially, although it does now on my local branch (because there is also an algebra instance below, so to kill the potential diamond one needs to add the <code>nsmul</code> field). But it becomes too slow even without adding it.</p>



<a name="233624077"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Slow%20definition/near/233624077" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Slow.20definition.html#233624077">(Apr 08 2021 at 09:19)</a>:</h4>
<p>I found a way to speed up things, but I don't understand what's going on. The current ring structure on a quotient is:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u₁</span><span class="o">}</span> <span class="o">[</span><span class="n">ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">R</span> <span class="bp">→</span> <span class="n">R</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="n">ring</span> <span class="o">(</span><span class="n">ring_quot</span> <span class="n">r</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">neg</span>           <span class="o">:=</span> <span class="n">quot.map</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="bp">-</span><span class="n">a</span><span class="o">)</span>
    <span class="n">rel.neg</span><span class="o">,</span>
  <span class="n">add_left_neg</span>  <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">rintros</span> <span class="o">⟨⟩,</span> <span class="n">exact</span> <span class="n">congr_arg</span> <span class="o">(</span><span class="n">quot.mk</span> <span class="n">_</span><span class="o">)</span> <span class="o">(</span><span class="n">add_left_neg</span> <span class="n">_</span><span class="o">),</span> <span class="o">},</span>
  <span class="bp">..</span> <span class="o">(</span><span class="n">ring_quot.semiring</span> <span class="n">r</span><span class="o">)</span> <span class="o">}</span>
</code></pre></div>
<p>With this definition, my test example <code>foo2</code> takes 18s to compile. If I change it to</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u₁</span><span class="o">}</span> <span class="o">[</span><span class="n">ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">R</span> <span class="bp">→</span> <span class="n">R</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="n">ring</span> <span class="o">(</span><span class="n">ring_quot</span> <span class="n">r</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">add</span>           <span class="o">:=</span> <span class="n">quot.map₂</span> <span class="o">(</span><span class="bp">+</span><span class="o">)</span> <span class="n">rel.add_right</span> <span class="n">rel.add_left</span><span class="o">,</span>
  <span class="n">add_assoc</span>     <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">rintros</span> <span class="o">⟨⟩</span> <span class="o">⟨⟩</span> <span class="o">⟨⟩,</span> <span class="n">exact</span> <span class="n">congr_arg</span> <span class="o">(</span><span class="n">quot.mk</span> <span class="n">_</span><span class="o">)</span> <span class="o">(</span><span class="n">add_assoc</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span><span class="o">),</span> <span class="o">},</span>
  <span class="n">zero</span>          <span class="o">:=</span> <span class="n">quot.mk</span> <span class="n">_</span> <span class="mi">0</span><span class="o">,</span>
  <span class="n">zero_add</span>      <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">rintros</span> <span class="o">⟨⟩,</span> <span class="n">exact</span> <span class="n">congr_arg</span> <span class="o">(</span><span class="n">quot.mk</span> <span class="n">_</span><span class="o">)</span> <span class="o">(</span><span class="n">zero_add</span> <span class="n">_</span><span class="o">),</span> <span class="o">},</span>
  <span class="n">add_zero</span>      <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">rintros</span> <span class="o">⟨⟩,</span> <span class="n">exact</span> <span class="n">congr_arg</span> <span class="o">(</span><span class="n">quot.mk</span> <span class="n">_</span><span class="o">)</span> <span class="o">(</span><span class="n">add_zero</span> <span class="n">_</span><span class="o">),</span> <span class="o">},</span>
  <span class="n">add_comm</span>      <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">rintros</span> <span class="o">⟨⟩</span> <span class="o">⟨⟩,</span> <span class="n">exact</span> <span class="n">congr_arg</span> <span class="o">(</span><span class="n">quot.mk</span> <span class="n">_</span><span class="o">)</span> <span class="o">(</span><span class="n">add_comm</span> <span class="n">_</span> <span class="n">_</span><span class="o">),</span> <span class="o">},</span>
  <span class="n">mul</span>           <span class="o">:=</span> <span class="n">quot.map₂</span> <span class="o">(</span><span class="bp">*</span><span class="o">)</span> <span class="n">rel.mul_right</span> <span class="n">rel.mul_left</span><span class="o">,</span>
  <span class="n">mul_assoc</span>     <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">rintros</span> <span class="o">⟨⟩</span> <span class="o">⟨⟩</span> <span class="o">⟨⟩,</span> <span class="n">exact</span> <span class="n">congr_arg</span> <span class="o">(</span><span class="n">quot.mk</span> <span class="n">_</span><span class="o">)</span> <span class="o">(</span><span class="n">mul_assoc</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span><span class="o">),</span> <span class="o">},</span>
  <span class="n">one</span>           <span class="o">:=</span> <span class="n">quot.mk</span> <span class="n">_</span> <span class="mi">1</span><span class="o">,</span>
  <span class="n">one_mul</span>       <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">rintros</span> <span class="o">⟨⟩,</span> <span class="n">exact</span> <span class="n">congr_arg</span> <span class="o">(</span><span class="n">quot.mk</span> <span class="n">_</span><span class="o">)</span> <span class="o">(</span><span class="n">one_mul</span> <span class="n">_</span><span class="o">),</span> <span class="o">},</span>
  <span class="n">mul_one</span>       <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">rintros</span> <span class="o">⟨⟩,</span> <span class="n">exact</span> <span class="n">congr_arg</span> <span class="o">(</span><span class="n">quot.mk</span> <span class="n">_</span><span class="o">)</span> <span class="o">(</span><span class="n">mul_one</span> <span class="n">_</span><span class="o">),</span> <span class="o">},</span>
  <span class="n">left_distrib</span>  <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">rintros</span> <span class="o">⟨⟩</span> <span class="o">⟨⟩</span> <span class="o">⟨⟩,</span> <span class="n">exact</span> <span class="n">congr_arg</span> <span class="o">(</span><span class="n">quot.mk</span> <span class="n">_</span><span class="o">)</span> <span class="o">(</span><span class="n">left_distrib</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span><span class="o">),</span> <span class="o">},</span>
  <span class="n">right_distrib</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">rintros</span> <span class="o">⟨⟩</span> <span class="o">⟨⟩</span> <span class="o">⟨⟩,</span> <span class="n">exact</span> <span class="n">congr_arg</span> <span class="o">(</span><span class="n">quot.mk</span> <span class="n">_</span><span class="o">)</span> <span class="o">(</span><span class="n">right_distrib</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span><span class="o">),</span> <span class="o">},</span>
  <span class="n">neg</span>           <span class="o">:=</span> <span class="n">quot.map</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="bp">-</span><span class="n">a</span><span class="o">)</span> <span class="n">rel.neg</span><span class="o">,</span>
  <span class="n">add_left_neg</span>  <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">rintros</span> <span class="o">⟨⟩,</span> <span class="n">exact</span> <span class="n">congr_arg</span> <span class="o">(</span><span class="n">quot.mk</span> <span class="n">_</span><span class="o">)</span> <span class="o">(</span><span class="n">add_left_neg</span> <span class="n">_</span><span class="o">)</span> <span class="o">}</span> <span class="o">}</span>
</code></pre></div>
<p>(So, doing everything by hand instead of referring to the semiring structure), then this goes down to 8s. </p>
<p>If I trim it down to</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u₁</span><span class="o">}</span> <span class="o">[</span><span class="n">ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">R</span> <span class="bp">→</span> <span class="n">R</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="n">ring</span> <span class="o">(</span><span class="n">ring_quot</span> <span class="n">r</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">add</span>           <span class="o">:=</span> <span class="n">quot.map₂</span> <span class="o">(</span><span class="bp">+</span><span class="o">)</span> <span class="n">rel.add_right</span> <span class="n">rel.add_left</span><span class="o">,</span>
  <span class="n">zero</span>          <span class="o">:=</span> <span class="n">quot.mk</span> <span class="n">_</span> <span class="mi">0</span><span class="o">,</span>
  <span class="n">mul</span>           <span class="o">:=</span> <span class="n">quot.map₂</span> <span class="o">(</span><span class="bp">*</span><span class="o">)</span> <span class="n">rel.mul_right</span> <span class="n">rel.mul_left</span><span class="o">,</span>
  <span class="n">one</span>           <span class="o">:=</span> <span class="n">quot.mk</span> <span class="n">_</span> <span class="mi">1</span><span class="o">,</span>
  <span class="n">neg</span>           <span class="o">:=</span> <span class="n">quot.map</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="bp">-</span><span class="n">a</span><span class="o">)</span> <span class="n">rel.neg</span><span class="o">,</span>
  <span class="n">add_left_neg</span>  <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">rintros</span> <span class="o">⟨⟩,</span> <span class="n">exact</span> <span class="n">congr_arg</span> <span class="o">(</span><span class="n">quot.mk</span> <span class="n">_</span><span class="o">)</span> <span class="o">(</span><span class="n">add_left_neg</span> <span class="n">_</span><span class="o">)</span> <span class="o">},</span>
  <span class="bp">..</span> <span class="o">(</span><span class="n">ring_quot.semiring</span> <span class="n">r</span><span class="o">)</span> <span class="o">}</span>
</code></pre></div>
<p>(Keeping only the data fields, and leaving the Prop fields to the semiring structure), this goes up again to 21s.</p>
<p>So the content of Prop-fields matters, which I don't get. And all this is to be compared to the 18ms for the semiring version. </p>
<p>TLDR: I don't understand anything to the inner workings of structure elaboration. Any advice on how to make things right / good practice rule would be most welcome!</p>



<a name="233636361"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Slow%20definition/near/233636361" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Slow.20definition.html#233636361">(Apr 08 2021 at 11:23)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/113488-general/topic/Slow.20definition/near/233615736">said</a>:</p>
<blockquote>
<p>I just noticed that ring_quot.ring uses the automatic <code>has_sub</code> - I'll see if changing that makes things better.</p>
</blockquote>
<p>Done in <a href="https://github.com/leanprover-community/mathlib/issues/7112">#7112</a>, although I didn't end up profiling it because the behavior seemed like something we'd want anyway</p>



<a name="233638104"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Slow%20definition/near/233638104" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Slow.20definition.html#233638104">(Apr 08 2021 at 11:41)</a>:</h4>
<p>I had done profiling, and it doesn't make any difference. Unfortunately, the speedup I mentioned earlier in the discussion is not enough for <a href="https://github.com/leanprover-community/mathlib/issues/7084">#7084</a>, which is therefore stuck for now :-(</p>



<a name="233658727"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Slow%20definition/near/233658727" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Slow.20definition.html#233658727">(Apr 08 2021 at 14:11)</a>:</h4>
<p>I'm wondering if the solution here would not be to make more things irreducible: here the exterior algebra is a quotient of the tensor algebra, which itself is already a complicated quotient, so if Lean tries to unfold anything in exterior algebras the terms are astronomically big right away, which is probably not reasonable (and essentially pointless). Thoughts, anyone?</p>



<a name="233658883"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Slow%20definition/near/233658883" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Slow.20definition.html#233658883">(Apr 08 2021 at 14:12)</a>:</h4>
<p>(by "irreducible", I mean use structures just like in the definition of reals, not mark things irreducible after the fact).</p>



<a name="233659658"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Slow%20definition/near/233659658" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Slow.20definition.html#233659658">(Apr 08 2021 at 14:16)</a>:</h4>
<p>Note that originally things were marked <code>irreducible</code> and that actually broke typeclass search</p>



<a name="233669712"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Slow%20definition/near/233669712" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Slow.20definition.html#233669712">(Apr 08 2021 at 15:07)</a>:</h4>
<blockquote>
<p>(So, doing everything by hand instead of referring to the semiring structure), then this goes down to 8s.</p>
</blockquote>
<p>This makes no difference for me. On my desktop it takes around 9 seconds to elaborate <code>foo2</code> below, and if I uncomment all the comments then it still takes around 9 seconds. </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">linear_algebra.exterior_algebra</span>
<span class="kn">import</span> <span class="n">algebra.ring_quot</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">R</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span>

<span class="kd">set_option</span> <span class="n">profiler</span> <span class="n">true</span>

<span class="kd">def</span> <span class="n">foo1</span> <span class="o">{</span><span class="n">S</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">S</span><span class="o">]</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">S</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span> <span class="n">semiring</span> <span class="o">(</span><span class="n">exterior_algebra</span> <span class="n">S</span> <span class="n">M</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">let</span> <span class="n">i</span> <span class="o">:</span> <span class="n">semiring</span> <span class="o">(</span><span class="n">tensor_algebra</span> <span class="n">S</span> <span class="n">M</span><span class="o">)</span> <span class="o">:=</span> <span class="n">infer_instance</span> <span class="k">in</span>
<span class="bp">@</span><span class="n">ring_quot.semiring</span> <span class="o">(</span><span class="n">tensor_algebra</span> <span class="n">S</span> <span class="n">M</span><span class="o">)</span> <span class="n">i</span> <span class="o">(</span><span class="n">exterior_algebra.rel</span> <span class="n">S</span> <span class="n">M</span><span class="o">)</span>

<span class="kd">universe</span> <span class="n">u₁</span>

<span class="kn">open</span> <span class="n">ring_quot</span>

<span class="c1">-- local attribute [-instance] ring_quot.ring</span>

<span class="c1">-- instance inst37 {R : Type u₁} [ring R] (r : R → R → Prop) : ring (ring_quot r) :=</span>
<span class="c1">-- { add           := quot.map₂ (+) rel.add_right rel.add_left,</span>
<span class="c1">--   add_assoc     := by { rintros ⟨⟩ ⟨⟩ ⟨⟩, exact congr_arg (quot.mk _) (add_assoc _ _ _), },</span>
<span class="c1">--   zero          := quot.mk _ 0,</span>
<span class="c1">--   zero_add      := by { rintros ⟨⟩, exact congr_arg (quot.mk _) (zero_add _), },</span>
<span class="c1">--   add_zero      := by { rintros ⟨⟩, exact congr_arg (quot.mk _) (add_zero _), },</span>
<span class="c1">--   add_comm      := by { rintros ⟨⟩ ⟨⟩, exact congr_arg (quot.mk _) (add_comm _ _), },</span>
<span class="c1">--   mul           := quot.map₂ (*) rel.mul_right rel.mul_left,</span>
<span class="c1">--   mul_assoc     := by { rintros ⟨⟩ ⟨⟩ ⟨⟩, exact congr_arg (quot.mk _) (mul_assoc _ _ _), },</span>
<span class="c1">--   one           := quot.mk _ 1,</span>
<span class="c1">--   one_mul       := by { rintros ⟨⟩, exact congr_arg (quot.mk _) (one_mul _), },</span>
<span class="c1">--   mul_one       := by { rintros ⟨⟩, exact congr_arg (quot.mk _) (mul_one _), },</span>
<span class="c1">--   left_distrib  := by { rintros ⟨⟩ ⟨⟩ ⟨⟩, exact congr_arg (quot.mk _) (left_distrib _ _ _), },</span>
<span class="c1">--   right_distrib := by { rintros ⟨⟩ ⟨⟩ ⟨⟩, exact congr_arg (quot.mk _) (right_distrib _ _ _), },</span>
<span class="c1">--   neg           := quot.map (λ a, -a) rel.neg,</span>
<span class="c1">--   add_left_neg  := by { rintros ⟨⟩, exact congr_arg (quot.mk _) (add_left_neg _) } }</span>

<span class="kd">def</span> <span class="n">foo2</span> <span class="o">{</span><span class="n">S</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">S</span><span class="o">]</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">S</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span> <span class="n">ring</span> <span class="o">(</span><span class="n">exterior_algebra</span> <span class="n">S</span> <span class="n">M</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">let</span> <span class="n">i</span> <span class="o">:</span> <span class="n">ring</span> <span class="o">(</span><span class="n">tensor_algebra</span> <span class="n">S</span> <span class="n">M</span><span class="o">)</span> <span class="o">:=</span> <span class="n">infer_instance</span> <span class="k">in</span>
<span class="bp">@</span><span class="n">ring_quot.ring</span> <span class="o">(</span><span class="n">tensor_algebra</span> <span class="n">S</span> <span class="n">M</span><span class="o">)</span> <span class="n">i</span> <span class="o">(</span><span class="n">exterior_algebra.rel</span> <span class="n">S</span> <span class="n">M</span><span class="o">)</span>
</code></pre></div>



<a name="233670333"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Slow%20definition/near/233670333" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Slow.20definition.html#233670333">(Apr 08 2021 at 15:09)</a>:</h4>
<p>Oh in fact if I just make ring_quot.ring not an instance then it still takes 9 seconds -- in my set-up it doesn't seem to be using <code>ring_quot.ring</code> at all (this is on a relatively recent master -- are you doing something else?)</p>



<a name="233670351"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Slow%20definition/near/233670351" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Slow.20definition.html#233670351">(Apr 08 2021 at 15:09)</a>:</h4>
<p>You need to do this in the original file, before <code>tensor_product</code> is defined.</p>



<a name="233670389"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Slow%20definition/near/233670389" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Slow.20definition.html#233670389">(Apr 08 2021 at 15:09)</a>:</h4>
<p>Got it!</p>



<a name="233670854"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Slow%20definition/near/233670854" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Slow.20definition.html#233670854">(Apr 08 2021 at 15:11)</a>:</h4>
<p>Did you actually mean <code>tensor_product</code> and not <code>tensor_algebra</code>?</p>



<a name="233675279"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Slow%20definition/near/233675279" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Slow.20definition.html#233675279">(Apr 08 2021 at 15:32)</a>:</h4>
<p>It's a universe issue.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">linear_algebra.exterior_algebra</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">R</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span>

<span class="kd">set_option</span> <span class="n">profiler</span> <span class="n">true</span>

<span class="kd">def</span> <span class="n">foo1</span> <span class="o">{</span><span class="n">S</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">S</span><span class="o">]</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">S</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span> <span class="n">semiring</span> <span class="o">(</span><span class="n">exterior_algebra</span> <span class="n">S</span> <span class="n">M</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">let</span> <span class="n">i</span> <span class="o">:</span> <span class="n">semiring</span> <span class="o">(</span><span class="n">tensor_algebra</span> <span class="n">S</span> <span class="n">M</span><span class="o">)</span> <span class="o">:=</span> <span class="n">infer_instance</span> <span class="k">in</span>
<span class="bp">@</span><span class="n">ring_quot.semiring</span> <span class="o">(</span><span class="n">tensor_algebra</span> <span class="n">S</span> <span class="n">M</span><span class="o">)</span> <span class="n">i</span> <span class="o">(</span><span class="n">exterior_algebra.rel</span> <span class="n">S</span> <span class="n">M</span><span class="o">)</span>

<span class="c1">-- Change {S : Type*} to {S : Type}</span>
<span class="c1">-- 455 ms</span>
<span class="kd">def</span> <span class="n">foo2</span> <span class="o">{</span><span class="n">S</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">S</span><span class="o">]</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">S</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span> <span class="n">ring</span> <span class="o">(</span><span class="n">exterior_algebra</span> <span class="n">S</span> <span class="n">M</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">let</span> <span class="n">i</span> <span class="o">:</span> <span class="n">ring</span> <span class="o">(</span><span class="n">tensor_algebra</span> <span class="n">S</span> <span class="n">M</span><span class="o">)</span> <span class="o">:=</span> <span class="n">infer_instance</span> <span class="k">in</span>
<span class="bp">@</span><span class="n">ring_quot.ring</span> <span class="o">(</span><span class="n">tensor_algebra</span> <span class="n">S</span> <span class="n">M</span><span class="o">)</span> <span class="n">i</span> <span class="o">(</span><span class="n">exterior_algebra.rel</span> <span class="n">S</span> <span class="n">M</span><span class="o">)</span>
</code></pre></div>



<a name="233675443"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Slow%20definition/near/233675443" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Slow.20definition.html#233675443">(Apr 08 2021 at 15:33)</a>:</h4>
<p>What if you put <code>{S : Type*}</code> in a separate variables declaration?</p>



<a name="233675514"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Slow%20definition/near/233675514" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Slow.20definition.html#233675514">(Apr 08 2021 at 15:34)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">linear_algebra.exterior_algebra</span>

<span class="kd">universes</span> <span class="n">u</span> <span class="n">v</span> <span class="n">w</span>
<span class="kd">variables</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">R</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span>

<span class="kd">set_option</span> <span class="n">profiler</span> <span class="n">true</span>

<span class="kd">def</span> <span class="n">foo1</span> <span class="o">{</span><span class="n">S</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">w</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">S</span><span class="o">]</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">S</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span> <span class="n">semiring</span> <span class="o">(</span><span class="n">exterior_algebra</span> <span class="n">S</span> <span class="n">M</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">let</span> <span class="n">i</span> <span class="o">:</span> <span class="n">semiring</span> <span class="o">(</span><span class="n">tensor_algebra</span> <span class="n">S</span> <span class="n">M</span><span class="o">)</span> <span class="o">:=</span> <span class="n">infer_instance</span> <span class="k">in</span>
<span class="bp">@</span><span class="n">ring_quot.semiring</span> <span class="o">(</span><span class="n">tensor_algebra</span> <span class="n">S</span> <span class="n">M</span><span class="o">)</span> <span class="n">i</span> <span class="o">(</span><span class="n">exterior_algebra.rel</span> <span class="n">S</span> <span class="n">M</span><span class="o">)</span>

<span class="c1">-- 455 ms</span>
<span class="kd">def</span> <span class="n">foo2</span> <span class="o">{</span><span class="n">S</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">w</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">S</span><span class="o">]</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">S</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span> <span class="n">ring</span> <span class="o">(</span><span class="n">exterior_algebra</span> <span class="n">S</span> <span class="n">M</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">let</span> <span class="n">i</span> <span class="o">:</span> <span class="n">ring</span> <span class="o">(</span><span class="n">tensor_algebra</span> <span class="n">S</span> <span class="n">M</span><span class="o">)</span> <span class="o">:=</span> <span class="n">infer_instance</span> <span class="k">in</span>
<span class="bp">@</span><span class="n">ring_quot.ring</span> <span class="o">(</span><span class="n">tensor_algebra</span> <span class="n">S</span> <span class="n">M</span><span class="o">)</span> <span class="n">i</span> <span class="o">(</span><span class="n">exterior_algebra.rel</span> <span class="n">S</span> <span class="n">M</span><span class="o">)</span>
</code></pre></div>
<p>This is also instant. It's <code>{Type*}</code> v <code>{Type u}</code> again.</p>



<a name="233675827"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Slow%20definition/near/233675827" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Slow.20definition.html#233675827">(Apr 08 2021 at 15:35)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">linear_algebra.exterior_algebra</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">R</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span>
<span class="kd">variable</span> <span class="o">{</span><span class="n">S</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>

<span class="kd">set_option</span> <span class="n">profiler</span> <span class="n">true</span>

<span class="kd">def</span> <span class="n">foo1</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">S</span><span class="o">]</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">S</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span> <span class="n">semiring</span> <span class="o">(</span><span class="n">exterior_algebra</span> <span class="n">S</span> <span class="n">M</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">let</span> <span class="n">i</span> <span class="o">:</span> <span class="n">semiring</span> <span class="o">(</span><span class="n">tensor_algebra</span> <span class="n">S</span> <span class="n">M</span><span class="o">)</span> <span class="o">:=</span> <span class="n">infer_instance</span> <span class="k">in</span>
<span class="bp">@</span><span class="n">ring_quot.semiring</span> <span class="o">(</span><span class="n">tensor_algebra</span> <span class="n">S</span> <span class="n">M</span><span class="o">)</span> <span class="n">i</span> <span class="o">(</span><span class="n">exterior_algebra.rel</span> <span class="n">S</span> <span class="n">M</span><span class="o">)</span>

<span class="c1">-- 484ms</span>
<span class="kd">def</span> <span class="n">foo2</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">S</span><span class="o">]</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">S</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span> <span class="n">ring</span> <span class="o">(</span><span class="n">exterior_algebra</span> <span class="n">S</span> <span class="n">M</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">let</span> <span class="n">i</span> <span class="o">:</span> <span class="n">ring</span> <span class="o">(</span><span class="n">tensor_algebra</span> <span class="n">S</span> <span class="n">M</span><span class="o">)</span> <span class="o">:=</span> <span class="n">infer_instance</span> <span class="k">in</span>
<span class="bp">@</span><span class="n">ring_quot.ring</span> <span class="o">(</span><span class="n">tensor_algebra</span> <span class="n">S</span> <span class="n">M</span><span class="o">)</span> <span class="n">i</span> <span class="o">(</span><span class="n">exterior_algebra.rel</span> <span class="n">S</span> <span class="n">M</span><span class="o">)</span>
</code></pre></div>
<p>As Eric suggests: if you strip it out it's quick even with Type*.</p>



<a name="233676041"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Slow%20definition/near/233676041" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Slow.20definition.html#233676041">(Apr 08 2021 at 15:36)</a>:</h4>
<p>This is annoying, because I constantly run into universe issues where someone wrote <code>Type u</code> and mean <code>Type something_other_than_u</code> because guessing the universe variables already in the lemma was a pain for them.</p>
<p>In the past I've ended up stripping out universe variables entirely and replacing things with <code>Type*</code>. Only now we find that introduces subtler problems...</p>



<a name="233676368"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Slow%20definition/near/233676368" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Slow.20definition.html#233676368">(Apr 08 2021 at 15:38)</a>:</h4>
<p>I have not encountered this issue much, but the first time it came for me was also in linear algebra.  Could there be something specific to the linear algebra part of the library that makes these issues more prominent?</p>



<a name="233677352"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Slow%20definition/near/233677352" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Slow.20definition.html#233677352">(Apr 08 2021 at 15:44)</a>:</h4>
<p>I think this was why universes were causing problems with some previous linear algebra thread:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">universes</span> <span class="n">u</span> <span class="n">v</span> <span class="n">w</span>
<span class="c1">-- this is the type of `flip`</span>
<span class="k">#check</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">{</span><span class="n">φ</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">w</span><span class="o">},</span> <span class="o">(</span><span class="n">α</span> <span class="bp">→</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">φ</span><span class="o">)</span> <span class="bp">→</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">φ</span>
<span class="c1">-- Type (max (u+1) (v+1) (w+1) (max u v w) v u w)</span>
</code></pre></div>
<p>This type can be simplified, but you can't run the simplifier on universe levels :-)</p>



<a name="233677615"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Slow%20definition/near/233677615" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Slow.20definition.html#233677615">(Apr 08 2021 at 15:46)</a>:</h4>
<p>Indeed, it was <code>flip</code>!  Maybe it is the fact of having 3 interlaced Types that causes problems?</p>



<a name="233677643"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Slow%20definition/near/233677643" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Slow.20definition.html#233677643">(Apr 08 2021 at 15:46)</a>:</h4>
<p>My instinct, probably not the correct one but it's what I tell students, is that whilst it's important to stay universe polymorphic, can you really imagine a situation where you have your ring in one universe and your module in another one? Put everything into one universe! And then of course people want to do modules over <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">Z</mi></mrow><annotation encoding="application/x-tex">\Z</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">Z</span></span></span></span></span> and they realise they have to do everything in <code>Type</code>.</p>



<a name="233677794"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Slow%20definition/near/233677794" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Slow.20definition.html#233677794">(Apr 08 2021 at 15:47)</a>:</h4>
<p>... which is fine as it might even be inconsistent to have more than <code>Type</code>!  <span aria-label="upside down" class="emoji emoji-1f643" role="img" title="upside down">:upside_down:</span></p>



<a name="233683319"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Slow%20definition/near/233683319" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Slow.20definition.html#233683319">(Apr 08 2021 at 16:21)</a>:</h4>
<p>Here is the non-diamond which I think is causing the issue:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">linear_algebra.exterior_algebra</span>

<span class="kd">universes</span> <span class="n">u</span> <span class="n">v</span> <span class="n">w</span>
<span class="kd">variables</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">R</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span>

<span class="kd">set_option</span> <span class="n">profiler</span> <span class="n">true</span>

<span class="c1">-- 10 seconds</span>
<span class="kd">def</span> <span class="n">foo</span> <span class="o">{</span><span class="n">S</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">S</span><span class="o">]</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">S</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span>
  <span class="bp">@</span><span class="n">tensor_algebra.semiring</span> <span class="n">S</span> <span class="o">(</span><span class="bp">@</span><span class="n">comm_ring.to_comm_semiring</span> <span class="n">S</span> <span class="n">_inst_4</span><span class="o">)</span> <span class="n">M</span> <span class="n">_inst_2</span> <span class="n">_inst_5</span> <span class="bp">=</span>
  <span class="bp">@</span><span class="n">ring.to_semiring</span> <span class="o">(</span><span class="bp">@</span><span class="n">tensor_algebra</span> <span class="n">S</span> <span class="o">(</span><span class="bp">@</span><span class="n">comm_ring.to_comm_semiring</span> <span class="n">S</span> <span class="n">_inst_4</span><span class="o">)</span> <span class="n">M</span> <span class="n">_inst_2</span> <span class="n">_inst_5</span><span class="o">)</span> <span class="o">(</span><span class="bp">@</span><span class="n">tensor_algebra.ring</span> <span class="n">M</span> <span class="n">_inst_2</span> <span class="n">S</span> <span class="n">_inst_4</span> <span class="n">_inst_5</span><span class="o">)</span>
<span class="o">:=</span> <span class="n">rfl</span>

<span class="c1">-- 1/2 second</span>
<span class="kd">def</span> <span class="n">bar</span> <span class="o">{</span><span class="n">S</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">w</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">S</span><span class="o">]</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">S</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span>
  <span class="bp">@</span><span class="n">tensor_algebra.semiring</span> <span class="n">S</span> <span class="o">(</span><span class="bp">@</span><span class="n">comm_ring.to_comm_semiring</span> <span class="n">S</span> <span class="n">_inst_4</span><span class="o">)</span> <span class="n">M</span> <span class="n">_inst_2</span> <span class="n">_inst_5</span> <span class="bp">=</span>
  <span class="bp">@</span><span class="n">ring.to_semiring</span> <span class="o">(</span><span class="bp">@</span><span class="n">tensor_algebra</span> <span class="n">S</span> <span class="o">(</span><span class="bp">@</span><span class="n">comm_ring.to_comm_semiring</span> <span class="n">S</span> <span class="n">_inst_4</span><span class="o">)</span> <span class="n">M</span> <span class="n">_inst_2</span> <span class="n">_inst_5</span><span class="o">)</span> <span class="o">(</span><span class="bp">@</span><span class="n">tensor_algebra.ring</span> <span class="n">M</span> <span class="n">_inst_2</span> <span class="n">S</span> <span class="n">_inst_4</span> <span class="n">_inst_5</span><span class="o">)</span>
<span class="o">:=</span> <span class="n">rfl</span>
</code></pre></div>
<p>(<code>foo</code> and <code>bar</code> are the same apart from <code>{S : Type*}</code> changed to <code>{S : Type w}</code>)</p>



<a name="233684425"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Slow%20definition/near/233684425" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Slow.20definition.html#233684425">(Apr 08 2021 at 16:30)</a>:</h4>
<p>What does <code>foo</code> infer for the <code>*</code>?</p>



<a name="233684730"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Slow%20definition/near/233684730" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Slow.20definition.html#233684730">(Apr 08 2021 at 16:31)</a>:</h4>
<p><code>{S : Type u_2} </code></p>



<a name="233684815"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Slow%20definition/near/233684815" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Slow.20definition.html#233684815">(Apr 08 2021 at 16:32)</a>:</h4>
<p>Thanks a lot for debugging this and noticing it was a universe issue! In the meantime, I have made this quotient ring construction irreducible, which I think is a good idea in any case because it hides some irrelevant complexity.</p>



<a name="233684946"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Slow%20definition/near/233684946" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Slow.20definition.html#233684946">(Apr 08 2021 at 16:33)</a>:</h4>
<p>Thanks a lot for your diamond-killing! You have put in a lot of work recently with some really technical and messy issues and I am all too happy to help.</p>



<a name="233685075"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Slow%20definition/near/233685075" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Slow.20definition.html#233685075">(Apr 08 2021 at 16:33)</a>:</h4>
<p>After making things irreducible, <code>foo</code> takes 2 seconds and <code>bar</code>takes 0.5s, so it's better but the universe issues are still in the way.</p>



<a name="233685373"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Slow%20definition/near/233685373" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Slow.20definition.html#233685373">(Apr 08 2021 at 16:35)</a>:</h4>
<p><span class="user-mention" data-user-id="310045">@Eric Wieser</span> as far as I can see <code>foo</code> and <code>bar</code> are identical even up to universes.</p>



<a name="233685634"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Slow%20definition/near/233685634" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Slow.20definition.html#233685634">(Apr 08 2021 at 16:38)</a>:</h4>
<p>For some reason Lean is spending a long time solving for <code>*</code> in <code>foo</code>, and ultimately deciding that it can be anything.</p>



<a name="233686530"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Slow%20definition/near/233686530" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Slow.20definition.html#233686530">(Apr 08 2021 at 16:44)</a>:</h4>
<p>If someone had told me 5 years ago I'd be working with an analyst on universe issues, I would have been extremely skeptical.</p>



<a name="233686697"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Slow%20definition/near/233686697" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Slow.20definition.html#233686697">(Apr 08 2021 at 16:45)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113488-general/topic/Slow.20definition/near/233686530">said</a>:</p>
<blockquote>
<p>If someone had told me 5 years ago I'd be working with an analyst on universe issues, I would have been extremely skeptical.</p>
</blockquote>
<p>Sounds like you're in a different universe now to the one you thought you were in</p>



<a name="233686732"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Slow%20definition/near/233686732" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Slow.20definition.html#233686732">(Apr 08 2021 at 16:46)</a>:</h4>
<p>I'm not really an analyst, you know, more of a dynamical systems/probability person. But still in a different universe, yes :-)</p>



<a name="233686935"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Slow%20definition/near/233686935" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Slow.20definition.html#233686935">(Apr 08 2021 at 16:47)</a>:</h4>
<p>And I've already written a paper relying on the classification of irreducible unitary representations of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>L</mi><mo stretchy="false">(</mo><mn>2</mn><mo separator="true">,</mo><mi mathvariant="double-struck">R</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">SL(2,\R)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathbb">R</span></span><span class="mclose">)</span></span></span></span>, so that almost makes me an automorphic guy also :-)</p>



<a name="233687082"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Slow%20definition/near/233687082" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Slow.20definition.html#233687082">(Apr 08 2021 at 16:48)</a>:</h4>
<p>They're defeq to projective 2-d reps of the Weil group of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">R</mi></mrow><annotation encoding="application/x-tex">\R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">R</span></span></span></span></span> I guess.</p>



<a name="233708350"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Slow%20definition/near/233708350" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Slow.20definition.html#233708350">(Apr 08 2021 at 18:49)</a>:</h4>
<p>Another weirdness I encountered while fixing the slowness. In the file <code>data.mv_polynomial.equiv</code>, on Line 255, there is</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">change</span> <span class="n">algebra_map</span> <span class="n">R</span> <span class="o">(</span><span class="n">mv_polynomial</span> <span class="n">S₁</span> <span class="o">(</span><span class="n">mv_polynomial</span> <span class="n">S₂</span> <span class="n">R</span><span class="o">))</span> <span class="n">r</span> <span class="k">with</span> <span class="n">C</span> <span class="o">(</span><span class="n">C</span> <span class="n">r</span><span class="o">),</span>
</code></pre></div>
<p>which is already slow, and becomes slower after the refactor. You can replace the <code>change</code> with an equivalent</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="k">have</span> <span class="n">A</span> <span class="o">:</span> <span class="n">algebra_map</span> <span class="n">R</span> <span class="o">(</span><span class="n">mv_polynomial</span> <span class="n">S₁</span> <span class="o">(</span><span class="n">mv_polynomial</span> <span class="n">S₂</span> <span class="n">R</span><span class="o">))</span> <span class="n">r</span> <span class="bp">=</span> <span class="n">C</span> <span class="o">(</span><span class="n">C</span> <span class="n">r</span><span class="o">)</span> <span class="o">:=</span> <span class="n">rfl</span>
</code></pre></div>
<p>which takes 64s on my branch. With <code>:= by refl</code>, same thing. With <code>, by refl</code>, it becomes instant (less than 200ms).</p>



<a name="233725304"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Slow%20definition/near/233725304" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Slow.20definition.html#233725304">(Apr 08 2021 at 20:46)</a>:</h4>
<p>Another weird example.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">finite_field.char_poly_pow_card</span> <span class="o">{</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">K</span><span class="o">]</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="n">matrix</span> <span class="n">n</span> <span class="n">n</span> <span class="n">K</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">char_poly</span> <span class="o">(</span><span class="n">M</span> <span class="bp">^</span> <span class="o">(</span><span class="n">fintype.card</span> <span class="n">K</span><span class="o">))</span> <span class="bp">=</span> <span class="n">char_poly</span> <span class="n">M</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">by_cases</span> <span class="n">hn</span> <span class="o">:</span> <span class="n">nonempty</span> <span class="n">n</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">haveI</span> <span class="o">:=</span> <span class="n">hn</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">char_p.exists</span> <span class="n">K</span> <span class="k">with</span> <span class="n">p</span> <span class="n">hp</span><span class="o">,</span> <span class="n">letI</span> <span class="o">:=</span> <span class="n">hp</span><span class="o">,</span>
    <span class="n">rcases</span> <span class="n">finite_field.card</span> <span class="n">K</span> <span class="n">p</span> <span class="k">with</span> <span class="o">⟨⟨</span><span class="n">k</span><span class="o">,</span> <span class="n">kpos</span><span class="o">⟩,</span> <span class="o">⟨</span><span class="n">hp</span><span class="o">,</span> <span class="n">hk</span><span class="o">⟩⟩,</span>
    <span class="n">haveI</span> <span class="o">:</span> <span class="n">fact</span> <span class="n">p.prime</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">hp</span><span class="o">⟩,</span>
    <span class="n">dsimp</span> <span class="n">at</span> <span class="n">hk</span><span class="o">,</span> <span class="n">rw</span> <span class="n">hk</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
    <span class="n">apply</span> <span class="o">(</span><span class="n">frobenius_inj</span> <span class="o">(</span><span class="n">polynomial</span> <span class="n">K</span><span class="o">)</span> <span class="n">p</span><span class="o">)</span><span class="bp">.</span><span class="n">iterate</span> <span class="n">k</span><span class="o">,</span>
    <span class="n">repeat</span> <span class="o">{</span> <span class="n">rw</span> <span class="n">iterate_frobenius</span><span class="o">,</span> <span class="n">rw</span> <span class="bp">←</span> <span class="n">hk</span> <span class="o">},</span>
    <span class="n">rw</span> <span class="bp">←</span> <span class="n">finite_field.expand_card</span><span class="o">,</span>
    <span class="n">unfold</span> <span class="n">char_poly</span><span class="o">,</span> <span class="n">rw</span> <span class="o">[</span><span class="n">alg_hom.map_det</span><span class="o">,</span> <span class="bp">←</span> <span class="n">is_monoid_hom.map_pow</span><span class="o">],</span>
    <span class="n">apply</span> <span class="n">congr_arg</span> <span class="n">det</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">mat_poly_equiv.injective</span><span class="o">,</span> <span class="n">swap</span><span class="o">,</span> <span class="o">{</span> <span class="n">apply_instance</span> <span class="o">},</span>
    <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">mat_poly_equiv.coe_alg_hom</span><span class="o">,</span> <span class="n">alg_hom.map_pow</span><span class="o">,</span> <span class="n">mat_poly_equiv.coe_alg_hom</span><span class="o">,</span>
          <span class="n">mat_poly_equiv_char_matrix</span><span class="o">,</span> <span class="n">hk</span><span class="o">,</span> <span class="n">sub_pow_char_pow_of_commute</span><span class="o">,</span> <span class="bp">←</span> <span class="n">C_pow</span><span class="o">],</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">mat_poly_equiv_eq_X_pow_sub_C</span> <span class="o">(</span><span class="n">p</span> <span class="bp">^</span> <span class="n">k</span><span class="o">)</span> <span class="n">M</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="o">(</span><span class="n">C</span> <span class="n">M</span><span class="o">)</span><span class="bp">.</span><span class="n">commute_X</span> <span class="o">}</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">congr</span><span class="o">,</span> <span class="n">apply</span> <span class="bp">@</span><span class="n">subsingleton.elim</span> <span class="n">_</span> <span class="o">(</span><span class="n">subsingleton_of_empty_left</span> <span class="n">hn</span><span class="o">)</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>
<p>takes 30s on mathlib master. If I change the last three lines to </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>    <span class="o">{</span> <span class="n">exact</span> <span class="o">(</span><span class="n">id</span> <span class="o">(</span><span class="n">mat_poly_equiv_eq_X_pow_sub_C</span> <span class="o">(</span><span class="n">p</span> <span class="bp">^</span> <span class="n">k</span><span class="o">)</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span> <span class="n">_</span><span class="o">)</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="o">(</span><span class="n">C</span> <span class="n">M</span><span class="o">)</span><span class="bp">.</span><span class="n">commute_X</span> <span class="o">}</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">apply</span> <span class="n">congr_arg</span><span class="o">,</span> <span class="n">apply</span> <span class="bp">@</span><span class="n">subsingleton.elim</span> <span class="n">_</span> <span class="o">(</span><span class="n">subsingleton_of_empty_left</span> <span class="n">hn</span><span class="o">)</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="o">},</span>
</code></pre></div>
<p>it goes down to 2s. </p>
<p>This PR is getting me to meet all the corners of mathlib where weird things are going on!</p>



<a name="233879890"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Slow%20definition/near/233879890" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Slow.20definition.html#233879890">(Apr 09 2021 at 19:42)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/issues/7084">#7084</a> is finally building without timeouts. There is an issue with the tests for <code>transport</code>, though, since it can not transport just by itself the <code>nsmul</code> field (or it can not transport the proof that it is equal to the inductive <code>nsmul</code>). Can this be fixed in <code>transport</code>, or should we use another playground for <code>transport</code> tests (or do you think this PR was a bad idea to begin with)? <span class="user-mention" data-user-id="110087">@Scott Morrison</span> , you wrote <code>transport</code>, right?</p>



<a name="233904818"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Slow%20definition/near/233904818" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Slow.20definition.html#233904818">(Apr 09 2021 at 23:11)</a>:</h4>
<p>Yes. Sorry, it's been a while since I worked on <code>transport</code>. Last year I had a long todo list of further improvements, but I stopped working on it for a while. I'd like to get back to it, but I think for now we should just change the tests to avoid this situation.</p>



<a name="233905110"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Slow%20definition/near/233905110" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Slow.20definition.html#233905110">(Apr 09 2021 at 23:14)</a>:</h4>
<p>Hmm.. Actually, I guess this fundamentally breaks <code>transport</code>... :-) I'll see how hard a fix would be.</p>



<a name="233906043"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Slow%20definition/near/233906043" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Slow.20definition.html#233906043">(Apr 09 2021 at 23:26)</a>:</h4>
<p><span class="user-mention" data-user-id="110050">@Sebastien Gouezel</span>, do you know if there is some way to ask <code>refine_struct</code> to make use of optional values? This would solve the problem.</p>



<a name="233907546"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Slow%20definition/near/233907546" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Slow.20definition.html#233907546">(Apr 09 2021 at 23:47)</a>:</h4>
<p>Ah, it was meant to all along, but <a href="https://github.com/leanprover-community/mathlib/issues/2319">#2319</a> accidentally broke it.</p>



<a name="233907810"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Slow%20definition/near/233907810" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Slow.20definition.html#233907810">(Apr 09 2021 at 23:50)</a>:</h4>
<p>Okay <a href="https://github.com/leanprover-community/mathlib/issues/7143">#7143</a> will fix this problem. I'd suggest just merging it into <a href="https://github.com/leanprover-community/mathlib/issues/7084">#7084</a>.</p>



<a name="233952880"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Slow%20definition/near/233952880" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Slow.20definition.html#233952880">(Apr 10 2021 at 12:51)</a>:</h4>
<p>Unfortunately <a href="https://github.com/leanprover-community/mathlib/issues/7143">#7143</a> doesn't work at all, so I've marked it WIP, and am hoping for some help from Simon.</p>



<a name="233953985"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Slow%20definition/near/233953985" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Slow.20definition.html#233953985">(Apr 10 2021 at 13:08)</a>:</h4>
<p>I think I've found a workaround, switching to better requirements for <code>nsmul</code> that should be more in line with what <code>transfer</code> can do.</p>



<a name="234046579"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Slow%20definition/near/234046579" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Slow.20definition.html#234046579">(Apr 11 2021 at 13:54)</a>:</h4>
<p>I've now changed the definition of <code>add_monoid</code> in <a href="https://github.com/leanprover-community/mathlib/issues/7084">#7084</a>. It is now</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">add_monoid</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">add_semigroup</span> <span class="n">M</span><span class="o">,</span> <span class="n">add_zero_class</span> <span class="n">M</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">nsmul</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">M</span> <span class="o">:=</span> <span class="n">nsmul_rec</span><span class="o">)</span>
<span class="o">(</span><span class="n">nsmul_zero'</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">nsmul</span> <span class="mi">0</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">.</span> <span class="n">try_refl_tac</span><span class="o">)</span>
<span class="o">(</span><span class="n">nsmul_succ'</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="n">x</span><span class="o">,</span> <span class="n">nsmul</span> <span class="n">n.succ</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">nsmul</span> <span class="n">n</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">x</span> <span class="bp">.</span> <span class="n">try_refl_tac</span><span class="o">)</span>
</code></pre></div>
<p>so, just using addition and multiplication to express the properties one wants of <code>nsmul</code>. This is the kind of thing that transfer should like more, and indeed in the tests <code>transfer</code> has no difficulty transferring a <code>semiring</code> instance with this new definition. Some tests are failing, but just because the definition is not the same so there are more fields to fill. <span class="user-mention" data-user-id="110087">@Scott Morrison</span> , I could fix the tests myself but I am not sure what they are testing, so it is maybe better if you have a look yourself. If you trust me to fix them, tell me and I'll do it!</p>



<a name="234046604"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Slow%20definition/near/234046604" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Slow.20definition.html#234046604">(Apr 11 2021 at 13:54)</a>:</h4>
<p>You mean <code>transport</code> not <code>transfer</code>, right?</p>



<a name="234046620"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Slow%20definition/near/234046620" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Slow.20definition.html#234046620">(Apr 11 2021 at 13:55)</a>:</h4>
<p>I'll look now.</p>



<a name="234047079"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Slow%20definition/near/234047079" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Slow.20definition.html#234047079">(Apr 11 2021 at 14:01)</a>:</h4>
<p>I fixed the tests for <code>equiv_rw</code>, but am a bit stumped by the failure of the test for <code>transport</code>. It works for semiring at the top of the file, but then not at the bottom.</p>



<a name="234047881"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Slow%20definition/near/234047881" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Slow.20definition.html#234047881">(Apr 11 2021 at 14:12)</a>:</h4>
<p>I've also fixed the tests for <code>refine_struct</code>. <code>transport</code> itself really shouldn't care how many fields there are: it works that out for the structure itself.</p>



<a name="234048144"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Slow%20definition/near/234048144" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Slow.20definition.html#234048144">(Apr 11 2021 at 14:16)</a>:</h4>
<p>Oh!</p>



<a name="234048203"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Slow%20definition/near/234048203" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Slow.20definition.html#234048203">(Apr 11 2021 at 14:17)</a>:</h4>
<p>The problem is that the second test for <code>transport</code> is transporting between <code>nat</code> and <code>mynat</code>. When it gets to the <code>npow</code> field, it can't tell the difference between the copies of <code>nat</code> that it is meant to transport to <code>mynat</code> (because they are the carrier type of the semiring), and the copies of <code>nat</code> that are referring to powers, and just be left invariant.</p>



<a name="234048339"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Slow%20definition/near/234048339" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Slow.20definition.html#234048339">(Apr 11 2021 at 14:19)</a>:</h4>
<p>It's late here, but I will try to think about a good solution to this. Not sure at this point.</p>



<a name="234061725"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Slow%20definition/near/234061725" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Slow.20definition.html#234061725">(Apr 11 2021 at 17:22)</a>:</h4>
<p>Isn't it just that the test is unfortunate here? Doing the same with <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">R</mi></mrow><annotation encoding="application/x-tex">\R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">R</span></span></span></span></span> instead of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">N</mi></mrow><annotation encoding="application/x-tex">\N</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">N</span></span></span></span></span> should avoid this issue, right?</p>



<a name="234083593"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Slow%20definition/near/234083593" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Slow.20definition.html#234083593">(Apr 11 2021 at 23:09)</a>:</h4>
<p>Yes.</p>



<a name="234140864"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Slow%20definition/near/234140864" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Slow.20definition.html#234140864">(Apr 12 2021 at 11:20)</a>:</h4>
<p>I have fixed the test by using the general <code>semiring.map</code> defined at the top of the file (which is defined for a generic ring and therefore not perturbed by the coincidental fact that our ring is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">N</mi></mrow><annotation encoding="application/x-tex">\N</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">N</span></span></span></span></span>). I hope it's ok.</p>



<a name="234141411"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Slow%20definition/near/234141411" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Slow.20definition.html#234141411">(Apr 12 2021 at 11:25)</a>:</h4>
<p>There is another test failing in  <a href="https://github.com/leanprover-community/mathlib/issues/7084">#7084</a>, for <code>ring_exp</code> (hopefully the last one!)</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="n">b</span><span class="o">)</span> <span class="bp">^</span> <span class="mi">1000000</span> <span class="bp">=</span> <span class="o">(</span><span class="n">b</span> <span class="bp">*</span> <span class="n">a</span><span class="o">)</span> <span class="bp">^</span> <span class="mi">1000000</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">ring_exp</span>
<span class="c1">-- deep recursion was detected at 'replace' (potential solution: increase stack space in your system)</span>
</code></pre></div>
<p>This is probably due to the fact that I changed the definition of powers (now, <code>x ^ n.succ</code> is definitionally <code>x ^ n * x</code>, while it used to be <code>x * x^n</code>). I don't understand the internals of <code>ring_exp</code> enough to be able to fix this. <span class="user-mention" data-user-id="238446">@Anne Baanen</span> , do you think you could have a look or give me a hint where to look?</p>



<a name="234141925"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Slow%20definition/near/234141925" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Slow.20definition.html#234141925">(Apr 12 2021 at 11:30)</a>:</h4>
<p>It's not supposed to use defeq to unfold <code>pow</code>s, instead applying the <a href="https://github.com/leanprover-community/mathlib/blob/nsmul_data/src/tactic/ring_exp.lean#L1091"><code>pow_p_pf_succ</code></a> family of lemmas. Those still typecheck, right?</p>



<a name="234142121"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Slow%20definition/near/234142121" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Slow.20definition.html#234142121">(Apr 12 2021 at 11:32)</a>:</h4>
<p>Would it work to fix the previous commit, or should I wait for the new oleans to be built?</p>



<a name="234142269"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Slow%20definition/near/234142269" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Slow.20definition.html#234142269">(Apr 12 2021 at 11:33)</a>:</h4>
<p>Fixing the previous commit would be perfect.</p>



<a name="234142385"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Slow%20definition/near/234142385" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Slow.20definition.html#234142385">(Apr 12 2021 at 11:34)</a>:</h4>
<p>Yes, all the lemmas still typecheck, the problem only shows up in this specific test.</p>



<a name="234142483"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Slow%20definition/near/234142483" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Slow.20definition.html#234142483">(Apr 12 2021 at 11:35)</a>:</h4>
<p>Strangely enough, the test works if one replaces <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">Q</mi></mrow><annotation encoding="application/x-tex">\mathbb{Q}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.85556em;vertical-align:-0.16667em;"></span><span class="mord"><span class="mord mathbb">Q</span></span></span></span></span> with <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">N</mi></mrow><annotation encoding="application/x-tex">\N</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">N</span></span></span></span></span>, or a general <code>comm_ring</code>.</p>



<a name="234142774"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Slow%20definition/near/234142774" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Slow.20definition.html#234142774">(Apr 12 2021 at 11:38)</a>:</h4>
<p>The proof term looks like it typechecks too, so it is the last <code>exact</code> that fails.</p>



<a name="234143424"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Slow%20definition/near/234143424" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Slow.20definition.html#234143424">(Apr 12 2021 at 11:45)</a>:</h4>
<p><del>I think it's a general bug that <code>ring_exp</code> happens to expose:</del></p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">my_op</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="n">a</span> <span class="bp">^</span> <span class="mi">10000000000</span>
<span class="kd">example</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">)</span> <span class="o">:</span> <span class="n">my_op</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">^</span> <span class="mi">100000000000</span> <span class="o">:=</span> <span class="n">rfl</span> <span class="c1">-- deep recursion detected at replace</span>
</code></pre></div>



<a name="234143595"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Slow%20definition/near/234143595" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Slow.20definition.html#234143595">(Apr 12 2021 at 11:46)</a>:</h4>
<p>Nevermind, miscopied the number of 0's</p>



<a name="234144796"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Slow%20definition/near/234144796" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Slow.20definition.html#234144796">(Apr 12 2021 at 11:57)</a>:</h4>
<p>But overall yes, seems that this is an artifact of bad unfolding of the definition of <code>npow</code>. The following works:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">local</span> <span class="kn">attribute</span> <span class="o">[</span><span class="n">irreducible</span><span class="o">]</span> <span class="n">npow_rec</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="n">b</span><span class="o">)</span> <span class="bp">^</span> <span class="mi">1000000</span> <span class="bp">=</span> <span class="o">(</span><span class="n">b</span> <span class="bp">*</span> <span class="n">a</span><span class="o">)</span> <span class="bp">^</span> <span class="mi">1000000</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">ring_exp</span> <span class="c1">-- works</span>
</code></pre></div>



<a name="234145138"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Slow%20definition/near/234145138" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Slow.20definition.html#234145138">(Apr 12 2021 at 12:00)</a>:</h4>
<p>Ah, and changing elaboration order by going from <code>example</code> to <code>lemma</code> breaks the <code>my_op</code> example:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">my_op</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="n">a</span> <span class="bp">^</span> <span class="mi">10000</span>
<span class="kd">lemma</span> <span class="n">fooQ</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">)</span> <span class="o">:</span> <span class="n">my_op</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">^</span> <span class="mi">10000</span> <span class="o">:=</span> <span class="n">rfl</span> <span class="c1">-- deep recursion detected at replace</span>
<span class="kd">lemma</span> <span class="n">fooN</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">my_op</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">^</span> <span class="mi">10000</span> <span class="o">:=</span> <span class="n">rfl</span> <span class="c1">-- works</span>

<span class="kn">local</span> <span class="kn">attribute</span> <span class="o">[</span><span class="n">irreducible</span><span class="o">]</span> <span class="n">npow_rec</span>

<span class="kd">lemma</span> <span class="n">fooQ'</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">)</span> <span class="o">:</span> <span class="n">my_op</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">^</span> <span class="mi">10000</span> <span class="o">:=</span> <span class="n">rfl</span> <span class="c1">-- works</span>
</code></pre></div>



<a name="234145654"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Slow%20definition/near/234145654" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Slow.20definition.html#234145654">(Apr 12 2021 at 12:04)</a>:</h4>
<p>Is there an easy way to suggest to lean "when unifying <code>@npow α inst1 x n =?= @npow α inst2 x n</code>, try unifying <code>inst1</code> with <code>inst2</code> before unfolding the whole thing"?</p>



<a name="234145676"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Slow%20definition/near/234145676" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Slow.20definition.html#234145676">(Apr 12 2021 at 12:04)</a>:</h4>
<p>(I guess making <code>npow_rec</code> irreducible is close enough.)</p>



<a name="234150856"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Slow%20definition/near/234150856" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Slow.20definition.html#234150856">(Apr 12 2021 at 12:46)</a>:</h4>
<p>Here's my attempt at fixing this by making <code>npow_rec</code> irreducible (doesn't build yet because there are still some uses of reducible <code>npow_rec</code>): <a href="https://github.com/leanprover-community/mathlib/commit/7dc0d02c8610d881cd33f1605c3315518484b8fb">https://github.com/leanprover-community/mathlib/commit/7dc0d02c8610d881cd33f1605c3315518484b8fb</a></p>
<p>If we make <code>npow_rec</code> irreducible, we can't prove its properties anymore by <code>try_refl_tac</code> in the instances. I made a new <code>npow_zero_tac</code> and <code>npow_succ_tac</code> that try to apply the correct definitional lemmas. Unfolding <code>npow_rec</code> in <code>try_refl_tac</code> doesn't work always, since it may appear in a form like <code>div_inv_monoid.npow._default</code>.</p>



<a name="234163224"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Slow%20definition/near/234163224" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Slow.20definition.html#234163224">(Apr 12 2021 at 14:00)</a>:</h4>
<p>What I don't get is why it didn't show up before. Is it that one definition <code>x^(n+1) = x * x^n</code> is optimized by tail-recursion and the other <code>x^(n+1) = x^n * x</code> is not? If this is the case, I should definitely switch back to the original definition. I'd like to avoid putting <code>npow_rec</code> irreducible, because being able to compute small powers by <code>rfl</code> on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">N</mi></mrow><annotation encoding="application/x-tex">\mathbb{N}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">N</span></span></span></span></span> or <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">Q</mi></mrow><annotation encoding="application/x-tex">\mathbb{Q}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.85556em;vertical-align:-0.16667em;"></span><span class="mord"><span class="mord mathbb">Q</span></span></span></span></span> seems desirable.</p>



<a name="234170097"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Slow%20definition/near/234170097" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Slow.20definition.html#234170097">(Apr 12 2021 at 14:37)</a>:</h4>
<p>The issue is not with the definition of <code>npow</code> itself, it's the fact that there are many <code>npow</code> fields available, so to unify <code>some_class_extending_monoid.npow</code> with <code>some_other_class_extending_monoid.npow</code> we need to unfold both sides a couple of times. But if one side has a shorter path to <code>npow_rec</code> than another, it will unfold the definition of <code>npow_rec</code>, actually calculating the outcome.</p>



<a name="234170259"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Slow%20definition/near/234170259" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Slow.20definition.html#234170259">(Apr 12 2021 at 14:38)</a>:</h4>
<p>So the better comparison is: why doesn't this happen for the <code>(+)</code> operator on <code>ℕ</code>?</p>



<a name="234170581"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Slow%20definition/near/234170581" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Slow.20definition.html#234170581">(Apr 12 2021 at 14:40)</a>:</h4>
<p>Is it just that <code>npow</code> causes the terms to grow exponentially?</p>



<a name="234170695"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Slow%20definition/near/234170695" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Slow.20definition.html#234170695">(Apr 12 2021 at 14:40)</a>:</h4>
<p>I think it's really a tail-recursion optimization. Look at the following:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">mypow1</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="n">x</span> <span class="o">:=</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">mypow1</span> <span class="n">n</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">x</span>

<span class="kd">def</span> <span class="n">haspow1</span> <span class="o">:</span> <span class="n">has_pow</span> <span class="n">ℚ</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">x</span> <span class="n">n</span><span class="o">,</span> <span class="n">mypow1</span> <span class="n">n</span> <span class="n">x</span><span class="o">⟩</span>
<span class="kd">def</span> <span class="n">my_op1</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="n">mypow1</span> <span class="mi">10000</span> <span class="n">a</span>
<span class="kd">lemma</span> <span class="n">foo1</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">)</span> <span class="o">:</span> <span class="n">my_op1</span> <span class="n">a</span> <span class="bp">=</span> <span class="bp">@</span><span class="n">has_pow.pow</span> <span class="n">ℚ</span> <span class="n">ℕ</span> <span class="n">haspow1</span> <span class="n">a</span> <span class="mi">10000</span>  <span class="o">:=</span> <span class="n">rfl</span> <span class="c1">-- deep recursion detected at replace</span>

<span class="kd">def</span> <span class="n">mypow2</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="n">x</span> <span class="o">:=</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">mypow2</span> <span class="n">n</span> <span class="n">x</span>

<span class="kd">def</span> <span class="n">haspow2</span> <span class="o">:</span> <span class="n">has_pow</span> <span class="n">ℚ</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">x</span> <span class="n">n</span><span class="o">,</span> <span class="n">mypow2</span> <span class="n">n</span> <span class="n">x</span><span class="o">⟩</span>
<span class="kd">def</span> <span class="n">my_op2</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="n">mypow2</span> <span class="mi">10000</span> <span class="n">a</span>
<span class="kd">lemma</span> <span class="n">foo2</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">)</span> <span class="o">:</span> <span class="n">my_op2</span> <span class="n">a</span> <span class="bp">=</span> <span class="bp">@</span><span class="n">has_pow.pow</span> <span class="n">ℚ</span> <span class="n">ℕ</span> <span class="n">haspow2</span> <span class="n">a</span> <span class="mi">10000</span>  <span class="o">:=</span> <span class="n">rfl</span> <span class="c1">-- works</span>
</code></pre></div>
<p>Exact same definition for both, but one with left multiplication and the other one with right multiplication. One works, the other fails.</p>



<a name="234170787"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Slow%20definition/near/234170787" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Slow.20definition.html#234170787">(Apr 12 2021 at 14:41)</a>:</h4>
<p>I'll switch back to the other direction, even if it makes some things more painful.</p>



<a name="234170822"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Slow%20definition/near/234170822" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Slow.20definition.html#234170822">(Apr 12 2021 at 14:41)</a>:</h4>
<p>(And I'll add a comment explaining why it has to be done this way).</p>



<a name="234170859"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Slow%20definition/near/234170859" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Slow.20definition.html#234170859">(Apr 12 2021 at 14:41)</a>:</h4>
<p>Huh, but the recursive call isn't in tail position for those definitions.</p>



<a name="234171010"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Slow%20definition/near/234171010" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Slow.20definition.html#234171010">(Apr 12 2021 at 14:42)</a>:</h4>
<p>It might depend on how multiplication is defined, no?</p>



<a name="234171298"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Slow%20definition/near/234171298" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Slow.20definition.html#234171298">(Apr 12 2021 at 14:44)</a>:</h4>
<p>This is always a "proper" tail-recursive definition, but still fails:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">mypow3</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="n">x</span> <span class="n">acc</span> <span class="o">:=</span> <span class="n">acc</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">x</span> <span class="n">acc</span> <span class="o">:=</span> <span class="n">mypow3</span> <span class="n">n</span> <span class="n">x</span> <span class="o">(</span><span class="n">acc</span> <span class="bp">*</span> <span class="n">x</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">haspow3</span> <span class="o">:</span> <span class="n">has_pow</span> <span class="n">ℚ</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">x</span> <span class="n">n</span><span class="o">,</span> <span class="n">mypow3</span> <span class="n">n</span> <span class="n">x</span> <span class="mi">1</span><span class="o">⟩</span>
<span class="kd">def</span> <span class="n">my_op3</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="n">mypow3</span> <span class="mi">10000</span> <span class="n">a</span> <span class="mi">1</span>
<span class="kd">lemma</span> <span class="n">foo3</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">)</span> <span class="o">:</span> <span class="n">my_op3</span> <span class="n">a</span> <span class="bp">=</span> <span class="bp">@</span><span class="n">has_pow.pow</span> <span class="n">ℚ</span> <span class="n">ℕ</span> <span class="n">haspow3</span> <span class="n">a</span> <span class="mi">10000</span> <span class="o">:=</span> <span class="n">rfl</span> <span class="c1">-- deep recursion detected at replace</span>
</code></pre></div>



<a name="234172002"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Slow%20definition/near/234172002" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Slow.20definition.html#234172002">(Apr 12 2021 at 14:48)</a>:</h4>
<p>Really weird...</p>



<a name="234172431"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Slow%20definition/near/234172431" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Slow.20definition.html#234172431">(Apr 12 2021 at 14:50)</a>:</h4>
<p>Looking at the <code>set_option trace.type_context.is_def_eq_detail true</code>, for some reason Lean really wants to unfold only the <code>mypow3</code> on the right hand side:</p>
<div class="codehilite" data-code-language="Text only"><pre><span></span><code>[type_context.is_def_eq_detail] [2]: a ^ 10000 =?= my_op3 a
[type_context.is_def_eq_detail] unfold right: my_op3
[type_context.is_def_eq_detail] [3]: a ^ 10000 =?= mypow3 10000 a 1
[type_context.is_def_eq_detail] unfold right: mypow3
[type_context.is_def_eq_detail] [4]: a ^ 10000 =?= mypow3 (5000.add (2500.add (1250.add (62
5.add (624.add 0))))) a (1 * a)
[type_context.is_def_eq_detail] unfold right: mypow3
[type_context.is_def_eq_detail] [5]: a ^ 10000 =?= mypow3 (5000.add (2500.add (1250.add (62
5.add (312.add (156.add (78.add (39.add (38.add 0))))))))) a (1 * a * a)
[type_context.is_def_eq_detail] unfold right: mypow3
[type_context.is_def_eq_detail] [6]: a ^ 10000 =?= mypow3 (5000.add (2500.add (1250.add (62
5.add (312.add (156.add (78.add (39.add (19.add (18.add 0)))))))))) a
  (1 * a * a * a)
[type_context.is_def_eq_detail] unfold right: mypow3
[type_context.is_def_eq_detail] [7]: a ^ 10000 =?= mypow3 (5000.add (2500.add (1250.add (62
5.add (312.add (156.add (78.add (39.add (19.add (9.add (8.add 0))))))))))) a
  (1 * a * a * a * a)
[type_context.is_def_eq_detail] unfold right: mypow3
[type_context.is_def_eq_detail] [8]: a ^ 10000 =?= mypow3
  (5000.add
     (2500.add (1250.add (625.add (312.add (156.add (78.add (39.add (19.add (9.add (4.add (
2.add (1.add 0)))))))))))))
  a
  (1 * a * a * a * a * a)
[type_context.is_def_eq_detail] unfold right: mypow3
...
</code></pre></div>



<a name="234172704"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Slow%20definition/near/234172704" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Slow.20definition.html#234172704">(Apr 12 2021 at 14:52)</a>:</h4>
<p>(From the Lean source: because <code>mypow3</code> can be delta-reduced, and <code>has_pow.pow</code> cannot?)</p>



<a name="234173134"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Slow%20definition/near/234173134" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Slow.20definition.html#234173134">(Apr 12 2021 at 14:54)</a>:</h4>
<p>So we actually want non-tail recursive definitions? It looks like, for <code>foo2</code>, they block the delta-reducing:</p>
<div class="codehilite" data-code-language="Text only"><pre><span></span><code>[type_context.is_def_eq_detail] [2]: a ^ 10000 =?= my_op2 a
[type_context.is_def_eq_detail] unfold right: my_op2
[type_context.is_def_eq_detail] [3]: a ^ 10000 =?= mypow2 10000 a
[type_context.is_def_eq_detail] unfold right: mypow2
[type_context.is_def_eq_detail] [4]: a ^ 10000 =?= a * mypow2 (5000.add (2500.add (1250.add (625.add (624.add 0))))) a
[type_context.is_def_eq_detail] [5]: (λ (x : ℚ) (n : ℕ), mypow2 n x) a 10000 =?= distrib.mul a (mypow2 (5000.add (2500.add (1250.add (625.add (624.add 0))))) a)
[type_context.is_def_eq_detail] after whnf_core: mypow2 10000 a =?= distrib.mul a (mypow2 (5000.add (2500.add (1250.add (625.add (624.add 0))))) a)
[type_context.is_def_eq_detail] unfold left: mypow2
[type_context.is_def_eq_detail] [6]: a * mypow2 (5000.add (2500.add (1250.add (625.add (624.add 0))))) a =?= distrib.mul a (mypow2 (5000.add (2500.add (1250.add (625.add (624.add 0))))) a)
[type_context.is_def_eq_detail] [7]: distrib.mul a (mypow2 (5000.add (2500.add (1250.add (625.add (624.add 0))))) a) =?= semiring.mul a (mypow2 (5000.add (2500.add (1250.add (625.add (624.add 0))))) a)
[type_context.is_def_eq_detail] [8]: semiring.mul a (mypow2 (5000.add (2500.add (1250.add (625.add (624.add 0))))) a) =?= comm_semiring.mul a (mypow2 (5000.add (2500.add (1250.add (625.add (624.add 0))))) a)
[type_context.is_def_eq_detail] [9]: comm_semiring.mul a (mypow2 (5000.add (2500.add (1250.add (625.add (624.add 0))))) a) =?= comm_ring.mul a (mypow2 (5000.add (2500.add (1250.add (625.add (624.add 0))))) a)
[type_context.is_def_eq_detail] [10]: comm_ring.mul a (mypow2 (5000.add (2500.add (1250.add (625.add (624.add 0))))) a) =?= euclidean_domain.mul a (mypow2 (5000.add (2500.add (1250.add (625.add (624.add 0))))) a)
[type_context.is_def_eq_detail] [11]: euclidean_domain.mul a (mypow2 (5000.add (2500.add (1250.add (625.add (624.add 0))))) a) =?= a * mypow2 (5000.add (2500.add (1250.add (625.add (624.add 0))))) a
[type_context.is_def_eq_detail] [12]: a * mypow2 (5000.add (2500.add (1250.add (625.add (624.add 0))))) a =?= distrib.mul a (mypow2 (5000.add (2500.add (1250.add (625.add (624.add 0))))) a)
[type_context.is_def_eq_detail] [13]: distrib.mul a (mypow2 (5000.add (2500.add (1250.add (625.add (624.add 0))))) a) =?= ring.mul a (mypow2 (5000.add (2500.add (1250.add (625.add (624.add 0))))) a)
[type_context.is_def_eq_detail] [14]: ring.mul a (mypow2 (5000.add (2500.add (1250.add (625.add (624.add 0))))) a) =?= division_ring.mul a (mypow2 (5000.add (2500.add (1250.add (625.add (624.add 0))))) a)
[type_context.is_def_eq_detail] [15]: division_ring.mul a (mypow2 (5000.add (2500.add (1250.add (625.add (624.add 0))))) a) =?= field.mul a (mypow2 (5000.add (2500.add (1250.add (625.add (624.add 0))))) a)
[type_context.is_def_eq_detail] [16]: field.mul a (mypow2 (5000.add (2500.add (1250.add (625.add (624.add 0))))) a) =?= a.mul (mypow2 (5000.add (2500.add (1250.add (625.add (624.add : ...
</code></pre></div>



<a name="234188922"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Slow%20definition/near/234188922" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Slow.20definition.html#234188922">(Apr 12 2021 at 16:26)</a>:</h4>
<p>Would an <code>id_delta</code> help? edit: I can't see a way</p>



<a name="234189539"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Slow%20definition/near/234189539" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Slow.20definition.html#234189539">(Apr 12 2021 at 16:30)</a>:</h4>
<p>I'll just switch to the <code>mypow2</code> definition, which works fine.</p>



<a name="234189975"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Slow%20definition/near/234189975" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Slow.20definition.html#234189975">(Apr 12 2021 at 16:33)</a>:</h4>
<p>This is probably worth filing as a github issue since you have a MWE, just so it doesn't get forgotten</p>



<a name="234219220"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Slow%20definition/near/234219220" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Slow.20definition.html#234219220">(Apr 12 2021 at 19:49)</a>:</h4>
<p><a href="https://github.com/leanprover-community/lean/issues/563">lean#563</a></p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
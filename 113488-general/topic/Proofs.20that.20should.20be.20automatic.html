---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/Proofs.20that.20should.20be.20automatic.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic.html">Proofs that should be automatic</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="293714901"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proofs%20that%20should%20be%20automatic/near/293714901" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic.html#293714901">(Aug 16 2022 at 13:21)</a>:</h4>
<p>I recently decided that I'm far too tolerant when Lean asks me to prove trivialities. Today I decided I'd start collecting a list of stark examples of proofs that:</p>
<ul>
<li>Lean seems unable to do automatically</li>
<li>Lean really should be able to do automatically</li>
</ul>



<a name="293715052"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proofs%20that%20should%20be%20automatic/near/293715052" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic.html#293715052">(Aug 16 2022 at 13:22)</a>:</h4>
<p>I just encountered my first potential example:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.set.basic</span>

<span class="kn">open</span> <span class="n">set</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">U</span> <span class="n">V</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">hUV</span> <span class="o">:</span> <span class="n">U</span> <span class="bp">∪</span> <span class="n">V</span> <span class="bp">=</span> <span class="n">univ</span><span class="o">)</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">∉</span> <span class="n">U</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">V</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">replace</span> <span class="n">hUV</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">U</span> <span class="bp">∨</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">V</span><span class="o">,</span> <span class="o">{</span> <span class="n">rw</span> <span class="bp">←</span> <span class="n">mem_union</span><span class="o">,</span> <span class="n">simp</span> <span class="o">[</span><span class="n">hUV</span><span class="o">],</span> <span class="o">},</span>
  <span class="n">tauto</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="293715086"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proofs%20that%20should%20be%20automatic/near/293715086" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic.html#293715086">(Aug 16 2022 at 13:22)</a>:</h4>
<p>My question is: is this really an example or am I missing a tactic / trick?</p>



<a name="293718544"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proofs%20that%20should%20be%20automatic/near/293718544" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic.html#293718544">(Aug 16 2022 at 13:29)</a>:</h4>
<p>You should state <code>U ∪ V = univ</code> as <code>codisjoint U V</code>.</p>



<a name="293718560"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proofs%20that%20should%20be%20automatic/near/293718560" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic.html#293718560">(Aug 16 2022 at 13:29)</a>:</h4>
<p>This also works:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">U</span> <span class="n">V</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">hUV</span> <span class="o">:</span> <span class="n">U</span> <span class="bp">∪</span> <span class="n">V</span> <span class="bp">=</span> <span class="n">univ</span><span class="o">)</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">∉</span> <span class="n">U</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">V</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="n">set.ext_iff</span> <span class="n">at</span> <span class="n">hUV</span><span class="o">,</span>
  <span class="n">simpa</span> <span class="o">[</span><span class="n">ha</span><span class="o">]</span> <span class="n">using</span> <span class="n">hUV</span> <span class="n">a</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="293719401"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proofs%20that%20should%20be%20automatic/near/293719401" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic.html#293719401">(Aug 16 2022 at 13:34)</a>:</h4>
<p><span class="user-mention silent" data-user-id="387244">Yaël Dillies</span> <a href="#narrow/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic/near/293718544">said</a>:</p>
<blockquote>
<p>You should state <code>U ∪ V = univ</code> as <code>codisjoint U V</code>.</p>
</blockquote>
<p>Maybe this would be a better idiom but I don't think it addresses my point.</p>



<a name="294967950"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proofs%20that%20should%20be%20automatic/near/294967950" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic.html#294967950">(Aug 24 2022 at 01:15)</a>:</h4>
<p>What is the behaviour you expect?</p>



<a name="294968098"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proofs%20that%20should%20be%20automatic/near/294968098" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic.html#294968098">(Aug 24 2022 at 01:18)</a>:</h4>
<p>I'm not at a computer to be able to try it, but I would solve this via:</p>
<ul>
<li>a \mem univ</li>
<li>a \mem U union V (rw hUV)</li>
<li>a \mem U or a \mem V </li>
<li>a \mem V (using ha in some suitable logic lemma)</li>
</ul>
<p>I'm honestly not sure you could ask for more than that?</p>



<a name="294968203"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proofs%20that%20should%20be%20automatic/near/294968203" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic.html#294968203">(Aug 24 2022 at 01:20)</a>:</h4>
<p>and Eric's proof is imo proof that lean seems to be able to do it.</p>



<a name="294968269"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proofs%20that%20should%20be%20automatic/near/294968269" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic.html#294968269">(Aug 24 2022 at 01:21)</a>:</h4>
<p>do we have codisjoint U V iff forall a, a mem U or a mem V? Because it strikes me that that lemma might be useful here</p>



<a name="294980465"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proofs%20that%20should%20be%20automatic/near/294980465" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic.html#294980465">(Aug 24 2022 at 05:04)</a>:</h4>
<p>Not yet, no.</p>



<a name="294981185"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proofs%20that%20should%20be%20automatic/near/294981185" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic.html#294981185">(Aug 24 2022 at 05:12)</a>:</h4>
<p>It's not true for things like groups</p>



<a name="294994974"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proofs%20that%20should%20be%20automatic/near/294994974" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic.html#294994974">(Aug 24 2022 at 07:45)</a>:</h4>
<p><span class="user-mention silent" data-user-id="330967">Wrenna Robson</span> <a href="#narrow/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic/near/294967950">said</a>:</p>
<blockquote>
<p>What is the behaviour you expect?</p>
</blockquote>
<p>I would like Lean never present me with something this trivial but if it ever did, I would like a tactic like <code>tauto</code> to close it.</p>



<a name="294999749"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proofs%20that%20should%20be%20automatic/near/294999749" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic.html#294999749">(Aug 24 2022 at 08:20)</a>:</h4>
<p>I don't think this is a realistic expectation.</p>



<a name="294999851"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proofs%20that%20should%20be%20automatic/near/294999851" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic.html#294999851">(Aug 24 2022 at 08:21)</a>:</h4>
<p>What if you replace hUV in your example with "a \mem U union V"?</p>



<a name="294999916"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proofs%20that%20should%20be%20automatic/near/294999916" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic.html#294999916">(Aug 24 2022 at 08:21)</a>:</h4>
<p>That feels at least more reasonable to expect to be tautologous.</p>



<a name="295000029"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proofs%20that%20should%20be%20automatic/near/295000029" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic.html#295000029">(Aug 24 2022 at 08:22)</a>:</h4>
<p>Wrenna, this would be automatic in Isabelle. Oliver's point is that we don't have enough automation in mathlib.</p>



<a name="295000061"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proofs%20that%20should%20be%20automatic/near/295000061" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic.html#295000061">(Aug 24 2022 at 08:22)</a>:</h4>
<p>hmm, fair enough</p>



<a name="295000147"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proofs%20that%20should%20be%20automatic/near/295000147" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic.html#295000147">(Aug 24 2022 at 08:23)</a>:</h4>
<p>I would have assumed an automator would trip on the fact that hUV is much stronger than needed so you need to work out what to use.</p>



<a name="295000187"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proofs%20that%20should%20be%20automatic/near/295000187" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic.html#295000187">(Aug 24 2022 at 08:23)</a>:</h4>
<p>how would Isabelle do it; what is the approach they use?</p>



<a name="295000345"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proofs%20that%20should%20be%20automatic/near/295000345" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic.html#295000345">(Aug 24 2022 at 08:25)</a>:</h4>
<p>I don't disagree by the way that we could do with more automation in mathlib.</p>



<a name="295000456"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proofs%20that%20should%20be%20automatic/near/295000456" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic.html#295000456">(Aug 24 2022 at 08:25)</a>:</h4>
<p>I know almost nothing about proof automation. My hope in starting this thread was that we might assemble a corpus of test cases that some smart person writing such tactics could use.</p>



<a name="295000463"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proofs%20that%20should%20be%20automatic/near/295000463" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic.html#295000463">(Aug 24 2022 at 08:26)</a>:</h4>
<p>Isabelle has a lot (like <strong>a lot</strong>) of automation, but I expect this would be solved using sledgehammer, which is a very polyvalent self-replacing tactic. How it works is that you write your proof forwardly and automation tries to fill in the step every time. If it doesn't get it, you give it more hints and try again.</p>



<a name="295000581"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proofs%20that%20should%20be%20automatic/near/295000581" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic.html#295000581">(Aug 24 2022 at 08:26)</a>:</h4>
<p>Someone could try this example in Isabelle, but I expect it needs at most one hint.</p>



<a name="295000861"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proofs%20that%20should%20be%20automatic/near/295000861" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic.html#295000861">(Aug 24 2022 at 08:29)</a>:</h4>
<p>right I would expect it to be able to do it with a single hint! but not from nothing.</p>



<a name="295000901"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proofs%20that%20should%20be%20automatic/near/295000901" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic.html#295000901">(Aug 24 2022 at 08:29)</a>:</h4>
<p>Eric's solution is very nearly that.</p>



<a name="295001217"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proofs%20that%20should%20be%20automatic/near/295001217" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic.html#295001217">(Aug 24 2022 at 08:31)</a>:</h4>
<p>like that simpa is doing a reasonable degree of automation</p>



<a name="295002622"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proofs%20that%20should%20be%20automatic/near/295002622" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic.html#295002622">(Aug 24 2022 at 08:42)</a>:</h4>
<p>But Eric still had to come up with it! I'm sorry to break it to you, but Eric is not your tactic.</p>



<a name="295004416"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proofs%20that%20should%20be%20automatic/near/295004416" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic.html#295004416">(Aug 24 2022 at 08:54)</a>:</h4>
<p>what about <code>yael_search</code>? :b</p>
<p>On a serious note, these sort of proofs maybe need a self-replacing tactic a-la <code>polyrith</code>, or <code>(i)tauto</code> needs to be able to expand common definitions (at least to do with sets/finsets). <code>simp</code> is very flexible but having to come up with a neat <code>simp(a)</code> proof for everything is not only annoying, but distracting from what you're working towards</p>



<a name="295004527"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proofs%20that%20should%20be%20automatic/near/295004527" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic.html#295004527">(Aug 24 2022 at 08:55)</a>:</h4>
<p>Here, I would expect automation to use <a href="https://leanprover-community.github.io/mathlib_docs/find/set.eq_univ_iff_forall">docs#set.eq_univ_iff_forall</a>.</p>



<a name="295004573"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proofs%20that%20should%20be%20automatic/near/295004573" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic.html#295004573">(Aug 24 2022 at 08:55)</a>:</h4>
<p>I recently spent a nontrivial amount of time on the goal <code>(x : Z) (x : N) : x - 1 - k = x - k.succ</code> which is not right</p>



<a name="295004882"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proofs%20that%20should%20be%20automatic/near/295004882" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic.html#295004882">(Aug 24 2022 at 08:58)</a>:</h4>
<p><code>rw [nat.succ_eq_add_one, int.coe_nat_add, ←sub_sub, sub_right_comm]</code>?</p>



<a name="295004947"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proofs%20that%20should%20be%20automatic/near/295004947" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic.html#295004947">(Aug 24 2022 at 08:58)</a>:</h4>
<p>again, <code>yael_search</code> is not a tactic. it's clear that they can be done, but why do I need to hassle with this?</p>



<a name="295005085"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proofs%20that%20should%20be%20automatic/near/295005085" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic.html#295005085">(Aug 24 2022 at 08:59)</a>:</h4>
<p>and sure, maybe <code>succ</code> is an implementation detail and if I <code>rw [succ_eq_add_one]</code> then maybe <code>ring</code> or <code>push_cast, ring</code> will work. but if implementation details keep appearing in goals for whatever reasons then it doesn't really matter this idealism, because it affects the day-to-day</p>



<a name="295005488"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proofs%20that%20should%20be%20automatic/near/295005488" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic.html#295005488">(Aug 24 2022 at 09:02)</a>:</h4>
<p>(and it means I have to do <code>have : ... := by { ... }</code> instead of <code>have ... := by tactic</code> or ideally even inlining it)</p>



<a name="295006602"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proofs%20that%20should%20be%20automatic/near/295006602" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Moritz Doll <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic.html#295006602">(Aug 24 2022 at 09:11)</a>:</h4>
<p>not really a single proof, but I spent recently too much time on finding the correct version of lemmas like <a href="https://leanprover-community.github.io/mathlib_docs/find/mul_le_mul_of_nonneg_left">docs#mul_le_mul_of_nonneg_left</a><br>
maybe a variant of <code>congr</code> for inequalities would be nice. So <code>a (b+d) &lt; a (c + d)</code> gets reduced to <code>b &lt; c</code> and a bunch of stuff that positivity can prove</p>



<a name="295006830"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proofs%20that%20should%20be%20automatic/near/295006830" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ruben Van de Velde <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic.html#295006830">(Aug 24 2022 at 09:12)</a>:</h4>
<p>Isn't that <a href="https://leanprover-community.github.io/mathlib_docs/tactics.html#mono">tactic#mono</a>?</p>



<a name="295006839"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proofs%20that%20should%20be%20automatic/near/295006839" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic.html#295006839">(Aug 24 2022 at 09:12)</a>:</h4>
<p>I would really love having Coq's generalized rewriting, if only for <code>≤</code>.</p>



<a name="295007129"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proofs%20that%20should%20be%20automatic/near/295007129" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Moritz Doll <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic.html#295007129">(Aug 24 2022 at 09:14)</a>:</h4>
<p><span class="user-mention silent" data-user-id="307953">Ruben Van de Velde</span> <a href="#narrow/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic/near/295006830">said</a>:</p>
<blockquote>
<p>Isn't that <a href="https://leanprover-community.github.io/mathlib_docs/tactics.html#mono">tactic#mono</a>?</p>
</blockquote>
<p>I have never heard of that tactic, I will have a look at it</p>



<a name="295007865"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proofs%20that%20should%20be%20automatic/near/295007865" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic.html#295007865">(Aug 24 2022 at 09:19)</a>:</h4>
<p><span class="user-mention silent" data-user-id="284160">Eric Rodriguez</span> <a href="#narrow/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic/near/295004573">said</a>:</p>
<blockquote>
<p>I recently spent a nontrivial amount of time on the goal <code>(x : Z) (x : N) : x - 1 - k = x - k.succ</code> which is not right</p>
</blockquote>
<p>Yes this feels like a really good example.</p>



<a name="295011546"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proofs%20that%20should%20be%20automatic/near/295011546" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic.html#295011546">(Aug 24 2022 at 09:44)</a>:</h4>
<p>By the way - why does <code>mem_union_eq</code> exist? I was expecting <code>mem_union</code> to be the simp lemma here...</p>



<a name="295011744"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proofs%20that%20should%20be%20automatic/near/295011744" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic.html#295011744">(Aug 24 2022 at 09:46)</a>:</h4>
<p><code>=</code> lemmas and <code>↔</code> are not quite treated the same. <span class="user-mention silent" data-user-id="310045">Eric Wieser</span> fixed some of this, but I'm not sure the issue is fully solved.</p>



<a name="295011859"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proofs%20that%20should%20be%20automatic/near/295011859" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic.html#295011859">(Aug 24 2022 at 09:47)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">U</span> <span class="n">V</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">hUV</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">U</span> <span class="bp">∪</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">∉</span> <span class="n">U</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">V</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">mem_union_eq</span><span class="o">,</span> <span class="n">or_iff_not_imp_left</span><span class="o">,</span> <span class="n">hUV</span><span class="o">]</span> <span class="n">at</span> <span class="n">hUV</span><span class="o">,</span> <span class="n">tauto</span> <span class="o">}</span>
</code></pre></div>



<a name="295011883"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proofs%20that%20should%20be%20automatic/near/295011883" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic.html#295011883">(Aug 24 2022 at 09:47)</a>:</h4>
<p>This is the best I've got for that, btw</p>



<a name="295011920"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proofs%20that%20should%20be%20automatic/near/295011920" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic.html#295011920">(Aug 24 2022 at 09:47)</a>:</h4>
<p>Or if you allow non-terminal simps:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">U</span> <span class="n">V</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">hUV</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">U</span> <span class="bp">∪</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">∉</span> <span class="n">U</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">V</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">simp</span> <span class="n">at</span> <span class="n">hUV</span><span class="o">,</span> <span class="n">tauto</span> <span class="o">}</span>
</code></pre></div>



<a name="295011922"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proofs%20that%20should%20be%20automatic/near/295011922" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic.html#295011922">(Aug 24 2022 at 09:47)</a>:</h4>
<p>An example which came up yesterday on the discord: given a finset of five integers each of which is at most 50, prove that the sum is at most 50+49+48+47+46. This does not need a proof in a classroom situation but was pretty nasty to do in Lean</p>



<a name="295011962"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proofs%20that%20should%20be%20automatic/near/295011962" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic.html#295011962">(Aug 24 2022 at 09:47)</a>:</h4>
<p>(But I changed <code>hUV</code>, so I cheated.)</p>



<a name="295012151"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proofs%20that%20should%20be%20automatic/near/295012151" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic.html#295012151">(Aug 24 2022 at 09:49)</a>:</h4>
<p><span class="user-mention silent" data-user-id="330967">Wrenna Robson</span> <a href="#narrow/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic/near/295011920">said</a>:</p>
<blockquote>
<p>Or if you allow non-terminal simps:</p>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">U</span> <span class="n">V</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">hUV</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">U</span> <span class="bp">∪</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">∉</span> <span class="n">U</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">V</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">or_iff_not_imp_left</span><span class="o">,</span> <span class="n">hUV</span><span class="o">]</span> <span class="n">at</span> <span class="n">hUV</span><span class="o">,</span> <span class="n">tauto</span> <span class="o">}</span>
</code></pre></div><br>
</p>
</blockquote>
<p>This is a fine <code>simp</code>, because <code>tauto</code> is a fancy tactic too.</p>



<a name="295012162"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proofs%20that%20should%20be%20automatic/near/295012162" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic.html#295012162">(Aug 24 2022 at 09:49)</a>:</h4>
<p>Incidentally, an example of these is some stuff which SMT solvers can discharge easily, that I was talking about with some of the lean-crypto people.</p>



<a name="295012679"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proofs%20that%20should%20be%20automatic/near/295012679" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic.html#295012679">(Aug 24 2022 at 09:52)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">U</span> <span class="n">V</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">hUV</span> <span class="o">:</span> <span class="n">U</span> <span class="bp">∪</span> <span class="n">V</span> <span class="bp">=</span> <span class="n">univ</span><span class="o">)</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">∉</span> <span class="n">U</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">V</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">eq_univ_iff_forall</span><span class="o">]</span> <span class="n">at</span> <span class="n">hUV</span><span class="o">,</span> <span class="n">specialize</span> <span class="n">hUV</span> <span class="n">a</span><span class="o">,</span> <span class="n">tauto</span> <span class="o">}</span>
</code></pre></div>
<p>Does this fufill the "one hint" requirement? I would say maybe. Should <code>eq_univ_iff_forall</code> be a simp lemma in general?</p>



<a name="295012934"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proofs%20that%20should%20be%20automatic/near/295012934" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic.html#295012934">(Aug 24 2022 at 09:54)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic/near/295011922">said</a>:</p>
<blockquote>
<p>An example which came up yesterday on the discord: given a finset of five integers each of which is at most 50, prove that the sum is at most 50+49+48+47+46. This does not need a proof in a classroom situation but was pretty nasty to do in Lean</p>
</blockquote>
<p>I'd argue that that proof by induction really is the "morally" right thing to do. Some of the subgoal proofs were pretty absurd, though...</p>



<a name="295013168"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proofs%20that%20should%20be%20automatic/near/295013168" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic.html#295013168">(Aug 24 2022 at 09:56)</a>:</h4>
<p>Oh:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">U</span> <span class="n">V</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">hUV</span> <span class="o">:</span> <span class="n">U</span> <span class="bp">∪</span> <span class="n">V</span> <span class="bp">=</span> <span class="n">univ</span><span class="o">)</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">∉</span> <span class="n">U</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">V</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">eq_univ_iff_forall</span><span class="o">]</span> <span class="n">at</span> <span class="n">hUV</span><span class="o">,</span> <span class="n">finish</span> <span class="o">}</span>
</code></pre></div>



<a name="295013232"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proofs%20that%20should%20be%20automatic/near/295013232" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic.html#295013232">(Aug 24 2022 at 09:56)</a>:</h4>
<p>I mean this is pretty close to full automation I would argue. Arguably it's only not because of the form of <code>hUV</code>.</p>



<a name="295013709"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proofs%20that%20should%20be%20automatic/near/295013709" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic.html#295013709">(Aug 24 2022 at 10:00)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic/near/295011922">said</a>:</p>
<blockquote>
<p>An example which came up yesterday on the discord: given a finset of five integers each of which is at most 50, prove that the sum is at most 50+49+48+47+46. This does not need a proof in a classroom situation but was pretty nasty to do in Lean</p>
</blockquote>
<p>So this is equivalent to <code>a &lt;= 50, b &lt;= 50, c &lt;= 50, d &lt;= 50, e &lt;= 50, a &lt; b &lt; c &lt; d &lt; e, show that a + b + c + d + e &lt; 240</code>, right?</p>



<a name="295013729"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proofs%20that%20should%20be%20automatic/near/295013729" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic.html#295013729">(Aug 24 2022 at 10:00)</a>:</h4>
<p>Can Lean do it in that form?</p>



<a name="295014725"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proofs%20that%20should%20be%20automatic/near/295014725" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic.html#295014725">(Aug 24 2022 at 10:07)</a>:</h4>
<p>Because this is an easy SMT solve:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">;</span> <span class="n">Variable</span> <span class="n">declarations</span>
<span class="o">(</span><span class="n">declare</span><span class="bp">-</span><span class="k">fun</span> <span class="n">a</span> <span class="o">()</span> <span class="n">Int</span><span class="o">)</span>
<span class="o">(</span><span class="n">declare</span><span class="bp">-</span><span class="k">fun</span> <span class="n">b</span> <span class="o">()</span> <span class="n">Int</span><span class="o">)</span>
<span class="o">(</span><span class="n">declare</span><span class="bp">-</span><span class="k">fun</span> <span class="n">c</span> <span class="o">()</span> <span class="n">Int</span><span class="o">)</span>
<span class="o">(</span><span class="n">declare</span><span class="bp">-</span><span class="k">fun</span> <span class="n">d</span> <span class="o">()</span> <span class="n">Int</span><span class="o">)</span>
<span class="o">(</span><span class="n">declare</span><span class="bp">-</span><span class="k">fun</span> <span class="n">e</span> <span class="o">()</span> <span class="n">Int</span><span class="o">)</span>

<span class="bp">;</span> <span class="n">Constraints</span>
<span class="o">(</span><span class="n">assert</span> <span class="o">(</span><span class="bp">&lt;=</span> <span class="n">a</span> <span class="mi">50</span><span class="o">))</span>
<span class="o">(</span><span class="n">assert</span> <span class="o">(</span><span class="bp">&lt;=</span> <span class="n">b</span> <span class="mi">50</span><span class="o">))</span>
<span class="o">(</span><span class="n">assert</span> <span class="o">(</span><span class="bp">&lt;=</span> <span class="n">c</span> <span class="mi">50</span><span class="o">))</span>
<span class="o">(</span><span class="n">assert</span> <span class="o">(</span><span class="bp">&lt;=</span> <span class="n">d</span> <span class="mi">50</span><span class="o">))</span>
<span class="o">(</span><span class="n">assert</span> <span class="o">(</span><span class="bp">&lt;=</span> <span class="n">e</span> <span class="mi">50</span><span class="o">))</span>

<span class="o">(</span><span class="n">assert</span> <span class="o">(</span><span class="bp">&lt;</span> <span class="n">a</span> <span class="n">b</span><span class="o">))</span>
<span class="o">(</span><span class="n">assert</span> <span class="o">(</span><span class="bp">&lt;</span> <span class="n">b</span> <span class="n">c</span><span class="o">))</span>
<span class="o">(</span><span class="n">assert</span> <span class="o">(</span><span class="bp">&lt;</span> <span class="n">c</span> <span class="n">d</span><span class="o">))</span>
<span class="o">(</span><span class="n">assert</span> <span class="o">(</span><span class="bp">&lt;</span> <span class="n">d</span> <span class="n">e</span><span class="o">))</span>
<span class="o">(</span><span class="n">assert</span> <span class="o">(</span><span class="bp">&gt;</span> <span class="o">(</span><span class="bp">+</span> <span class="o">(</span><span class="bp">+</span> <span class="o">(</span><span class="bp">+</span> <span class="o">(</span><span class="bp">+</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="n">c</span><span class="o">)</span> <span class="n">d</span><span class="o">)</span> <span class="n">e</span><span class="o">)</span> <span class="mi">240</span> <span class="o">))</span>

<span class="bp">;</span> <span class="n">Solve</span>
<span class="o">(</span><span class="n">check</span><span class="bp">-</span><span class="n">sat</span><span class="o">)</span>
<span class="o">(</span><span class="n">get</span><span class="bp">-</span><span class="n">model</span><span class="o">)</span>
</code></pre></div>



<a name="295014738"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proofs%20that%20should%20be%20automatic/near/295014738" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic.html#295014738">(Aug 24 2022 at 10:07)</a>:</h4>
<p><a href="https://compsys-tools.ens-lyon.fr/z3/index.php">https://compsys-tools.ens-lyon.fr/z3/index.php</a></p>



<a name="295015214"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proofs%20that%20should%20be%20automatic/near/295015214" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic.html#295015214">(Aug 24 2022 at 10:10)</a>:</h4>
<p>Right and indeed:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span> <span class="n">e</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">}</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≤</span> <span class="mi">50</span><span class="o">)</span> <span class="o">(</span><span class="n">hb</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">≤</span> <span class="mi">50</span><span class="o">)</span> <span class="o">(</span><span class="n">hc</span> <span class="o">:</span> <span class="n">c</span> <span class="bp">≤</span> <span class="mi">50</span><span class="o">)</span> <span class="o">(</span><span class="n">hd</span> <span class="o">:</span> <span class="n">d</span> <span class="bp">≤</span> <span class="mi">50</span><span class="o">)</span> <span class="o">(</span><span class="n">he</span> <span class="o">:</span> <span class="n">e</span> <span class="bp">≤</span> <span class="mi">50</span><span class="o">)</span>
<span class="o">(</span><span class="n">hab</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">hbc</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">c</span><span class="o">)</span> <span class="o">(</span><span class="n">hcd</span> <span class="o">:</span> <span class="n">c</span> <span class="bp">&lt;</span> <span class="n">d</span><span class="o">)</span> <span class="o">(</span><span class="n">hde</span> <span class="o">:</span> <span class="n">d</span> <span class="bp">&lt;</span> <span class="n">e</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">c</span> <span class="bp">+</span> <span class="n">d</span> <span class="bp">+</span> <span class="n">e</span> <span class="bp">≤</span> <span class="mi">46</span> <span class="bp">+</span> <span class="mi">47</span> <span class="bp">+</span> <span class="mi">48</span> <span class="bp">+</span> <span class="mi">49</span> <span class="bp">+</span> <span class="mi">50</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">linarith</span>
</code></pre></div>



<a name="295015548"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proofs%20that%20should%20be%20automatic/near/295015548" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic.html#295015548">(Aug 24 2022 at 10:12)</a>:</h4>
<p>So we are just 1 <code>wlog</code> away from the general statement.</p>



<a name="295015591"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proofs%20that%20should%20be%20automatic/near/295015591" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic.html#295015591">(Aug 24 2022 at 10:13)</a>:</h4>
<p>But I guess <code>wlog</code> struggles with <code>5!</code>.</p>



<a name="295016165"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proofs%20that%20should%20be%20automatic/near/295016165" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic.html#295016165">(Aug 24 2022 at 10:17)</a>:</h4>
<p>yeah and this wouldn't work if you wanted to prove it for all n, I suppose.</p>



<a name="295136362"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proofs%20that%20should%20be%20automatic/near/295136362" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Moritz Doll <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic.html#295136362">(Aug 24 2022 at 22:29)</a>:</h4>
<p><span class="user-mention silent" data-user-id="307953">Ruben Van de Velde</span> <a href="#narrow/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic/near/295006830">said</a>:</p>
<blockquote>
<p>Isn't that <a href="https://leanprover-community.github.io/mathlib_docs/tactics.html#mono">tactic#mono</a>?</p>
</blockquote>
<p>thank you so much Ruben. Even though the proofs are now longer by lines, they are so much more readable:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">-</span>    <span class="n">refine</span> <span class="n">mul_le_mul_of_nonneg_left</span> <span class="n">_</span> <span class="o">(</span><span class="n">inv_nonneg.mpr</span> <span class="n">fac_nonneg</span><span class="o">),</span>
<span class="bp">-</span>    <span class="n">refine</span> <span class="n">pow_le_pow_of_le_left</span> <span class="o">(</span><span class="kd">by</span> <span class="n">positivity</span><span class="o">)</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span>
<span class="bp">-</span>    <span class="c1">-- We use linarith to prove |x - y| ≤ |b - a|:</span>
<span class="bp">-</span>    <span class="n">exact</span> <span class="n">abs_le_abs</span> <span class="o">(</span><span class="kd">by</span> <span class="n">linarith</span> <span class="o">[</span><span class="n">hx.2</span><span class="o">,</span> <span class="n">hy.1</span><span class="o">])</span> <span class="o">(</span><span class="kd">by</span> <span class="n">linarith</span> <span class="o">[</span><span class="n">hx.1</span><span class="o">,</span> <span class="n">hy.2</span><span class="o">]),</span>
<span class="bp">+</span>    <span class="n">mono</span><span class="bp">*</span><span class="o">,</span>
<span class="bp">+</span>    <span class="n">any_goals</span> <span class="o">{</span> <span class="n">positivity</span> <span class="o">},</span>
<span class="bp">+</span>    <span class="o">{</span> <span class="n">exact</span> <span class="n">hx.2</span> <span class="o">},</span>
<span class="bp">+</span>    <span class="o">{</span> <span class="n">exact</span> <span class="n">hy.1</span> <span class="o">},</span>
<span class="bp">+</span>    <span class="o">{</span> <span class="n">linarith</span> <span class="o">[</span><span class="n">hx.1</span><span class="o">,</span> <span class="n">hy.2</span><span class="o">]</span> <span class="o">},</span>
</code></pre></div>
<p>and</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">-</span>  <span class="n">refine</span> <span class="n">mul_le_mul_of_nonneg_left</span> <span class="n">_</span> <span class="n">hSup</span><span class="o">,</span>
<span class="bp">-</span>  <span class="n">refine</span> <span class="n">mul_le_mul_of_nonneg_left</span> <span class="n">_</span> <span class="o">(</span><span class="n">pow_nonneg</span> <span class="o">(</span><span class="n">sub_pos.mpr</span> <span class="n">h</span><span class="o">)</span><span class="bp">.</span><span class="n">le</span> <span class="n">_</span><span class="o">),</span>
<span class="bp">-</span>  <span class="n">exact</span> <span class="n">sub_le_sub_right</span> <span class="n">hx.2</span> <span class="n">_</span><span class="o">,</span>
<span class="bp">+</span>  <span class="n">mono</span><span class="bp">*</span> <span class="k">with</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="o">(</span><span class="n">b</span> <span class="bp">-</span> <span class="n">a</span><span class="o">)</span> <span class="bp">^</span> <span class="n">n</span><span class="o">,</span>
<span class="bp">+</span>  <span class="n">any_goals</span> <span class="o">{</span> <span class="n">positivity</span> <span class="o">},</span>
<span class="bp">+</span>  <span class="n">exact</span> <span class="n">hx.2</span><span class="o">,</span>
</code></pre></div>



<a name="295138243"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proofs%20that%20should%20be%20automatic/near/295138243" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Moritz Doll <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic.html#295138243">(Aug 24 2022 at 22:51)</a>:</h4>
<p>it feels like <code>mono*, any_goals { positivity }</code> is exactly the thing I wanted to have</p>



<a name="297468460"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proofs%20that%20should%20be%20automatic/near/297468460" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bolton Bailey <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic.html#297468460">(Sep 06 2022 at 19:01)</a>:</h4>
<p>What do people think of this as a proof that should be automatic?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">nat.min_add_sub</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">min</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">+</span> <span class="o">(</span><span class="n">a</span> <span class="bp">-</span> <span class="n">b</span><span class="o">)</span> <span class="bp">=</span> <span class="n">a</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>
<p>It feels like if only there was a way to get lean to realize that the definition of min is somehow essentially casework, then this could be solved by tidy or something.</p>



<a name="297468695"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proofs%20that%20should%20be%20automatic/near/297468695" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic.html#297468695">(Sep 06 2022 at 19:03)</a>:</h4>
<p>It also needs to understand truncated subtraction.</p>



<a name="297468813"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proofs%20that%20should%20be%20automatic/near/297468813" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic.html#297468813">(Sep 06 2022 at 19:04)</a>:</h4>
<p>My first reaction was: "That looks very wrong! The symmetry is broken!" -- And then "Oooooh wait. ℕ... Never mind."</p>



<a name="297474297"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proofs%20that%20should%20be%20automatic/near/297474297" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic.html#297474297">(Sep 06 2022 at 19:38)</a>:</h4>
<p>Perhaps a general mechanism to indicate "to prove stuff about <code>foo x y</code> you should case on <code>some_lemma x y</code>" would help with that</p>



<a name="297474387"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proofs%20that%20should%20be%20automatic/near/297474387" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic.html#297474387">(Sep 06 2022 at 19:39)</a>:</h4>
<p>We have things like <a href="https://leanprover-community.github.io/mathlib_docs/find/finset.sup_induction">docs#finset.sup_induction</a> already, but those are too strong if your goal also includes a bare <code>s</code> as well as <code>s.sup f</code></p>



<a name="297477554"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proofs%20that%20should%20be%20automatic/near/297477554" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bolton Bailey <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic.html#297477554">(Sep 06 2022 at 19:59)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic/near/297474297">said</a>:</p>
<blockquote>
<p>Perhaps a general mechanism to indicate "to prove stuff about <code>foo x y</code> you should case on <code>some_lemma x y</code>" would help with that</p>
</blockquote>
<p>Maybe a <code>@[case_simp]</code> tag for lemmas of the form <code>a = if b then c else d</code> where <code>c</code> and <code>d</code> are both simpler than <code>a</code></p>



<a name="297484869"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proofs%20that%20should%20be%20automatic/near/297484869" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic.html#297484869">(Sep 06 2022 at 20:48)</a>:</h4>
<p><span class="user-mention silent" data-user-id="412682">Moritz Doll</span> <a href="#narrow/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic/near/295006602">said</a>:</p>
<blockquote>
<p>not really a single proof, but I spent recently too much time on finding the correct version of lemmas like <a href="https://leanprover-community.github.io/mathlib_docs/find/mul_le_mul_of_nonneg_left">docs#mul_le_mul_of_nonneg_left</a><br>
maybe a variant of <code>congr</code> for inequalities would be nice. So <code>a (b+d) &lt; a (c + d)</code> gets reduced to <code>b &lt; c</code> and a bunch of stuff that positivity can prove</p>
</blockquote>
<p><span class="user-mention" data-user-id="412682">@Moritz Doll</span> I totally agree, I think this "inequality-congr" is the basic mental tactic we use to prove inequalities on paper.  I actually have a work-in-progress version of this tactic for teaching, see<br>
<a href="https://hrmacbeth.github.io/math2001/01_Proofs_by_Calculation.html#proving-inequalities">https://hrmacbeth.github.io/math2001/01_Proofs_by_Calculation.html#proving-inequalities</a></p>
<p>It needs more polishing before joining mathlib, though.</p>



<a name="297484906"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proofs%20that%20should%20be%20automatic/near/297484906" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic.html#297484906">(Sep 06 2022 at 20:49)</a>:</h4>
<p>This was actually my motivation for writing <code>positivity</code>.</p>



<a name="297489423"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proofs%20that%20should%20be%20automatic/near/297489423" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic.html#297489423">(Sep 06 2022 at 21:24)</a>:</h4>
<p>Oh this is also the tactic idea I was telling you in DMs, right? What I got from discussing it with Jannis is that we even needed generalised rewriting.</p>



<a name="297514027"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proofs%20that%20should%20be%20automatic/near/297514027" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic.html#297514027">(Sep 07 2022 at 02:22)</a>:</h4>
<p><span class="user-mention" data-user-id="387244">@Yaël Dillies</span> I think this is easier than generalized rewriting, and more akin to <code>congr</code> than to <code>rw</code> (it's interesting to me that both Moritz and I used <code>congr</code> as our mental analogy).</p>
<p>As I understand it, generalized-rewriting by <code>h : a ≤ b</code> would let you, e.g., reduce a goal <code>⊢ 3 * a ≤ 5</code> to a goal <code>⊢ 3 * b ≤ 5</code>.</p>
<p>By contrast, what I have written is a finishing tactic which would, e.g., prove the goal <code>⊢ 3 * a ≤ 3 * b</code>.</p>



<a name="297514859"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proofs%20that%20should%20be%20automatic/near/297514859" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic.html#297514859">(Sep 07 2022 at 02:39)</a>:</h4>
<p>It's very much in the same vein as the tactic <code>mono*</code> (discussed <a href="#narrow/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic/near/295136362">upthread</a>), but designed to be "greedy".   Compare their behaviour on the goal <code>⊢ a * x ≤ b * x</code>.</p>
<ul>
<li>the tactic I wrote will go ahead and reduce this to the goals <code>a ≤ b</code> and <code>0 ≤ x</code>.</li>
<li>the tactic <code>mono</code> will tell you that it could reduce this to (<code>x ≤ 0</code> and <code>b ≤ a</code>) or to (<code>0 ≤ x</code> and <code>a ≤ b</code>), and ask you to disambiguate.</li>
</ul>
<p>In my experience, paper proofs are usually written in such a way that the greedy behaviour is correct, so it's a more efficient user experience if you don't have to disambiguate (especially when you're using the recursive form <code>mono*</code> and would have disambiguate several times in a single proof).</p>
<p>But they are close enough that it would probably be possible to re-implement my tactic as a variant of <code>mono</code>.</p>



<a name="297519491"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proofs%20that%20should%20be%20automatic/near/297519491" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Moritz Doll <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic.html#297519491">(Sep 07 2022 at 04:15)</a>:</h4>
<p>concerning <code>mono*</code> I had a slight issue, where mono produced more <code>positivity</code>-goals than what I had when wrote the proof by hand. This might be related to the "non-greedyness" of mono.</p>



<a name="297534752"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proofs%20that%20should%20be%20automatic/near/297534752" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic.html#297534752">(Sep 07 2022 at 07:24)</a>:</h4>
<p>Ah yes, so this is not quite the tactic I want/need. But still interesting!</p>



<a name="297534888"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proofs%20that%20should%20be%20automatic/near/297534888" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic.html#297534888">(Sep 07 2022 at 07:25)</a>:</h4>
<p>SRL has those huge calc blocks that would become much more readable if I could rewrite along inequalities, but I can't use your tactic there because most calls would be non finishing.</p>



<a name="297742204"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proofs%20that%20should%20be%20automatic/near/297742204" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jannis Limperg <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic.html#297742204">(Sep 08 2022 at 09:53)</a>:</h4>
<p><span class="user-mention silent" data-user-id="282271">Bolton Bailey</span> <a href="#narrow/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic/near/297468460">said</a>:</p>
<blockquote>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">nat.min_add_sub</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">min</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">+</span> <span class="o">(</span><span class="n">a</span> <span class="bp">-</span> <span class="n">b</span><span class="o">)</span> <span class="bp">=</span> <span class="n">a</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div><br>
</p>
</blockquote>
<p>Aesop will be able to do this, assuming a good simp set:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">Aesop</span>

<span class="kd">@[simp]</span>
<span class="kd">theorem</span> <span class="n">Nat.not_le_le</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span> <span class="bp">↔</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">a</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">@[simp]</span>
<span class="kd">theorem</span> <span class="n">Nat.sub_eq_zero</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">-</span> <span class="n">b</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">@[simp]</span>
<span class="kd">theorem</span> <span class="n">Nat.add_sub</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">a</span><span class="o">)</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">+</span> <span class="o">(</span><span class="n">a</span> <span class="bp">-</span> <span class="n">b</span><span class="o">)</span> <span class="bp">=</span> <span class="n">a</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">theorem</span> <span class="n">Nat.min_add_sub</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">min</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">+</span> <span class="o">(</span><span class="n">a</span> <span class="bp">-</span> <span class="n">b</span><span class="o">)</span> <span class="bp">=</span> <span class="n">a</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">aesop</span> <span class="o">(</span><span class="n">add</span> <span class="n">norm</span> <span class="n">unfold</span> <span class="n">min</span><span class="o">)</span>
</code></pre></div>
<p>Aesop recognises that the goal, after unfolding <code>min</code>, contains an <code>if</code>, and splits along its condition. (It essentially runs <code>split_ifs</code> eagerly, which imo is usually the right thing to do.) <code>simp</code> does the rest.</p>



<a name="297752654"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proofs%20that%20should%20be%20automatic/near/297752654" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic.html#297752654">(Sep 08 2022 at 11:09)</a>:</h4>
<p>I had forgotten about this example.  On <a href="https://github.com/leanprover-community/mathlib/tree/adomani_remove_subs">branch#adomani_remove_subs</a>, this also is a proof:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic.remove_subs</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">min</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">+</span> <span class="o">(</span><span class="n">a</span> <span class="bp">-</span> <span class="n">b</span><span class="o">)</span> <span class="bp">=</span> <span class="n">a</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">remove_subs</span><span class="bp">;</span> <span class="n">simp</span><span class="bp">;</span> <span class="n">assumption</span>
</code></pre></div>



<a name="297752864"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proofs%20that%20should%20be%20automatic/near/297752864" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic.html#297752864">(Sep 08 2022 at 11:10)</a>:</h4>
<p><span class="user-mention" data-user-id="256311">@Jannis Limperg</span> should <code>Nat.not_le_le</code> really be <code>Nat.not_le_lt</code>, with a strict inequality on one side?</p>



<a name="297759861"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proofs%20that%20should%20be%20automatic/near/297759861" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jannis Limperg <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic.html#297759861">(Sep 08 2022 at 11:59)</a>:</h4>
<p>Hehe, yes, of course.</p>



<a name="297834065"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proofs%20that%20should%20be%20automatic/near/297834065" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic.html#297834065">(Sep 08 2022 at 17:46)</a>:</h4>
<p>With that lemma, Aesop should be able to prove much more than <code>Nat.min_add_sub</code> <span aria-label="upside down" class="emoji emoji-1f643" role="img" title="upside down">:upside_down:</span></p>



<a name="297927698"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proofs%20that%20should%20be%20automatic/near/297927698" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic.html#297927698">(Sep 09 2022 at 08:38)</a>:</h4>
<p>In the spirit of automatization, the <a href="#narrow/stream/113488-general/topic/Automatic.20proof.20for.20nat-sub">nat-subtraction</a> discussion and the <a href="#narrow/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic/near/297468460">example with <code>max/min</code></a> that <span class="user-mention" data-user-id="282271">@Bolton Bailey</span> and <span class="user-mention" data-user-id="310045">@Eric Wieser</span> mentioned above seem to suggest support for a tactic similar to <code>split_ifs</code> that would look for stuff on which to do <code>cases</code> and actually do it.</p>
<p>Would this be something desirable?</p>



<a name="297927705"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proofs%20that%20should%20be%20automatic/near/297927705" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic.html#297927705">(Sep 09 2022 at 08:38)</a>:</h4>
<p>The tactic <code>remove_subs</code> could be easily modified to at least split over <code>max/min</code> but probably even more generally, to fit with some user-flag that tells it what to do cases on.</p>



<a name="299442115"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proofs%20that%20should%20be%20automatic/near/299442115" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic.html#299442115">(Sep 18 2022 at 14:38)</a>:</h4>
<p><code>example {α β} {f : α → β} {b : β} : (∃ a, f a = b) ∨ ∀ a, f a ≠ b</code></p>
<p><code>finish</code> can do this but we're encouraged not to use it, afair. <code>tauto!</code> and <code>itauto!</code> failing on this is unexplicable (and it's not <code>ne</code>, the ¬ version fails as well)</p>



<a name="299442468"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proofs%20that%20should%20be%20automatic/near/299442468" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic.html#299442468">(Sep 18 2022 at 14:41)</a>:</h4>
<p>I suspect <code>tauto</code> does not know about moving negations out of quantifiers?</p>



<a name="299454582"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proofs%20that%20should%20be%20automatic/near/299454582" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bolton Bailey <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic.html#299454582">(Sep 18 2022 at 16:44)</a>:</h4>
<p>To generalize what I was saying before in the context of this example, I feel there should be more emphasis on automatic tactics breaking down logical connectives. Just as <code>tidy</code> calls <code>split</code> when it sees an <code>and</code> and <code>intro</code> when it sees a <code>-&gt;</code> I feel like it should call something like<code>decidable.or_iff_not_imp_left</code> when it sees the goal is a disjunction (and indeed <code>classical, rw decidable.or_iff_not_imp_left, tidy,</code> closes the goal).</p>



<a name="299459311"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proofs%20that%20should%20be%20automatic/near/299459311" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic.html#299459311">(Sep 18 2022 at 17:37)</a>:</h4>
<p><span class="user-mention" data-user-id="359917">@Timothee Lacroix</span> 's AI can solve this one! I just kept selecting the top option. Maybe it got lucky but still!</p>



<a name="299465162"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proofs%20that%20should%20be%20automatic/near/299465162" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic.html#299465162">(Sep 18 2022 at 18:36)</a>:</h4>
<p><code>itauto</code> doesn't know anything about predicate logic</p>



<a name="299536260"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proofs%20that%20should%20be%20automatic/near/299536260" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic.html#299536260">(Sep 19 2022 at 10:10)</a>:</h4>
<p>Anyone know a way to make this automatic (assuming we're in a classical context):<br>
<code>lemma blahj {a b : Prop} (h : ¬a ↔ ¬b) : a ↔ b := sorry</code></p>



<a name="299536438"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proofs%20that%20should%20be%20automatic/near/299536438" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic.html#299536438">(Sep 19 2022 at 10:11)</a>:</h4>
<p>It's essentially just  one direction of <code>not_iff_not</code> but we don't actually seem to have it.</p>



<a name="299536537"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proofs%20that%20should%20be%20automatic/near/299536537" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic.html#299536537">(Sep 19 2022 at 10:11)</a>:</h4>
<p>Could be called <code>iff.of_not</code></p>



<a name="299538063"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proofs%20that%20should%20be%20automatic/near/299538063" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic.html#299538063">(Sep 19 2022 at 10:23)</a>:</h4>
<p><code>not_iff_not.1</code></p>



<a name="299538750"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proofs%20that%20should%20be%20automatic/near/299538750" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic.html#299538750">(Sep 19 2022 at 10:29)</a>:</h4>
<p>Aye, I mean, that's what I did, but none of the automated tools could find it...</p>



<a name="299539110"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proofs%20that%20should%20be%20automatic/near/299539110" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic.html#299539110">(Sep 19 2022 at 10:32)</a>:</h4>
<p>library search should find one directional versions of iff lemmas</p>



<a name="299539178"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proofs%20that%20should%20be%20automatic/near/299539178" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic.html#299539178">(Sep 19 2022 at 10:33)</a>:</h4>
<p>it might be underpowered in lean 4</p>



<a name="299539219"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proofs%20that%20should%20be%20automatic/near/299539219" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic.html#299539219">(Sep 19 2022 at 10:34)</a>:</h4>
<p>It fails in Lean 3.<br>
<code>lemma blahj {a b : Prop} (h : ¬a ↔ ¬b) : a ↔ b := by library_search!</code><br>
<code>lemma blahj {a b : Prop} (h : ¬a ↔ ¬b) : a ↔ b := by library_search</code></p>
<p>both fail.</p>



<a name="299540898"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proofs%20that%20should%20be%20automatic/near/299540898" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic.html#299540898">(Sep 19 2022 at 10:49)</a>:</h4>
<p>That's unfortunate, and perhaps counts as a <code>library_search</code> bug...</p>



<a name="299542456"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proofs%20that%20should%20be%20automatic/near/299542456" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic.html#299542456">(Sep 19 2022 at 11:01)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">blahj</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">¬</span><span class="n">a</span> <span class="bp">↔</span> <span class="bp">¬</span><span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">↔</span> <span class="n">b</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">tauto</span><span class="bp">!</span>
</code></pre></div>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/branch.23gsmul_instance.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/branch.23gsmul_instance.html">branch#gsmul_instance</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="232985623"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/branch%23gsmul_instance/near/232985623" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/branch.23gsmul_instance.html#232985623">(Apr 03 2021 at 06:31)</a>:</h4>
<p><span class="user-mention" data-user-id="110050">@Sebastien Gouezel</span> has started a major refactor of mathlib at <a href="https://github.com/leanprover-community/mathlib/tree/gsmul_instance">branch#gsmul_instance</a>. The goal is to get rid of the global instances <code>add_comm_monoid.nat_semimodule</code>, <code>add_comm_group.int_module</code> and <code>algebra_int</code>. So far, it seems to be a lot of work, but also means we get rid of a lot of annoying diamond problems. So it definitely seems worth it. Kudos to <span class="user-mention" data-user-id="110050">@Sebastien Gouezel</span> ! <span aria-label="muscle" class="emoji emoji-1f4aa" role="img" title="muscle">:muscle:</span> <span aria-label="octopus" class="emoji emoji-1f419" role="img" title="octopus">:octopus:</span> </p>
<p>I just did a bit of work on this branch, and Lean complained that it couldn't find an instance <code>algebra int (zmod p)</code>. Of course this is to be expected. So I went back to the file on <code>zmod</code>, and added that instance. But during breakfast I realised that Lean will also need <code>algebra nat (zmod p)</code>. You see where this is going: for every</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">:</span> <span class="n">ring</span> <span class="o">(</span><span class="n">foo_bar</span> <span class="n">quux</span><span class="o">)</span> <span class="o">:=</span> <span class="n">_</span>
</code></pre></div>
<p>we will now need two extra lines</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">:</span> <span class="n">algebra</span> <span class="n">nat</span> <span class="o">(</span><span class="n">foo_bar</span> <span class="n">quux</span><span class="o">)</span> <span class="o">:=</span> <span class="n">algebra_nat</span> <span class="n">_</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">algebra</span> <span class="n">int</span> <span class="o">(</span><span class="n">foo_bar</span> <span class="n">quux</span><span class="o">)</span> <span class="o">:=</span> <span class="n">algebra_int</span> <span class="n">_</span>
</code></pre></div>
<p>(Actually, <code>algebra nat</code> should already happen for every <code>semiring</code>.)<br>
And we also need <code>instance : module int (xyzzy baz)</code> for every <code>instance : add_comm_group (xyzzy baz)</code>.</p>
<p>Is this something that we can automate? Can we change Lean 3.37.42, so that it will trigger extra instance declarations whenever it parses one of</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">:</span> <span class="n">add_comm_monoid</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">add_comm_group</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">semiring</span> <span class="c1">-- or comm_semiring</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">ring</span> <span class="c1">-- or comm_ring</span>
</code></pre></div>



<a name="232986170"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/branch%23gsmul_instance/near/232986170" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/branch.23gsmul_instance.html#232986170">(Apr 03 2021 at 06:42)</a>:</h4>
<p>cc <span class="user-mention" data-user-id="110043">@Gabriel Ebner</span> <span class="user-mention" data-user-id="110596">@Rob Lewis</span> <span class="user-mention" data-user-id="111080">@Floris van Doorn</span> <span class="user-mention" data-user-id="110087">@Scott Morrison</span></p>



<a name="232986231"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/branch%23gsmul_instance/near/232986231" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/branch.23gsmul_instance.html#232986231">(Apr 03 2021 at 06:44)</a>:</h4>
<p>Would it be helpful or disrupting to have a nat_semimodule instance on int alone?</p>



<a name="232986472"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/branch%23gsmul_instance/near/232986472" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/branch.23gsmul_instance.html#232986472">(Apr 03 2021 at 06:49)</a>:</h4>
<p>I think we need it on every abelian group.</p>



<a name="232987485"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/branch%23gsmul_instance/near/232987485" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/branch.23gsmul_instance.html#232987485">(Apr 03 2021 at 07:10)</a>:</h4>
<p>I had a crazy idea that should fix all the diamond issues while keeping the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">Z</mi></mrow><annotation encoding="application/x-tex">\Z</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">Z</span></span></span></span></span>-module instance on <code>add_comm_group</code>s. I'd like to hear your thoughts about it.</p>



<a name="232987619"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/branch%23gsmul_instance/near/232987619" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/branch.23gsmul_instance.html#232987619">(Apr 03 2021 at 07:12)</a>:</h4>
<p>But you want to disable <code>algebra_int</code>, right?</p>



<a name="232987653"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/branch%23gsmul_instance/near/232987653" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/branch.23gsmul_instance.html#232987653">(Apr 03 2021 at 07:13)</a>:</h4>
<p>If you keep <code>add_comm_group.int_module</code>, how can we make sure that we don't hit diamonds on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">Z</mi></mrow><annotation encoding="application/x-tex">\Z</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">Z</span></span></span></span></span> again?</p>



<a name="232987669"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/branch%23gsmul_instance/near/232987669" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/branch.23gsmul_instance.html#232987669">(Apr 03 2021 at 07:13)</a>:</h4>
<p><em>The problem</em>: we want every <code>add_comm_group</code> to be a <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">Z</mi></mrow><annotation encoding="application/x-tex">\Z</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">Z</span></span></span></span></span>-module. For now, this is registered through the instance <code>add_comm_group.int_module</code>, where the multiplication is <code>gsmul</code>, defined by induction over the integer, through the addition. But some <code>add_comm_group</code>s get different module instances. For instance, if <code>M</code> and <code>N</code> are modules over a ring <code>R</code>, then the space of linear maps <code>M →ₗ[R] N</code> has both an <code>add_comm_group</code> and an <code>R</code>-module structure. When <code>R = ℤ</code>, you get two <code>ℤ</code>-module structures on <code>M →ₗ[ℤ] N</code>, the <code>add_comm_group.int_module</code> one, and the one coming from the linear structure. And they are not defeq.</p>



<a name="232987832"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/branch%23gsmul_instance/near/232987832" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/branch.23gsmul_instance.html#232987832">(Apr 03 2021 at 07:16)</a>:</h4>
<p><em>The solution</em>: a variation on forgetful inheritance. I want to <em>enrich</em> the definition of <code>add_comm_group</code>, by adding data: a <code>ℤ</code>-action with the right axioms. Then the instance from <code>add_comm_group</code> to <code>ℤ</code>-modules would use this data (and we would remove completely <code>add_comm_group.int_module</code>). We would only need to make sure that whenever one can construct a new <code>ℤ</code>-module, the module structure is defeq to the one stored in the <code>add_comm_group</code>.</p>



<a name="232987910"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/branch%23gsmul_instance/near/232987910" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/branch.23gsmul_instance.html#232987910">(Apr 03 2021 at 07:18)</a>:</h4>
<p>But then we can do the same thing with <code>comm_ring</code> and <code>algebra_int</code>, right?</p>



<a name="232987916"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/branch%23gsmul_instance/near/232987916" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/branch.23gsmul_instance.html#232987916">(Apr 03 2021 at 07:18)</a>:</h4>
<p>So we should remove that <code>algebra int (zmod n)</code> instances again?</p>



<a name="232987948"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/branch%23gsmul_instance/near/232987948" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/branch.23gsmul_instance.html#232987948">(Apr 03 2021 at 07:19)</a>:</h4>
<p><em>An example</em>: when we define <code>M →ₗ[R] N</code>, we have to register an <code>add_comm_group</code> on this space. According to the scheme above, we should be careful about the compatibility. Since the <code>R</code>-action is given by <code>(r • f) (x) = r • (f x)</code>, using the action in the target space, we define the <code>ℤ</code>-action in the same way, by <code>(n • f) (x) = n • (f x)</code>. Then in the particular case of <code>R = ℤ</code>, everything matches, and there is no diamond.</p>



<a name="232988093"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/branch%23gsmul_instance/near/232988093" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/branch.23gsmul_instance.html#232988093">(Apr 03 2021 at 07:22)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/113488-general/topic/branch.23gsmul_instance/near/232987910">said</a>:</p>
<blockquote>
<p>But then we can do the same thing with <code>comm_ring</code> and <code>algebra_int</code>, right?</p>
</blockquote>
<p>Since a <code>comm_ring</code> is in particular an <code>add_comm_group</code>, yes, it would carry such a <code>ℤ</code>-action. We can define it to be left-multiplication. And then in the case of <code>R = ℤ</code>, it means that our <code>ℤ</code>-module structure coming from the <code>add_comm_group</code> would be defeq to the <code>ℤ</code>-module structure coming from the ring structure, without having to tweak the definition of <code>ℤ</code>-multiplication.</p>



<a name="232988155"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/branch%23gsmul_instance/near/232988155" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/branch.23gsmul_instance.html#232988155">(Apr 03 2021 at 07:22)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/113488-general/topic/branch.23gsmul_instance/near/232987916">said</a>:</p>
<blockquote>
<p>So we should remove that <code>algebra int (zmod n)</code> instances again?</p>
</blockquote>
<p>Yes, we would also remove all the manual <code>algebra_int</code> instances, and define a global one that would be completely diamond-free.</p>



<a name="232988164"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/branch%23gsmul_instance/near/232988164" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/branch.23gsmul_instance.html#232988164">(Apr 03 2021 at 07:23)</a>:</h4>
<p>ok, I think I see how this is going to work.</p>



<a name="232988180"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/branch%23gsmul_instance/near/232988180" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/branch.23gsmul_instance.html#232988180">(Apr 03 2021 at 07:23)</a>:</h4>
<p>But we'll need to do the same trick for <code>nat</code> and <code>add_comm_monoid</code></p>



<a name="232988184"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/branch%23gsmul_instance/near/232988184" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/branch.23gsmul_instance.html#232988184">(Apr 03 2021 at 07:23)</a>:</h4>
<p>And we should also do the same for <code>nat</code> and <code>add_comm_monoid</code>, yes.</p>



<a name="232988200"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/branch%23gsmul_instance/near/232988200" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/branch.23gsmul_instance.html#232988200">(Apr 03 2021 at 07:23)</a>:</h4>
<p>I say this is a crazy idea because this would be a <em>huge</em> refactor.</p>



<a name="232988252"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/branch%23gsmul_instance/near/232988252" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/branch.23gsmul_instance.html#232988252">(Apr 03 2021 at 07:24)</a>:</h4>
<p>But this <code>ℤ</code>-module thing has been a major painpoint several times, so I think it would probably be worth it.</p>



<a name="232988269"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/branch%23gsmul_instance/near/232988269" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/branch.23gsmul_instance.html#232988269">(Apr 03 2021 at 07:24)</a>:</h4>
<p>I have a few questions abouth this idea:</p>



<a name="232988278"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/branch%23gsmul_instance/near/232988278" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/branch.23gsmul_instance.html#232988278">(Apr 03 2021 at 07:25)</a>:</h4>
<p>And then there is <a href="https://github.com/leanprover-community/mathlib/blob/master/src/data/zmod/basic.lean#L337">https://github.com/leanprover-community/mathlib/blob/master/src/data/zmod/basic.lean#L337</a></p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">char_p</span> <span class="n">R</span> <span class="n">n</span><span class="o">]</span> <span class="o">:</span> <span class="n">algebra</span> <span class="o">(</span><span class="n">zmod</span> <span class="n">n</span><span class="o">)</span> <span class="n">R</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">zmod.cast_hom</span> <span class="o">(</span><span class="n">dvd_refl</span> <span class="n">n</span><span class="o">)</span> <span class="n">R</span><span class="o">)</span><span class="bp">.</span><span class="n">to_algebra</span>
</code></pre></div>



<a name="232988299"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/branch%23gsmul_instance/near/232988299" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/branch.23gsmul_instance.html#232988299">(Apr 03 2021 at 07:25)</a>:</h4>
<p>So we can now get two instances of <code>algebra (zmod n) (zmod n)</code></p>



<a name="232988302"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/branch%23gsmul_instance/near/232988302" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/branch.23gsmul_instance.html#232988302">(Apr 03 2021 at 07:25)</a>:</h4>
<p>1) would it really solve all diamond problems in this area one can think of (<span class="user-mention" data-user-id="310045">@Eric Wieser</span> has thought a lot about it, so maybe he could think of other examples I have overlooked).</p>



<a name="232988308"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/branch%23gsmul_instance/near/232988308" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/branch.23gsmul_instance.html#232988308">(Apr 03 2021 at 07:25)</a>:</h4>
<p>One from <span aria-label="up" class="emoji emoji-2b06" role="img" title="up">:up:</span> and another from <code>algebra.id</code></p>



<a name="232988394"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/branch%23gsmul_instance/near/232988394" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/branch.23gsmul_instance.html#232988394">(Apr 03 2021 at 07:27)</a>:</h4>
<p>2) For the implementation, I expect that we could add a default field and defaults arguments for the prop fields, so hopefully this shouldn't make to much of a difference in definitions where we don't care about the defeqness, and we would only change things where they matter. But I wonder about things like <code>to_additive</code> or the <code>additive/multiplicative</code> tricks, especially since the fields in <code>add_comm_group</code> and <code>comm_group</code> would not match any more.</p>



<a name="232988450"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/branch%23gsmul_instance/near/232988450" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/branch.23gsmul_instance.html#232988450">(Apr 03 2021 at 07:28)</a>:</h4>
<p>3) Performancewise, we would be adding data fields to a lot of structures we use all the time in mathlib, so how bad would it be?</p>



<a name="232988573"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/branch%23gsmul_instance/near/232988573" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/branch.23gsmul_instance.html#232988573">(Apr 03 2021 at 07:30)</a>:</h4>
<p>4) This seems directly related to the issue of numerics in Lean 4. With the above design, we should probably essentially never use any more <code>int.cast</code>, and replace it with the field in the <code>add_comm_group</code> structure applied to <code>1</code>, or something like that. If we do such a refactor, we'd better plan it to be compatible with the implementation of numerics we want in Lean 4 (which I haven't really followed). <span class="user-mention" data-user-id="110049">@Mario Carneiro</span>, do you have thoughts about this?</p>



<a name="232988648"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/branch%23gsmul_instance/near/232988648" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/branch.23gsmul_instance.html#232988648">(Apr 03 2021 at 07:32)</a>:</h4>
<p>This would mean ditching my branch  <a href="https://github.com/leanprover-community/mathlib/tree/gsmul_instance">branch#gsmul_instance</a>, but I don't care, this seems like a much better solution. I'm done with my rant, and I'm going to the sea because it's our last day of freedom before yet another lockdown, but I'll be happy to read what you think of it when I'm back this evening :-)</p>



<a name="232989069"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/branch%23gsmul_instance/near/232989069" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/branch.23gsmul_instance.html#232989069">(Apr 03 2021 at 07:41)</a>:</h4>
<p>The idea for numerics in lean 4 was to add a field <code>ofNat</code> to the base structures like <code>semiring</code>. From such a structure you get a natural interpretation of <code>nsmul</code>, although not <code>gsmul</code> (unless we extend the field to <code>ofInt</code>)</p>



<a name="232989078"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/branch%23gsmul_instance/near/232989078" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/branch.23gsmul_instance.html#232989078">(Apr 03 2021 at 07:41)</a>:</h4>
<p>That is, <code>nat.cast</code> would become a projection</p>



<a name="232989155"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/branch%23gsmul_instance/near/232989155" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/branch.23gsmul_instance.html#232989155">(Apr 03 2021 at 07:43)</a>:</h4>
<p>That's not quite the same as what you are proposing, which is to add <code>n * x</code> as a field of the structure. Perhaps we want both?</p>



<a name="232989195"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/branch%23gsmul_instance/near/232989195" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/branch.23gsmul_instance.html#232989195">(Apr 03 2021 at 07:44)</a>:</h4>
<p>Well at least on semirings there is a natural definition of <code>n * x</code> as <code>ofNat n * x</code></p>



<a name="232989396"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/branch%23gsmul_instance/near/232989396" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/branch.23gsmul_instance.html#232989396">(Apr 03 2021 at 07:48)</a>:</h4>
<p>Right, but we also need something that works for groups</p>



<a name="232989618"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/branch%23gsmul_instance/near/232989618" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/branch.23gsmul_instance.html#232989618">(Apr 03 2021 at 07:53)</a>:</h4>
<p>What's the advantage of adding fields to <code>add_comm_group</code> here, vs just remembering to add a few explicit nat_semimodule instances?</p>



<a name="232989636"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/branch%23gsmul_instance/near/232989636" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/branch.23gsmul_instance.html#232989636">(Apr 03 2021 at 07:53)</a>:</h4>
<p>I suspect we would actually need very few</p>



<a name="232989692"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/branch%23gsmul_instance/near/232989692" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/branch.23gsmul_instance.html#232989692">(Apr 03 2021 at 07:54)</a>:</h4>
<p>There don't seem to be many "primitive" types, my impression is that most are compound types like linear_map which inherit the module structure</p>



<a name="232991221"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/branch%23gsmul_instance/near/232991221" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/branch.23gsmul_instance.html#232991221">(Apr 03 2021 at 08:27)</a>:</h4>
<p>Ah, the argument is it combines <code>[add_comm_monoid A] [semimodule nat A]</code> into a single parameter</p>



<a name="232993149"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/branch%23gsmul_instance/near/232993149" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/branch.23gsmul_instance.html#232993149">(Apr 03 2021 at 09:07)</a>:</h4>
<p>Not the same, but related, I think:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.polynomial.algebra_map</span>

<span class="kd">noncomputable theory</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">R</span> <span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">A</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">R</span> <span class="n">A</span><span class="o">]</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">algebra</span> <span class="n">R</span> <span class="o">(</span><span class="n">polynomial</span> <span class="n">R</span><span class="o">)</span> <span class="o">:=</span> <span class="n">polynomial.algebra_of_algebra</span>

<span class="c1">-- it seems that this is not yet in mathlib</span>
<span class="kd">instance</span> <span class="n">polynomial.map_algebra</span> <span class="o">:</span> <span class="n">algebra</span> <span class="o">(</span><span class="n">polynomial</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">polynomial</span> <span class="n">A</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">polynomial.map_ring_hom</span> <span class="o">(</span><span class="n">algebra_map</span> <span class="n">R</span> <span class="n">A</span><span class="o">))</span><span class="bp">.</span><span class="n">to_algebra</span>

<span class="kd">lemma</span> <span class="bp">«</span><span class="n">problem</span><span class="bp">?»</span> <span class="o">:</span>
  <span class="bp">@</span><span class="n">eq</span> <span class="o">(</span><span class="n">algebra</span> <span class="o">(</span><span class="n">polynomial</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">polynomial</span> <span class="o">(</span><span class="n">polynomial</span> <span class="n">R</span><span class="o">)))</span>
  <span class="n">polynomial.algebra_of_algebra</span>
  <span class="n">polynomial.map_algebra</span>
  <span class="o">:=</span>
<span class="n">rfl</span> <span class="c1">-- fails</span>
</code></pre></div>



<a name="232994084"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/branch%23gsmul_instance/near/232994084" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/branch.23gsmul_instance.html#232994084">(Apr 03 2021 at 09:27)</a>:</h4>
<p>Why stop at <code>add_comm_group</code>? Why not register some kind of action of nat on all monoids and add_monoids, and an action of int on all groups and add_groups? We have this already, it's just monoid.pow etc. The axiom <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>g</mi><mi>h</mi><msup><mo stretchy="false">)</mo><mi>n</mi></msup><mo>=</mo><msup><mi>g</mi><mi>n</mi></msup><msup><mi>h</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">(gh)^n=g^nh^n</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span> doesn't hold in general but we could just throw this in later with the commutativity assumptions. We could at the same time try to solve the problem that <code>to_additive</code> can't handle power stuff because the order of the inputs is wrong, by making g^n mean n bub g.</p>
<p>Would this mean that we would not have to persuade Leo to change the definition of natural multiplication in Lean 4 or is that another thing?</p>



<a name="232998169"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/branch%23gsmul_instance/near/232998169" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/branch.23gsmul_instance.html#232998169">(Apr 03 2021 at 10:52)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span>, are you convinced that statement is true?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.polynomial.algebra_map</span>

<span class="kd">noncomputable theory</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">R</span> <span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">A</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">R</span> <span class="n">A</span><span class="o">]</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">algebra</span> <span class="n">R</span> <span class="o">(</span><span class="n">polynomial</span> <span class="n">R</span><span class="o">)</span> <span class="o">:=</span> <span class="n">polynomial.algebra_of_algebra</span>

<span class="c1">-- it seems that this is not yet in mathlib</span>
<span class="kd">instance</span> <span class="n">polynomial.map_algebra</span> <span class="o">:</span> <span class="n">algebra</span> <span class="o">(</span><span class="n">polynomial</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">polynomial</span> <span class="n">A</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">polynomial.map_ring_hom</span> <span class="o">(</span><span class="n">algebra_map</span> <span class="n">R</span> <span class="n">A</span><span class="o">))</span><span class="bp">.</span><span class="n">to_algebra</span>

<span class="kd">lemma</span> <span class="n">map_algebra_smul</span> <span class="o">(</span><span class="n">pr</span> <span class="o">:</span> <span class="n">polynomial</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">pa</span> <span class="o">:</span> <span class="n">polynomial</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">pr</span> <span class="bp">•</span> <span class="n">pa</span> <span class="bp">=</span> <span class="n">polynomial.map_ring_hom</span> <span class="o">(</span><span class="n">algebra_map</span> <span class="n">R</span> <span class="n">A</span><span class="o">)</span> <span class="n">pr</span> <span class="bp">*</span> <span class="n">pa</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">lemma</span> <span class="n">algebra_of_algebra_smul</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">pa</span> <span class="o">:</span> <span class="n">polynomial</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">r</span> <span class="bp">•</span> <span class="n">pa</span> <span class="bp">=</span> <span class="n">finsupp.map_range</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">r</span> <span class="bp">•</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">smul_zero</span> <span class="n">_</span><span class="o">)</span> <span class="n">pa</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">lemma</span> <span class="bp">«</span><span class="n">problem</span><span class="bp">?»</span> <span class="o">:</span>
  <span class="bp">@</span><span class="n">eq</span> <span class="o">(</span><span class="n">algebra</span> <span class="o">(</span><span class="n">polynomial</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">polynomial</span> <span class="o">(</span><span class="n">polynomial</span> <span class="n">R</span><span class="o">)))</span>
  <span class="n">polynomial.algebra_of_algebra</span>
  <span class="n">polynomial.map_algebra</span>
  <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">ext1</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">map_algebra_smul</span><span class="o">,</span> <span class="n">algebra_of_algebra_smul</span><span class="o">],</span>
  <span class="n">simp</span><span class="o">,</span>
  <span class="gr">sorry</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="232999514"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/branch%23gsmul_instance/near/232999514" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/branch.23gsmul_instance.html#232999514">(Apr 03 2021 at 11:19)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/issues/7019">#7019</a> adds a lemma that might make that <code>sorry</code> easier to prove, as then we can write</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[simp]</span>
<span class="kd">lemma</span> <span class="n">polynomial.map_algebra_self_algebra_map</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">algebra_map</span> <span class="o">(</span><span class="n">polynomial</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">polynomial</span> <span class="n">R</span><span class="o">))</span> <span class="bp">=</span> <span class="n">ring_hom.id</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">polynomial.map_ring_hom_id</span>
</code></pre></div>



<a name="233026073"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/branch%23gsmul_instance/near/233026073" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/branch.23gsmul_instance.html#233026073">(Apr 03 2021 at 19:12)</a>:</h4>
<p>I've started looking at this. There is something that is a mystery for me, maybe it will look obvious to some of you. Suppose that I have changed the definition  of <code>comm_monoid</code> to add a field with data. As follows:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.group.inj_surj</span>

<span class="kd">set_option</span> <span class="n">old_structure_cmd</span> <span class="n">true</span>

<span class="kd">universe</span> <span class="n">u</span>

<span class="sd">/-- The power operation in a monoid. `a^n = a*a*...*a` n times. -/</span>
<span class="kd">def</span> <span class="n">monoid.pow_rec</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">has_one</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">M</span>
<span class="bp">|</span> <span class="mi">0</span>     <span class="n">a</span> <span class="o">:=</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">monoid.pow_rec</span> <span class="n">n</span> <span class="n">a</span>

<span class="kd">@[ancestor monoid comm_semigroup]</span>
<span class="kd">class</span> <span class="n">my_comm_monoid</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">monoid</span> <span class="n">M</span><span class="o">,</span> <span class="n">comm_semigroup</span> <span class="n">M</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">nspow</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">M</span> <span class="o">:=</span> <span class="n">monoid.pow_rec</span> <span class="n">M</span><span class="o">)</span>
<span class="o">(</span><span class="n">nspow_add'</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">M</span><span class="o">),</span> <span class="n">nspow</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="n">n</span><span class="o">)</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">nspow</span> <span class="n">m</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">nspow</span> <span class="n">n</span> <span class="n">x</span><span class="o">)</span>
</code></pre></div>
<p>I will want to fill the last field with a tactic to do it automatically, but before that let's do by hand the first breaking example, in <code>inj_surj.lean</code>.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">protected</span> <span class="kd">def</span> <span class="n">my_comm_monoid_of_injective</span> <span class="o">{</span><span class="n">M₁</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">M₂</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
  <span class="o">[</span><span class="n">has_mul</span> <span class="n">M₁</span><span class="o">]</span> <span class="o">[</span><span class="n">has_one</span> <span class="n">M₁</span><span class="o">]</span> <span class="o">[</span><span class="n">comm_monoid</span> <span class="n">M₂</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">M₁</span> <span class="bp">→</span> <span class="n">M₂</span><span class="o">)</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">function.injective</span> <span class="n">f</span><span class="o">)</span>
  <span class="o">(</span><span class="n">one</span> <span class="o">:</span> <span class="n">f</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">mul</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">f</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">my_comm_monoid</span> <span class="n">M₁</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">nspow_add'</span> <span class="o">:=</span> <span class="kd">begin</span>
  <span class="k">assume</span> <span class="n">n</span> <span class="n">m</span> <span class="n">a</span><span class="o">,</span>
    <span class="n">induction</span> <span class="n">n</span> <span class="k">with</span> <span class="n">n</span> <span class="n">ih</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">nat.add_zero</span><span class="o">,</span> <span class="n">monoid.pow_rec</span><span class="o">,</span> <span class="n">mul_one</span><span class="o">]</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">nat.add_succ</span><span class="o">,</span> <span class="n">monoid.pow_rec</span><span class="o">,</span> <span class="n">ih</span><span class="o">,</span> <span class="n">monoid.pow_rec</span><span class="o">,</span> <span class="bp">←</span> <span class="n">mul_assoc</span><span class="o">,</span> <span class="bp">←</span> <span class="n">mul_assoc</span><span class="o">],</span>
      <span class="n">rw</span> <span class="n">mul_comm</span> <span class="n">a</span> <span class="n">_</span> <span class="o">}</span> <span class="c1">-- fails</span>
  <span class="kd">end</span>
  <span class="bp">..</span> <span class="n">hf.comm_semigroup</span> <span class="n">f</span> <span class="n">mul</span><span class="o">,</span> <span class="bp">..</span> <span class="n">hf.monoid</span> <span class="n">f</span> <span class="n">one</span> <span class="n">mul</span> <span class="o">}</span>
</code></pre></div>
<p>Here, the <code>rw mul_one</code> in the first step of the induction succeeds, which means it is able to somehow find the <code>mul_one_class</code> instance, which is probably coming from the last line with <code>.. hf.monoid f one mul, .. hf.comm_semigroup f mul</code>. Then, in the second step of the induction, it can rewrite <code>mul_assoc</code>, so it finds the semigroup instance. Unfortunately, the <code>rw mul_comm a _</code> fails, which means it doesn't find the <code>comm_semigroup</code> instance, which should follow from the same line.</p>
<p>Do you understand what is going on, and if there is a generic enough fix?</p>



<a name="233026260"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/branch%23gsmul_instance/near/233026260" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/branch.23gsmul_instance.html#233026260">(Apr 03 2021 at 19:15)</a>:</h4>
<p>Unrelated to the above: but if this refactor means that <code>add_monoid_hom</code> will be defeq (for groups?) to <code>Z</code>-linear module homs, that would would be insanely cool.</p>



<a name="233026340"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/branch%23gsmul_instance/near/233026340" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/branch.23gsmul_instance.html#233026340">(Apr 03 2021 at 19:16)</a>:</h4>
<p><span class="user-mention" data-user-id="110050">@Sebastien Gouezel</span> Can you prove the <code>pow_add</code> lemma for <code>monoid.pow_rec</code> in a separate lemma? Does that help at the location of the error?</p>



<a name="233026372"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/branch%23gsmul_instance/near/233026372" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/branch.23gsmul_instance.html#233026372">(Apr 03 2021 at 19:17)</a>:</h4>
<p>Yes, I can prove it, and the proof I have given works fine. The question here is really about which instances are available when doing proofs inside fields of a structure.</p>



<a name="233026849"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/branch%23gsmul_instance/near/233026849" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/branch.23gsmul_instance.html#233026849">(Apr 03 2021 at 19:25)</a>:</h4>
<p>How does the proposed <code>nsmul</code> field end up mapped to an <code>has_scalar</code> instance?</p>



<a name="233027118"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/branch%23gsmul_instance/near/233027118" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/branch.23gsmul_instance.html#233027118">(Apr 03 2021 at 19:29)</a>:</h4>
<p>Later on, we will declare a <code>has_scalar ℕ M</code> instance on all <code>add_comm_group</code>s using this field. But for now, I am only starting with the simplest stuff, i.e., adding the fields, making sure that they are populated when creating the structure, but not using them yet. If I can't do this properly, I won't be able to go any further.</p>



<a name="233027555"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/branch%23gsmul_instance/near/233027555" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/branch.23gsmul_instance.html#233027555">(Apr 03 2021 at 19:35)</a>:</h4>
<p>A good joke in my mwe: if instead of the automatically populated field <code>nspow</code> you fill it by hand, then you get an error at a different place:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">protected</span> <span class="kd">def</span> <span class="n">my_comm_monoid_of_injective</span> <span class="o">{</span><span class="n">M₁</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">M₂</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
  <span class="o">[</span><span class="n">has_mul</span> <span class="n">M₁</span><span class="o">]</span> <span class="o">[</span><span class="n">has_one</span> <span class="n">M₁</span><span class="o">]</span> <span class="o">[</span><span class="n">comm_monoid</span> <span class="n">M₂</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">M₁</span> <span class="bp">→</span> <span class="n">M₂</span><span class="o">)</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">function.injective</span> <span class="n">f</span><span class="o">)</span>
  <span class="o">(</span><span class="n">one</span> <span class="o">:</span> <span class="n">f</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">mul</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">f</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">my_comm_monoid</span> <span class="n">M₁</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">nspow</span> <span class="o">:=</span> <span class="n">monoid.pow_rec</span> <span class="n">M₁</span><span class="o">,</span>
  <span class="n">nspow_add'</span> <span class="o">:=</span> <span class="kd">begin</span>
  <span class="k">assume</span> <span class="n">n</span> <span class="n">m</span> <span class="n">a</span><span class="o">,</span>
    <span class="n">induction</span> <span class="n">n</span> <span class="k">with</span> <span class="n">n</span> <span class="n">ih</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">nat.add_zero</span><span class="o">,</span> <span class="n">monoid.pow_rec</span><span class="o">,</span> <span class="n">mul_one</span><span class="o">]</span> <span class="o">},</span> <span class="c1">-- already fails</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">nat.add_succ</span><span class="o">,</span> <span class="n">monoid.pow_rec</span><span class="o">,</span> <span class="n">ih</span><span class="o">,</span> <span class="n">monoid.pow_rec</span><span class="o">,</span> <span class="bp">←</span> <span class="n">mul_assoc</span><span class="o">,</span> <span class="bp">←</span> <span class="n">mul_assoc</span><span class="o">],</span>
      <span class="n">rw</span> <span class="n">mul_comm</span> <span class="n">a</span> <span class="n">_</span> <span class="o">}</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="bp">..</span> <span class="n">hf.comm_semigroup</span> <span class="n">f</span> <span class="n">mul</span><span class="o">,</span> <span class="bp">..</span> <span class="n">hf.monoid</span> <span class="n">f</span> <span class="n">one</span> <span class="n">mul</span> <span class="o">}</span>
</code></pre></div>
<p>Really weird...</p>



<a name="233028458"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/branch%23gsmul_instance/near/233028458" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/branch.23gsmul_instance.html#233028458">(Apr 03 2021 at 19:49)</a>:</h4>
<p>The idea here is that, for example, <code>prod.add_comm_group.nsmul</code> would be designed such that it's defeq to <code>prod.has_scalar.smul</code>?</p>



<a name="233028567"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/branch%23gsmul_instance/near/233028567" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/branch.23gsmul_instance.html#233028567">(Apr 03 2021 at 19:51)</a>:</h4>
<p>Yes, exactly. Just like it's done for metric spaces and uniform spaces.</p>



<a name="233029963"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/branch%23gsmul_instance/near/233029963" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/branch.23gsmul_instance.html#233029963">(Apr 03 2021 at 20:14)</a>:</h4>
<p>A workaround to my problem is to change my prop field, using instead <code>nspow_eq_rec : ∀ (n : ℕ) (x : M), nspow n x = monoid.pow_rec n x</code>, which can be proved by <code>rfl</code> when using the default field, so no need to activate other classes. This solves my issue (though it will need some tweaks down the road with alternate constructors, but nothing bad), but still I'd be interested to understand what is going on here.</p>



<a name="233036376"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/branch%23gsmul_instance/near/233036376" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/branch.23gsmul_instance.html#233036376">(Apr 03 2021 at 22:04)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">protected</span> <span class="kd">def</span> <span class="n">my_comm_monoid_of_injective</span> <span class="o">{</span><span class="n">M₁</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">M₂</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
  <span class="o">[</span><span class="n">has_mul</span> <span class="n">M₁</span><span class="o">]</span> <span class="o">[</span><span class="n">has_one</span> <span class="n">M₁</span><span class="o">]</span> <span class="o">[</span><span class="n">comm_monoid</span> <span class="n">M₂</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">M₁</span> <span class="bp">→</span> <span class="n">M₂</span><span class="o">)</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">function.injective</span> <span class="n">f</span><span class="o">)</span>
  <span class="o">(</span><span class="n">one</span> <span class="o">:</span> <span class="n">f</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">mul</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">f</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">my_comm_monoid</span> <span class="n">M₁</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">nspow_add'</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="n">letI</span> <span class="o">:</span> <span class="n">comm_semigroup</span> <span class="n">M₁</span> <span class="o">:=</span> <span class="n">hf.comm_semigroup</span> <span class="n">f</span> <span class="n">mul</span><span class="o">,</span>
    <span class="n">letI</span> <span class="o">:</span> <span class="n">monoid</span> <span class="n">M₁</span> <span class="o">:=</span> <span class="n">hf.monoid</span> <span class="n">f</span> <span class="n">one</span> <span class="n">mul</span><span class="o">,</span>
  <span class="k">assume</span> <span class="n">n</span> <span class="n">m</span> <span class="n">a</span><span class="o">,</span>
    <span class="n">induction</span> <span class="n">n</span> <span class="k">with</span> <span class="n">n</span> <span class="n">ih</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">nat.add_zero</span><span class="o">,</span> <span class="n">monoid.pow_rec</span><span class="o">],</span>
      <span class="n">symmetry</span><span class="o">,</span>
      <span class="c1">-- monoid.pow_rec M₁ m a * 1 = monoid.pow_rec M₁ m a</span>
      <span class="n">exact</span> <span class="n">mul_one</span> <span class="o">(</span><span class="n">monoid.pow_rec</span> <span class="n">M₁</span> <span class="n">m</span> <span class="n">a</span><span class="o">)</span> <span class="o">},</span> <span class="c1">-- fails &lt;---------------------------------------------------------------------</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">nat.add_succ</span><span class="o">,</span> <span class="n">monoid.pow_rec</span><span class="o">,</span> <span class="n">ih</span><span class="o">,</span> <span class="n">monoid.pow_rec</span><span class="o">,</span> <span class="bp">←</span> <span class="n">mul_assoc</span><span class="o">,</span> <span class="bp">←</span> <span class="n">mul_assoc</span><span class="o">],</span>
      <span class="n">rw</span> <span class="n">mul_comm</span> <span class="n">a</span> <span class="n">_</span> <span class="o">}</span> <span class="c1">-- fails</span>
  <span class="kd">end</span>
  <span class="bp">..</span> <span class="n">hf.comm_semigroup</span> <span class="n">f</span> <span class="n">mul</span><span class="o">,</span> <span class="bp">..</span> <span class="n">hf.monoid</span> <span class="n">f</span> <span class="n">one</span> <span class="n">mul</span> <span class="o">}</span>
</code></pre></div>
<p>gives</p>
<div class="codehilite" data-code-language="Text only"><pre><span></span><code>unexpected argument at application
  @mul_one M₁ _inst_4 (@monoid.pow_rec M₁ _inst_1 _inst_2 m a)
given argument
  @monoid.pow_rec M₁ _inst_1 _inst_2 m a
expected argument
  @monoid.pow_rec M₁
    (@semigroup.to_has_mul M₁
       (@monoid.to_semigroup M₁
          (@monoid.mk M₁
             (@comm_semigroup.mul M₁
                (@function.injective.comm_semigroup M₁ M₂ _inst_1 (@comm_monoid.to_comm_semigroup M₂ _inst_3) f hf
                   mul))
             _
             (@monoid.one M₁
                (@function.injective.monoid M₁ M₂ _inst_1 _inst_2 (@comm_monoid.to_monoid M₂ _inst_3) f hf one
                   mul))
             _
             _)))
    (@monoid.to_has_one M₁
       (@monoid.mk M₁
          (@comm_semigroup.mul M₁
             (@function.injective.comm_semigroup M₁ M₂ _inst_1 (@comm_monoid.to_comm_semigroup M₂ _inst_3) f hf
                mul))
          _
          (@monoid.one M₁
             (@function.injective.monoid M₁ M₂ _inst_1 _inst_2 (@comm_monoid.to_monoid M₂ _inst_3) f hf one mul))
          _
          _))
    m
    a
</code></pre></div>



<a name="233036825"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/branch%23gsmul_instance/near/233036825" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/branch.23gsmul_instance.html#233036825">(Apr 03 2021 at 22:12)</a>:</h4>
<p>Aah, <code>convert</code> instead of <code>exact</code> gives the goals <code>⊢ semigroup.to_has_mul M₁ = _inst_1</code> and <code>⊢ monoid.to_has_one M₁ = _inst_2</code>. So this is probably your problem: you have two non-defeq <code>mul</code>s on <code>M_1</code>, one coming from the <code>[has_mul M_1]</code> and one coming from pulling back multiplication on <code>M_2</code> and your <code>mul</code> axiom is not definitional (and similarly you have non-definitional 1s).</p>



<a name="233037709"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/branch%23gsmul_instance/near/233037709" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/branch.23gsmul_instance.html#233037709">(Apr 03 2021 at 22:28)</a>:</h4>
<p>OK so this is beyond my pay grade. If we look at the code you originally posted, as you say the <code>rw mul_one</code> in the first step of the induction succeeds. For the rewrite to succeed, Lean must be inferring an instance of <code>monoid M1</code> somehow, and you would imagine that the type class inference system is doing this, but it is <em>not</em>! Indeed <code>letI : monoid M₁ := by apply_instance,</code> on the line before <em>fails</em>! So Lean is doing some kind of magic which happens when creating structures where it looks at the <code>..</code> stuff but this is somehow not in the type class inference cache at the point where I am trying to infer an instance?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">protected</span> <span class="kd">def</span> <span class="n">my_comm_monoid_of_injective</span> <span class="o">{</span><span class="n">M₁</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">M₂</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
  <span class="o">[</span><span class="n">has_mul</span> <span class="n">M₁</span><span class="o">]</span> <span class="o">[</span><span class="n">has_one</span> <span class="n">M₁</span><span class="o">]</span> <span class="o">[</span><span class="n">comm_monoid</span> <span class="n">M₂</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">M₁</span> <span class="bp">→</span> <span class="n">M₂</span><span class="o">)</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">function.injective</span> <span class="n">f</span><span class="o">)</span>
  <span class="o">(</span><span class="n">one</span> <span class="o">:</span> <span class="n">f</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">mul</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">f</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">my_comm_monoid</span> <span class="n">M₁</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">nspow_add'</span> <span class="o">:=</span> <span class="kd">begin</span>
  <span class="k">assume</span> <span class="n">n</span> <span class="n">m</span> <span class="n">a</span><span class="o">,</span>
    <span class="n">induction</span> <span class="n">n</span> <span class="k">with</span> <span class="n">n</span> <span class="n">ih</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">nat.add_zero</span><span class="o">,</span> <span class="n">monoid.pow_rec</span><span class="o">],</span>
      <span class="c1">-- ⊢ monoid.pow_rec M₁ m a = monoid.pow_rec M₁ m a * 1</span>
      <span class="c1">-- letI : monoid M₁ := by apply_instance, -- this FAILS</span>
      <span class="c1">-- and the next line will only work if Lean can find a monoid structure on M₁</span>
      <span class="n">rw</span> <span class="n">mul_one</span><span class="o">,</span> <span class="c1">-- but it works anyway!</span>
     <span class="o">},</span>
<span class="bp">...</span>
</code></pre></div>



<a name="233037983"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/branch%23gsmul_instance/near/233037983" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/branch.23gsmul_instance.html#233037983">(Apr 03 2021 at 22:33)</a>:</h4>
<p>(deleted)</p>



<a name="233038803"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/branch%23gsmul_instance/near/233038803" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/branch.23gsmul_instance.html#233038803">(Apr 03 2021 at 22:49)</a>:</h4>
<p>(deleted)</p>



<a name="233039171"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/branch%23gsmul_instance/near/233039171" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/branch.23gsmul_instance.html#233039171">(Apr 03 2021 at 22:56)</a>:</h4>
<p>This works:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">protected</span> <span class="kd">def</span> <span class="n">my_comm_monoid_of_injective</span> <span class="o">{</span><span class="n">M₁</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">M₂</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
  <span class="o">[</span><span class="n">has_mul</span> <span class="n">M₁</span><span class="o">]</span> <span class="o">[</span><span class="n">has_one</span> <span class="n">M₁</span><span class="o">]</span> <span class="o">[</span><span class="n">comm_monoid</span> <span class="n">M₂</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">M₁</span> <span class="bp">→</span> <span class="n">M₂</span><span class="o">)</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">function.injective</span> <span class="n">f</span><span class="o">)</span>
  <span class="o">(</span><span class="n">one</span> <span class="o">:</span> <span class="n">f</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">mul</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">f</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">my_comm_monoid</span> <span class="n">M₁</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">nspow_add'</span> <span class="o">:=</span> <span class="kd">begin</span>
  <span class="k">assume</span> <span class="n">n</span> <span class="n">m</span> <span class="n">a</span><span class="o">,</span>
    <span class="n">letI</span> <span class="o">:</span> <span class="n">comm_semigroup</span> <span class="n">M₁</span> <span class="o">:=</span> <span class="n">hf.comm_semigroup</span> <span class="n">f</span> <span class="n">mul</span><span class="o">,</span>
    <span class="n">induction</span> <span class="n">n</span> <span class="k">with</span> <span class="n">n</span> <span class="n">ih</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">nat.add_zero</span><span class="o">,</span> <span class="n">monoid.pow_rec</span><span class="o">,</span> <span class="n">mul_one</span><span class="o">]</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">nat.add_succ</span><span class="o">,</span> <span class="n">monoid.pow_rec</span><span class="o">,</span> <span class="n">ih</span><span class="o">,</span> <span class="n">monoid.pow_rec</span><span class="o">,</span> <span class="bp">←</span> <span class="n">mul_assoc</span><span class="o">,</span> <span class="bp">←</span> <span class="n">mul_assoc</span><span class="o">],</span>
      <span class="n">rw</span> <span class="n">mul_comm</span> <span class="n">a</span> <span class="n">_</span> <span class="o">}</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="bp">..</span> <span class="n">hf.comm_semigroup</span> <span class="n">f</span> <span class="n">mul</span><span class="o">,</span> <span class="bp">..</span> <span class="n">hf.monoid</span> <span class="n">f</span> <span class="n">one</span> <span class="n">mul</span> <span class="o">}</span>
</code></pre></div>



<a name="233039238"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/branch%23gsmul_instance/near/233039238" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/branch.23gsmul_instance.html#233039238">(Apr 03 2021 at 22:58)</a>:</h4>
<p>Isn't the axiomatization of <code>nspow</code> incomplete? It's not possible to prove <code>nspow 0 x = 1</code></p>



<a name="233039273"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/branch%23gsmul_instance/near/233039273" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/branch.23gsmul_instance.html#233039273">(Apr 03 2021 at 22:59)</a>:</h4>
<p>(you can prove it is idempotent but I don't think that's good enough to conclude it is <code>1</code> in a monoid)</p>



<a name="233039592"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/branch%23gsmul_instance/near/233039592" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/branch.23gsmul_instance.html#233039592">(Apr 03 2021 at 23:05)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">protected</span> <span class="kd">def</span> <span class="n">my_comm_monoid_of_injective</span> <span class="o">{</span><span class="n">M₁</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">M₂</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
  <span class="o">[</span><span class="n">has_mul</span> <span class="n">M₁</span><span class="o">]</span> <span class="o">[</span><span class="n">has_one</span> <span class="n">M₁</span><span class="o">]</span> <span class="o">[</span><span class="n">my_comm_monoid</span> <span class="n">M₂</span><span class="o">]</span>
  <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">M₁</span> <span class="bp">→</span> <span class="n">M₂</span><span class="o">)</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">function.injective</span> <span class="n">f</span><span class="o">)</span>
  <span class="o">(</span><span class="n">one</span> <span class="o">:</span> <span class="n">f</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">mul</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">f</span> <span class="n">y</span><span class="o">)</span>
  <span class="o">(</span><span class="n">nspow₁</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">M₁</span> <span class="bp">→</span> <span class="n">M₁</span> <span class="o">:=</span> <span class="n">monoid.pow_rec</span> <span class="n">M₁</span><span class="o">)</span>
  <span class="o">(</span><span class="n">nsm</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">nspow₁</span> <span class="n">n</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">my_comm_monoid.nspow</span> <span class="n">n</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">))</span> <span class="o">:</span>
  <span class="n">my_comm_monoid</span> <span class="n">M₁</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">nspow</span> <span class="o">:=</span> <span class="n">nspow₁</span><span class="o">,</span>
  <span class="n">nspow_add'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">n</span> <span class="n">m</span> <span class="n">x</span><span class="o">,</span> <span class="kd">begin</span>
    <span class="n">change</span> <span class="n">nspow₁</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="n">n</span><span class="o">)</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">nspow₁</span> <span class="n">m</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">nspow₁</span> <span class="n">n</span> <span class="n">x</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">hf</span><span class="o">,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">nsm</span><span class="o">,</span> <span class="n">mul</span><span class="o">,</span> <span class="n">nsm</span><span class="o">,</span> <span class="n">nsm</span><span class="o">,</span> <span class="n">my_comm_monoid.nspow_add'</span><span class="o">],</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="bp">..</span> <span class="n">hf.comm_semigroup</span> <span class="n">f</span> <span class="n">mul</span><span class="o">,</span> <span class="bp">..</span> <span class="n">hf.monoid</span> <span class="n">f</span> <span class="n">one</span> <span class="n">mul</span> <span class="o">}</span>
</code></pre></div>



<a name="233040022"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/branch%23gsmul_instance/near/233040022" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/branch.23gsmul_instance.html#233040022">(Apr 03 2021 at 23:14)</a>:</h4>
<p>or</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[ancestor monoid comm_semigroup]</span>
<span class="kd">class</span> <span class="n">my_comm_monoid</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">monoid</span> <span class="n">M</span><span class="o">,</span> <span class="n">comm_semigroup</span> <span class="n">M</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">nspow</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">M</span> <span class="o">:=</span> <span class="n">monoid.pow_rec</span> <span class="n">M</span><span class="o">)</span>
<span class="o">(</span><span class="n">nspow_eq'</span> <span class="o">:</span> <span class="n">nspow</span> <span class="bp">=</span> <span class="n">monoid.pow_rec</span> <span class="n">M</span> <span class="bp">.</span> <span class="n">control_laws_tac</span><span class="o">)</span>

<span class="kn">protected</span> <span class="kd">def</span> <span class="n">my_comm_monoid_of_injective</span> <span class="o">{</span><span class="n">M₁</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">M₂</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
  <span class="o">[</span><span class="n">has_mul</span> <span class="n">M₁</span><span class="o">]</span> <span class="o">[</span><span class="n">has_one</span> <span class="n">M₁</span><span class="o">]</span> <span class="o">[</span><span class="n">my_comm_monoid</span> <span class="n">M₂</span><span class="o">]</span>
  <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">M₁</span> <span class="bp">→</span> <span class="n">M₂</span><span class="o">)</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">function.injective</span> <span class="n">f</span><span class="o">)</span>
  <span class="o">(</span><span class="n">one</span> <span class="o">:</span> <span class="n">f</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">mul</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">f</span> <span class="n">y</span><span class="o">)</span>
  <span class="o">(</span><span class="n">nspow</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">M₁</span> <span class="bp">→</span> <span class="n">M₁</span> <span class="o">:=</span> <span class="n">monoid.pow_rec</span> <span class="n">M₁</span><span class="o">)</span>
  <span class="o">(</span><span class="n">nsm</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">nspow</span> <span class="n">n</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">my_comm_monoid.nspow</span> <span class="n">n</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">))</span> <span class="o">:</span>
  <span class="n">my_comm_monoid</span> <span class="n">M₁</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">nspow</span> <span class="o">:=</span> <span class="n">nspow</span><span class="o">,</span>
  <span class="n">nspow_eq'</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="n">funext</span> <span class="n">n</span> <span class="n">x</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">hf</span><span class="o">,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">nsm</span><span class="o">,</span> <span class="k">show</span> <span class="n">_</span><span class="bp">=</span><span class="n">_</span><span class="o">,</span> <span class="k">from</span> <span class="n">my_comm_monoid.nspow_eq'</span><span class="o">],</span>
    <span class="n">induction</span> <span class="n">n</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">one.symm</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">monoid.pow_rec</span><span class="o">,</span> <span class="n">n_ih</span><span class="o">,</span> <span class="bp">←</span> <span class="n">mul</span><span class="o">],</span> <span class="n">refl</span> <span class="o">}</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="bp">..</span> <span class="n">hf.comm_semigroup</span> <span class="n">f</span> <span class="n">mul</span><span class="o">,</span> <span class="bp">..</span> <span class="n">hf.monoid</span> <span class="n">f</span> <span class="n">one</span> <span class="n">mul</span> <span class="o">}</span>
</code></pre></div>



<a name="233062342"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/branch%23gsmul_instance/near/233062342" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/branch.23gsmul_instance.html#233062342">(Apr 04 2021 at 07:05)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113488-general/topic/branch.23gsmul_instance/near/233039238">said</a>:</p>
<blockquote>
<p>Isn't the axiomatization of <code>nspow</code> incomplete? It's not possible to prove <code>nspow 0 x = 1</code></p>
</blockquote>
<p>Sure, it was just for the mwe but I also have the other axioms in my files.</p>



<a name="233062658"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/branch%23gsmul_instance/near/233062658" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/branch.23gsmul_instance.html#233062658">(Apr 04 2021 at 07:11)</a>:</h4>
<p>Mario and Kevin, your solutions work, but they are specific to the problem at hand. My goal was really to do the following: endow a type with the power <code>monoid.pow_rec</code> (not another one) and prove with a universal tactic block that it satisfies the axioms, so that this tactic block can be used in all situations and then automated. The pullback comm_monoid was just an example of a situation where my universal tactic block, which most often works, failed because of Lean not finding the right instance. I can absolutely do it by hand or by modifying the definition like you did, but I was looking for a more principled solution which would always work automatically. Anyway, the solution to change the axioms by requiring instead equality with <code>monoid.pow_rec</code> works (the automatic proof is just by <code>rfl</code> and always works), so I'll go this route.</p>



<a name="233062914"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/branch%23gsmul_instance/near/233062914" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/branch.23gsmul_instance.html#233062914">(Apr 04 2021 at 07:17)</a>:</h4>
<p>I would suggest avoiding a full tactic block in an auto param unless you actually need to do something tactic-like such as inspecting the kind of definition that the user gave. If it's just a theorem parametric on values provided by the user then you should prove a lemma and the auto_param tactic should be essentially <code>apply my_lemma</code></p>



<a name="233063272"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/branch%23gsmul_instance/near/233063272" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/branch.23gsmul_instance.html#233063272">(Apr 04 2021 at 07:25)</a>:</h4>
<p>That's what I did first, but the <code>my_lemma</code> needs some typeclasses that are not found, for the same reason as in my <a href="https://leanprover-community.github.io/mwe.html">#mwe</a> (that I minimized by removing the lemma and the tactic to get to the heart of the issue).</p>



<a name="233063537"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/branch%23gsmul_instance/near/233063537" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/branch.23gsmul_instance.html#233063537">(Apr 04 2021 at 07:31)</a>:</h4>
<p>you may have to supply the typeclasses manually, since as kevin observed there is a bit of magic to construct the typeclass argument for <code>extends</code> structures inside a structure literal</p>



<a name="233063684"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/branch%23gsmul_instance/near/233063684" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/branch.23gsmul_instance.html#233063684">(Apr 04 2021 at 07:34)</a>:</h4>
<p>Yes, my question was precisely about this magic bit, and if I could make it even a little bit more magical to just work in all situations :-)</p>



<a name="233063745"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/branch%23gsmul_instance/near/233063745" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/branch.23gsmul_instance.html#233063745">(Apr 04 2021 at 07:35)</a>:</h4>
<p>The fix in the tactic example is to add <code>letI := hf.comm_semigroup f mul</code> but I think I'm missing the actual question</p>



<a name="233063816"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/branch%23gsmul_instance/near/233063816" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/branch.23gsmul_instance.html#233063816">(Apr 04 2021 at 07:36)</a>:</h4>
<p>The tactic state inside structure fields is a bit of a mess since there are a bunch of typeclasses inside things like <code>has_mul.mul</code> that aren't actually in the context, so some theorems will work by unification and others will fail because the typeclass isn't available</p>



<a name="233063819"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/branch%23gsmul_instance/near/233063819" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/branch.23gsmul_instance.html#233063819">(Apr 04 2021 at 07:37)</a>:</h4>
<p>The actual question is "is there a way to not need a fix"?</p>



<a name="233063829"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/branch%23gsmul_instance/near/233063829" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/branch.23gsmul_instance.html#233063829">(Apr 04 2021 at 07:37)</a>:</h4>
<p>Well there's an error in the provided tactic block, so no?</p>



<a name="233063830"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/branch%23gsmul_instance/near/233063830" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/branch.23gsmul_instance.html#233063830">(Apr 04 2021 at 07:37)</a>:</h4>
<p>And I suspect the answer is no.</p>



<a name="233063833"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/branch%23gsmul_instance/near/233063833" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/branch.23gsmul_instance.html#233063833">(Apr 04 2021 at 07:37)</a>:</h4>
<p>of course the tactic block or statement has to change to make it work</p>



<a name="233063882"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/branch%23gsmul_instance/near/233063882" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/branch.23gsmul_instance.html#233063882">(Apr 04 2021 at 07:38)</a>:</h4>
<p>but this seems like a tautology</p>



<a name="233063886"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/branch%23gsmul_instance/near/233063886" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/branch.23gsmul_instance.html#233063886">(Apr 04 2021 at 07:38)</a>:</h4>
<p>Or maybe the question is "is there a way to fix Lean to not need a fix in this kind of situation"?</p>



<a name="233063902"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/branch%23gsmul_instance/near/233063902" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/branch.23gsmul_instance.html#233063902">(Apr 04 2021 at 07:39)</a>:</h4>
<p>Or "is there a magic instruction I could add in my tactic block to infer the instances I need from the <code>.. </code> line"?</p>



<a name="233063930"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/branch%23gsmul_instance/near/233063930" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/branch.23gsmul_instance.html#233063930">(Apr 04 2021 at 07:40)</a>:</h4>
<p>(Without adding it by hand, because by hand it would depend on the specific situation and I  want a fix that always works)</p>



<a name="233064086"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/branch%23gsmul_instance/near/233064086" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/branch.23gsmul_instance.html#233064086">(Apr 04 2021 at 07:43)</a>:</h4>
<p>Well part of the issue is that this uses <code>old_structure_cmd</code>. When you use <code>{ .. hf.comm_semigroup f mul }</code>, it has to splat out the projections into the structure, so it's not like <code>letI : comm_semigroup M₁ := hf.comm_semigroup f mul</code> was actually added to the context. If you had <code>comm_semigroup M₁</code> available to the typeclass system, then in the new structure command it would pick that instance up since it would be a typeclass argument to <code>my_comm_monoid.mk</code>. With the old structure command it can't be, it is splatted out into fields, so you have to specify it in both places</p>



<a name="233064152"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/branch%23gsmul_instance/near/233064152" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/branch.23gsmul_instance.html#233064152">(Apr 04 2021 at 07:44)</a>:</h4>
<p>One way to write it without repetition is</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">begin</span>
  <span class="n">letI</span> <span class="o">:=</span> <span class="n">hf.comm_semigroup</span> <span class="n">f</span> <span class="n">mul</span><span class="o">,</span>
  <span class="n">refine</span> <span class="o">{</span> <span class="n">nspow_add'</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="k">assume</span> <span class="n">n</span> <span class="n">m</span> <span class="n">a</span><span class="o">,</span>
      <span class="n">induction</span> <span class="n">n</span> <span class="k">with</span> <span class="n">n</span> <span class="n">ih</span><span class="o">,</span>
      <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">nat.add_zero</span><span class="o">,</span> <span class="n">monoid.pow_rec</span><span class="o">,</span> <span class="n">mul_one</span><span class="o">]</span> <span class="o">},</span>
      <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">nat.add_succ</span><span class="o">,</span> <span class="n">monoid.pow_rec</span><span class="o">,</span> <span class="n">ih</span><span class="o">,</span> <span class="n">monoid.pow_rec</span><span class="o">,</span> <span class="bp">←</span> <span class="n">mul_assoc</span><span class="o">,</span> <span class="bp">←</span> <span class="n">mul_assoc</span><span class="o">],</span>
        <span class="n">rw</span> <span class="n">mul_comm</span> <span class="n">a</span> <span class="n">_</span> <span class="o">}</span>
    <span class="kd">end</span>
    <span class="bp">..</span> <span class="o">(</span><span class="kd">by</span> <span class="n">apply_instance</span> <span class="o">:</span> <span class="n">comm_semigroup</span> <span class="n">M₁</span><span class="o">),</span>
    <span class="bp">..</span> <span class="n">hf.monoid</span> <span class="n">f</span> <span class="n">one</span> <span class="n">mul</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>
<p>but that's not exactly shorter</p>



<a name="233064196"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/branch%23gsmul_instance/near/233064196" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/branch.23gsmul_instance.html#233064196">(Apr 04 2021 at 07:45)</a>:</h4>
<p>The mystery to me is that it finds <em>some</em> instances, like <code>mul_one_class</code>. And it doesn't find the same ones if the <code>nspow</code> field is populated by hand or with the tactic.</p>



<a name="233064271"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/branch%23gsmul_instance/near/233064271" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/branch.23gsmul_instance.html#233064271">(Apr 04 2021 at 07:47)</a>:</h4>
<p>are you sure it found <code>mul_one_class</code>? It probably just got it by unification</p>



<a name="233064370"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/branch%23gsmul_instance/near/233064370" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/branch.23gsmul_instance.html#233064370">(Apr 04 2021 at 07:48)</a>:</h4>
<p>You can try the example in <a href="#narrow/stream/113488-general/topic/branch.23gsmul_instance/near/233026073">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/branch.23gsmul_instance/near/233026073</a></p>



<a name="233064451"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/branch%23gsmul_instance/near/233064451" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/branch.23gsmul_instance.html#233064451">(Apr 04 2021 at 07:50)</a>:</h4>
<p>(and then try it again by filling the <code>nspow</code> field by hand instead of with the automatic block, to see the difference).</p>



<a name="233064549"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/branch%23gsmul_instance/near/233064549" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/branch.23gsmul_instance.html#233064549">(Apr 04 2021 at 07:52)</a>:</h4>
<p>What's the goal state at the failing mul_comm?</p>



<a name="233064812"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/branch%23gsmul_instance/near/233064812" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/branch.23gsmul_instance.html#233064812">(Apr 04 2021 at 07:59)</a>:</h4>
<p>Indeed, if you provide <code>nspow := monoid.pow_rec M₁</code> (that is, <code>@monoid.pow_rec M₁ _inst_1 _inst_2</code>), then at the failing <code>mul_one</code> application the goal is</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">_</span> <span class="bp">=</span> <span class="n">has_mul.mul</span> <span class="n">M₁</span> <span class="o">(</span><span class="n">mul_one_class.to_has_mul</span> <span class="n">M₁</span><span class="o">)</span> <span class="n">_</span> <span class="o">(</span><span class="n">has_one.one</span> <span class="n">M₁</span> <span class="n">_inst_2</span><span class="o">)</span>
</code></pre></div>
<p>and if you don't provide it and let it fill in automatically <code>monoid.pow_rec M₁</code> (that is, <code>@monoid.pow_rec M₁ (mul_one_class.to_has_mul M₁) (mul_one_class.to_has_one M₁)</code>), then the goal is</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">_</span> <span class="bp">=</span> <span class="n">has_mul.mul</span> <span class="n">M₁</span> <span class="o">(</span><span class="n">mul_one_class.to_has_mul</span> <span class="n">M₁</span><span class="o">)</span> <span class="n">_</span> <span class="o">(</span><span class="n">has_one.one</span> <span class="n">M₁</span> <span class="o">(</span><span class="n">mul_one_class.to_has_one</span> <span class="n">M₁</span><span class="o">))</span>
</code></pre></div>
<p>and so <code>mul_one_class.mul_one</code> actually matches by unification, not by typeclass inference.</p>



<a name="233065001"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/branch%23gsmul_instance/near/233065001" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/branch.23gsmul_instance.html#233065001">(Apr 04 2021 at 08:02)</a>:</h4>
<p>Ah, thanks for explaining the mystery! I am still wondering why filling it with the tactic block uses <code>has_mul.mul M₁ (mul_one_class.to_has_mul M₁) _ (has_one.one M₁ (mul_one_class.to_has_one M₁))</code>, and especially where the tactic block is finding this <code>mul_one_class</code> instance.</p>



<a name="233065071"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/branch%23gsmul_instance/near/233065071" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/branch.23gsmul_instance.html#233065071">(Apr 04 2021 at 08:03)</a>:</h4>
<p>You might wonder why the automatic instantiation of <code>nspow</code> has <code>mul_one_class</code> all over it, and that's because of a trick that lean uses while elaborating the <code>monoid.pow_rec M</code> in the opt_param inside the structure definition of <code>my_comm_monoid</code>. The context at that point doesn't actually have a <code>monoid</code> instance in it, it has a bunch of fields, but lean will actually add the equivalent of <code>letI := &lt;mul, one, mul_one, one_mul&gt;</code> to typeclass inference (it's not actually using <code>letI</code> since this is part of core lean) in order to elaborate it, so you end up with these explicit <code>monoid.mk</code> things inside typeclass args</p>



<a name="233065145"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/branch%23gsmul_instance/near/233065145" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/branch.23gsmul_instance.html#233065145">(Apr 04 2021 at 08:04)</a>:</h4>
<p>ok, thanks a lot!</p>



<a name="233065236"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/branch%23gsmul_instance/near/233065236" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/branch.23gsmul_instance.html#233065236">(Apr 04 2021 at 08:06)</a>:</h4>
<p>if you replace the field with <code>(nspow : ℕ → M → M := by show_term {exact monoid.pow_rec M})</code> with <code>pp.all</code> you will see that it is actually </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="o">(</span><span class="bp">@</span><span class="n">monoid.pow_rec</span> <span class="n">M₁</span>
            <span class="o">(</span><span class="bp">@</span><span class="n">mul_one_class.to_has_mul</span> <span class="n">M₁</span>
               <span class="o">(</span><span class="bp">@</span><span class="n">monoid.to_mul_one_class</span> <span class="n">M₁</span>
                  <span class="o">(</span><span class="bp">@</span><span class="n">monoid.mk</span> <span class="n">M₁</span>
<span class="bp">...</span>
</code></pre></div>



<a name="233065245"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/branch%23gsmul_instance/near/233065245" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/branch.23gsmul_instance.html#233065245">(Apr 04 2021 at 08:06)</a>:</h4>
<p>Does it mean that if I defined my <code>pow_rec</code> to also take an instance <code>[comm_semi_group G]</code>, then core Lean would also find it and add it here, and then it would be available by unification in the tactic block proof?</p>



<a name="233065278"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/branch%23gsmul_instance/near/233065278" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/branch.23gsmul_instance.html#233065278">(Apr 04 2021 at 08:07)</a>:</h4>
<p>Unfortunately, you are pretty limited when it comes to using unification to find things, because that depends on the actual sequence of things in the hierarchy of typeclasses leading to the projections that were used</p>



<a name="233065310"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/branch%23gsmul_instance/near/233065310" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/branch.23gsmul_instance.html#233065310">(Apr 04 2021 at 08:08)</a>:</h4>
<p>you just got lucky here with <code>mul_one_class</code>, most instances can't be found this way</p>



<a name="233065433"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/branch%23gsmul_instance/near/233065433" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/branch.23gsmul_instance.html#233065433">(Apr 04 2021 at 08:10)</a>:</h4>
<p>If there are any defeq diamonds like <code>A -&gt; B -&gt; D</code> and <code>A -&gt; C -&gt; D</code> and typeclass inference finds the first path (in a context where you have <code>A</code> and need <code>D</code>), then theorems about <code>B</code> will trigger but not theorems about <code>C</code></p>



<a name="233067708"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/branch%23gsmul_instance/near/233067708" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/branch.23gsmul_instance.html#233067708">(Apr 04 2021 at 09:01)</a>:</h4>
<p>Just to summarize the discussion: there is a magical tactic "pull an instance out of thin air" that is used by Lean core C++ when filling in <code>opt_param</code> fields of structures. Unfortunately, it is not accessible to mere mortal users. Thanks Mario for the explanations!</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
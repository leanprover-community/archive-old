---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/Tree.20notation.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tree.20notation.html">Tree notation</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="271701998"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tree%20notation/near/271701998" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tree.20notation.html#271701998">(Feb 12 2022 at 18:18)</a>:</h4>
<p>Is there notation for <a href="https://leanprover-community.github.io/mathlib_docs/find/tree">docs#tree</a>? If not, what could one be?</p>



<a name="271702196"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tree%20notation/near/271702196" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tree.20notation.html#271702196">(Feb 12 2022 at 18:21)</a>:</h4>
<p>The context is <a href="https://github.com/leanprover-community/mathlib/pull/10645">#10645</a> where we're gonna use a tactic to generate a (huge) certificate tree, then cache it by putting it in the code.</p>



<a name="271702303"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tree%20notation/near/271702303" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tree.20notation.html#271702303">(Feb 12 2022 at 18:22)</a>:</h4>
<p><code>roth?</code> will output <code>Try this: roth &lt;insert big tree here&gt;</code> and <code>roth t</code> where <code>t</code> is a <code>tree</code> will apply a custom tactic for nodes and another one for leaves.</p>



<a name="271702379"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tree%20notation/near/271702379" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tree.20notation.html#271702379">(Feb 12 2022 at 18:24)</a>:</h4>
<p>So I'm actually only interested in <code>tree unit</code>, with specific notation if possible because I don't want to have to write <code>()</code> in every node.</p>



<a name="271702418"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tree%20notation/near/271702418" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tree.20notation.html#271702418">(Feb 12 2022 at 18:25)</a>:</h4>
<p>Of course, we can always flatten <code>tree α</code> to <code>list (option α)</code> (or maybe in our case to <code>list bool</code>. I'm open to suggestions. I just want something usable.</p>



<a name="271714756"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tree%20notation/near/271714756" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tree.20notation.html#271714756">(Feb 12 2022 at 23:10)</a>:</h4>
<p>Do you care if the tree is "readable"? You could output some compressed representation as a string and parse it in the tactic</p>



<a name="271714833"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tree%20notation/near/271714833" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tree.20notation.html#271714833">(Feb 12 2022 at 23:12)</a>:</h4>
<p>No, I don't care about readability at all, and it's meant to be processed by a tactic anyway so an additional parsing shouldn't. However, the length of the said string could be of the order of 1000 characters, so they can't hold on a line. Is <code>"stuff" ++ "other stuff"</code> an acceptable way to circumvent the problem?</p>



<a name="271715500"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tree%20notation/near/271715500" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tree.20notation.html#271715500">(Feb 12 2022 at 23:29)</a>:</h4>
<p>Do you think we could go as far as outputting one big number?</p>



<a name="271715557"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tree%20notation/near/271715557" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tree.20notation.html#271715557">(Feb 12 2022 at 23:30)</a>:</h4>
<p>Why is that better than a string?</p>



<a name="271715559"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tree%20notation/near/271715559" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tree.20notation.html#271715559">(Feb 12 2022 at 23:30)</a>:</h4>
<p>Can you wrap numbers in lean?</p>



<a name="271715632"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tree%20notation/near/271715632" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tree.20notation.html#271715632">(Feb 12 2022 at 23:32)</a>:</h4>
<p>It's better than a string of <code>t</code> and <code>f</code>, but it's worse than a string of literally any allowable character.</p>



<a name="271715662"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tree%20notation/near/271715662" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tree.20notation.html#271715662">(Feb 12 2022 at 23:33)</a>:</h4>
<p>base64 encoding would be the common way to encode a blob of bits in a text file.</p>



<a name="271716026"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tree%20notation/near/271716026" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tree.20notation.html#271716026">(Feb 12 2022 at 23:42)</a>:</h4>
<p>SHould I write such a parser from scratch and dedicated to <code>tree</code> or should I set up an API for turning a repr into a base64 string?</p>



<a name="271722524"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tree%20notation/near/271722524" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tree.20notation.html#271722524">(Feb 13 2022 at 02:33)</a>:</h4>
<p><span class="user-mention" data-user-id="387244">@Yaël Dillies</span> I had a go at this:</p>
<div class="spoiler-block"><div class="spoiler-header">
<p>tree &lt;-&gt; string</p>
</div><div class="spoiler-content" aria-hidden="true">
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">data.tree</span>
<span class="kn">import</span> <span class="n">data.nat.digits</span>
<span class="kn">import</span> <span class="n">tactic.slim_check</span>

<span class="c1">--def base64_chars : string :=</span>
<span class="c1">--"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"</span>

<span class="kd">def</span> <span class="n">base64_to_char</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="mi">64</span><span class="o">)</span> <span class="o">:</span> <span class="n">char</span> <span class="o">:=</span>
<span class="k">if</span> <span class="n">h1</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="mi">26</span> <span class="k">then</span> <span class="n">char.of_nat</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">65</span><span class="o">)</span>
<span class="k">else</span> <span class="k">if</span> <span class="n">h2</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="mi">52</span> <span class="k">then</span> <span class="n">char.of_nat</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">71</span><span class="o">)</span>
<span class="k">else</span> <span class="k">if</span> <span class="n">h3</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="mi">62</span> <span class="k">then</span> <span class="n">char.of_nat</span> <span class="o">(</span><span class="n">n</span> <span class="bp">-</span> <span class="mi">4</span><span class="o">)</span>
<span class="k">else</span> <span class="k">if</span> <span class="n">h4</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">62</span> <span class="k">then</span> <span class="sc">'+'</span>
<span class="k">else</span> <span class="k">if</span> <span class="n">h5</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">63</span> <span class="k">then</span> <span class="sc">'/'</span>
<span class="k">else</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">exfalso</span><span class="o">,</span> <span class="n">simp</span> <span class="n">at</span> <span class="n">h3</span><span class="o">,</span> <span class="n">interval_cases</span> <span class="n">n</span><span class="bp">;</span> <span class="n">trivial</span><span class="o">,</span> <span class="o">}</span>

<span class="kd">def</span> <span class="n">base64_to_char'</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">char</span> <span class="o">:=</span>
<span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="mi">64</span> <span class="k">then</span> <span class="n">base64_to_char</span> <span class="n">n</span> <span class="n">h</span> <span class="k">else</span> <span class="sc">'A'</span>

<span class="kd">def</span> <span class="n">base64_of_char</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">char</span><span class="o">)</span> <span class="o">:</span> <span class="n">option</span> <span class="n">ℕ</span> <span class="o">:=</span>
<span class="k">let</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">char.to_nat</span> <span class="n">c</span> <span class="k">in</span>
<span class="k">if</span> <span class="mi">65</span> <span class="bp">&lt;=</span> <span class="n">n</span> <span class="bp">∧</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="mi">91</span> <span class="k">then</span> <span class="n">some</span> <span class="o">(</span><span class="n">n</span> <span class="bp">-</span> <span class="mi">65</span><span class="o">)</span>
<span class="k">else</span> <span class="k">if</span> <span class="mi">97</span> <span class="bp">&lt;=</span> <span class="n">n</span> <span class="bp">∧</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="mi">123</span> <span class="k">then</span> <span class="n">some</span> <span class="o">(</span><span class="n">n</span> <span class="bp">-</span> <span class="mi">71</span><span class="o">)</span>
<span class="k">else</span> <span class="k">if</span> <span class="mi">48</span> <span class="bp">&lt;=</span> <span class="n">n</span> <span class="bp">∧</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="mi">58</span> <span class="k">then</span> <span class="n">some</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">4</span><span class="o">)</span>
<span class="k">else</span> <span class="k">if</span> <span class="n">c</span> <span class="bp">=</span> <span class="sc">'+'</span> <span class="k">then</span> <span class="n">some</span> <span class="mi">62</span>
<span class="k">else</span> <span class="k">if</span> <span class="n">c</span> <span class="bp">=</span> <span class="sc">'/'</span> <span class="k">then</span> <span class="n">some</span> <span class="mi">63</span>
<span class="k">else</span> <span class="n">none</span>

<span class="c1">--example (n : ℕ) (h : n &lt; 64) : base64_of_char (base64_to_char n h) = n := by dec_trivial!</span>

<span class="kd">def</span> <span class="n">to_bool_list_aux</span> <span class="o">:</span> <span class="n">tree</span> <span class="n">unit</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">bool</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">bool</span>
<span class="bp">|</span> <span class="n">tree.nil</span> <span class="n">acc</span> <span class="o">:=</span> <span class="n">ff</span> <span class="o">::</span> <span class="n">acc</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">tree.node</span> <span class="n">_</span> <span class="n">l</span> <span class="n">r</span><span class="o">)</span> <span class="n">acc</span> <span class="o">:=</span> <span class="n">to_bool_list_aux</span> <span class="n">l</span> <span class="o">(</span><span class="n">to_bool_list_aux</span> <span class="n">r</span> <span class="o">(</span><span class="n">tt</span> <span class="o">::</span> <span class="n">acc</span><span class="o">))</span>

<span class="kd">def</span> <span class="n">to_bool_list</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">tree</span> <span class="n">unit</span><span class="o">)</span> <span class="o">:</span> <span class="n">list</span> <span class="n">bool</span> <span class="o">:=</span> <span class="n">to_bool_list_aux</span> <span class="n">t</span> <span class="o">[]</span>

<span class="kd">def</span> <span class="n">of_bool_list_aux</span> <span class="o">:</span> <span class="n">list</span> <span class="n">bool</span> <span class="bp">→</span> <span class="n">list</span> <span class="o">(</span><span class="n">tree</span> <span class="n">unit</span><span class="o">)</span> <span class="bp">→</span> <span class="n">option</span> <span class="o">(</span><span class="n">tree</span> <span class="n">unit</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="o">[]</span> <span class="o">:=</span> <span class="n">none</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="o">(</span><span class="n">t</span> <span class="o">::</span> <span class="n">_</span><span class="o">)</span> <span class="o">:=</span> <span class="n">some</span> <span class="n">t</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">ff</span> <span class="o">::</span> <span class="n">xs</span><span class="o">)</span> <span class="n">stack</span> <span class="o">:=</span> <span class="n">of_bool_list_aux</span> <span class="n">xs</span> <span class="o">(</span><span class="n">tree.nil</span> <span class="o">::</span> <span class="n">stack</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">tt</span> <span class="o">::</span> <span class="n">xs</span><span class="o">)</span> <span class="o">[]</span> <span class="o">:=</span> <span class="n">none</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">tt</span> <span class="o">::</span> <span class="n">xs</span><span class="o">)</span> <span class="o">[</span><span class="n">_</span><span class="o">]</span> <span class="o">:=</span> <span class="n">none</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">tt</span> <span class="o">::</span> <span class="n">xs</span><span class="o">)</span> <span class="o">(</span><span class="n">r</span> <span class="o">::</span> <span class="n">l</span> <span class="o">::</span> <span class="n">stack</span><span class="o">)</span> <span class="o">:=</span> <span class="n">of_bool_list_aux</span> <span class="n">xs</span> <span class="o">(</span><span class="n">tree.node</span> <span class="o">()</span> <span class="n">l</span> <span class="n">r</span> <span class="o">::</span> <span class="n">stack</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">of_bool_list</span> <span class="o">(</span><span class="n">xs</span> <span class="o">:</span> <span class="n">list</span> <span class="n">bool</span><span class="o">)</span> <span class="o">:</span> <span class="n">option</span> <span class="o">(</span><span class="n">tree</span> <span class="n">unit</span><span class="o">)</span> <span class="o">:=</span> <span class="n">of_bool_list_aux</span> <span class="n">xs</span> <span class="o">[]</span>

<span class="kd">def</span> <span class="n">string_of_bool_list</span> <span class="o">(</span><span class="n">xs</span> <span class="o">:</span> <span class="n">list</span> <span class="n">bool</span><span class="o">)</span> <span class="o">:</span> <span class="n">string</span> <span class="o">:=</span>
<span class="n">list.as_string</span> <span class="bp">$</span>
<span class="o">(</span><span class="n">xs.reverse.to_chunks</span> <span class="mi">6</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">list</span> <span class="n">bool</span><span class="o">),</span>
  <span class="n">base64_to_char'</span> <span class="o">(</span><span class="n">nat.of_digits</span> <span class="mi">2</span> <span class="o">(</span><span class="n">c.map</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">b</span><span class="o">,</span> <span class="n">cond</span> <span class="n">b</span> <span class="mi">1</span> <span class="mi">0</span><span class="o">))))</span>

<span class="sd">/-- round tripping, list ends up padded with a `ff` prefix to have multiple-of-six length -/</span>
<span class="kd">def</span> <span class="n">bool_list_of_string</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">string</span><span class="o">)</span> <span class="o">:</span> <span class="n">list</span> <span class="n">bool</span> <span class="o">:=</span> <span class="n">list.reverse</span> <span class="bp">$</span> <span class="k">do</span>
  <span class="n">c</span> <span class="bp">←</span> <span class="n">s.to_list</span><span class="o">,</span>
  <span class="n">n</span> <span class="bp">←</span> <span class="o">(</span><span class="n">base64_of_char</span> <span class="n">c</span><span class="o">)</span><span class="bp">.</span><span class="n">to_list</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">digs</span> <span class="o">:=</span> <span class="n">nat.to_digits</span> <span class="mi">2</span> <span class="n">n</span><span class="o">,</span>
  <span class="n">d</span> <span class="bp">←</span> <span class="o">(</span><span class="n">digs</span> <span class="bp">++</span> <span class="n">list.repeat</span> <span class="mi">0</span> <span class="o">(</span><span class="mi">6</span> <span class="bp">-</span> <span class="n">digs.length</span><span class="o">)),</span>
  <span class="n">pure</span> <span class="bp">$</span> <span class="n">d</span> <span class="bp">≠</span> <span class="mi">0</span>

<span class="kd">def</span> <span class="n">string_of_tree</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">tree</span> <span class="n">unit</span><span class="o">)</span> <span class="o">:</span> <span class="n">string</span> <span class="o">:=</span>
<span class="n">string_of_bool_list</span> <span class="bp">$</span> <span class="n">to_bool_list</span> <span class="n">t</span>

<span class="kd">def</span> <span class="n">tree_of_string</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">string</span><span class="o">)</span> <span class="o">:</span> <span class="n">option</span> <span class="o">(</span><span class="n">tree</span> <span class="n">unit</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">of_bool_list</span> <span class="bp">$</span> <span class="n">bool_list_of_string</span> <span class="n">s</span>

<span class="kd">abbreviation</span> <span class="n">N</span> <span class="o">:</span> <span class="n">tree</span> <span class="n">unit</span> <span class="o">:=</span> <span class="n">tree.nil</span>
<span class="kd">abbreviation</span> <span class="n">T</span> <span class="o">:</span> <span class="n">tree</span> <span class="n">unit</span> <span class="bp">→</span> <span class="n">tree</span> <span class="n">unit</span> <span class="bp">→</span> <span class="n">tree</span> <span class="n">unit</span> <span class="o">:=</span> <span class="n">tree.node</span> <span class="o">()</span>

<span class="kd">def</span> <span class="n">t</span> <span class="o">:=</span> <span class="o">(</span><span class="n">T</span> <span class="o">(</span><span class="n">T</span> <span class="n">N</span> <span class="o">(</span><span class="n">T</span> <span class="o">(</span><span class="n">T</span> <span class="n">N</span> <span class="n">N</span><span class="o">)</span> <span class="n">N</span><span class="o">))</span> <span class="o">(</span><span class="n">T</span> <span class="n">N</span> <span class="o">(</span><span class="n">T</span> <span class="n">N</span> <span class="o">(</span><span class="n">T</span> <span class="o">(</span><span class="n">T</span> <span class="n">N</span> <span class="n">N</span><span class="o">)</span> <span class="n">N</span><span class="o">))))</span>

<span class="k">#eval</span> <span class="o">(</span><span class="n">of_bool_list</span> <span class="o">(</span><span class="n">to_bool_list</span> <span class="n">t</span><span class="o">)</span> <span class="bp">=</span> <span class="n">t</span> <span class="o">:</span> <span class="n">bool</span><span class="o">)</span>
<span class="c1">-- tt</span>
<span class="k">#eval</span> <span class="o">(</span><span class="n">tree_of_string</span> <span class="o">(</span><span class="n">string_of_tree</span> <span class="n">t</span><span class="o">)</span> <span class="bp">=</span> <span class="n">t</span> <span class="o">:</span> <span class="n">bool</span><span class="o">)</span>
<span class="c1">-- tt</span>
<span class="k">#eval</span> <span class="n">string_of_tree</span> <span class="n">t</span>
<span class="c1">-- "vwC"</span>

<span class="kd">def</span> <span class="n">t'</span> <span class="o">:=</span> <span class="o">(</span><span class="n">T</span> <span class="o">(</span><span class="n">T</span> <span class="n">t</span> <span class="n">t</span><span class="o">)</span> <span class="n">t</span><span class="o">)</span>

<span class="k">#eval</span> <span class="o">(</span><span class="n">of_bool_list</span> <span class="o">(</span><span class="n">to_bool_list</span> <span class="n">t'</span><span class="o">)</span> <span class="bp">=</span> <span class="n">t'</span> <span class="o">:</span> <span class="n">bool</span><span class="o">)</span>
<span class="c1">-- tt</span>
<span class="k">#eval</span> <span class="o">(</span><span class="n">tree_of_string</span> <span class="o">(</span><span class="n">string_of_tree</span> <span class="n">t'</span><span class="o">)</span> <span class="bp">=</span> <span class="n">t'</span> <span class="o">:</span> <span class="n">bool</span><span class="o">)</span>
<span class="c1">-- tt</span>
<span class="k">#eval</span> <span class="n">string_of_tree</span> <span class="n">t'</span>
<span class="c1">-- "fhFfhFvwC"</span>

<span class="c1">-- Ignores non-base64 content:</span>
<span class="k">#eval</span> <span class="o">(</span><span class="n">tree_of_string</span> <span class="s2">" fhF   fhF vwC"</span> <span class="bp">=</span> <span class="n">t'</span> <span class="o">:</span> <span class="n">bool</span><span class="o">)</span>
<span class="c1">-- tt</span>
</code></pre></div>
</div></div>



<a name="271722570"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tree%20notation/near/271722570" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tree.20notation.html#271722570">(Feb 13 2022 at 02:34)</a>:</h4>
<p>It seems better to have a bespoke parser for your application, but having functions in mathlib to convert numbers to and from base64 seems useful.</p>



<a name="271722581"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tree%20notation/near/271722581" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tree.20notation.html#271722581">(Feb 13 2022 at 02:35)</a>:</h4>
<p>(There was a some complexity in the implementation to help Lean see everything terminated. It runs a little stack manipulation language to build the tree from a list of bools.)</p>



<a name="271733454"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tree%20notation/near/271733454" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tree.20notation.html#271733454">(Feb 13 2022 at 07:51)</a>:</h4>
<p>If the base64 parser ignores non-base64 content, then you can just put newlines and indentation in the string if you need multiple lines (lean doesn't require single line literals). If this is for roth, you also don't need to encode the tree structure; you can just have a stream of "oracle calls" and just pull from the stream whenever you need to make a decision at any point in the tree</p>



<a name="271733524"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tree%20notation/near/271733524" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tree.20notation.html#271733524">(Feb 13 2022 at 07:52)</a>:</h4>
<p>BTW, it's nice to see us finally getting proofs that are a blob of bytes like metamath proofs :)</p>



<a name="271733895"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tree%20notation/near/271733895" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tree.20notation.html#271733895">(Feb 13 2022 at 08:01)</a>:</h4>
<p>Didn't you do this already somewhere in the Matiyasevich proof?</p>



<a name="271734033"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tree%20notation/near/271734033" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tree.20notation.html#271734033">(Feb 13 2022 at 08:04)</a>:</h4>
<p>I don't think I have, although some applications have come close</p>



<a name="271734041"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tree%20notation/near/271734041" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tree.20notation.html#271734041">(Feb 13 2022 at 08:05)</a>:</h4>
<p>the matiyasevich proof is just a whole lot of single letter variables</p>



<a name="271734056"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tree%20notation/near/271734056" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tree.20notation.html#271734056">(Feb 13 2022 at 08:05)</a>:</h4>
<p>You're probably thinking of this: <a href="https://github.com/leanprover-community/mathlib/blob/master/src/number_theory/dioph.lean#L601-L612">https://github.com/leanprover-community/mathlib/blob/master/src/number_theory/dioph.lean#L601-L612</a></p>



<a name="271734110"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tree%20notation/near/271734110" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tree.20notation.html#271734110">(Feb 13 2022 at 08:06)</a>:</h4>
<p>The bit at the beginning with a bunch of notations is more like manual typeclass inference proving that an expression is diophantine</p>



<a name="271734133"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tree%20notation/near/271734133" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tree.20notation.html#271734133">(Feb 13 2022 at 08:07)</a>:</h4>
<p>and it's not particularly "encoded" - it's a literal transcription of the input but with de bruijn variables</p>



<a name="271734258"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tree%20notation/near/271734258" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tree.20notation.html#271734258">(Feb 13 2022 at 08:10)</a>:</h4>
<p>Whenever I think I can read mathlib I always remind myself that I still never made it through that part</p>



<a name="271734944"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tree%20notation/near/271734944" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tree.20notation.html#271734944">(Feb 13 2022 at 08:31)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113488-general/topic/Tree.20notation/near/271733454">said</a>:</p>
<blockquote>
<p>you also don't need to encode the tree structure; you can just have a stream of "oracle calls" and just pull from the stream whenever you need to make a decision at any point in the tree</p>
</blockquote>
<p>But is it not easier, or at least more principled; to build the tree first and then flatten it? To be clear, I need to make decisions all the time.</p>



<a name="271735601"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tree%20notation/near/271735601" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tree.20notation.html#271735601">(Feb 13 2022 at 08:47)</a>:</h4>
<p>Very nice, Kyle! I'm thinking that what we should have is a typeclass <code>has_bytes</code> to generally declare that a given type can be encoded with <code>list bool</code> and decoded from it. Then we can have a translation between <code>list bool</code> and base64. Both seem generally useful.</p>



<a name="271735712"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tree%20notation/near/271735712" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tree.20notation.html#271735712">(Feb 13 2022 at 08:50)</a>:</h4>
<p>I really like this little "Automate away Roth calculations" project. It's getting me to learn metaprogramming!</p>



<a name="271735913"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tree%20notation/near/271735913" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tree.20notation.html#271735913">(Feb 13 2022 at 08:57)</a>:</h4>
<p><del>I think the reals biject with <code>list bool</code></del> (if you allow infinite lists)</p>



<a name="271735965"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tree%20notation/near/271735965" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tree.20notation.html#271735965">(Feb 13 2022 at 08:58)</a>:</h4>
<p>Have you ever heard of countability, Kevin? <span aria-label="grinning" class="emoji emoji-1f600" role="img" title="grinning">:grinning:</span></p>



<a name="271736092"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tree%20notation/near/271736092" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tree.20notation.html#271736092">(Feb 13 2022 at 09:01)</a>:</h4>
<p>Oh it's finite lists of course :-(</p>



<a name="271736150"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tree%20notation/near/271736150" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tree.20notation.html#271736150">(Feb 13 2022 at 09:02)</a>:</h4>
<p>So isn't this just <code>denumerable</code> then??</p>



<a name="271736163"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tree%20notation/near/271736163" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tree.20notation.html#271736163">(Feb 13 2022 at 09:03)</a>:</h4>
<p>No -- I mean <a href="https://leanprover-community.github.io/mathlib_docs/find/encodable">docs#encodable</a></p>



<a name="271736252"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tree%20notation/near/271736252" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tree.20notation.html#271736252">(Feb 13 2022 at 09:05)</a>:</h4>
<p>And then you just biject list bool with nat (it bijects very naturally with pnat: regard ff as 0 and tt as 1, stick a 1 in front and you have a binary natural). Hopefully I'm getting the hang of this exotic <code>list</code> type now</p>



<a name="271736331"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tree%20notation/near/271736331" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tree.20notation.html#271736331">(Feb 13 2022 at 09:07)</a>:</h4>
<p>It is, yeah, except that we pick <code>list bool</code> as the encding state. Don't know if that matters too much for performance. That was my reasoning.</p>



<a name="271739504"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tree%20notation/near/271739504" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tree.20notation.html#271739504">(Feb 13 2022 at 10:35)</a>:</h4>
<blockquote>
<ul>
<li><code>dioph</code>: a predicate stating that a set <code>S ⊆ ℕ^α</code> is Diophantine, i.e. that</li>
</ul>
</blockquote>
<p>Alright, keep your secrets</p>



<a name="271739713"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tree%20notation/near/271739713" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tree.20notation.html#271739713">(Feb 13 2022 at 10:40)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/113488-general/topic/Tree.20notation/near/271739504">said</a>:</p>
<blockquote>
<blockquote>
<ul>
<li><code>dioph</code>: a predicate stating that a set <code>S ⊆ ℕ^α</code> is Diophantine, i.e. that</li>
</ul>
</blockquote>
<p>Alright, keep your secrets</p>
</blockquote>
<p><a href="https://github.com/leanprover-community/mathlib/pull/12011">#12011</a></p>



<a name="271742439"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tree%20notation/near/271742439" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tree.20notation.html#271742439">(Feb 13 2022 at 11:54)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113488-general/topic/Tree.20notation/near/271733454">said</a>:</p>
<blockquote>
<p>If the base64 parser ignores non-base64 content, then you can just put newlines and indentation in the string if you need multiple lines (lean doesn't require single line literals).</p>
</blockquote>
<p>Good idea -- the one I wrote already does <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span> Though I did that without fully realizing Lean strings allow raw newlines.</p>



<a name="271743211"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tree%20notation/near/271743211" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tree.20notation.html#271743211">(Feb 13 2022 at 12:12)</a>:</h4>
<p><span class="user-mention silent" data-user-id="387244">Yaël Dillies</span> <a href="#narrow/stream/113488-general/topic/Tree.20notation/near/271735601">said</a>:</p>
<blockquote>
<p>I'm thinking that what we should have is a typeclass <code>has_bytes</code> to generally declare that a given type can be encoded with <code>list bool</code> and decoded from it. Then we can have a translation between <code>list bool</code> and base64. Both seem generally useful.</p>
</blockquote>
<p>I know you like exploring rabbitholes, but this is a surprisingly deep one and I worry you might never return. <span aria-label="wink" class="emoji emoji-1f609" role="img" title="wink">:wink:</span></p>
<p>To make a serialization system that's robust, you would probably want a system that encodes a version into binary blob so that if you ever want to make changes to the interface later, you don't have to go and re-encode all your blobs, for example. If you don't have a generic system, then what you can do instead is create new decoding functions when you have new versions, and the choice of decoding function in the source code serves as the version indicator.</p>
<p>If embedding base64 certificates in proofs becomes more prevalent, then we'd have a better idea of what properties we'd want from serialization, and it might be worth having something more generic. But until then, I'd say it's additional work that shouldn't be done. (Even though I see why it would be useful.)</p>



<a name="271743374"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tree%20notation/near/271743374" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tree.20notation.html#271743374">(Feb 13 2022 at 12:16)</a>:</h4>
<p>There was a trick in the base64 encoder for trees, by the way. It rounds  the <code>list bool</code> up to the nearest multiple-of-six length, since base64 is a sequence of 6-bit numbers. I was relying on the fact that <code>ff</code> is interpreted in <code>of_bool_list_aux</code> as "push <code>tree.nil</code> onto the stack" and that at the end of evaluation, the function returns the top of stack. That means it can serve as a no-operation if it's at the beginning of the list.</p>
<p>The base64 encoder could deal with arbitrary <code>list bool</code>, though, by having it encode at the beginning how many bits to drop, using 3 additional bits to do so.</p>



<a name="271743588"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tree%20notation/near/271743588" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tree.20notation.html#271743588">(Feb 13 2022 at 12:22)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113488-general/topic/Tree.20notation/near/271736252">said</a>:</p>
<blockquote>
<p>And then you just biject list bool with nat (it bijects very naturally with pnat: regard ff as 0 and tt as 1, stick a 1 in front and you have a binary natural). Hopefully I'm getting the hang of this exotic <code>list</code> type now</p>
</blockquote>
<p>The first thing I tried was using <a href="https://leanprover-community.github.io/mathlib_docs/find/encodable">docs#encodable</a> for <code>list bool</code>, but the naturals it produced were hilariously large for the application.</p>
<p>The encoding scheme you mentioned would work, though. For these trees, you could skip having that 1 in front, actually, if you have the beginning of the list be the least-significant digits, because, incidentally, the <code>list bool -&gt; tree unit</code> decoder can handle an arbitrary number of <code>ff</code> appended to the end.</p>



<a name="271743621"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tree%20notation/near/271743621" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tree.20notation.html#271743621">(Feb 13 2022 at 12:22)</a>:</h4>
<p>I'm afraid the only way to preserve me from a rabbithole is to fill it up yourself <span aria-label="grinning" class="emoji emoji-1f600" role="img" title="grinning">:grinning:</span></p>



<a name="271743701"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tree%20notation/near/271743701" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tree.20notation.html#271743701">(Feb 13 2022 at 12:25)</a>:</h4>
<p>What about we merge the correctness proof of the algorithm now and worry about making it effective later? (<a href="https://github.com/leanprover-community/mathlib/pull/10645">#10645</a> for reference)</p>



<a name="271745571"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tree%20notation/near/271745571" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tree.20notation.html#271745571">(Feb 13 2022 at 13:14)</a>:</h4>
<p><span class="user-mention silent" data-user-id="387244">Yaël Dillies</span> <a href="#narrow/stream/113488-general/topic/Tree.20notation/near/271736331">said</a>:</p>
<blockquote>
<p>we pick <code>list bool</code> as the encoding state. Don't know if that matters too much for performance.</p>
</blockquote>
<p>I mainly used <code>list bool</code> so that there'd be something to recurse on in <code>of_bool_list_aux</code>, but also it turns out <code>nat.to_digits</code> is very slow.</p>
<p>With a faster <code>nat.to_digits</code>, we can make reasonably efficient <code>nat.to_base64</code> and <code>nat.from_base64</code> functions.</p>
<p>Here's a simpler implementation than before using these functions:</p>
<div class="spoiler-block"><div class="spoiler-header">
<p>tree &lt;-&gt; string via nat</p>
</div><div class="spoiler-content" aria-hidden="true">
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">data.tree</span>
<span class="kn">import</span> <span class="n">data.nat.digits</span>
<span class="kn">import</span> <span class="n">tactic.slim_check</span>

<span class="c1">--def base64_chars : string :=</span>
<span class="c1">--"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"</span>

<span class="kd">def</span> <span class="n">base64_to_char</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="mi">64</span><span class="o">)</span> <span class="o">:</span> <span class="n">char</span> <span class="o">:=</span>
<span class="k">if</span> <span class="n">h1</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="mi">26</span> <span class="k">then</span> <span class="n">char.of_nat</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">65</span><span class="o">)</span>
<span class="k">else</span> <span class="k">if</span> <span class="n">h2</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="mi">52</span> <span class="k">then</span> <span class="n">char.of_nat</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">71</span><span class="o">)</span>
<span class="k">else</span> <span class="k">if</span> <span class="n">h3</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="mi">62</span> <span class="k">then</span> <span class="n">char.of_nat</span> <span class="o">(</span><span class="n">n</span> <span class="bp">-</span> <span class="mi">4</span><span class="o">)</span>
<span class="k">else</span> <span class="k">if</span> <span class="n">h4</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">62</span> <span class="k">then</span> <span class="sc">'+'</span>
<span class="k">else</span> <span class="k">if</span> <span class="n">h5</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">63</span> <span class="k">then</span> <span class="sc">'/'</span>
<span class="k">else</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">exfalso</span><span class="o">,</span> <span class="n">simp</span> <span class="n">at</span> <span class="n">h3</span><span class="o">,</span> <span class="n">interval_cases</span> <span class="n">n</span><span class="bp">;</span> <span class="n">trivial</span><span class="o">,</span> <span class="o">}</span>

<span class="kd">def</span> <span class="n">base64_to_char'</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">char</span> <span class="o">:=</span>
<span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="mi">64</span> <span class="k">then</span> <span class="n">base64_to_char</span> <span class="n">n</span> <span class="n">h</span> <span class="k">else</span> <span class="sc">'A'</span>

<span class="kd">def</span> <span class="n">base64_of_char</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">char</span><span class="o">)</span> <span class="o">:</span> <span class="n">option</span> <span class="n">ℕ</span> <span class="o">:=</span>
<span class="k">let</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">char.to_nat</span> <span class="n">c</span> <span class="k">in</span>
<span class="k">if</span> <span class="mi">65</span> <span class="bp">&lt;=</span> <span class="n">n</span> <span class="bp">∧</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="mi">91</span> <span class="k">then</span> <span class="n">some</span> <span class="o">(</span><span class="n">n</span> <span class="bp">-</span> <span class="mi">65</span><span class="o">)</span>
<span class="k">else</span> <span class="k">if</span> <span class="mi">97</span> <span class="bp">&lt;=</span> <span class="n">n</span> <span class="bp">∧</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="mi">123</span> <span class="k">then</span> <span class="n">some</span> <span class="o">(</span><span class="n">n</span> <span class="bp">-</span> <span class="mi">71</span><span class="o">)</span>
<span class="k">else</span> <span class="k">if</span> <span class="mi">48</span> <span class="bp">&lt;=</span> <span class="n">n</span> <span class="bp">∧</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="mi">58</span> <span class="k">then</span> <span class="n">some</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">4</span><span class="o">)</span>
<span class="k">else</span> <span class="k">if</span> <span class="n">c</span> <span class="bp">=</span> <span class="sc">'+'</span> <span class="k">then</span> <span class="n">some</span> <span class="mi">62</span>
<span class="k">else</span> <span class="k">if</span> <span class="n">c</span> <span class="bp">=</span> <span class="sc">'/'</span> <span class="k">then</span> <span class="n">some</span> <span class="mi">63</span>
<span class="k">else</span> <span class="n">none</span>

<span class="c1">--example (n : ℕ) (h : n &lt; 64) : base64_of_char (base64_to_char n h) = n := by dec_trivial!</span>
<span class="c1">--example (n : ℕ) (h : n &lt; 64) : base64_of_char (base64_to_char' n) = n := by dec_trivial!</span>

<span class="sd">/-- *much* faster than `nat.to_digits`. -/</span>
<span class="kd">def</span> <span class="n">nat.to_digits'</span> <span class="o">(</span><span class="n">base</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="mi">2</span> <span class="bp">≤</span> <span class="n">base</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">ℕ</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="o">[]</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span>
  <span class="k">have</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">/</span> <span class="n">base</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">,</span> <span class="k">from</span> <span class="n">nat.div_lt_self</span> <span class="n">n.succ_pos</span> <span class="o">(</span><span class="n">nat.succ_le_iff.mp</span> <span class="n">h</span><span class="o">),</span>
  <span class="o">((</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">%</span> <span class="n">base</span><span class="o">)</span> <span class="o">::</span> <span class="n">nat.to_digits'</span> <span class="o">((</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">/</span> <span class="n">base</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">nat.to_base64</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">string</span> <span class="o">:=</span>
<span class="n">list.as_string</span> <span class="bp">$</span> <span class="o">(</span><span class="n">nat.to_digits'</span> <span class="mi">64</span> <span class="o">(</span><span class="kd">by</span> <span class="n">norm_num</span><span class="o">)</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="n">base64_to_char'</span>

<span class="kd">def</span> <span class="n">nat.from_base64</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">string</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">:=</span>
<span class="n">nat.of_digits</span> <span class="mi">64</span> <span class="o">(</span><span class="n">s.to_list</span> <span class="bp">&gt;&gt;=</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">c</span><span class="o">,</span> <span class="o">(</span><span class="n">base64_of_char</span> <span class="n">c</span><span class="o">)</span><span class="bp">.</span><span class="n">to_list</span><span class="o">))</span>

<span class="c1">--example (n : ℕ) : nat.from_base64 (nat.to_base64 n) = n := by slim_check</span>

<span class="kd">def</span> <span class="n">to_nat_aux</span> <span class="o">:</span> <span class="n">tree</span> <span class="n">unit</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span>
<span class="bp">|</span> <span class="n">tree.nil</span> <span class="n">acc</span> <span class="o">:=</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">acc</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">tree.node</span> <span class="n">_</span> <span class="n">l</span> <span class="n">r</span><span class="o">)</span> <span class="n">acc</span> <span class="o">:=</span> <span class="n">to_nat_aux</span> <span class="n">l</span> <span class="o">(</span><span class="n">to_nat_aux</span> <span class="n">r</span> <span class="o">(</span><span class="mi">1</span> <span class="bp">+</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">acc</span><span class="o">))</span>

<span class="kd">def</span> <span class="n">to_nat</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">tree</span> <span class="n">unit</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="n">to_nat_aux</span> <span class="n">t</span> <span class="mi">0</span>

<span class="kd">def</span> <span class="n">of_nat_aux_pop2</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">tree</span> <span class="n">unit</span><span class="o">)</span> <span class="bp">→</span> <span class="n">tree</span> <span class="n">unit</span> <span class="bp">×</span> <span class="n">tree</span> <span class="n">unit</span> <span class="bp">×</span> <span class="n">list</span> <span class="o">(</span><span class="n">tree</span> <span class="n">unit</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="o">:=</span> <span class="o">(</span><span class="n">tree.nil</span><span class="o">,</span> <span class="n">tree.nil</span><span class="o">,</span> <span class="o">[])</span>
<span class="bp">|</span> <span class="o">[</span><span class="n">t</span><span class="o">]</span> <span class="o">:=</span> <span class="o">(</span><span class="n">t</span><span class="o">,</span> <span class="n">tree.nil</span><span class="o">,</span> <span class="o">[])</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">t</span> <span class="o">::</span> <span class="n">t'</span> <span class="o">::</span> <span class="n">ts</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">t</span><span class="o">,</span> <span class="n">t'</span><span class="o">,</span> <span class="n">ts</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">of_nat_aux</span> <span class="o">:</span> <span class="n">list</span> <span class="n">bool</span> <span class="bp">→</span> <span class="n">list</span> <span class="o">(</span><span class="n">tree</span> <span class="n">unit</span><span class="o">)</span> <span class="bp">→</span> <span class="n">tree</span> <span class="n">unit</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="o">[]</span> <span class="o">:=</span> <span class="n">tree.nil</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="o">(</span><span class="n">t</span> <span class="o">::</span> <span class="n">_</span><span class="o">)</span> <span class="o">:=</span> <span class="n">t</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">ff</span> <span class="o">::</span> <span class="n">xs</span><span class="o">)</span> <span class="n">stack</span> <span class="o">:=</span> <span class="n">of_nat_aux</span> <span class="n">xs</span> <span class="o">(</span><span class="n">tree.nil</span> <span class="o">::</span> <span class="n">stack</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">tt</span> <span class="o">::</span> <span class="n">xs</span><span class="o">)</span> <span class="n">stack</span> <span class="o">:=</span>
  <span class="k">let</span> <span class="o">(</span><span class="n">r</span><span class="o">,</span> <span class="n">l</span><span class="o">,</span> <span class="n">stack</span><span class="o">)</span> <span class="o">:=</span> <span class="n">of_nat_aux_pop2</span> <span class="n">stack</span>
  <span class="k">in</span> <span class="n">of_nat_aux</span> <span class="n">xs</span> <span class="o">(</span><span class="n">tree.node</span> <span class="o">()</span> <span class="n">l</span> <span class="n">r</span> <span class="o">::</span> <span class="n">stack</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">string_of_tree</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">tree</span> <span class="n">unit</span><span class="o">)</span> <span class="o">:</span> <span class="n">string</span> <span class="o">:=</span> <span class="n">nat.to_base64</span> <span class="bp">$</span> <span class="n">to_nat</span> <span class="n">t</span>

<span class="kd">def</span> <span class="n">tree_of_string</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">string</span><span class="o">)</span> <span class="o">:</span> <span class="n">tree</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="n">of_nat_aux</span> <span class="o">(</span><span class="n">list.map</span> <span class="o">(</span><span class="bp">≠</span> <span class="mi">0</span><span class="o">)</span> <span class="bp">$</span> <span class="n">nat.to_digits'</span> <span class="mi">2</span> <span class="n">rfl.ge</span> <span class="o">(</span><span class="n">nat.from_base64</span> <span class="n">s</span><span class="o">))</span> <span class="o">[]</span>

<span class="c">/-</span><span class="cm">! ## Examples -/</span>

<span class="kd">abbreviation</span> <span class="n">N</span> <span class="o">:</span> <span class="n">tree</span> <span class="n">unit</span> <span class="o">:=</span> <span class="n">tree.nil</span>
<span class="kd">abbreviation</span> <span class="n">T</span> <span class="o">:</span> <span class="n">tree</span> <span class="n">unit</span> <span class="bp">→</span> <span class="n">tree</span> <span class="n">unit</span> <span class="bp">→</span> <span class="n">tree</span> <span class="n">unit</span> <span class="o">:=</span> <span class="n">tree.node</span> <span class="o">()</span>

<span class="kd">def</span> <span class="n">t</span> <span class="o">:=</span> <span class="o">(</span><span class="n">T</span> <span class="o">(</span><span class="n">T</span> <span class="n">N</span> <span class="o">(</span><span class="n">T</span> <span class="o">(</span><span class="n">T</span> <span class="n">N</span> <span class="n">N</span><span class="o">)</span> <span class="n">N</span><span class="o">))</span> <span class="o">(</span><span class="n">T</span> <span class="n">N</span> <span class="o">(</span><span class="n">T</span> <span class="n">N</span> <span class="o">(</span><span class="n">T</span> <span class="o">(</span><span class="n">T</span> <span class="n">N</span> <span class="n">N</span><span class="o">)</span> <span class="n">N</span><span class="o">))))</span>
<span class="c1">--def t := T N N</span>

<span class="k">#eval</span> <span class="o">(</span><span class="n">tree_of_string</span> <span class="o">(</span><span class="n">string_of_tree</span> <span class="n">t</span><span class="o">)</span> <span class="bp">=</span> <span class="n">t</span> <span class="o">:</span> <span class="n">bool</span><span class="o">)</span>
<span class="c1">-- tt</span>
<span class="k">#eval</span> <span class="n">string_of_tree</span> <span class="n">t</span>
<span class="c1">-- "ohe"</span>

<span class="kd">def</span> <span class="n">t'</span> <span class="o">:=</span> <span class="o">(</span><span class="n">T</span> <span class="o">(</span><span class="n">T</span> <span class="n">t</span> <span class="n">t</span><span class="o">)</span> <span class="n">t</span><span class="o">)</span>

<span class="k">#eval</span> <span class="o">(</span><span class="n">tree_of_string</span> <span class="o">(</span><span class="n">string_of_tree</span> <span class="n">t'</span><span class="o">)</span> <span class="bp">=</span> <span class="n">t'</span> <span class="o">:</span> <span class="n">bool</span><span class="o">)</span>
<span class="c1">-- tt</span>
<span class="k">#eval</span> <span class="n">string_of_tree</span> <span class="n">t'</span>
<span class="c1">-- "ohe0Qf0Qf"</span>

<span class="k">#eval</span> <span class="n">string_of_tree</span> <span class="n">tree.nil</span>
<span class="c1">-- ""</span>

<span class="c1">-- Ignores non-base64 content:</span>
<span class="k">#eval</span> <span class="o">(</span><span class="n">tree_of_string</span> <span class="s2">"  ohe 0Qf  0Q f "</span> <span class="bp">=</span> <span class="n">t'</span> <span class="o">:</span> <span class="n">bool</span><span class="o">)</span>
<span class="c1">-- tt</span>
</code></pre></div>
</div></div>



<a name="271749653"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tree%20notation/near/271749653" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tree.20notation.html#271749653">(Feb 13 2022 at 14:52)</a>:</h4>
<p>Ah! I would suggest using parsers for base64_of_char! <a href="https://leanprover-community.github.io/mathlib_docs/find/parser.numeral">docs#parser.numeral</a></p>



<a name="271749666"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tree%20notation/near/271749666" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tree.20notation.html#271749666">(Feb 13 2022 at 14:53)</a>:</h4>
<p>We can write a hex one and a base64 also.</p>



<a name="271765973"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tree%20notation/near/271765973" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tree.20notation.html#271765973">(Feb 13 2022 at 21:17)</a>:</h4>
<p>I want to point out that typeclasses like <code>has_bytes</code> and non-<code>meta</code> code is unnecessary here (again, assuming this is for roth). The main thing you need is:</p>
<ul>
<li>A type <code>bitstream</code></li>
<li>function <code>read_bit : state bitstream bool</code> which peels off one bit from the stream</li>
<li><code>bitstream.mk : string -&gt; bitstream</code> which initializes a bitstream from a base64 string (the stream is self-closing so it is okay to have trailing 0's)</li>
<li>(optional) a general typeclass implementing <code>read : state bitstream A</code> by calling <code>read_bit</code> several times, until you have enough entropy to reconstitute the type. This is basically a deserializer</li>
</ul>



<a name="271765989"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tree%20notation/near/271765989" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tree.20notation.html#271765989">(Feb 13 2022 at 21:17)</a>:</h4>
<p>For Roth, I think the actual data you want to encode is <code>bool</code>, so you don't need the typeclass</p>



<a name="271766058"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tree%20notation/near/271766058" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tree.20notation.html#271766058">(Feb 13 2022 at 21:19)</a>:</h4>
<p>For constructing these streams we also need a utility to produce the stream and turn it into a string literal that can be pasted into the code</p>



<a name="271766070"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tree%20notation/near/271766070" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tree.20notation.html#271766070">(Feb 13 2022 at 21:19)</a>:</h4>
<p>but that would only be used during authoring, it wouldn't be run normally</p>



<a name="271766553"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tree%20notation/near/271766553" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tree.20notation.html#271766553">(Feb 13 2022 at 21:30)</a>:</h4>
<p><code>bitstream = list bool</code> or do you have something else in mind? Kyle mentioned that doing arithmetic on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">N</mi></mrow><annotation encoding="application/x-tex">\N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">N</span></span></span></span> might be the fastest because it has special support in the kernel.</p>



<a name="271766899"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tree%20notation/near/271766899" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tree.20notation.html#271766899">(Feb 13 2022 at 21:38)</a>:</h4>
<p>It seems compelling having <code>abbreviation entropy := nat</code> and then having <code>rand_nat (hi : nat) : state entropy nat</code> to get a number in the range <code>[0,hi)</code> when <code>hi</code> is positive (defined by returning <code>s % hi</code> and replacing the current state <code>s</code> with <code>s / hi</code>). (Maybe not using randomness terminology)</p>



<a name="271767844"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tree%20notation/near/271767844" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tree.20notation.html#271767844">(Feb 13 2022 at 22:01)</a>:</h4>
<p>(An example for (de)serializing trees.)</p>
<div class="spoiler-block"><div class="spoiler-header">
<p>now with monads</p>
</div><div class="spoiler-content" aria-hidden="true">
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">data.tree</span>
<span class="kn">import</span> <span class="n">data.nat.digits</span>
<span class="kn">import</span> <span class="n">tactic.slim_check</span>

<span class="c1">--def base64_chars : string :=</span>
<span class="c1">--"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"</span>

<span class="kd">def</span> <span class="n">base64_to_char</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="mi">64</span><span class="o">)</span> <span class="o">:</span> <span class="n">char</span> <span class="o">:=</span>
<span class="k">if</span> <span class="n">h1</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="mi">26</span> <span class="k">then</span> <span class="n">char.of_nat</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">65</span><span class="o">)</span>
<span class="k">else</span> <span class="k">if</span> <span class="n">h2</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="mi">52</span> <span class="k">then</span> <span class="n">char.of_nat</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">71</span><span class="o">)</span>
<span class="k">else</span> <span class="k">if</span> <span class="n">h3</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="mi">62</span> <span class="k">then</span> <span class="n">char.of_nat</span> <span class="o">(</span><span class="n">n</span> <span class="bp">-</span> <span class="mi">4</span><span class="o">)</span>
<span class="k">else</span> <span class="k">if</span> <span class="n">h4</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">62</span> <span class="k">then</span> <span class="sc">'+'</span>
<span class="k">else</span> <span class="k">if</span> <span class="n">h5</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">63</span> <span class="k">then</span> <span class="sc">'/'</span>
<span class="k">else</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">exfalso</span><span class="o">,</span> <span class="n">simp</span> <span class="n">at</span> <span class="n">h3</span><span class="o">,</span> <span class="n">interval_cases</span> <span class="n">n</span><span class="bp">;</span> <span class="n">trivial</span><span class="o">,</span> <span class="o">}</span>

<span class="kd">def</span> <span class="n">base64_to_char'</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">char</span> <span class="o">:=</span>
<span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="mi">64</span> <span class="k">then</span> <span class="n">base64_to_char</span> <span class="n">n</span> <span class="n">h</span> <span class="k">else</span> <span class="sc">'A'</span>

<span class="kd">def</span> <span class="n">base64_of_char</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">char</span><span class="o">)</span> <span class="o">:</span> <span class="n">option</span> <span class="n">ℕ</span> <span class="o">:=</span>
<span class="k">let</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">char.to_nat</span> <span class="n">c</span> <span class="k">in</span>
<span class="k">if</span> <span class="mi">65</span> <span class="bp">&lt;=</span> <span class="n">n</span> <span class="bp">∧</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="mi">91</span> <span class="k">then</span> <span class="n">some</span> <span class="o">(</span><span class="n">n</span> <span class="bp">-</span> <span class="mi">65</span><span class="o">)</span>
<span class="k">else</span> <span class="k">if</span> <span class="mi">97</span> <span class="bp">&lt;=</span> <span class="n">n</span> <span class="bp">∧</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="mi">123</span> <span class="k">then</span> <span class="n">some</span> <span class="o">(</span><span class="n">n</span> <span class="bp">-</span> <span class="mi">71</span><span class="o">)</span>
<span class="k">else</span> <span class="k">if</span> <span class="mi">48</span> <span class="bp">&lt;=</span> <span class="n">n</span> <span class="bp">∧</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="mi">58</span> <span class="k">then</span> <span class="n">some</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">4</span><span class="o">)</span>
<span class="k">else</span> <span class="k">if</span> <span class="n">c</span> <span class="bp">=</span> <span class="sc">'+'</span> <span class="k">then</span> <span class="n">some</span> <span class="mi">62</span>
<span class="k">else</span> <span class="k">if</span> <span class="n">c</span> <span class="bp">=</span> <span class="sc">'/'</span> <span class="k">then</span> <span class="n">some</span> <span class="mi">63</span>
<span class="k">else</span> <span class="n">none</span>

<span class="c1">--example (n : ℕ) (h : n &lt; 64) : base64_of_char (base64_to_char n h) = n := by dec_trivial!</span>
<span class="c1">--example (n : ℕ) (h : n &lt; 64) : base64_of_char (base64_to_char' n) = n := by dec_trivial!</span>

<span class="kd">def</span> <span class="n">nat.to_base64</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">string</span> <span class="o">:=</span>
<span class="n">list.as_string</span> <span class="bp">$</span> <span class="o">(</span><span class="n">nat.digits</span> <span class="mi">64</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="n">base64_to_char'</span>

<span class="kd">def</span> <span class="n">nat.from_base64</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">string</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">:=</span>
<span class="n">nat.of_digits</span> <span class="mi">64</span> <span class="o">(</span><span class="n">s.to_list</span> <span class="bp">&gt;&gt;=</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">c</span><span class="o">,</span> <span class="o">(</span><span class="n">base64_of_char</span> <span class="n">c</span><span class="o">)</span><span class="bp">.</span><span class="n">to_list</span><span class="o">))</span>

<span class="c1">--example (n : ℕ) : nat.from_base64 (nat.to_base64 n) = n := by slim_check</span>

<span class="c">/-</span><span class="cm">! ## nondeterminism certificate monad -/</span>

<span class="kd">abbreviation</span> <span class="n">entropy</span> <span class="o">:=</span> <span class="n">ℕ</span>
<span class="kd">abbreviation</span> <span class="n">rands</span> <span class="o">:=</span> <span class="n">state</span> <span class="n">entropy</span>

<span class="sd">/-- should have `i &lt; n` -/</span>
<span class="kd">def</span> <span class="n">push_rand</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">rands</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="n">state_t.modify</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">e</span><span class="o">,</span> <span class="n">i</span> <span class="bp">+</span> <span class="n">e</span> <span class="bp">*</span> <span class="n">n</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">seed_base64</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">string</span><span class="o">)</span> <span class="o">:</span> <span class="n">rands</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="n">state_t.put</span> <span class="o">(</span><span class="n">nat.from_base64</span> <span class="n">s</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">get_rand</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">rands</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="k">do</span>
  <span class="n">e</span> <span class="bp">←</span> <span class="n">state_t.get</span><span class="o">,</span>
  <span class="n">state_t.put</span> <span class="o">(</span><span class="n">e</span> <span class="bp">/</span> <span class="n">n</span><span class="o">),</span>
  <span class="n">pure</span> <span class="o">(</span><span class="n">e</span> <span class="bp">%</span> <span class="n">n</span><span class="o">)</span>

<span class="c">/-</span><span class="cm">! ## Trees -/</span>

<span class="kd">def</span> <span class="n">to_nat_aux</span> <span class="o">:</span> <span class="n">tree</span> <span class="n">unit</span> <span class="bp">→</span> <span class="n">rands</span> <span class="n">unit</span>
<span class="bp">|</span> <span class="n">tree.nil</span> <span class="o">:=</span> <span class="n">push_rand</span> <span class="mi">0</span> <span class="mi">2</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">tree.node</span> <span class="n">_</span> <span class="n">l</span> <span class="n">r</span><span class="o">)</span> <span class="o">:=</span> <span class="k">do</span>
  <span class="n">to_nat_aux</span> <span class="n">r</span><span class="o">,</span>
  <span class="n">to_nat_aux</span> <span class="n">l</span><span class="o">,</span>
  <span class="n">push_rand</span> <span class="mi">1</span> <span class="mi">2</span>

<span class="kd">def</span> <span class="n">to_nat</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">tree</span> <span class="n">unit</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="o">(</span><span class="n">state_t.run</span> <span class="o">(</span><span class="n">to_nat_aux</span> <span class="n">t</span><span class="o">)</span> <span class="mi">0</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">of_nat_aux</span> <span class="o">:</span> <span class="n">rands</span> <span class="o">(</span><span class="n">tree</span> <span class="n">unit</span><span class="o">)</span> <span class="o">:=</span> <span class="k">do</span>
  <span class="n">b</span> <span class="bp">←</span> <span class="n">get_rand</span> <span class="mi">2</span><span class="o">,</span>
  <span class="k">if</span> <span class="n">b</span> <span class="bp">=</span> <span class="mi">0</span> <span class="k">then</span>
    <span class="n">pure</span> <span class="n">tree.nil</span>
  <span class="k">else</span> <span class="k">do</span>
    <span class="n">l</span> <span class="bp">←</span> <span class="n">of_nat_aux</span><span class="o">,</span>
    <span class="n">r</span> <span class="bp">←</span> <span class="n">of_nat_aux</span><span class="o">,</span>
    <span class="n">pure</span> <span class="bp">$</span> <span class="n">tree.node</span> <span class="o">()</span> <span class="n">l</span> <span class="n">r</span>

<span class="kd">def</span> <span class="n">string_of_tree</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">tree</span> <span class="n">unit</span><span class="o">)</span> <span class="o">:</span> <span class="n">string</span> <span class="o">:=</span> <span class="n">nat.to_base64</span> <span class="bp">$</span> <span class="n">to_nat</span> <span class="n">t</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">tree_of_string</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">string</span><span class="o">)</span> <span class="o">:</span> <span class="n">tree</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">state_t.run</span> <span class="o">(</span><span class="k">do</span> <span class="n">seed_base64</span> <span class="n">s</span><span class="o">,</span> <span class="n">of_nat_aux</span><span class="o">)</span> <span class="mi">0</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">print_string_of_tree</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">tree</span> <span class="n">unit</span><span class="o">)</span> <span class="o">(</span><span class="n">size</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="mi">80</span><span class="o">)</span> <span class="o">:</span> <span class="n">io</span> <span class="n">unit</span> <span class="o">:=</span> <span class="k">do</span>
  <span class="n">io.put_str</span> <span class="s2">"tree_of_string </span><span class="se">\"</span><span class="s2">"</span><span class="o">,</span>
  <span class="n">io.put_str</span> <span class="bp">$</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">"</span><span class="bp">.</span><span class="n">intercalate</span> <span class="o">((</span><span class="n">string_of_tree</span> <span class="n">t</span><span class="o">)</span><span class="bp">.</span><span class="n">to_chunks</span> <span class="n">size</span> <span class="o">[]),</span>
  <span class="n">io.put_str</span> <span class="s2">"</span><span class="se">\"</span><span class="s2">"</span>

<span class="c">/-</span><span class="cm">! ## Examples -/</span>

<span class="kd">abbreviation</span> <span class="n">N</span> <span class="o">:</span> <span class="n">tree</span> <span class="n">unit</span> <span class="o">:=</span> <span class="n">tree.nil</span>
<span class="kd">abbreviation</span> <span class="n">T</span> <span class="o">:</span> <span class="n">tree</span> <span class="n">unit</span> <span class="bp">→</span> <span class="n">tree</span> <span class="n">unit</span> <span class="bp">→</span> <span class="n">tree</span> <span class="n">unit</span> <span class="o">:=</span> <span class="n">tree.node</span> <span class="o">()</span>

<span class="kd">def</span> <span class="n">t</span> <span class="o">:=</span> <span class="o">(</span><span class="n">T</span> <span class="o">(</span><span class="n">T</span> <span class="n">N</span> <span class="o">(</span><span class="n">T</span> <span class="o">(</span><span class="n">T</span> <span class="n">N</span> <span class="n">N</span><span class="o">)</span> <span class="n">N</span><span class="o">))</span> <span class="o">(</span><span class="n">T</span> <span class="n">N</span> <span class="o">(</span><span class="n">T</span> <span class="n">N</span> <span class="o">(</span><span class="n">T</span> <span class="o">(</span><span class="n">T</span> <span class="n">N</span> <span class="n">N</span><span class="o">)</span> <span class="n">N</span><span class="o">))))</span>
<span class="c1">--def t := T N N</span>

<span class="k">#eval</span> <span class="o">(</span><span class="n">tree_of_string</span> <span class="o">(</span><span class="n">string_of_tree</span> <span class="n">t</span><span class="o">)</span> <span class="bp">=</span> <span class="n">t</span> <span class="o">:</span> <span class="n">bool</span><span class="o">)</span>
<span class="c1">-- tt</span>
<span class="k">#eval</span> <span class="n">string_of_tree</span> <span class="n">t</span>
<span class="c1">-- "bUD"</span>

<span class="kd">def</span> <span class="n">t'</span> <span class="o">:=</span> <span class="o">(</span><span class="n">T</span> <span class="o">(</span><span class="n">T</span> <span class="n">t</span> <span class="n">t</span><span class="o">)</span> <span class="n">t</span><span class="o">)</span>

<span class="k">#eval</span> <span class="o">(</span><span class="n">tree_of_string</span> <span class="o">(</span><span class="n">string_of_tree</span> <span class="n">t'</span><span class="o">)</span> <span class="bp">=</span> <span class="n">t'</span> <span class="o">:</span> <span class="n">bool</span><span class="o">)</span>
<span class="c1">-- tt</span>
<span class="k">#eval</span> <span class="n">string_of_tree</span> <span class="n">t'</span>
<span class="c1">-- "vRN2oGbUD"</span>

<span class="k">#eval</span> <span class="n">string_of_tree</span> <span class="n">tree.nil</span>
<span class="c1">-- ""</span>

<span class="k">#eval</span> <span class="n">tree_of_string</span> <span class="s2">""</span>
<span class="c1">-- tree.nil</span>

<span class="c1">-- Ignores non-base64 content:</span>
<span class="k">#eval</span> <span class="o">(</span><span class="n">tree_of_string</span> <span class="s2">"  vRN2  oG bUD "</span> <span class="bp">=</span> <span class="n">t'</span> <span class="o">:</span> <span class="n">bool</span><span class="o">)</span>
<span class="c1">-- tt</span>

<span class="kd">def</span> <span class="n">bt</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">tree</span> <span class="n">unit</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">tree.nil</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">tree.node</span> <span class="o">()</span> <span class="o">(</span><span class="n">bt</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">bt</span> <span class="n">n</span><span class="o">)</span>

<span class="k">#eval</span> <span class="n">print_string_of_tree</span> <span class="o">(</span><span class="n">bt</span> <span class="mi">12</span><span class="o">)</span>

<span class="k">#eval</span> <span class="o">(</span><span class="n">tree_of_string</span> <span class="s2">"//kJn</span>
<span class="s2">M5JTOZynM5kJPZyJT+JTOZyTmcykPZyJTeykTm8nM5kJPZyJT+kJnM5JTOZyPZyJTeykTm8JTOZyTmcy</span>
<span class="s2">k/JTOZyTmcykPZyJTeykTm8TmcyknM5kJfykTm8kJnM5PZyJTeykTm8JTOZyTmcykfykTm8kJnM5Tmcy</span>
<span class="s2">knM5kJ/nM5kJPZyJT+kJnM5JTOZyPZyJTeykTm8JTOZyTmcyk/kJnM5JTOZynM5kJPZyJT+JTOZyTmcy</span>
<span class="s2">kPZyJTeykTm8PZyJTeykTm8JTOZyTmcykfykTm8kJnM5TmcyknM5kJ/JTOZyTmcykPZyJTeykTm8Tmcy</span>
<span class="s2">knM5kJfykTm8kJnM5/JTOZyTmcykPZyJTeykTm8TmcyknM5kJfykTm8kJnM5PZyJTeykTm8JTOZyTmcy</span>
<span class="s2">kfykTm8kJnM5TmcyknM5kJ/TmcyknM5kJfykTm8kJnM5nM5kJPZyJT+kJnM5JTOZyfykTm8kJnM5Tmcy</span>
<span class="s2">knM5kJ/kJnM5JTOZynM5kJPZyJT+PZyJTeykTm8JTOZyTmcykfykTm8kJnM5TmcyknM5kJ/JTOZyTmcy</span>
<span class="s2">kPZyJTeykTm8TmcyknM5kJfykTm8kJnM5fykTm8kJnM5TmcyknM5kJ/kJnM5JTOZynM5kJPZyJT+Tmcy</span>
<span class="s2">knM5kJfykTm8kJnM5nM5kJPZyJT+kJnM5JTOZy/nM5kJPZyJT+kJnM5JTOZyPZyJTeykTm8JTOZyTmcy</span>
<span class="s2">k/kJnM5JTOZynM5kJPZyJT+JTOZyTmcykPZyJTeykTm8PZyJTeykTm8JTOZyTmcykfykTm8kJnM5Tmcy</span>
<span class="s2">knM5kJ/JTOZyTmcykPZyJTeykTm8TmcyknM5kJfykTm8kJnM5/kJnM5JTOZynM5kJPZyJT+JTOZyTmcy</span>
<span class="s2">kPZyJTeykTm8nM5kJPZyJT+kJnM5JTOZyPZyJTeykTm8JTOZyTmcyk/JTOZyTmcykPZyJTeykTm8Tmcy</span>
<span class="s2">knM5kJfykTm8kJnM5PZyJTeykTm8JTOZyTmcykfykTm8kJnM5TmcyknM5kJ/PZyJTeykTm8JTOZyTmcy</span>
<span class="s2">kfykTm8kJnM5TmcyknM5kJ/JTOZyTmcykPZyJTeykTm8TmcyknM5kJfykTm8kJnM5fykTm8kJnM5Tmcy</span>
<span class="s2">knM5kJ/kJnM5JTOZynM5kJPZyJT+TmcyknM5kJfykTm8kJnM5nM5kJPZyJT+kJnM5JTOZy/JTOZyTmcy</span>
<span class="s2">kPZyJTeykTm8TmcyknM5kJfykTm8kJnM5PZyJTeykTm8JTOZyTmcykfykTm8kJnM5TmcyknM5kJ/Tmcy</span>
<span class="s2">knM5kJfykTm8kJnM5nM5kJPZyJT+kJnM5JTOZyfykTm8kJnM5TmcyknM5kJ/kJnM5JTOZynM5kJPZyJT"</span> <span class="bp">=</span> <span class="n">bt</span> <span class="mi">12</span> <span class="o">:</span> <span class="n">bool</span><span class="o">)</span>
<span class="c1">-- tt</span>
</code></pre></div>
</div></div>



<a name="271770315"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tree%20notation/near/271770315" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tree.20notation.html#271770315">(Feb 13 2022 at 22:57)</a>:</h4>
<p><span class="user-mention silent" data-user-id="387244">Yaël Dillies</span> <a href="#narrow/stream/113488-general/topic/Tree.20notation/near/271766553">said</a>:</p>
<blockquote>
<p><code>bitstream = list bool</code> or do you have something else in mind? Kyle mentioned that doing arithmetic on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">N</mi></mrow><annotation encoding="application/x-tex">\N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">N</span></span></span></span> might be the fastest because it has special support in the kernel.</p>
</blockquote>
<p>I think that pulling bits from a list is faster than base conversion if you pull things of non-power-of-two sizes from the stream</p>



<a name="271770459"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tree%20notation/near/271770459" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tree.20notation.html#271770459">(Feb 13 2022 at 23:00)</a>:</h4>
<p>The fastest way to implement something that pulls directly from a base64 string is something like <code>string.iterator * nat * nat</code> where the pair of <code>nat</code> represents the last decoded number and the number of bits remaining in it</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
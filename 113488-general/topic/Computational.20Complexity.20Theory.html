---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/Computational.20Complexity.20Theory.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html">Computational Complexity Theory</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="264319554"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/264319554" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Parker Bjur <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#264319554">(Dec 09 2021 at 15:45)</a>:</h4>
<p>Is there a method for writing proofs about computational complexity in lean? I have not been able to find anything of the sort but I am also not very sure where to look.</p>



<a name="264320056"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/264320056" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#264320056">(Dec 09 2021 at 15:49)</a>:</h4>
<p>There is an apparently convenient way to do so in Coq through the λ calculus: <a href="https://drops.dagstuhl.de/opus/frontdoor.php?source_opus=13915">https://drops.dagstuhl.de/opus/frontdoor.php?source_opus=13915</a></p>



<a name="264320394"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/264320394" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#264320394">(Dec 09 2021 at 15:51)</a>:</h4>
<p>See also these previous threads:</p>
<ul>
<li><a href="#narrow/stream/116395-maths/topic/complexity.20theory">https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/complexity.20theory</a></li>
<li><a href="#narrow/stream/113488-general/topic/Ph.2ED.2E.20on.20formalizing.20complexity.20classes">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Ph.2ED.2E.20on.20formalizing.20complexity.20classes</a></li>
<li><a href="#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Complexity.20theory">https://leanprover.zulipchat.com/#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Complexity.20theory</a></li>
<li><a href="#narrow/stream/113489-new-members/topic/Computability.2C.20P.20.28and.20NP.29">https://leanprover.zulipchat.com/#narrow/stream/113489-new-members/topic/Computability.2C.20P.20.28and.20NP.29</a></li>
</ul>



<a name="264321904"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/264321904" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Parker Bjur <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#264321904">(Dec 09 2021 at 16:01)</a>:</h4>
<p>Thank You!</p>



<a name="265910621"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/265910621" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#265910621">(Dec 23 2021 at 12:07)</a>:</h4>
<p>This is a long shot but ... is anyone working on any complexity theory in Lean?</p>



<a name="266004248"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266004248" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266004248">(Dec 24 2021 at 14:06)</a>:</h4>
<p>How difficult would it be to transcribe the Fabian Kunze et al's library from Coq to Lean? Any rough estimate anyone?<br>
<a href="https://github.com/uds-psl/cook-levin">https://github.com/uds-psl/cook-levin</a></p>



<a name="266025566"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266025566" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266025566">(Dec 24 2021 at 21:43)</a>:</h4>
<p>I don't see a good reason to actually transcribe it, those proofs don't look easy to follow. Probably you should just use the theorems as inspiration</p>



<a name="266026173"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266026173" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266026173">(Dec 24 2021 at 21:59)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113488-general/topic/Computational.20Complexity.20Theory/near/266025566">said</a>:</p>
<blockquote>
<p>I don't see a good reason to actually transcribe it, those proofs don't look easy to follow. Probably you should just use the theorems as inspiration</p>
</blockquote>
<p>Thank you for an answer!</p>
<p>On which level would you recommend me to get inspired by it? Should I break down the problem to equivalent lemmata one-to-one?</p>



<a name="266031639"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266031639" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bolton Bailey <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266031639">(Dec 24 2021 at 23:58)</a>:</h4>
<p>I've been working on a PR for the mu-recursive definition of computability. It seems like <a href="https://github.com/uds-psl/cook-levin">https://github.com/uds-psl/cook-levin</a> and <a href="https://arxiv.org/pdf/1102.5495.pdf">https://arxiv.org/pdf/1102.5495.pdf</a> both use definitions that have a similar approach to the model of computation. Perhaps after this PR is made, we can build up from there in terms of defining the time complexity of various algorithms.</p>



<a name="266032132"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266032132" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bolton Bailey <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266032132">(Dec 25 2021 at 00:08)</a>:</h4>
<p>Ok, the PR is <a href="https://github.com/leanprover-community/mathlib/pull/11046">#11046</a>. <span class="user-mention" data-user-id="417654">@Martin Dvořák</span> , if you or anyone else wants to contribute, feel free to push to this branch. It feels like someone comes along every few months looking for a complexity library and not finding one. Maybe the issue is that we just need to get started, and once people see there's something to build off of, it'll grow from there.</p>



<a name="266032352"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266032352" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266032352">(Dec 25 2021 at 00:14)</a>:</h4>
<p>That's exactly what happened with graph theory BTW. Consider making your own stream!</p>



<a name="266054882"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266054882" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266054882">(Dec 25 2021 at 11:17)</a>:</h4>
<p>Great initiative!</p>



<a name="266056104"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266056104" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266056104">(Dec 25 2021 at 11:53)</a>:</h4>
<p>It seems to me that I don't have permission to create new streams. Will any admin or moderator help me?</p>



<a name="266056534"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266056534" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266056534">(Dec 25 2021 at 12:03)</a>:</h4>
<p><span class="user-mention silent" data-user-id="282271">Bolton Bailey</span> <a href="#narrow/stream/113488-general/topic/Computational.20Complexity.20Theory/near/266031639">said</a>:</p>
<blockquote>
<p>I've been working on a PR for the mu-recursive definition of computability. It seems like <a href="https://github.com/uds-psl/cook-levin">https://github.com/uds-psl/cook-levin</a> and <a href="https://arxiv.org/pdf/1102.5495.pdf">https://arxiv.org/pdf/1102.5495.pdf</a> both use definitions that have a similar approach to the model of computation. Perhaps after this PR is made, we can build up from there in terms of defining the time complexity of various algorithms.</p>
</blockquote>
<p>How big is the time overhead of partial recursive functions over Turing Machines? And over RAM, is it known?</p>



<a name="266064466"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266064466" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266064466">(Dec 25 2021 at 15:48)</a>:</h4>
<p><span class="user-mention silent" data-user-id="282271">Bolton Bailey</span> <a href="#narrow/stream/113488-general/topic/Computational.20Complexity.20Theory/near/266032132">said</a>:</p>
<blockquote>
<p>Ok, the PR is <a href="https://github.com/leanprover-community/mathlib/pull/11046">#11046</a>. <span class="user-mention silent" data-user-id="417654">Martin Dvořák</span> , if you or anyone else wants to contribute, feel free to push to this branch. It feels like someone comes along every few months looking for a complexity library and not finding one. Maybe the issue is that we just need to get started, and once people see there's something to build off of, it'll grow from there.</p>
</blockquote>
<p>Idea if more than 1 person wants to contribute: open PRs to that branch instead of committing and pushing directly to it (as if it were a master branch)</p>



<a name="266080256"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266080256" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266080256">(Dec 25 2021 at 23:19)</a>:</h4>
<p>Would someone more knowledgeable mind laying down a roadmap on this subject? I am having a hard time understanding the structure of the Coq repo</p>



<a name="266081232"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266081232" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266081232">(Dec 25 2021 at 23:50)</a>:</h4>
<p>I can sketch some preliminary roadmap but somebody more knowledgeable will have to check and correct after me. Would it be for thee, knowledgeable person, easier this way?</p>



<a name="266081273"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266081273" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266081273">(Dec 25 2021 at 23:52)</a>:</h4>
<p><span class="user-mention" data-user-id="417654">@Martin Dvořák</span> I'd say go for it :D. It's a brand new branch so np</p>



<a name="266114221"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266114221" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266114221">(Dec 26 2021 at 15:29)</a>:</h4>
<p>My rough sketch of the roadmap towards complexity theory in Lean is the following. We will follow the approach of Kunze et al.<br>
Paper: <a href="https://drops.dagstuhl.de/opus/volltexte/2021/13915/pdf/LIPIcs-ITP-2021-20.pdf">https://drops.dagstuhl.de/opus/volltexte/2021/13915/pdf/LIPIcs-ITP-2021-20.pdf</a><br>
Code (Coq): <a href="https://github.com/uds-psl/coq-library-complexity">https://github.com/uds-psl/coq-library-complexity</a><br>
Please note that we won't use the letter L for the name of the complexity class (deterministic logarithmic time).</p>
<p>(1) Define the notion of a decision problem in the weak call-by-value λ-calculus L.<br>
(2) Define the class P in L.<br>
(3) Define the class NP in L.<br>
(4) Define polytime reductions in L.<br>
(5) Prove that, if A polytime reduces to B in P, then A in P.<br>
(6) Define the classes NP-hard and NP-complete in L.<br>
(7) Define a natural NP-complete problem in L.<br>
(8) Prove that, if NP-hard A polytime reduces to B, then B is NP-hard.<br>
(9) Define the Abstract heap machines and Turing machines — just that we can state the auxiliary decision problems about them; we will not program in them; the reductions will be always programmed in L.<br>
(10) State and prove the polytime reductions (very challenging).<br>
(11) State your favourite version of the tiling problem.<br>
(12) Prove the NP-hardness of the tiling problem using the tools above (the vanilla TM will have to be reduced to it).<br>
(13) Reduce your tiling problem to some form of SAT.<br>
(14) We can continue building the complexity theory from here on without getting our hands dirty with the intricacies of various computational models.</p>



<a name="266114722"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266114722" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266114722">(Dec 26 2021 at 15:42)</a>:</h4>
<p>Turing machines already exist in the file <code>computability.turing_machine</code>.</p>



<a name="266114950"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266114950" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266114950">(Dec 26 2021 at 15:49)</a>:</h4>
<p>I sent an e-mail to Fabian Kunze requesting his help.</p>



<a name="266115210"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266115210" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266115210">(Dec 26 2021 at 15:56)</a>:</h4>
<p>I don't understand why ye are grinning. I did my best I could do with my very superficial understanding of Kunze et al's approach.</p>



<a name="266115220"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266115220" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266115220">(Dec 26 2021 at 15:57)</a>:</h4>
<p>I am aware of not providing much of a hint regarding the implementation.</p>



<a name="266115718"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266115718" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stuart Presnell <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266115718">(Dec 26 2021 at 16:09)</a>:</h4>
<p>It looks like an impressive and ambitious plan of work. I don’t know enough to make suggestions, but I’m very pleased to see that someone’s taking this on.</p>



<a name="266116466"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266116466" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266116466">(Dec 26 2021 at 16:27)</a>:</h4>
<p><span class="user-mention silent" data-user-id="417654">Martin Dvořák</span> <a href="#narrow/stream/113488-general/topic/Computational.20Complexity.20Theory/near/266115210">said</a>:</p>
<blockquote>
<p>I don't understand why ye are grinning.</p>
</blockquote>
<p>Sorry, I didn't mean it in a mocking way. I was just happy that you actually did it <span aria-label="smiley" class="emoji emoji-1f603" role="img" title="smiley">:smiley:</span><br>
Zulip's mobile app doesn't have the "on hover" functionality that shows the actual emoji "word"</p>



<a name="266129313"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266129313" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266129313">(Dec 26 2021 at 21:50)</a>:</h4>
<p>I disagree with the idea of requiring everything to be done in L. Not only is that not the computational model we have chosen for the existing computability material, it is also overly restrictive; users should be able to use any computational basis they want that is relevantly equivalent to turing machines or RAM model or whatever is the best computational basis for complexity theory. Currently, <code>computability.turing_machine</code> contains 3 different computational bases that are all equivalent (although the framework for making use of the equivalences for application to complexity classes like P does not exist yet), and users should be able to write e.g. polynomial time TM2 programs. The language L is also polytime equivalent to TM0 so you should be able to write programs in L if you want to, but I would want to allow as much freedom in this area as possible.</p>



<a name="266132817"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266132817" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Dima Pasechnik <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266132817">(Dec 26 2021 at 23:19)</a>:</h4>
<p>Perhaps Fagin's equivalence of NP and sentences in existential 2nd order logic is something that  should be more prominent. (In this vein, polynomial-time solvability becomes definability in the 1st order logic).</p>



<a name="266163148"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266163148" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266163148">(Dec 27 2021 at 10:44)</a>:</h4>
<blockquote>
<p>I disagree with the idea of requiring everything to be done in L.</p>
</blockquote>
<p>A big advantage of L is that is much more ergonomic to use, since Lean quite directly maps to L and most features are directly supported (higher-order functions, partial applications, etc.) with pretty much the runtime and space complexity you'd expect.  You can directly compute the runtime of List.filter as defined in Lean.  It is also straightforward to show that concrete Lean definitions are computable in L; this is a lot more exhausting in the current computability library (particularly with recursive functions, or n-ary functions with n&gt;=3).  I don't even want to imagine a formalization using turing machines.</p>
<blockquote>
<p>users should be able to use any computational basis they want that is relevantly equivalent to turing machines</p>
</blockquote>
<p>L is one such model, I'm not sure I see your point.</p>



<a name="266163363"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266163363" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266163363">(Dec 27 2021 at 10:49)</a>:</h4>
<p>Well, the work on TMs is not get complete as far as connecting them to the primrec model. I would like to see a library closer to what we have for proving primrec, which does cover higher order stuff like list.filter.</p>



<a name="266163390"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266163390" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266163390">(Dec 27 2021 at 10:49)</a>:</h4>
<p>The underlying computational model is somewhat orthogonal to this, you can build a higher order notion of time complexity on any model</p>



<a name="266163649"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266163649" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266163649">(Dec 27 2021 at 10:54)</a>:</h4>
<p>From what I can tell of the complete implementation of L used to derive time bounds, it's not all that different from what you get from constructions like TM_to_partrec. It still has a pretty concrete operational model with an explicit evaluation context, so it's not as compositional as pure lambda calculus. The differences don't seem big enough to make it worth introducing yet another computational model and connecting it to the other models</p>



<a name="266163852"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266163852" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266163852">(Dec 27 2021 at 10:56)</a>:</h4>
<p>I realize that you've put a lot of effort into this development, but I don't think it's a good direction.  The <code>primrec</code>/... stuff is really unergonomic to work with, e.g. for <code>list.filter</code> you need several lemmas showing that list.filter is primrec/computable/partrec if the predicate is primrec/computable/partrec.  If we wanted to tackle time complexity, I feel like we'd end up with another computational model and set of theorems anyhow.</p>



<a name="266164178"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266164178" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266164178">(Dec 27 2021 at 11:01)</a>:</h4>
<p>I do think we can borrow some ideas from Kunze et al for the "frontend" part of this, like h.o. time complexity</p>



<a name="266164306"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266164306" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266164306">(Dec 27 2021 at 11:03)</a>:</h4>
<p><code>primrec</code> is limited to first order functions on naturals, which is why there is the proliferation of theorems. With <code>nat.partrec.code</code> it becomes more practical to express that a higher order function is "nice" once and for all by proving that it is h.o. equivalent to a single <code>code</code>. This option is not available in <code>primrec</code> itself because it is still bootstrapping</p>



<a name="266164415"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266164415" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266164415">(Dec 27 2021 at 11:05)</a>:</h4>
<p>In other words, I think we have the tools we need to simulate everything you would do with a computational model like L (in particular all the typeclasses and such that are necessary for an ergonomic library) without actually changing the basis</p>



<a name="266164522"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266164522" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266164522">(Dec 27 2021 at 11:07)</a>:</h4>
<p>I think we need to do some design work on that frontend though; I don't think transliterating the coq code precisely will actually work all that well in lean, we will need to make some modifications but it's going in the right direction</p>



<a name="266164668"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266164668" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266164668">(Dec 27 2021 at 11:09)</a>:</h4>
<blockquote>
<p>It still has a pretty concrete operational model with an explicit evaluation context, so it's not as compositional as pure lambda calculus.</p>
</blockquote>
<p>Yes, proving that the time complexity of <code>f t</code> is the runtime of <code>t</code> + runtime of <code>f</code> on the resulting value is the same in either formalism.  What you get with L is in my eyes the following:</p>
<ol>
<li>You get a single theorem for computability (namely, a definition of a lambda term that compute the function for all values).  Properties like complexity, termination, etc. are then theorems about this lambda term.  This also works for higher-order function without any friction.  (To be fair, we could also do this with partial recursive functions and maybe turing machines---but I'm not sure if there's a canonical turing machine that suffices for complexity analysis).</li>
<li>It's obvious how to represent data in L.  <code>List.take 10 xs</code> has <code>O(10)</code> runtime, no matter what the type of the elements in <code>xs</code> is.  Depending on how lists / function arguments / return values are represented in a Turing machine, this might entail copying the elements, the whole list, etc. (Though we could also solve that with other computational models, like random-access machines.)</li>
</ol>



<a name="266164765"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266164765" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266164765">(Dec 27 2021 at 11:10)</a>:</h4>
<blockquote>
<p>I think we need to do some design work on that frontend though; I don't think transliterating the coq code precisely will actually work all that well in lean, we will need to make some modifications but it's going in the right direction</p>
</blockquote>
<p>Completely agreed on that.  Transliterating is certainly the wrong way.  But I think their ideas are good and sound, and deserve to be used as inspiration.</p>



<a name="266165175"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266165175" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266165175">(Dec 27 2021 at 11:18)</a>:</h4>
<p>I think there is value in having a more complex intermediate language than L for the sake of having nice primitive operations with crafted time bounds. For example, throwing in the natural numbers with arithmetic operations on simply typed lambda calculus</p>



<a name="266165188"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266165188" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266165188">(Dec 27 2021 at 11:18)</a>:</h4>
<blockquote>
<p>In other words, I think we have the tools we need to simulate everything you would do with a computational model like L (in particular all the typeclasses and such that are necessary for an ergonomic library) without actually changing the basis</p>
</blockquote>
<p>I think it's clear that we could make a nicer frontend for showing computability, that just seems like an engineering problem.  The part that I don't see is how such a frontend would scale to showing time or space complexity.  Maybe you have already this figured out though.</p>



<a name="266165220"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266165220" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266165220">(Dec 27 2021 at 11:19)</a>:</h4>
<p>Certainly it is nice to be able to say that <code>list.take 10 xs</code> has time <code>O(10)</code>. It would be even better if it takes exactly 10 steps (and lots of other basic functions like it also have exactly the right number of steps)</p>



<a name="266165300"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266165300" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266165300">(Dec 27 2021 at 11:21)</a>:</h4>
<p>we probably won't be able to get that for everything, but a big haskell-ish language would make it easier to do the "writing concrete programs" part, which I expect to be much more important / time consuming than any work needed to set up the model and prove it is polynomially simulated by a TM or partial recursive function.</p>



<a name="266165418"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266165418" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266165418">(Dec 27 2021 at 11:23)</a>:</h4>
<blockquote>
<p>For example, throwing in the natural numbers with arithmetic operations on simply typed lambda calculus</p>
</blockquote>
<p>Practically speaking, this won't make any difference at all for any common NP problems because all natural numbers will be bounded by a very low bound.  Even the most basic implementation will be fast enough there.  We just need to replace <code>Nat</code> by <code>Num</code> (which is straightforward in the L approach).</p>



<a name="266165494"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266165494" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266165494">(Dec 27 2021 at 11:24)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110043">Gabriel Ebner</span> <a href="#narrow/stream/113488-general/topic/Computational.20Complexity.20Theory/near/266165188">said</a>:</p>
<blockquote>
<p>I think it's clear that we could make a nicer frontend for showing computability, that just seems like an engineering problem.  The part that I don't see is how such a frontend would scale to showing time or space complexity.  Maybe you have already this figured out though.</p>
</blockquote>
<p>I've been thinking mostly about time complexity here. I would borrow Kunze's work for this part. Regarding space complexity, I haven't thought much about it, and we might need a RAM model to get all the results that complexity theorists expect here</p>



<a name="266165532"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266165532" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266165532">(Dec 27 2021 at 11:25)</a>:</h4>
<blockquote>
<p>Certainly it is nice to be able to say that <code>list.take 10 xs</code> has time <code>O(10)</code>. It would be even better if it takes exactly 10 steps (and lots of other basic functions like it also have exactly the right number of steps)</p>
</blockquote>
<p>It won't take exactly 10 steps in any model of computation (for a non-specialized take implementation), because decrementing natural numbers has some non-constant runtime.</p>



<a name="266165642"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266165642" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266165642">(Dec 27 2021 at 11:27)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110043">Gabriel Ebner</span> <a href="#narrow/stream/113488-general/topic/Computational.20Complexity.20Theory/near/266165418">said</a>:</p>
<blockquote>
<blockquote>
<p>For example, throwing in the natural numbers with arithmetic operations on simply typed lambda calculus</p>
</blockquote>
<p>Practically speaking, this won't make any difference at all for any common NP problems because all natural numbers will be bounded by a very low bound.  Even the most basic implementation will be fast enough there.  We just need to replace <code>Nat</code> by <code>Num</code> (which is straightforward in the L approach).</p>
</blockquote>
<p>Yes, but that's not the point. The idea behind the haskell-ish intermediate language is to calibrate the time bounds to be exactly some nice numbers. For example, to set the cost of <code>m * n</code> to <code>m.size * n.size + 1</code> or whatever we can get away with (and not have to introspect further on how these operations work)</p>



<a name="266165710"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266165710" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266165710">(Dec 27 2021 at 11:28)</a>:</h4>
<p>The actual replacement of <code>Num</code> for <code>Nat</code> will happen in the once-and-for-all proof that this IL is polytime simulated by a TM</p>



<a name="266165723"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266165723" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266165723">(Dec 27 2021 at 11:28)</a>:</h4>
<blockquote>
<p>but a big haskell-ish language would make it easier to do the "writing concrete programs" part</p>
</blockquote>
<p>The whole idea about the L approach (and I believe what they do / want to do in Coq) is that this can be almost fully automated, since the host language maps so closely to the object language.  You write a function in pure idiomatic Lean, and then <code>deriving instance Computable for List.filter</code> and you have a realizing lambda term + theorems for the runtime of the cons and the nil case.</p>



<a name="266165867"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266165867" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266165867">(Dec 27 2021 at 11:31)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110043">Gabriel Ebner</span> <a href="#narrow/stream/113488-general/topic/Computational.20Complexity.20Theory/near/266165532">said</a>:</p>
<blockquote>
<blockquote>
<p>Certainly it is nice to be able to say that <code>list.take 10 xs</code> has time <code>O(10)</code>. It would be even better if it takes exactly 10 steps (and lots of other basic functions like it also have exactly the right number of steps)</p>
</blockquote>
<p>It won't take exactly 10 steps in any model of computation (for a non-specialized take implementation), because decrementing natural numbers has some non-constant runtime.</p>
</blockquote>
<p>This depends on how tight we need the simulation to be. If we can afford a log factor in the simulation then we can make decrementing numbers O(1)</p>



<a name="266165963"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266165963" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266165963">(Dec 27 2021 at 11:33)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113488-general/topic/Computational.20Complexity.20Theory/near/266165642">said</a>:</p>
<blockquote>
<p>Yes, but that's not the point. The idea behind the haskell-ish intermediate language is to calibrate the time bounds to be exactly some nice numbers. For example, to set the cost of <code>m * n</code> to <code>m.size + n.size + 1</code> or whatever we can get away with (and not have to introspect further on how these operations work)</p>
</blockquote>
<p>That would be a wonderful breakthough.  I believe the best known multiplication algorithms are O(n log n).</p>



<a name="266166191"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266166191" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266166191">(Dec 27 2021 at 11:37)</a>:</h4>
<p>Generally I think the focus on precise numbers is a distraction here.  Even in the best case there's going to be lots of annoying +1s and -1s that nobody cares about.  The runtime should be stated as a big-O, which is I think very much the standard in complexity theory.  Just imagine you'd have to account for all the index computations in a sorting algorithm...</p>



<a name="266166266"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266166266" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266166266">(Dec 27 2021 at 11:38)</a>:</h4>
<p>Sure, we can't build in everything so that's inevitable</p>



<a name="266166306"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266166306" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266166306">(Dec 27 2021 at 11:39)</a>:</h4>
<p>Right, and if it's inevitable we might as well accept it and use big-O everywhere.</p>



<a name="266166314"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266166314" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266166314">(Dec 27 2021 at 11:39)</a>:</h4>
<p>but unfortunately I think that in practice we won't be able to use big-O nearly as much as the books would have you believe</p>



<a name="266166384"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266166384" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266166384">(Dec 27 2021 at 11:40)</a>:</h4>
<p>lots of proofs require that you fix the big-O constant after the fact in some way that is not easily explained by any concrete definition of big-O</p>



<a name="266166419"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266166419" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266166419">(Dec 27 2021 at 11:41)</a>:</h4>
<p>Seriously, the biggest issue with L in my eyes is with subpolynomial complexity.  I mean sure, you can prove that an algorithm has O(n log n) runtime <em>in L</em>, but I'm not sure how convincing that result is to somebody else.  Then there's the question of what LOGSPACE is in L.</p>



<a name="266166485"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266166485" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266166485">(Dec 27 2021 at 11:42)</a>:</h4>
<p>Right. I think that for the question of what computational basis to use for our definitions, we should be looking at the tightest complexity classes, because those can sometimes distinguish the bases</p>



<a name="266166486"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266166486" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266166486">(Dec 27 2021 at 11:42)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113488-general/topic/Computational.20Complexity.20Theory/near/266166384">said</a>:</p>
<blockquote>
<p>lots of proofs require that you fix the big-O constant after the fact in some way that is not easily explained by any concrete definition of big-O</p>
</blockquote>
<p>Do you have any concrete examples?</p>



<a name="266166619"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266166619" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266166619">(Dec 27 2021 at 11:45)</a>:</h4>
<p>You generally need the existential constant to lie outside all variables, including parameters to the algorithm. This is generally very cumbersome to write, and it is easy to leave out a variable and then get stuck when you try to use the function recursively in a proof much later</p>



<a name="266167180"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266167180" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266167180">(Dec 27 2021 at 11:56)</a>:</h4>
<p>I see what you mean (in a paper I would always interpret big-O to quantify over everything unless specified otherwise), but I don't think it means big-O is problematic.  It just means we always need to quantify over all arguments, i.e. <code>is_O (fun (m,n) =&gt; runtime (m + n)) (fun (m,n) =&gt; (m+n) * (m+n).log)</code>, which is indeed a bit verbose (but fixable).</p>



<a name="266167537"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266167537" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266167537">(Dec 27 2021 at 12:02)</a>:</h4>
<p>Here's a more concrete example. Suppose we have a function like:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">foo</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">-&gt;</span> <span class="n">Nat</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="bp">=&gt;</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="n">n</span><span class="bp">+</span><span class="mi">1</span> <span class="bp">=&gt;</span> <span class="k">do</span> <span class="n">f</span> <span class="n">n</span><span class="bp">;</span> <span class="n">g</span> <span class="n">n</span><span class="bp">;</span> <span class="n">foo</span> <span class="n">n</span>
</code></pre></div>
<p>Let's suppose that <code>f n</code> is <code>O(n)</code> and <code>g n</code> is <code>O(n^2)</code>.If we wanted to keep big-O everywhere, we might want to argue like so:</p>
<div class="codehilite" data-code-language="Text only"><pre><span></span><code>time(f n) is O(n)
time(g n) is O(n^2)
time(foo n) is O(n^3)
time(f n; g n; foo n) is O(n + n^2 + n^3) = O(n^3)
</code></pre></div>
<p>but of course this doesn't work because of the recursion. So we have to introduce an explicit constant:</p>
<div class="codehilite" data-code-language="Text only"><pre><span></span><code>time(f n) is O(n)
time(g n) is O(n^2)
time(foo n) &lt;= c n^3
time(f n; g n; foo n) is O(n + n^2 + c n^3) &lt;= c (n+1)^3
</code></pre></div>
<p>but this also doesn't work because that last step isn't valid. The correct way to prove this is:</p>
<div class="codehilite" data-code-language="Text only"><pre><span></span><code>time(f n) is O(n)
time(g n) is O(n^2)
time(f n) + time(g n) is O(n^2)
Suppose time(f n) + time(g n) &lt;= d n^2
Pick c := d + 1 (or something)
Prove by induction: time(foo n) &lt;= c n^3

time(f n; g n; foo n) =
time(f n) + time(g n) + time(foo n) &lt;=
d n^2 + (d+1) n^3 &lt;= (d+1) (n+1)^3
</code></pre></div>
<p>The big-O is really not helping here; if we just had explicit constants for everything, for example if we knew <code>time(f n) &lt;= 4 n</code> and <code>time(g n) &lt;= 37 n^2</code> then this proof would be a lot simpler.</p>



<a name="266167706"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266167706" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266167706">(Dec 27 2021 at 12:05)</a>:</h4>
<p>Plus, you never know when a more precise bound might come in handy</p>



<a name="266167799"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266167799" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Dima Pasechnik <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266167799">(Dec 27 2021 at 12:07)</a>:</h4>
<p>The whole business about L seems to be geared towards various questions related to complexity of various λ-calculi. For the classical complexity theory this seems to be more of a sidetrack (which however might have technical benefits).</p>



<a name="266167880"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266167880" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266167880">(Dec 27 2021 at 12:08)</a>:</h4>
<p>I really don't want to prove anything about church rosser here, that seems like entirely a sidetrack if the goal is P and NP</p>



<a name="266167911"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266167911" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266167911">(Dec 27 2021 at 12:09)</a>:</h4>
<p>(To be fair, you don't need to take such a sidetrack if formalizing L; but it does seem likely to come up if you start thinking about compositionality in the lambda calculus)</p>



<a name="266168088"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266168088" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266168088">(Dec 27 2021 at 12:12)</a>:</h4>
<blockquote>
<p>if we just had explicit constants for everything</p>
</blockquote>
<p>Luckily, we can eliminate the big-O again if we need to fall back to explicit constants.  (Just like we can fall back to ε-δ-proofs if more general methods fail.)</p>



<a name="266168128"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266168128" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Dima Pasechnik <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266168128">(Dec 27 2021 at 12:12)</a>:</h4>
<p>Isn't the problem we see with big O here due to the true nature of big O being asymptotic? One needs to argue that O(n^k)&lt;O(n^{k+1}) as n-&gt;oo.</p>
<p>(OK in sense of proving something is in P).</p>



<a name="266168166"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266168166" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Dima Pasechnik <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266168166">(Dec 27 2021 at 12:13)</a>:</h4>
<p>One sweeps these explicit constants into exponents, that's OK is only done fixed number to times.</p>



<a name="266168318"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266168318" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266168318">(Dec 27 2021 at 12:16)</a>:</h4>
<blockquote>
<p>Isn't the problem we see with big O here due to the true nature of big O being asymptotic?</p>
</blockquote>
<p>This doesn't make any real difference.  If <code>f n = O(g n)</code> as <code>n → ∞</code>, then there exists a <code>c</code> such that <code>f n ≤ c * (g n + 1)</code> and vice versa. (assuming f,g≥0)</p>



<a name="266168359"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266168359" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266168359">(Dec 27 2021 at 12:17)</a>:</h4>
<p>I think it would be okay to have theorems of the form <code>\exists N, \all n &gt;= N, time(f n) &lt;= 37 n</code>, where we fix the <code>c</code> but not <code>N</code></p>



<a name="266168402"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266168402" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266168402">(Dec 27 2021 at 12:18)</a>:</h4>
<p>since I don't think that <code>N</code> interferes with recursive proofs as much as <code>c</code> does</p>



<a name="266168417"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266168417" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266168417">(Dec 27 2021 at 12:18)</a>:</h4>
<p>That's logically equivalent to a big-O so I'm not opposed.  But it's a bit unfortunate if we can't reuse the <code>is_O</code> definition.</p>



<a name="266168434"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266168434" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266168434">(Dec 27 2021 at 12:19)</a>:</h4>
<p>is it? big-O requires a multiplicative constant</p>



<a name="266168462"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266168462" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266168462">(Dec 27 2021 at 12:19)</a>:</h4>
<p>or do you mean something like <code>time(f n) - 37 n in O(1)</code></p>



<a name="266168568"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266168568" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266168568">(Dec 27 2021 at 12:21)</a>:</h4>
<p>We can still have <code>is_O</code>-stated theorems for "presentation" purposes (and who knows, maybe they will be usable in some proofs) but for the really hard time complexity theorems I will expect us to skip those and go straight for the ones with algebraically more complicated but logically simpler bounds</p>



<a name="266168569"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266168569" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266168569">(Dec 27 2021 at 12:21)</a>:</h4>
<blockquote>
<p>The whole business about L seems to be geared towards various questions related to complexity of various λ-calculi.</p>
</blockquote>
<p>No, that's certainly not the intention.  The idea behind L is that it is much closer to a functional language (like Lean) in syntax and operational semantics, so you don't have to do as much encoding as with Turing machines.  Like Mario is saying, a lot of basic operations (like applying a function or reading the first element of a list, etc.) take exactly one step in L, but can take several or even many steps in a Turing machine because of copying, skipping, etc.</p>



<a name="266168758"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266168758" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266168758">(Dec 27 2021 at 12:24)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113488-general/topic/Computational.20Complexity.20Theory/near/266168568">said</a>:</p>
<blockquote>
<p>We can still have <code>is_O</code>-stated theorems for "presentation" purposes (and who knows, maybe they will be usable in some proofs) but for the really hard time complexity theorems I will expect us to skip those and go straight for the ones with algebraically more complicated but logically simpler bounds</p>
</blockquote>
<p>I'm not sure I understand you.  Are you saying that <code>37</code> is better than <code>c</code>, because presumably <code>norm_num</code> can simplify it?  While I recognize the pain, I feel like the solution here should be better automation, and not theorems with hard-coded bounds.</p>



<a name="266168809"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266168809" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266168809">(Dec 27 2021 at 12:25)</a>:</h4>
<p>Not (just) because norm_num can work with it, but also because we don't need to deal with existential elimination and the resulting scoping. It's a lot easier to automate such a proof if everything is in the empty context</p>



<a name="266168896"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266168896" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Dima Pasechnik <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266168896">(Dec 27 2021 at 12:26)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113488-general/topic/Computational.20Complexity.20Theory/near/266168434">said</a>:</p>
<blockquote>
<p>is it? big-O requires a multiplicative constant</p>
</blockquote>
<p>Yes, but for the purposes of proving something in P, one can replace a constant by a sufficiently slowly growing function, e.g. <code>n</code>, or <code>log n</code>.</p>



<a name="266168910"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266168910" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266168910">(Dec 27 2021 at 12:27)</a>:</h4>
<p>So <code>Σ' c, time (f n) ≤ c * n^2</code> would be ok then?  (No elimination, no scope.)  If you allow classical logic, you can also avoid the existential elimination with an epsilon.</p>



<a name="266169075"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266169075" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266169075">(Dec 27 2021 at 12:30)</a>:</h4>
<p>I think that still suffers from the scoping over parameters problem. The normal way to write that would imply that <code>c</code> can depend on anything in scope, whereas if it is an explicit <code>37</code> then you know it doesn't. I think lean might still be able to work with it if it can unfold the value to <code>37</code>, but it can still possibly trigger scoping issues if it is not reduced</p>



<a name="266169104"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266169104" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266169104">(Dec 27 2021 at 12:31)</a>:</h4>
<p>Another way to hide the argument is to have <code>time_f_constant := 37</code> and then <code>time (f n) ≤ time_f_constant * n^2</code>, where you can control the parameters needed in <code>time_f_constant</code></p>



<a name="266169247"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266169247" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266169247">(Dec 27 2021 at 12:34)</a>:</h4>
<p>Maybe I'm naive, but is this so much easier than <code>rcases time_f_spec with ⟨time_f_constant, N, time_f_le⟩</code> at the beginning of the proof?</p>



<a name="266169293"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266169293" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Dima Pasechnik <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266169293">(Dec 27 2021 at 12:35)</a>:</h4>
<p>I guess I'm talking about completely eliminating big-O, in the sense that O(n)&lt;n^2 as n-&gt;oo, etc. This works for showing something in P.</p>



<a name="266169362"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266169362" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266169362">(Dec 27 2021 at 12:36)</a>:</h4>
<p>For showing things are in P, I think you can avoid constants altogether and instead use closure properties for most things</p>



<a name="266169378"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266169378" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266169378">(Dec 27 2021 at 12:37)</a>:</h4>
<p>The big-O stuff only comes up for tighter bounds like sorting in O(n log n)</p>



<a name="266169485"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266169485" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266169485">(Dec 27 2021 at 12:38)</a>:</h4>
<p><span class="user-mention" data-user-id="110043">@Gabriel Ebner</span> Maybe. I haven't worked it all out, so consider me moderately dubious but willing to try things and see what sticks</p>



<a name="266173538"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266173538" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266173538">(Dec 27 2021 at 13:45)</a>:</h4>
<p>This is a subject I'm very interested in and I will try to follow the discussions as hard as I can.</p>
<p>Can we have a separate stream <code>complexity theory</code> for it? It's getting more and more laborious to backtrack every discussion made about this topic. Different topics are spread over different streams and mixed/smashed into same threads.</p>
<p>Sorry for my ignorance, but what's the core idea for computing time and space complexity formally? The proofs that I've done/seen all my entire life about these were extremely informal, like counting loops inside loops and making some logical connection with the input size.</p>



<a name="266173637"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266173637" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266173637">(Dec 27 2021 at 13:48)</a>:</h4>
<p>Streams are usually made to divert attention away from a subject which isn't interesting to most people. Simply cut that thread into smaller ones if you feel like you can't follow the conversation.</p>



<a name="266191969"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266191969" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266191969">(Dec 27 2021 at 17:58)</a>:</h4>
<p><span class="user-mention silent" data-user-id="316505">Dima Pasechnik</span> <a href="#narrow/stream/113488-general/topic/Computational.20Complexity.20Theory/near/266132817">said</a>:</p>
<blockquote>
<p>Perhaps Fagin's equivalence of NP and sentences in existential 2nd order logic is something that  should be more prominent. (In this vein, polynomial-time solvability becomes definability in the 1st order logic).</p>
</blockquote>
<p>As a definition? Or an additional theorem about our classes?</p>



<a name="266226072"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266226072" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266226072">(Dec 28 2021 at 02:54)</a>:</h4>
<p><span class="user-mention silent" data-user-id="451983">Arthur Paulino</span> <a href="#narrow/stream/113488-general/topic/Computational.20Complexity.20Theory/near/266173538">said</a>:</p>
<blockquote>
<p>Sorry for my ignorance, but what's the core idea for computing time and space complexity formally? The proofs that I've done/seen all my entire life about these were extremely informal, like counting loops inside loops and making some logical connection with the input size.</p>
</blockquote>
<p>The basic idea is pretty simple: count all the basic steps evaluated by a program. You can very often get exact formulas for this, like <code>2 n^2 + 3 x - 7</code>; formally this is often an easier task than doing big-O analysis, although it can start to help once the formulas get too complicated. Once the tools to state such theorems are in place, the proofs are pretty trivial, it usually amounts to proofs like <code>\sum i &lt; n, 1 + 2 + (3 i - 1) = O(n^2)</code>.</p>



<a name="266226182"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266226182" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266226182">(Dec 28 2021 at 02:57)</a>:</h4>
<p>For space complexity, I'm not sure what the best setting is. Probably we want a computational model with a finite memory like an FSM (but with parametric memory size <code>k</code> possibly depending on the input <code>n</code>, instead of <code>O(1)</code>), and then a space complexity bound talks about whether such a limited model is capable of computing the desired function.</p>



<a name="266339123"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266339123" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Dima Pasechnik <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266339123">(Dec 29 2021 at 11:54)</a>:</h4>
<p><span class="user-mention silent" data-user-id="417654">Martin Dvořák</span> <a href="#narrow/stream/113488-general/topic/Computational.20Complexity.20Theory/near/266191969">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="316505">Dima Pasechnik</span> <a href="#narrow/stream/113488-general/topic/Computational.20Complexity.20Theory/near/266132817">said</a>:</p>
<blockquote>
<p>Perhaps Fagin's equivalence of NP and sentences in existential 2nd order logic is something that  should be more prominent. (In this vein, polynomial-time solvability becomes definability in the 1st order logic).</p>
</blockquote>
<p>As a definition? Or an additional theorem about our classes?</p>
</blockquote>
<p>either way would be useful - IMHO it's a very convenient way to think about the class NP, as it does not invoke weird stuff such as nondeterministic Turing machines.</p>



<a name="266340713"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266340713" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266340713">(Dec 29 2021 at 12:18)</a>:</h4>
<p>What is the "natural" NP-complete problem in this formalism?</p>



<a name="266341709"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266341709" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Dima Pasechnik <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266341709">(Dec 29 2021 at 12:36)</a>:</h4>
<p><span class="user-mention silent" data-user-id="417654">Martin Dvořák</span> <a href="#narrow/stream/113488-general/topic/Computational.20Complexity.20Theory/near/266340713">said</a>:</p>
<blockquote>
<p>What is the "natural" NP-complete problem in this formalism?</p>
</blockquote>
<p>the usual, e.g. SAT. For instance, see <a href="https://hal.archives-ouvertes.fr/hal-00017602/document">https://hal.archives-ouvertes.fr/hal-00017602/document</a></p>



<a name="266341917"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266341917" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Dima Pasechnik <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266341917">(Dec 29 2021 at 12:39)</a>:</h4>
<p>this brings up the question of a "natural reduction" - in the classical theory, Karp vs Turing reductions. Here we have "1st order reductions", as well.</p>



<a name="266416089"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266416089" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266416089">(Dec 30 2021 at 09:48)</a>:</h4>
<p>I will be free to start working on that after my Qualifying Exam on 2022-01-25. However, I'd need a lot of guidance in order to succeed in this task.</p>



<a name="266506605"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266506605" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266506605">(Dec 31 2021 at 14:35)</a>:</h4>
<p>I am super curious to see how it would be built up in Lean <span aria-label="eyes" class="emoji emoji-1f440" role="img" title="eyes">:eyes:</span></p>



<a name="266794676"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266794676" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Fabian Kunze <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266794676">(Jan 04 2022 at 11:02)</a>:</h4>
<p><span class="user-mention silent" data-user-id="417654">Martin Dvořák</span> <a href="#narrow/stream/113488-general/topic/Computational.20Complexity.20Theory/near/266114221">said</a>:</p>
<blockquote>
<p>(1) Define the notion of a decision problem in the weak call-by-value λ-calculus L.<br>
(2) Define the class P in L.<br>
(3) Define the class NP in L.<br>
(4) Define polytime reductions in L.<br>
(5) Prove that, if A polytime reduces to B in P, then A in P.<br>
(6) Define the classes NP-hard and NP-complete in L.<br>
(7) Define a natural NP-complete problem in L.<br>
(8) Prove that, if NP-hard A polytime reduces to B, then B is NP-hard.<br>
(9) Define the Abstract heap machines and Turing machines — just that we can state the auxiliary decision problems about them; we will not program in them; the reductions will be always programmed in L.<br>
(10) State and prove the polytime reductions (very challenging).<br>
(11) State your favourite version of the tiling problem.<br>
(12) Prove the NP-hardness of the tiling problem using the tools above (the vanilla TM will have to be reduced to it).<br>
(13) Reduce your tiling problem to some form of SAT.<br>
(14) We can continue building the complexity theory from here on without getting our hands dirty with the intricacies of various computational models.</p>
</blockquote>
<p>Hi, I'm one out the authors of the Cook-Levin mechanisation in Coq.</p>
<p>I think you are missing (or at last not explicitly acknowledging) the part that an 'time-invariant' simulation of L in terms of Turing machines is needed (if the model of computations is to be choosen L): As NP-complete talks more or less about simulating all poly-time verifiers  with a single problem, one needs to transform the L-algorithms into TMs, i.e. implement the abstract heap machine as TM. (Or is that the part (10)?)<br>
This part is quite hard: We developed an framework to verify Turing machines (See our <a href="https://www.ps.uni-saarland.de/Publications/details/ForsterEtAl:2019:VerifiedTMs.html">publication with Wuttke</a>).</p>



<a name="266794692"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266794692" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Fabian Kunze <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266794692">(Jan 04 2022 at 11:02)</a>:</h4>
<p>On a more general note:</p>
<p>Our experience there is also why we think that explicitly constructing TMs (or other low-level models of computation, like mu-recursive functions) just does not scale: There is so much overhead, like"how do I encode different types of data? (lists, terms, programms...)", or "How to verify simple composition of functions and other straightforward, non-recursive (or "non-loop-containing") programs without to much effort?" and of course "How can I verify loops/recursion"?<br>
Maybe, with a lot of engineering work, one can come up with a scaling verification framework, but our conclusion is that functional programming is such a sweet-spot in ITPs that one would waste time not using a functional language whenever possible.</p>
<p>It might be very much possible to support sublinear space in a lambda calculus, for example by introducing oracles for the input. No matter the model of computation, it seems that sublinear space will make it a lot more tedious to have composability of programs, as one can not use the same space measure for a program "on top level" and "a program called as a subroutine of another program".</p>



<a name="266796135"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266796135" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Fabian Kunze <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266796135">(Jan 04 2022 at 11:16)</a>:</h4>
<p>My judgement is that 1,2,3,4,6,7,9 are trivial.<br>
5 and 8 are very easy once one has a basic understanding on how to compose programs.</p>
<p>Proving that (7) is indeed NP-complete of course needs an universal L-program that runs in poly-time, for instance implementing the heap machine in L. With a good verification framework for the model of computation (in this case, L), this is not very hard, but without a good framework, this is very, very tedious, and maybe even unfeasible.</p>
<p>(I commented on 10 above, if that is the L-to-TM-reduction, i.e. the implementation of an L-interpreter as a TM. It took us a very talented student with an excellent bachelors thesis on this topic to come up with a verification framework for TMs, and after his thesis, it still was the work of over 100 hours of work to implement and verify the TMs needed for this step. )</p>
<p>11 and 12 were also tackled in a bachelor thesis with another extraordinary student, and needed a lot of proof Engineering to solve the many, many cases that can occur when simulating a computation with a tiling problem. </p>
<p>13 again is trivial, assuming one can write and verify basic programs in the model of computation (of course, as always, assuming one also can verify running times).</p>



<a name="266796165"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266796165" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266796165">(Jan 04 2022 at 11:17)</a>:</h4>
<p><span class="user-mention" data-user-id="468318">@Fabian Kunze</span> I'm curious whether by "TM" you mean in the strict sense defined by turing, or a more type-level programming friendly version. I think that while TMs construed literally are not good for verification, it is possible to get a more abstract model with user-chosen state spaces to do TM proofs without as much pain. I think that it is possible to get these looking something like WHILE programs or finite state machines with O(1) programs in between, which seems like a good balance between the native logic part used to write the programs, and the explicit step representation you need to do time and space bounds (within a constant factor).</p>



<a name="266796407"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266796407" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Fabian Kunze <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266796407">(Jan 04 2022 at 11:20)</a>:</h4>
<p>Yes, we abstract away the TM behind while-program like "combinators" that construct TMs in the background:<br>
"The Turing machine verification framework allows giving algorithms in the style of a<br>
register-based while-language, and a corresponding machine is automatically constructed<br>
behind the scenes. Separate correctness and verification proofs are then inclusion proofs<br>
between the automatically derived and the user-given relations for the constructed machine"</p>
<p>But there still is the problem that the "registers" contain asingle tape/strings, and that one might want to change the alphabet when composing machines/</p>



<a name="266796454"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266796454" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266796454">(Jan 04 2022 at 11:21)</a>:</h4>
<p>As an example of what can be done with such a framework, see the program <a href="https://github.com/leanprover-community/mathlib/blob/master/src/computability/tm_to_partrec.lean#L837-L887"><code>tm_to_partrec</code></a> and surrounding section. That one is implemented in a multi-stack machine, but if you have ideas for a more abstract model that still supports some nice operations I'm all ears</p>



<a name="266796468"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266796468" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266796468">(Jan 04 2022 at 11:21)</a>:</h4>
<p>You <em>can</em> change the alphabet when composing machines</p>



<a name="266796621"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266796621" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266796621">(Jan 04 2022 at 11:23)</a>:</h4>
<p>Ah. I think, based on your description, that one difference between our formalisms is that the mathlib one actually changes the model of computation rather than using combinators over the original model (and there are general theorems about reduction from one model to another)</p>



<a name="266796630"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266796630" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Fabian Kunze <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266796630">(Jan 04 2022 at 11:23)</a>:</h4>
<p>Yes, we change the alphabet, it is all possible, and we are quite happy with our final, hoare-like verification framework that hides most, or even all of those details.</p>



<a name="266796746"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266796746" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Fabian Kunze <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266796746">(Jan 04 2022 at 11:25)</a>:</h4>
<p>Yes, we do only have a shallow representation of the while language, not a deep one. One aspect was that this allows to add new data typ[es (lists of other things, for example) on the fly, as long as one person wrote the "basic" combinators to interact with that new data.</p>



<a name="266796861"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266796861" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Fabian Kunze <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266796861">(Jan 04 2022 at 11:26)</a>:</h4>
<p>Partrec seems to be very close to L in my eyes by the way, and I have no doubt that this approach can work.</p>



<a name="266796904"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266796904" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266796904">(Jan 04 2022 at 11:27)</a>:</h4>
<p>That's my impression as well. I think that <code>tm_to_partrec</code> automaton is a rough equivalent of your L-to-TM reduction</p>



<a name="266796938"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266796938" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Fabian Kunze <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266796938">(Jan 04 2022 at 11:27)</a>:</h4>
<p>Is the theoretical problem of coming up with a time measure for partrec-functions that is invariant w.r.t. turing machines solved?</p>



<a name="266796990"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266796990" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266796990">(Jan 04 2022 at 11:28)</a>:</h4>
<p>what do you mean by invariant?</p>



<a name="266797012"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266797012" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Fabian Kunze <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266797012">(Jan 04 2022 at 11:28)</a>:</h4>
<p>that the TM and part rec function simulate wach other with just polynomial overhead</p>



<a name="266797031"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266797031" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Fabian Kunze <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266797031">(Jan 04 2022 at 11:28)</a>:</h4>
<p>probably, count all mu-rec-loop-executions, is it?</p>



<a name="266797044"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266797044" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266797044">(Jan 04 2022 at 11:28)</a>:</h4>
<p>As long as you can accept a O(n) slowdown (e.g. anything P or larger) then you can do the simulation</p>



<a name="266797086"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266797086" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Fabian Kunze <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266797086">(Jan 04 2022 at 11:29)</a>:</h4>
<p>the slowdown of implementing mu-rec programs in TMs is only linear?</p>



<a name="266797103"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266797103" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Fabian Kunze <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266797103">(Jan 04 2022 at 11:29)</a>:</h4>
<p>sorry, other way arround]</p>



<a name="266797149"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266797149" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266797149">(Jan 04 2022 at 11:30)</a>:</h4>
<p>We don't have the actual time bounds proved yet, but the current setup should have O(1) from TM0 to TM1, O(n) slowdown for TM2 from TM1, and O(log n) slowdown for partrec from TM2</p>



<a name="266797165"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266797165" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266797165">(Jan 04 2022 at 11:30)</a>:</h4>
<p>TM2 is multi-stack machines</p>



<a name="266797191"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266797191" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Fabian Kunze <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266797191">(Jan 04 2022 at 11:30)</a>:</h4>
<p>Ah, nice.</p>



<a name="266797392"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266797392" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266797392">(Jan 04 2022 at 11:33)</a>:</h4>
<p>Well, to be precise the last step is not partrec, it is <a href="https://github.com/leanprover-community/mathlib/blob/master/src/computability/tm_to_partrec.lean#L68-L114">this model</a> which is proven equivalent to the partrec model but has a more explicit cost model</p>



<a name="266797448"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266797448" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266797448">(Jan 04 2022 at 11:34)</a>:</h4>
<p>partrec itself is mostly only focused on computability in the abstract, some of those algorithms are really bad (like double exponential) if run literally</p>



<a name="266797570"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266797570" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266797570">(Jan 04 2022 at 11:35)</a>:</h4>
<p>but that's why <a href="https://github.com/leanprover-community/mathlib/blob/master/src/computability/partrec.lean#L149-L159">partrec</a> is defined as a Prop with no computational content, you shouldn't be extracting an actual algorithm from it</p>



<a name="266797586"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266797586" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Fabian Kunze <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266797586">(Jan 04 2022 at 11:35)</a>:</h4>
<p>The TM2 model looks interesting. Is there documentation/intuition on what kind of types are allowed as elements on the stacks, and what kind of "elementary" operations are permitted?</p>



<a name="266797598"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266797598" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266797598">(Jan 04 2022 at 11:35)</a>:</h4>
<p>The stack element can be any finite type</p>



<a name="266797707"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266797707" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266797707">(Jan 04 2022 at 11:36)</a>:</h4>
<p>The elementary operations are basic operations on stacks <a href="https://github.com/leanprover-community/mathlib/blob/master/src/computability/turing_machine.lean#L1765-L1790">here</a></p>



<a name="266797741"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266797741" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Fabian Kunze <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266797741">(Jan 04 2022 at 11:37)</a>:</h4>
<p>and sigma is a finite type, i assume?</p>



<a name="266797762"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266797762" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266797762">(Jan 04 2022 at 11:37)</a>:</h4>
<p>yes, that's the "local state"</p>



<a name="266797892"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266797892" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266797892">(Jan 04 2022 at 11:38)</a>:</h4>
<p>in the simulation using basic TMs the basic states are pairs of a local state value and a label</p>



<a name="266797901"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266797901" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Fabian Kunze <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266797901">(Jan 04 2022 at 11:39)</a>:</h4>
<p>Very nice abstractions, in hindsight, more transformations when going from single-tape to multi-tape TMs would have made our life simpler.</p>



<a name="266798473"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/266798473" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#266798473">(Jan 04 2022 at 11:47)</a>:</h4>
<p>One of the things I like a lot about the TM models is that the type <code>Λ</code> of "labels" (aka TM states) is <em>not</em> required to be finite, but rather finitely supported (only a finite number of labels are reachable from any given label). That means that label types can be simple infinite inductive types like <a href="https://github.com/leanprover-community/mathlib/blob/master/src/computability/tm_to_partrec.lean#L761-L769">this one</a>, and we prove separately that for any starting point of interest there is a finite set of reachable states from it. In that example, we have a single label space covering all partrec programs, and finiteness is guaranteed by the fact that you only visit programs corresponding to subterms of the original program</p>



<a name="267042801"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/267042801" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Fabian Kunze <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#267042801">(Jan 06 2022 at 09:57)</a>:</h4>
<p>We are quite happy with the fact that in our hoare-style framework, we only need one lemma for each total TM, following the execution once, to get all properties of the tm we need (and the lemmas for the Hoare rules handle the well-formatted-conditions in the background.)</p>



<a name="267045017"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/267045017" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#267045017">(Jan 06 2022 at 10:21)</a>:</h4>
<p>what properties are those? Functional correctness and a time bound? Do you have an example?</p>



<a name="267603681"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/267603681" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Fabian Kunze <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#267603681">(Jan 11 2022 at 16:07)</a>:</h4>
<p>Yes, the specification of functional correctness and the running time. Well-formedness is already "baked in" into the type of turing machines, for instance that the alphabet is finite etc.</p>



<a name="268176724"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/268176724" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#268176724">(Jan 16 2022 at 10:17)</a>:</h4>
<p>Is anybody going to work on the implementation in foreseeable future?</p>



<a name="268204371"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/268204371" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bolton Bailey <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#268204371">(Jan 16 2022 at 20:13)</a>:</h4>
<p>I am going to continue working on it in <a href="https://github.com/leanprover-community/mathlib/pull/11046">#11046</a>. Notwithstanding all the discussion here, I'm just going to start by trying to finish a function <code>time</code> with the same type as <a href="https://leanprover-community.github.io/mathlib_docs/find/nat.partrec.code.eval">docs#nat.partrec.code.eval</a>, I'm not sure how long this will take me, but it seems like the best combination of achievability and forward progress to me.</p>



<a name="268338141"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/268338141" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#268338141">(Jan 18 2022 at 03:11)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113488-general/topic/Computational.20Complexity.20Theory/near/266226072">said</a>:</p>
<blockquote>
<p>The basic idea is pretty simple: count all the basic steps evaluated by a program. You can very often get exact formulas for this, like <code>2 n^2 + 3 x - 7</code>; formally this is often an easier task than doing big-O analysis, although it can start to help once the formulas get too complicated. Once the tools to state such theorems are in place, the proofs are pretty trivial, it usually amounts to proofs like <code>\sum i &lt; n, 1 + 2 + (3 i - 1) = O(n^2)</code>.</p>
</blockquote>
<p>What if you have, say, <code>f(a, b) = a + b</code>, would you say that this function is <code>O(a)</code> (or <code>O(b)</code> depending on how addition is defined) or <code>O(1)</code>?</p>



<a name="268339480"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/268339480" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#268339480">(Jan 18 2022 at 03:38)</a>:</h4>
<p>It depends on whether that is a primitive operation or not. If it is primitive, then it is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>. For a lot of purposes it might be reasonable to take it as such; the Word RAM model of computation allows addition to be <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>, although the addends must be <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(w)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mclose">)</span></span></span></span> bits where w, the "word size", is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Ω</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Omega(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Ω</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p>



<a name="268339507"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/268339507" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#268339507">(Jan 18 2022 at 03:39)</a>:</h4>
<p>If addition is not primitive, then I would expect <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>a</mi><mo>+</mo><mi>log</mi><mo>⁡</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log a + \log b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span></p>



<a name="268748415"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/268748415" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#268748415">(Jan 20 2022 at 19:56)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113488-general/topic/Computational.20Complexity.20Theory/near/268339480">said</a>:</p>
<blockquote>
<p>It depends on whether that is a primitive operation or not. If it is primitive, then it is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>. For a lot of purposes it might be reasonable to take it as such; the Word RAM model of computation allows addition to be <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>, although the addends must be <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(w)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mclose">)</span></span></span></span> bits where w, the "word size", is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Ω</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Omega(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Ω</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p>
</blockquote>
<p>Why Omega?</p>



<a name="268752385"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/268752385" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#268752385">(Jan 20 2022 at 20:27)</a>:</h4>
<p>Could this Isabelle/HOL project be used as inspiration for us?<br>
<a href="https://github.com/wimmers/poly-reductions">https://github.com/wimmers/poly-reductions</a></p>
<p>I don't know whether I understand what they did. They have the polytime reductions. Unfortunately, they don't have any problem proved to be NP-complete yet. Nevertheless, it is a part of their plan and their framework should be capable of that. Am I right?</p>



<a name="268756914"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/268756914" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#268756914">(Jan 20 2022 at 21:00)</a>:</h4>
<p>I think it's usually stated as an inequality <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>≤</mo><msup><mn>2</mn><mi>w</mi></msup></mrow><annotation encoding="application/x-tex">n\le 2^w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span></span></span></span></span></span></span></span>, the asymptotics of it don't matter so much. It's a hypothesis, but a fairly reasonable one for word RAM: it's saying that the entire problem fits in the address space of the machine</p>



<a name="268756985"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/268756985" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#268756985">(Jan 20 2022 at 21:01)</a>:</h4>
<p>For a regular computer, this is saying that 64-bit machines can work on problems of size at most 2^64</p>



<a name="268757163"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/268757163" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#268757163">(Jan 20 2022 at 21:02)</a>:</h4>
<p>For asymptotic complexity results, this is convenient because it means that as <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> grows so does <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span>, so you can do larger operations in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>



<a name="268757179"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/268757179" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#268757179">(Jan 20 2022 at 21:02)</a>:</h4>
<p>But can we choose word size to be much higher than Omega(log n) to reduce the time complexity in some cases?</p>



<a name="268757274"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/268757274" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#268757274">(Jan 20 2022 at 21:03)</a>:</h4>
<p>Yes, but the complexity bounds are stated as a function of both <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span> in this case</p>



<a name="268757316"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/268757316" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#268757316">(Jan 20 2022 at 21:03)</a>:</h4>
<p>Oh!</p>



<a name="268757324"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/268757324" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#268757324">(Jan 20 2022 at 21:04)</a>:</h4>
<p>For a really intense application of word RAM capabilities check out <a href="https://en.wikipedia.org/wiki/Fusion_tree">fusion trees</a></p>



<a name="268758422"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/268758422" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bolton Bailey <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#268758422">(Jan 20 2022 at 21:12)</a>:</h4>
<p>After thinking about the partial recursive implementation more, I'm not sure this approach actually works. If we are working over the naturals and the only primitive operation for mutating a natural is the successor function, it seems like there's no way for addition to be O(log n), since to construct <code>a + b</code> from <code>a</code> and <code>b</code>, you have to apply the successor at least <code>(b - a)</code> times. It also seems like you can't represent a natural in binary, since if you fix the number of registers you need for a natural at k, you can represent at most <code>t ^ k</code> numbers in <code>O(t)</code> time. I may need to rethink the approach.</p>



<a name="268759113"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/268759113" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#268759113">(Jan 20 2022 at 21:17)</a>:</h4>
<p>Basic question, possibly very stupid:</p>
<p>What is the difference between the partially-recursive functions and the call-by-value lambda-calculus, please?</p>



<a name="268759971"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/268759971" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bolton Bailey <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#268759971">(Jan 20 2022 at 21:23)</a>:</h4>
<p>That's a good question. I was a bit confused when <span class="user-mention" data-user-id="468318">@Fabian Kunze</span> said that mu-recursive functions wouldn't scale, after saying that the call-by-value lambda calculus was what he and his co-authors used, since I would have said that those models of computation are similar, or at least that it wouldn't be too hard to prove slowdown lemmas about one with respect to the other. Perhaps he or someone else can elaborate on the differences, or if this is indeed difficult?</p>



<a name="268760906"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/268760906" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#268760906">(Jan 20 2022 at 21:30)</a>:</h4>
<p><span class="user-mention" data-user-id="282271">@Bolton Bailey</span> This is why you probably shouldn't define <code>time</code> based on the partrec evaluation rules. It's only intended for defining computability, not complexity, and there are several reductions involved that are exponential or double exponential</p>



<a name="268761501"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/268761501" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#268761501">(Jan 20 2022 at 21:34)</a>:</h4>
<p>Any of the TM-based computation models should all be polynomially equivalent: <code>TM0</code>, <code>TM1</code>, <code>TM2</code>. You can also probably code binary in the <a href="https://leanprover-community.github.io/mathlib_docs/find/turing.to_partrec.code">docs#turing.to_partrec.code</a> model, but the built in nats in that model are unary</p>



<a name="268761503"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/268761503" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bolton Bailey <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#268761503">(Jan 20 2022 at 21:34)</a>:</h4>
<p>It occurs to me that if only the naturals were represented in binary and I could do an O(1) doubling or halving operation on them, I would have stacks and one could use multiple stacks to implement a Turing machine, so I imagine time in this model of computation would be within a polynomial factor of the usual definition.</p>



<a name="268761708"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/268761708" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#268761708">(Jan 20 2022 at 21:36)</a>:</h4>
<p>Take a look at <a href="https://leanprover-community.github.io/mathlib_docs/computability/tm_to_partrec.html#simulating-sequentialized-partial-recursive-functions-in-tm2">https://leanprover-community.github.io/mathlib_docs/computability/tm_to_partrec.html#simulating-sequentialized-partial-recursive-functions-in-tm2</a>, that's exactly what it does</p>



<a name="268762107"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/268762107" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#268762107">(Jan 20 2022 at 21:38)</a>:</h4>
<p>There are computational models similar to primitive recursive functions which compute functions in P, you have to switch out the <code>prec</code> constructor with "recursion on notation" aka <a href="https://leanprover-community.github.io/mathlib_docs/find/nat.binary_rec">docs#nat.binary_rec</a></p>



<a name="268804964"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/268804964" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Fabian Kunze <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#268804964">(Jan 21 2022 at 07:38)</a>:</h4>
<p>Regarding the observation with "not enough space to madd numbers":<br>
That exactly is the complication, function composition does not behave like before, where one cold just concatenate the resource consumption functions.</p>
<p>For TMs, one approach is to have input (and output) tapes, on which one can only read (or write and move one step to the right). I have not looked into it that deep, but as far as I understood,  you can arrange things such that one can compose "online" algorithms, for instance one can think of addition as a function that traverses two binary representations and, on the fly,. returns the stream of bits of the sum. If the function called on that result directly "consumes" the output (or, more explicitly, pauses and resumes the computation of the bits as needed), one can add numbers inside an log(n) algorithm.</p>
<p>Another approach (which I think is more common) is to represent numbers not as numbers, but as algorithms that, given an index i, return the i-the bit of the number. This allows to represent numbers of size up to n in log(n) space (But only a constant amount of them, because the code has to exists in the program itself). As long as one is only interested in space, this very inefficient representation does work.</p>
<p>But this inability of writing down intermediate results explicitly makes formalizations of space really complicated.</p>



<a name="268805372"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/268805372" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Fabian Kunze <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#268805372">(Jan 21 2022 at 07:45)</a>:</h4>
<p><span class="user-mention silent" data-user-id="282271">Bolton Bailey</span> <a href="#narrow/stream/113488-general/topic/Computational.20Complexity.20Theory/near/268759971">said</a>:</p>
<blockquote>
<p>That's a good question. I was a bit confused when <span class="user-mention silent" data-user-id="468318">Fabian Kunze</span> said that mu-recursive functions wouldn't scale, after saying that the call-by-value lambda calculus was what he and his co-authors used,</p>
</blockquote>
<p>I'm sorry, I was inconsitent: when I said "[I have no doubts that] partrec [] can work", this was meant as a retraction of my previous statement that I was sceptical using murec for time-complexity. I used those two names, partrec and murec, interchangeably, as they mean the same.</p>
<p>The one complication I see is that without an abstraction layer for encodings (gödel-numbers?), the statements and programs get a bit messy when programming an universal machine. With the lambda calculus, we more or less get any Algebraic data type "for free" using Scott encodings (wich are similar to church encodings, but vor cbv-languages).</p>



<a name="268861857"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/268861857" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yannick Forster <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#268861857">(Jan 21 2022 at 15:56)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113488-general/topic/Computational.20Complexity.20Theory/near/266165642">said</a>:</p>
<blockquote>
<p>The idea behind the haskell-ish intermediate language</p>
</blockquote>
<p>Do you have any more concrete thoughts how a haskell-ish intermediate language might look Mario?</p>



<a name="268862026"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/268862026" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yannick Forster <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#268862026">(Jan 21 2022 at 15:57)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113488-general/topic/Computational.20Complexity.20Theory/near/266797149">said</a>:</p>
<blockquote>
<p>We don't have the actual time bounds proved yet, but the current setup should have O(1) from TM0 to TM1, O(n) slowdown for TM2 from TM1, and O(log n) slowdown for partrec from TM2</p>
</blockquote>
<p>Do you see a chance to find a good notion of space complexity for <code>partrec</code>?</p>



<a name="268898755"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/268898755" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#268898755">(Jan 21 2022 at 20:26)</a>:</h4>
<p>I think the most natural thing would be to use a computational model which is similar in structure to <code>partrec</code> but uses binary strings as the basic data type instead of <code>nat</code></p>



<a name="268906109"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/268906109" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bolton Bailey <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#268906109">(Jan 21 2022 at 21:33)</a>:</h4>
<p>Ok, thanks Fabian for responding, I guess I'll start thinking about a binary-string <code>partrec</code>.</p>



<a name="268906443"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/268906443" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bolton Bailey <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#268906443">(Jan 21 2022 at 21:36)</a>:</h4>
<p><span class="user-mention silent" data-user-id="444411">Yannick Forster</span> <a href="#narrow/stream/113488-general/topic/Computational.20Complexity.20Theory/near/268862026">said</a>:</p>
<blockquote>
<p>Do you see a chance to find a good notion of space complexity for <code>partrec</code>?</p>
</blockquote>
<p>I think that space-complexity for <code>partrec</code> can look very similar to time-complexity for <code>partrec</code> in structure. Instead of <code>time (comp f g) = time f + time g</code> we have something like <code>space (comp f g) = max (space f) (space g)</code> (with appropriate inputs to <code>f</code> and <code>g</code>).</p>



<a name="268911193"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/268911193" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#268911193">(Jan 21 2022 at 22:20)</a>:</h4>
<p><span class="user-mention silent" data-user-id="468318">Fabian Kunze</span> <a href="#narrow/stream/113488-general/topic/Computational.20Complexity.20Theory/near/268804964">said</a>:</p>
<blockquote>
<p>For TMs, one approach is to have input (and output) tapes, on which one can only read (or write and move one step to the right).</p>
</blockquote>
<p>Would the TM always have a constant amount of tapes?</p>



<a name="268912072"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/268912072" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#268912072">(Jan 21 2022 at 22:29)</a>:</h4>
<p>Would the number of tapes be baked into the TM type?</p>



<a name="268960216"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/268960216" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yannick Forster <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#268960216">(Jan 22 2022 at 14:24)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113488-general/topic/Computational.20Complexity.20Theory/near/268898755">said</a>:</p>
<blockquote>
<p>I think the most natural thing would be to use a computational model which is similar in structure to <code>partrec</code> but uses binary strings as the basic data type instead of <code>nat</code></p>
</blockquote>
<p>What makes <code>partrec</code> tedious in my opinion is that you don't have a lambda, so all programs are combinatorial and passing around input is not as easy as in functional programming languages. But, of course, with a lambda you buy into the harder simulation proof. And why restrict to binary strings? Intuitively I'd rather argue for binary trees (like in the computability book by Jones. On top of that I would imagine that one can build an even more expressive simply typed language with natural numbers, lists, options and trees (which is immediately reduced to the simpler case with just one base type)</p>



<a name="268960371"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/268960371" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yannick Forster <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#268960371">(Jan 22 2022 at 14:28)</a>:</h4>
<p><span class="user-mention silent" data-user-id="282271">Bolton Bailey</span> <a href="#narrow/stream/113488-general/topic/Computational.20Complexity.20Theory/near/268906443">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="444411">Yannick Forster</span> <a href="#narrow/stream/113488-general/topic/Computational.20Complexity.20Theory/near/268862026">said</a>:</p>
<blockquote>
<p>Do you see a chance to find a good notion of space complexity for <code>partrec</code>?</p>
</blockquote>
<p>I think that space-complexity for <code>partrec</code> can look very similar to time-complexity for <code>partrec</code> in structure. Instead of <code>time (comp f g) = time f + time g</code> we have something like <code>space (comp f g) = max (space f) (space g)</code> (with appropriate inputs to <code>f</code> and <code>g</code>).</p>
</blockquote>
<p>It's not obvious to me that this works. (But of course it would be great if it would!) To implement on a Turing machine, you'd probably need some kind of environment implemented with pointers, and pointers can grow linear-logarithmically instead of just linearly. At least, that's what happens with lambda calculus and why for e.g. the full lambda calculus space complexity is still an open problem. For RAM machines, defining space is also way more subtle  than one might think (that was the content of the first paper by Slot and van Emde Boas, where they came up with the conjecture that all reasonable models of computation can simulate each other with polynomial overhead in time and constanct-factor (i.e. linear) overhead in space</p>



<a name="270335764"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/270335764" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bolton Bailey <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#270335764">(Feb 02 2022 at 05:15)</a>:</h4>
<p>Hey <span class="user-mention" data-user-id="110049">@Mario Carneiro</span> , I'm noticing that the definition of <a href="https://leanprover-community.github.io/mathlib_docs/find/turing.to_partrec.code.eval">docs#turing.to_partrec.code.eval</a> for <code>code.fix</code> could be changed to<br>
<code>| (code.fix f) := pfun.fix $ λ v, pure (if v.head = 0 then sum.inl v.tail else sum.inr v.tail)</code><br>
Which is shorter than what is there currently. I believe this essentially changes it from a "while" to a "do-while" semantics. I think this doesn't change the model too much and might be cleaner in the long run (if I can fix what breaks in this file). Is there a reason I'm missing for it to be defined the way we have it?</p>



<a name="270335855"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/270335855" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#270335855">(Feb 02 2022 at 05:17)</a>:</h4>
<p>you don't use <code>f</code> in that snippet?</p>



<a name="270335878"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/270335878" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bolton Bailey <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#270335878">(Feb 02 2022 at 05:17)</a>:</h4>
<p>Uhh, oops, you're right, just a sec</p>



<a name="270336176"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/270336176" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bolton Bailey <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#270336176">(Feb 02 2022 at 05:22)</a>:</h4>
<p>I think this is what I meant:<br>
<code>| (code.fix f) := pfun.fix $ λ v, if v.head = 0 then pure (sum.inl v.tail) else ((f.eval v.tail).map sum.inr) </code></p>



<a name="270336426"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/270336426" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bolton Bailey <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#270336426">(Feb 02 2022 at 05:25)</a>:</h4>
<p>I guess it doesn't end up that much shorter</p>



<a name="318138491"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/318138491" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#318138491">(Dec 27 2022 at 18:07)</a>:</h4>
<p>I think we should establish some regular Zoom meetings on formalizing complexity theory in Lean.<br>
Many of us are interested in having such a library, but it will require a lot of collaboration which seems that we haven't started yet.</p>



<a name="318236300"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/318236300" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#318236300">(Dec 28 2022 at 11:21)</a>:</h4>
<p>I suggest we start in the 3rd week of 2023. Indicate your time preferences please:<br>
<a href="https://doodle.com/meeting/participate/id/ep84nEQe">https://doodle.com/meeting/participate/id/ep84nEQe</a></p>



<a name="318241892"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/318241892" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#318241892">(Dec 28 2022 at 11:59)</a>:</h4>
<p>Also note that graph algorithms are of interest to me, if you happen to need one at some point.</p>



<a name="318250885"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/318250885" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#318250885">(Dec 28 2022 at 12:56)</a>:</h4>
<p><span class="user-mention silent" data-user-id="417654">Martin Dvořák</span> <a href="#narrow/stream/113488-general/topic/Computational.20Complexity.20Theory/near/318236300">said</a>:</p>
<blockquote>
<p>I suggest we start in the 3rd week of 2023. Indicate your time preferences please:<br>
<a href="https://doodle.com/meeting/participate/id/ep84nEQe">https://doodle.com/meeting/participate/id/ep84nEQe</a></p>
</blockquote>
<p>I signed up but mostly because this has been a topic of interest for me for a while, not necessarily because I'm actually competent enough to contribute something from a purley mathematical POV so if my vote ends up being a deal breaker just ignore me.</p>



<a name="318277684"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/318277684" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shreyas Srinivas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#318277684">(Dec 28 2022 at 15:40)</a>:</h4>
<p><span class="user-mention silent" data-user-id="395550">Henrik Böving</span> <a href="#narrow/stream/113488-general/topic/Computational.20Complexity.20Theory/near/318250885">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="417654">Martin Dvořák</span> <a href="#narrow/stream/113488-general/topic/Computational.20Complexity.20Theory/near/318236300">said</a>:</p>
<blockquote>
<p>I suggest we start in the 3rd week of 2023. Indicate your time preferences please:<br>
<a href="https://doodle.com/meeting/participate/id/ep84nEQe">https://doodle.com/meeting/participate/id/ep84nEQe</a></p>
</blockquote>
<p>I signed up but mostly because this has been a topic of interest for me for a while, not necessarily because I'm actually competent enough to contribute something from a purley mathematical POV so if my vote ends up being a deal breaker just ignore me.</p>
</blockquote>
<p>Complexity theory is broad enough as a subject that it is unlikely that  everyone knows all the relevant math beforehand, beyond the basic stuff.</p>



<a name="318282831"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/318282831" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#318282831">(Dec 28 2022 at 16:12)</a>:</h4>
<p>My knowledge ends at "There is P and NP and there is a couple of fun reductions to SAT  you can do to show things are in NP" :P</p>



<a name="318353815"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/318353815" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hanting Zhang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#318353815">(Dec 29 2022 at 03:19)</a>:</h4>
<p>:O I'm very interested as well! It seems I can't sign up for the meeting though. May I have an invite?</p>



<a name="318371141"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/318371141" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#318371141">(Dec 29 2022 at 07:51)</a>:</h4>
<p>Everyone is invited! Just vote in the poll, please.</p>



<a name="318374104"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/318374104" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hanting Zhang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#318374104">(Dec 29 2022 at 08:21)</a>:</h4>
<p>Oh apologies I was doing something wrong -- I've signed up now</p>



<a name="318374286"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/318374286" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#318374286">(Dec 29 2022 at 08:23)</a>:</h4>
<p>No need to apologize. Just clarify, please, did you just indicate that only one time works for you?</p>



<a name="318374441"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/318374441" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#318374441">(Dec 29 2022 at 08:24)</a>:</h4>
<p>Doodle asks every participant for a subset of time slots.</p>



<a name="318377629"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/318377629" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Johnson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#318377629">(Dec 29 2022 at 08:52)</a>:</h4>
<p>Don't forget to record the meetings and post on YouTube.</p>



<a name="318377896"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/318377896" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#318377896">(Dec 29 2022 at 08:53)</a>:</h4>
<p>Is it necessary?</p>



<a name="318378188"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/318378188" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#318378188">(Dec 29 2022 at 08:55)</a>:</h4>
<p>Recording meetings makes many people afraid of embarrassing themselves.</p>



<a name="318399312"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/318399312" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Johnson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#318399312">(Dec 29 2022 at 11:26)</a>:</h4>
<p>Participants may request to remove any problematic part of the video before posting on youtube, but it will rarely happen. Most Lean meetings are public. See for example mathlib4 porting meetings at leanprover community youtube channel. People who can't participate for whatever reason should have access to video materials.</p>



<a name="318416427"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/318416427" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#318416427">(Dec 29 2022 at 13:16)</a>:</h4>
<p>2c: I would suggest the first meetings not to be recorded because it's important that participants feel as comfortable to speak as possible. And the group still has to find its dynamics. Recording will be more natural when there's a minimal shape to begin with. (I'm not participating, but I have some experience starting out informal study groups)</p>



<a name="318416700"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/318416700" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#318416700">(Dec 29 2022 at 13:18)</a>:</h4>
<p>Please don't let anything hinder the spontaneity of the movement. It's an important ingredient!</p>



<a name="318903929"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/318903929" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Praneeth Kolichala <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#318903929">(Jan 01 2023 at 20:42)</a>:</h4>
<p>I'd very much like to attend but this is the same week as the POPL conference (Principles of Programming Languages). I only marked times as available when they didn't conflict with this (i.e. before 9:00 AM).</p>
<p>On the other hand, it seems there are quite a few talks about Lean, which presumably means other Lean people will be there. So while I can't really do a Zoom call, if other people will be at POPL I am willing to do an in-person meeting!</p>



<a name="318949099"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/318949099" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#318949099">(Jan 02 2023 at 08:12)</a>:</h4>
<p>I am sorry I chose an inconvenient week for the first call. Given how many people have responded to the poll, I will not change it now. I will be happy if you join us for the next meetings!</p>



<a name="319818095"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/319818095" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shreyas Srinivas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#319818095">(Jan 06 2023 at 16:44)</a>:</h4>
<p>This discussion <a href="#narrow/stream/113488-general/topic/elementary.20probability.20advice/near/306030991">on elementary probability</a> is very relevant to us. Most theoretical CS people may not be fluent in measure theory either.</p>



<a name="320405042"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/320405042" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#320405042">(Jan 10 2023 at 09:13)</a>:</h4>
<p>We shall meet on Monday 2023-01-16 at 15:00 GMT.</p>



<a name="320405909"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/320405909" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#320405909">(Jan 10 2023 at 09:19)</a>:</h4>
<p>Can someone with Zoom Pro generate a Zoom link for our meeting please? My links are limited to 40 minutes.</p>



<a name="320443790"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/320443790" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#320443790">(Jan 10 2023 at 12:54)</a>:</h4>
<p>If you use the add global time button when composing message you can add a time which will be rendered as everyones local time, eg: <time datetime="2023-01-16T15:00:00Z">2023-01-16T15:00:00Z</time></p>



<a name="320444669"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/320444669" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#320444669">(Jan 10 2023 at 12:58)</a>:</h4>
<p>Yes <time datetime="2023-01-16T15:00:00Z">2023-01-16T15:00:00+00:00</time> is correct.</p>



<a name="320537019"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/320537019" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#320537019">(Jan 10 2023 at 20:17)</a>:</h4>
<p>Hot news! The Cook-Levin theorem has been proved in Isabelle!<br>
<a href="https://www.isa-afp.org/entries/Cook_Levin.html">https://www.isa-afp.org/entries/Cook_Levin.html</a></p>



<a name="320537861"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/320537861" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hanting Zhang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#320537861">(Jan 10 2023 at 20:23)</a>:</h4>
<p>Wow!! Only two days ago as well :O</p>



<a name="320542822"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/320542822" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#320542822">(Jan 10 2023 at 20:54)</a>:</h4>
<p><span class="user-mention" data-user-id="468318">@Fabian Kunze</span> Can you please tell us a brief comparison with your proof in Coq?</p>



<a name="320548042"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/320548042" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shreyas Srinivas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#320548042">(Jan 10 2023 at 21:27)</a>:</h4>
<p>The first 360 odd pages in the proof doc are just for establishing the basic machinery of TMs and other basic stuff. I wonder how much we can shave this in size with effective use of mathlib</p>



<a name="320548224"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/320548224" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shreyas Srinivas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#320548224">(Jan 10 2023 at 21:28)</a>:</h4>
<p>and how much of this machinery related to TMs is reusable for the rest of the theorems in that book</p>



<a name="320548444"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/320548444" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shreyas Srinivas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#320548444">(Jan 10 2023 at 21:29)</a>:</h4>
<p>A significant chunk of the TM related proofs is about writing TMs for specific languages and proving their correctness and complexity.</p>



<a name="320548609"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/320548609" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#320548609">(Jan 10 2023 at 21:30)</a>:</h4>
<p>In general I would usually expect isabelle results to be shorter than ours because they can cut proofs quite short thanks to superior automation.</p>



<a name="320650952"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/320650952" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shreyas Srinivas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#320650952">(Jan 11 2023 at 09:13)</a>:</h4>
<p>I don't mean shorter through automation, but shorter in an amortized sense, because we have a library which might come in handy for proving this theorem, and the theorems we develop for this might come in handy elsewhere.</p>



<a name="320796051"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/320796051" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#320796051">(Jan 11 2023 at 20:58)</a>:</h4>
<p>Can somebody please generate the Zoom link?</p>



<a name="320816724"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/320816724" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shreyas Srinivas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#320816724">(Jan 11 2023 at 23:28)</a>:</h4>
<p><span class="user-mention silent" data-user-id="417654">Martin Dvořák</span> <a href="#narrow/stream/113488-general/topic/Computational.20Complexity.20Theory/near/320796051">said</a>:</p>
<blockquote>
<p>Can somebody please generate the Zoom link?</p>
</blockquote>
<p>I need to check if our institutions still have licenses.</p>



<a name="320816774"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/320816774" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shreyas Srinivas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#320816774">(Jan 11 2023 at 23:29)</a>:</h4>
<p>I'll be able to check if I can create a room by Friday evening</p>



<a name="320816998"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/320816998" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hanting Zhang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#320816998">(Jan 11 2023 at 23:31)</a>:</h4>
<p>I think I can generate one under my institution</p>



<a name="320817069"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/320817069" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hanting Zhang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#320817069">(Jan 11 2023 at 23:32)</a>:</h4>
<p><a href="https://usc.zoom.us/j/96278860441?pwd=YXFjdlJ2aFVlOUovMUVscitNWHZCdz09">https://usc.zoom.us/j/96278860441?pwd=YXFjdlJ2aFVlOUovMUVscitNWHZCdz09</a></p>



<a name="320817079"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/320817079" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hanting Zhang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#320817079">(Jan 11 2023 at 23:32)</a>:</h4>
<p>Does this work lol</p>



<a name="320855917"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/320855917" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Praneeth Kolichala <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#320855917">(Jan 12 2023 at 05:06)</a>:</h4>
<p>Over the past couple weeks, I've been working on my reworked definitions of polynomial time computation. I've uploaded the repository <a href="https://github.com/prakol16/circuits">here</a> with a reasonably detailed README. I feel like I have a reasonable path towards Cook-Levin, although the machinery for circuits is still quite basic. Essentially, we need to define uniform circuit families and show that composition (which is mostly straightforward with circuits) can actually be computed in polynomial time.</p>
<p>If anyone would like to help out or contribute, that would be very appreciated (especially now that winter break has ended, I will probably be busy again).</p>



<a name="320867245"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/320867245" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#320867245">(Jan 12 2023 at 07:12)</a>:</h4>
<p>Your README looks great! When I have more time, I will READYOU more carefully.</p>



<a name="320867680"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/320867680" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#320867680">(Jan 12 2023 at 07:16)</a>:</h4>
<p><span class="user-mention silent" data-user-id="355764">Hanting Zhang</span> <a href="#narrow/stream/113488-general/topic/Computational.20Complexity.20Theory/near/320817069">said</a>:</p>
<blockquote>
<p><a href="https://usc.zoom.us/j/96278860441?pwd=YXFjdlJ2aFVlOUovMUVscitNWHZCdz09">https://usc.zoom.us/j/96278860441?pwd=YXFjdlJ2aFVlOUovMUVscitNWHZCdz09</a></p>
</blockquote>
<p>Is it all right that I can join the call already now?</p>



<a name="320868337"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/320868337" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hanting Zhang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#320868337">(Jan 12 2023 at 07:22)</a>:</h4>
<p>uhhhh yeah idk how to restrict it</p>



<a name="320868528"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/320868528" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#320868528">(Jan 12 2023 at 07:23)</a>:</h4>
<p>Do other people use the same link?</p>



<a name="320893321"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/320893321" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#320893321">(Jan 12 2023 at 09:46)</a>:</h4>
<p>Can I distribute the link without a risk that the recipients will land into unrelated meetings?</p>



<a name="321015891"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/321015891" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#321015891">(Jan 12 2023 at 19:22)</a>:</h4>
<p><span class="user-mention silent" data-user-id="417654">Martin Dvořák</span> <a href="#narrow/stream/113488-general/topic/Computational.20Complexity.20Theory/near/320542822">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="468318">Fabian Kunze</span> Can you please tell us a brief comparison with your proof in Coq?</p>
</blockquote>
<p>The author of the new proof in Isabelle compares his proof to the proof in Coq as follows:<br>
<a href="/user_uploads/3121/Av_8_ATe9nMHRIxE_yh96r_V/image.png">image.png</a></p>
<div class="message_inline_image"><a href="/user_uploads/3121/Av_8_ATe9nMHRIxE_yh96r_V/image.png" title="image.png"><img src="/user_uploads/3121/Av_8_ATe9nMHRIxE_yh96r_V/image.png"></a></div>



<a name="321015982"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/321015982" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#321015982">(Jan 12 2023 at 19:22)</a>:</h4>
<p><a href="/user_uploads/3121/91P4mtevTE51q7CeJB6wIMfM/image.png">image.png</a></p>
<div class="message_inline_image"><a href="/user_uploads/3121/91P4mtevTE51q7CeJB6wIMfM/image.png" title="image.png"><img src="/user_uploads/3121/91P4mtevTE51q7CeJB6wIMfM/image.png"></a></div>



<a name="321027812"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/321027812" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Fabian Kunze <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#321027812">(Jan 12 2023 at 20:26)</a>:</h4>
<p><span class="user-mention silent" data-user-id="417654">Martin Dvořák</span> <a href="#narrow/stream/113488-general/topic/Computational.20Complexity.20Theory/near/320542822">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="468318">Fabian Kunze</span> Can you please tell us a brief comparison with your proof in Coq?</p>
</blockquote>
<p>We use a different intermediate problem to get from n-Tape TMs to SAT: Instead of oblivious 2-tape TMs, we use 1-tape TMs, and then look at the configuration history, which is a 2-dimensional table: Line $i$ line corresponds to the tape, head position and state after $i$ computation steps, and each cell in that line is more or less one cell of the tape. Then, we express the transition function of the Turing machine as a set of 2x3 cell large "dominos", and each 2x3 cell in the configuration history must be in this set of allowed states.<br>
This means that validity of the computation is a very local property, and we can just AND that each position in the table is one of the different allowed dominos.<br>
Both the intermediate problem used by us, and by the authors of the Isabelle formalization, are  standard proof ideas sketched in text books <br>
on complexity theory.</p>



<a name="321028311"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/321028311" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Fabian Kunze <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#321028311">(Jan 12 2023 at 20:29)</a>:</h4>
<p>On a higher level, our approach of using the lambda calculus as a model of computation enables us to more or less generate the witnesses of computability (i.e., the programs computing reduction functions etc) directly from the (functional) specification of those functions in Coq. We still have to verify many Turing machines (a TM interpreting lambda-calculus, and a translation from multi-tape TMs to single-tape-TMs), but at least not all the reduction functions need to be modeled as TMs.</p>



<a name="321028899"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/321028899" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Fabian Kunze <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#321028899">(Jan 12 2023 at 20:33)</a>:</h4>
<p><span class="user-mention silent" data-user-id="437861">Praneeth Kolichala</span> <a href="#narrow/stream/113488-general/topic/Computational.20Complexity.20Theory/near/320855917">said</a>:</p>
<blockquote>
<p>I feel like I have a reasonable path towards Cook-Levin, although the machinery for circuits is still quite basic. Essentially, we need to define uniform circuit families and show that composition (which is mostly straightforward with circuits) can actually be computed in polynomial time.</p>
</blockquote>
<p>Interesting, I would not have thought that circuits are a natural path towards formalizing cook-levin, doesn't one still need another model of computation to define "uniformity" of circuit families?</p>



<a name="321063540"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/321063540" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Praneeth Kolichala <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#321063540">(Jan 13 2023 at 00:51)</a>:</h4>
<p>Yes, we still need a model of computation to define uniformity (and this is the main model of computation; it is based on  an inductive definition akin to the current <a href="https://leanprover-community.github.io/mathlib_docs/find/nat.primrec">docs#nat.primrec</a>). The main thing is that (hopefully) we avoid having to deal with TMs directly.</p>



<a name="321064179"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/321064179" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shreyas Srinivas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#321064179">(Jan 13 2023 at 00:56)</a>:</h4>
<p><span class="user-mention silent" data-user-id="437861">Praneeth Kolichala</span> <a href="#narrow/stream/113488-general/topic/Computational.20Complexity.20Theory/near/321063540">said</a>:</p>
<blockquote>
<p>Yes, we still need a model of computation to define uniformity (and this is the main model of computation; it is based on  an inductive definition akin to the current <a href="https://leanprover-community.github.io/mathlib_docs/find/nat.primrec">docs#nat.primrec</a>). The main thing is that (hopefully) we avoid having to deal with TMs directly.</p>
</blockquote>
<p>Depends on your goal. If it is to just prove variants of complexity results in your model, then this will certainly do. There will have to be suitable adaptations of statements. For instance, in the time/space hierarchy theorems. If however your goal is to build a larger library of results which the TCS community finds useful, and builds upon further, then TM and RAM are unavoidable. There are relatively few  uniform translations of complexity results from one model to another, and usually one can do better for various classes of problems. Most people in this field care about them. There was a similar discussion in another thread.</p>



<a name="321064254"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/321064254" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shreyas Srinivas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#321064254">(Jan 13 2023 at 00:57)</a>:</h4>
<p>(deleted)</p>



<a name="321064998"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/321064998" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shreyas Srinivas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#321064998">(Jan 13 2023 at 01:03)</a>:</h4>
<p>If you wish to try model agnostic approaches, then descriptive complexity might be a nice approach.</p>



<a name="321423357"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/321423357" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Carter <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#321423357">(Jan 15 2023 at 00:34)</a>:</h4>
<p><span class="user-mention silent" data-user-id="466334">Shreyas Srinivas</span> <a href="#narrow/stream/113488-general/topic/Computational.20Complexity.20Theory/near/321064998">said</a>:</p>
<blockquote>
<p>If you wish to try model agnostic approaches, then descriptive complexity might be a nice approach.</p>
</blockquote>
<p>I've actually been playing around with something in this vein (I use vein loosely here, mostly its the idea of quantifying over models) (there is another thread in Is there code for X? with some of my earlier thoughts leading up to here). Basically define a model of computation and then we can write theorems about all models.<br>
<a href="https://github.com/calcu16/lean_complexity/blob/67ebab10624a272cf7c6c2a5345d26b2096e1c55/src/complexity/basic.lean">https://github.com/calcu16/lean_complexity/blob/67ebab10624a272cf7c6c2a5345d26b2096e1c55/src/complexity/basic.lean</a><br>
For better or worse I've been trying to abuse instances so that in theory I could autogenerate a  complexity bound from the lean definitions.<br>
for example I've defined nat.mul generically on any model to have complexity based on an equivalent formulation using nat.iterate</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="n">mul_complexity</span> <span class="o">[</span><span class="n">has_encoding</span> <span class="n">m</span> <span class="n">ℕ</span><span class="o">]</span> <span class="o">[</span><span class="n">has_encoding</span> <span class="n">m</span> <span class="o">(</span><span class="n">ℕ</span><span class="bp">×</span><span class="n">ℕ</span><span class="o">)]</span>
  <span class="o">[</span><span class="n">cf</span><span class="o">:</span> <span class="n">has_complexity</span> <span class="n">m</span>
    <span class="o">(</span><span class="n">curry</span> <span class="o">(</span><span class="n">compose</span>
      <span class="n">prod.fst</span>
      <span class="o">((</span><span class="n">compose</span>
        <span class="o">(</span><span class="n">uncurry</span> <span class="o">(</span><span class="n">nat.iterate</span> <span class="o">(</span><span class="n">fork</span> <span class="o">(</span><span class="n">uncurry</span> <span class="n">nat.add</span><span class="o">)</span> <span class="n">prod.snd</span><span class="o">)))</span>
        <span class="o">(((</span><span class="n">fork</span> <span class="n">prod.snd</span> <span class="o">(</span><span class="n">fork</span> <span class="o">(</span><span class="bp">@</span><span class="n">const</span> <span class="n">ℕ</span> <span class="o">(</span><span class="n">ℕ</span><span class="bp">×</span><span class="n">ℕ</span><span class="o">)</span> <span class="mi">0</span><span class="o">)</span> <span class="n">prod.fst</span><span class="o">))))))))]:</span>
  <span class="n">has_complexity</span> <span class="n">m</span> <span class="n">nat.mul</span> <span class="o">:=</span> <span class="bp">...</span>
</code></pre></div>
<p>Then assuming you have a model with the complexities of the necessary primitives defined for a model the complexity will "pop" out.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">complexity</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="n">γ</span><span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">has_equiv</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">preorder</span> <span class="n">γ</span><span class="o">]</span> <span class="o">[</span><span class="n">has_add</span> <span class="n">γ</span><span class="o">]</span>
  <span class="o">(</span><span class="n">m</span><span class="o">:</span> <span class="n">complexity.model</span> <span class="n">α</span> <span class="n">β</span> <span class="n">γ</span><span class="o">)</span> <span class="o">{</span><span class="n">δ</span><span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">complexity.has_encodable_function</span> <span class="n">m</span> <span class="n">δ</span><span class="o">]</span>
  <span class="o">(</span><span class="n">f</span><span class="o">:</span> <span class="n">δ</span><span class="o">)</span> <span class="o">[</span><span class="n">c</span><span class="o">:</span> <span class="n">complexity.has_complexity</span> <span class="n">m</span> <span class="n">f</span><span class="o">]:</span>
  <span class="n">complexity.cost_function'</span> <span class="n">m</span> <span class="n">δ</span> <span class="o">:=</span> <span class="n">c.value.cost</span>
</code></pre></div>
<p>For example in my case I'm using a model of counting beta reductions in untyped lambda calculus and I can get a complexity for it without having to write(or cost) nat.mul myself in lambda calculus.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span><span class="o">:</span>  <span class="o">(</span><span class="n">complexity</span> <span class="n">distance_model</span> <span class="n">nat.mul</span><span class="o">)</span> <span class="bp">≤</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span><span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="o">((</span><span class="mi">30</span><span class="bp">*</span><span class="n">y</span> <span class="bp">+</span> <span class="mi">43</span><span class="o">):</span><span class="n">ℕ</span><span class="o">))</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intros</span> <span class="n">n</span> <span class="n">m</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">complexity</span><span class="o">,</span> <span class="n">complexity.cost_function.less_than_or_equal</span><span class="o">,</span> <span class="n">has_complexity.value</span><span class="o">,</span> <span class="n">fork</span><span class="o">,</span> <span class="n">const</span><span class="o">,</span> <span class="n">uncurry</span><span class="o">],</span>
  <span class="n">ring_nf</span><span class="o">,</span>
  <span class="n">norm_num</span><span class="o">,</span>
  <span class="n">induction</span> <span class="n">m</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">iteration_complexity.cost_zero</span><span class="o">],</span>
    <span class="n">ring_nf</span> <span class="o">},</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">iteration_complexity.cost_succ'</span><span class="o">,</span> <span class="n">function.iterate_succ'</span><span class="o">,</span> <span class="n">nat.mul_succ</span><span class="o">,</span> <span class="n">add_mul</span><span class="o">,</span> <span class="n">nat.add_assoc</span><span class="o">],</span>
  <span class="n">nlinarith</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>One cute thing with this approach is that you don't even need a model, you could say something basically akin to "for all models with properties X Y Z" my function will have complexity better than C.</p>
<p>One thing that's not clear to me is how to interact with general recursion using the instance strategy (or even if the instance strategy is a good idea). Additionally functions need to be written in a point-free style, so pointers on how I could get generic pattern matching against lambdas would also be of use I think.</p>



<a name="321581523"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/321581523" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#321581523">(Jan 16 2023 at 08:06)</a>:</h4>
<p>[not relevant anymore]</p>



<a name="321691751"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/321691751" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#321691751">(Jan 16 2023 at 17:46)</a>:</h4>
<p>We have discussed that we would like to meet probably twice a month.<br>
Let's vote for a regular meeting — it will happen every other week, starting with the week that we vote about!<br>
<a href="https://doodle.com/meeting/participate/id/e791Lj8b">https://doodle.com/meeting/participate/id/e791Lj8b</a></p>



<a name="322997385"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20Complexity%20Theory/near/322997385" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20Complexity.20Theory.html#322997385">(Jan 23 2023 at 11:35)</a>:</h4>
<p>Please vote. I would like to announce the time of our meetings tomorrow.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/heq.20alternative.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/heq.20alternative.html">heq alternative</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="210378589"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20alternative/near/210378589" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/heq.20alternative.html#210378589">(Sep 17 2020 at 11:59)</a>:</h4>
<p>I found the following technique useful recently and thought it might be interesting to others.<br>
Sometimes in a dependently-typed situation we have two expressions which are morally equal but we cannot directly state their equality because the types of the two sides are only propositionally equal. For my example I'll take associativity of <code>append</code> on <code>vector</code>:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">{</span><span class="n">i</span> <span class="n">j</span> <span class="n">k</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">vector</span> <span class="n">α</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">vector</span> <span class="n">α</span> <span class="n">j</span><span class="o">)</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">vector</span> <span class="n">α</span> <span class="n">k</span><span class="o">)</span>

<span class="c1">-- doesn&#39;t typecheck</span>
<span class="c1">-- lemma bad_append : (x.append y).append z = x.append (y.append z) := ...</span>
<span class="c">/-</span><span class="cm"></span>
<span class="cm">error: type mismatch at application</span>
<span class="cm">  (x.append y).append z = x.append (y.append z)</span>
<span class="cm">term</span>
<span class="cm">  x.append (y.append z)</span>
<span class="cm">has type</span>
<span class="cm">  vector α (i + (j + k))</span>
<span class="cm">but is expected to have type</span>
<span class="cm">  vector α (i + j + k)</span>
<span class="cm">-/</span>
</code></pre></div>



<a name="210378730"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20alternative/near/210378730" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/heq.20alternative.html#210378730">(Sep 17 2020 at 12:00)</a>:</h4>
<p>There are a couple of ways to deal with this, including using heterogeneous equality or inserting a cast of some kind. Here is another one.  Often in the situation where you'd like to apply this equality, the term <code>(x.append y).append z</code> appears in a context that could accept a vector of any length. Then, you can apply a lemma of the following form:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">subtype</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">vector</span>
<span class="kn">import</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">basic</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">{</span><span class="n">i</span> <span class="n">j</span> <span class="n">k</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">vector</span> <span class="n">α</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">vector</span> <span class="n">α</span> <span class="n">j</span><span class="o">)</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">vector</span> <span class="n">α</span> <span class="n">k</span><span class="o">)</span>

<span class="kn">lemma</span> <span class="n">good_append</span> <span class="o">{</span><span class="n">ι</span> <span class="o">:</span> <span class="n">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">},</span> <span class="n">vector</span> <span class="n">α</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">ι</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">C</span> <span class="o">((</span><span class="n">x</span><span class="bp">.</span><span class="n">append</span> <span class="n">y</span><span class="o">)</span><span class="bp">.</span><span class="n">append</span> <span class="n">z</span><span class="o">)</span> <span class="bp">=</span> <span class="n">C</span> <span class="o">(</span><span class="n">x</span><span class="bp">.</span><span class="n">append</span> <span class="o">(</span><span class="n">y</span><span class="bp">.</span><span class="n">append</span> <span class="n">z</span><span class="o">))</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="k">have</span> <span class="n">A</span> <span class="o">:</span> <span class="o">(</span><span class="n">i</span> <span class="bp">+</span> <span class="n">j</span><span class="o">)</span> <span class="bp">+</span> <span class="n">k</span> <span class="bp">=</span> <span class="n">i</span> <span class="bp">+</span> <span class="o">(</span><span class="n">j</span> <span class="bp">+</span> <span class="n">k</span><span class="o">)</span> <span class="o">:=</span> <span class="n">nat</span><span class="bp">.</span><span class="n">add_assoc</span> <span class="n">i</span> <span class="n">j</span> <span class="n">k</span><span class="o">,</span>
  <span class="n">congr&#39;</span> <span class="mi">1</span><span class="o">,</span> <span class="o">{</span> <span class="n">exact</span> <span class="n">A</span> <span class="o">},</span>
  <span class="k">have</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">m</span><span class="o">)</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">vector</span> <span class="n">α</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">w</span> <span class="o">:</span> <span class="n">vector</span> <span class="n">α</span> <span class="n">m</span><span class="o">),</span>
    <span class="n">v</span> <span class="bp">==</span> <span class="n">w</span> <span class="bp">↔</span> <span class="n">v</span><span class="bp">.</span><span class="n">to_list</span> <span class="bp">=</span> <span class="n">w</span><span class="bp">.</span><span class="n">to_list</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rintros</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">rfl</span> <span class="n">v</span> <span class="n">w</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">heq_iff_eq</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">subtype</span><span class="bp">.</span><span class="n">ext_iff</span> <span class="o">},</span>
  <span class="n">rw</span> <span class="n">this</span> <span class="n">A</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">vector</span><span class="bp">.</span><span class="n">to_list_append</span><span class="o">],</span>
  <span class="n">apply</span> <span class="n">list</span><span class="bp">.</span><span class="n">append_assoc</span>
<span class="kn">end</span>
</code></pre></div>



<a name="210378971"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20alternative/near/210378971" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/heq.20alternative.html#210378971">(Sep 17 2020 at 12:03)</a>:</h4>
<p>For example <code>C</code> might be something like <code>is_palindrome : Π {n : ℕ}, vector α n → Prop</code>. Or in other situations, <code>C</code> might be some general property like continuity. Then you can rewrite under <code>C</code> using something like <code>refine (good_append x y z).mpr _</code>. (<code>rw</code> gets confused by the form of the lemma, and couldn't know where to rewrite.)</p>



<a name="210379436"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20alternative/near/210379436" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/heq.20alternative.html#210379436">(Sep 17 2020 at 12:07)</a>:</h4>
<p>Could we have some sort of <code>hrw</code> (heterogenous rw) that could make using any of these tricks easier?</p>



<a name="210387197"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20alternative/near/210387197" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/heq.20alternative.html#210387197">(Sep 17 2020 at 13:14)</a>:</h4>
<p>Is that <code>heq</code> <code>have</code> thing just missing API? I avoid heq like the plague.</p>



<a name="210387637"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20alternative/near/210387637" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/heq.20alternative.html#210387637">(Sep 17 2020 at 13:17)</a>:</h4>
<p>I think this is equivalent to the statement that if you tuple a vector with its length you get something you can state an equality about</p>



<a name="210387730"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20alternative/near/210387730" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/heq.20alternative.html#210387730">(Sep 17 2020 at 13:18)</a>:</h4>
<p>Is there a similar trick that can be done where <code>\iota</code> is a family of types that depends on a vector? It seems that <code>heq</code> would still cause issues in that case.</p>



<a name="210387872"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20alternative/near/210387872" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/heq.20alternative.html#210387872">(Sep 17 2020 at 13:19)</a>:</h4>
<p>that is, <code>⟨(i + j) + k, (x.append y).append z⟩ = ⟨i + (j + k), x.append (y.append z)⟩</code> is an equality in <code>Σ n, vector A n</code></p>



<a name="210387902"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20alternative/near/210387902" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/heq.20alternative.html#210387902">(Sep 17 2020 at 13:19)</a>:</h4>
<p>whch is of course true because that's equivalent to <code>list.append_assoc</code></p>



<a name="210387994"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20alternative/near/210387994" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/heq.20alternative.html#210387994">(Sep 17 2020 at 13:20)</a>:</h4>
<p>Well... it's a combination of <code>list.append</code> and <code>add_assoc</code> right?</p>



<a name="210388086"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20alternative/near/210388086" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/heq.20alternative.html#210388086">(Sep 17 2020 at 13:21)</a>:</h4>
<p>I mean that <code>Σ n, vector A n</code> is isomorphic to <code>list A</code>, and the two sides of that are mapped by the isomorphism to <code>(x ++ y) ++ z</code> and <code>x ++ (y ++ z)</code></p>



<a name="210388107"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20alternative/near/210388107" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/heq.20alternative.html#210388107">(Sep 17 2020 at 13:21)</a>:</h4>
<p>Oh I see.</p>



<a name="210388943"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20alternative/near/210388943" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/heq.20alternative.html#210388943">(Sep 17 2020 at 13:27)</a>:</h4>
<p>Right, and one way to look at it is that <code>sigma.mk</code> is the universal possible choice for <code>C</code>--but when you want to apply this lemma you probably don't have a <code>sigma.mk</code> in the term waiting to be rewritten, so it's more convenient to use in the form with <code>C</code>.</p>



<a name="210389245"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20alternative/near/210389245" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/heq.20alternative.html#210389245">(Sep 17 2020 at 13:29)</a>:</h4>
<p><span class="user-mention silent" data-user-id="243562">Adam Topaz</span> <a href="#narrow/stream/113488-general/topic/heq.20alternative/near/210387730">said</a>:</p>
<blockquote>
<p>Is there a similar trick that can be done where <code>\iota</code> is a family of types that depends on a vector? It seems that <code>heq</code> would still cause issues in that case.</p>
</blockquote>
<p>Yeah, I actually tried to do this when I wrote down the type of the lemma for the first time, and then Lean told me it wouldn't work--the purpose of <code>C</code> is to hide the problematic type index, so it can't appear in the result type of <code>C</code>.</p>



<a name="210389992"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20alternative/near/210389992" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/heq.20alternative.html#210389992">(Sep 17 2020 at 13:34)</a>:</h4>
<p>In my case the type doesn't change (as some might guess my real <code>C</code> is the property of a subset of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>R</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">R^n</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span> being definable in some structure, which is a <code>Prop</code>), so I didn't think about what one could do if it does change.</p>



<a name="210452306"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20alternative/near/210452306" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/heq.20alternative.html#210452306">(Sep 17 2020 at 21:14)</a>:</h4>
<p>Nice trick! <br>
I still feel like the lemma should be with <code>heq</code>, and that there should be tooling to make it easy to go from the <code>heq</code> statement to the lemma <code>good_append</code>.</p>



<a name="213656799"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20alternative/near/213656799" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/heq.20alternative.html#213656799">(Oct 17 2020 at 15:27)</a>:</h4>
<p>Here's yet another alternative which I haven't really tried to use for anything, but seems sensible for theoretical reasons:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic.basic</span>

<span class="c">/-</span><span class="cm"></span>
<span class="cm">dependent equality / dependent path / "pathover" from HoTT/cubical type theory</span>
<span class="cm">-/</span>

<span class="kd">inductive</span> <span class="n">deq</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">:</span>
  <span class="bp">Π</span> <span class="o">{</span><span class="n">a</span> <span class="n">a'</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a'</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">C</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">x'</span> <span class="o">:</span> <span class="n">C</span> <span class="n">a'</span><span class="o">),</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">refl</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">C</span> <span class="n">a</span><span class="o">)</span> <span class="o">:</span> <span class="n">deq</span> <span class="o">(</span><span class="n">eq.refl</span> <span class="n">a</span><span class="o">)</span> <span class="n">x</span> <span class="n">x</span>

<span class="kn">attribute</span> <span class="o">[</span><span class="n">refl</span><span class="o">]</span> <span class="n">deq.refl</span>

<span class="kd">notation</span> <span class="n">x</span> <span class="bp">`</span> <span class="bp">=</span><span class="o">[</span><span class="bp">`</span><span class="o">:</span><span class="mi">50</span> <span class="n">e</span><span class="o">:</span><span class="mi">50</span> <span class="bp">`</span><span class="o">]</span> <span class="bp">`</span><span class="o">:</span><span class="mi">50</span> <span class="n">x'</span><span class="o">:</span><span class="mi">50</span> <span class="o">:=</span> <span class="n">deq</span> <span class="n">e</span> <span class="n">x</span> <span class="n">x'</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">}</span>

<span class="kd">@[symm]</span> <span class="kd">lemma</span> <span class="n">deq.symm</span> <span class="o">{</span><span class="n">a</span> <span class="n">a'</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a'</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">C</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">x'</span> <span class="o">:</span> <span class="n">C</span> <span class="n">a'</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">x</span> <span class="bp">=</span><span class="o">[</span><span class="n">e</span><span class="o">]</span> <span class="n">x'</span> <span class="bp">→</span> <span class="n">x'</span> <span class="bp">=</span><span class="o">[</span><span class="n">e.symm</span><span class="o">]</span> <span class="n">x</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rintro</span> <span class="o">⟨⟩,</span>
  <span class="n">refl</span>
<span class="kd">end</span>

<span class="kd">@[trans]</span> <span class="kd">lemma</span> <span class="n">deq.trans</span> <span class="o">{</span><span class="n">a</span> <span class="n">a'</span> <span class="n">a''</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a'</span><span class="o">)</span> <span class="o">(</span><span class="n">e'</span> <span class="o">:</span> <span class="n">a'</span> <span class="bp">=</span> <span class="n">a''</span><span class="o">)</span>
  <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">C</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">x'</span> <span class="o">:</span> <span class="n">C</span> <span class="n">a'</span><span class="o">)</span> <span class="o">(</span><span class="n">x''</span> <span class="o">:</span> <span class="n">C</span> <span class="n">a''</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">x</span> <span class="bp">=</span><span class="o">[</span><span class="n">e</span><span class="o">]</span> <span class="n">x'</span> <span class="bp">→</span> <span class="n">x'</span> <span class="bp">=</span><span class="o">[</span><span class="n">e'</span><span class="o">]</span> <span class="n">x''</span> <span class="bp">→</span> <span class="n">x</span> <span class="bp">=</span><span class="o">[</span><span class="n">e.trans</span> <span class="n">e'</span><span class="o">]</span> <span class="n">x''</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rintros</span> <span class="o">⟨⟩</span> <span class="o">⟨⟩,</span>
  <span class="n">refl</span>
<span class="kd">end</span>
</code></pre></div>



<a name="213656936"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20alternative/near/213656936" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/heq.20alternative.html#213656936">(Oct 17 2020 at 15:30)</a>:</h4>
<p>Cool. I guess the <code>rinto</code> is necessary to see past the constructor of the inductive type?</p>



<a name="213657019"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20alternative/near/213657019" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/heq.20alternative.html#213657019">(Oct 17 2020 at 15:32)</a>:</h4>
<p>yes, it's just short for <code>cases</code></p>



<a name="213657025"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20alternative/near/213657025" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/heq.20alternative.html#213657025">(Oct 17 2020 at 15:32)</a>:</h4>
<p>But to really make this cubical, we would need <code>deq</code> over <code>deq</code>,  etc...</p>



<a name="213657043"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20alternative/near/213657043" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/heq.20alternative.html#213657043">(Oct 17 2020 at 15:33)</a>:</h4>
<p><code>deq</code> over <code>deq</code> is not really any more cubical, but it is a separate issue I'm a bit confused about</p>



<a name="213657050"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20alternative/near/213657050" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/heq.20alternative.html#213657050">(Oct 17 2020 at 15:34)</a>:</h4>
<p>Isn't it a path dependent on a path?</p>



<a name="213657092"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20alternative/near/213657092" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/heq.20alternative.html#213657092">(Oct 17 2020 at 15:34)</a>:</h4>
<p>A path dependent on a path is still a path</p>



<a name="213657096"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20alternative/near/213657096" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/heq.20alternative.html#213657096">(Oct 17 2020 at 15:34)</a>:</h4>
<p>I think you're thinking of a path <em>in</em> a path type</p>



<a name="213657111"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20alternative/near/213657111" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/heq.20alternative.html#213657111">(Oct 17 2020 at 15:35)</a>:</h4>
<p>(I'm assuming by <code>deq</code> over <code>deq</code> you meant something like <code>e : a = a'</code>, <code>f : x =[e] x'</code>, then you want some kind of <code>y =[f] y'</code>)</p>



<a name="213657160"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20alternative/near/213657160" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/heq.20alternative.html#213657160">(Oct 17 2020 at 15:36)</a>:</h4>
<p>that just corresponds to a longer telescope/context</p>



<a name="213657172"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20alternative/near/213657172" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/heq.20alternative.html#213657172">(Oct 17 2020 at 15:37)</a>:</h4>
<p>like a path <code>\I -&gt; Sigma (a : A) (b : B a), C a b</code> (where <code>\I</code> is the interval)</p>



<a name="213657177"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20alternative/near/213657177" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/heq.20alternative.html#213657177">(Oct 17 2020 at 15:37)</a>:</h4>
<p>while a higher cube is <code>\I -&gt; \I -&gt; A</code></p>



<a name="213657190"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20alternative/near/213657190" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/heq.20alternative.html#213657190">(Oct 17 2020 at 15:37)</a>:</h4>
<p>er, <code>Pi</code> wasn't right--something more like <code>Sigma</code>, but really more like <code>a : A, b : B a |- \I -&gt; C a b</code></p>



<a name="213657227"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20alternative/near/213657227" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/heq.20alternative.html#213657227">(Oct 17 2020 at 15:38)</a>:</h4>
<p>ok even this is wrong</p>



<a name="213657241"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20alternative/near/213657241" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/heq.20alternative.html#213657241">(Oct 17 2020 at 15:39)</a>:</h4>
<p><code>a</code> and <code>b</code> should also depend on an interval variable... but hopefully you get the idea</p>



<a name="213657433"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20alternative/near/213657433" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/heq.20alternative.html#213657433">(Oct 17 2020 at 15:44)</a>:</h4>
<p>Explicitly, this is the next entry in the sequence</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">ddeq</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">D</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">C</span> <span class="n">a</span> <span class="bp">→</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">:</span>
  <span class="bp">Π</span> <span class="o">{</span><span class="n">a</span> <span class="n">a'</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">e</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a'</span><span class="o">}</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">C</span> <span class="n">a</span><span class="o">}</span> <span class="o">{</span><span class="n">x'</span> <span class="o">:</span> <span class="n">C</span> <span class="n">a'</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span><span class="o">[</span><span class="n">e</span><span class="o">]</span> <span class="n">x'</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">D</span> <span class="n">a</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">y'</span> <span class="o">:</span> <span class="n">D</span> <span class="n">a'</span> <span class="n">x'</span><span class="o">),</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">refl</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">C</span> <span class="n">a</span><span class="o">}</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">D</span> <span class="n">a</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span> <span class="n">ddeq</span> <span class="o">(</span><span class="n">deq.refl</span> <span class="n">x</span><span class="o">)</span> <span class="n">y</span> <span class="n">y</span>
</code></pre></div>



<a name="213657487"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20alternative/near/213657487" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/heq.20alternative.html#213657487">(Oct 17 2020 at 15:45)</a>:</h4>
<p>I'm just being naive and thinking of a path of paths as a cube.</p>



<a name="213657490"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20alternative/near/213657490" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/heq.20alternative.html#213657490">(Oct 17 2020 at 15:45)</a>:</h4>
<p>But yes I get the idea</p>



<a name="213657550"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20alternative/near/213657550" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/heq.20alternative.html#213657550">(Oct 17 2020 at 15:47)</a>:</h4>
<p>Right, this one isn't a path of paths, it's a path whose image under the fibration/display map corresponding to <code>C</code> is the given path <code>e</code></p>



<a name="213657553"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20alternative/near/213657553" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/heq.20alternative.html#213657553">(Oct 17 2020 at 15:47)</a>:</h4>
<p>Forgetting cubical stuff, it seems that to really make this behave like equality we would need the <code>ddeq</code> you defined, and a <code>dddeq</code> and a <code>ddddeq</code> and ...</p>



<a name="213657554"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20alternative/near/213657554" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/heq.20alternative.html#213657554">(Oct 17 2020 at 15:47)</a>:</h4>
<p>or in the <code>ddeq</code>, three paths, each one lying over the next (previous?)</p>



<a name="213657617"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20alternative/near/213657617" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/heq.20alternative.html#213657617">(Oct 17 2020 at 15:49)</a>:</h4>
<p>Oh you mean like the Kan filling condition for cubes? (I don't remember the actual name)</p>



<a name="213657624"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20alternative/near/213657624" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/heq.20alternative.html#213657624">(Oct 17 2020 at 15:49)</a>:</h4>
<p>Amusingly, this is (at least spiritually) related to the other conversation about the topology on an sigma type</p>



<a name="213668025"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20alternative/near/213668025" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/heq.20alternative.html#213668025">(Oct 17 2020 at 19:52)</a>:</h4>
<p>I built the pathover library for Lean 2 HoTT, and I was also worried about needing ddeq, dddeq, etc. (and in HoTT it's worse because then you also need square, dsquare, ddsquare, ..., cube, dcube, ..., ...). However, if you defined <code>ddeq</code>, depending on a path <code>p : x = x'</code> and a pathover <code>q : y =[p] y'</code> and write it as something as <code>z =[p][q] z'</code>, then you can prove that it's equivalent to <code>z =[(p, q)] z'</code>, where <code>(p, q)</code> is a path <code>(x, y) = (x', y')</code> in the sigma-type, built from <code>p</code> and <code>q</code>. And then it's easier to just use <code>z =[(p, q)] z'</code> in the first place, and then you never have to define <code>deq</code>.</p>



<a name="213669928"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20alternative/near/213669928" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/heq.20alternative.html#213669928">(Oct 17 2020 at 20:42)</a>:</h4>
<p>Is <code>deq</code> different from equality of sigma types?  I was experimenting with this, and you can at least implement the recursor for <span class="user-mention" data-user-id="110032">@Reid Barton</span>'s <code>deq</code> with it.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">def</span> <span class="n">deq</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">a</span> <span class="n">a'</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">C</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">x'</span> <span class="o">:</span> <span class="n">C</span> <span class="n">a'</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="n">psigma.mk</span> <span class="n">a</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">psigma.mk</span> <span class="n">a'</span> <span class="n">x'</span>

<span class="kd">infix</span> <span class="bp">`</span> <span class="bp">===</span> <span class="bp">`</span><span class="o">:</span><span class="mi">50</span> <span class="o">:=</span> <span class="n">deq</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">}</span>

<span class="kd">@[refl]</span> <span class="kd">lemma</span> <span class="n">deq.refl</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">C</span> <span class="n">a</span><span class="o">}</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">===</span> <span class="n">x</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">exact</span> <span class="n">rfl</span>  <span class="c1">-- "not a rfl lemma"</span>
<span class="kd">@[symm]</span> <span class="kd">lemma</span> <span class="n">deq.symm</span> <span class="o">{</span><span class="n">a</span> <span class="n">a'</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">C</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">x'</span> <span class="o">:</span> <span class="n">C</span> <span class="n">a'</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">===</span> <span class="n">x'</span> <span class="bp">→</span> <span class="n">x'</span> <span class="bp">===</span> <span class="n">x</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">rintro</span> <span class="o">⟨⟩,</span> <span class="n">refl</span><span class="o">,</span> <span class="o">}</span>
<span class="kd">@[trans]</span> <span class="kd">lemma</span> <span class="n">deq.trans</span> <span class="o">{</span><span class="n">a</span> <span class="n">a'</span> <span class="n">a''</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">C</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">x'</span> <span class="o">:</span> <span class="n">C</span> <span class="n">a'</span><span class="o">)</span> <span class="o">(</span><span class="n">x''</span> <span class="o">:</span> <span class="n">C</span> <span class="n">a''</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">x</span> <span class="bp">===</span> <span class="n">x'</span> <span class="bp">→</span> <span class="n">x'</span> <span class="bp">===</span> <span class="n">x''</span> <span class="bp">→</span> <span class="n">x</span> <span class="bp">===</span> <span class="n">x''</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">rintro</span> <span class="o">⟨⟩</span> <span class="o">⟨⟩,</span> <span class="n">refl</span><span class="o">,</span> <span class="o">}</span>

<span class="kd">lemma</span> <span class="n">deq.index_eq</span> <span class="o">{</span><span class="n">a</span> <span class="n">a'</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">C</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">x'</span> <span class="o">:</span> <span class="n">C</span> <span class="n">a'</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">x</span> <span class="bp">===</span> <span class="n">x'</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a'</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">rintro</span> <span class="o">⟨⟩,</span> <span class="n">refl</span> <span class="o">}</span>

<span class="kd">lemma</span> <span class="n">deq.value_eq</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="n">x'</span> <span class="o">:</span> <span class="n">C</span> <span class="n">a</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">x</span> <span class="bp">===</span> <span class="n">x'</span> <span class="bp">→</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x'</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">rintro</span> <span class="o">⟨⟩,</span> <span class="n">refl</span> <span class="o">}</span>

<span class="kd">lemma</span> <span class="n">deq.value_eq'</span> <span class="o">{</span><span class="n">a</span> <span class="n">a'</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">C</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">x'</span> <span class="o">:</span> <span class="n">C</span> <span class="n">a'</span><span class="o">)</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a'</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">x</span> <span class="bp">===</span> <span class="n">x'</span> <span class="bp">→</span> <span class="o">(</span><span class="n">eq.rec</span> <span class="n">x</span> <span class="n">e</span> <span class="o">:</span> <span class="n">C</span> <span class="n">a'</span><span class="o">)</span> <span class="bp">=</span> <span class="n">x'</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">rintro</span> <span class="o">⟨⟩,</span> <span class="n">refl</span> <span class="o">}</span>

<span class="kd">lemma</span> <span class="n">deq.to_heq</span> <span class="o">{</span><span class="n">a</span> <span class="n">a'</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">C</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">x'</span> <span class="o">:</span> <span class="n">C</span> <span class="n">a'</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">x</span> <span class="bp">===</span> <span class="n">x'</span> <span class="bp">→</span> <span class="n">x</span> <span class="bp">==</span> <span class="n">x'</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">deq</span><span class="o">]</span>

<span class="kd">def</span> <span class="n">deq.rec</span> <span class="o">{</span><span class="n">C'</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">a</span> <span class="n">a'</span> <span class="o">:</span> <span class="n">α</span><span class="o">},</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a'</span> <span class="bp">→</span> <span class="n">C</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">C</span> <span class="n">a'</span> <span class="bp">→</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">}</span>
  <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">C</span> <span class="n">a</span><span class="o">),</span> <span class="n">C'</span> <span class="n">rfl</span> <span class="n">x</span> <span class="n">x</span><span class="o">)</span>
  <span class="o">{</span><span class="n">a</span> <span class="n">a'</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">e</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a'</span><span class="o">}</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">C</span> <span class="n">a</span><span class="o">}</span> <span class="o">{</span><span class="n">x'</span> <span class="o">:</span> <span class="n">C</span> <span class="n">a'</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">x</span> <span class="bp">===</span> <span class="n">x'</span> <span class="bp">→</span> <span class="n">C'</span> <span class="n">e</span> <span class="n">x</span> <span class="n">x'</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">subst</span> <span class="n">e</span><span class="o">,</span> <span class="n">rintro</span> <span class="o">⟨⟩,</span> <span class="n">apply</span> <span class="n">f</span> <span class="o">}</span>

<span class="kd">lemma</span> <span class="n">deq.rec_rule</span> <span class="o">{</span><span class="n">C'</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">a</span> <span class="n">a'</span> <span class="o">:</span> <span class="n">α</span><span class="o">},</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a'</span> <span class="bp">→</span> <span class="n">C</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">C</span> <span class="n">a'</span> <span class="bp">→</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">}</span>
  <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">C</span> <span class="n">a</span><span class="o">),</span> <span class="n">C'</span> <span class="n">rfl</span> <span class="n">x</span> <span class="n">x</span><span class="o">)</span>
  <span class="o">{</span><span class="n">a</span> <span class="n">a'</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">e</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a'</span><span class="o">}</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">C</span> <span class="n">a</span><span class="o">}</span> <span class="o">{</span><span class="n">x'</span> <span class="o">:</span> <span class="n">C</span> <span class="n">a'</span><span class="o">}</span> <span class="o">:</span>
  <span class="bp">@</span><span class="n">deq.rec</span> <span class="n">α</span> <span class="n">C</span> <span class="bp">@</span><span class="n">C'</span> <span class="bp">@</span><span class="n">f</span> <span class="n">a</span> <span class="n">a</span> <span class="n">rfl</span> <span class="n">x</span> <span class="n">x</span> <span class="n">deq.refl</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">rfl</span>
</code></pre></div>



<a name="213673963"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20alternative/near/213673963" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/heq.20alternative.html#213673963">(Oct 17 2020 at 22:34)</a>:</h4>
<p>If you have proof irrelevance like in Lean 3 they are the same. <br>
In HoTT they are not quite the same, but closely related:<br>
<a href="https://github.com/leanprover/lean2/blob/8072fdf9a0b31abb9d43ab894d7a858639e20ed7/hott/types/sigma.hlean#L109-L110">https://github.com/leanprover/lean2/blob/8072fdf9a0b31abb9d43ab894d7a858639e20ed7/hott/types/sigma.hlean#L109-L110</a><br>
A path is in a sigma type consists of a path between the first components and then a path between the second components over the first path.</p>



<a name="213689411"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20alternative/near/213689411" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/heq.20alternative.html#213689411">(Oct 18 2020 at 05:25)</a>:</h4>
<p>I like Kyle's version of deq, it looks strictly more useful than <code>heq</code></p>



<a name="213691656"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20alternative/near/213691656" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/heq.20alternative.html#213691656">(Oct 18 2020 at 06:27)</a>:</h4>
<p>I think the type of <code>deq</code> is less convenient to work with than <code>heq</code>: the elaborator will not always be able to figure out what <code>C</code> is from the types of <code>x</code> and <code>x'</code>. In the hott3 library we had to make the family of pathovers explicit, because the elaborator of Lean 3 too often couldn't figure out the type family (in Lean 2 this was not necessary).</p>



<a name="213691835"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20alternative/near/213691835" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/heq.20alternative.html#213691835">(Oct 18 2020 at 06:33)</a>:</h4>
<p>That's probably true. I often use sigma type equalities in lieu of <code>deq</code> (as mentioned earlier in this thread), but you can almost never avoid writing the type family</p>



<a name="213691897"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20alternative/near/213691897" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/heq.20alternative.html#213691897">(Oct 18 2020 at 06:35)</a>:</h4>
<p>Why do you think <code>deq</code> is more useful than <code>heq</code>? Isn't <code>deq</code> just a special case of <code>heq</code>, and you can prove all lemmas about <code>deq</code> for <code>heq</code>?</p>



<a name="213691959"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20alternative/near/213691959" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/heq.20alternative.html#213691959">(Oct 18 2020 at 06:37)</a>:</h4>
<p><code>heq</code> is a special case of <code>deq</code> (with the identity <code>C</code>), not the other way around afaict</p>



<a name="213692081"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20alternative/near/213692081" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/heq.20alternative.html#213692081">(Oct 18 2020 at 06:41)</a>:</h4>
<p>Oh, you're right. From <code>deq x x'</code> you get that <code>a = a'</code>, which you don't get from <code>x == x'</code>. Yeah, that sounds pretty useful.</p>



<a name="213709491"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20alternative/near/213709491" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/heq.20alternative.html#213709491">(Oct 18 2020 at 14:47)</a>:</h4>
<p>The difference between my original <code>deq</code> and Kyle's version is indexing vs bundling--in Lean, everything in sight is a Prop and so there seems to be no disadvantage to Kyle's bundled version.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/unfolding.20definitions.20from.20type.20class.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/unfolding.20definitions.20from.20type.20class.html">unfolding definitions from type class</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="263945591"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unfolding%20definitions%20from%20type%20class/near/263945591" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/unfolding.20definitions.20from.20type.20class.html#263945591">(Dec 07 2021 at 00:48)</a>:</h4>
<p>Say I have a goal like <code>⊢ f x</code> where <code>f</code> is coming from a type class instance. How do I unfold the definition of <code>f</code> from the type class?</p>



<a name="263945849"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unfolding%20definitions%20from%20type%20class/near/263945849" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/unfolding.20definitions.20from.20type.20class.html#263945849">(Dec 07 2021 at 00:52)</a>:</h4>
<p>Generally the answer is to not unfold, and use and/or build the API for <code>f</code> instead. If you must unfold, you can <code>dsimp [f]</code> or <code>unfold f</code> or <code>delta f</code>.</p>



<a name="263946142"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unfolding%20definitions%20from%20type%20class/near/263946142" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/unfolding.20definitions.20from.20type.20class.html#263946142">(Dec 07 2021 at 00:56)</a>:</h4>
<p>I'm building the API for <code>f</code>, so that's why I need to unfold. Unfortunately, none of your suggestions worked.</p>



<a name="263946698"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unfolding%20definitions%20from%20type%20class/near/263946698" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/unfolding.20definitions.20from.20type.20class.html#263946698">(Dec 07 2021 at 01:03)</a>:</h4>
<p>It would be easier to help if you gave a more complete example, of a specific f and example that leaves you in that goal state, and what exactly you'd like the goal to look like after</p>



<a name="263946717"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unfolding%20definitions%20from%20type%20class/near/263946717" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/unfolding.20definitions.20from.20type.20class.html#263946717">(Dec 07 2021 at 01:03)</a>:</h4>
<p>Let me try to make a toy example.</p>



<a name="263947852"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unfolding%20definitions%20from%20type%20class/near/263947852" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/unfolding.20definitions.20from.20type.20class.html#263947852">(Dec 07 2021 at 01:20)</a>:</h4>
<p>Well, my toy example has the goal with the <code>f</code> expanded. Dang it.</p>



<a name="263948098"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unfolding%20definitions%20from%20type%20class/near/263948098" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/unfolding.20definitions.20from.20type.20class.html#263948098">(Dec 07 2021 at 01:24)</a>:</h4>
<p>Here's the real code:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">order.filter.ultrafilter</span>
<span class="kn">import</span> <span class="n">order.filter.partial</span>
<span class="kn">import</span> <span class="n">algebra.support</span>

<span class="kd">noncomputable theory</span>
<span class="kn">open</span> <span class="n">set</span> <span class="n">filter</span> <span class="n">classical</span>
<span class="n">open_locale</span> <span class="n">classical</span> <span class="n">filter</span>
<span class="kn">open</span> <span class="n">has_sup</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>

<span class="kd">class</span> <span class="n">convergence_space</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">conv</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">a</span> <span class="bp">-&gt;</span> <span class="n">a</span> <span class="bp">-&gt;</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="o">(</span><span class="n">pure_conv</span> <span class="o">:</span> <span class="k">forall</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">a</span><span class="o">},</span> <span class="n">conv</span> <span class="o">(</span><span class="n">pure</span> <span class="n">x</span><span class="o">)</span> <span class="n">x</span><span class="o">)</span>
<span class="o">(</span><span class="n">le_conv</span> <span class="o">:</span> <span class="k">forall</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">a</span><span class="o">}</span> <span class="o">{</span><span class="n">l</span> <span class="n">l'</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">a</span><span class="o">},</span> <span class="n">l</span> <span class="bp">&lt;=</span> <span class="n">l'</span> <span class="bp">-&gt;</span> <span class="n">conv</span> <span class="n">l'</span> <span class="n">x</span> <span class="bp">-&gt;</span> <span class="n">conv</span> <span class="n">l</span> <span class="n">x</span><span class="o">)</span> <span class="c1">-- l &lt;= l' means l' ⊆ l</span>

<span class="kd">class</span> <span class="n">kent_convergence_space</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">convergence_space</span> <span class="n">a</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">kent_conv</span> <span class="o">:</span> <span class="k">forall</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">a</span><span class="o">}</span> <span class="o">{</span><span class="n">l</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">a</span><span class="o">},</span> <span class="n">conv</span> <span class="n">l</span> <span class="n">x</span> <span class="bp">-&gt;</span> <span class="n">conv</span> <span class="o">(</span><span class="n">sup</span> <span class="n">l</span> <span class="o">(</span><span class="n">pure</span> <span class="n">x</span><span class="o">))</span> <span class="n">x</span><span class="o">)</span>

<span class="kd">class</span> <span class="n">limit_space</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">kent_convergence_space</span> <span class="n">a</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">sup_conv</span> <span class="o">:</span> <span class="k">forall</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">a</span><span class="o">}</span> <span class="o">{</span><span class="n">l</span> <span class="n">l'</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">a</span><span class="o">},</span> <span class="n">conv</span> <span class="n">l</span> <span class="n">x</span> <span class="bp">-&gt;</span> <span class="n">conv</span> <span class="n">l'</span> <span class="n">x</span> <span class="bp">-&gt;</span> <span class="n">conv</span> <span class="o">(</span><span class="n">sup</span> <span class="n">l</span> <span class="n">l'</span><span class="o">)</span> <span class="n">x</span><span class="o">)</span> <span class="c1">-- l ⊔ l' means l ∩ l'</span>

<span class="kn">open</span> <span class="n">convergence_space</span>
<span class="kn">open</span> <span class="n">kent_convergence_space</span>
<span class="kn">open</span> <span class="n">limit_space</span>

<span class="kd">def</span> <span class="n">induced</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">-&gt;</span> <span class="n">b</span><span class="o">)</span> <span class="o">[</span><span class="n">convergence_space</span> <span class="n">b</span><span class="o">]</span> <span class="o">:</span> <span class="n">convergence_space</span> <span class="n">a</span> <span class="o">:=</span> <span class="o">{</span>
  <span class="n">conv</span> <span class="o">:=</span> <span class="k">fun</span> <span class="n">l</span> <span class="n">x</span><span class="o">,</span> <span class="n">conv</span> <span class="o">(</span><span class="n">map</span> <span class="n">f</span> <span class="n">l</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">),</span>
  <span class="n">pure_conv</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">filter.map_pure</span><span class="o">,</span> <span class="n">pure_conv</span><span class="o">],</span>
  <span class="n">le_conv</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="k">assume</span> <span class="n">x</span> <span class="o">:</span> <span class="n">a</span><span class="o">,</span>
    <span class="k">assume</span> <span class="n">l</span> <span class="n">l'</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">a</span><span class="o">,</span>
    <span class="k">assume</span> <span class="o">:</span> <span class="n">l</span> <span class="bp">&lt;=</span> <span class="n">l'</span><span class="o">,</span>
    <span class="k">assume</span> <span class="o">:</span> <span class="n">conv</span> <span class="o">(</span><span class="n">map</span> <span class="n">f</span> <span class="n">l'</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">),</span>
    <span class="k">have</span> <span class="o">:</span> <span class="n">map</span> <span class="n">f</span> <span class="n">l</span> <span class="bp">&lt;=</span> <span class="n">map</span> <span class="n">f</span> <span class="n">l'</span><span class="o">,</span>
      <span class="n">apply</span> <span class="n">map_mono</span> <span class="o">(</span><span class="kd">by</span> <span class="n">assumption</span> <span class="o">:</span> <span class="n">l</span> <span class="bp">&lt;=</span> <span class="n">l'</span><span class="o">),</span>
    <span class="n">apply</span> <span class="n">le_conv</span>
      <span class="o">(</span><span class="kd">by</span> <span class="n">assumption</span> <span class="o">:</span> <span class="n">map</span> <span class="n">f</span> <span class="n">l</span> <span class="bp">&lt;=</span> <span class="n">map</span> <span class="n">f</span> <span class="n">l'</span><span class="o">)</span>
      <span class="o">(</span><span class="kd">by</span> <span class="n">assumption</span> <span class="o">:</span> <span class="n">conv</span> <span class="o">(</span><span class="n">map</span> <span class="n">f</span> <span class="n">l'</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">))</span>
  <span class="kd">end</span><span class="o">,</span>
<span class="o">}</span>

<span class="kd">def</span> <span class="n">induced_kent</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">-&gt;</span> <span class="n">b</span><span class="o">)</span> <span class="o">[</span><span class="n">kent_convergence_space</span> <span class="n">b</span><span class="o">]</span> <span class="o">:</span> <span class="n">kent_convergence_space</span> <span class="n">a</span> <span class="o">:=</span>
<span class="k">let</span> <span class="n">ind</span> <span class="o">:=</span> <span class="n">induced</span> <span class="n">f</span> <span class="k">in</span> <span class="o">{</span>
  <span class="n">kent_conv</span> <span class="o">:=</span>
    <span class="kd">begin</span>
      <span class="n">intros</span> <span class="n">x</span> <span class="n">l</span> <span class="n">h</span><span class="o">,</span>
      <span class="n">delta</span> <span class="n">conv</span> <span class="c1">-- HAS NO EFFECT</span>
    <span class="kd">end</span><span class="o">,</span>
    <span class="bp">..</span><span class="n">ind</span>
<span class="o">}</span>
</code></pre></div>



<a name="263948385"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unfolding%20definitions%20from%20type%20class/near/263948385" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/unfolding.20definitions.20from.20type.20class.html#263948385">(Dec 07 2021 at 01:29)</a>:</h4>
<p>You also don't usually have to actually unfold, you can just know what the next step is (maybe <code>intro</code>) and do it.</p>



<a name="263948680"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unfolding%20definitions%20from%20type%20class/near/263948680" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/unfolding.20definitions.20from.20type.20class.html#263948680">(Dec 07 2021 at 01:34)</a>:</h4>
<p>In this case though you probably want something like</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">induced_def</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">-&gt;</span> <span class="n">b</span><span class="o">)</span> <span class="o">[</span><span class="n">convergence_space</span> <span class="n">b</span><span class="o">]</span> <span class="o">{</span><span class="n">l</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">a</span><span class="o">}</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">a</span><span class="o">}</span> <span class="o">:</span>
  <span class="bp">@</span><span class="n">convergence_space.conv</span> <span class="n">a</span> <span class="o">(</span><span class="n">induced</span> <span class="n">f</span><span class="o">)</span> <span class="n">l</span> <span class="n">x</span> <span class="bp">↔</span> <span class="n">conv</span> <span class="o">(</span><span class="n">map</span> <span class="n">f</span> <span class="n">l</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">iff.rfl</span>

<span class="kd">def</span> <span class="n">induced_kent</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">-&gt;</span> <span class="n">b</span><span class="o">)</span> <span class="o">[</span><span class="n">kent_convergence_space</span> <span class="n">b</span><span class="o">]</span> <span class="o">:</span> <span class="n">kent_convergence_space</span> <span class="n">a</span> <span class="o">:=</span>
<span class="k">let</span> <span class="n">ind</span> <span class="o">:=</span> <span class="n">induced</span> <span class="n">f</span> <span class="k">in</span> <span class="o">{</span>
  <span class="n">kent_conv</span> <span class="o">:=</span>
    <span class="kd">begin</span>
      <span class="n">intros</span> <span class="n">x</span> <span class="n">l</span> <span class="n">h</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">induced_def</span><span class="o">,</span>
    <span class="kd">end</span><span class="o">,</span>
    <span class="bp">..</span><span class="n">ind</span>
<span class="o">}</span>
</code></pre></div>



<a name="263948807"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unfolding%20definitions%20from%20type%20class/near/263948807" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/unfolding.20definitions.20from.20type.20class.html#263948807">(Dec 07 2021 at 01:36)</a>:</h4>
<p>This is where <code>class</code> is starting to make your life more difficult, and it would be more convenient to follow the pattern used by <code>topological_space</code></p>



<a name="263948965"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unfolding%20definitions%20from%20type%20class/near/263948965" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/unfolding.20definitions.20from.20type.20class.html#263948965">(Dec 07 2021 at 01:39)</a>:</h4>
<p>I tried the approach of <code>topological space</code>, but it produces other problems.</p>



<a name="263949294"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unfolding%20definitions%20from%20type%20class/near/263949294" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/unfolding.20definitions.20from.20type.20class.html#263949294">(Dec 07 2021 at 01:44)</a>:</h4>
<p>Thanks for the <code>induced_def</code> hint. That works.</p>



<a name="263970518"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unfolding%20definitions%20from%20type%20class/near/263970518" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/unfolding.20definitions.20from.20type.20class.html#263970518">(Dec 07 2021 at 08:27)</a>:</h4>
<p>Why are you using ascii art everywhere?!?</p>



<a name="263971862"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unfolding%20definitions%20from%20type%20class/near/263971862" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/unfolding.20definitions.20from.20type.20class.html#263971862">(Dec 07 2021 at 08:44)</a>:</h4>
<p>(Patrick is referring to <code>∀</code> vs <code>forall</code>, → vs <code>-&gt;</code>, <code>λ</code> vs <code>fun</code>, ...)</p>



<a name="291495872"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unfolding%20definitions%20from%20type%20class/near/291495872" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/unfolding.20definitions.20from.20type.20class.html#291495872">(Jul 31 2022 at 15:23)</a>:</h4>
<p>I'm trying to prove the following lemma:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">convergence_space.inf_iff</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">convergence_space</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">converges_</span> <span class="o">(</span><span class="n">p</span> <span class="bp">⊓</span> <span class="n">q</span><span class="o">)</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">↔</span> <span class="n">converges_</span> <span class="n">p</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">∧</span> <span class="n">converges_</span> <span class="n">q</span> <span class="n">f</span> <span class="n">x</span> <span class="o">:=</span>
</code></pre></div>
<p>I need to unfold what p ⊓ q here means. I can't seem to unfold it to the definition that was given in the complete_lattice (convergence_space α) instance. Any tips?</p>



<a name="291497244"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unfolding%20definitions%20from%20type%20class/near/291497244" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/unfolding.20definitions.20from.20type.20class.html#291497244">(Jul 31 2022 at 15:51)</a>:</h4>
<p>Use <code>change</code>?</p>



<a name="291497351"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unfolding%20definitions%20from%20type%20class/near/291497351" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/unfolding.20definitions.20from.20type.20class.html#291497351">(Jul 31 2022 at 15:53)</a>:</h4>
<p>Or, define a <code>convergence_space.inf_eq</code> lemma.</p>
<p><a href="https://leanprover-community.github.io/mathlib_docs/tactics.html#unfold_projs">tactic#unfold_projs</a> might do something helpful as well.</p>



<a name="291504258"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unfolding%20definitions%20from%20type%20class/near/291504258" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/unfolding.20definitions.20from.20type.20class.html#291504258">(Jul 31 2022 at 18:12)</a>:</h4>
<p>If the exact definition of something gives you any extra properties that the basic API doesn't, you can make an <code>rfl</code> lemma to unfold it.</p>



<a name="291508634"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unfolding%20definitions%20from%20type%20class/near/291508634" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/unfolding.20definitions.20from.20type.20class.html#291508634">(Jul 31 2022 at 19:41)</a>:</h4>
<p><span class="user-mention silent" data-user-id="387244">Yaël Dillies</span> <a href="#narrow/stream/113488-general/topic/unfolding.20definitions.20from.20type.20class/near/291497244">said</a>:</p>
<blockquote>
<p>Use <code>change</code>?</p>
</blockquote>
<p>I can't use <code>change</code> since I don't know what the definition is to begin with. It's the one autogenerated from complete_lattice_of_Inf .</p>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/113488-general/topic/unfolding.20definitions.20from.20type.20class/near/291497351">said</a>:</p>
<blockquote>
<p>Or, define a <code>convergence_space.inf_eq</code> lemma.<br>
<a href="https://leanprover-community.github.io/mathlib_docs/tactics.html#unfold_projs">tactic#unfold_projs</a> might do something helpful as well.</p>
</blockquote>
<p>inf_eq is basically what I'm trying to define. I tried <code>unfold_projs</code> but it doesn't unfold to the point where I can see what p ⊓ q means.</p>



<a name="291508744"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unfolding%20definitions%20from%20type%20class/near/291508744" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/unfolding.20definitions.20from.20type.20class.html#291508744">(Jul 31 2022 at 19:44)</a>:</h4>
<p>I can dig into the code of complete_lattice_of_Inf to see what it is doing, but I would like a way unfold the definition to tell me what it is doing.</p>



<a name="291508837"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unfolding%20definitions%20from%20type%20class/near/291508837" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/unfolding.20definitions.20from.20type.20class.html#291508837">(Jul 31 2022 at 19:45)</a>:</h4>
<p>Are you using VS Code? Have you already tried clicking on the term in the widgets view and navigate through the instances until you can see what it is?</p>



<a name="291508895"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unfolding%20definitions%20from%20type%20class/near/291508895" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/unfolding.20definitions.20from.20type.20class.html#291508895">(Jul 31 2022 at 19:46)</a>:</h4>
<p>Yes, I'm using VS Code. I clicked around, but I couldn't find anything useful.</p>



<a name="291509567"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unfolding%20definitions%20from%20type%20class/near/291509567" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/unfolding.20definitions.20from.20type.20class.html#291509567">(Jul 31 2022 at 20:01)</a>:</h4>
<p>So <code>p ⊓ q</code> is <code>Inf {p, q}</code> according to <code>complete_lattice_of_Inf</code> so I can use <code>change</code> here with that. It bugs me that I have to dig this out instead of getting it from doing an <code>unfold</code>. This can't be that hard, can it?</p>



<a name="291510144"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unfolding%20definitions%20from%20type%20class/near/291510144" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/unfolding.20definitions.20from.20type.20class.html#291510144">(Jul 31 2022 at 20:14)</a>:</h4>
<p>The approach used by mathlib is to write a rfl lemma for every data field of an instance</p>



<a name="291510252"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unfolding%20definitions%20from%20type%20class/near/291510252" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/unfolding.20definitions.20from.20type.20class.html#291510252">(Jul 31 2022 at 20:16)</a>:</h4>
<p>Eg, see <a href="https://leanprover-community.github.io/mathlib_docs/find/submodule.inf_coe">docs#submodule.inf_coe</a></p>



<a name="291510339"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unfolding%20definitions%20from%20type%20class/near/291510339" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/unfolding.20definitions.20from.20type.20class.html#291510339">(Jul 31 2022 at 20:19)</a>:</h4>
<p>I didn't know that. I have seen <code>*_eq</code> lemmas here and there, but I didn't really see a pattern or why they existed. So basically you are saying that I have no choice but to dig into the code?</p>



<a name="291510346"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unfolding%20definitions%20from%20type%20class/near/291510346" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/unfolding.20definitions.20from.20type.20class.html#291510346">(Jul 31 2022 at 20:19)</a>:</h4>
<p>In your case though, it would probably be best to provide to provide <code>inf</code> manually rather than getting the default <code>Inf {x, y}</code> definition</p>



<a name="291510347"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unfolding%20definitions%20from%20type%20class/near/291510347" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/unfolding.20definitions.20from.20type.20class.html#291510347">(Jul 31 2022 at 20:19)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/submodule.inf_coe">docs#submodule.inf_coe</a> doesn't work.</p>



<a name="291510409"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unfolding%20definitions%20from%20type%20class/near/291510409" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/unfolding.20definitions.20from.20type.20class.html#291510409">(Jul 31 2022 at 20:20)</a>:</h4>
<p>I wasn't suggesting it would work; my point is that you should write a lemma that describes how everything was defined as soon as you define an instance</p>



<a name="291510528"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unfolding%20definitions%20from%20type%20class/near/291510528" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/unfolding.20definitions.20from.20type.20class.html#291510528">(Jul 31 2022 at 20:22)</a>:</h4>
<blockquote>
<p>In your case though, it would probably be best to provide to provide inf manually rather than getting the default Inf {x, y} definition</p>
</blockquote>
<p>I have done this in my master branch, but it requires proving stuff. In fact, in my master branch I define an instance of every single type class that makes up complete_lattice. But I want to avoid having to do all this work since I have to repeat this sort of thing for 4 more things in the convergence_space hierarchy.</p>



<a name="291510548"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unfolding%20definitions%20from%20type%20class/near/291510548" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/unfolding.20definitions.20from.20type.20class.html#291510548">(Jul 31 2022 at 20:23)</a>:</h4>
<blockquote>
<p>you should write a lemma that describes how everything was defined as soon as you define an instance</p>
</blockquote>
<p>I can do this, but the unfolding problem remains.</p>



<a name="291510560"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unfolding%20definitions%20from%20type%20class/near/291510560" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/unfolding.20definitions.20from.20type.20class.html#291510560">(Jul 31 2022 at 20:23)</a>:</h4>
<p>If the proof is <code>rfl</code>, then you don't need to manually unfold anything</p>



<a name="291510622"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unfolding%20definitions%20from%20type%20class/near/291510622" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/unfolding.20definitions.20from.20type.20class.html#291510622">(Jul 31 2022 at 20:24)</a>:</h4>
<p>I don't follow. How will I know that p ⊓ q is Inf {p, q} without digging into the code or unfolding?</p>



<a name="291510738"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unfolding%20definitions%20from%20type%20class/near/291510738" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/unfolding.20definitions.20from.20type.20class.html#291510738">(Jul 31 2022 at 20:26)</a>:</h4>
<p>If you don't know what the definition even ended up being, that's often a sign that you probably should define it differently</p>



<a name="291510750"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unfolding%20definitions%20from%20type%20class/near/291510750" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/unfolding.20definitions.20from.20type.20class.html#291510750">(Jul 31 2022 at 20:27)</a>:</h4>
<p>You're right that it creates more work, but you'll have to do that anyway later to prove that <code>inf</code> does the right thing</p>



<a name="291510755"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unfolding%20definitions%20from%20type%20class/near/291510755" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/unfolding.20definitions.20from.20type.20class.html#291510755">(Jul 31 2022 at 20:27)</a>:</h4>
<p>So you may as well just define it the right way to begin with</p>



<a name="291510803"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unfolding%20definitions%20from%20type%20class/near/291510803" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/unfolding.20definitions.20from.20type.20class.html#291510803">(Jul 31 2022 at 20:28)</a>:</h4>
<p>Perhaps you want <a href="https://leanprover-community.github.io/mathlib_docs/find/function.injective.complete_lattice">docs#function.injective.complete_lattice</a> instead of <a href="https://leanprover-community.github.io/mathlib_docs/find/complete_lattice_of_Inf">docs#complete_lattice_of_Inf</a></p>



<a name="291510809"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unfolding%20definitions%20from%20type%20class/near/291510809" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/unfolding.20definitions.20from.20type.20class.html#291510809">(Jul 31 2022 at 20:28)</a>:</h4>
<p>I have already done this in my master branch as I mentioned. My takeaway here is that <code>unfold</code> just does not work in the way I expect.</p>



<a name="291512377"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unfolding%20definitions%20from%20type%20class/near/291512377" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/unfolding.20definitions.20from.20type.20class.html#291512377">(Jul 31 2022 at 21:03)</a>:</h4>
<p>Scrolling up, I notice that you never actually mention how you tried to use <code>unfold</code>; I assume <code>unfold has_inf.inf</code> didn't work?</p>



<a name="291514307"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unfolding%20definitions%20from%20type%20class/near/291514307" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/unfolding.20definitions.20from.20type.20class.html#291514307">(Jul 31 2022 at 21:48)</a>:</h4>
<p>Can you post a <a href="https://leanprover-community.github.io/mwe.html">#mwe</a> ? Note how your previous question in this thread was resolved quickly after you posted one.</p>



<a name="291760346"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unfolding%20definitions%20from%20type%20class/near/291760346" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/unfolding.20definitions.20from.20type.20class.html#291760346">(Aug 02 2022 at 19:57)</a>:</h4>
<p>Here you go:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">order.filter</span>

<span class="kd">variable</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>

<span class="kd">class</span> <span class="n">convergence_space</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">converges</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>

<span class="kn">open</span> <span class="n">convergence_space</span>

<span class="kd">def</span> <span class="n">converges_</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">convergence_space</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">converges</span> <span class="n">_</span> <span class="n">p</span> <span class="n">f</span> <span class="n">x</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">partial_order</span> <span class="o">(</span><span class="n">convergence_space</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_Inf</span> <span class="o">(</span><span class="n">convergence_space</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">complete_lattice</span> <span class="o">(</span><span class="n">convergence_space</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="n">complete_lattice_of_Inf</span> <span class="o">(</span><span class="n">convergence_space</span> <span class="n">α</span><span class="o">)</span> <span class="gr">sorry</span>

<span class="kd">lemma</span> <span class="n">convergence_space.inf_iff</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">convergence_space</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">converges_</span> <span class="o">(</span><span class="n">p</span> <span class="bp">⊓</span> <span class="n">q</span><span class="o">)</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">↔</span> <span class="n">converges_</span> <span class="n">p</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">∧</span> <span class="n">converges_</span> <span class="n">q</span> <span class="n">f</span> <span class="n">x</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">hconv</span><span class="o">,</span>
    <span class="n">unfold</span> <span class="n">has_inf.inf</span> <span class="n">at</span> <span class="n">hconv</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="gr">sorry</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>



<a name="291767159"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unfolding%20definitions%20from%20type%20class/near/291767159" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/unfolding.20definitions.20from.20type.20class.html#291767159">(Aug 02 2022 at 20:51)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">dunfold</span> <span class="n">has_inf.inf</span> <span class="n">semilattice_inf.inf</span> <span class="n">lattice.inf</span> <span class="n">conditionally_complete_lattice.inf</span>
      <span class="n">complete_lattice.inf</span> <span class="n">convergence_space.complete_lattice</span> <span class="n">complete_lattice_of_Inf</span> <span class="n">at</span> <span class="n">hconv</span><span class="o">,</span>
</code></pre></div>
<p>works</p>



<a name="291767173"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unfolding%20definitions%20from%20type%20class/near/291767173" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/unfolding.20definitions.20from.20type.20class.html#291767173">(Aug 02 2022 at 20:51)</a>:</h4>
<p>You needed to keep unfolding further</p>



<a name="291767196"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unfolding%20definitions%20from%20type%20class/near/291767196" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/unfolding.20definitions.20from.20type.20class.html#291767196">(Aug 02 2022 at 20:51)</a>:</h4>
<p>I don't quite get why <code>unfold</code> can't make progress beyond <code>convergence_space.complete_lattice</code></p>



<a name="291918883"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unfolding%20definitions%20from%20type%20class/near/291918883" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/unfolding.20definitions.20from.20type.20class.html#291918883">(Aug 03 2022 at 20:55)</a>:</h4>
<p>Ah, I didn't realize that I could unfold multiple definitions in one <code>unfold</code>. I was actually writing <code>unfold</code> multiple times and I stopped at complete_lattice.inf since I thought that was the last place since that is instance I defined that would have it.</p>



<a name="291918985"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unfolding%20definitions%20from%20type%20class/near/291918985" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/unfolding.20definitions.20from.20type.20class.html#291918985">(Aug 03 2022 at 20:56)</a>:</h4>
<p>Oh wait, you used <code>dunfold</code>. First time seeing that tactic.</p>



<a name="291922121"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unfolding%20definitions%20from%20type%20class/near/291922121" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/unfolding.20definitions.20from.20type.20class.html#291922121">(Aug 03 2022 at 21:23)</a>:</h4>
<p>If you hover over <code>complete_lattice.inf</code> in the infoview you'll see that it's <code>@complete_lattice.inf _ convergence_space.complete_lattice</code>, which is why I unfolded <code>convergence_space.complete_lattice</code> next</p>



<a name="291922139"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unfolding%20definitions%20from%20type%20class/near/291922139" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/unfolding.20definitions.20from.20type.20class.html#291922139">(Aug 03 2022 at 21:23)</a>:</h4>
<p>I'm afraid I have no idea why <code>unfold convergence_space.complete_lattice</code> failed but <code>dunfold convergence_space.complete_lattice</code> worked</p>



<a name="292073107"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unfolding%20definitions%20from%20type%20class/near/292073107" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/unfolding.20definitions.20from.20type.20class.html#292073107">(Aug 04 2022 at 21:36)</a>:</h4>
<p>Should I report it as a possible bug?</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
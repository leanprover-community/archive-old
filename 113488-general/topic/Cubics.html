---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/Cubics.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Cubics.html">Cubics</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="278832547"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Cubics/near/278832547" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Cubics.html#278832547">(Apr 13 2022 at 14:01)</a>:</h4>
<p><span class="user-mention" data-user-id="120184">@David Kurniadi Angdinata</span>, why did you not define <a href="https://leanprover-community.github.io/mathlib_docs/find/cubic">docs#cubic</a> as <code>polynomial.degree_le R 3</code> (<a href="https://leanprover-community.github.io/mathlib_docs/find/polynomial.degree_le">docs#polynomial.degree_le</a>)?</p>



<a name="278833790"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Cubics/near/278833790" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Cubics.html#278833790">(Apr 13 2022 at 14:11)</a>:</h4>
<p>I remember a PR about something similar, let me search.</p>



<a name="278833929"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Cubics/near/278833929" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Cubics.html#278833929">(Apr 13 2022 at 14:13)</a>:</h4>
<p>It's <a href="https://github.com/leanprover-community/mathlib/pull/6428">#6428</a>, but the only explanation is "Working directly with specific polynomials (like <code>X^n - X - 1</code>) is really painful, since whenever you try to do something simple like checking that the polynomial is monic or computing its degree, you have to prove a bunch of trivial inequalities. Bundling solves this problem".</p>



<a name="278834025"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Cubics/near/278834025" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Cubics.html#278834025">(Apr 13 2022 at 14:14)</a>:</h4>
<p>right -- proving that the degree of x^2+1 is 2 is surprisingly annoying right now (as one of my UG students found out a few weeks ago)</p>



<a name="278834064"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Cubics/near/278834064" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Cubics.html#278834064">(Apr 13 2022 at 14:14)</a>:</h4>
<p>(and it's not even true if R is the zero ring ;-) )</p>



<a name="278885657"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Cubics/near/278885657" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Cubics.html#278885657">(Apr 13 2022 at 20:28)</a>:</h4>
<p>I find that working with <code>nat_degree_le</code> is way better.</p>



<a name="278885770"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Cubics/near/278885770" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Cubics.html#278885770">(Apr 13 2022 at 20:29)</a>:</h4>
<p>What Riccardo is describing sounds like a case for a strong dedicated API, but not really a case for a dedicated structure.</p>



<a name="278887660"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Cubics/near/278887660" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Browning <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Cubics.html#278887660">(Apr 13 2022 at 20:44)</a>:</h4>
<p><span class="user-mention silent" data-user-id="321459">Damiano Testa</span> <a href="#narrow/stream/113488-general/topic/Cubics/near/278885657">said</a>:</p>
<blockquote>
<p>I find that working with <code>nat_degree_le</code> is way better.</p>
</blockquote>
<p>Certainly, but proving the other inequality is still painful.</p>



<a name="278887794"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Cubics/near/278887794" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Browning <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Cubics.html#278887794">(Apr 13 2022 at 20:45)</a>:</h4>
<p><span class="user-mention silent" data-user-id="387244">Yaël Dillies</span> <a href="#narrow/stream/113488-general/topic/Cubics/near/278885770">said</a>:</p>
<blockquote>
<p>What Riccardo is describing sounds like a case for a strong dedicated API, but not really a case for a dedicated structure.</p>
</blockquote>
<p>I also came to this conclusion for the trinomials project. I hope to return to it at some point, and see if I can avoid bundled trinomials.</p>



<a name="278911388"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Cubics/near/278911388" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Ang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Cubics.html#278911388">(Apr 14 2022 at 01:06)</a>:</h4>
<p><span class="user-mention" data-user-id="387244">@Yaël Dillies</span> I just thought it was easier to work with four coefficients than with a submodule of R[X], and I was really just following the <code>quadratic_discriminant</code> file that’s already present (PS: can an admin kick my other account? I don’t have access to that one anymore and want to receive the right pings)</p>



<a name="278912074"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Cubics/near/278912074" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Ang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Cubics.html#278912074">(Apr 14 2022 at 01:16)</a>:</h4>
<p>When I wrote this I really only needed cubics that aren’t quadratic/linear/constant (so the four coefficients are kinda natural to start from), but I was told to include the degenerate cases as well, so now R[X] &lt;= 3 seems more natural</p>



<a name="279001166"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Cubics/near/279001166" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Cubics.html#279001166">(Apr 14 2022 at 18:08)</a>:</h4>
<p>Just a follow-up on the difficulty of computing explicit <code>nat_degree</code>s, I gave it a shot!  Below is my attempt: it has not been easy!  But I was indeed able to prove that the degree of <code>X^2 + 1</code> is <code>2</code> in any non-trivial semiring!  <span aria-label="upside down" class="emoji emoji-1f643" role="img" title="upside down">:upside_down:</span> </p>
<div class="spoiler-block"><div class="spoiler-header">
<p>Computing degrees</p>
</div><div class="spoiler-content" aria-hidden="true">
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.polynomial.degree.definitions</span>

<span class="kn">open</span> <span class="n">polynomial</span>
<span class="n">open_locale</span> <span class="n">polynomial</span> <span class="n">classical</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">R</span><span class="o">]</span>

<span class="kd">lemma</span> <span class="n">C_X_pow_add_C_X_pow1</span> <span class="o">{</span><span class="n">r</span> <span class="n">s</span> <span class="o">:</span> <span class="n">R</span><span class="o">}</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">mn</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">C</span> <span class="n">r</span> <span class="bp">*</span> <span class="o">(</span><span class="mi">1</span> <span class="bp">*</span> <span class="n">X</span><span class="o">)</span> <span class="bp">^</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">C</span> <span class="n">s</span> <span class="bp">*</span> <span class="o">(</span><span class="mi">1</span> <span class="bp">*</span> <span class="n">X</span><span class="o">)</span> <span class="bp">^</span> <span class="n">m</span> <span class="bp">=</span> <span class="n">C</span> <span class="n">s</span> <span class="bp">*</span> <span class="o">(</span><span class="mi">1</span> <span class="bp">*</span> <span class="n">X</span><span class="o">)</span> <span class="bp">^</span> <span class="n">m</span> <span class="bp">+</span> <span class="n">C</span> <span class="n">r</span> <span class="bp">*</span> <span class="o">(</span><span class="mi">1</span> <span class="bp">*</span> <span class="n">X</span><span class="o">)</span> <span class="bp">^</span> <span class="n">n</span> <span class="o">:=</span>
<span class="n">add_comm</span> <span class="n">_</span> <span class="n">_</span>

<span class="kd">lemma</span> <span class="n">nat_degree_monomial_le</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">monomial</span> <span class="n">n</span> <span class="n">r</span><span class="o">)</span><span class="bp">.</span><span class="n">nat_degree</span> <span class="bp">≤</span> <span class="n">n</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">rw</span> <span class="n">nat_degree_monomial</span><span class="o">,</span> <span class="n">split_ifs</span><span class="o">,</span> <span class="n">simp</span> <span class="o">}</span>

<span class="kd">lemma</span> <span class="n">nat_degree_add_add</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">r</span> <span class="n">s</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">s0</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">R</span><span class="o">[</span><span class="n">X</span><span class="o">])</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">f.nat_degree</span> <span class="bp">≤</span> <span class="n">m</span><span class="o">)</span>
  <span class="o">(</span><span class="n">mn</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">f</span> <span class="bp">+</span> <span class="n">monomial</span> <span class="n">m</span> <span class="n">r</span> <span class="bp">+</span> <span class="n">monomial</span> <span class="n">n</span> <span class="n">s</span><span class="o">)</span><span class="bp">.</span><span class="n">nat_degree</span> <span class="bp">=</span> <span class="n">n</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rwa</span> <span class="o">[</span><span class="n">nat_degree_add_eq_right_of_nat_degree_lt</span><span class="o">,</span> <span class="n">nat_degree_monomial</span><span class="o">,</span> <span class="n">if_neg</span> <span class="n">s0</span><span class="o">],</span>
  <span class="n">refine</span> <span class="o">(</span><span class="n">nat_degree_add_le</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">trans_lt</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">max_lt</span><span class="o">,</span>
  <span class="n">refine</span> <span class="n">hf.trans_lt</span> <span class="o">(</span><span class="n">mn.trans_le</span> <span class="o">(</span><span class="n">le_of_eq</span> <span class="n">_</span><span class="o">)),</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">nat_degree_monomial</span><span class="o">,</span> <span class="n">if_neg</span> <span class="n">s0</span><span class="o">],</span>
  <span class="n">refine</span> <span class="o">(</span><span class="n">nat_degree_monomial_le</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">trans_lt</span> <span class="o">(</span><span class="n">mn.trans_le</span> <span class="o">(</span><span class="n">le_of_eq</span> <span class="n">_</span><span class="o">)),</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">nat_degree_monomial</span><span class="o">,</span> <span class="n">if_neg</span> <span class="n">s0</span><span class="o">],</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">nat_degree_add_once</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">r</span> <span class="n">s</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">s0</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">)</span>
  <span class="o">(</span><span class="n">mn</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">monomial</span> <span class="n">m</span> <span class="n">r</span> <span class="bp">+</span> <span class="n">monomial</span> <span class="n">n</span> <span class="n">s</span><span class="o">)</span><span class="bp">.</span><span class="n">nat_degree</span> <span class="bp">=</span> <span class="n">n</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rwa</span> <span class="o">[</span><span class="n">nat_degree_add_eq_right_of_nat_degree_lt</span><span class="o">,</span> <span class="n">nat_degree_monomial</span><span class="o">,</span> <span class="n">if_neg</span> <span class="n">s0</span><span class="o">],</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">nat_degree_monomial</span><span class="o">,</span> <span class="n">nat_degree_monomial</span><span class="o">,</span> <span class="n">if_neg</span> <span class="n">s0</span><span class="o">],</span>
  <span class="n">split_ifs</span><span class="o">,</span>
  <span class="n">exact</span> <span class="o">(</span><span class="n">nat.zero_le</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">trans_lt</span> <span class="n">mn</span><span class="o">,</span>
  <span class="n">assumption</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">variable</span> <span class="o">[</span><span class="n">nontrivial</span> <span class="n">R</span><span class="o">]</span>
<span class="c1">--  my test polynomial: C u * X + X ^ 5 + C s + C t * X ^ 2 + X ^ 8</span>
<span class="c1">-- {r s t u : R} (r0 : t ≠ 0)</span>
<span class="c1">--  Kevin's example</span>
<span class="kd">lemma</span> <span class="n">nat_degree_le</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">X</span> <span class="bp">^</span> <span class="mi">2</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">R</span><span class="o">[</span><span class="n">X</span><span class="o">])</span><span class="bp">.</span><span class="n">nat_degree</span> <span class="bp">≤</span> <span class="mi">2</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="c1">-- First, make sure that all summands are `monomial`s</span>
  <span class="n">try</span> <span class="o">{</span> <span class="n">rw</span> <span class="n">X</span> <span class="o">},</span>
  <span class="n">try</span> <span class="o">{</span> <span class="n">rw</span> <span class="bp">←</span> <span class="n">C_1</span> <span class="o">},</span>
  <span class="n">repeat</span> <span class="o">{</span> <span class="n">rw</span> <span class="bp">←</span> <span class="n">monomial_zero_left</span> <span class="o">},</span>
  <span class="n">repeat</span> <span class="o">{</span> <span class="n">rw</span> <span class="n">monomial_pow</span> <span class="o">},</span>
  <span class="n">repeat</span> <span class="o">{</span> <span class="n">rw</span> <span class="n">monomial_mul_monomial</span> <span class="o">},</span>
  <span class="c1">-- and clean up various add_zeros, mul_ones,...</span>
  <span class="n">try</span> <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="bp">-</span><span class="n">monomial_zero_left</span><span class="o">]</span> <span class="o">},</span>
  <span class="c1">-- We peel off each summand and produce goals where we need to show that each summand has</span>
  <span class="c1">-- degree bounded by our target</span>
  <span class="n">repeat</span> <span class="o">{</span> <span class="n">refine</span> <span class="o">(</span><span class="n">nat_degree_add_le</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">trans</span> <span class="o">(</span><span class="n">max_le</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span> <span class="o">},</span>
  <span class="c1">-- since our summands are monomials, we know that their degrees are at most their exponents</span>
  <span class="n">any_goals</span> <span class="o">{</span> <span class="n">apply</span> <span class="o">(</span><span class="n">nat_degree_monomial_le</span> <span class="n">_</span> <span class="o">(</span><span class="n">_</span> <span class="o">:</span> <span class="n">R</span><span class="o">))</span><span class="bp">.</span><span class="n">trans</span> <span class="n">_</span> <span class="o">},</span>
  <span class="c1">-- therefore, `norm_num` should be able to prove the inequalities.</span>
  <span class="n">all_goals</span> <span class="o">{</span> <span class="n">norm_num</span> <span class="o">},</span>
<span class="kd">end</span>

<span class="c1">-- {r s t u : R} (r0 : t ≠ 0) (z0 : (1 : R) ≠ 0)</span>
<span class="kd">lemma</span> <span class="n">le_nat_degree</span> <span class="o">:</span>
  <span class="mi">2</span> <span class="bp">≤</span> <span class="o">(</span><span class="n">X</span> <span class="bp">^</span> <span class="mi">2</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">R</span><span class="o">[</span><span class="n">X</span><span class="o">])</span><span class="bp">.</span><span class="n">nat_degree</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="c1">-- First, make sure that all summands are `monomial`s</span>
  <span class="n">try</span> <span class="o">{</span> <span class="n">rw</span> <span class="n">X</span> <span class="o">},</span>
  <span class="n">try</span> <span class="o">{</span> <span class="n">rw</span> <span class="bp">←</span> <span class="n">C_1</span> <span class="o">},</span>
  <span class="n">repeat</span> <span class="o">{</span> <span class="n">rw</span> <span class="bp">←</span> <span class="n">monomial_zero_left</span> <span class="o">},</span>
  <span class="n">repeat</span> <span class="o">{</span> <span class="n">rw</span> <span class="n">monomial_pow</span> <span class="o">},</span>
  <span class="n">repeat</span> <span class="o">{</span> <span class="n">rw</span> <span class="n">monomial_mul_monomial</span> <span class="o">},</span>
  <span class="c1">-- and clean up various add_zeros, mul_ones,...</span>
  <span class="n">try</span> <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="bp">-</span><span class="n">monomial_zero_left</span><span class="o">]</span> <span class="o">},</span>
  <span class="c1">-- Now that all summands are monomials, we convert them to the form `C r * X ^ n`,</span>
  <span class="c1">-- with possibly `r = 1` and `n = 0` or `n = 1`, for uniformity.</span>
  <span class="n">repeat</span> <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">monomial_eq_C_mul_X</span><span class="o">]</span> <span class="o">},</span>
  <span class="c1">-- we also rearrange parentheses, just in case</span>
  <span class="n">repeat</span> <span class="o">{</span> <span class="n">rw</span> <span class="bp">←</span> <span class="n">add_assoc</span> <span class="o">},</span>

  <span class="c1">-- mark each summand with a `1 * X`: later on, we will remove these markers, to go deeper into</span>
  <span class="c1">-- the various summands.  The presence of a `1 *` in a term is our cue that we have not yet</span>
  <span class="c1">-- rearranged it.</span>
  <span class="n">rw</span> <span class="bp">←</span> <span class="n">one_mul</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">R</span><span class="o">[</span><span class="n">X</span><span class="o">]),</span>

  <span class="c1">--  This block sorts the summands in ascending degree of exponent.</span>
  <span class="c1">--  The number of iterations should be adapted to each case -- this choice works for small cases.</span>
  <span class="c1">--  We visit each pair of consecutive summands and decide whether we swap them or not.</span>
  <span class="c1">--  The number of times that we visit all the summands is determined by the first `iterate`.</span>
  <span class="c1">--  The visits to the summands happens in the second `iterate`.</span>
  <span class="n">iterate</span> <span class="mi">2</span>
  <span class="c1">-- The inner loop visits each consecutive pairs of summands and swaps them, if the swap makes the</span>
  <span class="c1">-- sequence of exponents decrease.</span>
  <span class="o">{</span> <span class="n">iterate</span> <span class="mi">3</span>
    <span class="o">{</span> <span class="c1">-- We focus on the first pair.  `C_X_pow_add_C_X_pow1` will swap the two summands</span>
      <span class="c1">-- creating a proof obligation of showing that the new order is strictly monotone increasing.</span>
      <span class="c1">-- `norm_num` will try to solve side goal and if it does not succeed, then `refl` fails and</span>
      <span class="c1">-- the swap does not occur.</span>
      <span class="c1">-- If `norm_num` succeeds, we have straightened a little, otherwise, the two first terms are</span>
      <span class="c1">-- in correct order.</span>
      <span class="c1">--  In either case, after the `try`, we have not increased the number of inversions among the</span>
      <span class="c1">--  exponents of our summands and it could have decreased.</span>
      <span class="n">try</span> <span class="o">{</span> <span class="n">work_on_goal</span> <span class="mi">1</span> <span class="o">{</span> <span class="n">rw</span> <span class="n">C_X_pow_add_C_X_pow1</span><span class="o">,</span> <span class="n">rotate</span><span class="o">,</span> <span class="n">norm_num</span><span class="bp">;</span> <span class="n">refl</span> <span class="o">}</span> <span class="o">},</span>
      <span class="c1">-- so we shift parentheses around isolating the not-yet-visited terms (highlighted by the `1`)</span>
      <span class="n">repeat</span> <span class="o">{</span> <span class="n">rw</span> <span class="n">add_assoc</span> <span class="o">(</span><span class="n">C</span> <span class="n">_</span> <span class="bp">*</span> <span class="o">(</span><span class="mi">1</span> <span class="bp">*</span> <span class="n">X</span><span class="o">)</span> <span class="bp">^</span> <span class="n">_</span><span class="o">)</span> <span class="o">},</span>
      <span class="c1">-- we mark as straightened the term that was just (possibly) rearranged</span>
      <span class="n">try</span> <span class="o">{</span> <span class="n">nth_rewrite</span> <span class="mi">0</span> <span class="n">one_mul</span> <span class="n">X</span> <span class="o">},</span>
      <span class="c1">-- and we prepare to start again with the next pair</span>
      <span class="n">repeat</span> <span class="o">{</span> <span class="n">rw</span> <span class="bp">←</span> <span class="n">add_assoc</span> <span class="o">(</span><span class="n">C</span> <span class="n">_</span> <span class="bp">*</span> <span class="o">(</span><span class="mi">1</span> <span class="bp">*</span> <span class="n">X</span><span class="o">)</span> <span class="bp">^</span> <span class="n">_</span><span class="o">)</span> <span class="o">}</span> <span class="o">},</span>
      <span class="c1">-- We are now outside of the first `iterate`.</span>
      <span class="c1">-- we clear and replace the markers</span>
      <span class="n">try</span> <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">one_mul</span><span class="o">]</span> <span class="o">},</span> <span class="n">try</span> <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">one_mul</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">R</span><span class="o">[</span><span class="n">X</span><span class="o">])]</span> <span class="o">},</span>
      <span class="c1">-- we rearrange parentheses</span>
      <span class="n">repeat</span> <span class="o">{</span> <span class="n">rw</span> <span class="bp">←</span> <span class="n">add_assoc</span> <span class="o">}</span> <span class="o">},</span>

  <span class="c1">-- Unless we made mistakes (or we looped too little), our expression has exponents sorted in</span>
  <span class="c1">-- strictly increasing order.</span>
  <span class="c1">-- We clear the leftover markers</span>
  <span class="n">try</span> <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">one_mul</span> <span class="n">X</span><span class="o">]</span> <span class="o">},</span>
  <span class="c1">-- We re-express everything in terms of `monomial`s</span>
  <span class="n">repeat</span> <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">monomial_eq_C_mul_X</span><span class="o">]</span> <span class="o">},</span>
  <span class="c1">-- Now we strip off each summand from the right-most one back</span>
  <span class="c1">-- remember that the further right we go, the higher the exponent.</span>
  <span class="c1">-- Lemma `nat_degree_add_add` creates proof obligations of checking that the ordering is</span>
  <span class="c1">-- correct and that the various coefficients are non-zero</span>
  <span class="c1">-- (really, we only need the highest coefficient to be non-zero, the remaining ones might well</span>
  <span class="c1">-- be zero, but I decided that this was enough!)</span>
  <span class="n">repeat</span> <span class="o">{</span> <span class="n">rw</span> <span class="n">nat_degree_add_add</span> <span class="o">},</span>
  <span class="n">try</span> <span class="o">{</span> <span class="n">rw</span> <span class="n">nat_degree_add_once</span> <span class="o">},</span>
  <span class="c1">-- Finally, we try to prove these proof obligations using `norm_num` or `assumptions that might</span>
  <span class="c1">-- be floating around.</span>
  <span class="n">any_goals</span> <span class="o">{</span> <span class="n">norm_num</span> <span class="o">},</span>
  <span class="n">all_goals</span> <span class="o">{</span> <span class="n">assumption</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>
</div></div>



<a name="279002847"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Cubics/near/279002847" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Cubics.html#279002847">(Apr 14 2022 at 18:23)</a>:</h4>
<p>Thanks Damiano -- I think you've made my point quite well :-/</p>



<a name="279003322"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Cubics/near/279003322" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Cubics.html#279003322">(Apr 14 2022 at 18:27)</a>:</h4>
<p>Btw, the challenge is now to find a polynomial written as a sum of terms with distinct exponents and non-zero coefficients, for which the above code does <em>not</em> compute the degree!</p>



<a name="279004013"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Cubics/near/279004013" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Cubics.html#279004013">(Apr 14 2022 at 18:33)</a>:</h4>
<p>I don't see the issue:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.polynomial.degree.definitions</span>

<span class="kn">open</span> <span class="n">polynomial</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">R</span><span class="o">}</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">nontrivial</span> <span class="n">R</span><span class="o">]</span> <span class="o">:</span> <span class="o">(</span><span class="n">X</span> <span class="bp">^</span> <span class="mi">2</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">polynomial</span> <span class="n">R</span><span class="o">)</span><span class="bp">.</span><span class="n">nat_degree</span> <span class="bp">=</span> <span class="mi">2</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">nat_degree_add_eq_left_of_nat_degree_lt</span><span class="o">,</span> <span class="n">nat_degree_X_pow</span><span class="o">],</span>
  <span class="n">simp</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="279004203"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Cubics/near/279004203" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Cubics.html#279004203">(Apr 14 2022 at 18:35)</a>:</h4>
<p>Sure, I was just giving a general procedure to compute natdegrees of explicit polynomials</p>



<a name="279004256"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Cubics/near/279004256" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Cubics.html#279004256">(Apr 14 2022 at 18:35)</a>:</h4>
<p>Oh, does this work for any polynomial? That's exciting!</p>



<a name="279004797"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Cubics/near/279004797" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Cubics.html#279004797">(Apr 14 2022 at 18:41)</a>:</h4>
<p>Well, it works on 2...</p>



<a name="279005649"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Cubics/near/279005649" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Cubics.html#279005649">(Apr 14 2022 at 18:49)</a>:</h4>
<p>It would be nice to make it a <code>norm_num</code> extension</p>



<a name="279013995"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Cubics/near/279013995" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Cubics.html#279013995">(Apr 14 2022 at 19:59)</a>:</h4>
<p>Patrick, I'm happy to try, but I'm not even entirely sure what is a <code>norm_num</code> extension.</p>
<p>Moreover, I think that all the code above could be <em>much</em> simpler if I only knew some metaprogramming.  I would need a lot of help with that.</p>



<a name="279031999"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Cubics/near/279031999" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Cubics.html#279031999">(Apr 14 2022 at 23:02)</a>:</h4>
<p><code>norm_num</code> essentially works in an "extendable" way, I'm not really sure how. but it means that if you have some definition that you want to evaluate, you don't have to edit the core tactic, you can just do it in a separate file</p>



<a name="279032013"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Cubics/near/279032013" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Cubics.html#279032013">(Apr 14 2022 at 23:02)</a>:</h4>
<p>cc <span class="user-mention" data-user-id="110049">@Mario Carneiro</span>, he made most of this I think</p>



<a name="279051050"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Cubics/near/279051050" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Cubics.html#279051050">(Apr 15 2022 at 05:23)</a>:</h4>
<p>Thanks Eric, I'll look a little at the various <code>norm_num</code> files and will ask questions.</p>



<a name="279051135"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Cubics/near/279051135" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Cubics.html#279051135">(Apr 15 2022 at 05:25)</a>:</h4>
<p>By the way, most of the structure above is about sorting a sum of monomials by degree, which is independent of computing degrees.  I can see if <code>abel</code> or <code>ring</code> works there.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
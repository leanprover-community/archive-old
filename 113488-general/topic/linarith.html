---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/linarith.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html">linarith</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="148096612"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148096612" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#148096612">(Nov 21 2018 at 08:53)</a>:</h4>
<p>Shouldn't <code>linarith</code> be able to take care of this?</p>
<div class="codehilite"><pre><span></span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span>
<span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">),</span>
<span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">),</span>
<span class="n">ha</span> <span class="o">:</span> <span class="bp">¬</span><span class="n">a</span><span class="bp">.</span><span class="n">val</span> <span class="bp">&lt;</span> <span class="n">i</span><span class="bp">.</span><span class="n">val</span><span class="o">,</span>
<span class="n">h</span> <span class="o">:</span> <span class="n">b</span><span class="bp">.</span><span class="n">val</span> <span class="bp">&lt;</span> <span class="n">i</span><span class="bp">.</span><span class="n">val</span><span class="o">,</span>
<span class="n">H</span> <span class="o">:</span> <span class="n">a</span><span class="bp">.</span><span class="n">val</span> <span class="bp">≤</span> <span class="n">b</span><span class="bp">.</span><span class="n">val</span><span class="o">,</span>
<span class="n">a_1</span> <span class="o">:</span> <span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="o">(</span><span class="n">a</span><span class="bp">.</span><span class="n">val</span><span class="o">)</span> <span class="bp">&gt;</span> <span class="n">b</span><span class="bp">.</span><span class="n">val</span>
<span class="err">⊢</span> <span class="n">false</span>
</pre></div>



<a name="148096896"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148096896" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#148096896">(Nov 21 2018 at 09:00)</a>:</h4>
<p>I thought it has been made clear that <code>linarith</code> doesn't deal with <code>nat</code></p>



<a name="148097084"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148097084" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#148097084">(Nov 21 2018 at 09:05)</a>:</h4>
<p>After <code>apply ha</code> it should be an easy target for <code>mono</code> but it doesn't work <span class="emoji emoji-2639" title="sad">:sad:</span></p>



<a name="148097138"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148097138" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#148097138">(Nov 21 2018 at 09:06)</a>:</h4>
<p><span class="user-mention" data-user-id="110026">@Simon Hudon</span> </p>
<div class="codehilite"><pre><span></span>import tactic.monotonicity

example (n : ℕ)
(i : fin (n + 1 + 1))
(a b : fin (n + 1))
(ha : ¬a.val &lt; i.val)
(h : b.val &lt; i.val)
(H : a.val ≤ b.val)
(a_1 : nat.succ (a.val) &gt; b.val) : false :=
begin
  apply ha,
  mono*,  -- does nothing :-(
  exact calc a.val ≤ _ : H
  ... &lt; _ : h,
end
</pre></div>



<a name="148097160"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148097160" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#148097160">(Nov 21 2018 at 09:07)</a>:</h4>
<p>Change <code>nat.succ (a.val)</code> to <code>a.val + 1</code>.</p>



<a name="148097178"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148097178" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#148097178">(Nov 21 2018 at 09:08)</a>:</h4>
<p>This is the first thing I tried, but it changes nothing</p>



<a name="148097262"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148097262" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#148097262">(Nov 21 2018 at 09:09)</a>:</h4>
<p>maybe stop (over)relying on tactics</p>



<a name="148097310"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148097310" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#148097310">(Nov 21 2018 at 09:10)</a>:</h4>
<p>Oh, change <code>ha</code> to <code>a.val ≥ i.val</code>.</p>



<a name="148097329"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148097329" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#148097329">(Nov 21 2018 at 09:11)</a>:</h4>
<p>that works</p>



<a name="148097395"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148097395" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#148097395">(Nov 21 2018 at 09:12)</a>:</h4>
<p>Kenny, the discussion is not really about how to prove that particular goal. It's about having a toolset which gets rid of hundred of stupid goals like this, that would otherwise break our proof flow and concentration</p>



<a name="148097485"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148097485" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#148097485">(Nov 21 2018 at 09:14)</a>:</h4>
<p>There's something wrong with the routine that makes <code>linarith</code> work for <code>nat</code> and the part that deals with negated hypotheses, I'll look into it when I have a minute.</p>



<a name="148097660"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148097660" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#148097660">(Nov 21 2018 at 09:18)</a>:</h4>
<p>Nice! In the mean time, Johan can use <code>replace ha := le_of_not_lt ha ; linarith</code> to close that goal</p>



<a name="148097675"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148097675" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#148097675">(Nov 21 2018 at 09:18)</a>:</h4>
<p>Or <code>apply ha; linarith</code>.</p>



<a name="148097682"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148097682" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#148097682">(Nov 21 2018 at 09:18)</a>:</h4>
<p>indeed</p>



<a name="148099129"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148099129" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#148099129">(Nov 21 2018 at 09:49)</a>:</h4>
<p>Another <code>linarith</code>wishlist entry: if there is an assumption <code>abs x ≤ c</code>, convert it to <code>x ≤ c</code> and <code>-x ≤ c</code>.</p>



<a name="148101337"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148101337" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#148101337">(Nov 21 2018 at 10:36)</a>:</h4>
<p>There are various unfolding/preprocessing things like that, that <code>linarith</code> could do. Writing a separate tactic that unfolds <code>abs</code> would be very easy, and you could even add <code>meta def linarith' := unfold_abs; linarith</code> if you wanted. But I'm not sure that bundling all these things into the main tactic is a good idea.</p>



<a name="148101362"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148101362" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#148101362">(Nov 21 2018 at 10:37)</a>:</h4>
<p>There's now a PR open to fix Johan's problem, btw.</p>



<a name="148101659"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148101659" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#148101659">(Nov 21 2018 at 10:45)</a>:</h4>
<p>OK, I understand. I can definitely unfold it by hand when needed. I am just motivated by the principle of maximal laziness.</p>



<a name="148104169"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148104169" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#148104169">(Nov 21 2018 at 11:34)</a>:</h4>
<p><span class="user-mention" data-user-id="110596">@Rob Lewis</span> Cool! Thanks a lot.</p>



<a name="148104182"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148104182" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#148104182">(Nov 21 2018 at 11:35)</a>:</h4>
<p>Now there is still the problem with <code>nat.succ _</code> vs <code>_ + 1</code>. Could that be fixed as well?</p>



<a name="148104248"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148104248" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#148104248">(Nov 21 2018 at 11:36)</a>:</h4>
<p>Because then I could run <code>split_ifs with foo bar; {ext, simp, linarith}</code> and be done with it. Otherwise I need to explicitly <code>change</code> my goal for each goal. Or should I write a custom simp-lemma for this, that I use locally?</p>



<a name="148104284"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148104284" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#148104284">(Nov 21 2018 at 11:37)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">δ_monotone</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="o">[</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">])</span> <span class="o">:</span> <span class="n">monotone</span> <span class="o">(</span><span class="n">δ</span> <span class="n">i</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">intros</span> <span class="n">a</span> <span class="n">b</span> <span class="n">H</span><span class="o">,</span>
  <span class="n">change</span> <span class="n">a</span><span class="bp">.</span><span class="n">val</span> <span class="bp">≤</span> <span class="n">b</span><span class="bp">.</span><span class="n">val</span> <span class="n">at</span> <span class="n">H</span><span class="o">,</span>
  <span class="n">dsimp</span> <span class="o">[</span><span class="n">fin</span><span class="bp">.</span><span class="n">succ_above</span><span class="o">],</span>
  <span class="n">split_ifs</span> <span class="k">with</span> <span class="n">ha</span> <span class="n">hb</span><span class="bp">;</span>
  <span class="n">try</span> <span class="o">{</span> <span class="n">ext1</span><span class="o">,</span> <span class="n">simp</span><span class="o">,</span> <span class="n">linarith</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">ext1</span><span class="o">,</span> <span class="n">simp</span><span class="o">,</span> <span class="n">change</span> <span class="bp">_</span> <span class="bp">≤</span> <span class="bp">_</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">linarith</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">ext1</span><span class="o">,</span> <span class="n">simp</span><span class="o">,</span> <span class="n">change</span> <span class="bp">_</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">≤</span> <span class="bp">_</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">linarith</span> <span class="o">}</span>
<span class="kn">end</span>
</pre></div>



<a name="148104414"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148104414" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#148104414">(Nov 21 2018 at 11:40)</a>:</h4>
<p><span class="user-mention" data-user-id="110050">@Sebastien Gouezel</span> If you don't want to do it by hand, you can finish this and use it (or modify it to fit your purposes). Just use <code>unfold_abs; linarith</code> in place of <code>linarith</code>, or define an alias for that.</p>
<div class="codehilite"><pre><span></span><span class="kn">open</span> <span class="n">tactic</span>
<span class="kn">lemma</span> <span class="n">le_and_le_of_abs_le</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_linear_ordered_comm_group</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">abs</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span> <span class="bp">∧</span> <span class="bp">-</span><span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span> <span class="o">:=</span>
<span class="n">sorry</span>

<span class="n">meta</span> <span class="n">def</span> <span class="n">unfold_abs</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="n">local_context</span> <span class="bp">&gt;&gt;=</span> <span class="n">list</span><span class="bp">.</span><span class="n">mmap&#39;</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">e</span><span class="o">,</span> <span class="n">try</span> <span class="o">(</span><span class="n">mk_app</span> <span class="bp">`</span><span class="n">le_and_le_of_abs_le</span> <span class="o">[</span><span class="n">e</span><span class="o">]</span> <span class="bp">&gt;&gt;=</span> <span class="n">cases</span><span class="o">))</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">abs</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="n">abs</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">c</span><span class="o">)</span> <span class="o">:</span> <span class="n">true</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">unfold_abs</span>
<span class="kn">end</span>
</pre></div>



<a name="148104502"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148104502" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#148104502">(Nov 21 2018 at 11:41)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span> This falls into the same basket as Sebastien's request. There are lots of constants that can be unfolded or rewritten into a form that <code>linarith</code> will handle. I don't want to build them all in. You can just add <code>nat.succ_eq_add_one</code> to the <code>simp</code> call.</p>



<a name="148104578"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148104578" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#148104578">(Nov 21 2018 at 11:42)</a>:</h4>
<p>Ok, thanks, will do.</p>



<a name="148104774"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148104774" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#148104774">(Nov 21 2018 at 11:47)</a>:</h4>
<blockquote>
<p>maybe stop (over)relying on tactics</p>
</blockquote>
<p><span class="user-mention" data-user-id="110064">@Kenny Lau</span> Can you golf this?</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">δ_monotone</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="o">[</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">])</span> <span class="o">:</span> <span class="n">monotone</span> <span class="o">(</span><span class="n">δ</span> <span class="n">i</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">a</span><span class="bp">.</span><span class="n">val</span> <span class="bp">≤</span> <span class="n">b</span><span class="bp">.</span><span class="n">val</span><span class="o">),</span>
<span class="k">by</span> <span class="n">dsimp</span> <span class="o">[</span><span class="n">fin</span><span class="bp">.</span><span class="n">succ_above</span><span class="o">]</span><span class="bp">;</span> <span class="n">split_ifs</span> <span class="k">with</span> <span class="n">ha</span> <span class="n">hb</span><span class="bp">;</span> <span class="o">{</span> <span class="n">ext1</span><span class="o">,</span> <span class="n">simp</span> <span class="o">[</span><span class="n">nat</span><span class="bp">.</span><span class="n">succ_eq_add_one</span><span class="o">],</span> <span class="n">linarith</span> <span class="o">}</span>
</pre></div>


<p>You can find it here: <a href="https://github.com/leanprover-community/mathlib/blob/simplicial/algebraic_topology/simplex_category.lean#L33-L35" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/simplicial/algebraic_topology/simplex_category.lean#L33-L35">https://github.com/leanprover-community/mathlib/blob/simplicial/algebraic_topology/simplex_category.lean#L33-L35</a></p>



<a name="148105362"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148105362" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#148105362">(Nov 21 2018 at 12:00)</a>:</h4>
<p><span class="user-mention" data-user-id="110596">@Rob Lewis</span> So presumably goals of this form are also outside the scope of <code>linarith</code>?</p>
<div class="codehilite"><pre><span></span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span>
<span class="n">i</span> <span class="n">j</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">),</span>
<span class="n">H</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">≤</span> <span class="n">j</span><span class="o">,</span>
<span class="n">a</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">),</span>
<span class="n">h</span> <span class="o">:</span> <span class="n">a</span><span class="bp">.</span><span class="n">val</span> <span class="bp">&lt;</span> <span class="n">i</span><span class="bp">.</span><span class="n">val</span><span class="o">,</span>
<span class="n">h_1</span> <span class="o">:</span> <span class="o">(</span><span class="n">fin</span><span class="bp">.</span><span class="n">cast_succ</span> <span class="n">a</span><span class="o">)</span><span class="bp">.</span><span class="n">val</span> <span class="bp">&lt;</span> <span class="o">(</span><span class="n">fin</span><span class="bp">.</span><span class="n">succ</span> <span class="n">j</span><span class="o">)</span><span class="bp">.</span><span class="n">val</span><span class="o">,</span>
<span class="n">h_2</span> <span class="o">:</span> <span class="bp">¬</span><span class="n">a</span><span class="bp">.</span><span class="n">val</span> <span class="bp">&lt;</span> <span class="n">j</span><span class="bp">.</span><span class="n">val</span><span class="o">,</span>
<span class="n">h_3</span> <span class="o">:</span> <span class="bp">¬</span><span class="o">(</span><span class="n">fin</span><span class="bp">.</span><span class="n">succ</span> <span class="n">a</span><span class="o">)</span><span class="bp">.</span><span class="n">val</span> <span class="bp">&lt;</span> <span class="n">i</span><span class="bp">.</span><span class="n">val</span>
<span class="err">⊢</span> <span class="n">a</span><span class="bp">.</span><span class="n">val</span> <span class="bp">=</span> <span class="mi">1</span> <span class="bp">+</span> <span class="o">(</span><span class="mi">1</span> <span class="bp">+</span> <span class="n">a</span><span class="bp">.</span><span class="n">val</span><span class="o">)</span>
</pre></div>


<p>I have 7 goals that are all of this form or another... I would like to kill them all in one go.</p>



<a name="148105382"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148105382" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#148105382">(Nov 21 2018 at 12:00)</a>:</h4>
<p>Sorry, I should paste context...</p>



<a name="148105384"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148105384" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#148105384">(Nov 21 2018 at 12:00)</a>:</h4>
<p>So these are nats?</p>



<a name="148105470"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148105470" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#148105470">(Nov 21 2018 at 12:03)</a>:</h4>
<p>What is the argument in maths?</p>



<a name="148105480"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148105480" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#148105480">(Nov 21 2018 at 12:03)</a>:</h4>
<p>Um, <code>linarith</code> doesn't know anything about the relation between <code>fin</code> and <code>fin.val</code>, or anything about <code>fin.succ</code> or <code>fin.cast_succ</code>.</p>



<a name="148105484"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148105484" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#148105484">(Nov 21 2018 at 12:03)</a>:</h4>
<p>I am not sure you can ask <code>linarith</code> to start unfolding <code>fin.succ</code> or stuff like that</p>



<a name="148105487"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148105487" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#148105487">(Nov 21 2018 at 12:03)</a>:</h4>
<p>There will be a never-ending list of things you want it to unfold.</p>



<a name="148105530"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148105530" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#148105530">(Nov 21 2018 at 12:04)</a>:</h4>
<p>Basically, those are a bunch of random inequalities between distinct variables, not even all of the same type.</p>



<a name="148105541"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148105541" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#148105541">(Nov 21 2018 at 12:04)</a>:</h4>
<p>The only thing <code>linarith</code> will learn is that <code>j.val &lt; i.val</code>.</p>



<a name="148105559"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148105559" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#148105559">(Nov 21 2018 at 12:05)</a>:</h4>
<p>What about <code>x ∈ {a : ℕ | a &gt; 5}</code> ? That unfolds to an inequality, but it's surely not <code>linarith</code>'s job to figure that out.</p>



<a name="148105571"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148105571" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#148105571">(Nov 21 2018 at 12:05)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span> there must be such a function in mathlib</p>



<a name="148105575"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148105575" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#148105575">(Nov 21 2018 at 12:06)</a>:</h4>
<p>(or not)</p>



<a name="148105617"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148105617" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#148105617">(Nov 21 2018 at 12:06)</a>:</h4>
<p>(yes it’s decidable)</p>



<a name="148105647"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148105647" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#148105647">(Nov 21 2018 at 12:07)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> right, see my last few comments. <span class="emoji emoji-1f642" title="slight smile">:slight_smile:</span> Infinitely many things can unfold to linear inequalities. If <code>linarith</code> tries everything possible it will be unpredictable and slow.</p>



<a name="148105717"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148105717" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#148105717">(Nov 21 2018 at 12:09)</a>:</h4>
<p>Cool, I'm getting the hang of this! <span class="user-mention" data-user-id="110596">@Rob Lewis</span> Thanks for your help. I'm starting to understand how to play with <code>linarith</code>.<br>
After:</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">simplicial_identity₁</span> <span class="o">{</span><span class="n">i</span> <span class="n">j</span> <span class="o">:</span> <span class="o">[</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">]}</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">≤</span> <span class="n">j</span><span class="o">)</span> <span class="o">:</span> <span class="n">δ</span> <span class="n">j</span><span class="bp">.</span><span class="n">succ</span> <span class="err">∘</span> <span class="n">δ</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">δ</span> <span class="n">i</span><span class="bp">.</span><span class="n">cast_succ</span> <span class="err">∘</span> <span class="n">δ</span> <span class="n">j</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">change</span> <span class="n">i</span><span class="bp">.</span><span class="n">val</span> <span class="bp">≤</span> <span class="n">j</span><span class="bp">.</span><span class="n">val</span> <span class="n">at</span> <span class="n">H</span><span class="o">,</span>
  <span class="n">funext</span> <span class="n">a</span><span class="o">,</span>
  <span class="n">dsimp</span> <span class="o">[</span><span class="n">fin</span><span class="bp">.</span><span class="n">succ_above</span><span class="o">],</span>
  <span class="n">split_ifs</span><span class="bp">;</span> <span class="o">{</span> <span class="n">try</span> <span class="o">{</span><span class="n">ext1</span><span class="o">},</span> <span class="n">try</span> <span class="o">{</span><span class="n">simp</span> <span class="o">[</span><span class="n">nat</span><span class="bp">.</span><span class="n">succ_eq_add_one</span><span class="o">]</span> <span class="n">at</span> <span class="bp">*</span><span class="o">},</span> <span class="n">try</span> <span class="o">{</span><span class="n">linarith</span><span class="o">}</span> <span class="o">},</span>
<span class="kn">end</span>
</pre></div>


<p>Before:</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">simplicial_identity₁</span> <span class="o">{</span><span class="n">i</span> <span class="n">j</span> <span class="o">:</span> <span class="o">[</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">]}</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">≤</span> <span class="n">j</span><span class="o">)</span> <span class="o">:</span> <span class="n">δ</span> <span class="n">j</span><span class="bp">.</span><span class="n">succ</span> <span class="err">∘</span> <span class="n">δ</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">δ</span> <span class="n">i</span><span class="bp">.</span><span class="n">cast_succ</span> <span class="err">∘</span> <span class="n">δ</span> <span class="n">j</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">funext</span> <span class="n">a</span><span class="o">,</span>
  <span class="n">dsimp</span> <span class="o">[</span><span class="n">fin</span><span class="bp">.</span><span class="n">succ_above</span><span class="o">],</span>
  <span class="n">by_cases</span> <span class="n">hja</span> <span class="o">:</span> <span class="o">(</span><span class="n">j</span><span class="bp">.</span><span class="n">val</span> <span class="bp">&lt;</span> <span class="n">a</span><span class="bp">.</span><span class="n">val</span><span class="o">),</span>
  <span class="o">{</span> <span class="k">have</span> <span class="n">hja&#39;</span> <span class="o">:</span> <span class="o">((</span><span class="n">fin</span><span class="bp">.</span><span class="n">succ</span> <span class="n">j</span><span class="o">)</span><span class="bp">.</span><span class="n">val</span> <span class="bp">&lt;</span> <span class="o">(</span><span class="n">fin</span><span class="bp">.</span><span class="n">succ</span> <span class="n">a</span><span class="o">)</span><span class="bp">.</span><span class="n">val</span><span class="o">)</span> <span class="o">:=</span>
    <span class="k">begin</span>
      <span class="n">simp</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">nat</span><span class="bp">.</span><span class="n">succ_le_succ</span> <span class="n">hja</span><span class="o">,</span>
    <span class="kn">end</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">hia</span> <span class="o">:</span> <span class="o">((</span><span class="n">i</span><span class="bp">.</span><span class="n">cast_succ</span><span class="o">)</span><span class="bp">.</span><span class="n">val</span> <span class="bp">&lt;</span> <span class="o">(</span><span class="n">fin</span><span class="bp">.</span><span class="n">succ</span> <span class="n">a</span><span class="o">)</span><span class="bp">.</span><span class="n">val</span><span class="o">)</span> <span class="o">:=</span>
    <span class="k">begin</span>
      <span class="n">simp</span><span class="o">,</span>
      <span class="n">refine</span> <span class="o">(</span><span class="n">lt_of_le_of_lt</span> <span class="n">H</span> <span class="bp">_</span><span class="o">),</span>
      <span class="n">exact</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">le_trans</span> <span class="n">hja</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">le_succ</span> <span class="n">a</span><span class="bp">.</span><span class="n">val</span><span class="o">))</span>
    <span class="kn">end</span><span class="o">,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">if_pos</span> <span class="n">hja</span><span class="o">,</span> <span class="n">if_pos</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">le_trans</span> <span class="n">H</span> <span class="n">hja</span><span class="o">),</span> <span class="n">if_pos</span> <span class="n">hja&#39;</span><span class="o">,</span> <span class="n">if_pos</span> <span class="n">hia</span><span class="o">]},</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">dif_neg</span> <span class="n">hja</span><span class="o">],</span>
    <span class="n">by_cases</span> <span class="n">hia</span> <span class="o">:</span> <span class="o">(</span><span class="n">i</span><span class="bp">.</span><span class="n">val</span> <span class="bp">≤</span> <span class="n">a</span><span class="bp">.</span><span class="n">val</span><span class="o">),</span>
    <span class="o">{</span> <span class="k">have</span> <span class="n">hia&#39;</span> <span class="o">:</span> <span class="o">((</span><span class="n">fin</span><span class="bp">.</span><span class="n">raise</span> <span class="n">i</span><span class="o">)</span><span class="bp">.</span><span class="n">val</span> <span class="bp">≤</span> <span class="o">(</span><span class="n">fin</span><span class="bp">.</span><span class="n">raise</span> <span class="n">a</span><span class="o">)</span><span class="bp">.</span><span class="n">val</span><span class="o">)</span> <span class="o">:=</span> <span class="n">hia</span><span class="o">,</span>

      <span class="k">have</span> <span class="n">hja&#39;</span> <span class="o">:</span> <span class="bp">¬</span><span class="o">(</span><span class="n">j</span><span class="bp">.</span><span class="n">succ</span><span class="bp">.</span><span class="n">val</span> <span class="bp">≤</span> <span class="n">a</span><span class="bp">.</span><span class="n">succ</span><span class="bp">.</span><span class="n">val</span><span class="o">)</span> <span class="o">:=</span>
      <span class="k">begin</span>
        <span class="n">simp</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
        <span class="n">exact</span> <span class="n">nat</span><span class="bp">.</span><span class="n">succ_le_succ</span> <span class="n">hja</span>
      <span class="kn">end</span><span class="o">,</span>
      <span class="n">rw</span> <span class="o">[</span><span class="n">dif_pos</span> <span class="n">hia</span><span class="o">,</span> <span class="n">dif_pos</span> <span class="n">hia&#39;</span><span class="o">,</span> <span class="n">dif_neg</span> <span class="n">hja&#39;</span><span class="o">],</span>
      <span class="n">simp</span> <span class="o">[</span><span class="n">fin</span><span class="bp">.</span><span class="n">raise</span><span class="o">],</span>
      <span class="n">apply</span> <span class="n">fin</span><span class="bp">.</span><span class="n">eq_of_veq</span><span class="o">,</span>
      <span class="n">simp</span><span class="o">},</span>
    <span class="o">{</span> <span class="k">have</span> <span class="n">hja&#39;</span> <span class="o">:</span> <span class="bp">¬</span><span class="o">(</span><span class="n">j</span><span class="bp">.</span><span class="n">succ</span><span class="bp">.</span><span class="n">val</span> <span class="bp">≤</span> <span class="n">a</span><span class="bp">.</span><span class="n">raise</span><span class="bp">.</span><span class="n">val</span><span class="o">)</span> <span class="o">:=</span>
      <span class="k">begin</span>
        <span class="n">simp</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
        <span class="n">exact</span> <span class="n">nat</span><span class="bp">.</span><span class="n">le_trans</span> <span class="n">hja</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">le_succ</span> <span class="n">j</span><span class="bp">.</span><span class="n">val</span><span class="o">)</span>
      <span class="kn">end</span><span class="o">,</span>
      <span class="k">have</span> <span class="n">hia&#39;</span> <span class="o">:</span> <span class="bp">¬</span><span class="o">((</span><span class="n">fin</span><span class="bp">.</span><span class="n">raise</span> <span class="n">i</span><span class="o">)</span><span class="bp">.</span><span class="n">val</span> <span class="bp">≤</span> <span class="o">(</span><span class="n">fin</span><span class="bp">.</span><span class="n">raise</span> <span class="n">a</span><span class="o">)</span><span class="bp">.</span><span class="n">val</span><span class="o">)</span> <span class="o">:=</span>
      <span class="k">begin</span>
        <span class="n">unfold</span> <span class="n">fin</span><span class="bp">.</span><span class="n">raise</span><span class="o">,</span> <span class="n">exact</span> <span class="n">hia</span>
      <span class="kn">end</span><span class="o">,</span>
      <span class="n">rw</span> <span class="o">[</span><span class="n">dif_neg</span> <span class="n">hia</span><span class="o">,</span> <span class="n">dif_neg</span> <span class="n">hja&#39;</span><span class="o">,</span> <span class="n">dif_neg</span> <span class="n">hia&#39;</span><span class="o">]}}</span>
<span class="kn">end</span>
</pre></div>



<a name="148106009"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148106009" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#148106009">(Nov 21 2018 at 12:15)</a>:</h4>
<p><span class="user-mention" data-user-id="110064">@Kenny Lau</span> Do you mean it should be provable by <code>dec_trivial</code>?</p>



<a name="148122480"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148122480" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#148122480">(Nov 21 2018 at 16:48)</a>:</h4>
<p><span class="user-mention" data-user-id="110031">@Patrick Massot</span> <span class="user-mention" data-user-id="110596">@Rob Lewis</span> Did the problem turn out to be <code>mono</code>?</p>



<a name="148122892"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148122892" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#148122892">(Nov 21 2018 at 16:54)</a>:</h4>
<p><code>linarith</code> doesn't use <code>mono</code> so the bug in <code>linarith</code> had nothing to do with <code>mono</code> (and is now fixed). But I'm still disappointed I can't get <code>mono</code> to help here</p>



<a name="148123052"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148123052" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#148123052">(Nov 21 2018 at 16:56)</a>:</h4>
<p>You can try, what I posted right after pinging you is a MWE</p>



<a name="148123091"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148123091" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#148123091">(Nov 21 2018 at 16:57)</a>:</h4>
<p>search for "does nothing" in this thread</p>



<a name="148124879"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148124879" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#148124879">(Nov 21 2018 at 17:23)</a>:</h4>
<p>I wouldn't expect it to do anything in that case. What would you expect it to do?</p>



<a name="148125029"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148125029" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#148125029">(Nov 21 2018 at 17:25)</a>:</h4>
<p>I would expect it to close the goal</p>



<a name="148128435"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148128435" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#148128435">(Nov 21 2018 at 18:23)</a>:</h4>
<p>You mean using mixed transitivity? It doesn’t do that. What it does is identify a monotonic function on either side of a relation. &lt; is that relation in your case but it doesn’t have a monotonic function on both sides.</p>



<a name="148128458"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148128458" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#148128458">(Nov 21 2018 at 18:23)</a>:</h4>
<p>If you want, you can treat &lt; as the monotonic function and -&gt; as the relation.</p>



<a name="148128569"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148128569" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#148128569">(Nov 21 2018 at 18:25)</a>:</h4>
<p>To do that, you need to do <code>revert h</code> before mono.</p>



<a name="148131648"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148131648" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#148131648">(Nov 21 2018 at 19:18)</a>:</h4>
<p>This is sad. We need something like <code>cc</code> for inequality, working together with <code>mono</code></p>



<a name="148131680"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148131680" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#148131680">(Nov 21 2018 at 19:19)</a>:</h4>
<p>Maybe something like what I did for tfae would work for that</p>



<a name="148131689"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148131689" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#148131689">(Nov 21 2018 at 19:19)</a>:</h4>
<p>Except <code>tfae</code> doesn't work <span class="emoji emoji-2639" title="sad">:sad:</span></p>



<a name="148131747"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148131747" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#148131747">(Nov 21 2018 at 19:20)</a>:</h4>
<p>The following is ridiculous but gives hope:</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="n">r</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">≤</span> <span class="n">q</span><span class="o">)</span> <span class="o">(</span><span class="n">h&#39;</span> <span class="o">:</span> <span class="n">q</span> <span class="bp">≤</span> <span class="n">r</span><span class="o">)</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">≤</span> <span class="n">r</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">refine</span> <span class="n">le_trans</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">swap</span><span class="o">,</span>
  <span class="n">tauto</span><span class="o">,</span>
  <span class="n">tauto</span>
<span class="kn">end</span>
</pre></div>



<a name="148131762"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148131762" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#148131762">(Nov 21 2018 at 19:21)</a>:</h4>
<p>This is the kind goal I hope some "<code>cc</code> for inequalities" would solve</p>



<a name="148131878"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148131878" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#148131878">(Nov 21 2018 at 19:23)</a>:</h4>
<p>What is tricky for this kind of tactic is that one would expect it to work in the case of mixed transitivity which makes selecting a relation a bit more difficult. I could do it specifically for <code>&lt;</code> and <code>≤</code> to simplify things but it's a bit disappointing in terms of generality</p>



<a name="148131995"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148131995" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#148131995">(Nov 21 2018 at 19:25)</a>:</h4>
<p>But in the situations that you're showing, it seems like the kind of stuff <code>linarith</code> should handle</p>



<a name="148135817"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148135817" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#148135817">(Nov 21 2018 at 20:36)</a>:</h4>
<p>Patrick, can you elaborate on what you mean by "cc for inequalities"?</p>



<a name="148135937"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148135937" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#148135937">(Nov 21 2018 at 20:38)</a>:</h4>
<p>I think he more or less means solvable using linear order axioms, without any algebra.</p>



<a name="148135954"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148135954" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#148135954">(Nov 21 2018 at 20:39)</a>:</h4>
<p>But I think linarith does those.</p>



<a name="148136093"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148136093" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#148136093">(Nov 21 2018 at 20:41)</a>:</h4>
<p>Ah. Yeah, linarith does those. But I guess it requires some extra algebraic structure on the type that isn't always necessary.</p>



<a name="148136290"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148136290" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#148136290">(Nov 21 2018 at 20:45)</a>:</h4>
<p>And maybe preorder axioms and partial order axioms would be nice as well.</p>



<a name="148136993"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148136993" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#148136993">(Nov 21 2018 at 20:59)</a>:</h4>
<p>Indeed. A tactic for this kind of transitivity reasoning would be a nice project for someone who wants to learn about writing tactics. <span class="emoji emoji-1f609" title="wink">:wink:</span></p>



<a name="148136997"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148136997" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#148136997">(Nov 21 2018 at 20:59)</a>:</h4>
<p>Note, I haven't really looked into <code>mono</code> yet, so I'm not sure how much overlap there is.</p>



<a name="148137165"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148137165" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#148137165">(Nov 21 2018 at 21:03)</a>:</h4>
<p>There isn't much overlap actually. To implement this tactic, tfae would be more helpful. It calculates the transitive closure of implication on the local assumptions.</p>



<a name="148137182"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148137182" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#148137182">(Nov 21 2018 at 21:04)</a>:</h4>
<p>You replace implication by a preorder and you'd get what Patrick is talking about with the additional difficulty of handling <code>&lt;</code> properly</p>



<a name="148137301"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148137301" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#148137301">(Nov 21 2018 at 21:06)</a>:</h4>
<p>Ah, sure. Sounds reasonable enough.</p>



<a name="148140643"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148140643" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#148140643">(Nov 21 2018 at 22:16)</a>:</h4>
<p>I'd love to try to understand how to adapt <code>tfae</code> here, but again I don't think this would be reasonable before we get a deterministic behavior from <code>tfae</code></p>



<a name="148181673"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148181673" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#148181673">(Nov 22 2018 at 15:30)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span> I see someone has figured out the function in mathlib</p>



<a name="148187179"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148187179" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#148187179">(Nov 22 2018 at 17:24)</a>:</h4>
<p><span class="user-mention" data-user-id="110064">@Kenny Lau</span> Wait, which function in mathlib are you referring to?</p>



<a name="148190141"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148190141" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#148190141">(Nov 22 2018 at 18:39)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span> <code>fin.succ_above</code></p>



<a name="148191135"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148191135" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#148191135">(Nov 22 2018 at 19:07)</a>:</h4>
<p>Aah, yes, I'm using that one. Was that answering a question of mine?</p>



<a name="148191179"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148191179" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#148191179">(Nov 22 2018 at 19:08)</a>:</h4>
<p>Or maybe you just think it is confusing notation? It probably is...</p>



<a name="148191834"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148191834" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#148191834">(Nov 22 2018 at 19:29)</a>:</h4>
<p>never mind, ignore me</p>



<a name="148254707"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148254707" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#148254707">(Nov 23 2018 at 23:59)</a>:</h4>
<p>More requests: are these reasonable to expect from <code>linarith</code>?</p>
<div class="codehilite"><pre><span></span>n m : ℕ,
h₁ : n &lt; m,
⊢ n + 1 ≤ m
</pre></div>


<p>and</p>
<div class="codehilite"><pre><span></span>n m l : ℕ,
a_left : n ≤ l,
a_right : l &lt; n + (m - n)
⊢ l &lt; m
</pre></div>


<p>and</p>
<div class="codehilite"><pre><span></span>a_left : n ≤ l,
a_right : l &lt; m
⊢ l &lt; n + (m - n)
</pre></div>



<a name="148256879"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148256879" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#148256879">(Nov 24 2018 at 01:16)</a>:</h4>
<blockquote>
<p>The following is ridiculous but gives hope:</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="n">r</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">≤</span> <span class="n">q</span><span class="o">)</span> <span class="o">(</span><span class="n">h&#39;</span> <span class="o">:</span> <span class="n">q</span> <span class="bp">≤</span> <span class="n">r</span><span class="o">)</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">≤</span> <span class="n">r</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">refine</span> <span class="n">le_trans</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">swap</span><span class="o">,</span>
  <span class="n">tauto</span><span class="o">,</span>
  <span class="n">tauto</span>
<span class="kn">end</span>
</pre></div>


<p>This is the kind of goal I hope some "<code>cc</code> for inequalities" would solve</p>
</blockquote>
<p>So like this?</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">nat</span><span class="bp">.</span><span class="n">basic</span>

<span class="n">meta</span> <span class="n">def</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">interactive</span><span class="bp">.</span><span class="n">cc_inequality</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="bp">`</span><span class="o">[</span><span class="n">transitivity</span><span class="bp">;</span> <span class="n">tauto</span><span class="o">]</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="n">r</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">≤</span> <span class="n">q</span><span class="o">)</span> <span class="o">(</span><span class="n">h&#39;</span> <span class="o">:</span> <span class="n">q</span> <span class="bp">≤</span> <span class="n">r</span><span class="o">)</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">≤</span> <span class="n">r</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">cc_inequality</span>
</pre></div>



<a name="148263754"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148263754" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#148263754">(Nov 24 2018 at 05:33)</a>:</h4>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span> Your first question is <code>exact h1</code>, so I would hope that <code>linarith</code> could do it.  The second and third are nasty because they use nat-subtraction. I think we still need a <code>num_cast</code> tactic that would lift it to <code>int</code>, and then <code>linarith</code> could do the job.</p>



<a name="148265222"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148265222" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Ashworth <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#148265222">(Nov 24 2018 at 06:27)</a>:</h4>
<p>Cooper will kill these, if you're willing to use another dependency</p>



<a name="148265691"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148265691" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#148265691">(Nov 24 2018 at 06:42)</a>:</h4>
<p>Am I allowed to import <code>cooper</code> into <code>data.nat.basic</code>? :-)</p>



<a name="148265692"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148265692" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#148265692">(Nov 24 2018 at 06:42)</a>:</h4>
<p>Thanks for the suggestion, I will try out cooper!</p>



<a name="148270921"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148270921" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#148270921">(Nov 24 2018 at 09:54)</a>:</h4>
<p><code>linarith</code> will not prove any of those. Think of it as a tactic for linear rational inequalities.  If a goal over <code>int</code> is still provable when you replace <code>int</code> with <code>rat</code>, it will still work. Inequalities over <code>nat</code> are cast to inequalities over <code>int</code>, with extra assumptions that all atoms are nonnegative. Applications of nat subtraction are treated as atoms.</p>



<a name="148270931"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148270931" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#148270931">(Nov 24 2018 at 09:55)</a>:</h4>
<p>The first one isn't true in a dense order. The second ones involve properties of nat subtraction beyond nonnegativity.</p>



<a name="148270979"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148270979" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#148270979">(Nov 24 2018 at 09:56)</a>:</h4>
<p><code>cooper</code> isn't in mathlib, it's in Seul's repository. Use it, of course, but incorporating it into mathlib is a bigger discussion.</p>



<a name="148271514"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148271514" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#148271514">(Nov 24 2018 at 10:13)</a>:</h4>
<p>Would it be possible to edit <code>linarith</code> so that it automatically knows that variables coerced from nat are nonnegative? Compare:</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span><span class="o">:</span><span class="n">a</span><span class="bp">≥</span><span class="mi">0</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="mi">3</span><span class="o">:</span><span class="n">ℚ</span><span class="o">)</span><span class="bp">/</span><span class="mi">4</span> <span class="bp">≤</span> <span class="o">(</span><span class="mi">4</span><span class="o">:</span><span class="n">ℚ</span><span class="o">)</span> <span class="bp">+</span> <span class="n">a</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">linarith</span> <span class="c1">--works</span>
<span class="kn">example</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="mi">3</span><span class="o">:</span><span class="n">ℚ</span><span class="o">)</span><span class="bp">/</span><span class="mi">4</span> <span class="bp">≤</span> <span class="o">(</span><span class="mi">4</span><span class="o">:</span><span class="n">ℚ</span><span class="o">)</span> <span class="bp">+</span> <span class="err">↑</span><span class="n">a</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">linarith</span> <span class="c1">-- fails</span>
<span class="kn">example</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span><span class="o">:</span><span class="n">a</span><span class="bp">≥</span><span class="mi">0</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="mi">3</span><span class="o">:</span><span class="n">ℚ</span><span class="o">)</span><span class="bp">/</span><span class="mi">4</span> <span class="bp">≤</span> <span class="o">(</span><span class="mi">4</span><span class="o">:</span><span class="n">ℚ</span><span class="o">)</span> <span class="bp">+</span> <span class="err">↑</span><span class="n">a</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">linarith</span> <span class="c1">-- even this fails</span>
</pre></div>



<a name="148273249"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148273249" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#148273249">(Nov 24 2018 at 11:07)</a>:</h4>
<p><code>linarith</code> isn't a smart tactic. It does one thing (linear rational arithmetic) very well, and by coincidence, sometimes it can do things with <code>nat</code> and <code>int</code>. In your second example, it doesn't know any connection between <code>a</code> and <code>↑a</code>, and why should it? Instead of a cast, that could be <code>abs</code>, or <code>square</code>, or any nonnegative function. In the very special case when it sees an inequality over <code>nat</code>, it will cast it to <code>int</code> and add the nonnegativity hypotheses. But it won't go digging through the input looking for things it can learn are nonnegative. That's a kind of preprocessing that can be done separately.</p>



<a name="148273254"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148273254" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#148273254">(Nov 24 2018 at 11:08)</a>:</h4>
<p>The third example is a little different. It sees the <code>a &gt;= 0</code> hypothesis, and casts it to <code>int</code>. But the overall problem is in <code>rat</code>.</p>



<a name="148273298"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148273298" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#148273298">(Nov 24 2018 at 11:08)</a>:</h4>
<p>In general, there's no well-defined type of the "overall problem," since you could have hypotheses over many different types.</p>



<a name="148273305"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148273305" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#148273305">(Nov 24 2018 at 11:09)</a>:</h4>
<p>It could try to guess what type to cast to, or it could cast to every type that appears. This wouldn't be so unreasonable.</p>



<a name="148283001"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148283001" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#148283001">(Nov 24 2018 at 16:24)</a>:</h4>
<p>Thanks for explaining! As always, there was a lot of complexity lurking here that I didn't appreciate.</p>



<a name="199178649"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/199178649" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#199178649">(May 29 2020 at 16:32)</a>:</h4>
<p>Linarith just failed me on a goal that seemed to me to be in its range of applicability. I know that it is not supposed to be extended further, but still I wanted to mention it here:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">lemma</span> <span class="n">zou</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">¬</span> <span class="o">(</span><span class="n">x</span> <span class="bp">&lt;</span> <span class="mi">0</span><span class="o">))</span> <span class="o">(</span><span class="n">h&#39;</span> <span class="o">:</span> <span class="bp">¬</span> <span class="o">(</span><span class="n">x</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">))</span> <span class="o">(</span><span class="n">h&#39;&#39;</span> <span class="o">:</span> <span class="bp">¬</span><span class="o">(</span><span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">x</span><span class="o">))</span> <span class="o">:</span> <span class="n">false</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">linarith</span><span class="o">,</span> <span class="c1">-- fails</span>
<span class="kn">end</span>
</code></pre></div>



<a name="199178846"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/199178846" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#199178846">(May 29 2020 at 16:33)</a>:</h4>
<p>By the way, <code>hint</code> is not really happy with this lemma, as it complains</p>
<div class="codehilite"><pre><span></span><code><span class="n">Cannot</span> <span class="n">reify</span> <span class="n">expr</span> <span class="o">:</span>
<span class="n">false</span>
</code></pre></div>



<a name="199179093"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/199179093" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#199179093">(May 29 2020 at 16:35)</a>:</h4>
<p>it might be note-worthy that <code>apply h', linarith</code> succeeds</p>



<a name="199184325"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/199184325" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#199184325">(May 29 2020 at 17:18)</a>:</h4>
<p>What happens if you pushneg all the nots away first?</p>



<a name="199193519"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/199193519" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#199193519">(May 29 2020 at 18:31)</a>:</h4>
<p>If there are <code>n</code> disequalities in the context then <code>linarith</code> would have to run <code>2^n</code> times. "Not equals" isn't analogous to "not less than" in this context.</p>



<a name="199193686"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/199193686" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#199193686">(May 29 2020 at 18:32)</a>:</h4>
<p>The same applies for = in a goal, except there can be at most one there.</p>



<a name="199235969"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/199235969" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#199235969">(May 30 2020 at 03:35)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110050">Sebastien Gouezel</span> <a href="#narrow/stream/113488-general/topic/linarith/near/199178846">said</a>:</p>
<blockquote>
<p>By the way, <code>hint</code> is not really happy with this lemma, as it complains</p>
<div class="codehilite"><pre><span></span><code><span class="n">Cannot</span> <span class="n">reify</span> <span class="n">expr</span> <span class="o">:</span>
<span class="n">false</span>
</code></pre></div>


</blockquote>
<p>It seems that it is <code>omega</code> which prints this error message.</p>



<a name="199236017"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/199236017" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#199236017">(May 30 2020 at 03:36)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">omega</span>

<span class="kn">lemma</span> <span class="n">zou</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">¬</span> <span class="o">(</span><span class="n">x</span> <span class="bp">&lt;</span> <span class="mi">0</span><span class="o">))</span> <span class="o">(</span><span class="n">h&#39;</span> <span class="o">:</span> <span class="bp">¬</span> <span class="o">(</span><span class="n">x</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">))</span> <span class="o">(</span><span class="n">h&#39;&#39;</span> <span class="o">:</span> <span class="bp">¬</span><span class="o">(</span><span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">x</span><span class="o">))</span> <span class="o">:</span> <span class="n">false</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">omega</span><span class="o">,</span> <span class="c1">-- prints &quot;Cannot reify expr : false&quot;</span>
<span class="kn">end</span>
</code></pre></div>



<a name="199236088"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/199236088" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#199236088">(May 30 2020 at 03:38)</a>:</h4>
<p>I can see where in <code>omega</code> to turn off printing this message (and just fail silently). Shall we do that?</p>



<a name="199236514"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/199236514" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#199236514">(May 30 2020 at 03:50)</a>:</h4>
<p>It shouldn't fail silently, it should fail with this as the error message rather than print + fail</p>



<a name="199236531"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/199236531" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#199236531">(May 30 2020 at 03:51)</a>:</h4>
<p>(it should also be fixed to be able to reify <code>false</code>)</p>



<a name="204820484"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/204820484" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Paul Rowe <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#204820484">(Jul 23 2020 at 16:29)</a>:</h4>
<p>I'm curious if anything ever happened with this. I have run into this situation plenty of times: the target is false, and <code>omega</code> is strong enough to deduce that the hypotheses are inconsistent. I've been using the following (admittedly very idiosyncratic) pattern to deal with it:</p>
<div class="codehilite"><pre><span></span><code><span class="n">suffices</span> <span class="n">d</span><span class="o">:</span><span class="mi">1</span><span class="bp">&lt;</span><span class="mi">0</span><span class="o">,</span> <span class="k">by</span> <span class="n">linarith</span> <span class="n">only</span> <span class="o">[</span><span class="n">d</span><span class="o">],</span>
<span class="n">omega</span>
</code></pre></div>


<p>It feels odd every time I do it because there must be a better way, but I haven't found it yet. Also, while <code>linarith</code> will often work in these situations, it's much more expensive than <code>omega</code> which is why I restrict it to deriving false from an obvious inconsistency just to enable <code>omega</code>.</p>



<a name="204820970"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/204820970" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#204820970">(Jul 23 2020 at 16:33)</a>:</h4>
<p>does it work to <code>revert</code> one of the hypotheses (maybe one that looks like an inequality?) and then call <code>omega</code>? That should be both shorter and faster than your solution with <code>linarith</code></p>



<a name="204821360"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/204821360" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Paul Rowe <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#204821360">(Jul 23 2020 at 16:36)</a>:</h4>
<p>Oh that's clever. Yes, it does work on the first example I found. It's certainly way better than invoking <code>linarith</code> but still seems a little odd that <code>omega</code> cannot be applied directly.</p>



<a name="204822366"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/204822366" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#204822366">(Jul 23 2020 at 16:43)</a>:</h4>
<p><code>omega</code> has many bugs and this is one of them. Unfortunately the person who wrote it is not available to fix it and it's a project. But <code>linarith</code> should not be slower than <code>omega</code> (when they both work). There are goals that <code>omega</code> should solve in principle that <code>linarith</code> can't.</p>



<a name="204823100"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/204823100" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Paul Rowe <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#204823100">(Jul 23 2020 at 16:50)</a>:</h4>
<p>I see. Well, I'm glad we at least have <code>omega</code> in the form it's in! My observation of <code>omega</code> being faster than <code>linarith</code> is anecdotal in that I haven't run any unit tests or anything to compare them. All I know is that when I first encountered the issue, my bloated proofs ran much better with <code>omega</code> than with <code>linarith</code>.  In any case, I am mostly happy to learn that I am not missing something simple about <code>omega</code> that is obvious to others. Thanks for the replies!</p>



<a name="207018711"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/207018711" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/linarith.html#207018711">(Aug 15 2020 at 12:00)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110050">Sebastien Gouezel</span> <a href="#narrow/stream/113488-general/topic/linarith/near/199178649">said</a>:</p>
<blockquote>
<p>Linarith just failed me on a goal that seemed to me to be in its range of applicability. I know that it is not supposed to be extended further, but still I wanted to mention it here:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">lemma</span> <span class="n">zou</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">¬</span> <span class="o">(</span><span class="n">x</span> <span class="bp">&lt;</span> <span class="mi">0</span><span class="o">))</span> <span class="o">(</span><span class="n">h&#39;</span> <span class="o">:</span> <span class="bp">¬</span> <span class="o">(</span><span class="n">x</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">))</span> <span class="o">(</span><span class="n">h&#39;&#39;</span> <span class="o">:</span> <span class="bp">¬</span><span class="o">(</span><span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">x</span><span class="o">))</span> <span class="o">:</span> <span class="n">false</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">linarith</span><span class="o">,</span> <span class="c1">-- fails</span>
<span class="kn">end</span>
</code></pre></div>


</blockquote>
<p><a href="https://github.com/leanprover-community/mathlib/issues/3786">#3786</a> . I'm not giving in to peer pressure here! Mario needed branching preprocessors for something else, and handling disequality hypotheses was the simplest example of a branching preprocessor I could think of, so it was a good test. Don't go crazy with the new toy.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
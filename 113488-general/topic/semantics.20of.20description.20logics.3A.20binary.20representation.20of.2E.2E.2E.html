---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/semantics.20of.20description.20logics.3A.20binary.20representation.20of.2E.2E.2E.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/semantics.20of.20description.20logics.3A.20binary.20representation.20of.2E.2E.2E.html">semantics of description logics: binary representation of...</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="225874807"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/semantics%20of%20description%20logics%3A%20binary%20representation%20of.../near/225874807" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/semantics.20of.20description.20logics.3A.20binary.20representation.20of.2E.2E.2E.html#225874807">(Feb 10 2021 at 17:22)</a>:</h4>
<p>Imagine having to prove that <code>35 \ne 31</code>, you'd have to undo 30 <code>succ</code> to show that these terms are not the same.</p>



<a name="225875389"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/semantics%20of%20description%20logics%3A%20binary%20representation%20of.../near/225875389" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alexandre Rademaker <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/semantics.20of.20description.20logics.3A.20binary.20representation.20of.2E.2E.2E.html#225875389">(Feb 10 2021 at 17:26)</a>:</h4>
<p>Nice! I got it <span class="user-mention" data-user-id="308899">@Yakov Pechersky</span> ...  So bit0 is define for all types instances of <code>has_add</code>.  bit0 is the double of a value. the name <code>bit0</code> is not obvious.</p>



<a name="225875484"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/semantics%20of%20description%20logics%3A%20binary%20representation%20of.../near/225875484" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/semantics.20of.20description.20logics.3A.20binary.20representation.20of.2E.2E.2E.html#225875484">(Feb 10 2021 at 17:27)</a>:</h4>
<p>This is implicit in what others have said above but I didn't see it stated explicitly in this thread: numerals like <code>4</code> in Lean are just notation for things built out of <code>bit0</code> and <code>bit1</code> from <code>0</code> and <code>1</code> (which Lean gets from the <code>has_zero</code> and <code>has_one</code> typeclasses):</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">set_option</span> <span class="n">pp.numerals</span> <span class="n">false</span>
<span class="k">#check</span> <span class="mi">4</span> <span class="c1">-- bit0 (bit0 has_one.one) : ℕ</span>
</code></pre></div>



<a name="225875488"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/semantics%20of%20description%20logics%3A%20binary%20representation%20of.../near/225875488" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/semantics.20of.20description.20logics.3A.20binary.20representation.20of.2E.2E.2E.html#225875488">(Feb 10 2021 at 17:27)</a>:</h4>
<p>I think of it is <code>4</code> is <code>100</code> in binary, so read right to left, it is <code>bit0 (bit0 1)</code></p>



<a name="225875573"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/semantics%20of%20description%20logics%3A%20binary%20representation%20of.../near/225875573" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/semantics.20of.20description.20logics.3A.20binary.20representation.20of.2E.2E.2E.html#225875573">(Feb 10 2021 at 17:28)</a>:</h4>
<p>The point is that if you have a term written with <code>bit0</code> and <code>bit1</code>, like <code>bit1 $ bit0 $ bit1 $ bit0 $ bit0 1</code> then when you read it backwards you get the binary representation of the value, in this case <code>0b100101</code></p>



<a name="225875711"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/semantics%20of%20description%20logics%3A%20binary%20representation%20of.../near/225875711" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alexandre Rademaker <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/semantics.20of.20description.20logics.3A.20binary.20representation.20of.2E.2E.2E.html#225875711">(Feb 10 2021 at 17:29)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113488-general/topic/reasoning.20with.20strings/near/225871195">said</a>:</p>
<blockquote>
<p>Yes you can prove it directly using <code>nat.one_ne_bit0</code> but that's just what norm_num uses under the hood, users shouldn't need to interact with numerals on this level of abstraction</p>
</blockquote>
<p>That was my point above. The level of abstraction is important. It doesn't make sense having to deal with bit representation to prove that 1=4 is false.  What about <code>finish</code>. Does it calls <code>norm_num</code>? Or I should really use <code>norm_num</code>?</p>



<a name="225875719"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/semantics%20of%20description%20logics%3A%20binary%20representation%20of.../near/225875719" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/semantics.20of.20description.20logics.3A.20binary.20representation.20of.2E.2E.2E.html#225875719">(Feb 10 2021 at 17:29)</a>:</h4>
<p>Now, what's brutal is that the default cast in Lean of anything that has addition to <code>nat</code> is unary! There is a better <code>nat.bin_cast</code>. But unless the thing you're adding has nice properties (<code>add_monoid</code> or a subset of them depending on what you're adding), it's not provable that <code>nat.cast x = nat.bin_cast x</code></p>



<a name="225875919"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/semantics%20of%20description%20logics%3A%20binary%20representation%20of.../near/225875919" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/semantics.20of.20description.20logics.3A.20binary.20representation.20of.2E.2E.2E.html#225875919">(Feb 10 2021 at 17:30)</a>:</h4>
<p>That doesn't really matter though unless you use <code>#eval</code> on <code>nat.cast</code></p>



<a name="225876009"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/semantics%20of%20description%20logics%3A%20binary%20representation%20of.../near/225876009" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/semantics.20of.20description.20logics.3A.20binary.20representation.20of.2E.2E.2E.html#225876009">(Feb 10 2021 at 17:31)</a>:</h4>
<p>You can prove <code>(nat.cast 37 : real) = 37</code> in log n theorem applications</p>



<a name="225876020"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/semantics%20of%20description%20logics%3A%20binary%20representation%20of.../near/225876020" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/semantics.20of.20description.20logics.3A.20binary.20representation.20of.2E.2E.2E.html#225876020">(Feb 10 2021 at 17:31)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113488-general/topic/reasoning.20with.20strings/near/225875919">said</a>:</p>
<blockquote>
<p>That doesn't really matter though unless you use <code>#eval</code> on <code>nat.cast</code></p>
</blockquote>
<p><a href="https://github.com/leanprover-community/mathlib/pull/5462#discussion_r553226279">https://github.com/leanprover-community/mathlib/pull/5462#discussion_r553226279</a></p>



<a name="225876068"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/semantics%20of%20description%20logics%3A%20binary%20representation%20of.../near/225876068" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/semantics.20of.20description.20logics.3A.20binary.20representation.20of.2E.2E.2E.html#225876068">(Feb 10 2021 at 17:31)</a>:</h4>
<p>Which is a form of evaluation of <code>nat.cast</code>.</p>



<a name="225876083"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/semantics%20of%20description%20logics%3A%20binary%20representation%20of.../near/225876083" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/semantics.20of.20description.20logics.3A.20binary.20representation.20of.2E.2E.2E.html#225876083">(Feb 10 2021 at 17:31)</a>:</h4>
<p>yes, like I said</p>



<a name="225876103"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/semantics%20of%20description%20logics%3A%20binary%20representation%20of.../near/225876103" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/semantics.20of.20description.20logics.3A.20binary.20representation.20of.2E.2E.2E.html#225876103">(Feb 10 2021 at 17:31)</a>:</h4>
<p>don't evaluate <code>nat.cast</code> in the VM</p>



<a name="225876143"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/semantics%20of%20description%20logics%3A%20binary%20representation%20of.../near/225876143" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/semantics.20of.20description.20logics.3A.20binary.20representation.20of.2E.2E.2E.html#225876143">(Feb 10 2021 at 17:31)</a>:</h4>
<p>but you can use it to prove things</p>



<a name="225876439"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/semantics%20of%20description%20logics%3A%20binary%20representation%20of.../near/225876439" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/semantics.20of.20description.20logics.3A.20binary.20representation.20of.2E.2E.2E.html#225876439">(Feb 10 2021 at 17:33)</a>:</h4>
<p>In the PR you linked though, you are parsing decimal strings, so the obvious approach would be to look for 0-9 and evaluate <code>10*n+a</code>  for each digit</p>



<a name="225877043"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/semantics%20of%20description%20logics%3A%20binary%20representation%20of.../near/225877043" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alexandre Rademaker <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/semantics.20of.20description.20logics.3A.20binary.20representation.20of.2E.2E.2E.html#225877043">(Feb 10 2021 at 17:37)</a>:</h4>
<p><span class="user-mention silent" data-user-id="123965">Bryan Gin-ge Chen</span> <a href="#narrow/stream/113488-general/topic/reasoning.20with.20strings/near/225875484">said</a>:</p>
<blockquote>
<p>This is implicit in what others have said above but I didn't see it stated explicitly in this thread: numerals like <code>4</code> in Lean are just notation for things built out of <code>bit0</code> and <code>bit1</code> from <code>0</code> and <code>1</code> (which Lean gets from the <code>has_zero</code> and <code>has_one</code> typeclasses):</p>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">set_option</span> <span class="n">pp.numerals</span> <span class="n">false</span>
<span class="k">#check</span> <span class="mi">4</span> <span class="c1">-- bit0 (bit0 has_one.one) : ℕ</span>
</code></pre></div><br>
</p>
</blockquote>
<p>I see now, but they are not defined over 1 and 0 only, which was my initial difficulty. <code>bit0 1</code> reduces to 2 and <code>reduce bit0 2</code> reduces to 4, certainly because 2 first reduces to <code>bit0 1</code> then <code>bit0 2</code> is <code>bit0 $ bit0 1</code>..</p>
<p>BTW, in Emacs and Lean 3 (last version). The option you gave me shows <code>nat.zero.succ.succ</code> for <code>bit0 1</code>.</p>



<a name="225879006"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/semantics%20of%20description%20logics%3A%20binary%20representation%20of.../near/225879006" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alexandre Rademaker <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/semantics.20of.20description.20logics.3A.20binary.20representation.20of.2E.2E.2E.html#225879006">(Feb 10 2021 at 17:49)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113488-general/topic/reasoning.20with.20strings/near/225868145">said</a>:</p>
<blockquote>
<p>Actually, looking at your definitions, it seems like this result is correct: <code>Every hasChild man</code> seems to mean the collection of all people such that every child of theirs is a man, and since the men are <code>2,4</code>, the women are <code>1,3</code> and <code>2</code> is a child of <code>1</code> and <code>3</code> a child of <code>4</code>, the only person for which the predicate fails is <code>4</code> (all the nonbinaries at &gt;4 have no children so the concept is also satisfied for them)</p>
</blockquote>
<p>Hi <span class="user-mention" data-user-id="110049">@Mario Carneiro</span> , Indeed, this is the right interpretation of description logic. At the end of my file, I point to <a href="https://arxiv.org/pdf/1201.4089v3.pdf">https://arxiv.org/pdf/1201.4089v3.pdf</a>, a good introduction to the language. Basically, the interpretation of <code>forall R.C</code> means  {x | all I(R)-successors of x are in I(C)}. I believe my formalization capture this in <a href="https://github.com/arademaker/alc-lean/blob/master/src/alc.lean#L53-L54">https://github.com/arademaker/alc-lean/blob/master/src/alc.lean#L53-L54</a>. But I may be missing something in the translations of sets to propositions.</p>



<a name="225879332"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/semantics%20of%20description%20logics%3A%20binary%20representation%20of.../near/225879332" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/semantics.20of.20description.20logics.3A.20binary.20representation.20of.2E.2E.2E.html#225879332">(Feb 10 2021 at 17:50)</a>:</h4>
<p>So then the only problem was in your statement of the theorem: that example doesn't evaluate to <code>{1}</code>, it evaluates to <code>{4}^c</code></p>



<a name="225879474"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/semantics%20of%20description%20logics%3A%20binary%20representation%20of.../near/225879474" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alexandre Rademaker <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/semantics.20of.20description.20logics.3A.20binary.20representation.20of.2E.2E.2E.html#225879474">(Feb 10 2021 at 17:52)</a>:</h4>
<p>No, the only one that has ALL fillers of type Man is {1}</p>



<a name="225879580"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/semantics%20of%20description%20logics%3A%20binary%20representation%20of.../near/225879580" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/semantics.20of.20description.20logics.3A.20binary.20representation.20of.2E.2E.2E.html#225879580">(Feb 10 2021 at 17:52)</a>:</h4>
<p>That's not true though</p>



<a name="225879630"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/semantics%20of%20description%20logics%3A%20binary%20representation%20of.../near/225879630" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/semantics.20of.20description.20logics.3A.20binary.20representation.20of.2E.2E.2E.html#225879630">(Feb 10 2021 at 17:52)</a>:</h4>
<p>2 also has that property, because 2 has no children</p>



<a name="225879731"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/semantics%20of%20description%20logics%3A%20binary%20representation%20of.../near/225879731" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/semantics.20of.20description.20logics.3A.20binary.20representation.20of.2E.2E.2E.html#225879731">(Feb 10 2021 at 17:53)</a>:</h4>
<p>see also <a href="https://en.wikipedia.org/wiki/Vacuous_truth">https://en.wikipedia.org/wiki/Vacuous_truth</a></p>



<a name="225879763"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/semantics%20of%20description%20logics%3A%20binary%20representation%20of.../near/225879763" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alexandre Rademaker <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/semantics.20of.20description.20logics.3A.20binary.20representation.20of.2E.2E.2E.html#225879763">(Feb 10 2021 at 17:53)</a>:</h4>
<p>Oh.. you are right. I got it.</p>



<a name="225880004"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/semantics%20of%20description%20logics%3A%20binary%20representation%20of.../near/225880004" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/semantics.20of.20description.20logics.3A.20binary.20representation.20of.2E.2E.2E.html#225880004">(Feb 10 2021 at 17:55)</a>:</h4>
<p>You should try replacing <code>Every</code> with <code>Some</code> and prove that it evaluates to <code>{1}</code></p>



<a name="225880210"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/semantics%20of%20description%20logics%3A%20binary%20representation%20of.../near/225880210" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alexandre Rademaker <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/semantics.20of.20description.20logics.3A.20binary.20representation.20of.2E.2E.2E.html#225880210">(Feb 10 2021 at 17:56)</a>:</h4>
<p>So <code>Every hasChild Man</code> should evaluate to {1,2,3}. sorry, as you said above, the complement of {4}.</p>



<a name="225882024"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/semantics%20of%20description%20logics%3A%20binary%20representation%20of.../near/225882024" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alexandre Rademaker <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/semantics.20of.20description.20logics.3A.20binary.20representation.20of.2E.2E.2E.html#225882024">(Feb 10 2021 at 18:08)</a>:</h4>
<p>Thank you <span class="user-mention" data-user-id="110049">@Mario Carneiro</span> , that was so obvious that I am  embarrassed! </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span>
 <span class="n">interp</span> <span class="n">i</span> <span class="o">(</span><span class="n">Some</span> <span class="o">(</span><span class="n">Role.Atomic</span> <span class="n">ar.hasChild</span><span class="o">)</span> <span class="o">(</span><span class="n">Concept.Atomic</span> <span class="n">ac.man</span><span class="o">))</span> <span class="bp">=</span> <span class="o">({</span><span class="mi">1</span><span class="o">}</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
 <span class="n">ext</span> <span class="n">n</span><span class="o">,</span>
 <span class="n">apply</span> <span class="n">iff.intro</span><span class="o">,</span>
 <span class="o">{</span> <span class="n">intro</span> <span class="n">h1</span><span class="o">,</span>
   <span class="n">dsimp</span> <span class="o">[</span><span class="n">interp</span><span class="o">,</span><span class="n">r_interp</span><span class="o">,</span><span class="n">i</span><span class="o">]</span> <span class="n">at</span> <span class="n">h1</span><span class="o">,</span>
   <span class="n">rw</span> <span class="o">[</span><span class="n">ic</span><span class="o">,</span><span class="n">ir</span><span class="o">]</span> <span class="n">at</span> <span class="n">h1</span><span class="o">,</span>
   <span class="n">simp</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
   <span class="n">apply</span> <span class="o">(</span><span class="n">exists.elim</span> <span class="n">h1</span><span class="o">),</span>
   <span class="n">simp</span><span class="o">,</span> <span class="n">intros</span> <span class="n">a</span> <span class="n">h</span><span class="o">,</span>
   <span class="n">finish</span><span class="o">,</span>
 <span class="o">},</span>

 <span class="o">{</span> <span class="n">intros</span> <span class="n">h1</span><span class="o">,</span>
   <span class="n">dsimp</span> <span class="o">[</span><span class="n">interp</span><span class="o">,</span><span class="n">r_interp</span><span class="o">,</span><span class="n">i</span><span class="o">],</span>
   <span class="n">rw</span> <span class="o">[</span><span class="n">ic</span><span class="o">,</span><span class="n">ir</span><span class="o">],</span>
   <span class="n">norm_num</span> <span class="n">at</span> <span class="n">h1</span><span class="o">,</span>
   <span class="n">rw</span> <span class="n">h1</span><span class="o">,</span>
   <span class="n">apply</span> <span class="n">exists.intro</span> <span class="mi">2</span><span class="o">,</span>
   <span class="n">finish</span><span class="o">,</span>
 <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>



<a name="225882202"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/semantics%20of%20description%20logics%3A%20binary%20representation%20of.../near/225882202" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/semantics.20of.20description.20logics.3A.20binary.20representation.20of.2E.2E.2E.html#225882202">(Feb 10 2021 at 18:09)</a>:</h4>
<p>you should start the proof off with <code>simp [interp, r_interp, ir],</code> like I did, it makes the rest of the proof a lot easier</p>



<a name="225883976"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/semantics%20of%20description%20logics%3A%20binary%20representation%20of.../near/225883976" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alexandre Rademaker <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/semantics.20of.20description.20logics.3A.20binary.20representation.20of.2E.2E.2E.html#225883976">(Feb 10 2021 at 18:23)</a>:</h4>
<p>Thank you, yes, it makes sense. The finish in the first branch is doing a lot of work (i saw with <code>show_term{ finish }</code>). I am always curious about how to the steps explicit.</p>



<a name="225908498"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/semantics%20of%20description%20logics%3A%20binary%20representation%20of.../near/225908498" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alexandre Rademaker <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/semantics.20of.20description.20logics.3A.20binary.20representation.20of.2E.2E.2E.html#225908498">(Feb 10 2021 at 21:10)</a>:</h4>
<p>Hi <span class="user-mention" data-user-id="110049">@Mario Carneiro</span> , your proof above didn't work for me. I need to change the first branch to </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="o">{</span> <span class="n">rintro</span> <span class="n">h</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">h2</span> <span class="o">:=</span> <span class="n">h</span> <span class="o">(</span><span class="mi">3</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span>
    <span class="n">revert</span> <span class="n">h2</span><span class="o">,</span>
    <span class="n">finish</span><span class="o">,</span>
  <span class="o">}</span>
</code></pre></div>
<p>The second branch uses <code>rintro</code>, creating the goals with terms like <code>(1.add 0).succ</code>. I can't even reduce these terms with <code>#reduce</code>... </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="mi">2</span> <span class="n">goals</span>
<span class="n">h</span> <span class="o">:</span> <span class="mi">1</span> <span class="bp">∈</span> <span class="o">{</span><span class="mi">4</span><span class="o">}</span><span class="bp">ᶜ</span><span class="o">,</span>
<span class="n">ᾰ</span> <span class="o">:</span> <span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="o">(</span><span class="mi">1</span><span class="bp">.</span><span class="n">add</span> <span class="mi">0</span><span class="o">)</span><span class="bp">.</span><span class="n">succ</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>
<span class="bp">⊢</span> <span class="o">(</span><span class="mi">1</span><span class="bp">.</span><span class="n">add</span> <span class="mi">0</span><span class="o">)</span><span class="bp">.</span><span class="n">succ</span> <span class="bp">∈</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">}</span>

<span class="n">h</span> <span class="o">:</span> <span class="o">(</span><span class="mi">2</span><span class="bp">.</span><span class="n">add</span> <span class="o">(</span><span class="mi">1</span><span class="bp">.</span><span class="n">add</span> <span class="mi">0</span><span class="o">))</span><span class="bp">.</span><span class="n">succ</span> <span class="bp">∈</span> <span class="o">{</span><span class="mi">4</span><span class="o">}</span><span class="bp">ᶜ</span><span class="o">,</span>
<span class="n">ᾰ</span> <span class="o">:</span> <span class="o">((</span><span class="mi">2</span><span class="bp">.</span><span class="n">add</span> <span class="o">(</span><span class="mi">1</span><span class="bp">.</span><span class="n">add</span> <span class="mi">0</span><span class="o">))</span><span class="bp">.</span><span class="n">succ</span><span class="o">,</span> <span class="o">(</span><span class="mi">2</span><span class="bp">.</span><span class="n">add</span> <span class="mi">0</span><span class="o">)</span><span class="bp">.</span><span class="n">succ</span><span class="o">)</span> <span class="bp">∈</span> <span class="o">{(</span><span class="mi">4</span><span class="o">,</span> <span class="mi">3</span><span class="o">)}</span>
<span class="bp">⊢</span> <span class="o">(</span><span class="mi">2</span><span class="bp">.</span><span class="n">add</span> <span class="mi">0</span><span class="o">)</span><span class="bp">.</span><span class="n">succ</span> <span class="bp">∈</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">}</span>
</code></pre></div>



<a name="225908702"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/semantics%20of%20description%20logics%3A%20binary%20representation%20of.../near/225908702" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/semantics.20of.20description.20logics.3A.20binary.20representation.20of.2E.2E.2E.html#225908702">(Feb 10 2021 at 21:12)</a>:</h4>
<p>You used this proof exactly as written?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span>
  <span class="n">interp</span> <span class="n">i</span> <span class="o">(</span><span class="n">Every</span> <span class="o">(</span><span class="n">Role.Atomic</span> <span class="n">ar.hasChild</span><span class="o">)</span> <span class="o">(</span><span class="n">Concept.Atomic</span> <span class="n">ac.man</span><span class="o">))</span> <span class="bp">=</span> <span class="o">({</span><span class="mi">4</span><span class="o">}</span><span class="bp">ᶜ</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">ext</span> <span class="n">n</span><span class="o">,</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">interp</span><span class="o">,</span> <span class="n">r_interp</span><span class="o">,</span> <span class="n">ir</span><span class="o">],</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rintro</span> <span class="n">H</span> <span class="n">rfl</span><span class="o">,</span>
    <span class="k">have</span> <span class="o">:=</span> <span class="n">H</span> <span class="mi">3</span><span class="o">,</span> <span class="n">revert</span> <span class="n">this</span><span class="o">,</span>
    <span class="n">norm_num</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rintro</span> <span class="n">h</span> <span class="n">_</span> <span class="o">(⟨</span><span class="n">rfl</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span><span class="bp">|</span><span class="o">⟨</span><span class="n">rfl</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩),</span> <span class="o">{</span><span class="n">norm_num</span><span class="o">},</span>
    <span class="n">cases</span> <span class="n">h</span> <span class="n">rfl</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>



<a name="225908734"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/semantics%20of%20description%20logics%3A%20binary%20representation%20of.../near/225908734" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/semantics.20of.20description.20logics.3A.20binary.20representation.20of.2E.2E.2E.html#225908734">(Feb 10 2021 at 21:12)</a>:</h4>
<p>The goals shouldn't look anything like that</p>



<a name="225908871"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/semantics%20of%20description%20logics%3A%20binary%20representation%20of.../near/225908871" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/semantics.20of.20description.20logics.3A.20binary.20representation.20of.2E.2E.2E.html#225908871">(Feb 10 2021 at 21:13)</a>:</h4>
<p>What does your version look like</p>



<a name="225909354"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/semantics%20of%20description%20logics%3A%20binary%20representation%20of.../near/225909354" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alexandre Rademaker <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/semantics.20of.20description.20logics.3A.20binary.20representation.20of.2E.2E.2E.html#225909354">(Feb 10 2021 at 21:17)</a>:</h4>
<p>I am getting the error in <code>H 3</code> with 3 in red underline.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">failed</span> <span class="n">to</span> <span class="n">synthesize</span> <span class="n">type</span> <span class="kd">class</span> <span class="kd">instance</span> <span class="n">for</span>
<span class="n">H</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">i.δ</span><span class="o">),</span> <span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">i.atom_R</span> <span class="n">ar.hasChild</span> <span class="bp">→</span> <span class="n">b</span> <span class="bp">∈</span> <span class="n">i.atom_C</span> <span class="n">ac.man</span>
<span class="bp">⊢</span> <span class="n">has_one</span> <span class="n">i.δ</span>
<span class="n">state</span><span class="o">:</span>
<span class="n">H</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">i.δ</span><span class="o">),</span> <span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">i.atom_R</span> <span class="n">ar.hasChild</span> <span class="bp">→</span> <span class="n">b</span> <span class="bp">∈</span> <span class="n">i.atom_C</span> <span class="n">ac.man</span>
<span class="bp">⊢</span> <span class="n">false</span>
</code></pre></div>



<a name="225909636"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/semantics%20of%20description%20logics%3A%20binary%20representation%20of.../near/225909636" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/semantics.20of.20description.20logics.3A.20binary.20representation.20of.2E.2E.2E.html#225909636">(Feb 10 2021 at 21:19)</a>:</h4>
<p>Ah, it's probably because you removed the <code>@[reducible]</code> on <code>i</code></p>



<a name="225909855"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/semantics%20of%20description%20logics%3A%20binary%20representation%20of.../near/225909855" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/semantics.20of.20description.20logics.3A.20binary.20representation.20of.2E.2E.2E.html#225909855">(Feb 10 2021 at 21:21)</a>:</h4>
<p>Here's a version that works even if <code>i</code> is not reducible</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span>
  <span class="n">interp</span> <span class="n">i</span> <span class="o">(</span><span class="n">Every</span> <span class="o">(</span><span class="n">Role.Atomic</span> <span class="n">ar.hasChild</span><span class="o">)</span> <span class="o">(</span><span class="n">Concept.Atomic</span> <span class="n">ac.man</span><span class="o">))</span> <span class="bp">=</span> <span class="o">({</span><span class="mi">4</span><span class="o">}</span><span class="bp">ᶜ</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">dsimp</span> <span class="o">[</span><span class="n">i</span><span class="o">,</span> <span class="n">interp</span><span class="o">],</span>
  <span class="n">ext</span> <span class="n">n</span><span class="o">,</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">r_interp</span><span class="o">,</span> <span class="n">ir</span><span class="o">],</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rintro</span> <span class="n">H</span> <span class="n">rfl</span><span class="o">,</span>
    <span class="k">have</span> <span class="o">:=</span> <span class="n">H</span> <span class="mi">3</span><span class="o">,</span> <span class="n">revert</span> <span class="n">this</span><span class="o">,</span>
    <span class="n">norm_num</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rintro</span> <span class="n">h</span> <span class="n">_</span> <span class="o">(⟨</span><span class="n">rfl</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span><span class="bp">|</span><span class="o">⟨</span><span class="n">rfl</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩),</span> <span class="o">{</span><span class="n">norm_num</span><span class="o">},</span>
    <span class="n">cases</span> <span class="n">h</span> <span class="n">rfl</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>



<a name="225914095"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/semantics%20of%20description%20logics%3A%20binary%20representation%20of.../near/225914095" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alexandre Rademaker <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/semantics.20of.20description.20logics.3A.20binary.20representation.20of.2E.2E.2E.html#225914095">(Feb 10 2021 at 21:50)</a>:</h4>
<p>thank you. yes I have removed the <code>@[reducible]</code>! It is all clear now.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
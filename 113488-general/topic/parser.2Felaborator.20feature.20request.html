---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/parser.2Felaborator.20feature.20request.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/parser.2Felaborator.20feature.20request.html">parser/elaborator feature request</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="202937734"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/parser/elaborator%20feature%20request/near/202937734" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/parser.2Felaborator.20feature.20request.html#202937734">(Jul 05 2020 at 20:51)</a>:</h4>
<p>Could we expand the scope of <code>@</code> (make implicit arguments explicit) to expressions as well?</p>



<a name="202937783"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/parser/elaborator%20feature%20request/near/202937783" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/parser.2Felaborator.20feature.20request.html#202937783">(Jul 05 2020 at 20:52)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">constant</span> <span class="n">foo</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="bp">ℕ</span>

<span class="bp">#</span><span class="kn">check</span> <span class="bp">@</span><span class="n">foo</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">2</span>   <span class="c1">-- works</span>
<span class="bp">#</span><span class="kn">check</span> <span class="bp">@</span><span class="o">(</span><span class="n">foo</span> <span class="mi">0</span><span class="o">)</span> <span class="mi">1</span> <span class="mi">2</span> <span class="c1">-- fails</span>
</code></pre></div>



<a name="202937932"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/parser/elaborator%20feature%20request/near/202937932" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/parser.2Felaborator.20feature.20request.html#202937932">(Jul 05 2020 at 20:56)</a>:</h4>
<p>That's probably something you can write your own function to do</p>



<a name="202938001"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/parser/elaborator%20feature%20request/near/202938001" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/parser.2Felaborator.20feature.20request.html#202938001">(Jul 05 2020 at 20:58)</a>:</h4>
<p>as in C++ code?</p>



<a name="202938016"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/parser/elaborator%20feature%20request/near/202938016" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/parser.2Felaborator.20feature.20request.html#202938016">(Jul 05 2020 at 20:59)</a>:</h4>
<p>No, I'm thinking of a Lean function where you write a tactic to build it's type</p>



<a name="202938090"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/parser/elaborator%20feature%20request/near/202938090" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/parser.2Felaborator.20feature.20request.html#202938090">(Jul 05 2020 at 21:01)</a>:</h4>
<p>It's less obvious to make than I thought actually</p>



<a name="202938143"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/parser/elaborator%20feature%20request/near/202938143" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/parser.2Felaborator.20feature.20request.html#202938143">(Jul 05 2020 at 21:02)</a>:</h4>
<p>Maybe a macro (like <code>format!</code>) would be a good approach to make it work</p>



<a name="202938560"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/parser/elaborator%20feature%20request/near/202938560" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/parser.2Felaborator.20feature.20request.html#202938560">(Jul 05 2020 at 21:14)</a>:</h4>
<p>Try this:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">open</span> <span class="n">tactic</span>

<span class="n">reserve</span> <span class="kn">prefix</span> <span class="bp">`</span><span class="n">elab</span><span class="bp">!</span> <span class="bp">`</span><span class="o">:</span><span class="mi">100</span>

<span class="n">setup_tactic_parser</span>
<span class="kn">open</span> <span class="n">lean</span>

<span class="n">meta</span> <span class="n">def</span> <span class="n">explicit_binder</span> <span class="o">:</span> <span class="n">expr</span> <span class="bp">→</span> <span class="n">expr</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">expr</span><span class="bp">.</span><span class="n">pi</span> <span class="n">n</span> <span class="bp">_</span> <span class="n">d</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span>
  <span class="n">expr</span><span class="bp">.</span><span class="n">pi</span> <span class="n">n</span> <span class="n">binder_info</span><span class="bp">.</span><span class="n">default</span> <span class="n">d</span> <span class="err">$</span> <span class="n">explicit_binder</span> <span class="n">b</span>
<span class="bp">|</span> <span class="n">e</span> <span class="o">:=</span> <span class="n">e</span>

<span class="bp">@</span><span class="o">[</span><span class="n">user_notation</span><span class="o">]</span>
<span class="n">meta</span> <span class="n">def</span> <span class="n">elab_macro</span> <span class="o">(</span><span class="bp">_</span> <span class="o">:</span> <span class="n">parse</span> <span class="err">$</span> <span class="n">tk</span> <span class="s2">&quot;elab!&quot;</span><span class="o">)</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">parse</span> <span class="n">texpr</span><span class="o">)</span> <span class="o">:</span> <span class="n">lean</span><span class="bp">.</span><span class="n">parser</span> <span class="n">pexpr</span> <span class="o">:=</span>
<span class="n">do</span> <span class="n">e</span> <span class="err">←</span> <span class="n">to_expr</span> <span class="n">e</span><span class="bp">.</span><span class="n">mk_explicit</span><span class="o">,</span>
   <span class="n">t</span> <span class="err">←</span> <span class="n">infer_type</span> <span class="n">e</span><span class="o">,</span>
   <span class="k">let</span> <span class="n">t</span> <span class="o">:=</span> <span class="n">explicit_binder</span> <span class="n">t</span><span class="o">,</span>
   <span class="n">return</span> <span class="err">$</span> <span class="bp">``</span><span class="o">(</span><span class="bp">@</span><span class="n">id</span> <span class="err">%%</span><span class="n">t</span> <span class="err">%%</span><span class="n">e</span><span class="o">)</span>

<span class="bp">#</span><span class="kn">check</span> <span class="o">(</span><span class="n">elab</span><span class="bp">!</span> <span class="n">function</span><span class="bp">.</span><span class="n">comp</span><span class="o">)</span> <span class="bp">ℤ</span>
</code></pre></div>



<a name="202938788"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/parser/elaborator%20feature%20request/near/202938788" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/parser.2Felaborator.20feature.20request.html#202938788">(Jul 05 2020 at 21:21)</a>:</h4>
<p>Still not great</p>



<a name="202938903"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/parser/elaborator%20feature%20request/near/202938903" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/parser.2Felaborator.20feature.20request.html#202938903">(Jul 05 2020 at 21:24)</a>:</h4>
<p>In any case, you might like what Leo is putting in the Lean 4 elaborator. He's adding named arguments. You should be able to write <code>foo 0 (n := 1) (p := 2)</code></p>



<a name="202939754"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/parser/elaborator%20feature%20request/near/202939754" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/parser.2Felaborator.20feature.20request.html#202939754">(Jul 05 2020 at 21:51)</a>:</h4>
<p>I also think that <code>@</code> should work on expressions. There isn't really a reason not to, and it's one of the reasons why the pretty printer doesn't round trip</p>



<a name="202939794"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/parser/elaborator%20feature%20request/near/202939794" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/parser.2Felaborator.20feature.20request.html#202939794">(Jul 05 2020 at 21:52)</a>:</h4>
<p>Why is that?</p>



<a name="202939802"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/parser/elaborator%20feature%20request/near/202939802" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/parser.2Felaborator.20feature.20request.html#202939802">(Jul 05 2020 at 21:52)</a>:</h4>
<p>You can't write <code>@(\lam {x : nat}, x) 1</code></p>



<a name="202939819"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/parser/elaborator%20feature%20request/near/202939819" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/parser.2Felaborator.20feature.20request.html#202939819">(Jul 05 2020 at 21:53)</a>:</h4>
<p>it means that there are some terms that can't be printed in a way where they will be parsed correctly</p>



<a name="202939884"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/parser/elaborator%20feature%20request/near/202939884" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/parser.2Felaborator.20feature.20request.html#202939884">(Jul 05 2020 at 21:55)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">foo</span> <span class="o">:=</span> <span class="k">by</span> <span class="k">have</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">},</span> <span class="n">x</span><span class="o">)</span><span class="bp">;</span> <span class="n">exact</span> <span class="bp">@</span><span class="n">this</span> <span class="mi">1</span>

<span class="kn">set_option</span> <span class="n">pp</span><span class="bp">.</span><span class="n">all</span> <span class="n">true</span>
<span class="bp">#</span><span class="kn">print</span> <span class="n">foo</span>

<span class="kn">example</span> <span class="o">:=</span>
<span class="bp">@</span><span class="o">(</span><span class="bp">λ</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">nat</span><span class="o">},</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="bp">@</span><span class="n">has_one</span><span class="bp">.</span><span class="n">one</span><span class="bp">.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat</span><span class="bp">.</span><span class="n">has_one</span><span class="o">)</span>
</code></pre></div>



<a name="202939955"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/parser/elaborator%20feature%20request/near/202939955" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/parser.2Felaborator.20feature.20request.html#202939955">(Jul 05 2020 at 21:57)</a>:</h4>
<p>That said, I don't think that kenny's example should work. If you write <code>(foo 0)</code> then that should mean <code>foo 0 _</code> so <code>@(foo 0) 1 2</code> means <code>@foo 0 _ 1 2</code>. The correct version would be <code>@(@foo 0) 1 2</code></p>



<a name="202940098"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/parser/elaborator%20feature%20request/near/202940098" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/parser.2Felaborator.20feature.20request.html#202940098">(Jul 05 2020 at 22:00)</a>:</h4>
<p>It also would make sense for <code>#check λ {x : ℕ}, x</code> to have type <code>ℕ</code></p>



<a name="202940100"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/parser/elaborator%20feature%20request/near/202940100" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/parser.2Felaborator.20feature.20request.html#202940100">(Jul 05 2020 at 22:00)</a>:</h4>
<p>Right, that's the issue that I've been having with it. But if <code>foo</code> takes another implicit argument before <code>0</code> that's where <code>@</code> makes a functional applicative too verbose</p>



<a name="202940120"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/parser/elaborator%20feature%20request/near/202940120" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/parser.2Felaborator.20feature.20request.html#202940120">(Jul 05 2020 at 22:01)</a>:</h4>
<p>I'm sorry, I don't understand the objection</p>



<a name="202940192"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/parser/elaborator%20feature%20request/near/202940192" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/parser.2Felaborator.20feature.20request.html#202940192">(Jul 05 2020 at 22:03)</a>:</h4>
<p>Kenny's example get more interesting if you have this type:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">constant</span> <span class="n">foo</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">q</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="bp">ℕ</span>
</code></pre></div>



<a name="202940245"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/parser/elaborator%20feature%20request/near/202940245" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/parser.2Felaborator.20feature.20request.html#202940245">(Jul 05 2020 at 22:05)</a>:</h4>
<p>Then, your solution <code>@(@foo 0) 1 2</code> would have to be <code>@(@foo 7 0) 1 2</code>. I think avoiding that would be one reasonable argument for applying <code>@</code> on a partial application</p>



<a name="202940246"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/parser/elaborator%20feature%20request/near/202940246" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/parser.2Felaborator.20feature.20request.html#202940246">(Jul 05 2020 at 22:05)</a>:</h4>
<p>Did I miss anything?</p>
<div class="codehilite"><pre><span></span><code><span class="kn">constant</span> <span class="n">foo</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="bp">ℕ</span>
<span class="bp">#</span><span class="kn">check</span> <span class="o">(</span><span class="bp">@</span><span class="n">foo</span> <span class="n">a</span><span class="o">)</span> <span class="c1">-- @foo a</span>
<span class="bp">#</span><span class="kn">check</span> <span class="o">(</span><span class="n">foo</span> <span class="n">m</span><span class="o">)</span> <span class="c1">-- @foo _ m _</span>
<span class="bp">#</span><span class="kn">check</span> <span class="bp">@</span><span class="o">(</span><span class="n">foo</span> <span class="n">m</span><span class="o">)</span> <span class="c1">-- @foo _ m</span>
<span class="bp">#</span><span class="kn">check</span> <span class="bp">@</span><span class="o">(</span><span class="bp">@</span><span class="n">foo</span> <span class="n">a</span> <span class="n">m</span><span class="o">)</span> <span class="c1">-- @foo a m</span>
<span class="bp">#</span><span class="kn">check</span> <span class="bp">@</span><span class="o">(</span><span class="n">foo</span> <span class="bp">_</span><span class="o">)</span> <span class="c1">-- @foo _ _</span>
<span class="bp">#</span><span class="kn">check</span> <span class="o">(</span><span class="bp">@</span><span class="n">foo</span> <span class="n">a</span> <span class="n">m</span><span class="o">)</span> <span class="n">p</span> <span class="c1">-- @foo a m _ p</span>
</code></pre></div>



<a name="202940297"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/parser/elaborator%20feature%20request/near/202940297" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/parser.2Felaborator.20feature.20request.html#202940297">(Jul 05 2020 at 22:06)</a>:</h4>
<p>I don't get your question. Are you asking if your enumeration of desired behavior is exhaustive?</p>



<a name="202940308"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/parser/elaborator%20feature%20request/near/202940308" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/parser.2Felaborator.20feature.20request.html#202940308">(Jul 05 2020 at 22:07)</a>:</h4>
<p>I'm proposing a particular meaning for <code>@</code> on an expression and giving examples. Is there a problem case somewhere that I haven't demonstrated</p>



<a name="202941371"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/parser/elaborator%20feature%20request/near/202941371" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/parser.2Felaborator.20feature.20request.html#202941371">(Jul 05 2020 at 22:40)</a>:</h4>
<p>FYI: In Lean 2 you were able to apply <code>@</code> to an expression, and it worked in exactly the way you would expect. I don't know what problem was solved by disallowing it in Lean 3.</p>



<a name="202941467"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/parser/elaborator%20feature%20request/near/202941467" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/parser.2Felaborator.20feature.20request.html#202941467">(Jul 05 2020 at 22:44)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> What I understood of your suggestion was this here:</p>
<div class="codehilite"><pre><span></span><code><span class="bp">#</span><span class="kn">check</span> <span class="bp">@</span><span class="o">(</span><span class="n">foo</span> <span class="n">m</span><span class="o">)</span> <span class="c1">-- @foo _ m _</span>
</code></pre></div>


<p>Notice that it has one underscore than the list you showed. That is something I'm on the fence about</p>



<a name="202941575"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/parser/elaborator%20feature%20request/near/202941575" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/parser.2Felaborator.20feature.20request.html#202941575">(Jul 05 2020 at 22:47)</a>:</h4>
<p>Yeah I confused myself about that too (and <code>#check (λ {x : ℕ}, x) : ℕ</code> is another example of the problem). If we view it strictly compositionally, then by the time you see the <code>@</code> the expression has already had implicits inserted, which is too late</p>



<a name="202941615"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/parser/elaborator%20feature%20request/near/202941615" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/parser.2Felaborator.20feature.20request.html#202941615">(Jul 05 2020 at 22:48)</a>:</h4>
<p>I think one desideratum is that <code>@</code> on expressions should have the same effect as <code>@foo</code> when the expression is the local constant<code>foo</code></p>



<a name="202941674"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/parser/elaborator%20feature%20request/near/202941674" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/parser.2Felaborator.20feature.20request.html#202941674">(Jul 05 2020 at 22:51)</a>:</h4>
<p>but this means that <code>@(foo m)</code> yields <code>@foo _ m</code> even though <code>(foo m)</code> is <code>@foo _ m _</code></p>



<a name="202941721"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/parser/elaborator%20feature%20request/near/202941721" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/parser.2Felaborator.20feature.20request.html#202941721">(Jul 05 2020 at 22:52)</a>:</h4>
<p>If <code>@(foo m)</code> means <code>@foo _ m _</code> then this negates the point of <code>@</code> on expressions</p>



<a name="202941781"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/parser/elaborator%20feature%20request/near/202941781" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/parser.2Felaborator.20feature.20request.html#202941781">(Jul 05 2020 at 22:54)</a>:</h4>
<p>I agree. That's how to make it the most useful. Does that make it a bit weird?</p>



<a name="202941802"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/parser/elaborator%20feature%20request/near/202941802" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/parser.2Felaborator.20feature.20request.html#202941802">(Jul 05 2020 at 22:55)</a>:</h4>
<p>I think it means that <code>@</code> modifies the context of the expression inside the parens to tell it not to insert final implicits</p>



<a name="202942199"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/parser/elaborator%20feature%20request/near/202942199" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/parser.2Felaborator.20feature.20request.html#202942199">(Jul 05 2020 at 23:06)</a>:</h4>
<p>Put another way, elaboration works one "application group" at a time, with behavior modified by the <code>@</code> at the head constant, as well as potentially an <code>@</code> around the whole expression. Here's an enumeration of cases:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">constant</span> <span class="n">foo</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">{</span><span class="n">c</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">},</span> <span class="n">C</span> <span class="mi">0</span>
<span class="kn">variables</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">{</span><span class="n">c</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span>

<span class="bp">#</span><span class="kn">check</span> <span class="bp">@</span><span class="n">foo</span> <span class="c1">-- @foo</span>
<span class="bp">#</span><span class="kn">check</span> <span class="bp">@</span><span class="n">foo</span> <span class="n">a</span> <span class="c1">-- @foo a</span>
<span class="bp">#</span><span class="kn">check</span> <span class="bp">@</span><span class="n">foo</span> <span class="n">a</span> <span class="n">C</span> <span class="c1">-- @foo a C</span>
<span class="bp">#</span><span class="kn">check</span> <span class="bp">@</span><span class="n">foo</span> <span class="n">a</span> <span class="n">C</span> <span class="n">b</span> <span class="c1">-- @foo a C b</span>
<span class="bp">#</span><span class="kn">check</span> <span class="bp">@</span><span class="n">foo</span> <span class="n">a</span> <span class="n">C</span> <span class="n">b</span> <span class="n">c</span> <span class="c1">-- @foo a C b c</span>
<span class="bp">#</span><span class="kn">check</span> <span class="bp">@@</span><span class="n">foo</span> <span class="c1">-- @foo _</span>
<span class="bp">#</span><span class="kn">check</span> <span class="bp">@@</span><span class="n">foo</span> <span class="n">C</span> <span class="c1">-- @foo _ C</span>
<span class="bp">#</span><span class="kn">check</span> <span class="bp">@@</span><span class="n">foo</span> <span class="n">C</span> <span class="n">b</span> <span class="c1">-- @foo _ C b _</span>
<span class="bp">#</span><span class="kn">check</span> <span class="n">foo</span> <span class="c1">-- @foo _ _</span>
<span class="bp">#</span><span class="kn">check</span> <span class="n">foo</span> <span class="n">b</span> <span class="c1">-- @foo _ _ b _</span>

<span class="bp">#</span><span class="kn">check</span> <span class="bp">@</span><span class="o">(</span><span class="bp">@</span><span class="n">foo</span><span class="o">)</span> <span class="c1">-- @foo</span>
<span class="bp">#</span><span class="kn">check</span> <span class="bp">@</span><span class="o">(</span><span class="bp">@</span><span class="n">foo</span> <span class="n">a</span><span class="o">)</span> <span class="c1">-- @foo a</span>
<span class="bp">#</span><span class="kn">check</span> <span class="bp">@</span><span class="o">(</span><span class="bp">@</span><span class="n">foo</span> <span class="n">a</span> <span class="n">C</span><span class="o">)</span> <span class="c1">-- @foo a C</span>
<span class="bp">#</span><span class="kn">check</span> <span class="bp">@</span><span class="o">(</span><span class="bp">@</span><span class="n">foo</span> <span class="n">a</span> <span class="n">C</span> <span class="n">b</span><span class="o">)</span> <span class="c1">-- @foo a C b</span>
<span class="bp">#</span><span class="kn">check</span> <span class="bp">@</span><span class="o">(</span><span class="bp">@</span><span class="n">foo</span> <span class="n">a</span> <span class="n">C</span> <span class="n">b</span> <span class="n">c</span><span class="o">)</span> <span class="c1">-- @foo a C b c</span>
<span class="bp">#</span><span class="kn">check</span> <span class="bp">@</span><span class="o">(</span><span class="bp">@@</span><span class="n">foo</span><span class="o">)</span> <span class="c1">-- @foo</span>
<span class="bp">#</span><span class="kn">check</span> <span class="bp">@</span><span class="o">(</span><span class="bp">@@</span><span class="n">foo</span> <span class="n">C</span><span class="o">)</span> <span class="c1">-- @foo _ C</span>
<span class="bp">#</span><span class="kn">check</span> <span class="bp">@</span><span class="o">(</span><span class="bp">@@</span><span class="n">foo</span> <span class="n">C</span> <span class="n">b</span><span class="o">)</span> <span class="c1">-- @foo _ C b</span>
<span class="bp">#</span><span class="kn">check</span> <span class="bp">@</span><span class="o">(</span><span class="n">foo</span><span class="o">)</span> <span class="c1">-- @foo</span>
<span class="bp">#</span><span class="kn">check</span> <span class="bp">@</span><span class="o">(</span><span class="n">foo</span> <span class="n">b</span><span class="o">)</span> <span class="c1">-- @foo _ _ b</span>
</code></pre></div>



<a name="202942203"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/parser/elaborator%20feature%20request/near/202942203" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/parser.2Felaborator.20feature.20request.html#202942203">(Jul 05 2020 at 23:07)</a>:</h4>
<p>The effect of <code>@@(...)</code> is the same as <code>@(...)</code>, namely to suppress all insertions of trailing implicit args</p>



<a name="202942262"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/parser/elaborator%20feature%20request/near/202942262" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/parser.2Felaborator.20feature.20request.html#202942262">(Jul 05 2020 at 23:09)</a>:</h4>
<p>This ensures that <code>@(foo)</code> always means the same as <code>@foo</code></p>



<a name="202942324"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/parser/elaborator%20feature%20request/near/202942324" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/parser.2Felaborator.20feature.20request.html#202942324">(Jul 05 2020 at 23:11)</a>:</h4>
<p>This means that <code>\lam {x}, ...</code> can't be written as is because it will have implicits immediately inserted, unless you protect it with <code>@</code>:</p>
<div class="codehilite"><pre><span></span><code><span class="bp">#</span><span class="kn">check</span> <span class="bp">λ</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">},</span> <span class="n">x</span> <span class="c1">-- @(λ {x : ℕ}, x) _</span>
<span class="bp">#</span><span class="kn">check</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">},</span> <span class="n">x</span><span class="o">)</span> <span class="c1">-- @(λ {x : ℕ}, x) _</span>
<span class="bp">#</span><span class="kn">check</span> <span class="bp">@</span><span class="o">(</span><span class="bp">λ</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">},</span> <span class="n">x</span><span class="o">)</span> <span class="c1">-- @(λ {x : ℕ}, x)</span>
<span class="bp">#</span><span class="kn">check</span> <span class="bp">@</span><span class="o">(</span><span class="bp">λ</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">},</span> <span class="n">x</span><span class="o">)</span> <span class="mi">0</span> <span class="c1">-- @(λ {x : ℕ}, x) 0</span>
</code></pre></div>



<a name="202942380"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/parser/elaborator%20feature%20request/near/202942380" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/parser.2Felaborator.20feature.20request.html#202942380">(Jul 05 2020 at 23:14)</a>:</h4>
<p><span class="user-mention" data-user-id="111080">@Floris van Doorn</span> After going through these cases, it's not clear to me what "exactly what you would expect" means anymore. Could you elaborate on lean 2 <code>@</code>?</p>



<a name="202943694"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/parser/elaborator%20feature%20request/near/202943694" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/parser.2Felaborator.20feature.20request.html#202943694">(Jul 05 2020 at 23:57)</a>:</h4>
<p>I typically used it when (partially) applying a constant to arguments, if you want to leave the first implicit arguments implicit, but make all later arguments explicit. For example, this worked:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">constant</span> <span class="n">foo</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">{</span><span class="n">c</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">{</span><span class="n">e</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">},</span> <span class="bp">ℕ</span>
<span class="kn">variables</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">{</span><span class="n">c</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">{</span><span class="n">e</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span>

<span class="bp">#</span><span class="kn">check</span> <span class="o">(</span><span class="bp">@</span><span class="o">(</span><span class="n">foo</span> <span class="n">b</span><span class="o">)</span> <span class="n">c</span> <span class="n">d</span> <span class="n">e</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span>
</code></pre></div>


<p>I think the binder type for lambdas was usually/always ignored when elaborating: it would not immediately apply the function to an argument.</p>



<a name="202944201"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/parser/elaborator%20feature%20request/near/202944201" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/parser.2Felaborator.20feature.20request.html#202944201">(Jul 06 2020 at 00:13)</a>:</h4>
<p>I wonder if we can bring back the <code>!foo</code> annotation too while we're at it</p>



<a name="202944789"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/parser/elaborator%20feature%20request/near/202944789" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/parser.2Felaborator.20feature.20request.html#202944789">(Jul 06 2020 at 00:31)</a>:</h4>
<p>What did it do?</p>



<a name="202944794"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/parser/elaborator%20feature%20request/near/202944794" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/parser.2Felaborator.20feature.20request.html#202944794">(Jul 06 2020 at 00:31)</a>:</h4>
<p>it makes all arguments implicit</p>



<a name="202944797"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/parser/elaborator%20feature%20request/near/202944797" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/parser.2Felaborator.20feature.20request.html#202944797">(Jul 06 2020 at 00:31)</a>:</h4>
<p><code>!foo = foo _ _ _ _</code></p>



<a name="202944843"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/parser/elaborator%20feature%20request/near/202944843" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/parser.2Felaborator.20feature.20request.html#202944843">(Jul 06 2020 at 00:32)</a>:</h4>
<p>Is that useful? Maybe you'd rather have something like Coq's <code>Set Implicit Arguments</code> command.</p>



<a name="202944849"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/parser/elaborator%20feature%20request/near/202944849" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/parser.2Felaborator.20feature.20request.html#202944849">(Jul 06 2020 at 00:32)</a>:</h4>
<p>It's local to the particular application</p>



<a name="202944854"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/parser/elaborator%20feature%20request/near/202944854" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/parser.2Felaborator.20feature.20request.html#202944854">(Jul 06 2020 at 00:33)</a>:</h4>
<p>It's basically the opposite of <code>@foo</code></p>



<a name="202945424"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/parser/elaborator%20feature%20request/near/202945424" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/parser.2Felaborator.20feature.20request.html#202945424">(Jul 06 2020 at 00:51)</a>:</h4>
<p>In the Lean 2 HoTT library the <code>!</code> was used all over the place.  We made many arguments explicit, because you could easily write <code>!foo</code> if you didn't want to write them explicitly.</p>



<a name="202946471"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/parser/elaborator%20feature%20request/near/202946471" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/parser.2Felaborator.20feature.20request.html#202946471">(Jul 06 2020 at 01:24)</a>:</h4>
<p>If you have <code>foo : \Pi a, a -&gt; b</code>, is there a way to omit <code>a</code> but not the parameter of type <code>a</code>?</p>



<a name="202946676"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/parser/elaborator%20feature%20request/near/202946676" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/parser.2Felaborator.20feature.20request.html#202946676">(Jul 06 2020 at 01:31)</a>:</h4>
<p>Not using <code>!</code> and <code>@</code></p>



<a name="202946716"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/parser/elaborator%20feature%20request/near/202946716" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/parser.2Felaborator.20feature.20request.html#202946716">(Jul 06 2020 at 01:32)</a>:</h4>
<p>lean 2 also had regular implicit arguments, that's what you would use in that example</p>



<a name="202946740"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/parser/elaborator%20feature%20request/near/202946740" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/parser.2Felaborator.20feature.20request.html#202946740">(Jul 06 2020 at 01:33)</a>:</h4>
<p>Ok, I think I see why that's useful. If you have <code>!foo = x</code>, <code>x</code> can dictate the implicit arguments of <code>foo</code>, is that right?</p>



<a name="202946782"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/parser/elaborator%20feature%20request/near/202946782" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/parser.2Felaborator.20feature.20request.html#202946782">(Jul 06 2020 at 01:34)</a>:</h4>
<p>yes</p>



<a name="202946786"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/parser/elaborator%20feature%20request/near/202946786" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/parser.2Felaborator.20feature.20request.html#202946786">(Jul 06 2020 at 01:34)</a>:</h4>
<p>I see</p>



<a name="202946790"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/parser/elaborator%20feature%20request/near/202946790" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/parser.2Felaborator.20feature.20request.html#202946790">(Jul 06 2020 at 01:34)</a>:</h4>
<p>also in theorem applications it is very common for our usual implicitness method to be too conservative</p>



<a name="202946859"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/parser/elaborator%20feature%20request/near/202946859" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/parser.2Felaborator.20feature.20request.html#202946859">(Jul 06 2020 at 01:37)</a>:</h4>
<p>You mean with <code>apply</code> or when proving a proof term?</p>



<a name="202947510"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/parser/elaborator%20feature%20request/near/202947510" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/parser.2Felaborator.20feature.20request.html#202947510">(Jul 06 2020 at 01:55)</a>:</h4>
<p>in proof terms</p>



<a name="202947568"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/parser/elaborator%20feature%20request/near/202947568" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/parser.2Felaborator.20feature.20request.html#202947568">(Jul 06 2020 at 01:56)</a>:</h4>
<p>Our usual convention says anything that can be inferred from the hypotheses (not the goal) is implicit, but in theorem applications, working backwards, the goal is usually known</p>



<a name="202947645"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/parser/elaborator%20feature%20request/near/202947645" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/parser.2Felaborator.20feature.20request.html#202947645">(Jul 06 2020 at 01:59)</a>:</h4>
<p>That's true</p>



<a name="202947648"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/parser/elaborator%20feature%20request/near/202947648" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/parser.2Felaborator.20feature.20request.html#202947648">(Jul 06 2020 at 01:59)</a>:</h4>
<p>That might even make proof terms more robust</p>



<a name="202947720"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/parser/elaborator%20feature%20request/near/202947720" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/parser.2Felaborator.20feature.20request.html#202947720">(Jul 06 2020 at 02:00)</a>:</h4>
<p>I usually write <code>foo _ _</code> for arguments I want inferred, even if I know what should go in the <code>_</code></p>



<a name="202947731"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/parser/elaborator%20feature%20request/near/202947731" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/parser.2Felaborator.20feature.20request.html#202947731">(Jul 06 2020 at 02:01)</a>:</h4>
<p>That's flexible enough. It still breaks if the number of arguments or implicit arguments changes</p>



<a name="202947743"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/parser/elaborator%20feature%20request/near/202947743" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/parser.2Felaborator.20feature.20request.html#202947743">(Jul 06 2020 at 02:01)</a>:</h4>
<p>is that actually reliable though? I would be pretty surprised if the number of arguments changes but the term still unifies</p>



<a name="202947785"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/parser/elaborator%20feature%20request/near/202947785" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/parser.2Felaborator.20feature.20request.html#202947785">(Jul 06 2020 at 02:02)</a>:</h4>
<p>unless it was a duplicate / unused argument or something</p>



<a name="202947955"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/parser/elaborator%20feature%20request/near/202947955" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/parser.2Felaborator.20feature.20request.html#202947955">(Jul 06 2020 at 02:06)</a>:</h4>
<p>I think the most likely situation that this would help with is if explicit arguments become implicit or vice versa</p>



<a name="206596452"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/parser/elaborator%20feature%20request/near/206596452" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/parser.2Felaborator.20feature.20request.html#206596452">(Aug 11 2020 at 16:25)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">constant</span> <span class="n">foo</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">⦃</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">⦄</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="bp">ℕ</span>
<span class="bp">#</span><span class="kn">check</span> <span class="bp">@</span><span class="n">id</span> <span class="bp">_</span> <span class="o">(</span><span class="n">foo</span> <span class="mi">0</span><span class="o">)</span> <span class="mi">1</span> <span class="mi">2</span>
</code></pre></div>



<a name="206596475"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/parser/elaborator%20feature%20request/near/206596475" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/parser.2Felaborator.20feature.20request.html#206596475">(Aug 11 2020 at 16:25)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> look I made it work using <code>{{}}</code> and <code>id</code></p>



<a name="206596637"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/parser/elaborator%20feature%20request/near/206596637" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/parser.2Felaborator.20feature.20request.html#206596637">(Aug 11 2020 at 16:27)</a>:</h4>
<p>that is unexpected</p>



<a name="206597120"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/parser/elaborator%20feature%20request/near/206597120" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/parser.2Felaborator.20feature.20request.html#206597120">(Aug 11 2020 at 16:31)</a>:</h4>
<p>that's what you get by learning Lean using machine learning (i.e. having me just explore things)</p>



<a name="206597141"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/parser/elaborator%20feature%20request/near/206597141" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/parser.2Felaborator.20feature.20request.html#206597141">(Aug 11 2020 at 16:31)</a>:</h4>
<p>you get unexpected results</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/Defining.20circuits.20.2B.20proving.20circuit.20generation.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Defining.20circuits.20.2B.20proving.20circuit.20generation.html">Defining circuits + proving circuit generation</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="305771186"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Defining%20circuits%20%2B%20proving%20circuit%20generation/near/305771186" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Defining.20circuits.20.2B.20proving.20circuit.20generation.html#305771186">(Oct 24 2022 at 08:37)</a>:</h4>
<p>I was just reading the proof that all classical circuits/Boolean functions can be generated by AND and XOR gates along with FANOUT and CROSSOVER operations and the like - and I was wondering how you would prove this in Lean. I was thinking maybe you would want to define some suitable inductive type for circuits, and then show that you have some map from that to Boolean functions and then show that the map is surjective.</p>
<p>But I'm not sure how such a type should be properly defined. Does anyone have any thoughts? Surely something like this has been done before?</p>



<a name="305772233"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Defining%20circuits%20%2B%20proving%20circuit%20generation/near/305772233" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Defining.20circuits.20.2B.20proving.20circuit.20generation.html#305772233">(Oct 24 2022 at 08:45)</a>:</h4>
<p>I would guess something like</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">gate</span> <span class="o">(</span><span class="n">σ</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">xor</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">gate</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">and</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">gate</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">input</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">σ</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">gate.eval</span> <span class="o">(</span><span class="n">args</span> <span class="o">:</span> <span class="n">σ</span> <span class="bp">→</span> <span class="n">bool</span><span class="o">)</span> <span class="o">:</span> <span class="n">gate</span> <span class="n">σ</span> <span class="bp">→</span> <span class="n">bool</span>
<span class="bp">|</span> <span class="n">input</span> <span class="n">i</span> <span class="o">:=</span> <span class="n">args</span> <span class="n">i</span>
<span class="bp">|</span> <span class="n">and</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">band</span> <span class="o">(</span><span class="n">x.eval</span> <span class="n">args</span><span class="o">)</span> <span class="o">(</span><span class="n">y.eval</span> <span class="n">args</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">xor</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">bxor</span> <span class="o">(</span><span class="n">x.eval</span> <span class="n">args</span><span class="o">)</span> <span class="o">(</span><span class="n">y.eval</span> <span class="n">args</span><span class="o">)</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">function.surjective</span> <span class="n">gate.eval</span>
</code></pre></div>



<a name="305772502"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Defining%20circuits%20%2B%20proving%20circuit%20generation/near/305772502" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Defining.20circuits.20.2B.20proving.20circuit.20generation.html#305772502">(Oct 24 2022 at 08:47)</a>:</h4>
<p>In that example, fanouts and crossovers are encoded in lean's expression tree to make things easier</p>



<a name="305775169"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Defining%20circuits%20%2B%20proving%20circuit%20generation/near/305775169" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Defining.20circuits.20.2B.20proving.20circuit.20generation.html#305775169">(Oct 24 2022 at 09:04)</a>:</h4>
<p>What about functions with multiple outputs? Potentially I guess you could do that as a general case of this...</p>



<a name="305776465"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Defining%20circuits%20%2B%20proving%20circuit%20generation/near/305776465" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Defining.20circuits.20.2B.20proving.20circuit.20generation.html#305776465">(Oct 24 2022 at 09:12)</a>:</h4>
<p>Also I think it wants to be <code>fin n</code> instead of general sigma as the argument I know does an induction.</p>



<a name="305776541"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Defining%20circuits%20%2B%20proving%20circuit%20generation/near/305776541" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Defining.20circuits.20.2B.20proving.20circuit.20generation.html#305776541">(Oct 24 2022 at 09:13)</a>:</h4>
<p>At the very least a fintype (I can't recall if doing an induction on fintypes is a good idea).</p>



<a name="305780560"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Defining%20circuits%20%2B%20proving%20circuit%20generation/near/305780560" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Defining.20circuits.20.2B.20proving.20circuit.20generation.html#305780560">(Oct 24 2022 at 09:38)</a>:</h4>
<p>I'm also pretty sure that FANOUT and CROSSOVER want to be explicit gates because they are part of the content of the circuit (and FANOUT in particular can't exist in a quantum circuit, so it's good to make the distinction explicit).</p>



<a name="305795433"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Defining%20circuits%20%2B%20proving%20circuit%20generation/near/305795433" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Defining.20circuits.20.2B.20proving.20circuit.20generation.html#305795433">(Oct 24 2022 at 11:17)</a>:</h4>
<p>A function with multiple outputs is just a collection of single-output functions</p>



<a name="305795513"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Defining%20circuits%20%2B%20proving%20circuit%20generation/near/305795513" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Defining.20circuits.20.2B.20proving.20circuit.20generation.html#305795513">(Oct 24 2022 at 11:17)</a>:</h4>
<p><span class="user-mention silent" data-user-id="330967">Wrenna Robson</span> <a href="#narrow/stream/113488-general/topic/Defining.20circuits.20.2B.20proving.20circuit.20generation/near/305776465">said</a>:</p>
<blockquote>
<p>Also I think it wants to be <code>fin n</code> instead of general sigma as the argument I know does an induction.</p>
</blockquote>
<p>You can always prove the surjectivity for <code>σ = fin n</code> or <code>fintype σ</code>, there's no need to restrict the definition</p>



<a name="305894110"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Defining%20circuits%20%2B%20proving%20circuit%20generation/near/305894110" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Defining.20circuits.20.2B.20proving.20circuit.20generation.html#305894110">(Oct 24 2022 at 18:59)</a>:</h4>
<p>You also need to be able to feed in dummy values.</p>



<a name="305894155"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Defining%20circuits%20%2B%20proving%20circuit%20generation/near/305894155" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Defining.20circuits.20.2B.20proving.20circuit.20generation.html#305894155">(Oct 24 2022 at 18:59)</a>:</h4>
<p>I think that's ok currently</p>



<a name="305923489"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Defining%20circuits%20%2B%20proving%20circuit%20generation/near/305923489" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Defining.20circuits.20.2B.20proving.20circuit.20generation.html#305923489">(Oct 24 2022 at 22:28)</a>:</h4>
<p>You might be interested in the description in terms of monoidal categories (circuits with FANOUT and CROSSOVER "live" in a cartesian monoidal category, circuits with CROSSOVER "live" in a symmetric monoidal category, circuits with neither live in a monoidal category). In some sense your inductive type is going to be the construction of the free [cartesian|symmetric| ] monoidal category, but before quotienting by all the relations making the axioms true. (e.g. that CROSSOVER squares to the identity, etc)</p>



<a name="305999064"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Defining%20circuits%20%2B%20proving%20circuit%20generation/near/305999064" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Defining.20circuits.20.2B.20proving.20circuit.20generation.html#305999064">(Oct 25 2022 at 10:31)</a>:</h4>
<p>Yes, I believe this is true.</p>



<a name="305999543"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Defining%20circuits%20%2B%20proving%20circuit%20generation/near/305999543" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Defining.20circuits.20.2B.20proving.20circuit.20generation.html#305999543">(Oct 25 2022 at 10:34)</a>:</h4>
<p>I guess what I'm most struggling with is how you define the operation that is, you know, "I have some circuit with 5 outputs and I want to stick 3 of those outputs into another circuit with 4 inputs, get an input from another circuit, and let the other outputs extend"</p>



<a name="305999575"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Defining%20circuits%20%2B%20proving%20circuit%20generation/near/305999575" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Defining.20circuits.20.2B.20proving.20circuit.20generation.html#305999575">(Oct 25 2022 at 10:35)</a>:</h4>
<p>Which I can't picture with Eric's construction.</p>



<a name="306000440"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Defining%20circuits%20%2B%20proving%20circuit%20generation/near/306000440" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Defining.20circuits.20.2B.20proving.20circuit.20generation.html#306000440">(Oct 25 2022 at 10:41)</a>:</h4>
<p>You can do that by adding what amounts to a monad instance on <code>gate</code>: Given a <code>gate X</code> and a function from <code>X</code> to <code>gate Y</code> you can construct a <code>gate Y</code> by composition</p>



<a name="306000784"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Defining%20circuits%20%2B%20proving%20circuit%20generation/near/306000784" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Defining.20circuits.20.2B.20proving.20circuit.20generation.html#306000784">(Oct 25 2022 at 10:44)</a>:</h4>
<p>In Eric's construction circuits only have one output. A circuit with multiple outputs would be a <code>Output -&gt; gate Input</code> function (a Kleisli arrow).</p>



<a name="306000794"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Defining%20circuits%20%2B%20proving%20circuit%20generation/near/306000794" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Defining.20circuits.20.2B.20proving.20circuit.20generation.html#306000794">(Oct 25 2022 at 10:44)</a>:</h4>
<p>Aha</p>



<a name="306000869"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Defining%20circuits%20%2B%20proving%20circuit%20generation/near/306000869" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Defining.20circuits.20.2B.20proving.20circuit.20generation.html#306000869">(Oct 25 2022 at 10:45)</a>:</h4>
<p>where Output and Input are both themselves kinds of gate?</p>



<a name="306000947"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Defining%20circuits%20%2B%20proving%20circuit%20generation/near/306000947" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Defining.20circuits.20.2B.20proving.20circuit.20generation.html#306000947">(Oct 25 2022 at 10:46)</a>:</h4>
<p>In the last bit <code>Output</code> and <code>Input</code> are finite types that range over the set of wires coming in/out</p>



<a name="306001017"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Defining%20circuits%20%2B%20proving%20circuit%20generation/near/306001017" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Defining.20circuits.20.2B.20proving.20circuit.20generation.html#306001017">(Oct 25 2022 at 10:46)</a>:</h4>
<p>so the input value of type <code>Output</code> is selecting which wire you want to sample</p>



<a name="306001296"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Defining%20circuits%20%2B%20proving%20circuit%20generation/near/306001296" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Defining.20circuits.20.2B.20proving.20circuit.20generation.html#306001296">(Oct 25 2022 at 10:49)</a>:</h4>
<p>You can use Eric's <code>eval</code> function to apply a <code>Output -&gt; gate Input</code> to a <code>Input -&gt; bool</code> function to get an <code>Output -&gt; bool</code> function (this might help explain why everything seems turned around, the input and output are contravariant)</p>



<a name="306002298"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Defining%20circuits%20%2B%20proving%20circuit%20generation/near/306002298" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Defining.20circuits.20.2B.20proving.20circuit.20generation.html#306002298">(Oct 25 2022 at 10:57)</a>:</h4>
<p><code>Output</code> and <code>Input</code> can be thought of as types that hold the names of the wires. Most like you will want to set them to <code>fin n</code> so that you can use <code>![ ... ]</code> notation, but there's no reason to do so in the definition</p>



<a name="306002898"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Defining%20circuits%20%2B%20proving%20circuit%20generation/near/306002898" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Defining.20circuits.20.2B.20proving.20circuit.20generation.html#306002898">(Oct 25 2022 at 11:01)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">gate.bind</span> <span class="o">(</span><span class="n">blocks</span> <span class="o">:</span> <span class="n">σ</span> <span class="bp">→</span> <span class="n">gate</span> <span class="n">σ2</span><span class="o">)</span> <span class="o">:</span> <span class="n">gate</span> <span class="n">σ</span> <span class="bp">→</span> <span class="n">gate</span> <span class="n">σ2</span>
<span class="bp">|</span> <span class="n">input</span> <span class="n">i</span> <span class="o">:=</span> <span class="n">blocks</span> <span class="n">i</span>
<span class="bp">|</span> <span class="n">and</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">band</span> <span class="o">(</span><span class="n">x.bind</span> <span class="n">blocks</span><span class="o">)</span> <span class="o">(</span><span class="n">y.bind</span> <span class="n">blocks</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">xor</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">bxor</span> <span class="o">(</span><span class="n">x.bind</span> <span class="n">blocks</span><span class="o">)</span> <span class="o">(</span><span class="n">y.bind</span> <span class="n">blocks</span><span class="o">)</span>
</code></pre></div>
<p>I couldn't work it out from your initial description; do you want to allow constant values? if so, you can implement <code>eval</code> in terms of <code>bind</code> composed with <code>gate.const</code>. If you only want to permit "dummy" wires with indeterminate values, then I think you can still do this but you'll need to make the return type of <code>eval</code> <code>option bool</code></p>



<a name="306006148"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Defining%20circuits%20%2B%20proving%20circuit%20generation/near/306006148" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Defining.20circuits.20.2B.20proving.20circuit.20generation.html#306006148">(Oct 25 2022 at 11:24)</a>:</h4>
<p>Yes, I want to allow constant values.</p>



<a name="306622693"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Defining%20circuits%20%2B%20proving%20circuit%20generation/near/306622693" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Defining.20circuits.20.2B.20proving.20circuit.20generation.html#306622693">(Oct 28 2022 at 10:16)</a>:</h4>
<p>So oddly enough, entirely separately to the above I was looking today at this Coq definition (for a different context, but similar context). How would I replicate this in Lean 3/Lean 4?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">Inductive</span> <span class="n">ZX</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">-&gt;</span> <span class="n">nat</span> <span class="bp">-&gt;</span> <span class="kt">Type</span> <span class="o">:=</span>
  <span class="bp">|</span> <span class="n">Empty</span> <span class="o">:</span> <span class="n">ZX</span> <span class="mi">0</span> <span class="mi">0</span>
  <span class="bp">|</span> <span class="n">X_Spider</span> <span class="n">nIn</span> <span class="n">nOut</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span> <span class="n">ZX</span> <span class="n">nIn</span> <span class="n">nOut</span>
  <span class="bp">|</span> <span class="n">Z_Spider</span> <span class="n">nIn</span> <span class="n">nOut</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span> <span class="n">ZX</span> <span class="n">nIn</span> <span class="n">nOut</span>
  <span class="bp">|</span> <span class="n">Cap</span> <span class="o">:</span> <span class="n">ZX</span> <span class="mi">0</span> <span class="mi">2</span>
  <span class="bp">|</span> <span class="n">Cup</span> <span class="o">:</span> <span class="n">ZX</span> <span class="mi">2</span> <span class="mi">0</span>
  <span class="bp">|</span> <span class="n">Swap</span> <span class="o">:</span> <span class="n">ZX</span> <span class="mi">2</span> <span class="mi">2</span>
  <span class="bp">|</span> <span class="n">Stack</span> <span class="o">{</span><span class="n">nIn0</span> <span class="n">nIn1</span> <span class="n">nOut0</span> <span class="n">nOut1</span><span class="o">}</span> <span class="o">(</span><span class="n">zx0</span> <span class="o">:</span> <span class="n">ZX</span> <span class="n">nIn0</span> <span class="n">nOut0</span><span class="o">)</span> <span class="o">(</span><span class="n">zx1</span> <span class="o">:</span> <span class="n">ZX</span> <span class="n">nIn1</span> <span class="n">nOut1</span><span class="o">)</span> <span class="o">:</span>
      <span class="n">ZX</span> <span class="o">(</span><span class="n">nIn0</span> <span class="bp">+</span> <span class="n">nIn1</span><span class="o">)</span> <span class="o">(</span><span class="n">nOut0</span> <span class="bp">+</span> <span class="n">nOut1</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">Compose</span> <span class="o">{</span><span class="n">nIn</span> <span class="n">nMid</span> <span class="n">nOut</span><span class="o">}</span> <span class="o">(</span><span class="n">zx0</span> <span class="o">:</span> <span class="n">ZX</span> <span class="n">nIn</span> <span class="n">nMid</span><span class="o">)</span> <span class="o">(</span><span class="n">zx1</span> <span class="o">:</span> <span class="n">ZX</span> <span class="n">nMid</span> <span class="n">nOut</span><span class="o">)</span> <span class="o">:</span> <span class="n">ZX</span> <span class="n">nIn</span> <span class="n">nOut.</span>
</code></pre></div>



<a name="306623237"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Defining%20circuits%20%2B%20proving%20circuit%20generation/near/306623237" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Defining.20circuits.20.2B.20proving.20circuit.20generation.html#306623237">(Oct 28 2022 at 10:19)</a>:</h4>
<p>I'm not sure what <code>R</code> is (though I recognize the inductive type as being for the ZX graphical calculus), but here's Lean 3:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variables</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span>

<span class="kd">inductive</span> <span class="n">ZX</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">-&gt;</span> <span class="n">ℕ</span> <span class="bp">-&gt;</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">Empty</span> <span class="o">:</span> <span class="n">ZX</span> <span class="mi">0</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="n">X_Spider</span> <span class="n">nIn</span> <span class="n">nOut</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span> <span class="n">ZX</span> <span class="n">nIn</span> <span class="n">nOut</span>
<span class="bp">|</span> <span class="n">Z_Spider</span> <span class="n">nIn</span> <span class="n">nOut</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span> <span class="n">ZX</span> <span class="n">nIn</span> <span class="n">nOut</span>
<span class="bp">|</span> <span class="n">Cap</span> <span class="o">:</span> <span class="n">ZX</span> <span class="mi">0</span> <span class="mi">2</span>
<span class="bp">|</span> <span class="n">Cup</span> <span class="o">:</span> <span class="n">ZX</span> <span class="mi">2</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="n">Swap</span> <span class="o">:</span> <span class="n">ZX</span> <span class="mi">2</span> <span class="mi">2</span>
<span class="bp">|</span> <span class="n">Stack</span> <span class="o">{</span><span class="n">nIn0</span> <span class="n">nIn1</span> <span class="n">nOut0</span> <span class="n">nOut1</span><span class="o">}</span> <span class="o">(</span><span class="n">zx0</span> <span class="o">:</span> <span class="n">ZX</span> <span class="n">nIn0</span> <span class="n">nOut0</span><span class="o">)</span> <span class="o">(</span><span class="n">zx1</span> <span class="o">:</span> <span class="n">ZX</span> <span class="n">nIn1</span> <span class="n">nOut1</span><span class="o">)</span> <span class="o">:</span>
    <span class="n">ZX</span> <span class="o">(</span><span class="n">nIn0</span> <span class="bp">+</span> <span class="n">nIn1</span><span class="o">)</span> <span class="o">(</span><span class="n">nOut0</span> <span class="bp">+</span> <span class="n">nOut1</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">Compose</span> <span class="o">{</span><span class="n">nIn</span> <span class="n">nMid</span> <span class="n">nOut</span><span class="o">}</span> <span class="o">(</span><span class="n">zx0</span> <span class="o">:</span> <span class="n">ZX</span> <span class="n">nIn</span> <span class="n">nMid</span><span class="o">)</span> <span class="o">(</span><span class="n">zx1</span> <span class="o">:</span> <span class="n">ZX</span> <span class="n">nMid</span> <span class="n">nOut</span><span class="o">)</span> <span class="o">:</span> <span class="n">ZX</span> <span class="n">nIn</span> <span class="n">nOut</span>
</code></pre></div>



<a name="306623825"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Defining%20circuits%20%2B%20proving%20circuit%20generation/near/306623825" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Defining.20circuits.20.2B.20proving.20circuit.20generation.html#306623825">(Oct 28 2022 at 10:22)</a>:</h4>
<p>Ah right, <code>R</code> should be the real numbers, recording the phase for the X/Z spider</p>



<a name="306623905"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Defining%20circuits%20%2B%20proving%20circuit%20generation/near/306623905" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Defining.20circuits.20.2B.20proving.20circuit.20generation.html#306623905">(Oct 28 2022 at 10:23)</a>:</h4>
<p>Right I thought it should just work in place.</p>



<a name="306623973"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Defining%20circuits%20%2B%20proving%20circuit%20generation/near/306623973" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Defining.20circuits.20.2B.20proving.20circuit.20generation.html#306623973">(Oct 28 2022 at 10:23)</a>:</h4>
<p>And aye it's the ZX Calculus.</p>



<a name="306625610"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Defining%20circuits%20%2B%20proving%20circuit%20generation/near/306625610" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Defining.20circuits.20.2B.20proving.20circuit.20generation.html#306625610">(Oct 28 2022 at 10:34)</a>:</h4>
<p>Yeah, alright, that does appear to work in Lean 3 - not sure about Lean 4 though.</p>



<a name="315422950"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Defining%20circuits%20%2B%20proving%20circuit%20generation/near/315422950" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lev Stambler <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Defining.20circuits.20.2B.20proving.20circuit.20generation.html#315422950">(Dec 12 2022 at 17:40)</a>:</h4>
<p>Is there any intuition as to why ZX calculus is used over more traditional representations of circuits?</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
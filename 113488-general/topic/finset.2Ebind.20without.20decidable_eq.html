---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/finset.2Ebind.20without.20decidable_eq.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finset.2Ebind.20without.20decidable_eq.html">finset.bind without decidable_eq</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="204818038"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finset.bind%20without%20decidable_eq/near/204818038" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finset.2Ebind.20without.20decidable_eq.html#204818038">(Jul 23 2020 at 16:10)</a>:</h4>
<p>How can I define the following without needing <code>decidable_eq</code>?</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">bind_prod</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">sa</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">fb</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">finset</span> <span class="n">β</span><span class="o">):</span> <span class="n">finset</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">β</span><span class="o">)</span>
  <span class="o">:=</span> <span class="n">sa</span><span class="bp">.</span><span class="n">bind</span><span class="o">(</span><span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="o">(</span><span class="n">fb</span> <span class="n">a</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="bp">⟨</span><span class="n">prod</span><span class="bp">.</span><span class="n">mk</span> <span class="n">a</span><span class="o">,</span> <span class="k">begin</span>
    <span class="n">intros</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">ha</span><span class="o">,</span>
    <span class="n">exact</span> <span class="o">(</span><span class="n">prod</span><span class="bp">.</span><span class="n">mk</span><span class="bp">.</span><span class="n">inj</span> <span class="n">ha</span><span class="o">)</span><span class="bp">.</span><span class="n">right</span><span class="o">,</span>
  <span class="kn">end</span><span class="bp">⟩</span><span class="o">)</span>
</code></pre></div>


<p>Normally <code>sa.bind</code> needs <code>decidable_eq</code> to remove duplicates, but in this case I already know there are no duplicates.</p>



<a name="204819976"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finset.bind%20without%20decidable_eq/near/204819976" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finset.2Ebind.20without.20decidable_eq.html#204819976">(Jul 23 2020 at 16:25)</a>:</h4>
<p>You can use something like <code>⟨sa.1.bind _, multiset.nodup_bind.2 _⟩</code></p>



<a name="204823750"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finset.bind%20without%20decidable_eq/near/204823750" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finset.2Ebind.20without.20decidable_eq.html#204823750">(Jul 23 2020 at 16:55)</a>:</h4>
<p>Yeah, that's the route I went:</p>
<div class="codehilite"><pre><span></span><code><span class="n">universes</span> <span class="n">u</span> <span class="n">v</span> <span class="n">w</span>
<span class="n">def</span> <span class="n">bind_prod</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">(</span><span class="n">sa</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">fb</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">finset</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">finset</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">β</span><span class="o">)</span>
  <span class="o">:=</span> <span class="bp">⟨</span>
    <span class="n">sa</span><span class="bp">.</span><span class="n">val</span><span class="bp">.</span><span class="n">bind</span><span class="o">(</span><span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="o">((</span><span class="n">fb</span> <span class="n">a</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="bp">⟨</span><span class="n">prod</span><span class="bp">.</span><span class="n">mk</span> <span class="n">a</span><span class="o">,</span> <span class="k">begin</span>
      <span class="n">intros</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">ha</span><span class="o">,</span>
      <span class="n">exact</span> <span class="o">(</span><span class="n">prod</span><span class="bp">.</span><span class="n">mk</span><span class="bp">.</span><span class="n">inj</span> <span class="n">ha</span><span class="o">)</span><span class="bp">.</span><span class="n">right</span><span class="o">,</span>
    <span class="kn">end</span><span class="bp">⟩</span><span class="o">)</span><span class="bp">.</span><span class="n">val</span><span class="o">),</span>
    <span class="k">begin</span>
      <span class="n">rw</span> <span class="n">multiset</span><span class="bp">.</span><span class="n">nodup_bind</span><span class="o">,</span>
      <span class="n">split</span><span class="o">,</span>
      <span class="n">intros</span> <span class="n">a</span> <span class="n">ha</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">finset</span><span class="bp">.</span><span class="n">nodup</span> <span class="bp">_</span><span class="o">,</span>
      <span class="n">refine</span> <span class="n">multiset</span><span class="bp">.</span><span class="n">pairwise_of_nodup</span> <span class="bp">_</span> <span class="o">(</span><span class="n">finset</span><span class="bp">.</span><span class="n">nodup</span> <span class="bp">_</span><span class="o">),</span>
      <span class="n">intros</span> <span class="n">a</span> <span class="n">ha</span> <span class="n">a2</span> <span class="n">ha2</span> <span class="n">heq</span><span class="o">,</span>
      <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">finset</span><span class="bp">.</span><span class="n">map_val</span><span class="o">],</span>
      <span class="n">rw</span> <span class="n">multiset</span><span class="bp">.</span><span class="n">disjoint_map_map</span><span class="o">,</span>
      <span class="n">intros</span> <span class="n">b1</span> <span class="n">hb1</span> <span class="n">b2</span> <span class="n">hb2</span><span class="o">,</span>
      <span class="n">unfold_coes</span><span class="o">,</span>
      <span class="n">simp</span> <span class="n">only</span> <span class="o">[],</span>
      <span class="n">intro</span> <span class="n">hanother</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">heq</span> <span class="o">(</span><span class="n">prod</span><span class="bp">.</span><span class="n">mk</span><span class="bp">.</span><span class="n">inj</span> <span class="n">hanother</span><span class="o">)</span><span class="bp">.</span><span class="n">left</span><span class="o">,</span>
    <span class="kn">end</span>
  <span class="bp">⟩</span>

<span class="kn">lemma</span> <span class="n">mem_bind_prod</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">(</span><span class="n">sa</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">fb</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">finset</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">ab</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">×</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">ab</span> <span class="err">∈</span> <span class="n">bind_prod</span> <span class="n">sa</span> <span class="n">fb</span> <span class="bp">↔</span> <span class="n">ab</span><span class="bp">.</span><span class="n">fst</span> <span class="err">∈</span> <span class="n">sa</span> <span class="bp">∧</span> <span class="n">ab</span><span class="bp">.</span><span class="n">snd</span> <span class="err">∈</span> <span class="n">fb</span> <span class="n">ab</span><span class="bp">.</span><span class="n">fst</span> <span class="o">:=</span> <span class="k">begin</span>
  <span class="n">unfold</span> <span class="n">bind_prod</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">finset</span><span class="bp">.</span><span class="n">mem_def</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[],</span>
  <span class="n">rw</span> <span class="n">multiset</span><span class="bp">.</span><span class="n">mem_bind</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="err">←</span> <span class="n">finset</span><span class="bp">.</span><span class="n">mem_def</span><span class="o">,</span> <span class="n">finset</span><span class="bp">.</span><span class="n">mem_map</span><span class="o">,</span> <span class="n">function</span><span class="bp">.</span><span class="n">embedding</span><span class="bp">.</span><span class="n">coe_fn_mk</span><span class="o">],</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span>
    <span class="n">rintros</span> <span class="bp">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">ha</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">hb</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span><span class="o">,</span>
    <span class="n">rw</span> <span class="err">←</span> <span class="n">finset</span><span class="bp">.</span><span class="n">mem_def</span> <span class="n">at</span> <span class="n">ha</span><span class="o">,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">ha</span><span class="o">,</span> <span class="n">hb</span><span class="o">],</span>
  <span class="o">},</span>
  <span class="o">{</span>
    <span class="n">rintros</span> <span class="bp">⟨</span><span class="n">ha</span><span class="o">,</span> <span class="n">hb</span><span class="bp">⟩</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">finset</span><span class="bp">.</span><span class="n">mem_def</span> <span class="n">at</span> <span class="n">ha</span><span class="o">,</span>
    <span class="n">use</span> <span class="o">[</span><span class="n">ab</span><span class="bp">.</span><span class="n">fst</span><span class="o">,</span> <span class="n">ha</span><span class="o">,</span> <span class="n">ab</span><span class="bp">.</span><span class="n">snd</span><span class="o">,</span> <span class="n">hb</span><span class="o">],</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">prod</span><span class="bp">.</span><span class="n">mk</span><span class="bp">.</span><span class="n">eta</span><span class="o">],</span>
  <span class="o">}</span>
<span class="kn">end</span>
</code></pre></div>



<a name="204823776"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finset.bind%20without%20decidable_eq/near/204823776" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finset.2Ebind.20without.20decidable_eq.html#204823776">(Jul 23 2020 at 16:55)</a>:</h4>
<p>Would this belong in mathlib?</p>



<a name="204824214"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finset.bind%20without%20decidable_eq/near/204824214" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finset.2Ebind.20without.20decidable_eq.html#204824214">(Jul 23 2020 at 16:59)</a>:</h4>
<p>I guess yes. I'd also add a <code>bind_nodup (s : finset α) (t : α → finset β) (ht : ∀ (i ∈ s) (j ∈ s), i ≠ j → disjoint (t i) (t j)) : finset β</code> as an intermediate definition.</p>



<a name="204824237"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finset.bind%20without%20decidable_eq/near/204824237" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finset.2Ebind.20without.20decidable_eq.html#204824237">(Jul 23 2020 at 16:59)</a>:</h4>
<p>This is very close to <code>finset.sigma</code>, which is slightly more general.</p>



<a name="204824370"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finset.bind%20without%20decidable_eq/near/204824370" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finset.2Ebind.20without.20decidable_eq.html#204824370">(Jul 23 2020 at 17:00)</a>:</h4>
<p>Can you show me how to express this using finset.sigma?</p>



<a name="204824371"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finset.bind%20without%20decidable_eq/near/204824371" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finset.2Ebind.20without.20decidable_eq.html#204824371">(Jul 23 2020 at 17:00)</a>:</h4>
<p>But it's probably worth having.</p>



<a name="204824395"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finset.bind%20without%20decidable_eq/near/204824395" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finset.2Ebind.20without.20decidable_eq.html#204824395">(Jul 23 2020 at 17:00)</a>:</h4>
<p>Is <code>prod_bind</code> a good name?</p>



<a name="204824436"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finset.bind%20without%20decidable_eq/near/204824436" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finset.2Ebind.20without.20decidable_eq.html#204824436">(Jul 23 2020 at 17:00)</a>:</h4>
<p>Thanks <span class="user-mention" data-user-id="110044">@Chris Hughes</span> !</p>



<a name="204824465"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finset.bind%20without%20decidable_eq/near/204824465" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finset.2Ebind.20without.20decidable_eq.html#204824465">(Jul 23 2020 at 17:01)</a>:</h4>
<p>You can do <code>(s.sigma t).map (equiv.sigma_equiv_prod _ _).to_embedding</code></p>



<a name="204824710"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finset.bind%20without%20decidable_eq/near/204824710" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finset.2Ebind.20without.20decidable_eq.html#204824710">(Jul 23 2020 at 17:03)</a>:</h4>
<p>Sweet, thanks!</p>



<a name="204825936"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finset.bind%20without%20decidable_eq/near/204825936" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finset.2Ebind.20without.20decidable_eq.html#204825936">(Jul 23 2020 at 17:14)</a>:</h4>
<p>I end up stuck trying to prove <code>⊢ (equiv.sigma_equiv_prod α β).to_fun ⟨ab.fst, ab.snd⟩ = ab</code> if I go down that route</p>



<a name="204825987"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finset.bind%20without%20decidable_eq/near/204825987" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finset.2Ebind.20without.20decidable_eq.html#204825987">(Jul 23 2020 at 17:14)</a>:</h4>
<p>Which looks like a trivial statement</p>



<a name="204826222"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finset.bind%20without%20decidable_eq/near/204826222" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finset.2Ebind.20without.20decidable_eq.html#204826222">(Jul 23 2020 at 17:16)</a>:</h4>
<p>Does <code>simp</code> work?</p>



<a name="204826250"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finset.bind%20without%20decidable_eq/near/204826250" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finset.2Ebind.20without.20decidable_eq.html#204826250">(Jul 23 2020 at 17:16)</a>:</h4>
<p>I think this is <code>prod.eta</code></p>



<a name="204826274"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finset.bind%20without%20decidable_eq/near/204826274" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finset.2Ebind.20without.20decidable_eq.html#204826274">(Jul 23 2020 at 17:17)</a>:</h4>
<p>No, it doesn't</p>



<a name="204826282"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finset.bind%20without%20decidable_eq/near/204826282" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finset.2Ebind.20without.20decidable_eq.html#204826282">(Jul 23 2020 at 17:17)</a>:</h4>
<p>Or <code>sigma.eta</code></p>



<a name="204826286"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finset.bind%20without%20decidable_eq/near/204826286" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finset.2Ebind.20without.20decidable_eq.html#204826286">(Jul 23 2020 at 17:17)</a>:</h4>
<p>The angle brackets are <code>sigma.mk</code></p>



<a name="204826292"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finset.bind%20without%20decidable_eq/near/204826292" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finset.2Ebind.20without.20decidable_eq.html#204826292">(Jul 23 2020 at 17:17)</a>:</h4>
<p>but <code>ab</code> is a <code>prod</code></p>



<a name="204826332"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finset.bind%20without%20decidable_eq/near/204826332" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finset.2Ebind.20without.20decidable_eq.html#204826332">(Jul 23 2020 at 17:17)</a>:</h4>
<p>So it's <code>prod.eta</code> I think.</p>



<a name="204826348"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finset.bind%20without%20decidable_eq/near/204826348" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finset.2Ebind.20without.20decidable_eq.html#204826348">(Jul 23 2020 at 17:17)</a>:</h4>
<p><code>apply prod.eta</code> should work hopefully.</p>



<a name="204826355"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finset.bind%20without%20decidable_eq/near/204826355" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finset.2Ebind.20without.20decidable_eq.html#204826355">(Jul 23 2020 at 17:17)</a>:</h4>
<p>While you're at it, please rewrite <code>equiv.sigma_equiv_prod</code> to avoid <code>λ ⟨a, b⟩</code></p>



<a name="204826404"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finset.bind%20without%20decidable_eq/near/204826404" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finset.2Ebind.20without.20decidable_eq.html#204826404">(Jul 23 2020 at 17:18)</a>:</h4>
<p>Use <code>λ a, (a.1, b.1)</code> instead.</p>



<a name="204826449"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finset.bind%20without%20decidable_eq/near/204826449" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finset.2Ebind.20without.20decidable_eq.html#204826449">(Jul 23 2020 at 17:18)</a>:</h4>
<p><code>prod.eta</code> doesn't exist</p>



<a name="204826465"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finset.bind%20without%20decidable_eq/near/204826465" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finset.2Ebind.20without.20decidable_eq.html#204826465">(Jul 23 2020 at 17:19)</a>:</h4>
<p><code>prod.mk.eta</code> does the trick though!</p>



<a name="204826536"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finset.bind%20without%20decidable_eq/near/204826536" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finset.2Ebind.20without.20decidable_eq.html#204826536">(Jul 23 2020 at 17:19)</a>:</h4>
<p><code>sigma_equiv_prod</code> is missing <code>simp</code> lemmas.</p>



<a name="204826641"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finset.bind%20without%20decidable_eq/near/204826641" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finset.2Ebind.20without.20decidable_eq.html#204826641">(Jul 23 2020 at 17:20)</a>:</h4>
<p>Goign the other way, how can I extract <code>(a, b) = ab</code> from <code>h: ⇑(equiv.sigma_equiv_prod α β) ⟨a, b⟩ = ab</code>?</p>



<a name="204826673"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finset.bind%20without%20decidable_eq/near/204826673" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finset.2Ebind.20without.20decidable_eq.html#204826673">(Jul 23 2020 at 17:21)</a>:</h4>
<p>The whole <code>sigma</code>/<code>psigma</code> section of <code>data/equiv/basic</code> should be fixed to (a) don't use <code>λ ⟨a, b⟩</code>; (b) have <code>simp</code> lemmas.</p>



<a name="204826722"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finset.bind%20without%20decidable_eq/near/204826722" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finset.2Ebind.20without.20decidable_eq.html#204826722">(Jul 23 2020 at 17:21)</a>:</h4>
<p>Is <code>λ ⟨a, b⟩</code> always an antipattern?</p>



<a name="204826845"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finset.bind%20without%20decidable_eq/near/204826845" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finset.2Ebind.20without.20decidable_eq.html#204826845">(Jul 23 2020 at 17:22)</a>:</h4>
<p>Using <code>λ ⟨a, b⟩, _</code> is a bad idea whenever you care about definitional equality of the result.</p>



<a name="204826872"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finset.bind%20without%20decidable_eq/near/204826872" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finset.2Ebind.20without.20decidable_eq.html#204826872">(Jul 23 2020 at 17:22)</a>:</h4>
<p>I.e., when you define a function. It's OK in a proof.</p>



<a name="204827072"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finset.bind%20without%20decidable_eq/near/204827072" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finset.2Ebind.20without.20decidable_eq.html#204827072">(Jul 23 2020 at 17:24)</a>:</h4>
<p>The main problem with <code>def f : α × β → α := λ ⟨a, b⟩, a</code> is that <code>f p</code> is not defeq <code>p.1</code>.</p>



<a name="204827085"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finset.bind%20without%20decidable_eq/near/204827085" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finset.2Ebind.20without.20decidable_eq.html#204827085">(Jul 23 2020 at 17:24)</a>:</h4>
<p>But <code>f (a, b)</code> is defeq <code>f a</code>.</p>



<a name="204827509"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finset.bind%20without%20decidable_eq/near/204827509" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finset.2Ebind.20without.20decidable_eq.html#204827509">(Jul 23 2020 at 17:29)</a>:</h4>
<p>Ok, my end result is</p>
<div class="codehilite"><pre><span></span><code><span class="n">universes</span> <span class="n">u</span> <span class="n">v</span> <span class="n">w</span>
<span class="n">def</span> <span class="n">bind_prod</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">(</span><span class="n">sa</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">fb</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">finset</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">finset</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">β</span><span class="o">)</span>
  <span class="o">:=</span> <span class="o">(</span><span class="n">sa</span><span class="bp">.</span><span class="n">sigma</span> <span class="n">fb</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="o">(</span><span class="n">equiv</span><span class="bp">.</span><span class="n">sigma_equiv_prod</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">)</span><span class="bp">.</span><span class="n">to_embedding</span>

<span class="kn">lemma</span> <span class="n">mem_bind_prod</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">(</span><span class="n">sa</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">fb</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">finset</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">ab</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">×</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">ab</span> <span class="err">∈</span> <span class="n">bind_prod</span> <span class="n">sa</span> <span class="n">fb</span> <span class="bp">↔</span> <span class="n">ab</span><span class="bp">.</span><span class="n">fst</span> <span class="err">∈</span> <span class="n">sa</span> <span class="bp">∧</span> <span class="n">ab</span><span class="bp">.</span><span class="n">snd</span> <span class="err">∈</span> <span class="n">fb</span> <span class="n">ab</span><span class="bp">.</span><span class="n">fst</span>
<span class="o">:=</span> <span class="k">begin</span>
  <span class="n">unfold</span> <span class="n">bind_prod</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">finset</span><span class="bp">.</span><span class="n">mem_map</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">exists_prop</span><span class="o">,</span> <span class="n">sigma</span><span class="bp">.</span><span class="n">exists</span><span class="o">,</span> <span class="n">finset</span><span class="bp">.</span><span class="n">mem_sigma</span><span class="o">,</span> <span class="n">equiv</span><span class="bp">.</span><span class="n">to_embedding_coe_fn</span><span class="o">,</span> <span class="n">equiv</span><span class="bp">.</span><span class="n">sigma_equiv_prod</span><span class="o">,</span> <span class="n">equiv</span><span class="bp">.</span><span class="n">coe_fn_mk</span><span class="o">],</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span>
    <span class="n">rintros</span> <span class="bp">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">ha</span><span class="o">,</span> <span class="n">hb</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">h</span><span class="bp">⟩</span><span class="o">,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="err">←</span> <span class="n">h</span><span class="o">],</span>
    <span class="n">exact</span> <span class="bp">⟨</span><span class="n">ha</span><span class="o">,</span> <span class="n">hb</span><span class="bp">⟩</span><span class="o">,</span>
  <span class="o">},</span>
  <span class="o">{</span>
    <span class="n">rintros</span> <span class="bp">⟨</span><span class="n">ha</span><span class="o">,</span> <span class="n">hb</span><span class="bp">⟩</span><span class="o">,</span>
    <span class="n">use</span> <span class="o">[</span><span class="n">ab</span><span class="bp">.</span><span class="n">fst</span><span class="o">,</span> <span class="n">ab</span><span class="bp">.</span><span class="n">snd</span><span class="o">],</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">ha</span><span class="o">,</span> <span class="n">hb</span><span class="o">,</span> <span class="n">true_and</span><span class="o">,</span> <span class="n">prod</span><span class="bp">.</span><span class="n">mk</span><span class="bp">.</span><span class="n">eta</span><span class="o">],</span>
  <span class="o">},</span>
<span class="kn">end</span>
</code></pre></div>



<a name="204828980"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finset.bind%20without%20decidable_eq/near/204828980" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finset.2Ebind.20without.20decidable_eq.html#204828980">(Jul 23 2020 at 17:42)</a>:</h4>
<p>It seems like I ought to be able to use the reverse equivalence to simplify the <code>lemma</code> there, but I don't see how.</p>



<a name="204829964"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finset.bind%20without%20decidable_eq/near/204829964" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finset.2Ebind.20without.20decidable_eq.html#204829964">(Jul 23 2020 at 17:49)</a>:</h4>
<p><span class="user-mention silent" data-user-id="214703">Yury G. Kudryashov</span> <a href="#narrow/stream/113488-general/topic/finset.2Ebind.20without.20decidable_eq/near/204826355">said</a>:</p>
<blockquote>
<p>While you're at it, please rewrite <code>equiv.sigma_equiv_prod</code> to avoid <code>λ ⟨a, b⟩</code></p>
</blockquote>
<p>I don't feel confident doing this - perhaps worth opening a github issue so that it's not forgotten about?</p>



<a name="204833305"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finset.bind%20without%20decidable_eq/near/204833305" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finset.2Ebind.20without.20decidable_eq.html#204833305">(Jul 23 2020 at 18:14)</a>:</h4>
<p>It was easier to PR it: <a href="https://github.com/leanprover-community/mathlib/issues/3530">#3530</a></p>



<a name="204839436"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finset.bind%20without%20decidable_eq/near/204839436" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jannis Limperg <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finset.2Ebind.20without.20decidable_eq.html#204839436">(Jul 23 2020 at 18:58)</a>:</h4>
<p><span class="user-mention silent" data-user-id="214703">Yury G. Kudryashov</span> <a href="#narrow/stream/113488-general/topic/finset.2Ebind.20without.20decidable_eq/near/204827072">said</a>:</p>
<blockquote>
<p>The main problem with <code>def f : α × β → α := λ ⟨a, b⟩, a</code> is that <code>f p</code> is not defeq <code>p.1</code>.</p>
</blockquote>
<p>Do we have an issue for this? Is there any reason (except effort) not to redefine pattern-matching lambdas so that they desugar to projections?</p>



<a name="204842967"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finset.bind%20without%20decidable_eq/near/204842967" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finset.2Ebind.20without.20decidable_eq.html#204842967">(Jul 23 2020 at 19:25)</a>:</h4>
<p><span class="user-mention" data-user-id="110043">@Gabriel Ebner</span> <span aria-label="up" class="emoji emoji-2b06" role="img" title="up">:up:</span> Do I understand correctly that this should be possible if the source type has only one constructor?</p>



<a name="204876967"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finset.bind%20without%20decidable_eq/near/204876967" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finset.2Ebind.20without.20decidable_eq.html#204876967">(Jul 24 2020 at 03:48)</a>:</h4>
<p>also the type has to be large eliminating (i.e. not <code>Exists</code>)</p>



<a name="204876979"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finset.bind%20without%20decidable_eq/near/204876979" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finset.2Ebind.20without.20decidable_eq.html#204876979">(Jul 24 2020 at 03:48)</a>:</h4>
<p>in fact it should probably be restricted to structures anyway since one-constructor inductives don't have standard projections</p>



<a name="204877071"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finset.bind%20without%20decidable_eq/near/204877071" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finset.2Ebind.20without.20decidable_eq.html#204877071">(Jul 24 2020 at 03:50)</a>:</h4>
<p>This is not the desired behavior for programming uses though, I'm not sure how I feel about destructuring <code>let</code> doing this all the time</p>



<a name="204877141"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finset.bind%20without%20decidable_eq/near/204877141" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finset.2Ebind.20without.20decidable_eq.html#204877141">(Jul 24 2020 at 03:52)</a>:</h4>
<p>actually I take it back, as long as <code>let (x, y) := s in t x y</code> expands to <code>(\lam p, t p.1 p.2) s</code>it should have the right VM-computational behavior</p>



<a name="204892395"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finset.bind%20without%20decidable_eq/near/204892395" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finset.2Ebind.20without.20decidable_eq.html#204892395">(Jul 24 2020 at 08:48)</a>:</h4>
<p>I think the VM generates special instructions for projections (i.e. access one field) that are different from the ones generated by pattern-matching (i.e. destruct the object and put all fields on the stack).</p>



<a name="204892464"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finset.bind%20without%20decidable_eq/near/204892464" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finset.2Ebind.20without.20decidable_eq.html#204892464">(Jul 24 2020 at 08:49)</a>:</h4>
<p>But I'm still open to a PR that turns <code>λ ⟨a,b⟩, a</code> into a projection, given the nicer definitional reduction.</p>



<a name="204983117"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finset.bind%20without%20decidable_eq/near/204983117" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finset.2Ebind.20without.20decidable_eq.html#204983117">(Jul 25 2020 at 02:10)</a>:</h4>
<p>I've also requested this feature in the past but at this point my main concern with it is a migration plan for Lean 4</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
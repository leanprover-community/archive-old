---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/tutorial_question.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/tutorial_question.html">tutorial_question</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="224778298"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial_question/near/224778298" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Papp <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/tutorial_question.html#224778298">(Feb 01 2021 at 19:27)</a>:</h4>
<p>So here is an exact statement -&gt; <a href="https://github.com/leanprover-community/tutorials/blob/master/src/exercises/00_first_proofs.lean#L160">https://github.com/leanprover-community/tutorials/blob/master/src/exercises/00_first_proofs.lean#L160</a> I don't quite understand. hx.2 is </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="n">x</span> <span class="bp">\</span><span class="k">in</span> <span class="n">up_bounds</span><span class="o">(</span><span class="n">low_bounds</span> <span class="n">A</span><span class="o">)</span>
</code></pre></div>
<p>and we sort of apply it as a function? I don't really understand how can we turn the above statement into a function or I'm just mistaken and this is something completely different?</p>



<a name="224778556"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial_question/near/224778556" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/tutorial_question.html#224778556">(Feb 01 2021 at 19:29)</a>:</h4>
<p>What's the definition of <code>up_bounds</code>?</p>



<a name="224778688"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial_question/near/224778688" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Papp <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/tutorial_question.html#224778688">(Feb 01 2021 at 19:30)</a>:</h4>
<p><a href="https://github.com/leanprover-community/tutorials/blob/master/src/exercises/00_first_proofs.lean#L27">https://github.com/leanprover-community/tutorials/blob/master/src/exercises/00_first_proofs.lean#L27</a></p>



<a name="224778704"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial_question/near/224778704" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/tutorial_question.html#224778704">(Feb 01 2021 at 19:30)</a>:</h4>
<p>Notice that it's a forall</p>



<a name="224778831"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial_question/near/224778831" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/tutorial_question.html#224778831">(Feb 01 2021 at 19:31)</a>:</h4>
<p><code>x \in {y | \forall a, P(y,a)}</code> unfolds to <code>\forall a, P(x, a)</code> so applying it to <code>b</code> yields <code>P(x, b)</code></p>



<a name="224779034"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial_question/near/224779034" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/tutorial_question.html#224779034">(Feb 01 2021 at 19:32)</a>:</h4>
<p>In fact, the notation <code>∀ a ∈ A, a ≤ x</code> is sugar for <code>∀ a, ∀ (H : a ∈ A), a ≤ x</code> so it's two foralls, hence two applications are used in the proof</p>



<a name="224779182"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial_question/near/224779182" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Papp <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/tutorial_question.html#224779182">(Feb 01 2021 at 19:33)</a>:</h4>
<p>Wait <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>∈</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">a \in A</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span> is the type of H?</p>



<a name="224779191"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial_question/near/224779191" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/tutorial_question.html#224779191">(Feb 01 2021 at 19:33)</a>:</h4>
<p>yes</p>



<a name="224779217"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial_question/near/224779217" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/tutorial_question.html#224779217">(Feb 01 2021 at 19:33)</a>:</h4>
<p><a href="https://ncatlab.org/nlab/show/propositions+as+types">Propositions are types</a></p>



<a name="224779282"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial_question/near/224779282" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Papp <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/tutorial_question.html#224779282">(Feb 01 2021 at 19:34)</a>:</h4>
<p>Yeah, I have to get used to that.</p>



<a name="224792546"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial_question/near/224792546" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Papp <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/tutorial_question.html#224792546">(Feb 01 2021 at 21:19)</a>:</h4>
<p>I watched Wadler's talk at Strangeloop in the end. Now I have a good idea.</p>



<a name="224792610"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial_question/near/224792610" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Papp <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/tutorial_question.html#224792610">(Feb 01 2021 at 21:19)</a>:</h4>
<p>Is there a part of the documentation which gives some idea how to desugar things in lean?</p>



<a name="224793093"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial_question/near/224793093" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/tutorial_question.html#224793093">(Feb 01 2021 at 21:23)</a>:</h4>
<p>most of that is defined when the notation is introduced. I don't have any particular place to point to for this one; the basic idea is that if you have a binder like <code>\all (a op b), ...</code> or <code>\ex (a op b), ...</code> where <code>op</code> is some infix operator and <code>a</code> is a variable, then it duplicates the binder to <code>\all a, \all (H : a op b)</code> or <code>\ex a, \ex (H : a op b)</code>.</p>



<a name="224793859"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial_question/near/224793859" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Papp <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/tutorial_question.html#224793859">(Feb 01 2021 at 21:29)</a>:</h4>
<p>I see. Maybe a stupid question, but how are the quantifiers transformed into types? I mean I understand that conjunction is transformed into the product type and implication transformed into functions, but how is the universal quantifier transformed into a type?</p>



<a name="224793955"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial_question/near/224793955" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/tutorial_question.html#224793955">(Feb 01 2021 at 21:30)</a>:</h4>
<p>A universal quantifier is the same (literally the same thing in lean) as the Pi type, a dependent function type</p>



<a name="224794035"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial_question/near/224794035" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/tutorial_question.html#224794035">(Feb 01 2021 at 21:30)</a>:</h4>
<p><code>\forall x : A, B x</code> is the type of functions <code>f</code> such that for <code>a</code> in <code>A</code>, <code>f a : B a</code></p>



<a name="224794104"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial_question/near/224794104" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/tutorial_question.html#224794104">(Feb 01 2021 at 21:31)</a>:</h4>
<p>You can also use <code>\Pi</code> instead of <code>\forall</code>; lean prefers <code>\forall</code> in pretty printing if <code>B x</code> is a proposition</p>



<a name="224794264"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial_question/near/224794264" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/tutorial_question.html#224794264">(Feb 01 2021 at 21:32)</a>:</h4>
<p>Lean 4 is switching to the adga-style notation <code>(x : A) -&gt; B x</code> which makes the notational similarity to implication more obvious</p>



<a name="224794384"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial_question/near/224794384" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/tutorial_question.html#224794384">(Feb 01 2021 at 21:33)</a>:</h4>
<p>in lean <code>A -&gt; B</code> is both the nondependent function type and also implication of propositions, and is a special case of Pi/forall when the rhs doesn't depend on the lhs</p>



<a name="224794858"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial_question/near/224794858" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Papp <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/tutorial_question.html#224794858">(Feb 01 2021 at 21:37)</a>:</h4>
<p>Ok, I guess I need to read up on this too. The wikipedia page says that the Sigma type is the pair of the existential quantifier in a similar sense.</p>



<a name="224795561"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial_question/near/224795561" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/tutorial_question.html#224795561">(Feb 01 2021 at 21:43)</a>:</h4>
<p>Yep, <code>\ex (x : A), B x</code> is a pair of an <code>a : A</code> and <code>b : B a</code></p>



<a name="224795705"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial_question/near/224795705" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/tutorial_question.html#224795705">(Feb 01 2021 at 21:44)</a>:</h4>
<p>in this case though lean has a distinct definition called <code>\Sigma</code> which does the same thing but for data (non-propositions)</p>



<a name="224795865"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial_question/near/224795865" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/tutorial_question.html#224795865">(Feb 01 2021 at 21:45)</a>:</h4>
<p>the reason being that an existential is always a proposition even if <code>A</code> is not, so there is no "first projection" function from <code>\ex (x : A), B x</code> to <code>A</code>, while there is a first and second projection for <code>\Sigma</code></p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
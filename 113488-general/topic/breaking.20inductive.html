---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/breaking.20inductive.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/breaking.20inductive.html">breaking inductive</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="272695438"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/breaking%20inductive/near/272695438" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonard Wiechmann <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/breaking.20inductive.html#272695438">(Feb 21 2022 at 14:30)</a>:</h4>
<p>hey all, i've been messing with <code>inductive</code> to test my understanding of the typing rules wrt universe levels.<br>
i've found 2 cases that i'm unsure about:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="c1">-- 1: incomplete recursive arguments.</span>

<span class="c1">-- this doesn't and shouldn't work. `r: nat -&gt; Sort 1`, which has type Sort 2, which is too large.</span>
<span class="kd">inductive</span> <span class="n">T1</span><span class="o">:</span> <span class="n">nat</span> <span class="bp">-&gt;</span> <span class="kt">Sort</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="n">c</span> <span class="o">(</span><span class="n">r</span><span class="o">:</span> <span class="n">T1</span><span class="o">):</span> <span class="n">T1</span> <span class="mi">0</span>

<span class="c1">-- but this should work, right? `r: nat -&gt; Prop`, which has type Prop = Sort 0 and 0 &lt;= 0.</span>
<span class="kd">inductive</span> <span class="n">T0</span><span class="o">:</span> <span class="n">nat</span> <span class="bp">-&gt;</span> <span class="kt">Sort</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="n">c</span> <span class="o">(</span><span class="n">r</span><span class="o">:</span> <span class="n">T0</span><span class="o">):</span> <span class="n">T0</span> <span class="mi">0</span>
<span class="c1">--           ^^</span>
<span class="c1">-- it gives me an error here:</span>
<span class="c1">--type expected at</span>
<span class="c1">--  T0</span>
<span class="c1">--term has type</span>
<span class="c1">--  ℕ → Prop</span>
<span class="c1">-- that error doesn't really make sense: `\N -&gt; Prop` is a type?</span>
<span class="c1">-- if anything, i'd have expected `r: T0` to error.</span>
</code></pre></div>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="c1">-- 2: definition of Vec doesn't work for generic universe level.</span>

<span class="c1">-- this errors: arg 3 to cons (ts) is too large, which it isn't.</span>
<span class="c1">-- this same definition works when using Type instead of Sort.</span>
<span class="kd">inductive</span> <span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="n">Vec</span> <span class="o">(</span><span class="n">T</span><span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">):</span> <span class="n">nat</span> <span class="bp">-&gt;</span> <span class="kt">Sort</span> <span class="n">u</span>
<span class="bp">|</span> <span class="n">nil</span><span class="o">:</span> <span class="n">Vec</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="n">cons</span> <span class="o">(</span><span class="n">t</span><span class="o">:</span> <span class="n">T</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span><span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">(</span><span class="n">ts</span><span class="o">:</span> <span class="n">Vec</span> <span class="n">n</span><span class="o">):</span> <span class="n">Vec</span> <span class="n">n.succ</span>

<span class="c1">-- but the definition for any concrete universe level is valid...</span>
<span class="c1">-- works.</span>
<span class="kd">inductive</span> <span class="n">Vec0</span> <span class="o">(</span><span class="n">T</span><span class="o">:</span> <span class="kt">Sort</span> <span class="mi">0</span><span class="o">):</span> <span class="n">nat</span> <span class="bp">-&gt;</span> <span class="kt">Sort</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="n">nil</span><span class="o">:</span> <span class="n">Vec0</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="n">cons</span> <span class="o">(</span><span class="n">t</span><span class="o">:</span> <span class="n">T</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span><span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">(</span><span class="n">ts</span><span class="o">:</span> <span class="n">Vec0</span> <span class="n">n</span><span class="o">):</span> <span class="n">Vec0</span> <span class="n">n.succ</span>

<span class="c1">-- works.</span>
<span class="kd">inductive</span> <span class="n">Vec1</span> <span class="o">(</span><span class="n">T</span><span class="o">:</span> <span class="kt">Sort</span> <span class="mi">1</span><span class="o">):</span> <span class="n">nat</span> <span class="bp">-&gt;</span> <span class="kt">Sort</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="n">nil</span><span class="o">:</span> <span class="n">Vec1</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="n">cons</span> <span class="o">(</span><span class="n">t</span><span class="o">:</span> <span class="n">T</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span><span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">(</span><span class="n">ts</span><span class="o">:</span> <span class="n">Vec1</span> <span class="n">n</span><span class="o">):</span> <span class="n">Vec1</span> <span class="n">n.succ</span>

<span class="c1">-- works.</span>
<span class="kd">inductive</span> <span class="n">Vec42</span> <span class="o">(</span><span class="n">T</span><span class="o">:</span> <span class="kt">Sort</span> <span class="mi">42</span><span class="o">):</span> <span class="n">nat</span> <span class="bp">-&gt;</span> <span class="kt">Sort</span> <span class="mi">42</span>
<span class="bp">|</span> <span class="n">nil</span><span class="o">:</span> <span class="n">Vec42</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="n">cons</span> <span class="o">(</span><span class="n">t</span><span class="o">:</span> <span class="n">T</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span><span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">(</span><span class="n">ts</span><span class="o">:</span> <span class="n">Vec42</span> <span class="n">n</span><span class="o">):</span> <span class="n">Vec42</span> <span class="n">n.succ</span>
</code></pre></div>



<a name="272695694"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/breaking%20inductive/near/272695694" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonard Wiechmann <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/breaking.20inductive.html#272695694">(Feb 21 2022 at 14:32)</a>:</h4>
<p>i think both examples should work.<br>
which is bugged: my understanding or lean?</p>



<a name="272695738"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/breaking%20inductive/near/272695738" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/breaking.20inductive.html#272695738">(Feb 21 2022 at 14:32)</a>:</h4>
<p>In 1, both <code>r : T1</code> and <code>r : T0</code> don't make any sense. I guess Lean's error reporting got confused.</p>



<a name="272695889"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/breaking%20inductive/near/272695889" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/breaking.20inductive.html#272695889">(Feb 21 2022 at 14:34)</a>:</h4>
<p>In 2, it is not a bug, but maybe a limitation? You can't create an inductive which is a Prop for some values of the universe parameters, and a Type for others--I think it has something to do with what recursor to generate.</p>



<a name="272695944"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/breaking%20inductive/near/272695944" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonard Wiechmann <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/breaking.20inductive.html#272695944">(Feb 21 2022 at 14:34)</a>:</h4>
<p>yeah, example 1 doesn't make sense semantically.<br>
but shouldn't <code>r: T0</code> for <code>T0: nat -&gt; Prop</code> work? -- just according to the universe levels. so make sense "syntactically"?</p>



<a name="272696010"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/breaking%20inductive/near/272696010" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/breaking.20inductive.html#272696010">(Feb 21 2022 at 14:35)</a>:</h4>
<p>no</p>



<a name="272696095"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/breaking%20inductive/near/272696095" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonard Wiechmann <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/breaking.20inductive.html#272696095">(Feb 21 2022 at 14:36)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/113488-general/topic/breaking.20inductive/near/272695889">said</a>:</p>
<blockquote>
<p>In 2, it is not a bug, but maybe a limitation? You can't create an inductive which is a Prop for some values of the universe parameters, and a Type for others--I think it has something to do with what recursor to generate.</p>
</blockquote>
<p>ok, that makes sense. it can't generate both recursors.</p>



<a name="272696126"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/breaking%20inductive/near/272696126" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/breaking.20inductive.html#272696126">(Feb 21 2022 at 14:36)</a>:</h4>
<p>in <code>r : T0</code>, <code>T0</code> had better be a type, but whoops it is a function <code>T0 : nat -&gt; Prop</code> instead</p>



<a name="272696157"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/breaking%20inductive/near/272696157" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/breaking.20inductive.html#272696157">(Feb 21 2022 at 14:36)</a>:</h4>
<p>Has nothing to do with universes.</p>



<a name="272696229"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/breaking%20inductive/near/272696229" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/breaking.20inductive.html#272696229">(Feb 21 2022 at 14:37)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/113488-general/topic/breaking.20inductive/near/272695889">said</a>:</p>
<blockquote>
<p>In 2, it is not a bug, but maybe a limitation? You can't create an inductive which is a Prop for some values of the universe parameters, and a Type for others--I think it has something to do with what recursor to generate.</p>
</blockquote>
<p>Actually you can, it's just not advisable</p>



<a name="272696239"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/breaking%20inductive/near/272696239" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonard Wiechmann <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/breaking.20inductive.html#272696239">(Feb 21 2022 at 14:37)</a>:</h4>
<p>oh, I think I see where I got confused.<br>
i thought <code>T0 = nat -&gt; Prop</code> and just substituted.</p>



<a name="272696308"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/breaking%20inductive/near/272696308" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/breaking.20inductive.html#272696308">(Feb 21 2022 at 14:38)</a>:</h4>
<p>Lean 4 disallows this in the elaborator now but you can still create them if you ask the kernel directly</p>



<a name="272696374"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/breaking%20inductive/near/272696374" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonard Wiechmann <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/breaking.20inductive.html#272696374">(Feb 21 2022 at 14:38)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113488-general/topic/breaking.20inductive/near/272696308">said</a>:</p>
<blockquote>
<p>Lean 4 disallows this in the elaborator now but you can still create them if you ask the kernel directly</p>
</blockquote>
<p>does it generate the recursor for <code>Type</code>, or both?</p>



<a name="272696392"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/breaking%20inductive/near/272696392" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/breaking.20inductive.html#272696392">(Feb 21 2022 at 14:39)</a>:</h4>
<p>It generates the recursor for Prop</p>



<a name="272696411"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/breaking%20inductive/near/272696411" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonard Wiechmann <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/breaking.20inductive.html#272696411">(Feb 21 2022 at 14:39)</a>:</h4>
<p>well, that makes sense :D</p>



<a name="272696412"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/breaking%20inductive/near/272696412" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/breaking.20inductive.html#272696412">(Feb 21 2022 at 14:39)</a>:</h4>
<p>that is, it is a small eliminating type</p>



<a name="272696450"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/breaking%20inductive/near/272696450" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/breaking.20inductive.html#272696450">(Feb 21 2022 at 14:39)</a>:</h4>
<p>it's a recursor for all variations of the type, but the motive targets <code>Prop</code></p>



<a name="272696586"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/breaking%20inductive/near/272696586" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonard Wiechmann <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/breaking.20inductive.html#272696586">(Feb 21 2022 at 14:40)</a>:</h4>
<p>right, because it isn't LE <em>for all</em> universe levels</p>



<a name="272696595"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/breaking%20inductive/near/272696595" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/breaking.20inductive.html#272696595">(Feb 21 2022 at 14:40)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="n">foo</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span>
<span class="bp">|</span> <span class="n">a</span> <span class="o">:</span> <span class="n">foo</span>
<span class="bp">|</span> <span class="n">b</span> <span class="o">:</span> <span class="n">foo</span>

<span class="kd">set_option</span> <span class="n">pp.universes</span> <span class="n">true</span>
<span class="k">#print</span> <span class="n">foo.rec</span>
<span class="c1">-- protected eliminator {u} foo.rec : ∀ {motive : foo.{u} → Prop}, motive foo.a.{u} → motive foo.b.{u} → ∀ (n : foo.{u}), motive n</span>
</code></pre></div>



<a name="272696673"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/breaking%20inductive/near/272696673" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonard Wiechmann <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/breaking.20inductive.html#272696673">(Feb 21 2022 at 14:41)</a>:</h4>
<p>you need 2 constructors to not be subsingleton, right?</p>



<a name="272696686"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/breaking%20inductive/near/272696686" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/breaking.20inductive.html#272696686">(Feb 21 2022 at 14:41)</a>:</h4>
<p>right</p>



<a name="272696696"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/breaking%20inductive/near/272696696" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/breaking.20inductive.html#272696696">(Feb 21 2022 at 14:41)</a>:</h4>
<p>or other things</p>



<a name="272696780"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/breaking%20inductive/near/272696780" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonard Wiechmann <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/breaking.20inductive.html#272696780">(Feb 21 2022 at 14:42)</a>:</h4>
<p>ok, I think i've cleared up my confusion, thanks guys!</p>



<a name="272696859"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/breaking%20inductive/near/272696859" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/breaking.20inductive.html#272696859">(Feb 21 2022 at 14:42)</a>:</h4>
<p>the fun part I like to show with this example is that <code>foo.a.{1}</code> and <code>foo.b.{1}</code> are neither provably equal nor provably distinct</p>



<a name="272697008"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/breaking%20inductive/near/272697008" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/breaking.20inductive.html#272697008">(Feb 21 2022 at 14:44)</a>:</h4>
<p>ah right, I was misremembering how the example I wanted to work fails</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="n">M</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span>
<span class="bp">|</span> <span class="n">mk</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">M</span>
</code></pre></div>



<a name="272697054"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/breaking%20inductive/near/272697054" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/breaking.20inductive.html#272697054">(Feb 21 2022 at 14:44)</a>:</h4>
<p>This seems like it should be large-eliminating but Lean still makes an eliminator into Prop only</p>



<a name="272697356"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/breaking%20inductive/near/272697356" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/breaking.20inductive.html#272697356">(Feb 21 2022 at 14:46)</a>:</h4>
<p>The real reason your <code>Vec</code> example doesn't work is because lean doesn't know that <code>imax 1 u &lt;= u</code></p>



<a name="272697450"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/breaking%20inductive/near/272697450" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/breaking.20inductive.html#272697450">(Feb 21 2022 at 14:47)</a>:</h4>
<p>here's a way you can check level inequalities:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="n">foo</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span>
<span class="bp">|</span> <span class="n">a</span> <span class="o">:</span> <span class="n">pempty.</span><span class="o">{</span><span class="n">imax</span> <span class="mi">1</span> <span class="n">u</span><span class="o">}</span> <span class="bp">→</span> <span class="n">foo</span>
</code></pre></div>
<p>this succeeds iff you put an expression <code>v</code> for the <code>pempty</code> such that <code>v &lt;= u</code> is true</p>



<a name="272697672"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/breaking%20inductive/near/272697672" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/breaking.20inductive.html#272697672">(Feb 21 2022 at 14:49)</a>:</h4>
<p>The system given in my paper will validate <code>imax 1 u &lt;= u</code>, because it does case disjunction when it can't make progress on the inequality. Lean doesn't, it uses a known-incomplete set of rewrite rules to normalize universe expressions, so you can get some spuriously rejected examples like this</p>



<a name="272701181"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/breaking%20inductive/near/272701181" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonard Wiechmann <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/breaking.20inductive.html#272701181">(Feb 21 2022 at 15:17)</a>:</h4>
<p>here is something else i'm unsure about:<br>
why are only the universe levels of the constructor "arguments" validated and not also the "parameters"?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">foo</span> <span class="o">(</span><span class="n">X</span><span class="o">:</span> <span class="kt">Sort</span> <span class="mi">42</span><span class="o">):</span> <span class="kt">Sort</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="n">ctor</span><span class="o">:</span> <span class="n">foo</span>
<span class="c1">-- foo.ctor : Π {X : Type 41}, foo X</span>
</code></pre></div>
<p>the full <code>foo.ctor</code> also takes <code>X</code>, but <code>universe(X) &gt; 1</code>.<br>
i probably don't understand this, because i don't really understand where the <code>&lt;=</code> constraint for arguments comes from in the first place.<br>
is there a somewhat simple answer that's not "because things work out that way, and everything else would be limiting or inconsistent"? maybe some paper that discusses the rationale?</p>



<a name="272716301"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/breaking%20inductive/near/272716301" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/breaking.20inductive.html#272716301">(Feb 21 2022 at 17:27)</a>:</h4>
<p>Well, it would be inconsistent to have a small type containing an injective copy of a large type</p>



<a name="272716592"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/breaking%20inductive/near/272716592" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/breaking.20inductive.html#272716592">(Feb 21 2022 at 17:30)</a>:</h4>
<p>like</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">foo</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">ctor</span> <span class="o">:</span> <span class="n">set</span> <span class="kt">Type</span> <span class="bp">-&gt;</span> <span class="n">foo</span>
</code></pre></div>
<p>Intuitively, this is cantor's paradox, although it doesn't immediately follow. The correct paradox to cite is <a href="https://cs.brown.edu/courses/cs1951x/docs/logic/girard.html">Girard's paradox</a></p>



<a name="272716714"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/breaking%20inductive/near/272716714" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/breaking.20inductive.html#272716714">(Feb 21 2022 at 17:31)</a>:</h4>
<p>For parameters this isn't really what's happening. It's more like we have a construction of an inductive type which depends on some fixed parameters, i.e. a family of inductive constructions. These play the role of constants so you can't use them to pull any funny business</p>



<a name="272716841"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/breaking%20inductive/near/272716841" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/breaking.20inductive.html#272716841">(Feb 21 2022 at 17:32)</a>:</h4>
<p>In particular, <code>foo</code> is not injective with respect to its parameters. It took a discovered inconsistency in Agda to realize that this had to be the case, but it's pretty obvious if you look at your <code>foo</code> that it has to be noninjective</p>



<a name="272716911"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/breaking%20inductive/near/272716911" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/breaking.20inductive.html#272716911">(Feb 21 2022 at 17:33)</a>:</h4>
<p>You can't prove it in lean but it is consistent for <code>foo X = unit</code> for all values of X</p>



<a name="272800938"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/breaking%20inductive/near/272800938" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonard Wiechmann <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/breaking.20inductive.html#272800938">(Feb 22 2022 at 13:20)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113488-general/topic/breaking.20inductive/near/272716301">said</a>:</p>
<blockquote>
<p>Well, it would be inconsistent to have a small type containing an injective copy of a large type</p>
</blockquote>
<p>ok, this seems to make sense:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">Trojan</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">intro</span> <span class="o">(</span><span class="n">soldier</span><span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:</span> <span class="n">Trojan</span>

<span class="kd">def</span> <span class="n">extract</span><span class="o">:</span> <span class="n">Trojan</span> <span class="bp">-&gt;</span> <span class="kt">Type</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">t</span><span class="o">,</span> <span class="n">Trojan.rec</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">soldier</span><span class="o">,</span> <span class="n">soldier</span><span class="o">)</span> <span class="n">t</span>

<span class="c1">-- this is *effectively* `Type -&gt; nat`, but it's type is Type, which is paradoxical.</span>
<span class="kd">def</span> <span class="n">troy</span><span class="o">:</span> <span class="n">Trojan</span> <span class="bp">-&gt;</span> <span class="n">nat</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">t</span><span class="o">,</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">soldier</span><span class="o">,</span> <span class="bp">...</span><span class="o">)</span> <span class="o">(</span><span class="n">extract</span> <span class="n">t</span><span class="o">)</span>
</code></pre></div>



<a name="272801017"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/breaking%20inductive/near/272801017" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonard Wiechmann <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/breaking.20inductive.html#272801017">(Feb 22 2022 at 13:21)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113488-general/topic/breaking.20inductive/near/272716714">said</a>:</p>
<blockquote>
<p>For parameters this isn't really what's happening. It's more like we have a construction of an inductive type which depends on some fixed parameters, i.e. a family of inductive constructions. These play the role of constants so you can't use them to pull any funny business</p>
</blockquote>
<p>this seems to intuitively make sense, because the "callsite" also needs to know about the parameters (and thus their Sorts). so you can't do funny extraction business.</p>



<a name="272801469"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/breaking%20inductive/near/272801469" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonard Wiechmann <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/breaking.20inductive.html#272801469">(Feb 22 2022 at 13:24)</a>:</h4>
<p>the last 2, I don't really understand:<br>
1: what does <code>foo</code> is not injective wrt its parameters mean? is there a link to said agda inconsistency?<br>
2: what does <code>foo X = unit</code> mean? guessing this refers to my foo from above. <code>inductive foo (X: Sort 42) : unit</code> doesn't make sense, because unit is not a sort.</p>



<a name="272803353"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/breaking%20inductive/near/272803353" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/breaking.20inductive.html#272803353">(Feb 22 2022 at 13:39)</a>:</h4>
<p><span class="user-mention silent" data-user-id="456923">Leonard Wiechmann</span> <a href="#narrow/stream/113488-general/topic/breaking.20inductive/near/272801469">said</a>:</p>
<blockquote>
<p>what does <code>foo</code> is not injective wrt its parameters mean? is there a link to said agda inconsistency?</p>
</blockquote>
<p>Agda inconsistency: <a href="https://coq-club.inria.narkive.com/iDuSeltD/agda-with-the-excluded-middle-is-inconsistent">https://coq-club.inria.narkive.com/iDuSeltD/agda-with-the-excluded-middle-is-inconsistent</a><br>
Injectivity here is saying that <code>foo X = foo Y -&gt; X = Y</code>, i.e. <code>foo</code> is injective as a function on types</p>



<a name="272803477"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/breaking%20inductive/near/272803477" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/breaking.20inductive.html#272803477">(Feb 22 2022 at 13:40)</a>:</h4>
<p>This is not possible because there are too many possible values of <code>X : Sort 42</code> compared to the number of values of <code>foo X : Type</code>, i.e. it's essentially a cardinality constraint</p>



<a name="272803721"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/breaking%20inductive/near/272803721" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/breaking.20inductive.html#272803721">(Feb 22 2022 at 13:42)</a>:</h4>
<p>When I say <code>foo X = unit</code>, I mean that you could add the axiom <code>axiom foo_is_unit (X) : foo X = unit</code> and the resulting system would still be consistent. (You can already prove that <code>foo X ≃ unit</code> using the way it has been defined, but type equalities are almost never provable in lean. This non-injectivity example is a rare case where you can actually prove an equality of types</p>



<a name="273078328"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/breaking%20inductive/near/273078328" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonard Wiechmann <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/breaking.20inductive.html#273078328">(Feb 24 2022 at 11:45)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113488-general/topic/breaking.20inductive/near/272803721">said</a>:</p>
<blockquote>
<p>When I say <code>foo X = unit</code>, I mean that you could add the axiom <code>axiom foo_is_unit (X) : foo X = unit</code> and the resulting system would still be consistent. (You can already prove that <code>foo X ≃ unit</code> using the way it has been defined, but type equalities are almost never provable in lean. This non-injectivity example is a rare case where you can actually prove an equality of types</p>
</blockquote>
<p>oh, I see. because foo is basically unit, except with a parameter.</p>



<a name="273078352"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/breaking%20inductive/near/273078352" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonard Wiechmann <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/breaking.20inductive.html#273078352">(Feb 24 2022 at 11:45)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113488-general/topic/breaking.20inductive/near/272803353">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="456923">Leonard Wiechmann</span> <a href="#narrow/stream/113488-general/topic/breaking.20inductive/near/272801469">said</a>:</p>
<blockquote>
<p>what does <code>foo</code> is not injective wrt its parameters mean? is there a link to said agda inconsistency?</p>
</blockquote>
<p>Agda inconsistency: <a href="https://coq-club.inria.narkive.com/iDuSeltD/agda-with-the-excluded-middle-is-inconsistent">https://coq-club.inria.narkive.com/iDuSeltD/agda-with-the-excluded-middle-is-inconsistent</a><br>
Injectivity here is saying that <code>foo X = foo Y -&gt; X = Y</code>, i.e. <code>foo</code> is injective as a function on types</p>
</blockquote>
<p>ok, awesome, thanks! i'll check it out once i've got some time.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/Finding.20the.20correct.20order.20instance.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Finding.20the.20correct.20order.20instance.html">Finding the correct order instance</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="243581095"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Finding%20the%20correct%20order%20instance/near/243581095" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Finding.20the.20correct.20order.20instance.html#243581095">(Jun 22 2021 at 21:25)</a>:</h4>
<p>Here's a goal I'm encountering.</p>
<div class="codehilite" data-code-language="Haskell"><pre><span></span><code><span class="nf">α</span><span class="kt">:</span> <span class="kt">Type</span> <span class="n">u_1</span>
<span class="nf">_inst_1</span><span class="kt">:</span> <span class="n">decidable_eq</span> <span class="n">α</span>
<span class="nf">_inst_2</span><span class="kt">:</span> <span class="n">some_order_instance</span> <span class="n">α</span>
<span class="nf">a</span> <span class="n">c</span> <span class="n">x</span><span class="kt">:</span> <span class="n">α</span>
<span class="nf">hx</span><span class="kt">:</span> <span class="n">a</span> <span class="o">+</span> <span class="n">c</span> <span class="err">≤</span> <span class="n">x</span>
<span class="err">⊢</span> <span class="err">∃</span> <span class="p">(</span><span class="n">y</span> <span class="kt">:</span> <span class="n">α</span><span class="p">),</span> <span class="n">c</span> <span class="o">+</span> <span class="n">y</span> <span class="ow">=</span> <span class="n">x</span>
</code></pre></div>
<p>What should be <code>some_order_instance</code>? The rest of the proof requires at least <code>ordered_cancel_add_comm_monoid α</code>.</p>



<a name="243581511"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Finding%20the%20correct%20order%20instance/near/243581511" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Finding.20the.20correct.20order.20instance.html#243581511">(Jun 22 2021 at 21:29)</a>:</h4>
<p>Maybe <a href="https://leanprover-community.github.io/mathlib_docs/find/has_exists_add_of_le">docs#has_exists_add_of_le</a>?</p>



<a name="243581698"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Finding%20the%20correct%20order%20instance/near/243581698" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Finding.20the.20correct.20order.20instance.html#243581698">(Jun 22 2021 at 21:31)</a>:</h4>
<p>But then how do I prove <code>c ≤ x</code>? I don't know that <code>a + c ≤ c</code>.</p>



<a name="243581798"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Finding%20the%20correct%20order%20instance/near/243581798" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Finding.20the.20correct.20order.20instance.html#243581798">(Jun 22 2021 at 21:32)</a>:</h4>
<p>I think that + <code>add_comm_group</code> is enough</p>



<a name="243581868"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Finding%20the%20correct%20order%20instance/near/243581868" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Finding.20the.20correct.20order.20instance.html#243581868">(Jun 22 2021 at 21:33)</a>:</h4>
<p>Yeah but then it doesn't apply to ℕ... This is related to my <code>locally_finite_order</code> PR btw</p>



<a name="243582083"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Finding%20the%20correct%20order%20instance/near/243582083" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Finding.20the.20correct.20order.20instance.html#243582083">(Jun 22 2021 at 21:35)</a>:</h4>
<p>I guess <span class="user-mention" data-user-id="321459">@Damiano Testa</span> will either know the instance or tell me it doesn't exist.</p>



<a name="243582165"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Finding%20the%20correct%20order%20instance/near/243582165" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Finding.20the.20correct.20order.20instance.html#243582165">(Jun 22 2021 at 21:36)</a>:</h4>
<p>Ahah, isn't it related to the monus that I was talking about with Scott?</p>



<a name="243582172"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Finding%20the%20correct%20order%20instance/near/243582172" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Finding.20the.20correct.20order.20instance.html#243582172">(Jun 22 2021 at 21:36)</a>:</h4>
<p><code>exists_add_of_le</code> gives <code> ∃ z, a + c + z = x</code>, and a suitable obtain and add_comm makes your goal <code>∃ y, c + y = c + z + a</code>?</p>



<a name="243582214"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Finding%20the%20correct%20order%20instance/near/243582214" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Finding.20the.20correct.20order.20instance.html#243582214">(Jun 22 2021 at 21:37)</a>:</h4>
<p>Oh, of course <span aria-label="grinning" class="emoji emoji-1f600" role="img" title="grinning">:grinning:</span></p>



<a name="243582225"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Finding%20the%20correct%20order%20instance/near/243582225" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Finding.20the.20correct.20order.20instance.html#243582225">(Jun 22 2021 at 21:37)</a>:</h4>
<p>This is me after 12h of ECM talks.</p>



<a name="243582706"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Finding%20the%20correct%20order%20instance/near/243582706" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Finding.20the.20correct.20order.20instance.html#243582706">(Jun 22 2021 at 21:43)</a>:</h4>
<p>And indeed the next lemma on my list requires the <code>monus</code>...<br>
<code>lemma image_sub (a b c : α) (h : a ≤ c) : (Ico a b).image (λ x, x - c) = Ico (a - c) (b - c) :=</code></p>



<a name="243582793"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Finding%20the%20correct%20order%20instance/near/243582793" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Finding.20the.20correct.20order.20instance.html#243582793">(Jun 22 2021 at 21:44)</a>:</h4>
<p>aka <code>x ≤ y → y - x + x = y</code></p>



<a name="243583894"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Finding%20the%20correct%20order%20instance/near/243583894" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Finding.20the.20correct.20order.20instance.html#243583894">(Jun 22 2021 at 21:57)</a>:</h4>
<p><span class="user-mention" data-user-id="387244">@Yaël Dillies</span>, have you seen the series of lemmas about intervals which inspired <span class="user-mention" data-user-id="329425">@Peter Nelson</span> to define <a href="https://leanprover-community.github.io/mathlib_docs/find/exists_add_of_le">docs#exists_add_of_le</a>?  See <a href="https://leanprover-community.github.io/mathlib_docs/find/set.Icc_add_bij">docs#set.Icc_add_bij</a> and following.</p>



<a name="243601162"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Finding%20the%20correct%20order%20instance/near/243601162" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Finding.20the.20correct.20order.20instance.html#243601162">(Jun 23 2021 at 02:28)</a>:</h4>
<p>Yaël, I am late to this, but reduing the assumptions on <code>has_exists_mul/add_of_le</code> is on my <code>todo</code> list.  For this to be effective, it might also be useful to have a typeclass asserting that the unit of a binary operation is the bottom of an order relation.   Below is what I have in mind: the first part works with the current typeclasses, the second one is an attempt with the new ones.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.ordered_monoid</span>

<span class="kd">variable</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>

<span class="c">/-</span><span class="cm">  What is in this section should be available after the `ordered` refactor. -/</span>
<span class="kn">section</span>

<span class="kd">@[to_additive]</span> <span class="kd">lemma</span> <span class="n">le_mul_self'</span> <span class="o">[</span><span class="n">mul_one_class</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">preorder</span> <span class="n">α</span><span class="o">]</span>
  <span class="o">[</span><span class="n">covariant_class</span> <span class="n">α</span> <span class="n">α</span> <span class="o">(</span><span class="n">function.swap</span> <span class="o">(</span><span class="bp">*</span><span class="o">))</span> <span class="o">(</span><span class="bp">≤</span><span class="o">)]</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">b1</span> <span class="o">:</span> <span class="mi">1</span> <span class="bp">≤</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">a</span> <span class="o">:=</span>
<span class="k">calc</span>  <span class="n">a</span> <span class="bp">=</span> <span class="mi">1</span> <span class="bp">*</span> <span class="n">a</span> <span class="o">:</span> <span class="o">(</span><span class="n">one_mul</span> <span class="n">a</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span>
    <span class="bp">...</span> <span class="bp">≤</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">a</span> <span class="o">:</span> <span class="n">mul_le_mul_right'</span> <span class="n">b1</span> <span class="n">_</span>

<span class="kd">@[to_additive]</span> <span class="kd">lemma</span> <span class="n">yael_mul</span> <span class="o">[</span><span class="n">ordered_comm_monoid</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">has_exists_mul_of_le</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">a</span> <span class="n">c</span> <span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span>
  <span class="o">(</span><span class="n">a1</span> <span class="o">:</span> <span class="mi">1</span> <span class="bp">≤</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">hx</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">c</span> <span class="bp">≤</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">c</span> <span class="bp">*</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">x</span> <span class="o">:=</span>
<span class="k">suffices</span> <span class="n">h</span> <span class="o">:</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">c</span> <span class="bp">*</span> <span class="n">y</span><span class="o">,</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">simp_rw</span> <span class="n">eq_comm</span><span class="o">,</span> <span class="n">exact</span> <span class="n">h</span> <span class="o">},</span>
<span class="n">exists_mul_of_le</span> <span class="o">(</span><span class="n">trans</span> <span class="o">(</span><span class="n">le_mul_self'</span> <span class="n">a1</span><span class="o">)</span> <span class="n">hx</span><span class="o">)</span>

<span class="kd">end</span>

<span class="c">/-</span><span class="cm">  In the `new` namespace is something that I am thinking about for `has_exists_mul_of_le`. -/</span>
<span class="kn">namespace</span> <span class="n">new</span>
<span class="kd">variable</span> <span class="o">(</span><span class="n">α</span><span class="o">)</span>

<span class="sd">/--  `0` is a bottom element. -/</span>
<span class="kd">class</span> <span class="n">has_zero_le</span> <span class="o">[</span><span class="n">has_add</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">has_zero</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">has_le</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">zero_le</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">a</span><span class="o">)</span>

<span class="sd">/--  `1` is a bottom element. -/</span>
<span class="kd">class</span> <span class="n">has_one_le</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">has_one</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">has_le</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">one_le</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="mi">1</span> <span class="bp">≤</span> <span class="n">a</span><span class="o">)</span>

<span class="kn">attribute</span> <span class="o">[</span><span class="n">to_additive</span> <span class="n">has_zero_le</span><span class="o">]</span> <span class="n">has_one_le</span>

<span class="sd">/--  The `has_exists_add_of_le` typeclass with fewer assumptions. -/</span>
<span class="kd">class</span> <span class="n">has_exists_add_of_le'</span> <span class="o">[</span><span class="n">has_add</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">has_le</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">exists_add_of_le</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">},</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">c</span><span class="o">)</span>

<span class="sd">/--  The `has_exists_mul_of_le` typeclass with fewer assumptions. -/</span>
<span class="kd">class</span> <span class="n">has_exists_mul_of_le'</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">has_le</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">exists_mul_of_le</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">},</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">c</span><span class="o">)</span>

<span class="kn">attribute</span> <span class="o">[</span><span class="n">to_additive</span><span class="o">]</span> <span class="n">has_exists_mul_of_le'</span>

<span class="kd">variable</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span>

<span class="kd">@[to_additive]</span> <span class="kd">lemma</span> <span class="n">le_mul_self'</span> <span class="o">[</span><span class="n">mul_one_class</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">preorder</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">has_one_le</span> <span class="n">α</span><span class="o">]</span>
  <span class="o">[</span><span class="n">covariant_class</span> <span class="n">α</span> <span class="n">α</span> <span class="o">(</span><span class="n">function.swap</span> <span class="o">(</span><span class="bp">*</span><span class="o">))</span> <span class="o">(</span><span class="bp">≤</span><span class="o">)]</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">a</span> <span class="o">:=</span>
<span class="k">calc</span>  <span class="n">a</span> <span class="bp">=</span> <span class="mi">1</span> <span class="bp">*</span> <span class="n">a</span> <span class="o">:</span> <span class="o">(</span><span class="n">one_mul</span> <span class="n">a</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span>
    <span class="bp">...</span> <span class="bp">≤</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">a</span> <span class="o">:</span> <span class="n">mul_le_mul_right'</span> <span class="o">(</span><span class="n">has_one_le.one_le</span> <span class="n">b</span><span class="o">)</span> <span class="n">_</span>

<span class="kd">@[to_additive]</span> <span class="kd">lemma</span> <span class="n">yael_mul</span> <span class="o">[</span><span class="n">mul_one_class</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">preorder</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">has_one_le</span> <span class="n">α</span><span class="o">]</span>
  <span class="o">[</span><span class="n">covariant_class</span> <span class="n">α</span> <span class="n">α</span> <span class="o">(</span><span class="n">function.swap</span> <span class="o">(</span><span class="bp">*</span><span class="o">))</span> <span class="o">(</span><span class="bp">≤</span><span class="o">)]</span> <span class="o">[</span><span class="n">has_exists_mul_of_le'</span> <span class="n">α</span><span class="o">]</span>
  <span class="o">{</span><span class="n">a</span> <span class="n">c</span> <span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">hx</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">c</span> <span class="bp">≤</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">c</span> <span class="bp">*</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">x</span> <span class="o">:=</span>
<span class="k">suffices</span> <span class="n">h</span> <span class="o">:</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">c</span> <span class="bp">*</span> <span class="n">y</span><span class="o">,</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">simp_rw</span> <span class="n">eq_comm</span><span class="o">,</span> <span class="n">exact</span> <span class="n">h</span> <span class="o">},</span>
<span class="n">has_exists_mul_of_le'.exists_mul_of_le</span> <span class="o">(</span><span class="n">trans</span> <span class="o">(</span><span class="n">le_mul_self'</span> <span class="n">c</span> <span class="n">a</span><span class="o">)</span> <span class="n">hx</span><span class="o">)</span>

<span class="kd">end</span> <span class="n">new</span>
</code></pre></div>



<a name="243614195"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Finding%20the%20correct%20order%20instance/near/243614195" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Finding.20the.20correct.20order.20instance.html#243614195">(Jun 23 2021 at 07:11)</a>:</h4>
<p>I can't help but feel relaxing these to <code>has_le</code> is asking for trouble</p>



<a name="243614439"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Finding%20the%20correct%20order%20instance/near/243614439" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Finding.20the.20correct.20order.20instance.html#243614439">(Jun 23 2021 at 07:14)</a>:</h4>
<p>The obvious phrasing to me for <code>has_zero_le</code> uses <a href="https://leanprover-community.github.io/mathlib_docs/find/order_bot">docs#order_bot</a></p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">zero_eq_bot</span> <span class="o">(</span><span class="n">α</span><span class="o">)</span> <span class="o">[</span><span class="n">order_bot</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">has_zero</span> <span class="n">α</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">eq</span> <span class="o">:</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">⊥</span><span class="o">)</span>
</code></pre></div>



<a name="243634100"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Finding%20the%20correct%20order%20instance/near/243634100" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Finding.20the.20correct.20order.20instance.html#243634100">(Jun 23 2021 at 10:49)</a>:</h4>
<p>Fair enough and, admittedly, I do not really have applications for this in the case in which the relation isn't, say, transitive.  Thus, the extra assumptions are always satisfied in my use cases.  In any case, I am not planning on doing this any time soon: I am already busy enough with the <code>order</code> refactor and I consider this as a plan for after it is done</p>
<p>If someone else wants to think about this, feel free to do so!</p>



<a name="243636985"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Finding%20the%20correct%20order%20instance/near/243636985" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Finding.20the.20correct.20order.20instance.html#243636985">(Jun 23 2021 at 11:22)</a>:</h4>
<p>Damiano, do you think there's a way to have an order class that would state <code>a &lt; b ↔ a + 1 ≤ b</code>? That would allow me to generalise this lemma (and the <code>Icc</code>, <code>Ioc</code>, <code>Ioo</code> variants).<br>
<code>lemma card_Ico (n m : ℕ) : (Ico n m).card = m - n :=</code> to <code>ℤ</code>, <code>ℕ+</code> and <code>fin n</code>.</p>



<a name="243637109"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Finding%20the%20correct%20order%20instance/near/243637109" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Finding.20the.20correct.20order.20instance.html#243637109">(Jun 23 2021 at 11:23)</a>:</h4>
<p>The <code>ℤ</code> lemma for it is called <a href="https://leanprover-
community.github.io/mathlib_docs/data/int/basic.html#int.lt_add_one_iff"><code>int.lt_add_one_iff</code></a></p>



<a name="243640291"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Finding%20the%20correct%20order%20instance/near/243640291" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Finding.20the.20correct.20order.20instance.html#243640291">(Jun 23 2021 at 11:57)</a>:</h4>
<p><span class="user-mention" data-user-id="238446">@Anne Baanen</span> had a <code>has_enum</code> refactor or similar to handle that</p>



<a name="243643512"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Finding%20the%20correct%20order%20instance/near/243643512" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Finding.20the.20correct.20order.20instance.html#243643512">(Jun 23 2021 at 12:27)</a>:</h4>
<p>Ah yeah. What I need is <code>has_enum</code> + <code>archimedean</code>.</p>



<a name="243644546"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Finding%20the%20correct%20order%20instance/near/243644546" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Finding.20the.20correct.20order.20instance.html#243644546">(Jun 23 2021 at 12:36)</a>:</h4>
<p>How is that going, Anne?</p>



<a name="243653535"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Finding%20the%20correct%20order%20instance/near/243653535" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Finding.20the.20correct.20order.20instance.html#243653535">(Jun 23 2021 at 13:45)</a>:</h4>
<p>I have an old version in <a href="https://github.com/leanprover-community/mathlib/tree/fin_range">branch#fin_range</a>, but I gave up my original attempt because it was too much work to replace the built-in <code>list.range</code>/<code>multiset.range</code>/<code>finset.range</code> outright (and I found another way to do what I "really" wanted without <code>has_enum</code>). The main action is in this file, containing a syntactic <code>has_enum</code> class (with only the definition of <code>list.Ico</code>) and a <code>lawful_enum</code> class with the specification: <a href="https://github.com/leanprover-community/mathlib/blob/fin_range/src/data/list/enum.lean">https://github.com/leanprover-community/mathlib/blob/fin_range/src/data/list/enum.lean</a></p>



<a name="243654188"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Finding%20the%20correct%20order%20instance/near/243654188" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Finding.20the.20correct.20order.20instance.html#243654188">(Jun 23 2021 at 13:50)</a>:</h4>
<p>I did not include a lemma on  <code>+ 1</code> or require the existence of a successor function, since <code>fin 0</code> does not have a <code>1</code> but it can still be enumerated (namely, with the empty list), and the successor function cannot be injective and strictly larger on finite types.</p>



<a name="243654285"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Finding%20the%20correct%20order%20instance/near/243654285" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Finding.20the.20correct.20order.20instance.html#243654285">(Jun 23 2021 at 13:51)</a>:</h4>
<p>Oh but this is very much what I'm doing now. I thought <code>has_enum</code> would mean that every element is either top or covered by another one, and that's a strictly weaker property than <code>locally_finite_order</code>.</p>



<a name="243654444"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Finding%20the%20correct%20order%20instance/near/243654444" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Finding.20the.20correct.20order.20instance.html#243654444">(Jun 23 2021 at 13:52)</a>:</h4>
<p>What was it that you "really" wanted when you did that?</p>



<a name="243654462"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Finding%20the%20correct%20order%20instance/near/243654462" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Finding.20the.20correct.20order.20instance.html#243654462">(Jun 23 2021 at 13:52)</a>:</h4>
<p>Please re-use as much as you need!</p>



<a name="243654971"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Finding%20the%20correct%20order%20instance/near/243654971" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Finding.20the.20correct.20order.20instance.html#243654971">(Jun 23 2021 at 13:55)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/113488-general/topic/Finding.20the.20correct.20order.20instance/near/243654444">said</a>:</p>
<blockquote>
<p>What was it that you "really" wanted when you did that?</p>
</blockquote>
<p>How to do the row manipulations in <a href="https://leanprover-community.github.io/mathlib_docs/find/det_vandermonde/src">src#det_vandermonde</a> (which in the end were easier to do with <code>finset.range</code> of natural numbers)</p>



<a name="243655795"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Finding%20the%20correct%20order%20instance/near/243655795" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Finding.20the.20correct.20order.20instance.html#243655795">(Jun 23 2021 at 14:01)</a>:</h4>
<p>What I now want here is to say that no element is in between the coercion from <code>ℕ</code> (or <code>ℤ</code>) to <code>α</code>. That's again something different and I think something like</p>
<div class="codehilite" data-code-language="Haskell"><pre><span></span><code><span class="o">@</span><span class="p">[</span><span class="kr">class</span><span class="p">]</span> <span class="n">structure</span> <span class="n">has_lt_iff_add_one_le</span> <span class="p">(</span><span class="n">α</span> <span class="kt">:</span> <span class="kt">Type</span><span class="o">*</span><span class="p">)</span> <span class="p">[</span><span class="n">ordered_semiring</span> <span class="n">α</span><span class="p">]</span> <span class="kt">:</span> <span class="kt">Prop</span> <span class="kt">:=</span>
<span class="p">(</span><span class="n">lt_iff_add_one_le</span> <span class="kt">:</span> <span class="err">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="kt">:</span> <span class="n">α</span><span class="p">,</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span> <span class="err">↔</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">1</span> <span class="err">≤</span> <span class="n">b</span><span class="p">)</span>
</code></pre></div>
<p>would be worth having.</p>



<a name="243656672"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Finding%20the%20correct%20order%20instance/near/243656672" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Finding.20the.20correct.20order.20instance.html#243656672">(Jun 23 2021 at 14:07)</a>:</h4>
<p>(this isn't Discord, you don't need to mark your lean as haskell!)</p>



<a name="243658872"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Finding%20the%20correct%20order%20instance/near/243658872" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Finding.20the.20correct.20order.20instance.html#243658872">(Jun 23 2021 at 14:22)</a>:</h4>
<p>Whoops! Yeah</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
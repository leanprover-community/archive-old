---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/Incomplete.20pattern.20match.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Incomplete.20pattern.20match.html">Incomplete pattern match</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="279786416"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Incomplete%20pattern%20match/near/279786416" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Johnson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Incomplete.20pattern.20match.html#279786416">(Apr 22 2022 at 06:58)</a>:</h4>
<p>There are three most popular ways to deal with partial functions in Lean.</p>
<p>The first way is to require a proof of the membership of the function's domain as a separate argument. The problem is that we need a proof whenever we want to call the function, so we also need proofs in theorem statements. If there are multiple partial functions, the theorem statement becomes hard to state and comprehend.</p>
<p>The second way is to use <code>option</code> type. It introduces unnecessary congitive overhead and forces us to work with option monad even if we want to prove something totally unrelated to the <code>option</code> type.</p>
<p>The third way is to return a junk value. This way turned out to be the most useful and easiest to work with. However, the problem is that it allows us to prove things that are false in real math. For example, <code>nat.pred</code> is implemented such that it returns <code>0</code> for <code>0</code>, so we can prove that the predecessor of <code>0</code> is <code>0</code>, which is false. Also, <code>nat.sub</code> is implemented such that it returns <code>0</code> if the result would be negative, so we can prove that <code>5 - 7 = 0</code>, which doesn't make sense.</p>
<p>In Isabelle/HOL, there is an axiomatically defined constant <code>undefined</code> which returns a "random" value of a given type (all types are inhabited). In Lean, we can implement <code>undefined</code> using <code>nonempty.some</code>, but it still allows us to prove nonsensical things, because <code>nonempty.some</code> always returns the same value for the same type, so it may cancel out if it's used in some other definition.</p>
<p>It would be nice if we could do something like this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">pred</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">a</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">a</span>

<span class="kd">def</span> <span class="n">sub</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span>
<span class="bp">|</span> <span class="n">a</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">a</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">a</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sub</span> <span class="n">a</span> <span class="n">b</span>
</code></pre></div>
<p>The equation compiler would basically do the following, except it would make the definitions computable:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">pred</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">refine</span> <span class="o">(</span><span class="n">_</span> <span class="o">:</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">),</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">f</span> <span class="n">a.succ</span> <span class="bp">=</span> <span class="n">a</span><span class="o">)</span><span class="bp">.</span><span class="n">some</span><span class="o">,</span>
  <span class="n">use</span> <span class="bp">λ</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="bp">@</span><span class="n">nat.rec</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">ℕ</span><span class="o">)</span> <span class="mi">0</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span> <span class="n">_</span><span class="o">,</span> <span class="n">a</span><span class="o">)</span> <span class="n">a</span><span class="o">,</span>
  <span class="n">simp</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">pred_succ</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="n">pred</span> <span class="n">a.succ</span> <span class="bp">=</span> <span class="n">a</span> <span class="o">:=</span>
<span class="n">pred._proof_1.some_spec</span> <span class="n">_</span>

<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">sub</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">refine</span> <span class="o">(</span><span class="n">_</span> <span class="o">:</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">),</span>
    <span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">f</span> <span class="n">a</span> <span class="mi">0</span> <span class="bp">=</span> <span class="n">a</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">f</span> <span class="n">a.succ</span> <span class="n">b.succ</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">a</span> <span class="n">b</span><span class="o">))</span><span class="bp">.</span><span class="n">some</span><span class="o">,</span>
  <span class="n">use</span> <span class="bp">λ</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="bp">@</span><span class="n">nat.rec</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">ℕ</span><span class="o">)</span> <span class="n">a</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">pred</span><span class="o">)</span> <span class="n">b</span><span class="o">,</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rintro</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span>
    <span class="n">change</span> <span class="n">pred</span> <span class="n">_</span> <span class="bp">=</span> <span class="n">_</span><span class="o">,</span>
    <span class="n">induction</span> <span class="n">b</span> <span class="k">with</span> <span class="n">b</span> <span class="n">ih</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">pred_succ</span><span class="o">]</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">change</span> <span class="n">pred</span> <span class="o">(</span><span class="n">pred</span> <span class="n">_</span><span class="o">)</span> <span class="bp">=</span> <span class="n">_</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">ih</span> <span class="o">}},</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">sub_zero'</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="n">sub</span> <span class="n">a</span> <span class="mi">0</span> <span class="bp">=</span> <span class="n">a</span> <span class="o">:=</span>
<span class="n">sub._proof_1.some_spec.1</span> <span class="n">_</span>

<span class="kd">lemma</span> <span class="n">sub_succ'</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="n">sub</span> <span class="n">a.succ</span> <span class="n">b.succ</span> <span class="bp">=</span> <span class="n">sub</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:=</span>
<span class="n">sub._proof_1.some_spec.2</span> <span class="n">_</span> <span class="n">_</span>
</code></pre></div>
<p>So, we can't prove anything about <code>pred 0</code>, just like we can't prove anything about <code>5 - 7</code><br>
We can't even prove that <code>1 - 2</code> is equal to <code>2 - 3</code></p>
<p>I guess it will never be implemented in Lean 3, but are there any plans to have something like this in Lean 4? The key point is to produce computable definitions.</p>



<a name="279787872"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Incomplete%20pattern%20match/near/279787872" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Incomplete.20pattern.20match.html#279787872">(Apr 22 2022 at 07:20)</a>:</h4>
<p>This is not intended as an answer to your question, but as my way of dealing with the junk values.  I have been <em>much</em> happier with nat-subtraction when I started parsing it in my mind as <code>max 0 ("real subtraction")</code>.  Thus, what you prove is correct, it is just that the symbol <code>lean.-</code> means something different than <code>maths.-</code>.</p>



<a name="279788093"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Incomplete%20pattern%20match/near/279788093" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Incomplete.20pattern.20match.html#279788093">(Apr 22 2022 at 07:23)</a>:</h4>
<p>Once I made peace with this, I started even enjoying the fact that if <code>f</code> is a polynomial, then <code>f.derivative.nat_degree ≤ f.nat_degree - 1</code>, with no extra assumptions!  Thus, <code>lean.-</code> is goofy, but has ways of surprising you with clean statements.</p>



<a name="279788973"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Incomplete%20pattern%20match/near/279788973" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Incomplete.20pattern.20match.html#279788973">(Apr 22 2022 at 07:35)</a>:</h4>
<p>In particular, our goofy nat subtraction has a lot of desirable properties. The main is probably that it is adjoint to addition, namely <code>a - b ≤ c ↔ a ≤ b + c</code> (<a href="https://leanprover-community.github.io/mathlib_docs/find/tsub_le_iff_left">docs#tsub_le_iff_left</a>). And many other "nonsensical" mathlib definitions are like this.</p>



<a name="279789009"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Incomplete%20pattern%20match/near/279789009" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Incomplete.20pattern.20match.html#279789009">(Apr 22 2022 at 07:35)</a>:</h4>
<blockquote>
<p>In Isabelle/HOL, there is an axiomatically defined constant <code>undefined</code> which returns a "random" value of a given type (all types are inhabited)</p>
</blockquote>
<p>In Lean too, it's called <code>undefined</code>/<code>sorry</code>.</p>



<a name="279789344"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Incomplete%20pattern%20match/near/279789344" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Johnson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Incomplete.20pattern.20match.html#279789344">(Apr 22 2022 at 07:39)</a>:</h4>
<p><span class="user-mention silent" data-user-id="387244">Yaël Dillies</span> <a href="#narrow/stream/113488-general/topic/Incomplete.20pattern.20match/near/279789009">said</a>:</p>
<blockquote>
<p>In Lean too, it's called <code>undefined</code>/<code>sorry</code>.</p>
</blockquote>
<p>That's incorrect. In Lean, <code>sorry</code> is a way of cheating - it allows you to prove false (artificially inhabit an empty type). In Isabelle/HOL, <code>undefined</code> is used in real proofs for junk values and you can't derive <code>false</code> from it (implementation bugs aside).</p>



<a name="279789463"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Incomplete%20pattern%20match/near/279789463" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Incomplete.20pattern.20match.html#279789463">(Apr 22 2022 at 07:41)</a>:</h4>
<p>So what does <code>undefined : false</code> mean?</p>



<a name="279789570"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Incomplete%20pattern%20match/near/279789570" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Johnson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Incomplete.20pattern.20match.html#279789570">(Apr 22 2022 at 07:42)</a>:</h4>
<p>It means a syntax error. Isabelle is not a dependently-typed language.</p>



<a name="279809390"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Incomplete%20pattern%20match/near/279809390" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Incomplete.20pattern.20match.html#279809390">(Apr 22 2022 at 11:17)</a>:</h4>
<p>Here's a Lean 4 way to almost do the right thing (it's not quite right because for example <code>rfl : sub 0 1 = sub 0 2</code>).</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">constant</span> <span class="n">pred_undefined</span> <span class="o">:</span> <span class="n">Nat</span>

<span class="kd">def</span> <span class="n">pred</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="n">Nat</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="bp">=&gt;</span> <span class="n">pred_undefined</span>
<span class="bp">|</span> <span class="n">a</span><span class="bp">+</span><span class="mi">1</span> <span class="bp">=&gt;</span> <span class="n">a</span>

<span class="kd">constant</span> <span class="n">sub_undefined</span> <span class="o">:</span> <span class="n">Nat</span>

<span class="kd">def</span> <span class="n">sub</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="n">Nat</span>
<span class="bp">|</span> <span class="mi">0</span><span class="o">,</span> <span class="n">b</span><span class="bp">+</span><span class="mi">1</span> <span class="bp">=&gt;</span> <span class="n">sub_undefined</span>
<span class="bp">|</span> <span class="n">a</span><span class="o">,</span> <span class="mi">0</span> <span class="bp">=&gt;</span> <span class="n">a</span>
<span class="bp">|</span> <span class="n">a</span><span class="bp">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">b</span><span class="bp">+</span><span class="mi">1</span> <span class="bp">=&gt;</span> <span class="n">sub</span> <span class="n">a</span> <span class="n">b</span>

<span class="k">#eval</span> <span class="n">pred</span> <span class="mi">0</span>
<span class="c1">-- 0</span>
<span class="k">#eval</span> <span class="n">sub</span> <span class="mi">0</span> <span class="mi">1</span>
<span class="c1">-- 0</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">pred</span> <span class="mi">0</span> <span class="bp">=</span> <span class="n">sub</span> <span class="mi">0</span> <span class="mi">1</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">pred</span><span class="o">,</span> <span class="n">sub</span><span class="o">]</span>
  <span class="c1">-- ⊢ pred_undefined = sub_undefined</span>
  <span class="n">rfl</span>
  <span class="c">/-</span><span class="cm"></span>
<span class="cm">  tactic 'rfl' failed, equality lhs</span>
<span class="cm">    pred_undefined</span>
<span class="cm">  is not definitionally equal to rhs</span>
<span class="cm">    sub_undefined</span>
<span class="cm">  ⊢ pred_undefined = sub_undefined</span>
<span class="cm">  -/</span>
</code></pre></div>
<p>Note that <code>constant</code> requires the type have an <code>Inhabited</code> instance, and it's not causing the definitions to depend on any additional axioms.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#print</span> <span class="kd">axioms</span> <span class="n">sub</span>
<span class="c1">-- 'sub' does not depend on any axioms</span>
</code></pre></div>



<a name="279809690"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Incomplete%20pattern%20match/near/279809690" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Incomplete.20pattern.20match.html#279809690">(Apr 22 2022 at 11:20)</a>:</h4>
<p>After writing that, it occurred to me that you can do the same sort of implementation in Lean 3, but using <code>irreducible</code> definitions instead of constants.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[irreducible]</span> <span class="kd">def</span> <span class="n">pred_undefined</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="mi">0</span>

<span class="kd">def</span> <span class="n">pred</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">pred_undefined</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">a</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">a</span>

<span class="kd">@[irreducible]</span> <span class="kd">def</span> <span class="n">sub_undefined</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="mi">0</span>

<span class="kd">def</span> <span class="n">sub</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">(</span><span class="n">b</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sub_undefined</span>
<span class="bp">|</span> <span class="n">a</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">a</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">a</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sub</span> <span class="n">a</span> <span class="n">b</span>

<span class="k">#eval</span> <span class="n">pred</span> <span class="mi">0</span>
<span class="c1">-- 0</span>
<span class="k">#eval</span> <span class="n">sub</span> <span class="mi">0</span> <span class="mi">1</span>
<span class="c1">-- 0</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">pred</span> <span class="mi">0</span> <span class="bp">=</span> <span class="n">sub</span> <span class="mi">0</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">pred</span><span class="o">,</span> <span class="n">sub</span><span class="o">],</span>
  <span class="c1">-- ⊢ pred_undefined = sub_undefined</span>
  <span class="n">refl</span><span class="o">,</span>
  <span class="c">/-</span><span class="cm"></span>
<span class="cm">  invalid apply tactic, failed to unify</span>
<span class="cm">    pred_undefined = sub_undefined</span>
<span class="cm">  with</span>
<span class="cm">    ?m_2 = ?m_2</span>
<span class="cm">  state:</span>
<span class="cm">  ⊢ pred_undefined = sub_undefined</span>
<span class="cm">  -/</span>
<span class="kd">end</span>
</code></pre></div>



<a name="279810279"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Incomplete%20pattern%20match/near/279810279" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Incomplete.20pattern.20match.html#279810279">(Apr 22 2022 at 11:26)</a>:</h4>
<p>Here's one that goes a little farther by making there be more undefined values. </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[irreducible]</span> <span class="kd">def</span> <span class="n">sub_undefined</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="mi">0</span>

<span class="kd">def</span> <span class="n">sub</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">(</span><span class="n">b</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sub_undefined</span> <span class="n">b</span>
<span class="bp">|</span> <span class="n">a</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">a</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">a</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sub</span> <span class="n">a</span> <span class="n">b</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">sub</span> <span class="mi">0</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">sub</span> <span class="mi">0</span> <span class="mi">2</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">sub</span><span class="o">],</span>
  <span class="c1">-- ⊢ sub_undefined 0 = sub_undefined 1</span>
  <span class="n">refl</span><span class="o">,</span>
  <span class="c">/-</span><span class="cm"></span>
<span class="cm">  invalid apply tactic, failed to unify</span>
<span class="cm">    sub_undefined 0 = sub_undefined 1</span>
<span class="cm">  with</span>
<span class="cm">    ?m_2 = ?m_2</span>
<span class="cm">  -/</span>
<span class="kd">end</span>
</code></pre></div>



<a name="279810499"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Incomplete%20pattern%20match/near/279810499" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Incomplete.20pattern.20match.html#279810499">(Apr 22 2022 at 11:29)</a>:</h4>
<p>Though you can do</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="n">sub</span> <span class="mi">0</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">sub</span> <span class="mi">0</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">rfl</span>
</code></pre></div>
<p>Would that be provable in Isabelle/HOL?</p>



<a name="279811107"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Incomplete%20pattern%20match/near/279811107" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Incomplete.20pattern.20match.html#279811107">(Apr 22 2022 at 11:36)</a>:</h4>
<p>Your <code>sub_undefined</code> is interesting, because I think you can prove <code>1 - 2 = 2 - 3</code> (edit: without cheating like kevin)</p>



<a name="279811115"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Incomplete%20pattern%20match/near/279811115" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Incomplete.20pattern.20match.html#279811115">(Apr 22 2022 at 11:36)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[irreducible]</span> <span class="kd">def</span> <span class="n">sub_undefined</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="mi">0</span>

<span class="kd">def</span> <span class="n">sub</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">(</span><span class="n">b</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sub_undefined</span> <span class="n">b</span>
<span class="bp">|</span> <span class="n">a</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">a</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">a</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sub</span> <span class="n">a</span> <span class="n">b</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">sub</span> <span class="mi">0</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">sub</span> <span class="mi">0</span> <span class="mi">2</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">sub</span><span class="o">],</span>
  <span class="n">delta</span> <span class="n">sub_undefined</span><span class="o">,</span>
  <span class="n">refl</span><span class="o">,</span> <span class="c1">-- muhahaha</span>
<span class="kd">end</span>
</code></pre></div>



<a name="279811159"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Incomplete%20pattern%20match/near/279811159" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Incomplete.20pattern.20match.html#279811159">(Apr 22 2022 at 11:36)</a>:</h4>
<p>I think you'll find that if it compiles then it's not cheating, by definition!</p>



<a name="279811319"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Incomplete%20pattern%20match/near/279811319" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Incomplete.20pattern.20match.html#279811319">(Apr 22 2022 at 11:38)</a>:</h4>
<p><span class="user-mention silent" data-user-id="456794">Patrick Johnson</span> <a href="#narrow/stream/113488-general/topic/Incomplete.20pattern.20match/near/279786416">said</a>:</p>
<blockquote>
<p>In Isabelle/HOL, there is an axiomatically defined constant <code>undefined</code> which returns a "random" value of a given type (all types are inhabited). In Lean, we can implement <code>undefined</code> using <code>nonempty.some</code>, but it still allows us to prove nonsensical things, because <code>nonempty.some</code> always returns the same value for the same type, so it may cancel out if it's used in some other definition.</p>
</blockquote>
<p>I'm not familiar with Isabelle/HOL, but when trying to learn more about <code>undefined</code>, it looks like <code>undefined = undefined</code> for a given type. If that's true, that seems to mean it has the same properties as <code>nonempty.some</code>.</p>



<a name="279811719"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Incomplete%20pattern%20match/near/279811719" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Incomplete.20pattern.20match.html#279811719">(Apr 22 2022 at 11:42)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> I forgot that <code>irreducible</code> only applies to the elaborator! Oh well. I think the Lean 4 version is safe from anything that (certainly you can't use <code>delta</code> on a <code>constant</code>).</p>



<a name="279811757"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Incomplete%20pattern%20match/near/279811757" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Incomplete.20pattern.20match.html#279811757">(Apr 22 2022 at 11:43)</a>:</h4>
<p>In Isabelle can you prove <code>0 - 1 = 0 - 2</code>?</p>



<a name="279811880"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Incomplete%20pattern%20match/near/279811880" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Incomplete.20pattern.20match.html#279811880">(Apr 22 2022 at 11:44)</a>:</h4>
<p>Oh, I guess you said you can't</p>



<a name="279812027"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Incomplete%20pattern%20match/near/279812027" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Incomplete.20pattern.20match.html#279812027">(Apr 22 2022 at 11:46)</a>:</h4>
<p>I think the semantics of this kind of thing get tricky. Let's say <code>sub</code> uses <code>undefined</code> in the "garbage" case. Then I copy and paste the definition of <code>sub</code> to <code>sub2</code>. Does <code>sub 0 1 = sub2 0 1</code>?</p>



<a name="279820610"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Incomplete%20pattern%20match/near/279820610" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Incomplete.20pattern.20match.html#279820610">(Apr 22 2022 at 13:03)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/113488-general/topic/Incomplete.20pattern.20match/near/279811757">said</a>:</p>
<blockquote>
<p>In Isabelle can you prove <code>0 - 1 = 0 - 2</code>?</p>
</blockquote>
<p>It looks like it depends on how you define the function.</p>
<p>If you do</p>
<div class="codehilite" data-code-language="Isabelle"><pre><span></span><code><span class="k">fun</span> <span class="n">sub</span> <span class="o">::</span> <span class="s">"nat ⇒ nat =&gt; nat"</span>
<span class="kp">where</span>
  <span class="s">"sub a b = (case b of 0 ⇒ a | Suc b' =&gt; case sub a b' of Suc k ⇒ k)"</span>
</code></pre></div>
<p>then the <code>undefined</code> jams up the <code>case</code> (and I, who installed Isabelle only about an hour ago, couldn't tell whether <code>case undefined of ...</code> could simplify to <code>undefined</code> or not).</p>
<div class="codehilite" data-code-language="Isabelle"><pre><span></span><code><span class="kn">lemma</span> <span class="n">foo4</span> <span class="o">:</span> <span class="s">"sub 0 1 = sub 0 2"</span>
  <span class="k">by</span> <span class="o">(</span><span class="n">simp_all</span> <span class="n">add</span><span class="o">:</span> <span class="n">sub_def</span><span class="o">)</span>
  <span class="c">(* fails. goal: undefined = (case undefined of Suc k ⇒ k) *)</span>
</code></pre></div>
<p>If instead we define subtraction like</p>
<div class="codehilite" data-code-language="Isabelle"><pre><span></span><code><span class="k">fun</span> <span class="n">sub2</span> <span class="o">::</span> <span class="s">"nat ⇒ nat =&gt; nat"</span>
<span class="kp">where</span>
  <span class="s">"sub2 a 0 = a"</span>
<span class="o">|</span> <span class="s">"sub2 a (Suc b) = (case a of Suc a' ⇒ sub2 a' b)"</span>
</code></pre></div>
<p>then you can prove <code>0 - 1 = 0 - 2</code> since it simplifies to <code>undefined = undefined</code>, which does end up being true in Isabelle.</p>
<div class="codehilite" data-code-language="Isabelle"><pre><span></span><code><span class="kn">lemma</span> <span class="n">foo24</span> <span class="o">:</span> <span class="s">"sub2 0 1 = sub2 0 (Suc 1)"</span>
  <span class="k">by</span> <span class="o">(</span><span class="n">simp_all</span> <span class="n">add</span><span class="o">:</span> <span class="n">sub_def</span><span class="o">)</span>

<span class="kn">lemma</span> <span class="n">foo1</span><span class="o">:</span> <span class="s">"(undefined::nat) = undefined"</span>
  <span class="k">by</span> <span class="n">simp_all</span>
</code></pre></div>
<p>With both definitions you can't prove <code>0 - 1 = 0</code>.</p>
<div class="codehilite" data-code-language="Isabelle"><pre><span></span><code><span class="kn">lemma</span> <span class="n">foo23</span><span class="o">:</span> <span class="s">"sub2 0 1 = 0"</span>
  <span class="k">by</span> <span class="o">(</span><span class="n">simp_all</span> <span class="n">add</span><span class="o">:</span> <span class="n">sub_def</span><span class="o">)</span>
  <span class="c">(* fails. goal: undefined = 0 *)</span>
</code></pre></div>
<div class="spoiler-block"><div class="spoiler-header">
<p>Isabelle code</p>
</div><div class="spoiler-content" aria-hidden="true">
<div class="codehilite" data-code-language="Isabelle"><pre><span></span><code><span class="k">theory</span> <span class="n">Scratch</span>
  <span class="kp">imports</span> <span class="n">Main</span>
<span class="k">begin</span>

<span class="kn">lemma</span> <span class="n">foo1</span><span class="o">:</span> <span class="s">"(undefined::nat) = undefined"</span>
  <span class="k">by</span> <span class="n">simp_all</span>

<span class="k">fun</span> <span class="n">sub</span> <span class="o">::</span> <span class="s">"nat ⇒ nat =&gt; nat"</span>
<span class="kp">where</span>
  <span class="s">"sub a b = (case b of 0 ⇒ a | Suc b' =&gt; case sub a b' of Suc k ⇒ k)"</span>

<span class="kn">lemma</span> <span class="n">foo2</span><span class="o">:</span> <span class="s">"sub 0 0 = 0"</span>
  <span class="k">by</span> <span class="o">(</span><span class="n">simp_all</span> <span class="n">add</span><span class="o">:</span> <span class="n">sub_def</span><span class="o">)</span>

<span class="kn">lemma</span> <span class="n">foo3</span><span class="o">:</span> <span class="s">"sub 0 1 = 0"</span>
  <span class="k">by</span> <span class="o">(</span><span class="n">simp_all</span> <span class="n">add</span><span class="o">:</span> <span class="n">sub_def</span><span class="o">)</span>
  <span class="c">(* fails: undefined = 0 *)</span>

<span class="kn">lemma</span> <span class="n">foo4</span> <span class="o">:</span> <span class="s">"sub 0 1 = sub 0 2"</span>
  <span class="k">by</span> <span class="o">(</span><span class="n">simp_all</span> <span class="n">add</span><span class="o">:</span> <span class="n">sub_def</span><span class="o">)</span>
  <span class="c">(* fails:  undefined = (case undefined of Suc k ⇒ k) *)</span>

<span class="k">fun</span> <span class="n">sub2</span> <span class="o">::</span> <span class="s">"nat ⇒ nat =&gt; nat"</span>
<span class="kp">where</span>
  <span class="s">"sub2 a 0 = a"</span>
<span class="o">|</span> <span class="s">"sub2 a (Suc b) = (case a of Suc a' ⇒ sub2 a' b)"</span>

<span class="kn">lemma</span> <span class="n">foo22</span><span class="o">:</span> <span class="s">"sub2 0 0 = 0"</span>
  <span class="k">by</span> <span class="o">(</span><span class="n">simp_all</span> <span class="n">add</span><span class="o">:</span> <span class="n">sub_def</span><span class="o">)</span>

<span class="kn">lemma</span> <span class="n">foo23</span><span class="o">:</span> <span class="s">"sub2 0 1 = 0"</span>
  <span class="k">by</span> <span class="o">(</span><span class="n">simp_all</span> <span class="n">add</span><span class="o">:</span> <span class="n">sub_def</span><span class="o">)</span>
  <span class="c">(* fails: undefined = 0 *)</span>

<span class="kn">lemma</span> <span class="n">foo24</span> <span class="o">:</span> <span class="s">"sub2 0 1 = sub2 0 (Suc 1)"</span>
  <span class="k">by</span> <span class="o">(</span><span class="n">simp_all</span> <span class="n">add</span><span class="o">:</span> <span class="n">sub_def</span><span class="o">)</span>

<span class="k">end</span>
</code></pre></div>
</div></div>



<a name="279822213"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Incomplete%20pattern%20match/near/279822213" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Incomplete.20pattern.20match.html#279822213">(Apr 22 2022 at 13:17)</a>:</h4>
<p>So if the answer to "can you prove <code>0 - 1 = 0 - 2</code>" is "it depends on the exact definition of <code>-</code>" then I'm not convinced that is an improvement on the answer "yes"</p>



<a name="279823373"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Incomplete%20pattern%20match/near/279823373" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Incomplete.20pattern.20match.html#279823373">(Apr 22 2022 at 13:26)</a>:</h4>
<p>Whatever the answer, it seems like having a special</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[irreducible]</span> <span class="kd">def</span> <span class="n">undefined</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">inhabited</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">arbitrary</span> <span class="n">α</span>
</code></pre></div>
<p>could still be useful as a way to mark which values are explicitly junk, while doing so in a way that, if it's something you're concerned about, gives you some amount of protection from proving nonsense (so long as you avoid piercing through the <code>irreducible</code> like Kevin did, though that's irrelevant in Lean 4, and also with the caveat that you still need to think about whether a function will evaluate to <code>undefined</code>).</p>
<div class="spoiler-block"><div class="spoiler-header">
<p>Lean 3 example with undefined</p>
</div><div class="spoiler-content" aria-hidden="true">
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">namespace</span> <span class="n">foo</span>
<span class="c1">-- in a namespace since there is already a top-level `meta def undefined`</span>

<span class="kd">@[irreducible]</span> <span class="kd">def</span> <span class="n">undefined</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">inhabited</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">arbitrary</span> <span class="n">α</span>

<span class="kd">def</span> <span class="n">sub</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">(</span><span class="n">b</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">undefined</span>
<span class="bp">|</span> <span class="n">a</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">a</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">a</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sub</span> <span class="n">a</span> <span class="n">b</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">sub</span> <span class="mi">0</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">sub</span> <span class="mi">0</span> <span class="mi">2</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">sub</span> <span class="mi">0</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">unfold</span> <span class="n">sub</span><span class="o">,</span>
  <span class="c1">-- ⊢ undefined = 0</span>
  <span class="n">refl</span><span class="o">,</span>
  <span class="c1">-- failed to unify</span>
<span class="kd">end</span>

<span class="kd">end</span> <span class="n">foo</span>
</code></pre></div>
</div></div>



<a name="279833881"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Incomplete%20pattern%20match/near/279833881" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Johnson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Incomplete.20pattern.20match.html#279833881">(Apr 22 2022 at 14:52)</a>:</h4>
<p>When I said</p>
<blockquote>
<p>In Isabelle/HOL, there is an axiomatically defined constant <code>undefined</code> which returns a "random" value of a given type (all types are inhabited). In Lean, we can implement <code>undefined</code> using <code>nonempty.some</code>, but it still allows us to prove nonsensical things, because <code>nonempty.some</code> always returns the same value for the same type, so it may cancel out if it's used in some other definition.</p>
</blockquote>
<p>my point was not that Isabelle has something that lean doesn't, but that different theorem provers deal with junk cases in different ways. And yes, <code>undefined</code> is just like <code>nonempty.some</code> in Lean (it's a fixed value of the given type, but we don't know the exact value, except for singleton types). The point is that in Isabelle, <code>undefined</code> is preferred over some exact default value in junk cases. But it's still not the best way to deal with it, since it may cancel out with undefineds from other functions.</p>
<p>In Lean, I think this definition would be much better:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.string.basic</span>

<span class="kd">@[irreducible]</span>
<span class="kd">def</span> <span class="n">junk</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">inhabited</span> <span class="n">β</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">β</span> <span class="o">:=</span> <span class="n">default</span>

<span class="kd">def</span> <span class="n">pred</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">junk</span> <span class="s2">"pred"</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">a</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">a</span>

<span class="kd">def</span> <span class="n">sub</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span>
<span class="bp">|</span> <span class="n">a</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">a</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">(</span><span class="n">b</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">junk</span> <span class="o">(</span><span class="s2">"sub"</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">a</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sub</span> <span class="n">a</span> <span class="n">b</span>
</code></pre></div>
<p>What I would like to see in Lean 4 is that we can make opaque rather than irreducible definitions (opaque is the kernel's version of irreducible, rather than elaborator's) and to have some macro <code>junk</code> which passes everything from the current definition's context to the <code>junk</code> function in a tuple, so that we don't have to deal with it explicitly.</p>



<a name="279837575"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Incomplete%20pattern%20match/near/279837575" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Incomplete.20pattern.20match.html#279837575">(Apr 22 2022 at 15:17)</a>:</h4>
<p>That's like <code>sub_undefined</code> in <a href="#narrow/stream/113488-general/topic/Incomplete.20pattern.20match/near/279810279">this message</a> but generalized. For what it's worth, it does have some potentially unexpected behavior:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="n">sub</span> <span class="mi">0</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">sub</span> <span class="mi">1</span> <span class="mi">2</span> <span class="o">:=</span> <span class="n">rfl</span>
</code></pre></div>



<a name="279837759"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Incomplete%20pattern%20match/near/279837759" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Incomplete.20pattern.20match.html#279837759">(Apr 22 2022 at 15:18)</a>:</h4>
<p><span class="user-mention silent" data-user-id="456794">Patrick Johnson</span> <a href="#narrow/stream/113488-general/topic/Incomplete.20pattern.20match/near/279833881">said</a>:</p>
<blockquote>
<p>What I would like to see in Lean 4 is that we can make opaque rather than irreducible definitions (opaque is the kernel's version of irreducible, rather than elaborator's) and to have some macro <code>junk</code> which passes everything from the current definition's context to the <code>junk</code> function in a tuple, so that we don't have to deal with it explicitly.</p>
</blockquote>
<p>Expect for the macro part, <code>constant</code> does the first part, right?</p>



<a name="279838023"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Incomplete%20pattern%20match/near/279838023" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Incomplete.20pattern.20match.html#279838023">(Apr 22 2022 at 15:20)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">constant</span> <span class="n">junk</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">Inhabited</span> <span class="n">β</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">β</span> <span class="o">:=</span> <span class="n">default</span>

<span class="kd">def</span> <span class="n">pred</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="n">Nat</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="bp">=&gt;</span> <span class="n">junk</span> <span class="s2">"pred"</span>
<span class="bp">|</span> <span class="n">a</span><span class="bp">+</span><span class="mi">1</span> <span class="bp">=&gt;</span> <span class="n">a</span>

<span class="kd">def</span> <span class="n">sub</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="n">Nat</span>
<span class="bp">|</span> <span class="n">a</span><span class="o">,</span> <span class="mi">0</span> <span class="bp">=&gt;</span> <span class="n">a</span>
<span class="bp">|</span> <span class="mi">0</span><span class="o">,</span> <span class="n">b</span><span class="bp">+</span><span class="mi">1</span> <span class="bp">=&gt;</span> <span class="n">junk</span> <span class="o">(</span><span class="s2">"sub"</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">a</span><span class="bp">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">b</span><span class="bp">+</span><span class="mi">1</span> <span class="bp">=&gt;</span> <span class="n">sub</span> <span class="n">a</span> <span class="n">b</span>
</code></pre></div>



<a name="289075900"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Incomplete%20pattern%20match/near/289075900" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Brandon Brown <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Incomplete.20pattern.20match.html#289075900">(Jul 10 2022 at 02:38)</a>:</h4>
<p>Naive question, why does it not make sense that <code>pred 0</code> is <code>0</code> and that <code>5 - 7 = 0</code> when the numbers are <code>Nat</code>? Seems very reasonable to me...</p>



<a name="289076236"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Incomplete%20pattern%20match/near/289076236" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Incomplete.20pattern.20match.html#289076236">(Jul 10 2022 at 02:45)</a>:</h4>
<p>It both makes sense and doesn't make sense. It makes sense in that it's <a href="https://en.wikipedia.org/wiki/Monus">monus</a>, but it doesn't make sense in that it doesn't agree with the minus when you embed <code>Nat</code> into <code>Int</code>.</p>



<a name="289076304"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Incomplete%20pattern%20match/near/289076304" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Incomplete.20pattern.20match.html#289076304">(Jul 10 2022 at 02:46)</a>:</h4>
<p>I think whether it makes sense or not just depends on what you're trying to model.</p>



<a name="289081838"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Incomplete%20pattern%20match/near/289081838" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Incomplete.20pattern.20match.html#289081838">(Jul 10 2022 at 04:41)</a>:</h4>
<p>Mathematically it's bad, for sociological reasons. Computer scientists have seen phenomena like this before (eg perhaps 5/2=2 in a system with integers and division) but to a mathematician (who has probably never heard of types) statements like "0-1=0" and "5/2=2" are <em>indisputably wrong</em> which is problematic. When a mathematician talks about a-b with a,b naturals they would never mean monus, because they've never heard of monus and monus is basically mathematically useless even though it has a role in CS</p>



<a name="289084408"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Incomplete%20pattern%20match/near/289084408" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Brandon Brown <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Incomplete.20pattern.20match.html#289084408">(Jul 10 2022 at 05:53)</a>:</h4>
<p>But if you haven't invented the integers or rationals yet, then why is <code>5 - 7 = 0</code> wrong? It wouldn't make sense to think of embeddings if those supersets haven't been defined yet right?</p>



<a name="289085124"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Incomplete%20pattern%20match/near/289085124" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Incomplete.20pattern.20match.html#289085124">(Jul 10 2022 at 06:13)</a>:</h4>
<p>We invented those things hundreds of years ago and we're not trying to market the software to mathematicians who haven't discovered them yet because they're all dead.</p>



<a name="289085170"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Incomplete%20pattern%20match/near/289085170" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Incomplete.20pattern.20match.html#289085170">(Jul 10 2022 at 06:14)</a>:</h4>
<p>The concept of the integers having "not been defined yet" is alien to us (as is the concept of being artificially restricted to answers in a certain type because we think about numerals in a more fluid way)</p>



<a name="289116152"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Incomplete%20pattern%20match/near/289116152" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Incomplete.20pattern.20match.html#289116152">(Jul 10 2022 at 17:59)</a>:</h4>
<p>If mathematicians want to write monus they normally end up writing something like <code>min 0 (a - b)</code> I've basically never seen this ceiling subtraction as it's own function</p>



<a name="289118336"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Incomplete%20pattern%20match/near/289118336" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ruben Van de Velde <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Incomplete.20pattern.20match.html#289118336">(Jul 10 2022 at 18:53)</a>:</h4>
<p>Wouldn't they write "max"?</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
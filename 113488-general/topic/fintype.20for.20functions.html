---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/fintype.20for.20functions.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fintype.20for.20functions.html">fintype for functions</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="291217270"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fintype%20for%20functions/near/291217270" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thorsten Altenkirch <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fintype.20for.20functions.html#291217270">(Jul 28 2022 at 16:24)</a>:</h4>
<p>Is there an instance of fintype that shows that </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">β</span><span class="o">]</span> <span class="o">:</span> <span class="n">fintype</span> <span class="o">(</span><span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span>
</code></pre></div>
<p>If not, maybe there is some advice how to prove it?</p>



<a name="291217363"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fintype%20for%20functions/near/291217363" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fintype.20for.20functions.html#291217363">(Jul 28 2022 at 16:25)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/pi.fintype">docs#pi.fintype</a></p>



<a name="291217518"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fintype%20for%20functions/near/291217518" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fintype.20for.20functions.html#291217518">(Jul 28 2022 at 16:26)</a>:</h4>
<p>It needs decidable equality on the domain to construct that fintype.</p>



<a name="291217764"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fintype%20for%20functions/near/291217764" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fintype.20for.20functions.html#291217764">(Jul 28 2022 at 16:28)</a>:</h4>
<p>One trick for finding these instances from within Lean when you're not sure of the decidability assumptions is this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">open_locale</span> <span class="n">classical</span>
<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">foo</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">β</span><span class="o">]</span> <span class="o">:</span> <span class="n">fintype</span> <span class="o">(</span><span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">apply_instance</span>
<span class="k">#print</span> <span class="n">foo</span>
<span class="c1">-- ... pi.fintype</span>
</code></pre></div>



<a name="291219237"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fintype%20for%20functions/near/291219237" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thorsten Altenkirch <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fintype.20for.20functions.html#291219237">(Jul 28 2022 at 16:39)</a>:</h4>
<p>Actually what we really want to show is</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">decPow</span><span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="mi">2</span> <span class="o">:=</span>
  <span class="o">(</span><span class="n">pred</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
  <span class="o">[</span><span class="n">decP</span> <span class="o">:</span> <span class="n">decidable_pred</span> <span class="n">pred</span><span class="o">]</span>

<span class="kd">instance</span> <span class="n">finpow</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span> <span class="mi">1</span><span class="o">)</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">A</span><span class="o">][</span><span class="n">decidable_eq</span> <span class="n">A</span><span class="o">]</span> <span class="o">:</span> <span class="n">fintype</span> <span class="o">(</span><span class="n">decPow</span> <span class="n">A</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>
<p>(How can we use universes better here?) We can show this by using pi.fintype and showing that decPow is the same as A -&gt; Bool but maybe there is a better way?</p>



<a name="291219688"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fintype%20for%20functions/near/291219688" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fintype.20for.20functions.html#291219688">(Jul 28 2022 at 16:42)</a>:</h4>
<p><del>Does <code>@[derive fintype]</code> work?</del></p>



<a name="291220105"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fintype%20for%20functions/near/291220105" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thorsten Altenkirch <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fintype.20for.20functions.html#291220105">(Jul 28 2022 at 16:46)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/113488-general/topic/fintype.20for.20functions/near/291219688">said</a>:</p>
<blockquote>
<p><del>Does <code>@[derive fintype]</code> work?</del></p>
</blockquote>
<p>Like</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">decPow</span><span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="mi">2</span> <span class="o">:=</span>
  <span class="o">(</span><span class="n">pred</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
  <span class="o">[</span><span class="n">decP</span> <span class="o">:</span> <span class="n">decidable_pred</span> <span class="n">pred</span><span class="o">]</span>
  <span class="kd">@[derive fintype]</span>
</code></pre></div>
<p>seems to work?</p>



<a name="291220254"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fintype%20for%20functions/near/291220254" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fintype.20for.20functions.html#291220254">(Jul 28 2022 at 16:47)</a>:</h4>
<p>It goes before not after</p>



<a name="291220277"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fintype%20for%20functions/near/291220277" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fintype.20for.20functions.html#291220277">(Jul 28 2022 at 16:48)</a>:</h4>
<p>But it won't work here</p>



<a name="291220393"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fintype%20for%20functions/near/291220393" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thorsten Altenkirch <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fintype.20for.20functions.html#291220393">(Jul 28 2022 at 16:49)</a>:</h4>
<p>Ok now I see. <code>failed to find a derive handler for 'fintype'</code></p>



<a name="291220407"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fintype%20for%20functions/near/291220407" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fintype.20for.20functions.html#291220407">(Jul 28 2022 at 16:49)</a>:</h4>
<p><code>import tactic.derive_fintype</code></p>



<a name="291220459"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fintype%20for%20functions/near/291220459" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thorsten Altenkirch <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fintype.20for.20functions.html#291220459">(Jul 28 2022 at 16:50)</a>:</h4>
<p>Ah ok then I get <code>failed to synthesize type class instance for</code></p>



<a name="291220461"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fintype%20for%20functions/near/291220461" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fintype.20for.20functions.html#291220461">(Jul 28 2022 at 16:50)</a>:</h4>
<p>But like I said, it won't work anyway. <code>by tactic.mk_fintype_instance</code> also fails</p>



<a name="291220621"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fintype%20for%20functions/near/291220621" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fintype.20for.20functions.html#291220621">(Jul 28 2022 at 16:51)</a>:</h4>
<p><span class="user-mention silent" data-user-id="271218">Thorsten Altenkirch</span> <a href="#narrow/stream/113488-general/topic/fintype.20for.20functions/near/291219237">said</a>:</p>
<blockquote>
<p>We can show this by using pi.fintype and showing that decPow is the same as A -&gt; Bool but maybe there is a better way?</p>
</blockquote>
<p>this sounds like a good strategy to me. I think the equivalence with <code>A -&gt; Bool</code> is worth having anyway</p>



<a name="291220816"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fintype%20for%20functions/near/291220816" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thorsten Altenkirch <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fintype.20for.20functions.html#291220816">(Jul 28 2022 at 16:52)</a>:</h4>
<p>Do we actually need the equivalence? It seems we should only need one direction. Namely that the is an injection from <code>DecProp A</code> to <code>A -&gt; Bool</code>. I guess there is a fintype instance for this?</p>



<a name="291220850"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fintype%20for%20functions/near/291220850" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fintype.20for.20functions.html#291220850">(Jul 28 2022 at 16:53)</a>:</h4>
<p><span class="user-mention silent" data-user-id="271218">Thorsten Altenkirch</span> <a href="#narrow/stream/113488-general/topic/fintype.20for.20functions/near/291219237">said</a>:</p>
<blockquote>
<p>(How can we use universes better here?)</p>
</blockquote>
<p>Let lean deal with it</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">decPow</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">pred</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="o">[</span><span class="n">decP</span> <span class="o">:</span> <span class="n">decidable_pred</span> <span class="n">pred</span><span class="o">]</span>
</code></pre></div>
<p>as it turns out, there's no need for a universe bump</p>



<a name="291221003"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fintype%20for%20functions/near/291221003" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fintype.20for.20functions.html#291221003">(Jul 28 2022 at 16:54)</a>:</h4>
<p>Arguably you should make the equivalence anyway since it's true</p>



<a name="291221065"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fintype%20for%20functions/near/291221065" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fintype.20for.20functions.html#291221065">(Jul 28 2022 at 16:54)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/fintype.of_surjective">docs#fintype.of_surjective</a> is what you're after</p>



<a name="291221150"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fintype%20for%20functions/near/291221150" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fintype.20for.20functions.html#291221150">(Jul 28 2022 at 16:55)</a>:</h4>
<p>Although you might run into trouble since that needs decidable equality of your structure</p>



<a name="291221156"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fintype%20for%20functions/near/291221156" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fintype.20for.20functions.html#291221156">(Jul 28 2022 at 16:55)</a>:</h4>
<p>I'm not sure you can make <code>decPow</code> be a computable <code>fintype</code> -- is that ok?</p>



<a name="291221277"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fintype%20for%20functions/near/291221277" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thorsten Altenkirch <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fintype.20for.20functions.html#291221277">(Jul 28 2022 at 16:56)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/113488-general/topic/fintype.20for.20functions/near/291221150">said</a>:</p>
<blockquote>
<p>Although you might run into trouble since that needs decidable equality of your structure</p>
</blockquote>
<p>Yes, but we need this anyway.</p>



<a name="291221289"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fintype%20for%20functions/near/291221289" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fintype.20for.20functions.html#291221289">(Jul 28 2022 at 16:56)</a>:</h4>
<p>Here's a noncomputable one:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">topology.separation</span>

<span class="n">open_locale</span> <span class="n">classical</span>

<span class="kd">structure</span> <span class="n">decPow</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="mi">2</span> <span class="o">:=</span>
  <span class="o">(</span><span class="n">pred</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
  <span class="o">[</span><span class="n">decP</span> <span class="o">:</span> <span class="n">decidable_pred</span> <span class="n">pred</span><span class="o">]</span>

<span class="c1">-- ideally this could be generated automatically using a `mk_equiv` attribute, like `mk_iff`</span>
<span class="kd">def</span> <span class="n">decPow_equiv</span> <span class="o">(</span><span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="n">decPow</span> <span class="n">A</span> <span class="bp">≃</span> <span class="o">(</span><span class="bp">Σ</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">),</span> <span class="n">decidable_pred</span> <span class="n">p</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">o</span><span class="o">,</span> <span class="o">⟨</span><span class="n">o.pred</span><span class="o">,</span> <span class="n">o.decP</span><span class="o">⟩,</span>
  <span class="n">inv_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">e</span><span class="o">,</span> <span class="bp">@</span><span class="n">decPow.mk</span> <span class="n">_</span> <span class="n">e.1</span> <span class="n">e.2</span><span class="o">,</span>
  <span class="n">left_inv</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">intro</span><span class="o">,</span> <span class="n">cases</span> <span class="n">x</span><span class="o">,</span> <span class="n">refl</span><span class="o">,</span> <span class="o">},</span>
  <span class="n">right_inv</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">intro</span><span class="o">,</span> <span class="n">cases</span> <span class="n">x</span><span class="o">,</span> <span class="n">refl</span><span class="o">,</span> <span class="o">}</span> <span class="o">}</span>

<span class="kd">noncomputable</span> <span class="kd">instance</span> <span class="n">finpow</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span> <span class="mi">1</span><span class="o">)</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">A</span><span class="o">]</span> <span class="o">:</span> <span class="n">fintype</span> <span class="o">(</span><span class="n">decPow</span> <span class="n">A</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">fintype.of_equiv</span> <span class="n">_</span> <span class="o">(</span><span class="n">decPow_equiv</span> <span class="n">A</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span>
</code></pre></div>



<a name="291221496"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fintype%20for%20functions/near/291221496" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fintype.20for.20functions.html#291221496">(Jul 28 2022 at 16:57)</a>:</h4>
<p>The issue is that you can't enumerate <code>decidable p</code> unless you have a proof or disproof of <code>p</code>.</p>



<a name="291221547"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fintype%20for%20functions/near/291221547" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fintype.20for.20functions.html#291221547">(Jul 28 2022 at 16:58)</a>:</h4>
<p>I disagree, it's computable</p>



<a name="291221592"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fintype%20for%20functions/near/291221592" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fintype.20for.20functions.html#291221592">(Jul 28 2022 at 16:58)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.fintype.basic</span>

<span class="kd">structure</span> <span class="n">decPow</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">pred</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="o">[</span><span class="n">decP</span> <span class="o">:</span> <span class="n">decidable_pred</span> <span class="n">pred</span><span class="o">]</span>

<span class="kn">attribute</span> <span class="o">[</span><span class="kd">instance</span><span class="o">]</span> <span class="n">decPow.decP</span>

<span class="kd">instance</span> <span class="n">finpow</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span> <span class="mi">1</span><span class="o">)</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">A</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">A</span><span class="o">]</span> <span class="o">:</span> <span class="n">fintype</span> <span class="o">(</span><span class="n">decPow</span> <span class="n">A</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">fintype.of_equiv</span> <span class="o">(</span><span class="n">A</span> <span class="bp">→</span> <span class="n">bool</span><span class="o">)</span> <span class="bp">$</span>
  <span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">p</span><span class="o">,</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="n">p</span> <span class="n">a</span><span class="o">⟩,</span>
    <span class="n">inv_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">A</span> <span class="n">i</span><span class="o">,</span> <span class="n">A.pred</span> <span class="n">i</span><span class="o">,</span>
    <span class="n">left_inv</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
    <span class="n">right_inv</span> <span class="o">:=</span> <span class="gr">sorry</span> <span class="o">}</span>
</code></pre></div>



<a name="291221625"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fintype%20for%20functions/near/291221625" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fintype.20for.20functions.html#291221625">(Jul 28 2022 at 16:58)</a>:</h4>
<p>Ah, right, ok</p>



<a name="291221701"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fintype%20for%20functions/near/291221701" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fintype.20for.20functions.html#291221701">(Jul 28 2022 at 16:59)</a>:</h4>
<p>At that point, I think it would be better to define <code>pred</code> to be <code>A -&gt; bool</code> rather than tacking on the decidability assumption, seeing as <code>decidable_pred</code> amounts to a way to lift <code>A -&gt; Prop</code> to <code>A -&gt; bool</code>.</p>



<a name="291221893"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fintype%20for%20functions/near/291221893" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fintype.20for.20functions.html#291221893">(Jul 28 2022 at 17:00)</a>:</h4>
<p><span class="user-mention" data-user-id="306601">@Kyle Miller</span>, can you add imports to your example?</p>



<a name="291222050"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fintype%20for%20functions/near/291222050" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fintype.20for.20functions.html#291222050">(Jul 28 2022 at 17:01)</a>:</h4>
<p>Sure, it's a silly one (<code>import topology.separation</code>) just because of the file I happened to be in.</p>



<a name="291222129"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fintype%20for%20functions/near/291222129" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fintype.20for.20functions.html#291222129">(Jul 28 2022 at 17:01)</a>:</h4>
<p>Weird, I can't reproduce your code any more</p>



<a name="291222208"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fintype%20for%20functions/near/291222208" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fintype.20for.20functions.html#291222208">(Jul 28 2022 at 17:02)</a>:</h4>
<p>I accidentally had <code>open_locale classical</code> too.</p>



<a name="291222641"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fintype%20for%20functions/near/291222641" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fintype.20for.20functions.html#291222641">(Jul 28 2022 at 17:05)</a>:</h4>
<p>Perhaps mathlib should have</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">equiv.sigma_decidable_pred</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">:</span> <span class="o">(</span><span class="bp">Σ</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">),</span> <span class="n">decidable_pred</span> <span class="n">p</span><span class="o">)</span> <span class="bp">≃</span> <span class="o">(</span><span class="n">α</span> <span class="bp">→</span> <span class="n">bool</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">A</span> <span class="n">i</span><span class="o">,</span> <span class="bp">@</span><span class="n">to_bool</span> <span class="o">(</span><span class="n">A.1</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">A.2</span> <span class="n">i</span><span class="o">),</span>
  <span class="n">inv_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">p</span><span class="o">,</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="n">p</span> <span class="n">a</span><span class="o">,</span> <span class="kd">by</span> <span class="n">apply_instance</span><span class="o">⟩,</span>
  <span class="n">left_inv</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="n">right_inv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">p</span><span class="o">,</span> <span class="n">funext</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">bool.to_bool_coe</span> <span class="n">_</span> <span class="o">}</span>
</code></pre></div>



<a name="291223560"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fintype%20for%20functions/near/291223560" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fintype.20for.20functions.html#291223560">(Jul 28 2022 at 17:12)</a>:</h4>
<p>The proof of the <code>sorry</code> escapes me</p>



<a name="291225176"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fintype%20for%20functions/near/291225176" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fintype.20for.20functions.html#291225176">(Jul 28 2022 at 17:23)</a>:</h4>
<p><span class="user-mention" data-user-id="310045">@Eric Wieser</span> Got it:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">foo</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">↔</span> <span class="n">q</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">decidable</span> <span class="n">p</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">decidable</span> <span class="n">q</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">==</span> <span class="n">y</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">have</span> <span class="o">:=</span> <span class="n">propext</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">unfreezingI</span> <span class="o">{</span> <span class="n">cases</span> <span class="n">this</span><span class="o">,</span> <span class="o">},</span>
  <span class="n">simp</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">@[simps]</span>
<span class="kd">def</span> <span class="n">equiv.sigma_decidable_pred</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">:</span> <span class="o">(</span><span class="bp">Σ</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">),</span> <span class="n">decidable_pred</span> <span class="n">p</span><span class="o">)</span> <span class="bp">≃</span> <span class="o">(</span><span class="n">α</span> <span class="bp">→</span> <span class="n">bool</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">A</span> <span class="n">i</span><span class="o">,</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">haveI</span> <span class="o">:=</span> <span class="n">A.2</span><span class="o">,</span> <span class="n">exact</span> <span class="n">A.1</span> <span class="n">i</span><span class="o">},</span>
  <span class="n">inv_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">p</span><span class="o">,</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">p</span> <span class="n">i</span><span class="o">,</span> <span class="kd">by</span> <span class="n">apply_instance</span><span class="o">⟩,</span>
  <span class="n">left_inv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">A</span><span class="o">,</span> <span class="kd">begin</span> <span class="n">cases</span> <span class="n">A</span><span class="o">,</span> <span class="n">resetI</span><span class="o">,</span> <span class="n">simp</span><span class="o">,</span> <span class="n">ext</span><span class="o">,</span> <span class="n">refl</span><span class="o">,</span> <span class="n">intros</span> <span class="n">i</span> <span class="n">i'</span> <span class="n">h</span><span class="o">,</span> <span class="n">cases</span> <span class="n">h</span><span class="o">,</span> <span class="n">dsimp</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">foo</span><span class="o">,</span>
    <span class="n">simp</span><span class="o">,</span>
 <span class="kd">end</span><span class="o">,</span>
  <span class="n">right_inv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">p</span><span class="o">,</span> <span class="n">funext</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">bool.to_bool_coe</span> <span class="n">_</span> <span class="o">}</span>
</code></pre></div>
<p>(I also changed <code>to_fun</code> to use a coercion, but that's immaterial.)</p>



<a name="291225591"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fintype%20for%20functions/near/291225591" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fintype.20for.20functions.html#291225591">(Jul 28 2022 at 17:26)</a>:</h4>
<p>I guess <code>decidable</code> is one of those rare types where you can deduce parameters are equal from heterogeneous equality of terms.</p>



<a name="291225796"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fintype%20for%20functions/near/291225796" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fintype.20for.20functions.html#291225796">(Jul 28 2022 at 17:28)</a>:</h4>
<p>Can you prove that?</p>



<a name="291225845"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fintype%20for%20functions/near/291225845" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fintype.20for.20functions.html#291225845">(Jul 28 2022 at 17:28)</a>:</h4>
<p>you can prove it by "cases" on <code>p</code> and <code>q</code></p>



<a name="291225872"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fintype%20for%20functions/near/291225872" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fintype.20for.20functions.html#291225872">(Jul 28 2022 at 17:28)</a>:</h4>
<p>that is, <code>p = true \/ p = false</code></p>



<a name="291225987"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fintype%20for%20functions/near/291225987" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fintype.20for.20functions.html#291225987">(Jul 28 2022 at 17:29)</a>:</h4>
<p>actually maybe not; even if you know <code>decidable true = decidable false</code> I don't think you can deduce a contradiction</p>



<a name="291226007"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fintype%20for%20functions/near/291226007" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fintype.20for.20functions.html#291226007">(Jul 28 2022 at 17:30)</a>:</h4>
<p>because both types are singletons</p>



<a name="291226330"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fintype%20for%20functions/near/291226330" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fintype.20for.20functions.html#291226330">(Jul 28 2022 at 17:31)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">equiv.sigma_decidable_pred</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">:</span> <span class="o">(</span><span class="bp">Σ</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">),</span> <span class="n">decidable_pred</span> <span class="n">p</span><span class="o">)</span> <span class="bp">≃</span> <span class="o">(</span><span class="n">α</span> <span class="bp">→</span> <span class="n">bool</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">A</span> <span class="n">i</span><span class="o">,</span> <span class="bp">@</span><span class="n">to_bool</span> <span class="o">(</span><span class="n">A.1</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">A.2</span> <span class="n">i</span><span class="o">),</span>
  <span class="n">inv_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">p</span><span class="o">,</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="n">p</span> <span class="n">a</span><span class="o">,</span> <span class="kd">by</span> <span class="n">apply_instance</span><span class="o">⟩,</span>
  <span class="n">left_inv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">p</span><span class="o">,</span> <span class="n">sigma.ext</span> <span class="o">(</span><span class="kd">by</span> <span class="n">simp</span><span class="o">)</span> <span class="bp">$</span> <span class="n">subsingleton.helim</span> <span class="o">(</span><span class="kd">by</span> <span class="n">simp</span><span class="o">)</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">right_inv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">p</span><span class="o">,</span> <span class="n">funext</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">bool.to_bool_coe</span> <span class="n">_</span> <span class="o">}</span>
</code></pre></div>
<p>maybe is a bit clearer</p>



<a name="291226459"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fintype%20for%20functions/near/291226459" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fintype.20for.20functions.html#291226459">(Jul 28 2022 at 17:32)</a>:</h4>
<p>I think <code>foo</code> is a weaker version of <a href="https://leanprover-community.github.io/mathlib_docs/find/subsingleton.helim">docs#subsingleton.helim</a>, actually</p>



<a name="291226525"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fintype%20for%20functions/near/291226525" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thorsten Altenkirch <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fintype.20for.20functions.html#291226525">(Jul 28 2022 at 17:33)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/113488-general/topic/fintype.20for.20functions/near/291221701">said</a>:</p>
<blockquote>
<p>At that point, I think it would be better to define <code>pred</code> to be <code>A -&gt; bool</code> rather than tacking on the decidability assumption, seeing as <code>decidable_pred</code> amounts to a way to lift <code>A -&gt; Prop</code> to <code>A -&gt; bool</code>.</p>
</blockquote>
<p>Yes, we thought of this. However, I want to use this in a lecture and it is easy to just use Prop for reasoning and to show separately that decidable predicates are the same as booleans. This is needed in the construction of the power automaton.</p>



<a name="291227168"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fintype%20for%20functions/near/291227168" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fintype.20for.20functions.html#291227168">(Jul 28 2022 at 17:39)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/113488-general/topic/fintype.20for.20functions/near/291225796">said</a>:</p>
<blockquote>
<p>Can you prove that?</p>
</blockquote>
<p>Sometimes Lean lets me too easily turn off the part of my brain that informs me about what I'm actually doing. I interpreted <code>foo</code> as if it were its converse when I said that.</p>



<a name="291822042"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fintype%20for%20functions/near/291822042" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Quanwen Chen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fintype.20for.20functions.html#291822042">(Aug 03 2022 at 09:23)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/113488-general/topic/fintype.20for.20functions/near/291221150">said</a>:</p>
<blockquote>
<p>Although you might run into trouble since that needs decidable equality of your structure</p>
</blockquote>
<p>Given the equivalence of <code>(Σ (p : α → Prop), decidable_pred p) ≃ (α → bool)</code>, do we have a convenient way to show the decidable equality of  <code>Σ (p : α → Prop), decidable_pred p</code>?</p>



<a name="291822185"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fintype%20for%20functions/near/291822185" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fintype.20for.20functions.html#291822185">(Aug 03 2022 at 09:24)</a>:</h4>
<p>Yes, you can use <code>equiv.sigma_decidable_pred.symm.surjective.forall\2</code> or similar</p>



<a name="291823676"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fintype%20for%20functions/near/291823676" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Quanwen Chen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fintype.20for.20functions.html#291823676">(Aug 03 2022 at 09:38)</a>:</h4>
<p>Figured out that <code>equiv.decidable_eq equiv.sigma_decidable_pred</code> could solve the problem.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
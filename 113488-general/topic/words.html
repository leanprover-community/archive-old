---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/words.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/words.html">words</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="185561933"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/words/near/185561933" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jeremy Avigad <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/words.html#185561933">(Jan 14 2020 at 03:25)</a>:</h4>
<p>In his talk in the Formal Abstracts session of the meeting at Carnegie Mellon last week, Tom Hales pointed out that for some purposes, it may be better to use the word "or" instead of the symbol <code>∨</code>. The former is not harder to type than the latter, it is familiar, it is easy to read, and everyone knows what it means.</p>
<p>For fun, I took Chris Hughes' proof of quadratic reciprocity in the library and replaced all the logical connectives with the words "not" "and" "or" "implies" "iff" "exists" and "forall". The result is attached.:</p>
<p><a href="/user_uploads/3121/WLhtWzuCMMmf2358-cAnE2M2/quadratic_reciprocity_with_words.lean" target="_blank" title="quadratic_reciprocity_with_words.lean">quadratic_reciprocity_with_words.lean</a></p>
<p>The theorem</p>
<div class="codehilite"><pre><span></span>lemma euler_criterion_units {x : units (zmodp p hp)} :
  (∃ y : units (zmodp p hp), y ^ 2 = x) ↔ x ^ (p / 2) = 1
</pre></div>


<p>becomes</p>
<div class="codehilite"><pre><span></span>lemma euler_criterion {a : zmodp p hp} (ha : a ≠ 0) :
  (exists y : zmodp p hp, y ^ 2 = a) iff a ^ (p / 2) = 1
</pre></div>


<p>and the line</p>
<div class="codehilite"><pre><span></span>have he : ∀ {x}, x ∈ Ico 1 (p / 2).succ → x ≠ 0 ∧ x ≤ p / 2
</pre></div>


<p>becomes</p>
<div class="codehilite"><pre><span></span>have he : forall {x}, x ∈ Ico 1 (p / 2).succ implies x ≠ 0 and x ≤ p / 2
</pre></div>


<p>Call me crazy, but I kind of like the text versions.</p>



<a name="185564814"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/words/near/185564814" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Enrico Borba <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/words.html#185564814">(Jan 14 2020 at 04:36)</a>:</h4>
<p>Some thoughts:</p>
<ul>
<li>In symbol-heavy statements, the words <code>and</code>/<code>not</code>/etc, will stand out more, and make the reading of the theorem much easier. </li>
<li>Similarly, in word-heavy statements, the symbolic forms of the connectives will likely be more readable than having even more text</li>
<li>I think it fits well with Lean supporting many different "styles" for statements &amp; proofs</li>
</ul>



<a name="185567387"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/words/near/185567387" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/words.html#185567387">(Jan 14 2020 at 05:52)</a>:</h4>
<p><span class="user-mention" data-user-id="256383">@Enrico Borba</span> But maybe in the word-heavy statements some subtle syntax highlighting could make the connectives stand out, even if they are in text form.<br>
Also, in my field of mathematics word-heavy seems to be preferred. I never see the <code>\not</code> symbol. I sometimes see <code>\and</code> and <code>\or</code>, but it's usually words. The quantifier-symbols are used, but I would still say less than their word-variants.</p>



<a name="185567630"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/words/near/185567630" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Enrico Borba <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/words.html#185567630">(Jan 14 2020 at 05:59)</a>:</h4>
<p>I don't mean the second point as a downside of having "word" form of the connectives. I mean it as a support for both versions to exist. Syntax highlighting will definitely help resolving any ambiguity for sure.</p>



<a name="185573127"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/words/near/185573127" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/words.html#185573127">(Jan 14 2020 at 08:12)</a>:</h4>
<p>My experience is the same as Johan's. I never see the symbols for not, and or or. Hales quoted Knuth as saying that in mathematical prose symbols should be avoided, and looking at the maths papers I read I see a lot of it is in prose. This is one reason to be very excited about Tom's project with Koepke. Their natural language examples looked very natural to me. Tom's work will make Jeremy's examples even better. Ideally we want Euler's criterion to literally look like this: "Let <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span> be a non-zero element of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">Z</mi><mi mathvariant="normal">/</mi><mi>p</mi><mi mathvariant="double-struck">Z</mi></mrow><annotation encoding="application/x-tex">\mathbb{Z}/p\mathbb{Z}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathbb">Z</span></span><span class="mord">/</span><span class="mord mathdefault">p</span><span class="mord"><span class="mord mathbb">Z</span></span></span></span></span>. Then there exists <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>∈</mo><mi mathvariant="double-struck">Z</mi><mi mathvariant="normal">/</mi><mi>p</mi><mi mathvariant="double-struck">Z</mi></mrow><annotation encoding="application/x-tex">y\in\mathbb{Z}/p\mathbb{Z}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.7335400000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathbb">Z</span></span><span class="mord">/</span><span class="mord mathdefault">p</span><span class="mord"><span class="mord mathbb">Z</span></span></span></span></span> such that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>y</mi><mn>2</mn></msup><mo>=</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">y^2=a</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.008548em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span> if and only if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>a</mi><mrow><mi>p</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow></msup><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">a^{p/2}=1</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8879999999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">p</span><span class="mord mtight">/</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>."</p>



<a name="185573149"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/words/near/185573149" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/words.html#185573149">(Jan 14 2020 at 08:12)</a>:</h4>
<p>eew that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">p/2</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mord">/</span><span class="mord">2</span></span></span></span> looks so ugly ;-) I would always write <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>a</mi><mrow><mo stretchy="false">(</mo><mi>p</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn></mrow></msup><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">a^{(p-1)/2}=1</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8879999999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight">p</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span><span class="mord mtight">/</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>...</p>



<a name="185576483"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/words/near/185576483" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/words.html#185576483">(Jan 14 2020 at 09:10)</a>:</h4>
<p>I think we can all agree that almost every mathematicians simply don't have symbols for "and", "or" and "not". And we indeed write a lot of sentences. <em>But</em> we don't write formulas with quantifiers as words. Jeremy's statement of the Euler criterion looks nothing like mathematics to me. I would either write a full sentence like Kevin did or a formula using symbols for quantifiers and equivalences. Having a controlled natural language parser for Lean would be something interesting. But until that happens, please <em>please</em> don't give us ugly Coq-like formulas.</p>



<a name="185577265"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/words/near/185577265" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/words.html#185577265">(Jan 14 2020 at 09:21)</a>:</h4>
<p>We do write things like</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi><mo stretchy="false">(</mo><mfrac><mrow><msub><mi>g</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>g</mi><mi>n</mi></msub></mrow><mi>f</mi></mfrac><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">{</mo><mi>x</mi><mo>∣</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo mathvariant="normal">≠</mo><mn>0</mn><mtext> and </mtext><mi mathvariant="normal">∣</mi><msub><mi>g</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi><mo>≤</mo><mi mathvariant="normal">∣</mi><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi><mtext> for all </mtext><mi>i</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">U(\frac{g_1, \ldots, g_n}{f}) = \{ x \mid f(x) \ne 0 \text{ and } |g_i(x)| \le |f(x)| \text{ for all } i\}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.2311079999999999em;vertical-align:-0.481108em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7475em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.446108em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:-0.03588em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mpunct mtight">,</span><span class="minner mtight">…</span><span class="mpunct mtight">,</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:-0.03588em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.481108em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mord text"><span class="mord"> and </span></span><span class="mord">∣</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mord">∣</span><span class="mord text"><span class="mord"> for all </span></span><span class="mord mathdefault">i</span><span class="mclose">}</span></span></span></span></p>



<a name="185577405"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/words/near/185577405" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/words.html#185577405">(Jan 14 2020 at 09:23)</a>:</h4>
<p>At least, I see that quite often. (Especially putting quantifiers at the end of a sentence <span aria-label="rolling on the floor laughing" class="emoji emoji-1f923" role="img" title="rolling on the floor laughing">:rolling_on_the_floor_laughing:</span>)</p>



<a name="185577831"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/words/near/185577831" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/words.html#185577831">(Jan 14 2020 at 09:28)</a>:</h4>
<p>Johan -- the original version of that definition had <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><msub><mi>g</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi><mo>≤</mo><mi mathvariant="normal">∣</mi><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi><mo>≠</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">|g_i(x)|\leq|f(x)|\not=0</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> and I initially mis-formalised it when doing the perfectoid project! If the index set of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>'s was empty then <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>≠</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">f(x)\not=0</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> was omitted. I only noticed when I started formalising lemmas about the sets ;-) Mathematicians are sloppy!</p>



<a name="185578858"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/words/near/185578858" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris B <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/words.html#185578858">(Jan 14 2020 at 09:43)</a>:</h4>
<p>I think this kind of stuff that lies right at the contact point between the user and the computer is mad important, but if you surveyed 50 Lean users about which language items they prefer as symbols/words I think you'd get 50 different responses. It would be nice if you could tell the editor extension which representation you prefer for a given language item. There are VSCode extensions that have features which can overlay text in the buffer you're working on without actually changing the source code but I don't know how intrusive those are on the implementation side.</p>



<a name="185657981"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/words/near/185657981" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Reichelt <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/words.html#185657981">(Jan 15 2020 at 00:57)</a>:</h4>
<p>I hope it's OK if I chime in, as I'm doing something that's similar to natural-language input for formal math. In my alternative approach, the user selects the natural-language content from menus, so the text never has to be parsed because it was already formal internally. As a result, the user doesn't have quite as much choice, but here is how Euclid's criterion turned out (I hope I didn't mess it up): <a href="https://slate-prover.herokuapp.com/libraries/hlm/Algebra/Fields/Prime%20fields/Eulers%20criterion" target="_blank" title="https://slate-prover.herokuapp.com/libraries/hlm/Algebra/Fields/Prime%20fields/Eulers%20criterion">https://slate-prover.herokuapp.com/libraries/hlm/Algebra/Fields/Prime%20fields/Eulers%20criterion</a><br>
To get an idea how this is entered, you can click the "edit" button or create a new definition or theorem. But a lot of things are not finished yet, including proof input.<br>
The reason I think this "reverse approach" works better than plain natural-language input is that with the latter, it is not easy for an inexperienced user to find out what the system will or will not accept.</p>



<a name="185708275"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/words/near/185708275" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jeremy Avigad <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/words.html#185708275">(Jan 15 2020 at 15:30)</a>:</h4>
<p>Nobody is claiming that the examples I posted look like ordinary mathematics, but I found it striking that the trivial syntactic substitutions made the expressions easier and more pleasant for me to read, despite the fact that, as a logician, I have been steeped in logical notation every day of my adult life.</p>
<p>Of course, readability is a subjective thing. We'd have to resort to polls and psychological experiments for anything like hard data. But Tom Hales, Peter Koepke, and all the people before them who have emphasized the importance of natural language are right that readability is important to make the technology attractive.</p>
<p>By the way, in his talk, Tom Hales mentioned the "harder direction," translating formal expressions into something approximating natural language. Many years ago, an MS student of mine, Steve Kieffer, did that: <br>
<a href="http://www.andrew.cmu.edu/user/avigad/Papers/mkm/index.html" target="_blank" title="http://www.andrew.cmu.edu/user/avigad/Papers/mkm/index.html">http://www.andrew.cmu.edu/user/avigad/Papers/mkm/index.html</a><br>
<a href="http://www.andrew.cmu.edu/user/avigad/Papers/mkm/munkres.pdf" target="_blank" title="http://www.andrew.cmu.edu/user/avigad/Papers/mkm/munkres.pdf">http://www.andrew.cmu.edu/user/avigad/Papers/mkm/munkres.pdf</a><br>
Tom is right that the output text does have a run-on computer-generated feel, but I think is is surprisingly reasonable. (The natural-language component wasn't even in Steve's MS thesis, which had only the formal expressions. We generated them afterwards using some very simple heuristics.)</p>
<p>I was happy that Steve came to the meeting last week. He is currently working on graphical tools for exploring / teaching mathematics (<a href="https://royalroadmath.org/newpfsc.html" target="_blank" title="https://royalroadmath.org/newpfsc.html">https://royalroadmath.org/newpfsc.html</a>). It would be nice to have something like that to explore mathlib, perfectoids, etc.</p>



<a name="185713788"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/words/near/185713788" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/words.html#185713788">(Jan 15 2020 at 16:19)</a>:</h4>
<p>Thanks for the pointer to that file by Steve Kieffer. I agree that there is too much stuff in the output text to make it feel "natural". But I guess using typing information could certainly improve that.</p>



<a name="185713808"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/words/near/185713808" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/words.html#185713808">(Jan 15 2020 at 16:19)</a>:</h4>
<p>As well natural language analogues of implicit variables and type classes.</p>



<a name="185714060"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/words/near/185714060" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/words.html#185714060">(Jan 15 2020 at 16:21)</a>:</h4>
<p>Can somebody tell me why I want to write <code>k[X₁,X₂,…Xₙ]</code> and I have to write <code>mv_polynomial (fin n) k</code>, and why I want to write <code>kⁿ</code> and I have to write <code>fin n → k</code>, in my algebraic geometry course? Is this to do with words, or is notation something else?</p>



<a name="185714164"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/words/near/185714164" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/words.html#185714164">(Jan 15 2020 at 16:22)</a>:</h4>
<p><code>k[X₁,X₂,…Xₙ]</code> and <code>kⁿ</code> are tokens which I would happily use in sentences in a maths paper -- in prose, I mean.</p>



<a name="185714384"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/words/near/185714384" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/words.html#185714384">(Jan 15 2020 at 16:24)</a>:</h4>
<p>The parser doesn't know that <code>ⁿ</code> has anything to do with <code>n</code> I guess.</p>



<a name="185714514"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/words/near/185714514" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/words.html#185714514">(Jan 15 2020 at 16:25)</a>:</h4>
<p>Is this fixed in Lean 4? My readers are pretty good at spotting this.</p>



<a name="185723712"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/words/near/185723712" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/words.html#185723712">(Jan 15 2020 at 17:50)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> But you don't type <code>kⁿ</code> into LaTeX either.</p>



<a name="185723742"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/words/near/185723742" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/words.html#185723742">(Jan 15 2020 at 17:50)</a>:</h4>
<p>So maybe there could be some intermediate form... which is exactly what Hales and Koepke are going for, I think.</p>



<a name="185903577"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/words/near/185903577" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/words.html#185903577">(Jan 17 2020 at 10:29)</a>:</h4>
<blockquote>
<p>The parser doesn't know that <code>ⁿ</code> has anything to do with <code>n</code> I guess.</p>
</blockquote>
<p>Yes, that is a first issue. We <em>can</em> tell both Lean 3 (I think) and Lean 4 to interpret <code>xⁿ</code> (for any <code>x</code>, but specifically for <code>ⁿ</code>) as <code>x ^ n</code>, though it should be a bit simpler to implement in Lean 4. And then of course we can overload <code>^</code> to mean a function space if the LHS is a type and hope that Lean can disambiguate it. Perhaps not a great idea in general, but acceptable in specific contexts?</p>



<a name="185903676"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/words/near/185903676" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/words.html#185903676">(Jan 17 2020 at 10:31)</a>:</h4>
<p>what happens with name resolution here?</p>



<a name="185903696"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/words/near/185903696" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/words.html#185903696">(Jan 17 2020 at 10:31)</a>:</h4>
<p>(does lean have "hygienic notation"?)</p>



<a name="185906975"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/words/near/185906975" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/words.html#185906975">(Jan 17 2020 at 11:25)</a>:</h4>
<p><code>notation</code> is always hygienic in Lean 3 &amp; Lean 4:</p>
<div class="codehilite"><pre><span></span>postfix `ⁿ`:100 := λ x, x ^ n
</pre></div>


<p>does not work because <code>n</code> is unbound. However, every good hygienic macro system also allows hygiene-bending operations, which in Lean 4 you can use like</p>
<div class="codehilite"><pre><span></span>macro (x : term) &quot;ⁿ&quot;:100 =&gt; `(x ^ $(mkTermId `n))
</pre></div>


<p>Now <code>n</code> will be resolved in the caller's scope, not the macro declaration's scope.</p>



<a name="185934908"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/words/near/185934908" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/words.html#185934908">(Jan 17 2020 at 16:54)</a>:</h4>
<p>In this part of my course, n is fixed once and for all, so I would at this point be happy if I could just have a <em>token</em> <code>kⁿ</code> meaning <code>n -&gt; k</code></p>



<a name="186057060"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/words/near/186057060" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/words.html#186057060">(Jan 19 2020 at 21:27)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> If <code>n</code> and <code>k</code> are both <code>variable/parameter</code>s, <code>notation `kⁿ` := n -&gt; k</code> should work in Lean 3, no?</p>



<a name="186057438"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/words/near/186057438" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/words.html#186057438">(Jan 19 2020 at 21:38)</a>:</h4>
<div class="codehilite"><pre><span></span>invalid notation declaration, contains reference to local variables
</pre></div>



<a name="186057450"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/words/near/186057450" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/words.html#186057450">(Jan 19 2020 at 21:39)</a>:</h4>
<p>Ah, should be <code>local notation</code> I assume?</p>



<a name="186057518"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/words/near/186057518" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/words.html#186057518">(Jan 19 2020 at 21:40)</a>:</h4>
<p>Oh this is great :D</p>



<a name="186057593"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/words/near/186057593" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/words.html#186057593">(Jan 19 2020 at 21:43)</a>:</h4>
<p>Just not very general or reusable :) . But for use in a single file it's probably fine, yes.</p>



<a name="186057722"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/words/near/186057722" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/words.html#186057722">(Jan 19 2020 at 21:46)</a>:</h4>
<p>(fun fact: <code>ⁿ</code> is a valid character in a name in Lean 3. Other superscripts have been removed at some point, I removed <code>ⁿ</code> as well now in Lean 4 so that the macro above can indeed work: <a href="https://github.com/leanprover/lean4/blob/master/tests/lean/run/kevin.lean#L6" target="_blank" title="https://github.com/leanprover/lean4/blob/master/tests/lean/run/kevin.lean#L6">https://github.com/leanprover/lean4/blob/master/tests/lean/run/kevin.lean#L6</a>)</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
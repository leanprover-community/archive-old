---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/A.20possible.20diamond.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html">A possible diamond</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="260154299"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260154299" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260154299">(Nov 03 2021 at 15:51)</a>:</h4>
<p>In a proof I am working on I got an error I don't fully understand, and it's possibly a diamond. The error is in <a href="https://github.com/leanprover-community/flt-regular/blob/RB_poss_diam/src/number_theory/discriminant/basic.lean#L190">number_theory/discriminant/basic</a>, in the <code>flt-regular</code> repo, branch <code>RB_possible_diam</code>. Before spending some time to provide a minimal example, I would ask if someone immediately recognize the error. The type of <code>this</code> and the goal are quite long with <code>set_option pp.all true</code>, but almost identical. <code>diff</code> tells me that the only difference is</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>             <span class="bp">@</span><span class="n">subtype.decidable_eq.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span>
               <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">nat</span><span class="o">),</span>
                  <span class="bp">@</span><span class="n">has_lt.lt.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_lt</span> <span class="n">x</span>
                    <span class="o">(</span><span class="bp">@</span><span class="n">power_basis.dim.</span><span class="o">{</span><span class="n">u</span> <span class="n">v</span><span class="o">}</span> <span class="n">K</span> <span class="n">L</span>
                       <span class="o">(</span><span class="bp">@</span><span class="n">euclidean_domain.to_comm_ring.</span><span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="n">K</span> <span class="o">(</span><span class="bp">@</span><span class="n">field.to_euclidean_domain.</span><span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="n">K</span> <span class="n">_inst_7</span><span class="o">))</span>
                       <span class="o">(</span><span class="bp">@</span><span class="n">division_ring.to_ring.</span><span class="o">{</span><span class="n">v</span><span class="o">}</span> <span class="n">L</span> <span class="o">(</span><span class="bp">@</span><span class="n">field.to_division_ring.</span><span class="o">{</span><span class="n">v</span><span class="o">}</span> <span class="n">L</span> <span class="n">_inst_8</span><span class="o">))</span>
                       <span class="n">_inst_10</span> <span class="n">pb</span><span class="o">))</span>
               <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">nat</span><span class="o">),</span> <span class="n">nat.decidable_eq</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span>
</code></pre></div>
<p>instead of</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>             <span class="n">classical.prop_decidable</span>
               <span class="o">(</span><span class="bp">@</span><span class="n">eq.</span><span class="o">{</span><span class="mi">1</span><span class="o">}</span>
                  <span class="o">(</span><span class="n">fin</span>
                     <span class="o">(</span><span class="bp">@</span><span class="n">power_basis.dim.</span><span class="o">{</span><span class="n">u</span> <span class="n">v</span><span class="o">}</span> <span class="n">K</span> <span class="n">L</span>
                        <span class="o">(</span><span class="bp">@</span><span class="n">euclidean_domain.to_comm_ring.</span><span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="n">K</span> <span class="o">(</span><span class="bp">@</span><span class="n">field.to_euclidean_domain.</span><span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="n">K</span> <span class="n">_inst_7</span><span class="o">))</span>
                        <span class="o">(</span><span class="bp">@</span><span class="n">division_ring.to_ring.</span><span class="o">{</span><span class="n">v</span><span class="o">}</span> <span class="n">L</span> <span class="o">(</span><span class="bp">@</span><span class="n">field.to_division_ring.</span><span class="o">{</span><span class="n">v</span><span class="o">}</span> <span class="n">L</span> <span class="n">_inst_8</span><span class="o">))</span>
                        <span class="n">_inst_10</span> <span class="n">pb</span><span class="o">))</span> <span class="n">a</span> <span class="n">b</span><span class="o">))</span>
</code></pre></div>
<p>Does someone recognize this error?</p>



<a name="260154664"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260154664" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260154664">(Nov 03 2021 at 15:53)</a>:</h4>
<p>There's probably a mis-stated lemma somewhere</p>



<a name="260154704"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260154704" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260154704">(Nov 03 2021 at 15:53)</a>:</h4>
<p>Which of those is your goal, and which is the lemma application?</p>



<a name="260155237"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260155237" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260155237">(Nov 03 2021 at 15:57)</a>:</h4>
<p>The goal is</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="o">(</span><span class="n">vandermonde</span> <span class="o">(</span><span class="bp">⇑</span><span class="o">(</span><span class="n">algebra_map</span> <span class="n">L</span> <span class="n">E</span><span class="o">)</span> <span class="bp">∘</span> <span class="bp">⇑</span><span class="o">(</span><span class="n">pb.basis</span><span class="o">)))</span><span class="bp">.</span><span class="n">det</span> <span class="bp">^</span> <span class="mi">2</span> <span class="bp">=</span> <span class="mi">0</span>
</code></pre></div>
<p>that is also the type of <code>this</code> (without <code>set_option pp.all true</code>). Let me see if I can produce a reasonable self contained example.</p>



<a name="260155287"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260155287" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260155287">(Nov 03 2021 at 15:57)</a>:</h4>
<p>The error goes away if I get rid of the open locale classical and add all the decidable_eq iota arguments lean asks for</p>



<a name="260155561"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260155561" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260155561">(Nov 03 2021 at 15:59)</a>:</h4>
<p>Being a stupid mathematician who doesn't know anything about <code>classical</code> I am very happy with this solution</p>



<a name="260156222"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260156222" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260156222">(Nov 03 2021 at 16:03)</a>:</h4>
<p>Right, the underlying problem is either:</p>
<ul>
<li>you have a definition without a <code>decidable</code> argument (fine), but you <code>unfold</code> it  (not fine) rather than adding a lemma that introduces the <code>decidable</code> argument</li>
<li>you have a lemma that needs a <code>decidable</code> argument in its _statement_, but you let it fall back to the classical one (not fine)</li>
</ul>



<a name="260156282"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260156282" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260156282">(Nov 03 2021 at 16:03)</a>:</h4>
<p>Can you paste a permalink to the relevant lines?</p>



<a name="260156481"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260156481" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260156481">(Nov 03 2021 at 16:04)</a>:</h4>
<p><a href="https://github.com/leanprover-community/flt-regular/blob/71b6e4152b6a18647cc001c8fee2afcc501e70ae/src/number_theory/discriminant/basic.lean#L190">Here it is</a></p>



<a name="260156726"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260156726" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260156726">(Nov 03 2021 at 16:06)</a>:</h4>
<p>Note that both the lemma and <code>this</code> are actually false, but it doesn't matter.</p>



<a name="260158388"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260158388" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260158388">(Nov 03 2021 at 16:18)</a>:</h4>
<p><del>Gitpod seems to run out of memory while trying to open that unfortunately...</del> I had a bad cache</p>



<a name="260159027"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260159027" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260159027">(Nov 03 2021 at 16:22)</a>:</h4>
<p>I've <a href="https://github.com/leanprover-community/flt-regular/blob/ee10a50e9c2c2e3b1da55a5551d0fba548ed550a/src/number_theory/discriminant/basic.lean#L190">sorried</a> the error</p>



<a name="260159065"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260159065" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260159065">(Nov 03 2021 at 16:23)</a>:</h4>
<p><code>exact this</code> should close the goal, but it doesn't.</p>



<a name="260159127"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260159127" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260159127">(Nov 03 2021 at 16:23)</a>:</h4>
<p>As Alex suggests, you should remove <code>open_locale classical</code>, add <code>decidable</code> to all the lemmas with complaints in their statements, then add back <code>open_locale classical</code></p>



<a name="260159148"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260159148" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260159148">(Nov 03 2021 at 16:23)</a>:</h4>
<p>In any case I am trying to avoid <code>open_locale classical</code> and adding <code>decidable_eq ι</code> where is needed.</p>



<a name="260159247"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260159247" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260159247">(Nov 03 2021 at 16:24)</a>:</h4>
<p>Ah, I should have <em>both</em> <code>open_locale classical</code> and <code>decidable_eq ι</code>?</p>



<a name="260159288"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260159288" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260159288">(Nov 03 2021 at 16:24)</a>:</h4>
<p>No no no.</p>



<a name="260159320"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260159320" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260159320">(Nov 03 2021 at 16:25)</a>:</h4>
<p>What you <em>don't</em> want is to put a <code>classical.dec_something</code> into the <em>type</em> of a lemma.</p>



<a name="260159359"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260159359" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260159359">(Nov 03 2021 at 16:25)</a>:</h4>
<p><span class="user-mention silent" data-user-id="130384">Riccardo Brasca</span> <a href="#narrow/stream/113488-general/topic/A.20possible.20diamond/near/260159247">said</a>:</p>
<blockquote>
<p>Ah, I should have <em>both</em> <code>open_locale classical</code> and <code>decidable_eq ι</code>?</p>
</blockquote>
<p>Only if you want the former. It's fine to have it if it makes things convenient inside <code>def</code>s and proofs, but it can lead to traps in lemmas</p>



<a name="260159365"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260159365" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260159365">(Nov 03 2021 at 16:25)</a>:</h4>
<p>It's fine if it's in the <em>proof</em>, because you never need to match the proof.</p>



<a name="260159396"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260159396" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260159396">(Nov 03 2021 at 16:25)</a>:</h4>
<p>In proofs you can always use <a href="https://leanprover-community.github.io/mathlib_docs/tactics.html#classical">tactic#classical</a>, which is less of a trap</p>



<a name="260159403"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260159403" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260159403">(Nov 03 2021 at 16:25)</a>:</h4>
<p>That's what the <code>classical</code> linter checks.</p>



<a name="260159520"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260159520" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260159520">(Nov 03 2021 at 16:26)</a>:</h4>
<p>I think the best approach is:</p>
<ul>
<li>Use the <code>classical</code> tactic in proofs that need it</li>
<li>For noncomputable defs, create a very small section around only the def, and use <code>open_locale classical</code> in that section</li>
</ul>



<a name="260159581"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260159581" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260159581">(Nov 03 2021 at 16:26)</a>:</h4>
<p>Having <code>open_locale classical</code> at the top is a trap waiting to be sprung</p>



<a name="260159864"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260159864" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260159864">(Nov 03 2021 at 16:29)</a>:</h4>
<p>So for instance;</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="c1">-- it's fine to use the classical decidable_eq argument inside this def, because it's already</span>
<span class="c1">-- noncomputable anyway</span>
<span class="kn">section</span>
<span class="n">open_locale</span> <span class="n">classical</span>
<span class="sd">/-- Given an `A`-algebra `B` and `b`, an `ι`-indexed family of elements of `B`, we define</span>
<span class="sd">`discriminant A ι b` as the determinant of `trace_matrix A ι b`. -/</span>
<span class="kd">def</span> <span class="n">discriminant</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">ι</span><span class="o">]</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">B</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">trace_matrix</span> <span class="n">A</span> <span class="n">b</span><span class="o">)</span><span class="bp">.</span><span class="n">det</span>
<span class="kd">end</span>

<span class="c1">-- this needs a `decidable_eq` argument otherwise it's not general enough</span>
<span class="kd">lemma</span> <span class="n">discriminant_def</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">ι</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">ι</span><span class="o">]</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">discriminant</span> <span class="n">A</span> <span class="n">b</span> <span class="bp">=</span> <span class="o">(</span><span class="n">trace_matrix</span> <span class="n">A</span> <span class="n">b</span><span class="o">)</span><span class="bp">.</span><span class="n">det</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">convert</span> <span class="n">rfl</span>
</code></pre></div>



<a name="260160284"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260160284" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260160284">(Nov 03 2021 at 16:32)</a>:</h4>
<p>Sorry for the stupid question, but is this the same as adding <code>[decidable_eq ι]</code> to the def?</p>



<a name="260160304"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260160304" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260160304">(Nov 03 2021 at 16:32)</a>:</h4>
<p>And in any case I should add <code>noncomputable</code>, right?</p>



<a name="260161433"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260161433" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260161433">(Nov 03 2021 at 16:39)</a>:</h4>
<p>You should write a small tutorial for mathematicians <span aria-label="rolling on the floor laughing" class="emoji emoji-1f923" role="img" title="rolling on the floor laughing">:rolling_on_the_floor_laughing:</span> . I've always thought putting</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">open_locale</span> <span class="n">classical</span>
<span class="kd">noncomputable theory</span>
</code></pre></div>
<p>at the beginning of the file means "let's do standard mathematics and forget about this CS stuff".</p>



<a name="260161645"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260161645" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260161645">(Nov 03 2021 at 16:41)</a>:</h4>
<p>One of the "I don't care about decidability" solutions/band-aids is to use <code>convert</code> (and sometimes <code>convert_to</code>) in place of <code>exact</code>. It's able to deal with differing decidable instances.</p>



<a name="260161708"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260161708" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260161708">(Nov 03 2021 at 16:41)</a>:</h4>
<p>(I haven't looked at what you're doing to see if it applies, but it can be a useful way to avoid redesigning definitions, even if that might be the right thing to do.)</p>



<a name="260161872"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260161872" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260161872">(Nov 03 2021 at 16:42)</a>:</h4>
<p><span class="user-mention silent" data-user-id="130384">Riccardo Brasca</span> <a href="#narrow/stream/113488-general/topic/A.20possible.20diamond/near/260160284">said</a>:</p>
<blockquote>
<p>Sorry for the stupid question, but is this the same as adding <code>[decidable_eq ι]</code> to the def?</p>
</blockquote>
<p>No, because adding <code>decidable_eq ι</code> means that all the lemmas about it need to as well</p>



<a name="260161949"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260161949" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260161949">(Nov 03 2021 at 16:43)</a>:</h4>
<p><span class="user-mention silent" data-user-id="130384">Riccardo Brasca</span> <a href="#narrow/stream/113488-general/topic/A.20possible.20diamond/near/260160304">said</a>:</p>
<blockquote>
<p>And in any case I should add <code>noncomputable</code>, right?</p>
</blockquote>
<p>You have <code>noncomputable theory</code> at the top of the file so that's not needed. If you want to remind yourself which things are computable, then remove <code>noncomputable theory</code> and add <code>noncomputable</code> wherever lean complains.</p>



<a name="260162113"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260162113" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260162113">(Nov 03 2021 at 16:44)</a>:</h4>
<p><code>noncomputable theory</code>is indeed an "I don't care about this" lever, but <code>open_locale classical</code> just hides it until it bites you later</p>



<a name="260162438"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260162438" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260162438">(Nov 03 2021 at 16:46)</a>:</h4>
<p><span class="user-mention silent" data-user-id="130384">Riccardo Brasca</span> <a href="#narrow/stream/113488-general/topic/A.20possible.20diamond/near/260161433">said</a>:</p>
<blockquote>
<p>You should write a small tutorial for mathematicians <span aria-label="rolling on the floor laughing" class="emoji emoji-1f923" role="img" title="rolling on the floor laughing">:rolling_on_the_floor_laughing:</span> . I've always thought putting</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">open_locale</span> <span class="n">classical</span>
<span class="kd">noncomputable theory</span>
</code></pre></div>
<p>at the beginning of the file means "let's do standard mathematics and forget about this CS stuff".</p>
</blockquote>
<p>Perhaps we should have a new library note on this topic?</p>



<a name="260162948"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260162948" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260162948">(Nov 03 2021 at 16:50)</a>:</h4>
<p>If I do</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">section</span>
<span class="n">open_locale</span> <span class="n">classical</span>
<span class="sd">/-- Given an `A`-algebra `B` and `b`, an `ι`-indexed family of elements of `B`, we define</span>
<span class="sd">`discriminant A ι b` as the determinant of `trace_matrix A ι b`. -/</span>
<span class="kd">noncomputable</span>
<span class="kd">def</span> <span class="n">discriminant</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">ι</span><span class="o">]</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">B</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">trace_matrix</span> <span class="n">A</span> <span class="n">b</span><span class="o">)</span><span class="bp">.</span><span class="n">det</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">discriminant_def</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">ι</span><span class="o">]</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="n">discriminant</span> <span class="n">A</span> <span class="n">b</span> <span class="bp">=</span> <span class="o">(</span><span class="n">trace_matrix</span> <span class="n">A</span> <span class="n">b</span><span class="o">)</span><span class="bp">.</span><span class="n">det</span> <span class="o">:=</span> <span class="n">rfl</span>
</code></pre></div>
<p>it immediately complains because <code>failed to synthesize type class instance for... [decidable_eq ι]</code>. And if I add it I am not able to prove the lemma anymore. I am sure I am doing something wrong here...</p>



<a name="260163082"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260163082" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260163082">(Nov 03 2021 at 16:51)</a>:</h4>
<p>Right, that's why in my comment I said:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="c1">-- this needs a `decidable_eq` argument otherwise it's not general enough</span>
<span class="kd">lemma</span> <span class="n">discriminant_def</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">ι</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">ι</span><span class="o">]</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">discriminant</span> <span class="n">A</span> <span class="n">b</span> <span class="bp">=</span> <span class="o">(</span><span class="n">trace_matrix</span> <span class="n">A</span> <span class="n">b</span><span class="o">)</span><span class="bp">.</span><span class="n">det</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">convert</span> <span class="n">rfl</span>
</code></pre></div>



<a name="260163137"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260163137" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260163137">(Nov 03 2021 at 16:51)</a>:</h4>
<p>That lemma needs <code>[decidable_eq ι]</code> because it's about <code>trace_matrix</code></p>



<a name="260163169"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260163169" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260163169">(Nov 03 2021 at 16:51)</a>:</h4>
<p>And one of the arguments to <code>trace_matrix</code> needs <code>decidable_eq</code></p>



<a name="260163411"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260163411" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260163411">(Nov 03 2021 at 16:53)</a>:</h4>
<p>OK, I don't care to add <code>[decidable_eq ι]</code>, but <code>rfl</code> doesn't prove it.</p>



<a name="260164953"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260164953" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260164953">(Nov 03 2021 at 17:02)</a>:</h4>
<p>Right, you need <code>by convert rfl</code>  because you have to prove the two different decidable instances are equal</p>



<a name="260164975"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260164975" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260164975">(Nov 03 2021 at 17:02)</a>:</h4>
<p>One of the tools in the toolbox for the mathematician who doesn't care about decidability is <code>by convert rfl</code>. Not sure if that works here</p>



<a name="260165038"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260165038" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260165038">(Nov 03 2021 at 17:03)</a>:</h4>
<p>It doesn't <span aria-label="unamused" class="emoji emoji-1f612" role="img" title="unamused">:unamused:</span></p>



<a name="260165141"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260165141" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260165141">(Nov 03 2021 at 17:03)</a>:</h4>
<p>Sorry, it does</p>



<a name="260165150"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260165150" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260165150">(Nov 03 2021 at 17:03)</a>:</h4>
<p>I'm confused Riccardo; it worked in <a href="#narrow/stream/113488-general/topic/A.20possible.20diamond/near/260159864">the snippet I posted</a></p>



<a name="260165376"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260165376" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260165376">(Nov 03 2021 at 17:04)</a>:</h4>
<p><del>I think you're running into this because <a href="https://leanprover-community.github.io/mathlib_docs/find/algebra.trace_form">docs#algebra.trace_form</a> needs a <code>decidable_eq</code> argument, but you could argue "it's noncomputable anyway, what's the point"</del></p>



<a name="260165450"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260165450" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260165450">(Nov 03 2021 at 17:05)</a>:</h4>
<p><del>If you replaced that argument with the classical instance in the definition of <a href="https://leanprover-community.github.io/mathlib_docs/find/algebra.trace_form">docs#algebra.trace_form</a>, then all the pain would fall inside mathlib and flt-regular wouldn't run into it</del></p>



<a name="260165752"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260165752" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260165752">(Nov 03 2021 at 17:07)</a>:</h4>
<p>It's <code>det</code> that requires a <code>decidable_eq</code> I think, not <code>trace_form</code>.</p>



<a name="260165903"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260165903" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260165903">(Nov 03 2021 at 17:08)</a>:</h4>
<p>There is no <code>decidable_eq</code> in <a href="https://leanprover-community.github.io/mathlib_docs/find/algebra.trace_form">docs#algebra.trace_form</a> if I am not blind.</p>



<a name="260166042"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260166042" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260166042">(Nov 03 2021 at 17:09)</a>:</h4>
<p>Ah you're right</p>



<a name="260166764"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260166764" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260166764">(Nov 03 2021 at 17:15)</a>:</h4>
<p>OK, things are better and better. But now <a href="https://github.com/leanprover-community/flt-regular/blob/7f84b5577445cf900e6f29a99f682761034d2d34/src/number_theory/discriminant/basic.lean#L114">this</a> line has become very slow. It think that everything comes from <code> ¬discriminant A b = 0</code> and <code> discriminant A b ≠ 0</code>, but I am not even sure what <code>≠</code> means.</p>



<a name="260167649"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260167649" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260167649">(Nov 03 2021 at 17:21)</a>:</h4>
<p><code>decidable_eq</code> only matters when an <code>ite</code> / <code>if</code> is involved. It doesn't affect what <code>=</code> means</p>



<a name="260168096"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260168096" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260168096">(Nov 03 2021 at 17:25)</a>:</h4>
<p>Maybe it's because I removed <code>open_locale classical</code> or whatever, but in practice the proofs where <code>≠</code> is involved are now broken.</p>



<a name="260168167"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260168167" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260168167">(Nov 03 2021 at 17:25)</a>:</h4>
<p>I'm waiting for gitpod...</p>



<a name="260168340"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260168340" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260168340">(Nov 03 2021 at 17:27)</a>:</h4>
<p>Anywhere you do <code>rw discriminant</code> you introduce a diamond</p>



<a name="260168375"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260168375" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260168375">(Nov 03 2021 at 17:27)</a>:</h4>
<p>You have to use <code>rw discriminant_def</code> instead</p>



<a name="260168504"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260168504" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260168504">(Nov 03 2021 at 17:28)</a>:</h4>
<p>Ah, this is good to know!</p>



<a name="260168689"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260168689" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260168689">(Nov 03 2021 at 17:29)</a>:</h4>
<p>The problem you're running into with that <code>by convert h</code> line is weird</p>



<a name="260168728"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260168728" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260168728">(Nov 03 2021 at 17:30)</a>:</h4>
<p>It looks like it might be a bug in the <code>classical</code> tactic</p>



<a name="260168830"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260168830" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260168830">(Nov 03 2021 at 17:30)</a>:</h4>
<p>In that without the <code>by convert</code> it fails with:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">synthesized</span> <span class="n">type</span> <span class="kd">class</span> <span class="kd">instance</span> <span class="n">is</span> <span class="n">not</span> <span class="n">definitionally</span> <span class="n">equal</span> <span class="n">to</span> <span class="n">expression</span> <span class="n">inferred</span> <span class="kd">by</span> <span class="n">typing</span> <span class="n">rules</span><span class="o">,</span> <span class="n">synthesized</span>
  <span class="bp">λ</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ι</span><span class="o">),</span> <span class="n">_inst</span> <span class="o">(</span><span class="n">a</span> <span class="bp">=</span> <span class="n">b</span><span class="o">)</span>
<span class="n">inferred</span>
  <span class="bp">λ</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ι</span><span class="o">),</span> <span class="n">classical.prop_decidable</span> <span class="o">(</span><span class="n">a</span> <span class="bp">=</span> <span class="n">b</span><span class="o">)</span>
</code></pre></div>
<p>But <code>_inst</code> is precisely <code>classical.prop_decidable</code>, <a href="https://leanprover-community.github.io/mathlib_docs/tactics.html#classical">tactic#classical</a> just isn't letting you know that</p>



<a name="260169030"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260169030" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260169030">(Nov 03 2021 at 17:32)</a>:</h4>
<p>Writing <code>discriminant_def</code> instead of <code>discriminant</code> indeed fixes all the issues!</p>



<a name="260169075"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260169075" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260169075">(Nov 03 2021 at 17:32)</a>:</h4>
<p>Not the slowdown though, right?</p>



<a name="260169131"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260169131" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260169131">(Nov 03 2021 at 17:33)</a>:</h4>
<p>No</p>



<a name="260169677"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260169677" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260169677">(Nov 03 2021 at 17:37)</a>:</h4>
<p>On gitpod this takes forever:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">zero_of_not_linear_independent</span> <span class="o">[</span><span class="n">is_domain</span> <span class="n">A</span><span class="o">]</span> <span class="o">{</span><span class="n">b</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">B</span><span class="o">}</span> <span class="o">(</span><span class="n">hli</span> <span class="o">:</span> <span class="bp">¬</span><span class="n">linear_independent</span> <span class="n">A</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">discriminant</span> <span class="n">A</span> <span class="n">b</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">by_contra</span> <span class="n">h</span><span class="o">,</span>
  <span class="gr">sorry</span>
<span class="kd">end</span>
</code></pre></div>
<p>Is this just gitpod?</p>



<a name="260169853"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260169853" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260169853">(Nov 03 2021 at 17:39)</a>:</h4>
<p>Same here, I had to add <code>classical</code> at the beginning of the proof.</p>



<a name="260169891"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260169891" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260169891">(Nov 03 2021 at 17:39)</a>:</h4>
<p>My short (and incomplete and opinionated) tutorial for mathematicians who don't want to learn much about decidability but still want to contribute to mathlib:</p>
<p>Decidability is a mechanism for helping us write definitions that are "computable," which has something to do with constructive mathematics, something classical mathematicians tend not to be familiar with.  We say a <code>Prop</code> is decidable if there is some algorithm that can decide whether it is true or false; Godel proved no such algorithm exists for all <code>Prop</code>s.  In classical mode, we pretend there is a noncomputable "algorithm" that can make these decisions.</p>
<ol>
<li>Feel free to use <code>open_locale classical</code> and <code>noncomputable theory</code>. It will likely lead to less work down the road if you use the <code>classical</code> tactic instead of <code>open_locale classical</code>, but then you'll need to add all the <code>decidable</code> instances Lean will ask you for.  It's up to you to decide which road to take.</li>
<li>Sometimes you will have things that will surprisingly not rewrite, or you'll have <code>exact</code>s that won't go through.  This might be because of decidable instances not lining up (from the fake classical one being equal to but not being defeq to a real decidable instance). Try using <code>convert_to</code> to "refresh" these instances, or to surgically change one part of an expression to create a new goal that looks like the rw lemma you're trying to use; in this case, you can usually use <code>convert</code> to apply the rw lemma.  For example, if both sides look the same but <code>refl</code> doesn't work, try <code>convert rfl</code>.</li>
<li>When you submit a PR to mathlib, be prepared for decidability experts to help you reconfigure your code to be more general (and maybe for them to tell you how much of a mess you've made of things -- but proving things at all is usually the hard part). This work will help people in the future avoid needing to use these <code>convert</code>/<code>convert_to</code> tricks.</li>
</ol>
<p>It can also be worth running things by the decidability experts on Zulip ahead of time, since they'll likely have tricks to make a lot of this decidability wrangling less painful.</p>



<a name="260169932"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260169932" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260169932">(Nov 03 2021 at 17:39)</a>:</h4>
<p><span class="user-mention silent" data-user-id="130384">Riccardo Brasca</span> <a href="#narrow/stream/113488-general/topic/A.20possible.20diamond/near/260169853">said</a>:</p>
<blockquote>
<p>Same here, I had to add <code>classical</code> at the beginning of the proof.</p>
</blockquote>
<p>I think this is a nasty bug somewhere (in <code>by_contra</code> or the instance lookup)</p>



<a name="260170152"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260170152" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260170152">(Nov 03 2021 at 17:41)</a>:</h4>
<p>How can <code>classical</code> have a bug? It just adds <code>classical.prop_decidable</code> to the context and resets the instance cache.  (If there's a bug, it must be <em>really</em> nasty.)</p>



<a name="260170257"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260170257" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260170257">(Nov 03 2021 at 17:42)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/113488-general/topic/A.20possible.20diamond/near/260170152">said</a>:</p>
<blockquote>
<p>How can <code>classical</code> have a bug? It just adds <code>classical.prop_decidable</code> to the context and resets the instance cache.  (If there's a bug, it must be <em>really</em> nasty.)</p>
</blockquote>
<p>The bug is that it adds the instance as a <code>have</code> not a <code>let</code></p>



<a name="260170336"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260170336" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260170336">(Nov 03 2021 at 17:42)</a>:</h4>
<p>Which means subsequent tactics can end up with diamonds they can't resolve</p>



<a name="260170438"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260170438" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260170438">(Nov 03 2021 at 17:43)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/113488-general/topic/A.20possible.20diamond/near/260169891">said</a>:</p>
<blockquote>
<ol>
<li>Feel free to use <code>open_locale classical</code> and <code>noncomputable theory</code>. It will likely lead to less work down the road if you use the <code>classical</code> tactic instead of <code>open_locale classical</code>, but then you'll need to add all the <code>decidable</code> instances Lean will ask you for.  It's up to you to decide which road to take.<br>
</li>
</ol>
</blockquote>
<p>This is what I've always done. But I discovered today it's not completely true...</p>



<a name="260170539"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260170539" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260170539">(Nov 03 2021 at 17:43)</a>:</h4>
<p>Including step 2? That's the key part for this to actually be workable. (If annoying and many times painful!)</p>



<a name="260170924"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260170924" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260170924">(Nov 03 2021 at 17:46)</a>:</h4>
<p>This is the original reason I opened this thread. If you look at the first message, I had</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">open_locale</span> <span class="n">classical</span>
<span class="kd">noncomputable theory</span>
</code></pre></div>
<p>at the beginning of the file, but I encountered a strange error at some point.</p>



<a name="260170932"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260170932" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260170932">(Nov 03 2021 at 17:46)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/113488-general/topic/A.20possible.20diamond/near/260169932">said</a>:</p>
<blockquote>
<p>I think this is a nasty bug somewhere (in <code>by_contra</code> or the instance lookup)</p>
</blockquote>
<p>The instance trace starts looking for <a href="https://leanprover-community.github.io/mathlib_docs/find/eq.decidable">docs#eq.decidable</a> and <a href="https://leanprover-community.github.io/mathlib_docs/find/decidable_eq_of_decidable_le">docs#decidable_eq_of_decidable_le</a> which starts a massive search for order instances</p>



<a name="260171000"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260171000" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260171000">(Nov 03 2021 at 17:46)</a>:</h4>
<p>But indeed this may be because I was using <code>rw [discriminant]</code> instead of <code>rw [discriminant_def]</code>, let me see.</p>



<a name="260171228"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260171228" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260171228">(Nov 03 2021 at 17:48)</a>:</h4>
<p><span class="user-mention" data-user-id="130384">@Riccardo Brasca</span> Did you try <code>convert this</code> at the beginning? If the only difference is that decidable instance in the type, then it should have worked.</p>



<a name="260171256"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260171256" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260171256">(Nov 03 2021 at 17:48)</a>:</h4>
<p>I got a timeout.</p>



<a name="260171284"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260171284" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260171284">(Nov 03 2021 at 17:49)</a>:</h4>
<p>Ah, here's the problem in <code>zero_of_not_linear_independent</code>; you need to <code>rw discriminant_def at h</code>. If you do that, the <code>by convert h</code> goes away, and it is much faster</p>



<a name="260172346"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260172346" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260172346">(Nov 03 2021 at 17:56)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/113488-general/topic/A.20possible.20diamond/near/260169891">said</a>:</p>
<blockquote>
<p>In classical mode, we pretend there is a noncomputable "algorithm" that can make these decisions.</p>
</blockquote>
<p>This simply isn't true.</p>



<a name="260172465"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260172465" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260172465">(Nov 03 2021 at 17:57)</a>:</h4>
<p><span class="user-mention" data-user-id="110031">@Patrick Massot</span> <a href="https://leanprover-community.github.io/mathlib_docs/find/classical.dec">docs#classical.dec</a>?</p>



<a name="260172570"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260172570" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260172570">(Nov 03 2021 at 17:58)</a>:</h4>
<p>You can pretend anything you want but mathematicians don't pretend there is an algorithm here.</p>



<a name="260172650"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260172650" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260172650">(Nov 03 2021 at 17:59)</a>:</h4>
<p>This kind of wording really isn't helping anything.</p>



<a name="260172840"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260172840" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260172840">(Nov 03 2021 at 18:00)</a>:</h4>
<p><span class="user-mention" data-user-id="310045">@Eric Wieser</span> thank you! Now everything seems to be working normal. I am not sure I've understood what was the problem at the beginning, and why I cannot simply put <code>open_locale classical</code>, but I am happy anyway.</p>



<a name="260172945"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260172945" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260172945">(Nov 03 2021 at 18:00)</a>:</h4>
<p><span class="user-mention" data-user-id="110031">@Patrick Massot</span> Thanks for the feedback that the scare quotes and wording aren't effective. How would you say it?</p>



<a name="260173214"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260173214" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260173214">(Nov 03 2021 at 18:02)</a>:</h4>
<p>The main point is that going to classical mode is declaring not to be interested in computability aspects. It's not "pretending" false things.</p>



<a name="260173341"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260173341" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260173341">(Nov 03 2021 at 18:03)</a>:</h4>
<p><span class="user-mention" data-user-id="130384">@Riccardo Brasca</span>, the problem comes down to the fact that when you forget to put <code>decidable_eq T</code> in a lemma statement, then either:</p>
<ul>
<li>You have no <code>open_locale classical</code>, and lean complains at you that you must add the argument. If you add this argument, your lemma is now as general as it need to be, and applies to all decision procedures.</li>
<li>You have <code>open_locale classical</code>, and lean inserts <code>classical.dec_eq</code> or equivalent. As a result, your lemma is now <strong>about the  <code>classical.dec_eq</code>  instance</strong>, and not about arbitrary decision algorithms any more</li>
</ul>
<p>The problem with the second outcome is that a later lemma inevitably introduces a decision algorithm such as "nat equality is obvious", and your lemma doesn't apply to it because your lemma is only about "the algorithm chosen using choice"</p>



<a name="260173349"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260173349" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260173349">(Nov 03 2021 at 18:03)</a>:</h4>
<p>A more useful explanation is to give more details about how Lean uses decidable stuff. But I think this is already covered in TPIL.</p>



<a name="260173682"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260173682" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260173682">(Nov 03 2021 at 18:05)</a>:</h4>
<p>I have a WIP linter that would have identified this problem, but I haven't found time to get it working properly</p>



<a name="260174271"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260174271" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260174271">(Nov 03 2021 at 18:09)</a>:</h4>
<p>And then why it is OK to have <code>open_locale classical</code> for definitions?</p>



<a name="260175309"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260175309" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260175309">(Nov 03 2021 at 18:16)</a>:</h4>
<p>It's about whether the instance appears on the LHS or the RHS of the <code>:=</code>. Letting classical instances leak into your type (aka statement) instead of parameterizing your type is almost always a bad idea, letting them leak into your implementation (aka proof) is fine</p>



<a name="260175422"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260175422" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260175422">(Nov 03 2021 at 18:17)</a>:</h4>
<p>Perhaps a better spelling would have been to use the <code>classical</code> tactic in <code>discriminant</code></p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/-- Given an `A`-algebra `B` and `b`, an `ι`-indexed family of elements of `B`, we define</span>
<span class="sd">`discriminant A ι b` as the determinant of `trace_matrix A ι b`. -/</span>
<span class="kd">def</span> <span class="n">discriminant</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">ι</span><span class="o">]</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">B</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">classical</span><span class="bp">;</span> <span class="n">exact</span> <span class="o">(</span><span class="n">trace_matrix</span> <span class="n">A</span> <span class="n">b</span><span class="o">)</span><span class="bp">.</span><span class="n">det</span>

<span class="c1">-- this needs a `decidable_eq` argument otherwise it's not general enough</span>
<span class="kd">lemma</span> <span class="n">discriminant_def</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">ι</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">ι</span><span class="o">]</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">discriminant</span> <span class="n">A</span> <span class="n">b</span> <span class="bp">=</span> <span class="o">(</span><span class="n">trace_matrix</span> <span class="n">A</span> <span class="n">b</span><span class="o">)</span><span class="bp">.</span><span class="n">det</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">convert</span> <span class="n">rfl</span>
</code></pre></div>
<p>which also avoids the <code>open_locale classical</code></p>



<a name="260176171"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260176171" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260176171">(Nov 03 2021 at 18:23)</a>:</h4>
<p>The real problem here is the idea that <code>matrix.det</code> "depends" on the <code>decidable_eq ι</code> instance at all</p>



<a name="260176469"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260176469" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260176469">(Nov 03 2021 at 18:25)</a>:</h4>
<p>What would you propose? If you replaced that with a classical instance, this wouldn't work:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">linear_algebra.matrix.determinant</span>
<span class="kn">import</span> <span class="n">data.matrix.notation</span>

<span class="k">#eval</span> <span class="n">matrix.det</span> <span class="bp">!</span><span class="o">[</span><span class="bp">!</span><span class="o">[(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">),</span> <span class="mi">2</span><span class="o">],</span> <span class="bp">!</span><span class="o">[</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">]]</span>
</code></pre></div>



<a name="260176632"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260176632" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260176632">(Nov 03 2021 at 18:26)</a>:</h4>
<p>That seems fine</p>



<a name="260176883"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260176883" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260176883">(Nov 03 2021 at 18:28)</a>:</h4>
<p>Ok, I think I understand now the issue with my code. I can go home and let the discussion to you <span aria-label="sweat smile" class="emoji emoji-1f605" role="img" title="sweat smile">:sweat_smile:</span></p>



<a name="260176974"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260176974" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260176974">(Nov 03 2021 at 18:29)</a>:</h4>
<p>It's not like the definition of <code>matrix.det</code> is a good algorithm anyways</p>



<a name="260177093"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260177093" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260177093">(Nov 03 2021 at 18:29)</a>:</h4>
<p>Tying together the definition of a thing with the way to compute that thing just leads to a definition which is bad for both reasoning about and computing</p>



<a name="260177164"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260177164" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260177164">(Nov 03 2021 at 18:30)</a>:</h4>
<p>Unfortunately, I think mathlib is too far down this road already</p>



<a name="260177204"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260177204" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260177204">(Nov 03 2021 at 18:30)</a>:</h4>
<p>Ah, your argument being that in lean4 we can still attach an efficient determinant implementation to a noncomputable definition?</p>



<a name="260177307"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260177307" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260177307">(Nov 03 2021 at 18:31)</a>:</h4>
<p>You could do it in Lean 3</p>



<a name="260177324"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260177324" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260177324">(Nov 03 2021 at 18:31)</a>:</h4>
<p>Oh, actually I think I agree with your original claim after all</p>



<a name="260177351"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260177351" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260177351">(Nov 03 2021 at 18:31)</a>:</h4>
<p>The only reason it requires <code>decidable_eq</code> is because <a href="https://leanprover-community.github.io/mathlib_docs/find/multilinear_map.map_add'">docs#multilinear_map.map_add'</a> uses it in a proof field</p>



<a name="260177374"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260177374" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260177374">(Nov 03 2021 at 18:31)</a>:</h4>
<p>That's ridiculous, we can just use the classical instance in that field</p>



<a name="260177497"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260177497" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260177497">(Nov 03 2021 at 18:32)</a>:</h4>
<p>Or put a <code>[decidable_eq \io]</code> argument on it</p>



<a name="260178895"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260178895" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260178895">(Nov 03 2021 at 18:42)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/113488-general/topic/A.20possible.20diamond/near/260177164">said</a>:</p>
<blockquote>
<p>Unfortunately, I think mathlib is too far down this road already</p>
</blockquote>
<p>We always boast that mathlib isn't scared of large refactors. So this seems like a challenge. If we know what to do, let's just turn the library on its head.</p>



<a name="260179228"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260179228" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260179228">(Nov 03 2021 at 18:45)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/113488-general/topic/A.20possible.20diamond/near/260177497">said</a>:</p>
<blockquote>
<p>Or put a <code>[decidable_eq \io]</code> argument on it</p>
</blockquote>
<p>I'm going ahead with this to see what happens</p>



<a name="260179871"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260179871" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260179871">(Nov 03 2021 at 18:50)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/113488-general/topic/A.20possible.20diamond/near/260176469">said</a>:</p>
<blockquote>
<p>What would you propose? If you replaced that with a classical instance, this wouldn't work:</p>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">linear_algebra.matrix.determinant</span>
<span class="kn">import</span> <span class="n">data.matrix.notation</span>

<span class="k">#eval</span> <span class="n">matrix.det</span> <span class="bp">!</span><span class="o">[</span><span class="bp">!</span><span class="o">[(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">),</span> <span class="mi">2</span><span class="o">],</span> <span class="bp">!</span><span class="o">[</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">]]</span>
</code></pre></div><br>
</p>
</blockquote>
<p>If we want to remove the decidability argument here, I would suggest having <code>matrix.gaussian_elim_det</code> and prove <code>matrix.gaussian_elim_det = matrix.det</code></p>



<a name="260179919"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260179919" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260179919">(Nov 03 2021 at 18:50)</a>:</h4>
<p>The decidability argument isn't even used in the computation, I don't think</p>



<a name="260179946"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260179946" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260179946">(Nov 03 2021 at 18:50)</a>:</h4>
<p>It's used in a type it doesn't need to be in</p>



<a name="260179986"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260179986" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260179986">(Nov 03 2021 at 18:50)</a>:</h4>
<p>In fact, I think you can't even do gaussian elimination in an arbitrary ring, so we would need it to be a separate definition anyway</p>



<a name="260180223"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260180223" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260180223">(Nov 03 2021 at 18:52)</a>:</h4>
<p>There are polynomial-size arithmetic circuits (using only ring operations) to compute determinants but for computations that come up in practice, yeah, you would usually be working over a ring (or field!) where a better algorithm is available</p>



<a name="260180519"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260180519" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260180519">(Nov 03 2021 at 18:54)</a>:</h4>
<p>huh, I just checked wikipedia and all the listed O(n^3) algorithms require a field</p>



<a name="260180602"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260180602" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260180602">(Nov 03 2021 at 18:55)</a>:</h4>
<p>I don't remember whether the arithmetic circuits are O(n^3), might be O(n^4). It was not so easy to find this stuff.</p>



<a name="260180688"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260180688" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260180688">(Nov 03 2021 at 18:56)</a>:</h4>
<p>Is it possible to extend the ring to a field of fractions? There might be characteristic constraints</p>



<a name="260180915"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260180915" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260180915">(Nov 03 2021 at 18:57)</a>:</h4>
<p>Aha: <a href="http://page.mi.fu-berlin.de/rote/Papers/pdf/Division-free+algorithms.pdf">http://page.mi.fu-berlin.de/rote/Papers/pdf/Division-free+algorithms.pdf</a></p>



<a name="260180925"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260180925" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260180925">(Nov 03 2021 at 18:57)</a>:</h4>
<p>indeed it's O(n^4)</p>



<a name="260183480"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260183480" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260183480">(Nov 03 2021 at 19:17)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/113488-general/topic/A.20possible.20diamond/near/260179946">said</a>:</p>
<blockquote>
<p>It's used in a type it doesn't need to be in</p>
</blockquote>
<p><a href="https://github.com/leanprover-community/mathlib/issues/10140">#10140</a> (wip, needs propagating downstream)</p>



<a name="260183553"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260183553" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260183553">(Nov 03 2021 at 19:18)</a>:</h4>
<p>This makes declaring multilinear_maps slightly harder, but using them easier</p>



<a name="260185083"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260185083" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260185083">(Nov 03 2021 at 19:29)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/113488-general/topic/A.20possible.20diamond/near/260176632">said</a>:</p>
<blockquote>
<p>That seems fine</p>
</blockquote>
<p>To be explicit, the simplest version of what I suggest would be to rename the current definition to <code>matrix.det_naive_impl</code> and wrap it in a <code>by classical</code> wrapper named <code>matrix.det</code> (like you suggested Riccardo do for <code>discriminant</code>), and continue to have all the lemmas be about the new <code>matrix.det</code>. Then in your <code>#eval</code> you have to type <code>#eval matrix.det_naive_impl</code>, but this isn't a big deal because if you wanted to compute the determinant of a matrix that wasn't tiny you would have needed to select a less naive implementation anyways.</p>



<a name="260185364"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260185364" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260185364">(Nov 03 2021 at 19:31)</a>:</h4>
<p>It seems pretty clear to me that being able to write <code>#eval matrix.det</code> instead of <code>#eval matrix.det_naive_impl</code> is not worth paying this <code>decidable_eq</code> tax whenever you just want to prove stuff.</p>



<a name="260185587"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260185587" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260185587">(Nov 03 2021 at 19:32)</a>:</h4>
<p>Of course if it happens that in this case the <code>decidable_eq</code> instance was unnecessary anyways then that's fine too.</p>



<a name="260186582"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260186582" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260186582">(Nov 03 2021 at 19:40)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/113488-general/topic/A.20possible.20diamond/near/260178895">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/113488-general/topic/A.20possible.20diamond/near/260177164">said</a>:</p>
<blockquote>
<p>Unfortunately, I think mathlib is too far down this road already</p>
</blockquote>
<p>We always boast that mathlib isn't scared of large refactors. So this seems like a challenge. If we know what to do, let's just turn the library on its head.</p>
</blockquote>
<p>There's a way that almost works, and if we had an additional feature (<code>erased_param</code>) I think it should be very possible.  The idea of <code>erased_param</code> is that it marks arguments that the VM should erase, in addition to the <code>Prop</code> arguments it already erases.</p>
<p>Here's what goes wrong right now.  A variant of <code>decidable</code> but for types rather than props could be</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">computable</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">value</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span>
<span class="o">(</span><span class="n">property</span> <span class="o">:</span> <span class="n">value</span> <span class="bp">=</span> <span class="n">x</span><span class="o">)</span>
</code></pre></div>
<p>so then if <code>x</code> is some noncomputable thing, <code>computable.value x</code> could potentially give a computable version.  However, this <code>x</code> argument "infects" everything with noncomputableness, even if it is never used, like in this contrived example:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">unit'</span> <span class="bp">|</span> <span class="n">mk</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">nonempty</span> <span class="n">unit'</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">unit'.mk</span><span class="o">⟩</span>

<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">unit'.mk'</span> <span class="o">:</span> <span class="n">unit'</span> <span class="o">:=</span> <span class="n">classical.choice</span> <span class="n">infer_instance</span>

<span class="kd">noncomputable</span> <span class="c1">-- (!)</span>
<span class="kd">instance</span> <span class="n">unit'.mk'.computable</span> <span class="o">:</span> <span class="n">computable</span> <span class="n">unit'.mk'</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">value</span> <span class="o">:=</span> <span class="n">unit'.mk</span><span class="o">,</span>
  <span class="n">property</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">generalize</span> <span class="o">:</span> <span class="n">unit'.mk'</span> <span class="bp">=</span> <span class="n">x</span><span class="o">,</span> <span class="n">cases</span> <span class="n">x</span><span class="o">,</span> <span class="n">refl</span><span class="o">,</span> <span class="o">}</span> <span class="o">}</span>
</code></pre></div>
<p>If it were possible to write the class as</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">computable</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">erased_param</span> <span class="bp">$</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">value</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span>
<span class="o">(</span><span class="n">property</span> <span class="o">:</span> <span class="n">value</span> <span class="bp">=</span> <span class="n">x</span><span class="o">)</span>
</code></pre></div>
<p>then (assuming in my ignorance that all the engineering challenges can be worked out) that instance wouldn't be noncomputable anymore and you would be allowed to do <code>#eval computable.value unit'.mk'</code>.</p>
<p>Other systems have this feature, like <a href="https://agda.readthedocs.io/en/v2.6.1/language/runtime-irrelevance.html">Agda</a>.</p>



<a name="260186713"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260186713" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260186713">(Nov 03 2021 at 19:41)</a>:</h4>
<p>(Instances of <code>computable</code> are free to depend on as many <code>computable</code> and <code>decidable</code> instances as they might want.)</p>



<a name="260186991"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260186991" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260186991">(Nov 03 2021 at 19:43)</a>:</h4>
<p>Kyle, didn't you have a version of something like this before that used <code>erased</code>? Does</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">computable</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">erased</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">value</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span>
<span class="o">(</span><span class="n">property</span> <span class="o">:</span> <span class="n">erased.mk</span> <span class="n">value</span> <span class="bp">=</span> <span class="n">x</span><span class="o">)</span>
</code></pre></div>
<p>work?</p>



<a name="260187042"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260187042" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260187042">(Nov 03 2021 at 19:44)</a>:</h4>
<p>Yeah, it's possible to mimic this using <a href="https://leanprover-community.github.io/mathlib_docs/find/erased">docs#erased</a>, but I couldn't really get it to work in a smooth way.</p>



<a name="260187202"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260187202" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260187202">(Nov 03 2021 at 19:45)</a>:</h4>
<p>In particular, using typeclass inference to build general <code>computable</code> instances from others.  (I didn't try <em>that</em> hard, to be honest.)</p>



<a name="260187680"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260187680" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260187680">(Nov 03 2021 at 19:48)</a>:</h4>
<p>I guess what I would try is to put every instance in the form <code>computable (erased.mk _)</code> and have instances like <code>[computable (erased.mk a)] [computable (erased.mk b)] : computable (erased.mk (a + b))</code>... but you probably already tried that</p>



<a name="260187790"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260187790" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260187790">(Nov 03 2021 at 19:49)</a>:</h4>
<p>Maybe for <code>Prop</code> the fact that we have connectives that already work on the "erased" form is important, I don't know.</p>



<a name="260187813"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260187813" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260187813">(Nov 03 2021 at 19:49)</a>:</h4>
<p>That instance would have exposed noncomputable <code>a</code> and <code>b</code> though</p>



<a name="260187821"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260187821" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260187821">(Nov 03 2021 at 19:49)</a>:</h4>
<p>Here were some experiments: <a href="https://gist.github.com/kmill/3808acff688ff3c0f26bc743146bcf4a">https://gist.github.com/kmill/3808acff688ff3c0f26bc743146bcf4a</a></p>
<p>The problem is that <code>computable (erased.mk _)</code> poisons computability, so you need something else.  I tried some notation:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">notation</span> <span class="bp">`</span><span class="n">omni</span> <span class="bp">`</span><span class="o">:</span><span class="mi">0</span> <span class="n">s</span> <span class="o">:=</span> <span class="o">(</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">s</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span> <span class="o">:</span> <span class="n">erased</span> <span class="n">_</span><span class="o">)</span>
</code></pre></div>
<p>("omniscient").  This lets you write <code>computable (omni _)</code> without that poisoning.</p>



<a name="260188069"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260188069" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260188069">(Nov 03 2021 at 19:51)</a>:</h4>
<p>but now that extra syntax is going to get in the way of typeclass inference</p>



<a name="260188240"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260188240" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260188240">(Nov 03 2021 at 19:52)</a>:</h4>
<p>That was indeed the problem, and I couldn't find any way around that.</p>



<a name="260188646"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260188646" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260188646">(Nov 03 2021 at 19:55)</a>:</h4>
<p>I wonder if this is enough information for Leo to implement first-class <a href="https://leanprover-community.github.io/mathlib_docs/find/erased">docs#erased</a> in the compiler? If <code>erased A</code> was defeq to <code>A</code> then everything would work</p>



<a name="260194168"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260194168" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260194168">(Nov 03 2021 at 20:36)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/113488-general/topic/A.20possible.20diamond/near/260185587">said</a>:</p>
<blockquote>
<p>Of course if it happens that in this case the <code>decidable_eq</code> instance was unnecessary anyways then that's fine too.</p>
</blockquote>
<p>Turns out I'm wrong, while the instance is unnecessary in <code>multilinear_map</code>, it's still needed by <a href="https://leanprover-community.github.io/mathlib_docs/find/equiv.perm.sign">docs#equiv.perm.sign</a></p>



<a name="260194621"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260194621" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260194621">(Nov 03 2021 at 20:40)</a>:</h4>
<p>Does the laplacian expansion of det also need decidable_eq? Probably, since it's a sum over fintypes?</p>



<a name="260194968"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260194968" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260194968">(Nov 03 2021 at 20:43)</a>:</h4>
<p>Isn't <code>(-1)^(i + j)</code> meaningless if your indices aren't ordered?</p>



<a name="260195030"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260195030" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260195030">(Nov 03 2021 at 20:44)</a>:</h4>
<p>I feel like any attempt to generalize that term will require decidability</p>



<a name="260195181"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260195181" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260195181">(Nov 03 2021 at 20:45)</a>:</h4>
<p>BTW reading the paper Mario shared, we have clows, called cycle, and cycles, which are cycle.nodup</p>



<a name="260202756"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260202756" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260202756">(Nov 03 2021 at 21:53)</a>:</h4>
<p>Maybe if you want to avoid <code>decidable_eq</code> in <code>matrix.det</code> you could create a <code>finset (bool × finset (n × n))</code>, where <code>finset (n × n)</code> represents the graph of a permutation of <code>n</code> and the <code>bool</code> is its sign.  Given one of these containing all permutations, you can define the determinant using the sum-over-permutations definition.</p>
<p>What might work for creating this is taking a <code>list n</code> representative <code>l</code> for <code>finset.univ</code>, calculating <code>list.permutations l</code> and zipping each with <code>l</code>, showing there are no dups so these lists can be written as a <code>finset (n × n)</code>, then working out the sign sequence for these partitions and zipping the <code>finset</code>s with that, showing the resulting list has no dups to create a <code>finset</code>, and then showing the resulting <code>finset</code> didn't depend on the <code>list n</code> representative.  It seems like <code>decidable_eq</code> isn't needed for any of these steps.  (Though I'm not sure it's worth it.)</p>



<a name="260203352"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260203352" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260203352">(Nov 03 2021 at 21:59)</a>:</h4>
<p>FWIW given that <code>fintype</code> is constructive, it's odd that it doesn't provide decidable equality--it's not any of the standard constructive meanings of "finite".</p>



<a name="260203653"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260203653" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260203653">(Nov 03 2021 at 22:01)</a>:</h4>
<p>This is because of the definition of list.nodup doesn't require decidable equality, iirc</p>



<a name="260203753"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260203753" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260203753">(Nov 03 2021 at 22:02)</a>:</h4>
<p>At least, why it doesn't require it. Could one use it to provide a decidable_eq instance?</p>



<a name="260203827"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260203827" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260203827">(Nov 03 2021 at 22:03)</a>:</h4>
<p>It doesn't need one because it's a <code>Prop</code>.  If <code>list.nodup</code> were a <code>decidable_pred</code>, I think you could manufacture a <code>decidable_eq</code>.</p>



<a name="260204009"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260204009" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260204009">(Nov 03 2021 at 22:04)</a>:</h4>
<p>I think a faster way to describe Kyle's construction is to see that <code>fintype X</code> is basically <code>trunc</code> of a <code>bijection</code> <code>fin n -&gt; X</code>, so if you have a matrix indexed by <code>X</code> you can precompose the rows and columns by that bijection and then take the determinant of that <code>n</code> x <code>n</code> matrix.</p>



<a name="260204048"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260204048" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260204048">(Nov 03 2021 at 22:05)</a>:</h4>
<p>The usual notion of finiteness would be <code>trunc</code> of an <code>equiv</code> <code>fin n -&gt; X</code>.</p>



<a name="260204093"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260204093" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260204093">(Nov 03 2021 at 22:05)</a>:</h4>
<p>That's a lot better than what I suggested.</p>



<a name="260204203"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260204203" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260204203">(Nov 03 2021 at 22:06)</a>:</h4>
<p>You still need to check that this isn't dependent on the <code>bijection</code> but if you don't mind admitting classical reasoning to prove this then there's certainly no problem.</p>



<a name="260204274"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260204274" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260204274">(Nov 03 2021 at 22:07)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/fintype.trunc_equiv_fin">docs#fintype.trunc_equiv_fin</a></p>



<a name="260204456"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260204456" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260204456">(Nov 03 2021 at 22:09)</a>:</h4>
<p>Which requires decidable equality</p>



<a name="260204462"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260204462" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260204462">(Nov 03 2021 at 22:09)</a>:</h4>
<p>This is assuming <code>decidable_eq</code>--so having decidable equality is exactly being able to upgrade from <code>bijection</code> to <code>equiv</code> (since <code>fin n</code> definitely has decidable equality)</p>



<a name="260204615"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260204615" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260204615">(Nov 03 2021 at 22:10)</a>:</h4>
<p>What are you referring to by <code>bijection</code> here? <code>subtype bijective</code>?</p>



<a name="260204654"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260204654" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260204654">(Nov 03 2021 at 22:11)</a>:</h4>
<p>In fact now I realize that what's weird about <code>fintype</code> is precisely that it mixes <code>trunc</code> and <code>bijection</code>, when most constructive settings don't even have both of these as distinct concepts.</p>



<a name="260204755"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260204755" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260204755">(Nov 03 2021 at 22:12)</a>:</h4>
<p>The point is that <a href="https://leanprover-community.github.io/mathlib_docs/find/fintype.complete">docs#fintype.complete</a> is a <code>Prop</code>, when it "should" be some kind of witness data</p>



<a name="260204910"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260204910" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260204910">(Nov 03 2021 at 22:14)</a>:</h4>
<p>Do we have <code>fintype.trunc_fin_embedding</code> that says fin (card X) embeds into a finite type X?</p>



<a name="260204965"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260204965" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260204965">(Nov 03 2021 at 22:14)</a>:</h4>
<p>That wouldn't need decidable equality, which I think is what you were saying above.</p>



<a name="260205107"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260205107" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260205107">(Nov 03 2021 at 22:16)</a>:</h4>
<p>It's funny how there's a difference between <code>trunc {f : fin n -&gt; X // bijective f}</code>, which is whether the type's elements can be listed (but you don't know where in the list any given element is), and <code>trunc {f : X -&gt; fin n // bijective f}</code> which is whether each element can be numbered (but you can't list out the elements).  The second one implies decidable equality, and the first is basically <code>fintype</code>.</p>



<a name="260207442"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260207442" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260207442">(Nov 03 2021 at 22:42)</a>:</h4>
<p><span class="user-mention" data-user-id="310045">@Eric Wieser</span> This should do:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">fintype.trunc_fin_bijective</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">trunc</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">fintype.card</span> <span class="n">α</span><span class="o">)</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">//</span> <span class="n">function.bijective</span> <span class="n">f</span><span class="o">}</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">generalize</span> <span class="n">hn</span> <span class="o">:</span> <span class="n">fintype.card</span> <span class="n">α</span> <span class="bp">=</span> <span class="n">n</span><span class="o">,</span>
  <span class="n">dunfold</span> <span class="n">fintype.card</span> <span class="n">finset.card</span> <span class="n">at</span> <span class="n">hn</span><span class="o">,</span>
  <span class="n">refine</span> <span class="n">quot.rec_on_subsingleton</span> <span class="o">(</span><span class="bp">@</span><span class="n">finset.univ</span> <span class="n">α</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="n">l</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">l</span><span class="o">)</span> <span class="o">(</span><span class="n">nd</span> <span class="o">:</span> <span class="n">l.nodup</span><span class="o">)</span> <span class="o">(</span><span class="n">hn</span> <span class="o">:</span> <span class="n">l.length</span> <span class="bp">=</span> <span class="n">n</span><span class="o">),</span> <span class="n">trunc.mk</span> <span class="n">_</span><span class="o">)</span>
    <span class="n">finset.mem_univ_val</span> <span class="n">finset.univ.2</span> <span class="n">hn</span><span class="o">,</span>
  <span class="n">subst</span> <span class="n">hn</span><span class="o">,</span>
  <span class="n">use</span> <span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">l.nth_le</span> <span class="n">i</span> <span class="n">i.property</span><span class="o">,</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">nd.nth_le_inj_iff</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">fin.ext</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">intro</span> <span class="n">x</span><span class="o">,</span>
    <span class="n">specialize</span> <span class="n">h</span> <span class="n">x</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">list.mem_iff_nth_le</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">obtain</span> <span class="o">⟨</span><span class="n">i</span><span class="o">,</span> <span class="n">hi</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">exact</span> <span class="o">⟨⟨</span><span class="n">i</span><span class="o">,</span> <span class="n">hi</span><span class="o">⟩,</span> <span class="n">rfl</span><span class="o">⟩,</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>



<a name="260213961"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260213961" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260213961">(Nov 04 2021 at 00:01)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/issues/10141">#10141</a></p>



<a name="260342199"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260342199" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260342199">(Nov 04 2021 at 22:15)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113488-general/topic/A.20possible.20diamond/near/260180915">said</a>:</p>
<blockquote>
<p>Aha: <a href="http://page.mi.fu-berlin.de/rote/Papers/pdf/Division-free+algorithms.pdf">http://page.mi.fu-berlin.de/rote/Papers/pdf/Division-free+algorithms.pdf</a></p>
</blockquote>
<p>Speaking of which, someone coincidentally posted a codegolf challenge about a division-free O(n^4) determinant algorithm yesterday: <a href="https://codegolf.stackexchange.com/questions/236835/birds-algorithm-for-computing-determinants">https://codegolf.stackexchange.com/questions/236835/birds-algorithm-for-computing-determinants</a></p>



<a name="260342529"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260342529" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260342529">(Nov 04 2021 at 22:18)</a>:</h4>
<blockquote>
<p>Yes @pajonk, I think we can agree that a 1x1 matrix is not really a matrix</p>
</blockquote>
<p>I believe that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>×</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">0 \times 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>×</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">1 \times 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> matrices exist, and that they are different. <span aria-label="rolling on the floor laughing" class="emoji emoji-1f923" role="img" title="rolling on the floor laughing">:rolling_on_the_floor_laughing:</span></p>



<a name="260342748"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260342748" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260342748">(Nov 04 2021 at 22:21)</a>:</h4>
<p>lean says that "they are different" doesn't typecheck</p>



<a name="260343086"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260343086" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260343086">(Nov 04 2021 at 22:25)</a>:</h4>
<p>So they are very different!</p>



<a name="260344397"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/260344397" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#260344397">(Nov 04 2021 at 22:39)</a>:</h4>
<p>"They are different" probably means that they are not <a href="https://leanprover-community.github.io/mathlib_docs/find/heq">docs#heq</a> and I'm not sure that we can prove it.</p>



<a name="261236018"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/261236018" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#261236018">(Nov 12 2021 at 10:45)</a>:</h4>
<p>I encountered another problem similar to the first one in this thread. In a proof, if I put</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">letI</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">E</span><span class="o">),</span> <span class="n">classical.prop_decidable</span> <span class="o">(</span><span class="n">eq</span> <span class="n">a</span> <span class="n">b</span><span class="o">),</span>
</code></pre></div>
<p>everything is OK, but with</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">letI</span> <span class="o">:=</span> <span class="n">classical.dec_eq</span> <span class="n">E</span><span class="o">,</span>
</code></pre></div>
<p>there is a problem. Does this mean there is a problem somewhere or I should just use <code>classical.prop_decidable</code> and be happy?</p>



<a name="261238353"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/261238353" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#261238353">(Nov 12 2021 at 11:11)</a>:</h4>
<p><span class="user-mention silent" data-user-id="387244">Yaël Dillies</span> <a href="#narrow/stream/113488-general/topic/A.20possible.20diamond/near/260342529">said</a>:</p>
<blockquote>
<blockquote>
<p>Yes @pajonk, I think we can agree that a 1x1 matrix is not really a matrix</p>
</blockquote>
<p>I believe that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>×</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">0 \times 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>×</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">1 \times 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> matrices exist, and that they are different. <span aria-label="rolling on the floor laughing" class="emoji emoji-1f923" role="img" title="rolling on the floor laughing">:rolling_on_the_floor_laughing:</span></p>
</blockquote>
<p>Fun fact: according to Lean, the type of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>×</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">0 \times 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> matrices <em>equals</em> the type of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>×</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">0 \times 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> matrices.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.matrix.basic</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">R</span> <span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">:</span> <span class="n">matrix</span> <span class="n">empty</span> <span class="n">m</span> <span class="n">R</span> <span class="bp">=</span> <span class="n">matrix</span> <span class="n">empty</span> <span class="n">n</span> <span class="n">R</span> <span class="o">:=</span>
<span class="n">congr_arg</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">f</span> <span class="o">:</span> <span class="n">empty</span> <span class="bp">→</span> <span class="kt">Type</span><span class="o">,</span> <span class="bp">Π</span> <span class="n">i</span><span class="o">,</span> <span class="n">f</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">subsingleton.elim</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span>
</code></pre></div>



<a name="261244513"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/261244513" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#261244513">(Nov 12 2021 at 12:23)</a>:</h4>
<p>Can you make a <a href="https://leanprover-community.github.io/mwe.html">#mwe</a> <span class="user-mention" data-user-id="130384">@Riccardo Brasca</span>?</p>



<a name="261245383"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/261245383" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#261245383">(Nov 12 2021 at 12:33)</a>:</h4>
<p>I think I have understood the problem: I recently added <a href="https://leanprover-community.github.io/mathlib_docs/find/polynomial.aeval_root_derivative_of_splits">docs#polynomial.aeval_root_derivative_of_splits</a>. This lemma uses, in the statement, <a href="https://leanprover-community.github.io/mathlib_docs/find/multiset.erase">docs#multiset.erase</a>, that has <code> [decidable_eq α]</code> as an assumption.<br>
The point is that <a href="https://leanprover-community.github.io/mathlib_docs/find/polynomial.aeval_root_derivative_of_splits">docs#polynomial.aeval_root_derivative_of_splits</a> does <em>not</em> have any <code> [decidable_eq]</code> in the assumptions, since at the beginning of the file there is <code>open_locale classical</code>, so I think Lean just uses <code>λ (a b : L), classical.prop_decidable (eq a b)</code>. Now, if I use that lemma somewhere else where the same instance is filled using <code>classical.dec_eq L</code> I get a problem. Indeed</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">logic.basic</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">L</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">L</span><span class="o">),</span> <span class="n">classical.prop_decidable</span> <span class="o">(</span><span class="n">eq</span> <span class="n">a</span> <span class="n">b</span><span class="o">))</span> <span class="bp">=</span> <span class="n">classical.dec_eq</span> <span class="n">L</span> <span class="o">:=</span> <span class="n">rfl</span>
</code></pre></div>
<p>does not work. I don't know if this is the intended behavior  or not. Maybe the correct solution is just to add <code>[decidable_eq L]</code> in <a href="https://leanprover-community.github.io/mathlib_docs/find/polynomial.aeval_root_derivative_of_splits">docs#polynomial.aeval_root_derivative_of_splits</a> even if there is <code>open_locale classical</code>?</p>



<a name="261245404"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/261245404" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#261245404">(Nov 12 2021 at 12:33)</a>:</h4>
<p>So in practice I've solved my problem and I think I even really understood it :)</p>



<a name="261246251"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/261246251" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#261246251">(Nov 12 2021 at 12:42)</a>:</h4>
<p>The problem is that <a href="https://leanprover-community.github.io/mathlib_docs/find/classical.dec_eq">docs#classical.dec_eq</a> is a <code>lemma</code> but carries data</p>



<a name="261246267"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/261246267" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#261246267">(Nov 12 2021 at 12:42)</a>:</h4>
<p>Lean never unfolds lemmas</p>



<a name="261246357"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/261246357" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#261246357">(Nov 12 2021 at 12:43)</a>:</h4>
<p>Apparently that's necessary: <a href="https://leanprover-community.github.io/mathlib_docs/notes.html#classical%20lemma">https://leanprover-community.github.io/mathlib_docs/notes.html#classical%20lemma</a></p>



<a name="261246948"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/261246948" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#261246948">(Nov 12 2021 at 12:48)</a>:</h4>
<p>I think that the confusion, at least for me, comes from the fact that</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">open_locale</span> <span class="n">classical</span>
<span class="kd">lemma</span> <span class="n">foo</span> <span class="bp">...</span>
</code></pre></div>
<p>is <em>less</em> general than</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">foo1</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">T</span><span class="o">]</span><span class="bp">...</span>
</code></pre></div>
<p>even if in <code>foo1</code> it seems to be one assumption more than in <code>foo</code>.</p>



<a name="261247018"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/261247018" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#261247018">(Nov 12 2021 at 12:49)</a>:</h4>
<p>Because <code>foo</code> only applies to the <code>decidable_eq</code> produced by <code>classical</code>, while <code>foo1</code> applies to any <code>decidable_eq</code> instance.</p>



<a name="261247066"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/261247066" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#261247066">(Nov 12 2021 at 12:49)</a>:</h4>
<p>This is surely a stupid thing, but I've understood it before</p>



<a name="261247375"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/261247375" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#261247375">(Nov 12 2021 at 12:52)</a>:</h4>
<p>Yes, that's certainly true, but it doesnt'explain why <code>classical.prop_decidable</code> and <code>classical.dec_eq</code> aren't equivalent by <code>rfl</code> despite having the same implementation</p>



<a name="261247448"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/261247448" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#261247448">(Nov 12 2021 at 12:53)</a>:</h4>
<p>I opened <a href="https://github.com/leanprover-community/mathlib/issues/10292">#10292</a> to see if the library note is still true</p>



<a name="261247689"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/261247689" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#261247689">(Nov 12 2021 at 12:55)</a>:</h4>
<p>Sure, that is a deeper question. At the moment I am just looking to understand how to do classical mathematics, and I am more and more convinced  that <code>open_locale classical</code> is not always the right way.</p>



<a name="261249045"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/261249045" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#261249045">(Nov 12 2021 at 13:09)</a>:</h4>
<p><span class="user-mention silent" data-user-id="130377">David Wärn</span> <a href="#narrow/stream/113488-general/topic/A.20possible.20diamond/near/261238353">said</a>:</p>
<blockquote>
<p>Fun fact: according to Lean, the type of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>×</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">0 \times 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> matrices <em>equals</em> the type of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>×</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">0 \times 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> matrices.</p>
</blockquote>
<p>I assume this doesn't work for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>×</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">0 \times 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> vs <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>×</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">1 \times 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> nor $1 \times 0$$ vs <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>×</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">2\times 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>?</p>



<a name="261258500"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/261258500" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#261258500">(Nov 12 2021 at 14:23)</a>:</h4>
<p><span class="user-mention silent" data-user-id="130377">David Wärn</span> <a href="#narrow/stream/113488-general/topic/A.20possible.20diamond/near/261238353">said</a>:</p>
<blockquote>
<p>Fun fact: according to Lean, the type of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>×</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">0 \times 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> matrices <em>equals</em> the type of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>×</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">0 \times 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> matrices.</p>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.matrix.basic</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">R</span> <span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">:</span> <span class="n">matrix</span> <span class="n">empty</span> <span class="n">m</span> <span class="n">R</span> <span class="bp">=</span> <span class="n">matrix</span> <span class="n">empty</span> <span class="n">n</span> <span class="n">R</span> <span class="o">:=</span>
<span class="n">congr_arg</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">f</span> <span class="o">:</span> <span class="n">empty</span> <span class="bp">→</span> <span class="kt">Type</span><span class="o">,</span> <span class="bp">Π</span> <span class="n">i</span><span class="o">,</span> <span class="n">f</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">subsingleton.elim</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span>
</code></pre></div><br>
</p>
</blockquote>
<p>For those who are confused by this example (which included me), first consider this example:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">empty_pi</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="n">empty</span> <span class="bp">→</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">:</span> <span class="o">(</span><span class="bp">Π</span> <span class="n">i</span><span class="o">,</span> <span class="n">α</span> <span class="n">i</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="bp">Π</span> <span class="n">i</span><span class="o">,</span> <span class="n">β</span> <span class="n">i</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">congr_arg</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">f</span> <span class="o">:</span> <span class="n">empty</span> <span class="bp">→</span> <span class="kt">Type</span><span class="o">,</span> <span class="bp">Π</span> <span class="n">i</span> <span class="o">:</span> <span class="n">empty</span><span class="o">,</span> <span class="n">f</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">subsingleton.elim</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span>
</code></pre></div>
<p>This proof makes sense: <code>α</code> and <code>β</code> are both "functions" out of the empty type, so they're equal, so the Pi-types of them must also be equal.<br>
Now  the arrow-case is a direct consequence of this (recall that <code>X → Y</code> is just notation for <code>Π _ : X, Y</code>):</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">empty_arrow</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">:</span> <span class="o">(</span><span class="n">empty</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">empty</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">empty_pi</span>
</code></pre></div>
<p>and that's how the above proof works.</p>



<a name="261277346"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/261277346" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#261277346">(Nov 12 2021 at 16:33)</a>:</h4>
<p>ha ha that's a funny proof David. Can you prove <code>matrix m empty = matrix n empty</code>? I'm not so sure this is provable.</p>



<a name="261278546"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/261278546" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#261278546">(Nov 12 2021 at 16:42)</a>:</h4>
<p><span class="user-mention silent" data-user-id="130384">Riccardo Brasca</span> <a href="#narrow/stream/113488-general/topic/A.20possible.20diamond/near/261247066">said</a>:</p>
<blockquote>
<p>This is surely a stupid thing, but I've understood it before</p>
</blockquote>
<p>Here's another weird "choosing stuff" thing. These computer scientists took the axiom of choice too far. You know when in a proof we say "OK we know this set can't be empty so let's just choose an element at random; I don't care which one it is but I know it has these properties and those will be enough to finish the proof". The computer scientists want to know which element we pick, but we don't care, we would happily choose a different element next year when we are lecturing the same proof, so the computer scientists made this <code>classical.choice</code> thing where they <em>choose exactly the same element every time</em>. Before I appreciated this, I just thought that this choice axiom did nothing more than <code>cases h with x hx</code> when the goal was a Type, but then when I realised it was always the same <code>x</code> as opposed to a random one I think I felt a little giddy.</p>



<a name="261282544"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/261282544" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#261282544">(Nov 12 2021 at 17:12)</a>:</h4>
<p>Same here!</p>



<a name="261284748"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/261284748" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#261284748">(Nov 12 2021 at 17:28)</a>:</h4>
<p>That's one reason to sometimes avoid <code>classical.choice</code> in definitions: since it's actually picking out some unknown-to-you but very specific element, there's nothing that requires you to prove the choice it made didn't matter.  (What if by some unlucky coincidences you manage to prove a "false" theorem because all the definitions chose the same elements with <code>classical.choice</code>?)</p>
<p>I was trying to think of the cases that feel safe to use it (from an avoiding-unluckly-coincidences perspective), and the only thing that comes to mind is when you want to extract the element of a singleton type (that includes the classical decidable instances).</p>
<p>There seems to be an awkward way to make it so you have to show choices didn't matter, but it's pretty awkward.  If each definition that uses choice in a non-unique way exposes an arbitrariness type (for the auxiliary data that we imagine the choice function uses to make its choices), then you're forced to prove that the choice didn't matter.  But then you have to manage these arbitrariness types and thread them correctly through all your definitions...</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/-- Select an element of  `α` using the data from `x`. -/</span>
<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">my_choice</span> <span class="o">{</span><span class="n">κ</span> <span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">κ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">nonempty</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span>
<span class="n">sigma.snd</span> <span class="o">(</span><span class="bp">@</span><span class="n">classical.choice</span> <span class="o">(</span><span class="bp">Σ</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">κ</span><span class="o">),</span> <span class="n">α</span><span class="o">)</span> <span class="o">⟨⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">h.some</span><span class="o">⟩⟩)</span>
</code></pre></div>
<p>The point is that this is now unprovable:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">unprovable</span> <span class="o">{</span><span class="n">κ</span> <span class="n">κ'</span> <span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">κ</span><span class="o">)</span> <span class="o">(</span><span class="n">x'</span> <span class="o">:</span> <span class="n">κ'</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">nonempty</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">my_choice</span> <span class="n">x</span> <span class="n">h</span> <span class="bp">=</span> <span class="n">my_choice</span> <span class="n">x'</span> <span class="n">h</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>
<p>But that's no good if everyone just chooses a random number:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">provable</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">nonempty</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">my_choice</span> <span class="mi">37</span> <span class="n">h</span> <span class="bp">=</span> <span class="n">my_choice</span> <span class="mi">37</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">rfl</span>
</code></pre></div>



<a name="283942660"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/283942660" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#283942660">(May 25 2022 at 21:27)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113488-general/topic/A.20possible.20diamond/near/261278546">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="130384">Riccardo Brasca</span> <a href="#narrow/stream/113488-general/topic/A.20possible.20diamond/near/261247066">said</a>:</p>
<blockquote>
<p>This is surely a stupid thing, but I've understood it before</p>
</blockquote>
<p>Here's another weird "choosing stuff" thing. These computer scientists took the axiom of choice too far. You know when in a proof we say "OK we know this set can't be empty so let's just choose an element at random; I don't care which one it is but I know it has these properties and those will be enough to finish the proof". The computer scientists want to know which element we pick, but we don't care, we would happily choose a different element next year when we are lecturing the same proof, so the computer scientists made this <code>classical.choice</code> thing where they <em>choose exactly the same element every time</em>. Before I appreciated this, I just thought that this choice axiom did nothing more than <code>cases h with x hx</code> when the goal was a Type, but then when I realised it was always the same <code>x</code> as opposed to a random one I think I felt a little giddy.</p>
</blockquote>
<p>In some sense isn't this the whole point of choice. I was always confused by choice because in order to prove <code>nonempty α</code> you have to provide a witness anyway so why not just return the witness provided. Then I realised that the power lay in the fact that it always returns the same element regardless of the witness. I realised this when proving Lagrange's theorem. To prove the isomorphism of sets <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mo>×</mo><mi>G</mi><mi mathvariant="normal">/</mi><mi>H</mi><mo>≃</mo><mi>G</mi></mrow><annotation encoding="application/x-tex">H × G / H ≃ G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">G</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≃</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span> you need choice. Given <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo>∈</mo><mi>G</mi></mrow><annotation encoding="application/x-tex">g \in G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span> you send it to the pair <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msup><mi>a</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mi>g</mi><mo separator="true">,</mo><mi>a</mi><mi>H</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a^{-1}g, aH)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mclose">)</span></span></span></span> where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span> is an element of the same coset as <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span>. You use <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span> to prove nonemptiness of the coset containing <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span> but you have to make sure you always choose the same element of the coset regardless of what element of the coset you start with.</p>
<p>I quite the following alternative version of choice when introducing the concept. They won't have to understand the difference between <code>nonempty</code> and <code>inhabited</code> or anything like that to understand it. It is <code>∀ {α : Sort u}, ∃ f : α → α, ∀ x y, f x = f y</code>. I can't remember how strong it is compared with the other versions. I think it's pretty weak but I think it still covers a lot of uses of choice. I thought about this once but I can't remember.</p>



<a name="283946384"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/283946384" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#283946384">(May 25 2022 at 22:04)</a>:</h4>
<p>There is another theorem called <a href="https://leanprover-community.github.io/mathlib_docs/find/classical.axiom_of_choice">docs#classical.axiom_of_choice</a> (rarely used in mathlib because <code>classical.choice</code> is easier) which is closer to the version found in the textbooks. The reason <code>classical.choice</code> being a function is important is that it lets you use it in lambdas to get statements like <code>classical.axiom_of_choice</code>; it is actually strictly stronger though since <code>axiom_of_choice</code> still keeps everything behind an existential so it is not <code>noncomputable</code> in the lean sense and you can't use it to define noncomputable things</p>



<a name="283946560"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/283946560" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#283946560">(May 25 2022 at 22:06)</a>:</h4>
<p>I guess the point is that the function should be random but not the element.</p>



<a name="283947026"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/283947026" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#283947026">(May 25 2022 at 22:12)</a>:</h4>
<p>the function should be a <em>function</em></p>



<a name="283947046"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/283947046" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#283947046">(May 25 2022 at 22:12)</a>:</h4>
<p>this is a rare case where the function-ness is the important part</p>



<a name="283947132"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20possible%20diamond/near/283947132" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20possible.20diamond.html#283947132">(May 25 2022 at 22:13)</a>:</h4>
<p>Reading the proof of <a href="https://en.wikipedia.org/wiki/Diaconescu%27s_theorem">Diaconescu's theorem</a> (<a href="https://leanprover-community.github.io/mathlib_docs/find/classical.em/src">src#classical.em</a>) is great for understanding how powerful this property is</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
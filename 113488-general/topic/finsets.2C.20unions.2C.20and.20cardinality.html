---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/finsets.2C.20unions.2C.20and.20cardinality.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finsets.2C.20unions.2C.20and.20cardinality.html">finsets, unions, and cardinality</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="222462824"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finsets%2C%20unions%2C%20and%20cardinality/near/222462824" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jeremy Avigad <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finsets.2C.20unions.2C.20and.20cardinality.html#222462824">(Jan 12 2021 at 17:07)</a>:</h4>
<p>Is there a good way to deal with finset-indexed unions of finsets, their cardinalities, and so on? I don't see much in the library -- only some workarounds with <code>supr</code>, and some cardinality operations on fintypes. Am I missing something obvious?</p>



<a name="222470184"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finsets%2C%20unions%2C%20and%20cardinality/near/222470184" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finsets.2C.20unions.2C.20and.20cardinality.html#222470184">(Jan 12 2021 at 17:58)</a>:</h4>
<p>You can use <code>finset.bind</code> to take a finset union of a finset</p>



<a name="222470324"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finsets%2C%20unions%2C%20and%20cardinality/near/222470324" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finsets.2C.20unions.2C.20and.20cardinality.html#222470324">(Jan 12 2021 at 17:59)</a>:</h4>
<p>and we have <a href="https://leanprover-community.github.io/mathlib_docs/find/finset.card_bind">docs#finset.card_bind</a> to prove a cardinality theorem about it</p>



<a name="222471575"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finsets%2C%20unions%2C%20and%20cardinality/near/222471575" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jeremy Avigad <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finsets.2C.20unions.2C.20and.20cardinality.html#222471575">(Jan 12 2021 at 18:09)</a>:</h4>
<p>Ah, I forgot. <code>s.bind t</code> is what we call <code>bUnion</code> when we talk about sets. Someone should document that! Thanks.</p>



<a name="222471963"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finsets%2C%20unions%2C%20and%20cardinality/near/222471963" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finsets.2C.20unions.2C.20and.20cardinality.html#222471963">(Jan 12 2021 at 18:12)</a>:</h4>
<p>I've been using <code>finset.bind</code> recently, and I appreciate where the name comes from, but if a sufficiently motivated individual were up to a rename, would anyone be opposed to it being called something like <code>finset.Union</code>?</p>



<a name="222476249"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finsets%2C%20unions%2C%20and%20cardinality/near/222476249" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finsets.2C.20unions.2C.20and.20cardinality.html#222476249">(Jan 12 2021 at 18:43)</a>:</h4>
<p><code>finset.fUnion</code> ;-)</p>



<a name="222477287"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finsets%2C%20unions%2C%20and%20cardinality/near/222477287" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finsets.2C.20unions.2C.20and.20cardinality.html#222477287">(Jan 12 2021 at 18:52)</a>:</h4>
<p><code>finset.finUnion</code>?</p>



<a name="222477321"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finsets%2C%20unions%2C%20and%20cardinality/near/222477321" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finsets.2C.20unions.2C.20and.20cardinality.html#222477321">(Jan 12 2021 at 18:52)</a>:</h4>
<p>seems to match <code>*set.*Union</code></p>



<a name="222478539"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finsets%2C%20unions%2C%20and%20cardinality/near/222478539" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finsets.2C.20unions.2C.20and.20cardinality.html#222478539">(Jan 12 2021 at 19:01)</a>:</h4>
<p>I prefer <code>bUnion</code> since it matches the set naming</p>



<a name="222483088"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finsets%2C%20unions%2C%20and%20cardinality/near/222483088" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finsets.2C.20unions.2C.20and.20cardinality.html#222483088">(Jan 12 2021 at 19:35)</a>:</h4>
<p>We also have <code>finset.sup</code>, shouldn't this be the same thing?</p>



<a name="222484121"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finsets%2C%20unions%2C%20and%20cardinality/near/222484121" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finsets.2C.20unions.2C.20and.20cardinality.html#222484121">(Jan 12 2021 at 19:44)</a>:</h4>
<p>Isn't sup just for two things?</p>



<a name="222486579"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finsets%2C%20unions%2C%20and%20cardinality/near/222486579" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finsets.2C.20unions.2C.20and.20cardinality.html#222486579">(Jan 12 2021 at 20:02)</a>:</h4>
<p>It looks like <code>finset.bind</code> is a specialized <code>finset.sup</code>.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">finset.bind</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">finset</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">β</span>
<span class="kd">def</span> <span class="n">finset.sup</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span>
</code></pre></div>
<p>The first is defined using <code>multiset.bind</code> (which is iterated unions of multisets), and the second by iterated unions of finsets.  Computationally, the second one removes duplicates as it goes.</p>



<a name="222492481"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finsets%2C%20unions%2C%20and%20cardinality/near/222492481" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finsets.2C.20unions.2C.20and.20cardinality.html#222492481">(Jan 12 2021 at 20:50)</a>:</h4>
<p>Do we have a lemma equating them?</p>



<a name="222506787"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finsets%2C%20unions%2C%20and%20cardinality/near/222506787" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finsets.2C.20unions.2C.20and.20cardinality.html#222506787">(Jan 12 2021 at 22:45)</a>:</h4>
<p>It didn't look like it, so I created <a href="https://github.com/leanprover-community/mathlib/issues/5717">#5717</a>.  I'm waiting to see if mathlib still compiles labeling it with awaiting-review.</p>



<a name="222648593"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finsets%2C%20unions%2C%20and%20cardinality/near/222648593" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finsets.2C.20unions.2C.20and.20cardinality.html#222648593">(Jan 13 2021 at 21:31)</a>:</h4>
<p>Instead of (or in addition to) renaming <code>finset.bind</code>, there's an option of reworking the notation for Union to use a typeclass and use  <code>finset.bind</code> to implement it.  I got something that seems to work for both sets and finsets (with the correct decidability requirements):</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">order.complete_lattice</span>
<span class="kn">import</span> <span class="n">data.set.lattice</span>
<span class="kn">import</span> <span class="n">data.finset.basic</span>
<span class="kn">import</span> <span class="n">data.fintype.basic</span>

<span class="kd">class</span> <span class="n">has_Union</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="n">out_param</span> <span class="bp">$</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">Union</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span>

<span class="kn">local</span> <span class="kd">notation</span> <span class="bp">`⋃`</span> <span class="n">binders</span> <span class="bp">`</span><span class="o">,</span> <span class="bp">`</span> <span class="n">r</span><span class="o">:(</span><span class="n">scoped</span> <span class="n">f</span><span class="o">,</span> <span class="n">has_Union.Union</span> <span class="n">f</span><span class="o">)</span> <span class="o">:=</span> <span class="n">r</span>

<span class="kd">instance</span> <span class="n">set.has_Union</span> <span class="o">(</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">has_Union</span> <span class="o">(</span><span class="n">ι</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">set</span> <span class="n">β</span><span class="o">)</span> <span class="n">f</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">Union</span> <span class="o">:=</span> <span class="n">set.Union</span> <span class="n">f</span> <span class="o">}</span>

<span class="kd">lemma</span> <span class="n">set.mem_Union'</span> <span class="o">{</span><span class="n">ι</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">β</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">β</span><span class="o">}</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="o">(</span><span class="bp">⋃</span><span class="n">i</span><span class="o">,</span> <span class="n">s</span> <span class="n">i</span><span class="o">)</span> <span class="bp">↔</span> <span class="bp">∃</span> <span class="n">i</span><span class="o">,</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span> <span class="n">i</span> <span class="o">:=</span>
<span class="n">set.mem_Union</span>

<span class="kd">instance</span> <span class="n">finset.has_Union_prop_nodep</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">has_Union</span> <span class="o">(</span><span class="n">p</span> <span class="bp">→</span> <span class="n">finset</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">finset</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">s</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">Union</span> <span class="o">:=</span> <span class="n">s</span> <span class="o">}</span>

<span class="kd">instance</span> <span class="n">finset.has_Union_prop</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable</span> <span class="n">p</span><span class="o">]</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">finset</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">has_Union</span> <span class="o">(</span><span class="n">p</span> <span class="bp">→</span> <span class="n">finset</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">finset</span> <span class="n">β</span><span class="o">)</span> <span class="n">f</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">Union</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="n">p</span> <span class="k">then</span> <span class="n">f</span> <span class="n">h</span> <span class="k">else</span> <span class="bp">∅</span> <span class="o">}</span>

<span class="kd">instance</span> <span class="n">finset.has_bUnion_nodep</span> <span class="o">(</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">ι</span><span class="o">)</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">β</span><span class="o">]</span>
  <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">finset</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">has_Union</span> <span class="o">(</span><span class="bp">Π</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ι</span><span class="o">),</span> <span class="n">finset</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">finset</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="bp">⋃</span><span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">),</span> <span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">Union</span> <span class="o">:=</span> <span class="o">(</span><span class="n">finset.univ</span> <span class="o">:</span> <span class="n">finset</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ι</span><span class="o">))</span><span class="bp">.</span><span class="n">bind</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="n">x.1</span><span class="o">)</span> <span class="o">}</span>

<span class="kd">instance</span> <span class="n">finset.has_bUnion</span> <span class="o">(</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">ι</span><span class="o">)</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">ι</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">β</span><span class="o">]</span>
  <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ι</span><span class="o">),</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span> <span class="bp">→</span> <span class="n">finset</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">has_Union</span> <span class="o">(</span><span class="bp">Π</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ι</span><span class="o">),</span> <span class="n">finset</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">finset</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="bp">⋃</span><span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">),</span> <span class="n">f</span> <span class="n">x</span> <span class="n">h</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">Union</span> <span class="o">:=</span> <span class="o">(</span><span class="n">finset.univ</span> <span class="o">:</span> <span class="n">finset</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ι</span><span class="o">))</span><span class="bp">.</span><span class="n">bind</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="n">x.1</span> <span class="n">x.2</span><span class="o">)</span> <span class="o">}</span>

<span class="kd">instance</span> <span class="n">finset.has_Union</span> <span class="o">(</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">ι</span><span class="o">]</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">β</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">finset</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">has_Union</span> <span class="o">(</span><span class="n">ι</span> <span class="bp">→</span> <span class="n">finset</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">finset</span> <span class="n">β</span><span class="o">)</span> <span class="n">f</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">Union</span> <span class="o">:=</span> <span class="n">finset.univ.bind</span> <span class="n">f</span> <span class="o">}</span>

<span class="kd">lemma</span> <span class="n">finset.bUnion_eq_bind</span> <span class="o">(</span><span class="n">ι</span> <span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span>
  <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">ι</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">⋃</span><span class="n">i</span><span class="bp">∈</span><span class="n">s</span><span class="o">,</span> <span class="n">f</span> <span class="n">i</span><span class="o">)</span> <span class="bp">=</span> <span class="n">s.bind</span> <span class="n">f</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">ext</span> <span class="n">a</span><span class="o">,</span> <span class="n">simp</span> <span class="o">[</span><span class="n">has_Union.Union</span><span class="o">]</span> <span class="o">}</span>

<span class="kd">lemma</span> <span class="n">finset.Union_eq_univ_bind</span> <span class="o">(</span><span class="n">ι</span> <span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">ι</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span>
  <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">⋃</span><span class="n">i</span><span class="o">,</span> <span class="n">f</span> <span class="n">i</span><span class="o">)</span> <span class="bp">=</span> <span class="n">finset.univ.bind</span> <span class="n">f</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">ext</span> <span class="n">a</span><span class="o">,</span> <span class="n">simp</span> <span class="o">[</span><span class="n">has_Union.Union</span><span class="o">]</span> <span class="o">}</span>

<span class="kd">lemma</span> <span class="n">finset.bUnion_bUnion_eq</span> <span class="o">(</span><span class="n">ι</span> <span class="n">ι'</span> <span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span>
  <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">ι</span><span class="o">)</span> <span class="o">(</span><span class="n">s'</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">ι'</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">ι'</span> <span class="bp">→</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">⋃</span><span class="o">(</span><span class="n">i</span><span class="bp">∈</span><span class="n">s</span><span class="o">)</span> <span class="o">(</span><span class="n">j</span><span class="bp">∈</span><span class="n">s'</span><span class="o">),</span> <span class="n">f</span> <span class="n">i</span> <span class="n">j</span><span class="o">)</span> <span class="bp">=</span> <span class="n">s.bind</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">s'.bind</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">y</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="n">y</span><span class="o">))</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">ext</span> <span class="n">a</span><span class="o">,</span> <span class="n">simp</span> <span class="o">[</span><span class="n">has_Union.Union</span><span class="o">]</span> <span class="o">}</span>
</code></pre></div>



<a name="222661346"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finsets%2C%20unions%2C%20and%20cardinality/near/222661346" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finsets.2C.20unions.2C.20and.20cardinality.html#222661346">(Jan 13 2021 at 23:20)</a>:</h4>
<p>Why do you have <code>f</code> in the typeclass arguments?</p>



<a name="222661527"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finsets%2C%20unions%2C%20and%20cardinality/near/222661527" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finsets.2C.20unions.2C.20and.20cardinality.html#222661527">(Jan 13 2021 at 23:22)</a>:</h4>
<p>Oh, I guess the variant instances answer that</p>



<a name="222729437"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finsets%2C%20unions%2C%20and%20cardinality/near/222729437" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finsets.2C.20unions.2C.20and.20cardinality.html#222729437">(Jan 14 2021 at 15:09)</a>:</h4>
<p>Getting the notation to work for both sets and finsets (and multisets?) seems like a great change to me!</p>



<a name="222755987"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finsets%2C%20unions%2C%20and%20cardinality/near/222755987" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finsets.2C.20unions.2C.20and.20cardinality.html#222755987">(Jan 14 2021 at 17:56)</a>:</h4>
<p>If <code>⋃i∈s, f i</code> means to union over every <code>i</code> with multiplicity when <code>s</code> is a multiset, then these two additional instances give fancy notation for <code>multiset.bind</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="n">multiset.has_Union_prop_nodep</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">multiset</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">has_Union</span> <span class="o">(</span><span class="n">p</span> <span class="bp">→</span> <span class="n">multiset</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">multiset</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">s</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">Union</span> <span class="o">:=</span> <span class="n">s</span> <span class="o">}</span>

<span class="kd">instance</span> <span class="n">multiset.has_bUnion</span> <span class="o">(</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">multiset</span> <span class="n">ι</span><span class="o">)</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">β</span><span class="o">]</span>
  <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">multiset</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">has_Union</span> <span class="o">(</span><span class="n">ι</span> <span class="bp">→</span> <span class="n">multiset</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">multiset</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="bp">⋃</span><span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">),</span> <span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">Union</span> <span class="o">:=</span> <span class="n">s.bind</span> <span class="n">f</span> <span class="o">}</span>

<span class="kd">lemma</span> <span class="n">multiset.bUnion_eq_bind</span> <span class="o">(</span><span class="n">ι</span> <span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span>
  <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">multiset</span> <span class="n">ι</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">multiset</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="bp">⋃</span><span class="n">i</span><span class="bp">∈</span><span class="n">s</span><span class="o">,</span> <span class="n">f</span> <span class="n">i</span><span class="o">)</span> <span class="bp">=</span> <span class="n">s.bind</span> <span class="n">f</span> <span class="o">:=</span> <span class="n">rfl</span>
</code></pre></div>



<a name="223294027"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finsets%2C%20unions%2C%20and%20cardinality/near/223294027" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finsets.2C.20unions.2C.20and.20cardinality.html#223294027">(Jan 19 2021 at 21:03)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/issues/5813">#5813</a> is renaming <code>multiset.bind</code> to <code>multiset.bUnion</code> and <code>finset.bind</code> to <code>finset.bUnion</code>.</p>
<p>(Is there a way to create a definition that causes a deprecation warning to show up if you use it? Or maybe a linter error?)</p>



<a name="223350070"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finsets%2C%20unions%2C%20and%20cardinality/near/223350070" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finsets.2C.20unions.2C.20and.20cardinality.html#223350070">(Jan 20 2021 at 09:40)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/113488-general/topic/finsets.2C.20unions.2C.20and.20cardinality/near/223294027">said</a>:</p>
<blockquote>
<p>(Is there a way to create a definition that causes a deprecation warning to show up if you use it? Or maybe a linter error?)</p>
</blockquote>
<p>It might be possible to adapt the <code>&gt;</code>/≥` linter to do so. But in this case, the mathlib development style is to just get rid of the old name and let the existing usages cause an error. Then the new name will be used soon enough.</p>



<a name="223411059"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finsets%2C%20unions%2C%20and%20cardinality/near/223411059" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finsets.2C.20unions.2C.20and.20cardinality.html#223411059">(Jan 20 2021 at 18:03)</a>:</h4>
<p><span class="user-mention" data-user-id="246273">@Bhavik Mehta</span> pointed out that <code>multiset.bind</code> is not actually the union of the indexed family of multisets, but the sum, so <a href="https://github.com/leanprover-community/mathlib/issues/5813">#5813</a> is now just for renaming <code>finset.bind</code> to <code>finset.bUnion</code>.</p>
<p>It might be good having the corresponding <code>multiset</code> union of an indexed family:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">multiset.bUnion</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">β</span><span class="o">]</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">multiset</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">multiset</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">multiset</span> <span class="n">β</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">s.map</span> <span class="n">t</span><span class="o">)</span><span class="bp">.</span><span class="n">sup</span>
</code></pre></div>
<p>(It turns out <code>finset.sup</code> and <code>multiset.sup</code> have different interfaces, hence the <code>multiset.map</code> in there.)</p>



<a name="223848597"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finsets%2C%20unions%2C%20and%20cardinality/near/223848597" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finsets.2C.20unions.2C.20and.20cardinality.html#223848597">(Jan 25 2021 at 01:57)</a>:</h4>
<p>Any objections to <a href="https://github.com/leanprover-community/mathlib/issues/5813">#5813</a> (renaming <code>finset.bind</code> to <code>finset.bUnion</code>)? It's a big change and likely to break a lot of code that depends on mathlib, but should make the function much easier to find.</p>
<p>(One thing we should also really do that would help with that is greatly expand the module docstring of <code>data.finset.basic</code>.)</p>



<a name="223850190"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finsets%2C%20unions%2C%20and%20cardinality/near/223850190" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hanting Zhang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finsets.2C.20unions.2C.20and.20cardinality.html#223850190">(Jan 25 2021 at 02:38)</a>:</h4>
<p>Yes, please rename. I couldn't find <code>finset.bUnion</code> in any searches. It seems like the most obvious name. Also why is <code>finset.attach</code> called <code>finset.attach</code>? Why is it not <code>finset.to_idk_fintype_val</code>? (I doubt this is any better.)</p>



<a name="223850332"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finsets%2C%20unions%2C%20and%20cardinality/near/223850332" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finsets.2C.20unions.2C.20and.20cardinality.html#223850332">(Jan 25 2021 at 02:42)</a>:</h4>
<p>It doesn't spit out a fintype though right? I guess it is analogous to <a href="https://leanprover-community.github.io/mathlib_docs/find/list.attach">docs#list.attach</a></p>



<a name="223850488"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finsets%2C%20unions%2C%20and%20cardinality/near/223850488" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hanting Zhang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finsets.2C.20unions.2C.20and.20cardinality.html#223850488">(Jan 25 2021 at 02:47)</a>:</h4>
<p>Oops. My bad.</p>



<a name="223850504"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finsets%2C%20unions%2C%20and%20cardinality/near/223850504" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finsets.2C.20unions.2C.20and.20cardinality.html#223850504">(Jan 25 2021 at 02:47)</a>:</h4>
<p>I agree its not an obvious name though!</p>



<a name="223850548"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finsets%2C%20unions%2C%20and%20cardinality/near/223850548" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finsets.2C.20unions.2C.20and.20cardinality.html#223850548">(Jan 25 2021 at 02:48)</a>:</h4>
<p>it's not an easy thing to name</p>



<a name="223850562"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finsets%2C%20unions%2C%20and%20cardinality/near/223850562" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finsets.2C.20unions.2C.20and.20cardinality.html#223850562">(Jan 25 2021 at 02:49)</a>:</h4>
<p>A lot of definitions on finset (including <code>finset.bind</code>) got their names because they are analogous to definitions on <code>multiset</code> and/or <code>list</code></p>



<a name="223850567"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finsets%2C%20unions%2C%20and%20cardinality/near/223850567" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finsets.2C.20unions.2C.20and.20cardinality.html#223850567">(Jan 25 2021 at 02:49)</a>:</h4>
<p>unfortunately this clashes in some places with naming on <code>set</code></p>



<a name="223850631"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finsets%2C%20unions%2C%20and%20cardinality/near/223850631" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finsets.2C.20unions.2C.20and.20cardinality.html#223850631">(Jan 25 2021 at 02:50)</a>:</h4>
<p>and for the most part <code>finset</code> prefers <code>set</code> like naming over <code>list</code> like, for example the empty thing is called <code>list.nil</code>, <code>multiset.zero</code>, <code>finset.empty</code> and <code>set.empty</code></p>



<a name="223850700"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finsets%2C%20unions%2C%20and%20cardinality/near/223850700" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finsets.2C.20unions.2C.20and.20cardinality.html#223850700">(Jan 25 2021 at 02:52)</a>:</h4>
<p>I think we should try to minimize naming variation where we can, so if this is called <code>list.attach</code> already then the finset version should be called <code>finset.attach</code> unless there is a much stronger name association on sets</p>



<a name="223850780"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finsets%2C%20unions%2C%20and%20cardinality/near/223850780" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finsets.2C.20unions.2C.20and.20cardinality.html#223850780">(Jan 25 2021 at 02:54)</a>:</h4>
<p>Yeah at least something like <code>map_subtype_mem</code> seems vaguely more descriptive than attach, if you asked me what <code>list.attach</code> does I'd never be able to guess. Of course if things have well known name in Haskell/FP that's a reason to use a less descriptive name if its to remain consistent with those languages, but it doesn't seem like that is the case here?</p>



<a name="223850872"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finsets%2C%20unions%2C%20and%20cardinality/near/223850872" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finsets.2C.20unions.2C.20and.20cardinality.html#223850872">(Jan 25 2021 at 02:57)</a>:</h4>
<p>I think that definitions should have single word names (or at least single name segment names) where possible, because otherwise it makes it much more confusing when reading theorems about the definition</p>



<a name="223850888"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finsets%2C%20unions%2C%20and%20cardinality/near/223850888" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finsets.2C.20unions.2C.20and.20cardinality.html#223850888">(Jan 25 2021 at 02:57)</a>:</h4>
<p><code>list.filter_map</code> is a naming nightmare</p>



<a name="223850943"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finsets%2C%20unions%2C%20and%20cardinality/near/223850943" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finsets.2C.20unions.2C.20and.20cardinality.html#223850943">(Jan 25 2021 at 02:58)</a>:</h4>
<p>Is it possible to have both <code>finset.bind</code> and <code>finset.bUnion</code> with aliases?</p>



<a name="223850958"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finsets%2C%20unions%2C%20and%20cardinality/near/223850958" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finsets.2C.20unions.2C.20and.20cardinality.html#223850958">(Jan 25 2021 at 02:59)</a>:</h4>
<p>yes, although does that mean we're duplicating the theorems too?</p>



<a name="223850967"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finsets%2C%20unions%2C%20and%20cardinality/near/223850967" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finsets.2C.20unions.2C.20and.20cardinality.html#223850967">(Jan 25 2021 at 02:59)</a>:</h4>
<p>if we do add an alias we still shouldn't use it in mathlib</p>



<a name="224000328"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finsets%2C%20unions%2C%20and%20cardinality/near/224000328" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hanting Zhang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finsets.2C.20unions.2C.20and.20cardinality.html#224000328">(Jan 26 2021 at 05:58)</a>:</h4>
<p>In lieu of <span class="user-mention" data-user-id="123965">@Bryan Gin-ge Chen</span>'s  comment on expanding <code>finset.basic</code> docs, I've made a very rough PR (<a href="https://github.com/leanprover-community/mathlib/issues/5893">#5893</a>) that is not finished. I'm not entirely sure what standards there are for writing paragraphs upon paragraphs of documentation, so I've just taken my best shot at it for now. </p>
<p>Anyone who has time to add something, please do!</p>



<a name="224000633"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finsets%2C%20unions%2C%20and%20cardinality/near/224000633" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finsets.2C.20unions.2C.20and.20cardinality.html#224000633">(Jan 26 2021 at 06:05)</a>:</h4>
<p>Looks good so far, unfinished PRs are Ok, you can tag it with WIP and help-wanted if you want.<br>
You can also preview (roughly) how it will look using <span class="user-mention" data-user-id="123965">@Bryan Gin-ge Chen</span> s previewer <a href="https://observablehq.com/@bryangingechen/github-lean-file-viewer?url=%22https://github.com/leanprover-community/mathlib/pull/5893/%22#docs">https://observablehq.com/@bryangingechen/github-lean-file-viewer?url=%22https://github.com/leanprover-community/mathlib/pull/5893/%22#docs</a> here it looks like the numbered lists aren't displaying properly, I think markdown syntax needs to be like</p>
<div class="codehilite" data-code-language="markdown"><pre><span></span><code><span class="k">1.</span> blah
<span class="k">2.</span> blah blah
</code></pre></div>
<p>to work properly</p>



<a name="224000723"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finsets%2C%20unions%2C%20and%20cardinality/near/224000723" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finsets.2C.20unions.2C.20and.20cardinality.html#224000723">(Jan 26 2021 at 06:07)</a>:</h4>
<p>Thanks for doing this <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span>!</p>



<a name="224129427"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finsets%2C%20unions%2C%20and%20cardinality/near/224129427" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finsets.2C.20unions.2C.20and.20cardinality.html#224129427">(Jan 27 2021 at 01:31)</a>:</h4>
<p>Here's another attempt at generalized big union notation, and it seems to work, but it should be tested with some real math rather than my basic examples.  One wart, to make the code simpler, is to have a default instance for the <code>Union</code> class called <code>Union.failure</code> to help with defining the instances for <code>finset</code> bounded unions -- the issue has to do with missing decidable instances.</p>
<p>A cool thing is that you can define instances for unioning over properties whose support is finite: <code>(⋃(i&lt;10), finset.range i) = finset.range 9</code>.  It can even handle dependent finite unions: <code>(⋃i (h:i&lt;10), ({⟨i, h⟩} : finset (fin 10))) = finset.univ</code>.</p>
<p>I imagine this design pattern would work for summation and product notation, too.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.set.basic</span>
<span class="kn">import</span> <span class="n">data.set.lattice</span>
<span class="kn">import</span> <span class="n">data.finset.basic</span>
<span class="kn">import</span> <span class="n">data.fintype.basic</span>
<span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">universes</span> <span class="n">u</span> <span class="n">v</span> <span class="n">w</span>

<span class="kn">namespace</span> <span class="n">new_Union</span>

<span class="kd">class</span> <span class="n">Union</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">γ</span> <span class="o">:</span> <span class="n">out_param</span> <span class="bp">$</span> <span class="kt">Sort</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">union</span> <span class="o">:</span> <span class="n">γ</span><span class="o">)</span>

<span class="kn">local</span> <span class="kd">notation</span> <span class="bp">`⋃`</span> <span class="n">binders</span> <span class="bp">`</span><span class="o">,</span> <span class="bp">`</span> <span class="n">r</span><span class="o">:(</span><span class="n">scoped</span> <span class="n">f</span><span class="o">,</span> <span class="n">Union.union</span> <span class="n">f</span><span class="o">)</span> <span class="o">:=</span> <span class="n">r</span>

<span class="sd">/-- To have bounded unions, there needs to be a `Union.union` instance for the internal</span>
<span class="sd">union (the `⋃(h : x ∈ s), f x`) even when one doesn't technically exist, for example</span>
<span class="sd">due to a lack of decidable equality for `finset`.  As a hack, we have this `Union.failure`</span>
<span class="sd">type that gives a low-priority default instance. -/</span>
<span class="kd">structure</span> <span class="n">Union.failure</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span>

<span class="kd">@[priority 0]</span>
<span class="kd">instance</span> <span class="n">Union.default_failure</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">Union</span> <span class="n">x</span> <span class="o">(</span><span class="n">Union.failure</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">union</span> <span class="o">:=</span> <span class="n">Union.failure.mk</span> <span class="n">x</span> <span class="o">}</span>

<span class="kd">instance</span> <span class="n">set_Union</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">Union</span> <span class="n">f</span> <span class="o">(</span><span class="n">set</span> <span class="n">β</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">union</span> <span class="o">:=</span> <span class="n">set.Union</span> <span class="n">f</span> <span class="o">}</span>

<span class="kd">instance</span> <span class="n">fintype_Union</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">finset</span> <span class="n">β</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">β</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">Union</span> <span class="n">t</span> <span class="o">(</span><span class="n">finset</span> <span class="n">β</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">union</span> <span class="o">:=</span> <span class="n">finset.univ.bUnion</span> <span class="n">t</span> <span class="o">}</span>

<span class="kd">instance</span> <span class="n">finset_dep_bUnion</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span><span class="o">}</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">β</span><span class="o">]</span>
  <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="bp">Π</span><span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">),</span> <span class="n">finset</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">Union</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">Union.union</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">),</span> <span class="n">t</span> <span class="n">x</span> <span class="n">h</span><span class="o">))</span> <span class="o">(</span><span class="n">finset</span> <span class="n">β</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">union</span> <span class="o">:=</span> <span class="n">s.attach.bUnion</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">t</span> <span class="n">x.1</span> <span class="n">x.2</span><span class="o">)</span> <span class="o">}</span>

<span class="kd">instance</span> <span class="n">finset_bUnion</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span><span class="o">}</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">finset</span> <span class="n">β</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">β</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">Union</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">Union.union</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">),</span> <span class="n">t</span> <span class="n">x</span><span class="o">))</span> <span class="o">(</span><span class="n">finset</span> <span class="n">β</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">union</span> <span class="o">:=</span> <span class="n">s.bUnion</span> <span class="n">t</span> <span class="o">}</span>

<span class="kd">instance</span> <span class="n">finset_dep_bUnion_fin_prop</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span><span class="o">}</span>
  <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_pred</span> <span class="n">p</span><span class="o">]</span> <span class="o">[</span><span class="n">fintype</span> <span class="o">{</span><span class="n">x</span> <span class="bp">|</span> <span class="n">p</span> <span class="n">x</span><span class="o">}]</span>
  <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="bp">Π</span><span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">p</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">finset</span> <span class="n">β</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">β</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">Union</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">Union.union</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">p</span> <span class="n">x</span><span class="o">),</span> <span class="n">t</span> <span class="n">x</span> <span class="n">h</span><span class="o">))</span> <span class="o">(</span><span class="n">finset</span> <span class="n">β</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">union</span> <span class="o">:=</span> <span class="o">(</span><span class="n">finset.univ</span> <span class="o">:</span> <span class="n">finset</span> <span class="o">{</span><span class="n">x</span> <span class="bp">|</span> <span class="n">p</span> <span class="n">x</span><span class="o">})</span><span class="bp">.</span><span class="n">bUnion</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">t</span> <span class="n">x.1</span> <span class="n">x.2</span><span class="o">)</span> <span class="o">}</span>

<span class="kd">instance</span> <span class="n">finset_bUnion_fin_prop</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span><span class="o">}</span>
  <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_pred</span> <span class="n">p</span><span class="o">]</span> <span class="o">[</span><span class="n">fintype</span> <span class="o">{</span><span class="n">x</span> <span class="bp">|</span> <span class="n">p</span> <span class="n">x</span><span class="o">}]</span>
  <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">finset</span> <span class="n">β</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">β</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">Union</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">Union.union</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">p</span> <span class="n">x</span><span class="o">),</span> <span class="n">t</span> <span class="n">x</span><span class="o">))</span> <span class="o">(</span><span class="n">finset</span> <span class="n">β</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">union</span> <span class="o">:=</span> <span class="o">(</span><span class="n">finset.univ</span> <span class="o">:</span> <span class="n">finset</span> <span class="o">{</span><span class="n">x</span> <span class="bp">|</span> <span class="n">p</span> <span class="n">x</span><span class="o">})</span><span class="bp">.</span><span class="n">bUnion</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">t</span> <span class="n">x.1</span><span class="o">)</span> <span class="o">}</span>

<span class="kn">section</span> <span class="n">set_test</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="bp">⋃</span><span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="o">{</span><span class="n">y</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">y</span> <span class="bp">∈</span> <span class="n">f</span> <span class="n">x</span><span class="o">}</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">ext</span><span class="o">,</span> <span class="n">simp</span> <span class="o">[</span><span class="n">Union.union</span><span class="o">]</span> <span class="o">}</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="bp">⋃</span><span class="n">x</span><span class="bp">∈</span><span class="n">s</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="o">{</span><span class="n">y</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span> <span class="bp">∧</span> <span class="n">y</span> <span class="bp">∈</span> <span class="n">f</span> <span class="n">x</span><span class="o">}</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">ext</span><span class="o">,</span> <span class="n">simp</span> <span class="o">[</span><span class="n">Union.union</span><span class="o">]</span> <span class="o">}</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="n">γ</span><span class="o">}</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">γ</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">⋃</span><span class="o">(</span><span class="n">x</span><span class="bp">∈</span><span class="n">s</span><span class="o">)</span> <span class="n">y</span><span class="o">,</span> <span class="n">t</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="o">{</span><span class="n">z</span> <span class="o">:</span> <span class="n">γ</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">x</span><span class="bp">∈</span><span class="n">s</span><span class="o">)</span> <span class="n">y</span><span class="o">,</span> <span class="n">z</span> <span class="bp">∈</span> <span class="n">t</span> <span class="n">x</span> <span class="n">y</span><span class="o">}</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">ext</span><span class="o">,</span> <span class="n">simp</span> <span class="o">[</span><span class="n">Union.union</span><span class="o">]</span> <span class="o">}</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="n">γ</span><span class="o">}</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">γ</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">⋃</span><span class="n">y</span> <span class="o">(</span><span class="n">x</span><span class="bp">∈</span><span class="n">s</span><span class="o">),</span> <span class="n">t</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="o">{</span><span class="n">z</span> <span class="o">:</span> <span class="n">γ</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">x</span><span class="bp">∈</span><span class="n">s</span><span class="o">)</span> <span class="n">y</span><span class="o">,</span> <span class="n">z</span> <span class="bp">∈</span> <span class="n">t</span> <span class="n">x</span> <span class="n">y</span><span class="o">}</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">ext</span><span class="o">,</span> <span class="n">simp</span> <span class="o">[</span><span class="n">Union.union</span><span class="o">],</span> <span class="n">tidy</span><span class="o">,</span> <span class="o">}</span>

<span class="kd">end</span> <span class="n">set_test</span>

<span class="kn">section</span> <span class="n">finset_test</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">β</span><span class="o">]</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">finset</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)</span>

<span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="bp">⋃</span><span class="n">x</span><span class="bp">∈</span><span class="n">s</span><span class="o">,</span> <span class="n">t</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">s.bUnion</span> <span class="n">t</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">example</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="o">(</span><span class="bp">⋃</span><span class="n">x</span><span class="o">,</span> <span class="n">t</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">finset.univ.bUnion</span> <span class="n">t</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">γ</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">γ</span><span class="o">]</span> <span class="o">(</span><span class="n">u</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">finset</span> <span class="n">γ</span><span class="o">)</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">γ</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">z</span> <span class="bp">∈</span> <span class="o">(</span><span class="bp">⋃</span><span class="o">(</span><span class="n">x</span><span class="bp">∈</span><span class="n">s</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span><span class="bp">∈</span><span class="n">t</span> <span class="n">x</span><span class="o">),</span> <span class="n">u</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="bp">↔</span>  <span class="bp">∃</span> <span class="o">(</span><span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="bp">∈</span> <span class="n">t</span> <span class="n">x</span><span class="o">),</span> <span class="n">z</span> <span class="bp">∈</span> <span class="n">u</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">Union.union</span><span class="o">]</span> <span class="o">}</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">γ</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">γ</span><span class="o">]</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">finset</span> <span class="n">γ</span><span class="o">)</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">β</span><span class="o">]</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">γ</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">z</span> <span class="bp">∈</span> <span class="o">(</span><span class="bp">⋃</span><span class="o">(</span><span class="n">x</span><span class="bp">∈</span><span class="n">s</span><span class="o">)</span> <span class="n">y</span><span class="o">,</span> <span class="n">t</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="bp">↔</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">x</span><span class="bp">∈</span><span class="n">s</span><span class="o">)</span> <span class="n">y</span><span class="o">,</span> <span class="n">z</span> <span class="bp">∈</span> <span class="n">t</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">Union.union</span><span class="o">],</span> <span class="o">}</span>

<span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="bp">⋃</span><span class="o">(</span><span class="n">i</span><span class="bp">&lt;</span><span class="mi">10</span><span class="o">),</span> <span class="n">finset.range</span> <span class="n">i</span><span class="o">)</span> <span class="bp">=</span> <span class="n">finset.range</span> <span class="mi">9</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">ext</span><span class="o">,</span> <span class="n">simp</span> <span class="o">[</span><span class="n">Union.union</span><span class="o">],</span> <span class="n">tidy</span><span class="o">,</span> <span class="n">omega</span><span class="o">,</span> <span class="o">}</span>

<span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="bp">⋃</span><span class="n">i</span> <span class="o">(</span><span class="n">h</span><span class="o">:</span><span class="n">i</span><span class="bp">&lt;</span><span class="mi">10</span><span class="o">),</span> <span class="o">({⟨</span><span class="n">i</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩}</span> <span class="o">:</span> <span class="n">finset</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">10</span><span class="o">)))</span> <span class="bp">=</span> <span class="n">finset.univ</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">ext</span><span class="o">,</span> <span class="n">simp</span> <span class="o">[</span><span class="n">Union.union</span><span class="o">],</span> <span class="n">tidy</span><span class="o">,</span> <span class="o">}</span>

<span class="kd">end</span> <span class="n">finset_test</span>

<span class="kd">end</span> <span class="n">new_Union</span>
</code></pre></div>



<a name="224132747"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finsets%2C%20unions%2C%20and%20cardinality/near/224132747" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finsets.2C.20unions.2C.20and.20cardinality.html#224132747">(Jan 27 2021 at 02:25)</a>:</h4>
<p>It works for summation notation, too.  For example, <code>2 * (∑(i ≤ n), i) = n * (n + 1)</code>.</p>
<p>This also gives a nice way to do summations over multisets.  We can define <code>(∑ (x ∈ s), f x) = (s.map f).sum</code>, where the sum is done with multiplicity.  (This is also another notation for <code>multiset.bind</code>, since it's defined to be the sum of an indexed family of multisets.)</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.finset.basic</span>
<span class="kn">import</span> <span class="n">data.fintype.basic</span>
<span class="kn">import</span> <span class="n">algebra.big_operators.basic</span>
<span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">universes</span> <span class="n">u</span> <span class="n">v</span> <span class="n">w</span>

<span class="kn">namespace</span> <span class="n">new_sum</span>

<span class="kd">class</span> <span class="n">has_sum</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">γ</span> <span class="o">:</span> <span class="n">out_param</span> <span class="bp">$</span> <span class="kt">Sort</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">sum</span> <span class="o">:</span> <span class="n">γ</span><span class="o">)</span>

<span class="kn">local</span> <span class="kd">notation</span> <span class="bp">`∑`</span> <span class="n">binders</span> <span class="bp">`</span><span class="o">,</span> <span class="bp">`</span> <span class="n">r</span><span class="o">:(</span><span class="n">scoped</span> <span class="n">f</span><span class="o">,</span> <span class="n">has_sum.sum</span> <span class="n">f</span><span class="o">)</span> <span class="o">:=</span> <span class="n">r</span>

<span class="sd">/-- This is a hack to help define bounded sums.  Try removing it to see why it's necessary. -/</span>
<span class="kd">structure</span> <span class="n">has_sum.failure</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span>

<span class="kd">@[priority 0]</span>
<span class="kd">instance</span> <span class="n">has_sum.default_failure</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">has_sum</span> <span class="n">x</span> <span class="o">(</span><span class="n">has_sum.failure</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">sum</span> <span class="o">:=</span> <span class="n">has_sum.failure.mk</span> <span class="n">x</span> <span class="o">}</span>

<span class="kd">instance</span> <span class="n">fintype_sum</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">β</span><span class="o">]</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">has_sum</span> <span class="n">t</span> <span class="n">β</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">sum</span> <span class="o">:=</span> <span class="n">finset.univ.sum</span> <span class="n">t</span> <span class="o">}</span>

<span class="kd">instance</span> <span class="n">finset_dep_sum</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span><span class="o">}</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">β</span><span class="o">]</span>
  <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="bp">Π</span><span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">),</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">has_sum</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">has_sum.sum</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">),</span> <span class="n">t</span> <span class="n">x</span> <span class="n">h</span><span class="o">))</span> <span class="n">β</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">sum</span> <span class="o">:=</span> <span class="n">s.attach.sum</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">t</span> <span class="n">x.1</span> <span class="n">x.2</span><span class="o">)</span> <span class="o">}</span>

<span class="kd">instance</span> <span class="n">finset_sum</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span><span class="o">}</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">β</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">has_sum</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">has_sum.sum</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">),</span> <span class="n">t</span> <span class="n">x</span><span class="o">))</span> <span class="n">β</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">sum</span> <span class="o">:=</span> <span class="n">s.sum</span> <span class="n">t</span> <span class="o">}</span>

<span class="kd">instance</span> <span class="n">finset_dep_sum_fin_prop</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">β</span><span class="o">]</span>
  <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_pred</span> <span class="n">p</span><span class="o">]</span> <span class="o">[</span><span class="n">fintype</span> <span class="o">{</span><span class="n">x</span> <span class="bp">|</span> <span class="n">p</span> <span class="n">x</span><span class="o">}]</span>
  <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="bp">Π</span><span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">p</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">has_sum</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">has_sum.sum</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">p</span> <span class="n">x</span><span class="o">),</span> <span class="n">t</span> <span class="n">x</span> <span class="n">h</span><span class="o">))</span> <span class="n">β</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">sum</span> <span class="o">:=</span> <span class="o">(</span><span class="n">finset.univ</span> <span class="o">:</span> <span class="n">finset</span> <span class="o">{</span><span class="n">x</span> <span class="bp">|</span> <span class="n">p</span> <span class="n">x</span><span class="o">})</span><span class="bp">.</span><span class="n">sum</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">t</span> <span class="n">x.1</span> <span class="n">x.2</span><span class="o">)</span> <span class="o">}</span>

<span class="kd">instance</span> <span class="n">finset_sum_fin_prop</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">β</span><span class="o">]</span>
  <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_pred</span> <span class="n">p</span><span class="o">]</span> <span class="o">[</span><span class="n">fintype</span> <span class="o">{</span><span class="n">x</span> <span class="bp">|</span> <span class="n">p</span> <span class="n">x</span><span class="o">}]</span>
  <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">has_sum</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">has_sum.sum</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">p</span> <span class="n">x</span><span class="o">),</span> <span class="n">t</span> <span class="n">x</span><span class="o">))</span> <span class="n">β</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">sum</span> <span class="o">:=</span> <span class="o">(</span><span class="n">finset.univ</span> <span class="o">:</span> <span class="n">finset</span> <span class="o">{</span><span class="n">x</span> <span class="bp">|</span> <span class="n">p</span> <span class="n">x</span><span class="o">})</span><span class="bp">.</span><span class="n">sum</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">t</span> <span class="n">x.1</span><span class="o">)</span> <span class="o">}</span>

<span class="kd">lemma</span> <span class="n">sum_le_eq_sum_range</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∑</span><span class="o">(</span><span class="n">i</span> <span class="bp">≤</span> <span class="n">n</span><span class="o">),</span> <span class="n">f</span> <span class="n">i</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="bp">∑</span><span class="o">(</span><span class="n">i</span> <span class="bp">∈</span> <span class="n">finset.range</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)),</span> <span class="n">f</span> <span class="n">i</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">has_sum.sum</span><span class="o">],</span>
  <span class="n">rw</span> <span class="bp">←</span><span class="n">finset.sum_image</span><span class="o">,</span>
  <span class="n">congr</span><span class="o">,</span> <span class="n">ext</span><span class="o">,</span> <span class="n">simp</span><span class="o">,</span> <span class="n">omega</span><span class="o">,</span>
  <span class="n">tidy</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">sum_le_succ</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∑</span><span class="o">(</span><span class="n">i</span> <span class="bp">≤</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">),</span> <span class="n">f</span> <span class="n">i</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">+</span> <span class="o">(</span><span class="bp">∑</span><span class="o">(</span><span class="n">i</span> <span class="bp">≤</span> <span class="n">n</span><span class="o">),</span> <span class="n">f</span> <span class="n">i</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">repeat</span> <span class="o">{</span> <span class="n">rw</span> <span class="n">sum_le_eq_sum_range</span><span class="o">,</span> <span class="o">},</span>
  <span class="n">dunfold</span> <span class="n">has_sum.sum</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">finset.sum_range_succ</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="mi">2</span> <span class="bp">*</span> <span class="o">(</span><span class="bp">∑</span><span class="o">(</span><span class="n">i</span> <span class="bp">≤</span> <span class="n">n</span><span class="o">),</span> <span class="n">i</span><span class="o">)</span> <span class="bp">=</span> <span class="n">n</span> <span class="bp">*</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">induction</span> <span class="n">n</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="n">sum_le_eq_sum_range</span><span class="o">,</span> <span class="n">simp</span> <span class="o">[</span><span class="n">has_sum.sum</span><span class="o">],</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">sum_le_succ</span><span class="o">,</span> <span class="n">mul_add</span><span class="o">,</span> <span class="n">n_ih</span><span class="o">,</span> <span class="n">nat.succ_eq_add_one</span><span class="o">],</span>
    <span class="n">ring</span><span class="o">,</span> <span class="o">},</span>
<span class="kd">end</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">multiset</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∑</span> <span class="o">(</span><span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">),</span> <span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">s.val.bind</span> <span class="n">f</span> <span class="o">:=</span>
<span class="n">rfl</span>

<span class="sd">/-- Sum over a multiset with repeats -/</span>
<span class="kd">instance</span> <span class="n">multiset_sum</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span><span class="o">}</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">multiset</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">β</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">has_sum</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">has_sum.sum</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">),</span> <span class="n">t</span> <span class="n">x</span><span class="o">))</span> <span class="n">β</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">sum</span> <span class="o">:=</span> <span class="o">(</span><span class="n">s.map</span> <span class="n">t</span><span class="o">)</span><span class="bp">.</span><span class="n">sum</span> <span class="o">}</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">multiset</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">multiset</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∑</span> <span class="o">(</span><span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">),</span> <span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">s.bind</span> <span class="n">f</span> <span class="o">:=</span>
<span class="n">rfl</span>

<span class="kd">end</span> <span class="n">new_sum</span>
</code></pre></div>



<a name="224132955"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finsets%2C%20unions%2C%20and%20cardinality/near/224132955" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finsets.2C.20unions.2C.20and.20cardinality.html#224132955">(Jan 27 2021 at 02:29)</a>:</h4>
<p>(A downside with this right now is that lemma statements that use the notation are in terms of <code>has_sum.sum</code>, where the current notation is guaranteed to be <code>finset.sum</code>, so you can easily use it without <code>open_locale big_operators</code>.)</p>



<a name="224138721"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finsets%2C%20unions%2C%20and%20cardinality/near/224138721" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finsets.2C.20unions.2C.20and.20cardinality.html#224138721">(Jan 27 2021 at 04:22)</a>:</h4>
<p><span class="user-mention" data-user-id="306601">@Kyle Miller</span> that looks really nice! And those downsides aren't very big downsides to me.<br>
If you have a generic class for using some sort of notation, like <code>Union.union</code> or <code>has_sum.sum</code> etc, then I don't think it needs to be local notation anymore.</p>



<a name="224150356"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finsets%2C%20unions%2C%20and%20cardinality/near/224150356" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finsets.2C.20unions.2C.20and.20cardinality.html#224150356">(Jan 27 2021 at 08:08)</a>:</h4>
<p>Does your sum/union notation allow arbitrarily nested dependent binders like are allowed today? Or only ones that match your patterns?</p>



<a name="224150486"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finsets%2C%20unions%2C%20and%20cardinality/near/224150486" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finsets.2C.20unions.2C.20and.20cardinality.html#224150486">(Jan 27 2021 at 08:10)</a>:</h4>
<p>I guess the litmus test would be to see whether we need to change 95% of the library when switching to this or only 5%.</p>



<a name="224151784"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finsets%2C%20unions%2C%20and%20cardinality/near/224151784" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finsets.2C.20unions.2C.20and.20cardinality.html#224151784">(Jan 27 2021 at 08:27)</a>:</h4>
<p>It would be cool if something like <a href="https://leanprover-community.github.io/mathlib_docs/find/finset.sum_hom">docs#finset.sum_hom</a> were part of the has_sum typeclass too, since that would unify a lot of lemmas</p>



<a name="224235171"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finsets%2C%20unions%2C%20and%20cardinality/near/224235171" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finsets.2C.20unions.2C.20and.20cardinality.html#224235171">(Jan 27 2021 at 19:29)</a>:</h4>
<p><span class="user-mention" data-user-id="310045">@Eric Wieser</span> It supports arbitrary nesting.  The patterns are applied "outside-in" so to speak.  There are some examples of nesting in the union example.</p>



<a name="224236732"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finsets%2C%20unions%2C%20and%20cardinality/near/224236732" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finsets.2C.20unions.2C.20and.20cardinality.html#224236732">(Jan 27 2021 at 19:41)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span> Switching to <code>has_union</code>, starting with just <code>set.Union</code>, probably should be a small change.  Switching <code>finset.bUnion</code> uses to <code>has_union.union</code> notation would probably be not so much bigger than the rename to <code>finset.bUnion</code> (something like 25 files).  I'm not sure how much effort summation/product notation would be yet.</p>



<a name="224236854"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finsets%2C%20unions%2C%20and%20cardinality/near/224236854" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finsets.2C.20unions.2C.20and.20cardinality.html#224236854">(Jan 27 2021 at 19:42)</a>:</h4>
<p>back when I introduced notation for <code>finset.sum</code> it was an "OK" refactor, I think</p>



<a name="224237239"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finsets%2C%20unions%2C%20and%20cardinality/near/224237239" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finsets.2C.20unions.2C.20and.20cardinality.html#224237239">(Jan 27 2021 at 19:45)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/113488-general/topic/finsets.2C.20unions.2C.20and.20cardinality/near/224151784">said</a>:</p>
<blockquote>
<p>It would be cool if something like <a href="https://leanprover-community.github.io/mathlib_docs/find/finset.sum_hom">docs#finset.sum_hom</a> were part of the has_sum typeclass too, since that would unify a lot of lemmas</p>
</blockquote>
<p>Either that or a companion typeclass that indicates that it's a "lawful" sum would be nice.  I'm not sure how you'd fit it into the <code>has_sum</code> typeclass itself, but let me know if you find a way.</p>



<a name="224237612"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finsets%2C%20unions%2C%20and%20cardinality/near/224237612" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finsets.2C.20unions.2C.20and.20cardinality.html#224237612">(Jan 27 2021 at 19:48)</a>:</h4>
<p>Another interesting application is that you can sum over sets that have a <code>fintype</code> instance without having to write <code>to_finset</code> yourself:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="n">finite_set_sum</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span><span class="o">}</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">s</span><span class="o">]</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">β</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">has_sum</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">has_sum.sum</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">),</span> <span class="n">t</span> <span class="n">x</span><span class="o">))</span> <span class="n">β</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">sum</span> <span class="o">:=</span> <span class="n">s.to_finset.sum</span> <span class="n">t</span> <span class="o">}</span>

<span class="kd">lemma</span> <span class="n">sum_neighbors</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">V</span><span class="o">]</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">∑</span><span class="o">(</span><span class="n">w</span> <span class="bp">∈</span> <span class="n">G.neighbor_set</span> <span class="n">v</span><span class="o">),</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">=</span> <span class="n">G.degree</span> <span class="n">v</span> <span class="o">:=</span>
<span class="kd">by</span>  <span class="n">simp</span> <span class="o">[</span><span class="n">has_sum.sum</span><span class="o">],</span>
</code></pre></div>
<p>(Then we can get rid of the combinatorial explosion of definitions like <code>simple_graph.neighbor_finset</code> and maybe rename <code>simple_graph.neighbor_set</code> to just <code>simple_graph.neighbors</code>.)</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
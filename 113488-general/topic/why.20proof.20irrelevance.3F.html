---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/why.20proof.20irrelevance.3F.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/why.20proof.20irrelevance.3F.html">why proof irrelevance?</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="271768629"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/why%20proof%20irrelevance%3F/near/271768629" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonard Wiechmann <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/why.20proof.20irrelevance.3F.html#271768629">(Feb 13 2022 at 22:19)</a>:</h4>
<p>strangely I can't find an answer to this: why do we care about proof irrelevance?<br>
i've found a few arguments referring to program extraction - those make sense. if you're going to extract, you don't want all the "evidence".<br>
but why do we care about it mathematically? what are some examples of how this makes theorem proving easier?<br>
i guess one of the things i've found is that it allows you to quantify over all propositions. but I don't quite see why that's worth the complexity.</p>
<p>edit: I guess my real question is: can someone give me an idea about what is hard/impossible without proof irrelevance?</p>



<a name="271768901"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/why%20proof%20irrelevance%3F/near/271768901" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/why.20proof.20irrelevance.3F.html#271768901">(Feb 13 2022 at 22:25)</a>:</h4>
<p>One answer is that if <code>s : set α</code>, then elements of <code>s</code> are in one-to-one correspondence with terms of <code>subtype (∈ s)</code> (that's <code>s</code> coerced to a type). If there weren't proof irrelevance, then in principle every element of <code>s</code> could correspond to more than one term of <code>subtype (∈ s)</code> (one for each membership proof).  Irrelevance seems to make it easier to blur the distinction between sets and types.</p>



<a name="271769864"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/why%20proof%20irrelevance%3F/near/271769864" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris B <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/why.20proof.20irrelevance.3F.html#271769864">(Feb 13 2022 at 22:46)</a>:</h4>
<p>I think one of the low hanging fruits is that you get definitional equality for any two <code>p p' : P</code>.</p>
<p><span class="user-mention silent" data-user-id="456923">Leonard Wiechmann</span> <a href="#narrow/stream/113488-general/topic/why.20proof.20irrelevance.3F/near/271768629">said</a>:</p>
<blockquote>
<p>I don't quite see why that's worth the complexity.</p>
</blockquote>
<p>Is it more complex? I'm not a type theory expert, but most of the stuff I've read about proof relevance has to do with higher inductive types, which certainly seem more complex than proof irrelevance.</p>



<a name="271770297"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/why%20proof%20irrelevance%3F/near/271770297" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonard Wiechmann <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/why.20proof.20irrelevance.3F.html#271770297">(Feb 13 2022 at 22:57)</a>:</h4>
<p>ok, i'm kind of getting a feeling for why it might be useful: sometimes you only want something to have a property and don't really care <em>why</em> it has that property. you can still use that property to derive other properties, just not if the proof is relevant. which appears to be very common. i think i'll get a better understanding for this by eg trying to prove some stuff without proof irrelevance.</p>
<p>re <span class="user-mention" data-user-id="228466">@Chris B</span> "Is it more complex?": i'm judging complexity by the number of typing rules, roughly. so the number of things that my type theory implementation needs to get right. also I don't really want to add rules that I don't understand too well, especially because it seems to be pretty easy to make a system inconsistent.</p>



<a name="271770852"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/why%20proof%20irrelevance%3F/near/271770852" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris B <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/why.20proof.20irrelevance.3F.html#271770852">(Feb 13 2022 at 23:06)</a>:</h4>
<p>Ah, I see where you're coming from. Mario's thesis on the type theory of lean has a section that discusses proof irrelevance and has some references to some other sources: <a href="https://github.com/digama0/lean-type-theory/releases/tag/v1.0">https://github.com/digama0/lean-type-theory/releases/tag/v1.0</a></p>



<a name="271770907"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/why%20proof%20irrelevance%3F/near/271770907" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonard Wiechmann <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/why.20proof.20irrelevance.3F.html#271770907">(Feb 13 2022 at 23:07)</a>:</h4>
<p>oh that sounds promising, thanks!!</p>



<a name="271849359"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/why%20proof%20irrelevance%3F/near/271849359" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonard Wiechmann <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/why.20proof.20irrelevance.3F.html#271849359">(Feb 14 2022 at 16:15)</a>:</h4>
<p>I messed around with a proof-relevant identity type.<br>
But I couldn't prove symmetry. I'm getting the feeling that it is impossible with proof relevance.<br>
I tried the same trick you use for <code>eq</code>: <code>eq_helper</code> in the code below.<br>
But the recursor requires a much more complicated type: <code>Π (a1 a2 : A), Eq a1 a2 → Sort l</code><br>
When trying to apply <code>Eq_helper</code> to <code>Eq.rec</code> anyway, I had to give an instance of <code>Π (a_1 : A), Eq a_1 a</code>, which of course doesn't exist in general.<br>
Maybe I'm missing something. Surely you can do rewrites in something like HoTT, right?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">universes</span> <span class="n">u</span> <span class="n">v</span>

<span class="kd">inductive</span> <span class="n">Eq</span> <span class="o">{</span><span class="n">A</span><span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">}</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">-&gt;</span> <span class="n">A</span> <span class="bp">-&gt;</span> <span class="kt">Sort</span> <span class="o">(</span><span class="n">max</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">refl</span> <span class="o">(</span><span class="n">a</span><span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="n">Eq</span> <span class="n">a</span> <span class="n">a</span>


<span class="kd">@[reducible]</span>
<span class="kd">def</span> <span class="n">eq_helper</span> <span class="o">(</span><span class="n">A</span><span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span><span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="o">(</span><span class="n">eq</span> <span class="n">x</span> <span class="n">a</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">eq_symm</span> <span class="o">(</span><span class="n">A</span><span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span><span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">eq</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="o">(</span><span class="n">eq</span> <span class="n">b</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intros</span> <span class="n">ab</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">aa</span> <span class="o">:=</span> <span class="n">eq.refl</span> <span class="n">a</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">ba</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">eq.rec</span> <span class="n">A</span> <span class="n">a</span> <span class="o">(</span><span class="n">eq_helper</span> <span class="n">A</span> <span class="n">a</span><span class="o">)</span> <span class="n">aa</span> <span class="n">b</span> <span class="n">ab</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">ba</span><span class="o">,</span>
<span class="kd">end</span>



<span class="kd">def</span> <span class="n">Eq_helper</span> <span class="o">(</span><span class="n">A</span><span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span><span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">:=</span>  <span class="bp">λ</span> <span class="o">(</span><span class="n">x1</span> <span class="n">x2</span><span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">e</span><span class="o">:</span> <span class="o">(</span><span class="n">Eq</span> <span class="n">x1</span> <span class="n">x2</span><span class="o">)),</span> <span class="o">(</span><span class="n">Eq</span> <span class="n">x2</span> <span class="n">a</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">Eq_symm</span> <span class="o">(</span><span class="n">A</span><span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span><span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">Eq</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="o">(</span><span class="n">Eq</span> <span class="n">b</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intros</span> <span class="n">ab</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">aa</span> <span class="o">:=</span> <span class="n">Eq.refl</span> <span class="n">a</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">ba</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">Eq.rec</span> <span class="n">A</span> <span class="o">(</span><span class="n">Eq_helper</span> <span class="n">A</span> <span class="n">a</span><span class="o">),</span>
  <span class="gr">sorry</span><span class="o">,</span>
<span class="kd">end</span>


<span class="kd">variable</span> <span class="n">A</span><span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span>
<span class="kd">variable</span> <span class="n">a_1</span><span class="o">:</span> <span class="n">A</span>
<span class="kd">variable</span> <span class="n">a</span><span class="o">:</span> <span class="n">A</span>
<span class="k">#reduce</span> <span class="o">(</span><span class="bp">Π</span> <span class="o">(</span><span class="n">a_1</span> <span class="o">:</span> <span class="n">A</span><span class="o">),</span> <span class="n">Eq_helper</span> <span class="n">A</span> <span class="n">a</span> <span class="n">a_1</span> <span class="n">a_1</span> <span class="o">(</span><span class="n">Eq.refl</span> <span class="n">a_1</span><span class="o">))</span>   <span class="c1">-- Π (a_1 : A), Eq a_1 a</span>
</code></pre></div>



<a name="271850812"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/why%20proof%20irrelevance%3F/near/271850812" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/why.20proof.20irrelevance.3F.html#271850812">(Feb 14 2022 at 16:25)</a>:</h4>
<p>It seems to work:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">universes</span> <span class="n">u</span> <span class="n">v</span>

<span class="kd">inductive</span> <span class="n">Eq</span> <span class="o">{</span><span class="n">A</span><span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">}</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">-&gt;</span> <span class="n">A</span> <span class="bp">-&gt;</span> <span class="kt">Sort</span> <span class="o">(</span><span class="n">max</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">refl</span> <span class="o">(</span><span class="n">a</span><span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="n">Eq</span> <span class="n">a</span> <span class="n">a</span>

<span class="kd">def</span> <span class="n">Eq_symm</span> <span class="o">(</span><span class="n">A</span><span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">)</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span><span class="o">:</span> <span class="n">A</span><span class="o">),</span> <span class="o">(</span><span class="n">Eq</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="o">(</span><span class="n">Eq</span> <span class="n">b</span> <span class="n">a</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="n">Eq.refl</span> <span class="n">_</span><span class="o">)</span> <span class="o">:=</span> <span class="n">Eq.refl</span> <span class="n">_</span>

<span class="kn">attribute</span> <span class="o">[</span><span class="n">refl</span><span class="o">]</span> <span class="n">Eq.refl</span>

<span class="kd">def</span> <span class="n">Eq_symm'</span> <span class="o">(</span><span class="n">A</span><span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span><span class="o">:</span> <span class="n">A</span><span class="o">):</span> <span class="o">(</span><span class="n">Eq</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="o">(</span><span class="n">Eq</span> <span class="n">b</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">hab</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">hab</span><span class="o">,</span>
  <span class="n">refl</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="271851056"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/why%20proof%20irrelevance%3F/near/271851056" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/why.20proof.20irrelevance.3F.html#271851056">(Feb 14 2022 at 16:27)</a>:</h4>
<p>Here's a direct use of the recursor:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">Eq_symm''</span> <span class="o">(</span><span class="n">A</span><span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span><span class="o">:</span> <span class="n">A</span><span class="o">):</span> <span class="o">(</span><span class="n">Eq</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="o">(</span><span class="n">Eq</span> <span class="n">b</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">Eq.rec</span> <span class="o">(</span><span class="kd">by</span> <span class="n">exact</span> <span class="n">Eq.refl</span><span class="o">)</span>
</code></pre></div>
<p>The <code>by exact</code> is because something's not elaborating correctly and that fixed it for reasons unknown.</p>



<a name="271853388"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/why%20proof%20irrelevance%3F/near/271853388" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonard Wiechmann <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/why.20proof.20irrelevance.3F.html#271853388">(Feb 14 2022 at 16:43)</a>:</h4>
<p>hmm yeah, that works. i'll have to study that a bit more.<br>
here's the proof with an explicit motive:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">Eq_helper</span> <span class="o">(</span><span class="n">A</span><span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="o">(</span><span class="n">x1</span> <span class="n">x2</span><span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">e</span><span class="o">:</span> <span class="o">(</span><span class="n">Eq</span> <span class="n">x1</span> <span class="n">x2</span><span class="o">)),</span> <span class="o">(</span><span class="n">Eq</span> <span class="n">x2</span> <span class="n">x1</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">Eq_symm''''</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">A</span><span class="o">),</span> <span class="n">Eq</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">Eq</span> <span class="n">b</span> <span class="n">a</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">e</span><span class="o">:</span> <span class="o">(</span><span class="n">Eq</span> <span class="n">a</span> <span class="n">b</span><span class="o">)),</span> <span class="o">(</span><span class="kd">by</span> <span class="n">exact</span> <span class="bp">@</span><span class="n">Eq.rec</span> <span class="n">A</span> <span class="o">(</span><span class="n">Eq_helper</span> <span class="n">A</span><span class="o">)</span> <span class="n">Eq.refl</span> <span class="n">a</span> <span class="n">b</span> <span class="n">e</span><span class="o">)</span>
</code></pre></div>
<p>also needs that by exact for some reason.</p>
<p>btw is there a way to have lean tell me what motive it inferred?</p>



<a name="271854269"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/why%20proof%20irrelevance%3F/near/271854269" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/why.20proof.20irrelevance.3F.html#271854269">(Feb 14 2022 at 16:49)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">Eq_symm''</span> <span class="o">(</span><span class="n">A</span><span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span><span class="o">:</span> <span class="n">A</span><span class="o">):</span> <span class="o">(</span><span class="n">Eq</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="o">(</span><span class="n">Eq</span> <span class="n">b</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">Eq.rec</span> <span class="o">(</span><span class="kd">by</span> <span class="n">exact</span> <span class="n">Eq.refl</span><span class="o">)</span>

<span class="kd">set_option</span> <span class="n">pp.implicit</span> <span class="n">true</span>

<span class="k">#print</span> <span class="n">Eq_symm''</span>
<span class="c">/-</span><span class="cm"></span>
<span class="cm">23:1: def Eq_symm'' : Π (A : Sort u) (a b : A), @Eq A a b → @Eq A b a :=</span>
<span class="cm">λ (A : Sort u) (a b : A), @Eq.rec A (λ (a b : A) (n : @Eq A a b), @Eq A b a) (@Eq.refl A) a b</span>
<span class="cm">-/</span>
</code></pre></div>



<a name="271854363"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/why%20proof%20irrelevance%3F/near/271854363" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonard Wiechmann <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/why.20proof.20irrelevance.3F.html#271854363">(Feb 14 2022 at 16:50)</a>:</h4>
<p>oh, that's awesome, thanks!</p>



<a name="271870595"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/why%20proof%20irrelevance%3F/near/271870595" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonard Wiechmann <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/why.20proof.20irrelevance.3F.html#271870595">(Feb 14 2022 at 18:50)</a>:</h4>
<p>here's a random question: what are some interesting Props <em>besides</em> equality?<br>
background: i'm interested in proofs from a program correctness perspective, not so much from a "pure math" perspective.<br>
i can't really think of any important relations besides equality, less/greater than; perhaps prime and equal-modulo. but all these seem to be defined in terms of equality.<br>
if there were no other interesting prop, a uniqueness of identity proofs axiom could be an alternative to <code>Prop</code> for me. (though I'd have to learn about possible paradoxes, and whether i care about them)</p>



<a name="271871007"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/why%20proof%20irrelevance%3F/near/271871007" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonard Wiechmann <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/why.20proof.20irrelevance.3F.html#271871007">(Feb 14 2022 at 18:54)</a>:</h4>
<p>now that i think about it, quantification could be a problem.<br>
if equality proofs are treated equally, quantification over equality should probably be treated in the same way.<br>
i guess, now i've ended up at Prop?</p>



<a name="271872389"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/why%20proof%20irrelevance%3F/near/271872389" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/why.20proof.20irrelevance.3F.html#271872389">(Feb 14 2022 at 19:02)</a>:</h4>
<p>Any mathematical proposition is a <code>Prop</code> in Lean, "does this turing machine halt", "is this thing a member of a set" etc. What you are describing is the special case where a relation is modeled using a function that takes two things and maps them onto <code>Prop</code></p>



<a name="271876954"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/why%20proof%20irrelevance%3F/near/271876954" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonard Wiechmann <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/why.20proof.20irrelevance.3F.html#271876954">(Feb 14 2022 at 19:33)</a>:</h4>
<p>ok, i've found an example that answers my original question (title of this thread):<br>
"""<br>
For example, in a dependent type theory, one may use dependent<br>
types of pairs to represent CNs modified by intersective adjectives [35]: for instance,<br>
a handsome man is a pair of a man and a proof that the man is handsome. Then,<br>
for such representations, one can ask: what is the identity criterion for handsome<br>
man? An obvious answer should be that it is the same as that for man: two handsome<br>
men are the same if, and only if, they are the same man. But this is not what the<br>
formal interpretation gives us since it also requires that the proofs of the man being<br>
handsome be the same. Obviously, this would not be a correct identity criterion for<br>
the modified CN handsome man.<br>
""" from Proof Irrelevance in Type-Theoretical Semantics∗ by Zhaohui Luo<br>
as I understand it, it comes down to the "basic" type theory not accurately modelling the <em>expected semantics</em> of propositions. namely, that only their truth value matters (with respect to identity), not their proof.</p>



<a name="271878232"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/why%20proof%20irrelevance%3F/near/271878232" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/why.20proof.20irrelevance.3F.html#271878232">(Feb 14 2022 at 19:41)</a>:</h4>
<p>In case I was being too opaque when I mentioned <code>subtype (∈ s)</code> earlier (explaining the mechanics and not the point), this is a dependent pair of types. Terms consist of a pair of <code>x : α</code> and a proof <code>h : x ∈ s</code>. With the example you brought up, <code>α</code> is "man" and <code>s</code> is the set (i.e. a predicate on <code>α</code>) of handsome men.  With proof irrelevance, <code>⟨x, h⟩ = ⟨y, h'⟩</code> if and only if <code>x = y</code>.</p>



<a name="271880190"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/why%20proof%20irrelevance%3F/near/271880190" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonard Wiechmann <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/why.20proof.20irrelevance.3F.html#271880190">(Feb 14 2022 at 19:57)</a>:</h4>
<p>oh, ok, that makes a lot of sense now, thanks!<br>
i didn't know that <code>subtype</code> terms were such pairs.</p>



<a name="271883489"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/why%20proof%20irrelevance%3F/near/271883489" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris B <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/why.20proof.20irrelevance.3F.html#271883489">(Feb 14 2022 at 20:26)</a>:</h4>
<p><span class="user-mention silent" data-user-id="456923">Leonard Wiechmann</span> <a href="#narrow/stream/113488-general/topic/why.20proof.20irrelevance.3F/near/271870595">said</a>:</p>
<blockquote>
<p>here's a random question: what are some interesting Props <em>besides</em> equality?<br>
background: i'm interested in proofs from a program correctness perspective, not so much from a "pure math" perspective.</p>
</blockquote>
<p>For program verification, Hoare triples and operational/denotational semantics come to mind.</p>



<a name="271886182"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/why%20proof%20irrelevance%3F/near/271886182" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joachim Breitner <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/why.20proof.20irrelevance.3F.html#271886182">(Feb 14 2022 at 20:49)</a>:</h4>
<p>Any inductively defined predicate (e.g. well-typedness) can be useful to use as an inductive data type for further definitions, I think, and that requires these proofs to be relevant. (This is similar to what Chris may allude to.)</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
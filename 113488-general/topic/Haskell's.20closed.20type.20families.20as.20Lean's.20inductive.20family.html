---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/Haskell's.20closed.20type.20families.20as.20Lean's.20inductive.20family.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Haskell's.20closed.20type.20families.20as.20Lean's.20inductive.20family.html">Haskell's closed type families as Lean's inductive family</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="247723783"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Haskell%27s%20closed%20type%20families%20as%20Lean%27s%20inductive%20family/near/247723783" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kaushik Chakraborty <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Haskell's.20closed.20type.20families.20as.20Lean's.20inductive.20family.html#247723783">(Jul 30 2021 at 15:33)</a>:</h4>
<p>I am trying to encode this closed type family encoded in Haskell in Lean 4. I think it can be done via Inductive Type families but since I am absolutely novice in these advanced type system encodings, not able to figure out. Any help would be appreciated. Thanks</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">type</span> <span class="n">family</span> <span class="n">ElementOf</span> <span class="n">a</span> <span class="n">where</span>
  <span class="n">ElementOf</span> <span class="o">[[</span><span class="n">a</span><span class="o">]]</span> <span class="bp">=</span> <span class="n">ElementOf</span> <span class="o">[</span><span class="n">a</span><span class="o">]</span>
  <span class="n">ElementOf</span> <span class="o">[</span><span class="n">a</span><span class="o">]</span>   <span class="bp">=</span> <span class="n">a</span>
</code></pre></div>



<a name="247724162"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Haskell%27s%20closed%20type%20families%20as%20Lean%27s%20inductive%20family/near/247724162" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Haskell's.20closed.20type.20families.20as.20Lean's.20inductive.20family.html#247724162">(Jul 30 2021 at 15:36)</a>:</h4>
<p>Type families like this cannot directly be represented in lean, because type constructors are not necessarily injective. But you can do something similar with typeclasses</p>



<a name="247724602"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Haskell%27s%20closed%20type%20families%20as%20Lean%27s%20inductive%20family/near/247724602" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Haskell's.20closed.20type.20families.20as.20Lean's.20inductive.20family.html#247724602">(Jul 30 2021 at 15:40)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">ElementOf</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">El</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">ElementOf</span> <span class="o">(</span><span class="n">List</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">α</span><span class="o">⟩</span>
<span class="kd">instance</span> <span class="o">[</span><span class="n">ElementOf</span> <span class="o">(</span><span class="n">List</span> <span class="n">α</span><span class="o">)]</span> <span class="o">:</span> <span class="n">ElementOf</span> <span class="o">(</span><span class="n">List</span> <span class="o">(</span><span class="n">List</span> <span class="n">α</span><span class="o">))</span> <span class="o">:=</span>
  <span class="o">⟨</span><span class="n">ElementOf.El</span> <span class="o">(</span><span class="n">List</span> <span class="n">α</span><span class="o">)⟩</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">ElementOf.El</span> <span class="o">(</span><span class="n">List</span> <span class="n">α</span><span class="o">)</span> <span class="bp">=</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">ElementOf.El</span> <span class="o">(</span><span class="n">List</span> <span class="o">(</span><span class="n">List</span> <span class="n">α</span><span class="o">))</span> <span class="bp">=</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">ElementOf.El</span> <span class="o">(</span><span class="n">List</span> <span class="o">(</span><span class="n">List</span> <span class="o">(</span><span class="n">List</span> <span class="n">α</span><span class="o">)))</span> <span class="bp">=</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">rfl</span>
</code></pre></div>



<a name="247737125"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Haskell%27s%20closed%20type%20families%20as%20Lean%27s%20inductive%20family/near/247737125" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kaushik Chakraborty <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Haskell's.20closed.20type.20families.20as.20Lean's.20inductive.20family.html#247737125">(Jul 30 2021 at 17:18)</a>:</h4>
<p>thanks. so when in Haskell it is said that type family is kind of a function from types to types and type classes are function from types to terms, in Lean type classes can do both right.</p>



<a name="247739194"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Haskell%27s%20closed%20type%20families%20as%20Lean%27s%20inductive%20family/near/247739194" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Haskell's.20closed.20type.20families.20as.20Lean's.20inductive.20family.html#247739194">(Jul 30 2021 at 17:38)</a>:</h4>
<p>yeah, because in dependent type theory, types are terms</p>



<a name="247741124"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Haskell%27s%20closed%20type%20families%20as%20Lean%27s%20inductive%20family/near/247741124" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Haskell's.20closed.20type.20families.20as.20Lean's.20inductive.20family.html#247741124">(Jul 30 2021 at 17:54)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span>  One limitation though is that you can't pattern match on types in Lean, though, right? Whereas that is what closed type families essentially do in Haskell. </p>
<p>That is, the closest approximation in Lean of a closed type family would be  something like:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">ElementOf</span><span class="bp">!.</span><span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">u</span>
<span class="bp">|</span> <span class="n">List</span> <span class="o">(</span><span class="n">List</span> <span class="n">α</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="n">ElementOf</span><span class="bp">!</span> <span class="o">(</span><span class="n">List</span> <span class="n">α</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">List</span> <span class="n">α</span> <span class="bp">=&gt;</span> <span class="n">α</span>
<span class="bp">|</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">panic</span><span class="bp">!</span> <span class="s2">"invalid type"</span>
</code></pre></div>
<p>But this doesn't work because you can't pattern match on types in Lean.</p>



<a name="247741463"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Haskell%27s%20closed%20type%20families%20as%20Lean%27s%20inductive%20family/near/247741463" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Haskell's.20closed.20type.20families.20as.20Lean's.20inductive.20family.html#247741463">(Jul 30 2021 at 17:56)</a>:</h4>
<p>What does that pattern match look like in haskell? This is a bit semantically weird so I don't know exactly how it's handled</p>



<a name="247741633"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Haskell%27s%20closed%20type%20families%20as%20Lean%27s%20inductive%20family/near/247741633" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Haskell's.20closed.20type.20families.20as.20Lean's.20inductive.20family.html#247741633">(Jul 30 2021 at 17:58)</a>:</h4>
<p>If you want to define a function out of a type family, you can add it as a field in the typeclass above</p>



<a name="247741693"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Haskell%27s%20closed%20type%20families%20as%20Lean%27s%20inductive%20family/near/247741693" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Haskell's.20closed.20type.20families.20as.20Lean's.20inductive.20family.html#247741693">(Jul 30 2021 at 17:58)</a>:</h4>
<p>The difference is that a type class is open whereas a closed type family is, well, closed.</p>



<a name="247741802"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Haskell%27s%20closed%20type%20families%20as%20Lean%27s%20inductive%20family/near/247741802" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Haskell's.20closed.20type.20families.20as.20Lean's.20inductive.20family.html#247741802">(Jul 30 2021 at 17:59)</a>:</h4>
<p>It is possible to define an inductive type family that only holds at certain types, but it's not actually as useful as you would think</p>



<a name="247741818"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Haskell%27s%20closed%20type%20families%20as%20Lean%27s%20inductive%20family/near/247741818" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Haskell's.20closed.20type.20families.20as.20Lean's.20inductive.20family.html#247741818">(Jul 30 2021 at 17:59)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113488-general/topic/Haskell's.20closed.20type.20families.20as.20Lean's.20inductive.20family/near/247741463">said</a>:</p>
<blockquote>
<p>What does that pattern match look like in haskell?</p>
</blockquote>
<p>That pattern match is what the closed type family example <span class="user-mention" data-user-id="118349">@Kaushik Chakraborty</span> gave does.</p>



<a name="247742051"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Haskell%27s%20closed%20type%20families%20as%20Lean%27s%20inductive%20family/near/247742051" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Haskell's.20closed.20type.20families.20as.20Lean's.20inductive.20family.html#247742051">(Jul 30 2021 at 18:00)</a>:</h4>
<p>okay but I already gave an approximate equivalent for that code snippet. I'm hoping for something that shows what aspect of the haskell version is missing from the lean version</p>



<a name="247742091"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Haskell%27s%20closed%20type%20families%20as%20Lean%27s%20inductive%20family/near/247742091" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Haskell's.20closed.20type.20families.20as.20Lean's.20inductive.20family.html#247742091">(Jul 30 2021 at 18:01)</a>:</h4>
<p>yes it's open. Why does that matter?</p>



<a name="247742293"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Haskell%27s%20closed%20type%20families%20as%20Lean%27s%20inductive%20family/near/247742293" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Haskell's.20closed.20type.20families.20as.20Lean's.20inductive.20family.html#247742293">(Jul 30 2021 at 18:02)</a>:</h4>
<p>that <code>panic!</code> in your version also looks bad. Is that what the haskell version does too?</p>



<a name="247742404"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Haskell%27s%20closed%20type%20families%20as%20Lean%27s%20inductive%20family/near/247742404" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Haskell's.20closed.20type.20families.20as.20Lean's.20inductive.20family.html#247742404">(Jul 30 2021 at 18:03)</a>:</h4>
<p>I don't think it makes sense for the haskell code to have a <code>panic!</code> in a type</p>



<a name="247742414"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Haskell%27s%20closed%20type%20families%20as%20Lean%27s%20inductive%20family/near/247742414" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Haskell's.20closed.20type.20families.20as.20Lean's.20inductive.20family.html#247742414">(Jul 30 2021 at 18:03)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113488-general/topic/Haskell's.20closed.20type.20families.20as.20Lean's.20inductive.20family/near/247742293">said</a>:</p>
<blockquote>
<p>that <code>panic!</code> in your version also looks bad. Is that what the haskell version does too?</p>
</blockquote>
<p>I added the <code>panic!</code> match since the original example is missing a catch-all alternative )which iirc would be required in Haskell).</p>



<a name="247742485"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Haskell%27s%20closed%20type%20families%20as%20Lean%27s%20inductive%20family/near/247742485" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Haskell's.20closed.20type.20families.20as.20Lean's.20inductive.20family.html#247742485">(Jul 30 2021 at 18:04)</a>:</h4>
<p>Are you sure? I think it is just a partial function, like a typeclass</p>



<a name="247742518"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Haskell%27s%20closed%20type%20families%20as%20Lean%27s%20inductive%20family/near/247742518" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Haskell's.20closed.20type.20families.20as.20Lean's.20inductive.20family.html#247742518">(Jul 30 2021 at 18:04)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113488-general/topic/Haskell's.20closed.20type.20families.20as.20Lean's.20inductive.20family/near/247742404">said</a>:</p>
<blockquote>
<p>I don't think it makes sense for the haskell code to have a <code>panic!</code> in a type</p>
</blockquote>
<p>No, actually, Haskell does support panicing in types. It is called a <a href="https://hackage.haskell.org/package/base/docs/GHC-TypeLits.html#t:TypeError">TypeError</a>.</p>



<a name="247742638"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Haskell%27s%20closed%20type%20families%20as%20Lean%27s%20inductive%20family/near/247742638" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Haskell's.20closed.20type.20families.20as.20Lean's.20inductive.20family.html#247742638">(Jul 30 2021 at 18:06)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113488-general/topic/Haskell's.20closed.20type.20families.20as.20Lean's.20inductive.20family/near/247742485">said</a>:</p>
<blockquote>
<p>Are you sure? I think it is just a partial function, like a typeclass</p>
</blockquote>
<p>No it is not. Closed type families are complete. That is the entire point of them in Haskell. :P <br>
However, You can cheat this with the <code>TypeError</code> I just mention much like in Lean you could with <code>panic!</code>.</p>



<a name="247742854"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Haskell%27s%20closed%20type%20families%20as%20Lean%27s%20inductive%20family/near/247742854" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Haskell's.20closed.20type.20families.20as.20Lean's.20inductive.20family.html#247742854">(Jul 30 2021 at 18:07)</a>:</h4>
<p>Also, for reference, here is the GHC User Guide section on <a href="https://downloads.haskell.org/ghc/9.0.1/docs/html/users_guide/exts/type_families.html#closed-type-families">closed type families</a>.</p>



<a name="247743732"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Haskell%27s%20closed%20type%20families%20as%20Lean%27s%20inductive%20family/near/247743732" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Haskell's.20closed.20type.20families.20as.20Lean's.20inductive.20family.html#247743732">(Jul 30 2021 at 18:15)</a>:</h4>
<p>unfortunately that section doesn't say anything about what you can do with closed type families, it just describes the declaration, which seems pretty well handled by those <code>instance</code>s in the lean version</p>



<a name="247744440"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Haskell%27s%20closed%20type%20families%20as%20Lean%27s%20inductive%20family/near/247744440" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Haskell's.20closed.20type.20families.20as.20Lean's.20inductive.20family.html#247744440">(Jul 30 2021 at 18:21)</a>:</h4>
<p>My argument was not that  the Lean analogue of closed type families would be necessary useful, just simply that a type class with instances is not it. <span aria-label="rolling on the floor laughing" class="emoji emoji-1f923" role="img" title="rolling on the floor laughing">:rolling_on_the_floor_laughing:</span> Also, your example could be translate d back into Haskell using associated (open) type families (which attach a type to a  type class just like you did).</p>



<a name="247744610"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Haskell%27s%20closed%20type%20families%20as%20Lean%27s%20inductive%20family/near/247744610" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Haskell's.20closed.20type.20families.20as.20Lean's.20inductive.20family.html#247744610">(Jul 30 2021 at 18:22)</a>:</h4>
<p>Such an example would look something like this in Haskell:</p>
<div class="codehilite" data-code-language="Haskell"><pre><span></span><code><span class="cm">{-# LANGUAGE TypeFamilies, FlexibleInstances #-}</span>

<span class="kr">class</span> <span class="kt">ElementOf</span> <span class="n">a</span> <span class="kr">where</span>
  <span class="kr">type</span> <span class="kt">El</span> <span class="n">a</span>

<span class="kr">instance</span> <span class="cm">{-# OVERLAPPABLE #-}</span> <span class="kt">ElementOf</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="kr">where</span>
  <span class="kr">type</span> <span class="kt">El</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">=</span> <span class="n">a</span>

<span class="kr">instance</span> <span class="cm">{-# OVERLAPPING #-}</span> <span class="kt">ElementOf</span> <span class="p">[[</span><span class="n">a</span><span class="p">]]</span> <span class="kr">where</span>
  <span class="kr">type</span> <span class="kt">El</span> <span class="p">[[</span><span class="n">a</span><span class="p">]]</span> <span class="ow">=</span> <span class="kt">El</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
</code></pre></div>



<a name="247746549"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Haskell%27s%20closed%20type%20families%20as%20Lean%27s%20inductive%20family/near/247746549" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Haskell's.20closed.20type.20families.20as.20Lean's.20inductive.20family.html#247746549">(Jul 30 2021 at 18:40)</a>:</h4>
<p>Having now tested my example on GHC 8.6, it doesn't compile because Haskell doesn't support overlapping open type family alternatives. This made me remember that one of the key uses of closed type families in Haskell is to deal with such cases. As Lean is much more okay with overlap, at least that concern does not exist.</p>



<a name="247756588"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Haskell%27s%20closed%20type%20families%20as%20Lean%27s%20inductive%20family/near/247756588" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anatole Dedecker <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Haskell's.20closed.20type.20families.20as.20Lean's.20inductive.20family.html#247756588">(Jul 30 2021 at 20:17)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113488-general/topic/Haskell's.20closed.20type.20families.20as.20Lean's.20inductive.20family/near/247724602">said</a>:</p>
<blockquote>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">ElementOf</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">El</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">ElementOf</span> <span class="o">(</span><span class="n">List</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">α</span><span class="o">⟩</span>
<span class="kd">instance</span> <span class="o">[</span><span class="n">ElementOf</span> <span class="o">(</span><span class="n">List</span> <span class="n">α</span><span class="o">)]</span> <span class="o">:</span> <span class="n">ElementOf</span> <span class="o">(</span><span class="n">List</span> <span class="o">(</span><span class="n">List</span> <span class="n">α</span><span class="o">))</span> <span class="o">:=</span>
  <span class="o">⟨</span><span class="n">ElementOf.El</span> <span class="o">(</span><span class="n">List</span> <span class="n">α</span><span class="o">)⟩</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">ElementOf.El</span> <span class="o">(</span><span class="n">List</span> <span class="n">α</span><span class="o">)</span> <span class="bp">=</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">ElementOf.El</span> <span class="o">(</span><span class="n">List</span> <span class="o">(</span><span class="n">List</span> <span class="n">α</span><span class="o">))</span> <span class="bp">=</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">ElementOf.El</span> <span class="o">(</span><span class="n">List</span> <span class="o">(</span><span class="n">List</span> <span class="o">(</span><span class="n">List</span> <span class="n">α</span><span class="o">)))</span> <span class="bp">=</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">rfl</span>
</code></pre></div><br>
</p>
</blockquote>
<p>In this exemple, there would be two diferent instances of <code>ElementOf (list (list nat))</code>, right ? One with <code>nat</code> and one with <code>list nat</code> ?</p>



<a name="247757895"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Haskell%27s%20closed%20type%20families%20as%20Lean%27s%20inductive%20family/near/247757895" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Haskell's.20closed.20type.20families.20as.20Lean's.20inductive.20family.html#247757895">(Jul 30 2021 at 20:30)</a>:</h4>
<p>Yes. The order of the two instances is significant; you can also get the same effect by marking the first instance as <code>(priority := low)</code></p>



<a name="247757942"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Haskell%27s%20closed%20type%20families%20as%20Lean%27s%20inductive%20family/near/247757942" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Haskell's.20closed.20type.20families.20as.20Lean's.20inductive.20family.html#247757942">(Jul 30 2021 at 20:30)</a>:</h4>
<p>That is, we are relying on typeclass inference to always apply the second instance when possible</p>



<a name="247772778"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Haskell%27s%20closed%20type%20families%20as%20Lean%27s%20inductive%20family/near/247772778" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Haskell's.20closed.20type.20families.20as.20Lean's.20inductive.20family.html#247772778">(Jul 30 2021 at 23:21)</a>:</h4>
<p>Here's an attempt at something like a closed type family (in Lean 3), using <code>has_coe_to_sort</code> as a small convenience.  It requires that you say how a type is constructed, in the form of a term of <code>ElementOf.dom</code>.  I implemented a generic <code>flatten</code> with it as a small test.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">ElementOf.dom</span>
<span class="bp">|</span> <span class="n">incl</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:</span> <span class="n">ElementOf.dom</span>
<span class="bp">|</span> <span class="n">list</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ElementOf.dom</span><span class="o">)</span> <span class="o">:</span> <span class="n">ElementOf.dom</span>

<span class="kn">namespace</span> <span class="n">ElementOf</span>

<span class="kd">def</span> <span class="n">dom.to_sort</span> <span class="o">:</span> <span class="n">dom</span> <span class="bp">→</span> <span class="kt">Type</span><span class="bp">*</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">dom.incl</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="n">α</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">dom.list</span> <span class="n">f</span><span class="o">)</span> <span class="o">:=</span> <span class="n">list</span> <span class="o">(</span><span class="n">dom.to_sort</span> <span class="n">f</span><span class="o">)</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_coe_to_sort</span> <span class="n">ElementOf.dom</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">ElementOf.dom.to_sort</span><span class="o">⟩</span>

<span class="kd">def</span> <span class="n">dom.apply</span> <span class="o">:</span> <span class="n">dom</span> <span class="bp">→</span> <span class="n">dom</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">dom.incl</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="n">dom.incl</span> <span class="n">α</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">dom.list</span> <span class="n">f</span><span class="o">)</span> <span class="o">:=</span> <span class="n">dom.apply</span> <span class="n">f</span>

<span class="kd">end</span> <span class="n">ElementOf</span>

<span class="kd">def</span> <span class="n">flatten</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="n">ElementOf.dom</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">list</span> <span class="n">α.apply</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">ElementOf.dom.incl</span> <span class="n">α</span><span class="o">)</span> <span class="n">x</span> <span class="o">:=</span> <span class="o">[</span><span class="n">x</span><span class="o">]</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">ElementOf.dom.list</span> <span class="n">f</span><span class="o">)</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">list.bind</span> <span class="n">x</span> <span class="n">flatten</span>
</code></pre></div>



<a name="247773362"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Haskell%27s%20closed%20type%20families%20as%20Lean%27s%20inductive%20family/near/247773362" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Haskell's.20closed.20type.20families.20as.20Lean's.20inductive.20family.html#247773362">(Jul 30 2021 at 23:32)</a>:</h4>
<p>I don't have much experience with them, but maybe this is a place where unification hints can be used to automatically generate the <code>ElementOf.dom</code> term.</p>



<a name="247773711"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Haskell%27s%20closed%20type%20families%20as%20Lean%27s%20inductive%20family/near/247773711" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Haskell's.20closed.20type.20families.20as.20Lean's.20inductive.20family.html#247773711">(Jul 30 2021 at 23:41)</a>:</h4>
<p>My memory was that unification hints were entirely broken in lean3 for anything using universe variables, and only really worked for <code>Type</code> not <code>Type*</code></p>



<a name="247813874"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Haskell%27s%20closed%20type%20families%20as%20Lean%27s%20inductive%20family/near/247813874" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Haskell's.20closed.20type.20families.20as.20Lean's.20inductive.20family.html#247813874">(Jul 31 2021 at 16:49)</a>:</h4>
<p><span class="user-mention" data-user-id="306601">@Kyle Miller</span>'s example inspired me and led me to this implementation (in Lean 4):</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="kd">inductive</span> <span class="n">Elem.</span><span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="o">:</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="n">outParam</span> <span class="bp">$</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">u</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">flat</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">=</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">Elem</span> <span class="n">α</span> <span class="n">β</span>
<span class="bp">|</span> <span class="n">list</span> <span class="o">(</span><span class="n">γ</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">=</span> <span class="n">List</span> <span class="n">γ</span><span class="o">)</span> <span class="o">(</span><span class="n">tail</span> <span class="o">:</span> <span class="n">Elem</span> <span class="n">γ</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">Elem</span> <span class="n">α</span> <span class="n">β</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">Elem</span> <span class="n">α</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">Elem.flat</span> <span class="n">rfl</span>
<span class="kd">instance</span> <span class="o">[</span><span class="n">e</span> <span class="o">:</span> <span class="n">Elem</span> <span class="n">α</span> <span class="n">β</span><span class="o">]</span> <span class="o">:</span> <span class="n">Elem</span> <span class="o">(</span><span class="n">List</span> <span class="n">α</span><span class="o">)</span> <span class="n">β</span> <span class="o">:=</span> <span class="n">Elem.list</span> <span class="n">α</span> <span class="n">rfl</span> <span class="n">e</span>

<span class="n">abbrev</span> <span class="n">ElemOf.</span><span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">Elem</span> <span class="n">α</span> <span class="n">β</span><span class="o">]</span> <span class="o">:=</span>
  <span class="n">β</span>

<span class="k">#reduce</span> <span class="n">ElemOf</span> <span class="o">(</span><span class="n">List</span> <span class="o">(</span><span class="n">List</span> <span class="n">Nat</span><span class="o">))</span> <span class="c1">-- Nat</span>

<span class="kd">def</span> <span class="n">flattenAux</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">Elem</span> <span class="n">α</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">List</span> <span class="n">β</span>
<span class="bp">|</span> <span class="n">Elem.flat</span> <span class="n">h</span> <span class="bp">=&gt;</span> <span class="o">[</span><span class="n">cast</span> <span class="n">h</span> <span class="n">a</span><span class="o">]</span>
<span class="bp">|</span> <span class="n">Elem.list</span> <span class="n">γ</span> <span class="n">h</span> <span class="n">e</span> <span class="bp">=&gt;</span> <span class="n">List.bind</span> <span class="o">(</span><span class="n">cast</span> <span class="n">h</span> <span class="n">a</span><span class="o">)</span> <span class="k">fun</span> <span class="n">x</span> <span class="bp">=&gt;</span> <span class="n">flattenAux</span> <span class="n">x</span> <span class="n">e</span>

<span class="kd">def</span> <span class="n">flatten</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">[</span><span class="n">e</span> <span class="o">:</span> <span class="n">Elem</span> <span class="n">α</span> <span class="n">β</span><span class="o">]</span> <span class="o">:</span> <span class="n">List</span> <span class="n">β</span> <span class="o">:=</span>
  <span class="n">flattenAux</span> <span class="n">a</span> <span class="n">e</span>

<span class="k">#reduce</span> <span class="n">flatten</span> <span class="o">[[</span><span class="mi">0</span><span class="o">],</span> <span class="o">[</span><span class="mi">1</span><span class="o">]]</span> <span class="c1">-- [0, 1]</span>
</code></pre></div>



<a name="247814341"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Haskell%27s%20closed%20type%20families%20as%20Lean%27s%20inductive%20family/near/247814341" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Haskell's.20closed.20type.20families.20as.20Lean's.20inductive.20family.html#247814341">(Jul 31 2021 at 17:00)</a>:</h4>
<p><span class="user-mention" data-user-id="315577">@Mac</span> Nice idea with the <code>class inductive</code>.  You can get rid of the type equalities:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="kd">inductive</span> <span class="n">Elem</span> <span class="o">:</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="n">outParam</span> <span class="bp">$</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">u</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">incl</span> <span class="o">:</span> <span class="n">Elem</span> <span class="n">α</span> <span class="n">α</span>
<span class="bp">|</span> <span class="n">list</span> <span class="o">(</span><span class="n">tail</span> <span class="o">:</span> <span class="n">Elem</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">Elem</span> <span class="o">(</span><span class="n">List</span> <span class="n">α</span><span class="o">)</span> <span class="n">β</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">Elem</span> <span class="n">α</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">Elem.incl</span>
<span class="kd">instance</span> <span class="o">[</span><span class="n">e</span> <span class="o">:</span> <span class="n">Elem</span> <span class="n">α</span> <span class="n">β</span><span class="o">]</span> <span class="o">:</span> <span class="n">Elem</span> <span class="o">(</span><span class="n">List</span> <span class="n">α</span><span class="o">)</span> <span class="n">β</span> <span class="o">:=</span> <span class="n">Elem.list</span> <span class="n">e</span>

<span class="n">abbrev</span> <span class="n">ElemOf</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">Elem</span> <span class="n">α</span> <span class="n">β</span><span class="o">]</span> <span class="o">:=</span> <span class="n">β</span>

<span class="k">#reduce</span> <span class="n">ElemOf</span> <span class="o">(</span><span class="n">List</span> <span class="o">(</span><span class="n">List</span> <span class="n">Nat</span><span class="o">))</span> <span class="c1">-- Nat</span>

<span class="kd">def</span> <span class="n">flattenAux</span> <span class="o">:</span> <span class="n">Elem</span> <span class="n">α</span> <span class="n">β</span> <span class="bp">→</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="bp">→</span> <span class="n">List</span> <span class="n">β</span>
<span class="bp">|</span> <span class="n">Elem.incl</span><span class="o">,</span> <span class="n">a</span> <span class="bp">=&gt;</span> <span class="o">[</span><span class="n">a</span><span class="o">]</span>
<span class="bp">|</span> <span class="n">Elem.list</span> <span class="n">tail</span><span class="o">,</span> <span class="n">a</span> <span class="bp">=&gt;</span> <span class="n">List.bind</span> <span class="n">a</span> <span class="k">fun</span> <span class="n">x</span> <span class="bp">=&gt;</span> <span class="n">flattenAux</span> <span class="n">tail</span> <span class="n">x</span>

<span class="kd">def</span> <span class="n">flatten</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">[</span><span class="n">e</span> <span class="o">:</span> <span class="n">Elem</span> <span class="n">α</span> <span class="n">β</span><span class="o">]</span> <span class="o">:</span> <span class="n">List</span> <span class="n">β</span> <span class="o">:=</span>
  <span class="n">flattenAux</span> <span class="n">e</span> <span class="n">a</span>

<span class="k">#reduce</span> <span class="n">flatten</span> <span class="o">[[</span><span class="mi">0</span><span class="o">]]</span> <span class="c1">-- [0]</span>
<span class="k">#reduce</span> <span class="n">flatten</span> <span class="o">[[[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">]]]</span> <span class="c1">-- [1, 2]</span>
</code></pre></div>



<a name="247814451"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Haskell%27s%20closed%20type%20families%20as%20Lean%27s%20inductive%20family/near/247814451" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Haskell's.20closed.20type.20families.20as.20Lean's.20inductive.20family.html#247814451">(Jul 31 2021 at 17:03)</a>:</h4>
<p><span class="user-mention" data-user-id="306601">@Kyle Miller</span> I personally like including the type equalities because it makes it so you don't have to rely on the sometimes finicky nature of <code>match</code> generalizing</p>



<a name="247814596"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Haskell%27s%20closed%20type%20families%20as%20Lean%27s%20inductive%20family/near/247814596" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Haskell's.20closed.20type.20families.20as.20Lean's.20inductive.20family.html#247814596">(Jul 31 2021 at 17:06)</a>:</h4>
<p>I'd rather make sure <code>match</code> generalizes properly than to deal with <code>cast</code>, but I suppose it's a matter of taste.</p>



<a name="247817689"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Haskell%27s%20closed%20type%20families%20as%20Lean%27s%20inductive%20family/near/247817689" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Haskell's.20closed.20type.20families.20as.20Lean's.20inductive.20family.html#247817689">(Jul 31 2021 at 18:19)</a>:</h4>
<p>I guess as a person who does a decent amount of systems programming, casting between types is a very natural operation for me. In fact, implicit casts kind of bothers me.</p>



<a name="247817795"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Haskell%27s%20closed%20type%20families%20as%20Lean%27s%20inductive%20family/near/247817795" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Haskell's.20closed.20type.20families.20as.20Lean's.20inductive.20family.html#247817795">(Jul 31 2021 at 18:22)</a>:</h4>
<p>That is, I would intuitively expect the <code>a</code> in the match to have the same type as the <code>a</code> outside it. The generalizing nature of <code>match</code> is often very counter-intuitive for me.</p>



<a name="247818639"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Haskell%27s%20closed%20type%20families%20as%20Lean%27s%20inductive%20family/near/247818639" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Haskell's.20closed.20type.20families.20as.20Lean's.20inductive.20family.html#247818639">(Jul 31 2021 at 18:41)</a>:</h4>
<p><span class="user-mention" data-user-id="315577">@Mac</span> The <code>cast</code> function tends to be annoying to deal with when you have to prove anything about your definitions, since you've put yourself on the road toward heterogeneous equalities, or worse, trying to prove that two types are not equal (which is impossible most of the time).</p>
<p>If it makes you feel any better, in this case the <code>match</code> "reveals" what <code>α</code> actually was (and the <code>a : α</code> in the type signature was unnecessary -- I removed it).  It's letting you deconstruct <code>α</code> and then, for example with <code>Elem.list</code>, reinterpret <code>a</code> as having type <code>List α'</code>, since that's the type it actually had.</p>



<a name="247818778"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Haskell%27s%20closed%20type%20families%20as%20Lean%27s%20inductive%20family/near/247818778" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Haskell's.20closed.20type.20families.20as.20Lean's.20inductive.20family.html#247818778">(Jul 31 2021 at 18:44)</a>:</h4>
<p>It can be made more explicit:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">flattenAux</span> <span class="o">:</span> <span class="n">Elem</span> <span class="n">α</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">List</span> <span class="n">β</span>
<span class="bp">|</span> <span class="n">Elem.incl</span> <span class="o">(</span><span class="n">α</span> <span class="o">:=</span> <span class="n">α</span><span class="o">),</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="o">[</span><span class="n">a</span><span class="o">]</span>
<span class="bp">|</span> <span class="n">Elem.list</span> <span class="o">(</span><span class="n">α</span> <span class="o">:=</span> <span class="n">α'</span><span class="o">)</span> <span class="n">tail</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">List</span> <span class="n">α'</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="n">List.bind</span> <span class="n">a</span> <span class="k">fun</span> <span class="n">x</span> <span class="bp">=&gt;</span> <span class="n">flattenAux</span> <span class="n">tail</span> <span class="n">x</span>
</code></pre></div>



<a name="247826375"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Haskell%27s%20closed%20type%20families%20as%20Lean%27s%20inductive%20family/near/247826375" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Haskell's.20closed.20type.20families.20as.20Lean's.20inductive.20family.html#247826375">(Jul 31 2021 at 22:15)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/113488-general/topic/Haskell's.20closed.20type.20families.20as.20Lean's.20inductive.20family/near/247818639">said</a>:</p>
<blockquote>
<p>It's letting you deconstruct <code>α</code> and then, for example with <code>Elem.list</code>, <strong>reinterpret</strong> <code>a</code> as having type <code>List α'</code></p>
</blockquote>
<p>The 'reintepret' is what I have a problem with. For me, that should always require an explicit cast (it even somewhat annoys me that Lean does this automatically with things like <code>def</code>s). However, I do realize that it is often a necessary part of the Lean.</p>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/113488-general/topic/Haskell's.20closed.20type.20families.20as.20Lean's.20inductive.20family/near/247818639">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="315577">Mac</span> The <code>cast</code> function tends to be annoying to deal with when you have to prove anything about your definitions, since you've put yourself on the road toward heterogeneous equalities, or worse, trying to prove that two types are not equal (which is impossible most of the time).</p>
</blockquote>
<p>My proofing experience has mostly been with logical systems of my own design so I sadly don't have much experience with proving things about practical functions like these. However, I am curious as to what is the problem with heterogenous equalities? Also, are there significant problems with augment inter- or intra- type equalities with  additional axioms (i.e. ones that state terms from two distinct types are equal or that state that two types are not equal)?</p>



<a name="247826427"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Haskell%27s%20closed%20type%20families%20as%20Lean%27s%20inductive%20family/near/247826427" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Haskell's.20closed.20type.20families.20as.20Lean's.20inductive.20family.html#247826427">(Jul 31 2021 at 22:17)</a>:</h4>
<p>I know that additional axioms in a mathematical may often be an anathema. But in program verification contexts, I don't imagine it is as much of one.</p>



<a name="247870911"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Haskell%27s%20closed%20type%20families%20as%20Lean%27s%20inductive%20family/near/247870911" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Haskell's.20closed.20type.20families.20as.20Lean's.20inductive.20family.html#247870911">(Aug 01 2021 at 18:26)</a>:</h4>
<blockquote>
<p>ones that state terms from two distinct types are equal</p>
</blockquote>
<p>It's not possible to say this in lean in any nontrivial way. Heterogeneous equality <code>HEq a b</code> (or <code>a == b</code> in lean 3) asserts that <code>a</code> and <code>b</code> have the same type and when you cast along that type equality the elements are equal. So terms of distinct types are never <code>HEq</code>.</p>



<a name="247871067"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Haskell%27s%20closed%20type%20families%20as%20Lean%27s%20inductive%20family/near/247871067" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Haskell's.20closed.20type.20families.20as.20Lean's.20inductive.20family.html#247871067">(Aug 01 2021 at 18:30)</a>:</h4>
<p><span class="user-mention silent" data-user-id="315577">Mac</span> <a href="#narrow/stream/113488-general/topic/Haskell's.20closed.20type.20families.20as.20Lean's.20inductive.20family/near/247826375">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/113488-general/topic/Haskell's.20closed.20type.20families.20as.20Lean's.20inductive.20family/near/247818639">said</a>:</p>
<blockquote>
<p>It's letting you deconstruct <code>α</code> and then, for example with <code>Elem.list</code>, <strong>reinterpret</strong> <code>a</code> as having type <code>List α'</code></p>
</blockquote>
<p>The 'reintepret' is what I have a problem with. For me, that should always require an explicit cast (it even somewhat annoys me that Lean does this automatically with things like <code>def</code>s). However, I do realize that it is often a necessary part of the Lean.</p>
</blockquote>
<p>There is no cast because we aren't actually talking about a single variable <code>a</code>; in each case there is a different variable with a different type, and the fact they are both called <code>a</code> is only due to our naming sense. This is shadowing at best, there is no actual relation between the <code>a</code> variables inside and outside the match</p>



<a name="247871141"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Haskell%27s%20closed%20type%20families%20as%20Lean%27s%20inductive%20family/near/247871141" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Haskell's.20closed.20type.20families.20as.20Lean's.20inductive.20family.html#247871141">(Aug 01 2021 at 18:33)</a>:</h4>
<blockquote>
<p>However, I am curious as to what is the problem with heterogenous equalities?</p>
</blockquote>
<p>The main problem with heterogeneous equalities is that they don't accomplish as much as you would expect of equality in an extensional type theory; in particular you can rarely rewrite with them, and it's incredibly difficult to use them at all without carefully chosen motives in the recursor</p>



<a name="247871208"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Haskell%27s%20closed%20type%20families%20as%20Lean%27s%20inductive%20family/near/247871208" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Haskell's.20closed.20type.20families.20as.20Lean's.20inductive.20family.html#247871208">(Aug 01 2021 at 18:34)</a>:</h4>
<p>The main reason for this is that the lemma <code>f == g -&gt; x == y -&gt; f x == g y</code> does not hold in lean (it's independent)</p>



<a name="247878394"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Haskell%27s%20closed%20type%20families%20as%20Lean%27s%20inductive%20family/near/247878394" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Haskell's.20closed.20type.20families.20as.20Lean's.20inductive.20family.html#247878394">(Aug 01 2021 at 21:39)</a>:</h4>
<p><span class="user-mention silent" data-user-id="315577">Mac</span> <a href="#narrow/stream/113488-general/topic/Haskell's.20closed.20type.20families.20as.20Lean's.20inductive.20family/near/247826375">said</a>:</p>
<blockquote>
<p>The 'reintepret' is what I have a problem with. For me, that should always require an explicit cast</p>
</blockquote>
<p>You can think of a <code>match</code> expression as a way to do an explicit cast, in the sense of a C# <code>is</code> type pattern (for example, <code>if (a is string s) { ... do something with s ... }</code>).  The analogy is somewhat clearer if you write the <code>match</code> explicitly:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">flattenAux</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">Elem</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">List</span> <span class="n">β</span> <span class="o">:=</span>
<span class="k">match</span> <span class="n">t</span><span class="o">,</span> <span class="n">a</span> <span class="k">with</span>
<span class="bp">|</span> <span class="n">Elem.incl</span><span class="o">,</span> <span class="n">a'</span> <span class="bp">=&gt;</span> <span class="o">[</span><span class="n">a'</span><span class="o">]</span>
<span class="bp">|</span> <span class="n">Elem.list</span> <span class="o">(</span><span class="n">α</span> <span class="o">:=</span> <span class="n">α'</span><span class="o">)</span> <span class="n">t'</span><span class="o">,</span> <span class="o">(</span><span class="n">a'</span> <span class="o">:</span> <span class="n">List</span> <span class="n">α'</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="n">List.bind</span> <span class="n">a'</span> <span class="k">fun</span> <span class="n">x</span> <span class="bp">=&gt;</span> <span class="n">flattenAux</span> <span class="n">t'</span> <span class="n">x</span>
</code></pre></div>
<p>The second case is something like a made-up <code>if (a is list&lt;α'&gt; a') { ... do something with a' ... }</code>. (Though Lean needs the <code>t</code> to drive this -- I wasn't sure of a good way to render the dependent types in C#!)</p>



<a name="247879013"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Haskell%27s%20closed%20type%20families%20as%20Lean%27s%20inductive%20family/near/247879013" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Haskell's.20closed.20type.20families.20as.20Lean's.20inductive.20family.html#247879013">(Aug 01 2021 at 21:54)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113488-general/topic/Haskell's.20closed.20type.20families.20as.20Lean's.20inductive.20family/near/247871141">said</a>:</p>
<blockquote>
<p>in an extensional type theory</p>
</blockquote>
<p>In proof assistants with an extensional type theory, in practice how do you change the type of a term to something equal? A while back I tried reading some of the NuPRL documentation, since ncatlab says it's extensional, but I couldn't find anything about that.</p>
<p>(An idle curiosity: are there proof assistants that let you dynamically add reduction rules given proofs of equalities? This would be one way to make equal things defeq.)</p>



<a name="247880137"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Haskell%27s%20closed%20type%20families%20as%20Lean%27s%20inductive%20family/near/247880137" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Haskell's.20closed.20type.20families.20as.20Lean's.20inductive.20family.html#247880137">(Aug 01 2021 at 22:25)</a>:</h4>
<p>Like I mentioned to Steven in the other thread, in Mizar (which uses set theory as the foundation but has a soft type system), there a command to say <code>reconsider x as B [by ...];</code> which amounts to the proof rule <code>|- x : A, |- A &lt;= B  =&gt; |- x : B</code>, where the <code>by</code> is a proof that <code>A</code> is a subset of <code>B</code>, where <code>A</code> is the "current" type of <code>x</code> as determined by the typechecker. I believe you can also give the newly type ascribed <code>x</code> a different name so that you can use <code>x</code> at either the old or new type.</p>



<a name="248184405"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Haskell%27s%20closed%20type%20families%20as%20Lean%27s%20inductive%20family/near/248184405" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Haskell's.20closed.20type.20families.20as.20Lean's.20inductive.20family.html#248184405">(Aug 03 2021 at 05:49)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113488-general/topic/Haskell's.20closed.20type.20families.20as.20Lean's.20inductive.20family/near/247871208">said</a>:</p>
<blockquote>
<p>The main reason for this is that the lemma <code>f == g -&gt; x == y -&gt; f x == g y</code> does not hold in lean (it's independent)</p>
</blockquote>
<p>If its independent, should you be able to safely do <code>axiom heq_trans : f == g -&gt; x == y -&gt; f x == g y</code> if needed?</p>



<a name="248184621"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Haskell%27s%20closed%20type%20families%20as%20Lean%27s%20inductive%20family/near/248184621" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Haskell's.20closed.20type.20families.20as.20Lean's.20inductive.20family.html#248184621">(Aug 03 2021 at 05:54)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113488-general/topic/Haskell's.20closed.20type.20families.20as.20Lean's.20inductive.20family/near/247870911">said</a>:</p>
<blockquote>
<blockquote>
<p>ones that state terms from two distinct types are equal</p>
</blockquote>
<p>It's not possible to say this in lean in any nontrivial way. Heterogeneous equality <code>HEq a b</code> (or <code>a == b</code> in lean 3) asserts that <code>a</code> and <code>b</code> have the same type and when you cast along that type equality the elements are equal. So terms of distinct types are never <code>HEq</code>.</p>
</blockquote>
<p>Is there anything preventing one from defining a new proper truly type heterogenous equality that does have the desired properties (either constructively or with axions)?</p>



<a name="248185239"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Haskell%27s%20closed%20type%20families%20as%20Lean%27s%20inductive%20family/near/248185239" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Haskell's.20closed.20type.20families.20as.20Lean's.20inductive.20family.html#248185239">(Aug 03 2021 at 06:08)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/113488-general/topic/Haskell's.20closed.20type.20families.20as.20Lean's.20inductive.20family/near/247878394">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="315577">Mac</span> <a href="#narrow/stream/113488-general/topic/Haskell's.20closed.20type.20families.20as.20Lean's.20inductive.20family/near/247826375">said</a>:</p>
<blockquote>
<p>The 'reintepret' is what I have a problem with. For me, that should always require an explicit cast</p>
</blockquote>
<p>You can think of a <code>match</code> expression as a way to do an explicit cast, in the sense of a C# <code>is</code> type pattern (for example, <code>if (a is string s) { ... do something with s ... }</code>).  The analogy is somewhat clearer if you write the <code>match</code> explicitly:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">flattenAux</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">Elem</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">List</span> <span class="n">β</span> <span class="o">:=</span>
<span class="k">match</span> <span class="n">t</span><span class="o">,</span> <span class="n">a</span> <span class="k">with</span>
<span class="bp">|</span> <span class="n">Elem.incl</span><span class="o">,</span> <span class="n">a'</span> <span class="bp">=&gt;</span> <span class="o">[</span><span class="n">a'</span><span class="o">]</span>
<span class="bp">|</span> <span class="n">Elem.list</span> <span class="o">(</span><span class="n">α</span> <span class="o">:=</span> <span class="n">α'</span><span class="o">)</span> <span class="n">t'</span><span class="o">,</span> <span class="o">(</span><span class="n">a'</span> <span class="o">:</span> <span class="n">List</span> <span class="n">α'</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="n">List.bind</span> <span class="n">a'</span> <span class="k">fun</span> <span class="n">x</span> <span class="bp">=&gt;</span> <span class="n">flattenAux</span> <span class="n">t'</span> <span class="n">x</span>
</code></pre></div>
<p>!)</p>
</blockquote>
<p>I get what it is doing, I just don't like it. In my view, <code>match</code>'s only effect should be pattern matching -- not type juggling. Thus <code>a</code> and <code>a'</code> should have the same type unless otherwise (explicitly) specified. However, your example does have an explicit cast in the form of the type ascription, so I am much more okay with it than I am with the implicit magic of a normal match.</p>



<a name="248246635"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Haskell%27s%20closed%20type%20families%20as%20Lean%27s%20inductive%20family/near/248246635" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Haskell's.20closed.20type.20families.20as.20Lean's.20inductive.20family.html#248246635">(Aug 03 2021 at 16:40)</a>:</h4>
<p><span class="user-mention silent" data-user-id="315577">Mac</span> <a href="#narrow/stream/113488-general/topic/Haskell's.20closed.20type.20families.20as.20Lean's.20inductive.20family/near/248184405">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113488-general/topic/Haskell's.20closed.20type.20families.20as.20Lean's.20inductive.20family/near/247871208">said</a>:</p>
<blockquote>
<p>The main reason for this is that the lemma <code>f == g -&gt; x == y -&gt; f x == g y</code> does not hold in lean (it's independent)</p>
</blockquote>
<p>If its independent, should you be able to safely do <code>axiom heq_trans : f == g -&gt; x == y -&gt; f x == g y</code> if needed?</p>
</blockquote>
<p>Well, it is closely related to injectivity of pi (if you only consider the types of the variables in the heqs) which is false in general because of Prop (<code>\forall x: Nat, true</code> is equal to <code>\forall x: Unit, true</code> by propositional extensionality)</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
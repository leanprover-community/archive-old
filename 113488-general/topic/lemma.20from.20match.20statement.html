---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/lemma.20from.20match.20statement.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/lemma.20from.20match.20statement.html">lemma from match statement</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="206086770"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lemma%20from%20match%20statement/near/206086770" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Viteri <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/lemma.20from.20match.20statement.html#206086770">(Aug 05 2020 at 22:41)</a>:</h4>
<p>Are there any lemmas that tie the matched variables to the particular case it was matched with?</p>
<p>I have a term constructor, and I am trying to define a function on it as follows:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">inductive</span> <span class="n">term</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">const</span> <span class="o">:</span> <span class="n">string</span> <span class="bp">→</span> <span class="n">option</span> <span class="n">sort</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">app</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>

<span class="kn">notation</span> <span class="bp">`</span><span class="n">clause</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">list</span> <span class="o">(</span><span class="n">option</span> <span class="n">term</span><span class="o">)</span>
<span class="kn">infixl</span> <span class="bp">`</span> <span class="err">•</span> <span class="bp">`</span> <span class="o">:</span><span class="mi">20</span>  <span class="o">:=</span> <span class="n">app</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="n">def</span> <span class="n">reduce_not_and_aux</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">clause</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">const</span> <span class="s2">&quot;and&quot;</span> <span class="bp">_</span> <span class="err">•</span> <span class="n">t₀</span> <span class="err">•</span> <span class="o">(</span><span class="n">const</span> <span class="s2">&quot;and&quot;</span> <span class="bp">_</span> <span class="err">•</span> <span class="n">t₁</span> <span class="err">•</span> <span class="n">t₂</span><span class="o">))</span> <span class="o">:=</span>
    <span class="n">mkNot</span> <span class="n">t₀</span> <span class="bp">::</span> <span class="n">mkNot</span> <span class="n">t₁</span> <span class="bp">::</span> <span class="n">reduce_not_and_aux</span> <span class="n">t₂</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">const</span> <span class="s2">&quot;and&quot;</span> <span class="bp">_</span> <span class="err">•</span> <span class="n">t₀</span> <span class="err">•</span> <span class="n">t₁</span><span class="o">)</span>  <span class="o">:=</span> <span class="o">[</span><span class="n">mkNot</span> <span class="n">t₀</span><span class="o">,</span> <span class="n">mkNot</span> <span class="n">t₁</span><span class="o">]</span>
<span class="bp">|</span> <span class="n">t</span> <span class="o">:=</span> <span class="o">[</span><span class="n">mkNot</span> <span class="n">t</span><span class="o">]</span>
</code></pre></div>


<p>However the equation compiler fails, and when I try to set_option for additional details, emacs crashes.<br>
I believe that lean is not inferring that t₂ is smaller than the full term. I have constructed a 'term_size' function, and I am trying to prove that it decreases. </p>
<p>This brings me to the original question -- can the match statement give me a lemma about what it matched?<br>
Specifically I would like to say that if the reduce_not_and_aux takes a term t, then t =(const "and" _ • t₀ • (const "and" _ • t₁ • t₂)) in the first case.</p>
<p>Thank You,<br>
Scott</p>



<a name="206093143"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lemma%20from%20match%20statement/near/206093143" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/lemma.20from.20match.20statement.html#206093143">(Aug 06 2020 at 00:23)</a>:</h4>
<p>A simp attribute works only on lemmas (and theorems), as far as I know.</p>



<a name="206093285"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lemma%20from%20match%20statement/near/206093285" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Viteri <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/lemma.20from.20match.20statement.html#206093285">(Aug 06 2020 at 00:26)</a>:</h4>
<p>woops thx</p>



<a name="206096153"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lemma%20from%20match%20statement/near/206096153" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/lemma.20from.20match.20statement.html#206096153">(Aug 06 2020 at 01:22)</a>:</h4>
<p>No, @[simp] works on definitions too.</p>



<a name="206096178"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lemma%20from%20match%20statement/near/206096178" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/lemma.20from.20match.20statement.html#206096178">(Aug 06 2020 at 01:23)</a>:</h4>
<p>It means that <code>simp</code> will happily unfold the definition itself. In my experience it's rarely what you want, and it's better to write custom simp lemmas yourself in nearly every circumstance.</p>



<a name="206096187"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lemma%20from%20match%20statement/near/206096187" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/lemma.20from.20match.20statement.html#206096187">(Aug 06 2020 at 01:23)</a>:</h4>
<p>The attribute <code>@[simps]</code> is extremely useful when defining structures: it will automatically create <code>@[simp]</code> lemmas for each of the projections.</p>



<a name="206490840"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lemma%20from%20match%20statement/near/206490840" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Viteri <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/lemma.20from.20match.20statement.html#206490840">(Aug 10 2020 at 17:48)</a>:</h4>
<p>I appreciate the comments here, but I would still be interested in an answer to the original question if possible.</p>



<a name="206505704"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lemma%20from%20match%20statement/near/206505704" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Viteri <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/lemma.20from.20match.20statement.html#206505704">(Aug 10 2020 at 19:54)</a>:</h4>
<p>Nevermind!</p>



<a name="206506938"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lemma%20from%20match%20statement/near/206506938" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/lemma.20from.20match.20statement.html#206506938">(Aug 10 2020 at 20:05)</a>:</h4>
<p>Hm, there seems to be a weird bug here:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">constant</span> <span class="n">sort</span> <span class="o">:</span> <span class="kt">Type</span>

<span class="kn">inductive</span> <span class="n">term</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">const</span> <span class="o">:</span> <span class="n">string</span> <span class="bp">→</span> <span class="n">option</span> <span class="n">sort</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">app</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
<span class="kn">open</span> <span class="n">term</span>

<span class="n">def</span> <span class="n">reduce_not_and_aux</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">unit</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">app</span> <span class="bp">_</span> <span class="n">t</span><span class="o">)</span> <span class="o">:=</span> <span class="n">reduce_not_and_aux</span> <span class="n">t</span>
<span class="bp">|</span> <span class="n">t</span> <span class="o">:=</span> <span class="o">()</span>
</code></pre></div>


<p>If you replace <code>constant sort : Type</code> with <code>def sort : Type := sorry</code> it works, which suggests somehow the noncomputable marker is interfering with the equation compiler</p>



<a name="206507425"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lemma%20from%20match%20statement/near/206507425" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/lemma.20from.20match.20statement.html#206507425">(Aug 10 2020 at 20:09)</a>:</h4>
<p>But even after fixing that, it seems the equation compiler still has an issue with the definition, which I assume is what you are seeing. The problem has to do with the way string matches are compiled. Here's an implementation that will work:</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">sort</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="kn">inductive</span> <span class="n">term</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">const</span> <span class="o">:</span> <span class="n">string</span> <span class="bp">→</span> <span class="n">option</span> <span class="n">sort</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">app</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
<span class="kn">open</span> <span class="n">term</span>

<span class="kn">notation</span> <span class="bp">`</span><span class="n">clause</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">list</span> <span class="o">(</span><span class="n">option</span> <span class="n">term</span><span class="o">)</span>
<span class="kn">infixl</span> <span class="bp">`</span> <span class="err">•</span> <span class="bp">`</span> <span class="o">:</span><span class="mi">20</span>  <span class="o">:=</span> <span class="n">app</span>

<span class="n">def</span> <span class="n">mkNot</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="n">def</span> <span class="n">is_and</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">bool</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">const</span> <span class="s2">&quot;and&quot;</span> <span class="bp">_</span><span class="o">)</span> <span class="o">:=</span> <span class="n">tt</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="o">:=</span> <span class="n">ff</span>

<span class="n">def</span> <span class="n">reduce_not_and_aux</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">clause</span>
<span class="bp">|</span> <span class="n">t</span><span class="bp">@</span><span class="o">(</span><span class="n">A1</span> <span class="err">•</span> <span class="n">t₀</span> <span class="err">•</span> <span class="o">(</span><span class="n">A2</span> <span class="err">•</span> <span class="n">t₁</span> <span class="err">•</span> <span class="n">t₂</span><span class="o">))</span> <span class="o">:=</span>
  <span class="k">if</span> <span class="n">is_and</span> <span class="n">A1</span> <span class="bp">∧</span> <span class="n">is_and</span> <span class="n">A2</span> <span class="k">then</span>
    <span class="n">mkNot</span> <span class="n">t₀</span> <span class="bp">::</span> <span class="n">mkNot</span> <span class="n">t₁</span> <span class="bp">::</span> <span class="n">reduce_not_and_aux</span> <span class="n">t₂</span>
  <span class="k">else</span> <span class="o">[</span><span class="n">mkNot</span> <span class="n">t</span><span class="o">]</span>
<span class="bp">|</span> <span class="n">t</span><span class="bp">@</span><span class="o">(</span><span class="n">A1</span> <span class="err">•</span> <span class="n">t₀</span> <span class="err">•</span> <span class="n">t₁</span><span class="o">)</span> <span class="o">:=</span>
  <span class="k">if</span> <span class="n">is_and</span> <span class="n">A1</span> <span class="k">then</span> <span class="o">[</span><span class="n">mkNot</span> <span class="n">t₀</span><span class="o">,</span> <span class="n">mkNot</span> <span class="n">t₁</span><span class="o">]</span>
  <span class="k">else</span> <span class="o">[</span><span class="n">mkNot</span> <span class="n">t</span><span class="o">]</span>
<span class="bp">|</span> <span class="n">t</span> <span class="o">:=</span> <span class="o">[</span><span class="n">mkNot</span> <span class="n">t</span><span class="o">]</span>
</code></pre></div>



<a name="206507562"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lemma%20from%20match%20statement/near/206507562" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/lemma.20from.20match.20statement.html#206507562">(Aug 10 2020 at 20:10)</a>:</h4>
<p>(it's about now that I wish lean had pattern guards)</p>



<a name="206507778"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lemma%20from%20match%20statement/near/206507778" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/lemma.20from.20match.20statement.html#206507778">(Aug 10 2020 at 20:13)</a>:</h4>
<p>If you are doing meta code, then the original version will work fine:</p>
<div class="codehilite"><pre><span></span><code><span class="n">meta</span> <span class="n">def</span> <span class="n">reduce_not_and_aux</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">clause</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">const</span> <span class="s2">&quot;and&quot;</span> <span class="bp">_</span> <span class="err">•</span> <span class="n">t₀</span> <span class="err">•</span> <span class="o">(</span><span class="n">const</span> <span class="s2">&quot;and&quot;</span> <span class="bp">_</span> <span class="err">•</span> <span class="n">t₁</span> <span class="err">•</span> <span class="n">t₂</span><span class="o">))</span> <span class="o">:=</span>
  <span class="n">mkNot</span> <span class="n">t₀</span> <span class="bp">::</span> <span class="n">mkNot</span> <span class="n">t₁</span> <span class="bp">::</span> <span class="n">reduce_not_and_aux</span> <span class="n">t₂</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">const</span> <span class="s2">&quot;and&quot;</span> <span class="bp">_</span> <span class="err">•</span> <span class="n">t₀</span> <span class="err">•</span> <span class="n">t₁</span><span class="o">)</span> <span class="o">:=</span> <span class="o">[</span><span class="n">mkNot</span> <span class="n">t₀</span><span class="o">,</span> <span class="n">mkNot</span> <span class="n">t₁</span><span class="o">]</span>
<span class="bp">|</span> <span class="n">t</span> <span class="o">:=</span> <span class="o">[</span><span class="n">mkNot</span> <span class="n">t</span><span class="o">]</span>
</code></pre></div>



<a name="206622858"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lemma%20from%20match%20statement/near/206622858" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Viteri <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/lemma.20from.20match.20statement.html#206622858">(Aug 11 2020 at 19:53)</a>:</h4>
<p>Thanks Mario! <br>
I had written the full definitions using term.rec_on to unblock myself, but this is much nicer.</p>
<p>On a separate note, is there a way to pattern match using functions?<br>
In other places I have definitions like</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">reduce_iff_aux</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">nat</span> <span class="bp">→</span> <span class="n">clause</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">const</span> <span class="s2">&quot;iff&quot;</span> <span class="bp">_</span> <span class="err">•</span> <span class="n">t₀</span> <span class="err">•</span> <span class="n">t₁</span><span class="o">)</span> <span class="mi">0</span> <span class="o">:=</span> <span class="o">[</span><span class="n">mkNot</span> <span class="n">t₀</span><span class="o">,</span> <span class="n">t₁</span><span class="o">]</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">const</span> <span class="s2">&quot;iff&quot;</span> <span class="bp">_</span> <span class="err">•</span> <span class="n">t₀</span> <span class="err">•</span> <span class="n">t₁</span><span class="o">)</span> <span class="mi">1</span> <span class="o">:=</span> <span class="o">[</span><span class="n">t₀</span><span class="o">,</span> <span class="n">mkNot</span> <span class="n">t₁</span><span class="o">]</span>
<span class="bp">|</span> <span class="bp">_</span>           <span class="bp">_</span> <span class="o">:=</span> <span class="o">[</span><span class="n">option</span><span class="bp">.</span><span class="n">none</span><span class="o">]</span>
 <span class="bp">```</span>
<span class="n">But</span> <span class="n">I</span> <span class="n">would</span> <span class="n">much</span> <span class="n">rather</span> <span class="n">define</span> <span class="n">something</span> <span class="n">like</span>
</code></pre></div>


<p>def iff (t₁ t₂ : term) : term := const "iff" _ • t₁ • t₂<br>
def reduce_iff_aux : term → nat → clause<br>
| (iff • t₀ • t₁) 0 := [mkNot t₀, t₁]<br>
| (iff • t₀ • t₁) 1 := [t₀, mkNot t₁]<br>
| _           _ := [option.none]</p>
<div class="codehilite"><pre><span></span><code>
</code></pre></div>



<a name="206623111"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lemma%20from%20match%20statement/near/206623111" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/lemma.20from.20match.20statement.html#206623111">(Aug 11 2020 at 19:55)</a>:</h4>
<p>Try putting <code>@[pattern]</code> before <code>def iff</code></p>



<a name="206623289"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lemma%20from%20match%20statement/near/206623289" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Viteri <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/lemma.20from.20match.20statement.html#206623289">(Aug 11 2020 at 19:56)</a>:</h4>
<p>that worked, thanks!</p>



<a name="207045936"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lemma%20from%20match%20statement/near/207045936" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Viteri <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/lemma.20from.20match.20statement.html#207045936">(Aug 16 2020 at 00:09)</a>:</h4>
<p>Investigating the cause of the string pattern match issue, I find that<br>
<code>#reduce (string.has_decidable_eq "hi" "hi")</code><br>
yields</p>
<div class="codehilite"><pre><span></span><code><span class="mi">619</span><span class="o">:</span><span class="mi">1</span><span class="o">:</span> <span class="n">excessive</span> <span class="n">memory</span> <span class="n">consumption</span> <span class="n">detected</span> <span class="n">at</span> <span class="err">&#39;</span><span class="n">replace&#39;</span> <span class="o">(</span><span class="n">potential</span> <span class="n">solution</span><span class="o">:</span> <span class="n">increase</span> <span class="n">memory</span> <span class="n">consumption</span> <span class="n">threshold</span><span class="o">)</span>
</code></pre></div>



<a name="207046033"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lemma%20from%20match%20statement/near/207046033" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Viteri <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/lemma.20from.20match.20statement.html#207046033">(Aug 16 2020 at 00:12)</a>:</h4>
<p>The same statement with #eval works correctly.<br>
Digging a bit deeper,  I receive the same error with</p>
<div class="codehilite"><pre><span></span><code><span class="bp">#</span><span class="n">reduce</span> <span class="o">(</span><span class="n">list</span><span class="bp">.</span><span class="n">has_dec_eq</span> <span class="s2">&quot;hi&quot;</span><span class="bp">.</span><span class="n">data</span> <span class="s2">&quot;hi&quot;</span><span class="bp">.</span><span class="n">data</span><span class="o">)</span>
</code></pre></div>



<a name="207046042"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lemma%20from%20match%20statement/near/207046042" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Viteri <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/lemma.20from.20match.20statement.html#207046042">(Aug 16 2020 at 00:13)</a>:</h4>
<p>(side note: why are the has_dec_eq statements named inconsistently?)</p>



<a name="207046161"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lemma%20from%20match%20statement/near/207046161" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/lemma.20from.20match.20statement.html#207046161">(Aug 16 2020 at 00:16)</a>:</h4>
<p><code>#reduce</code> doesn't work well with strings, see e.g. <a href="#narrow/stream/113489-new-members/topic/deep.20recursion.20with.20append">this thread</a> and <a href="#narrow/stream/113489-new-members/topic/deep.20recursion.20error.20reducing.20strings">this thread</a>.</p>



<a name="207046982"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lemma%20from%20match%20statement/near/207046982" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Viteri <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/lemma.20from.20match.20statement.html#207046982">(Aug 16 2020 at 00:41)</a>:</h4>
<p>Ok, but then what is the reason that Mario's is_and function works?</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">is_and</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">bool</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">const</span> <span class="s2">&quot;and&quot;</span> <span class="bp">_</span><span class="o">)</span> <span class="o">:=</span> <span class="n">tt</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="o">:=</span> <span class="n">ff</span>
</code></pre></div>



<a name="207047028"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lemma%20from%20match%20statement/near/207047028" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Viteri <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/lemma.20from.20match.20statement.html#207047028">(Aug 16 2020 at 00:42)</a>:</h4>
<p><code>#reduce (is_and (const "and" boolsort))</code><br>
works fine</p>



<a name="207047038"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lemma%20from%20match%20statement/near/207047038" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/lemma.20from.20match.20statement.html#207047038">(Aug 16 2020 at 00:43)</a>:</h4>
<p>The kernel can see that <code>"and" = "and"</code> without doing much work</p>



<a name="207047087"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lemma%20from%20match%20statement/near/207047087" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/lemma.20from.20match.20statement.html#207047087">(Aug 16 2020 at 00:44)</a>:</h4>
<p>in particular, without computing the entire normal form of <code>"and"</code></p>



<a name="207047104"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lemma%20from%20match%20statement/near/207047104" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Viteri <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/lemma.20from.20match.20statement.html#207047104">(Aug 16 2020 at 00:45)</a>:</h4>
<p>so pattern matching uses the kernel to check string equality?</p>



<a name="207047111"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lemma%20from%20match%20statement/near/207047111" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/lemma.20from.20match.20statement.html#207047111">(Aug 16 2020 at 00:45)</a>:</h4>
<p><code>#reduce</code> uses the kernel to reduce things to normal form</p>



<a name="207047172"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lemma%20from%20match%20statement/near/207047172" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/lemma.20from.20match.20statement.html#207047172">(Aug 16 2020 at 00:47)</a>:</h4>
<p>in this case, that thing is whatever the equation compiler turned <code>is_and</code> into, applied to its argument</p>



<a name="207047173"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lemma%20from%20match%20statement/near/207047173" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Viteri <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/lemma.20from.20match.20statement.html#207047173">(Aug 16 2020 at 00:47)</a>:</h4>
<p>is the issue with normal form on natural numbers that the normal form is written in unary representation or something?</p>



<a name="207047194"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lemma%20from%20match%20statement/near/207047194" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/lemma.20from.20match.20statement.html#207047194">(Aug 16 2020 at 00:48)</a>:</h4>
<p>yes but it's worse than that: the proof that <code>'a'</code> is a valid Unicode character is also encoded in unary</p>



<a name="207047237"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lemma%20from%20match%20statement/near/207047237" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Viteri <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/lemma.20from.20match.20statement.html#207047237">(Aug 16 2020 at 00:49)</a>:</h4>
<p>where does this notation come from?<br>
n &lt; 0xd800 ∨ (0xdfff &lt; n ∧ n &lt; 0x110000)</p>



<a name="207047243"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lemma%20from%20match%20statement/near/207047243" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Viteri <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/lemma.20from.20match.20statement.html#207047243">(Aug 16 2020 at 00:49)</a>:</h4>
<p>namely the hexadecimal</p>



<a name="207047313"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lemma%20from%20match%20statement/near/207047313" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/lemma.20from.20match.20statement.html#207047313">(Aug 16 2020 at 00:51)</a>:</h4>
<p>I would presume it's built-in just like ordinary decimal numeric literals.</p>



<a name="207047380"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lemma%20from%20match%20statement/near/207047380" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Viteri <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/lemma.20from.20match.20statement.html#207047380">(Aug 16 2020 at 00:53)</a>:</h4>
<p>When I write <code>#check 123</code> should I think of that as a unary nat?</p>



<a name="207047383"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lemma%20from%20match%20statement/near/207047383" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/lemma.20from.20match.20statement.html#207047383">(Aug 16 2020 at 00:53)</a>:</h4>
<p>I would think of it as 123</p>



<a name="207047421"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lemma%20from%20match%20statement/near/207047421" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Viteri <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/lemma.20from.20match.20statement.html#207047421">(Aug 16 2020 at 00:54)</a>:</h4>
<p>Because it infers the type is nat</p>



<a name="207047425"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lemma%20from%20match%20statement/near/207047425" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/lemma.20from.20match.20statement.html#207047425">(Aug 16 2020 at 00:54)</a>:</h4>
<p>the representation and whether you care what the representation is depends on the context</p>



<a name="207047427"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lemma%20from%20match%20statement/near/207047427" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/lemma.20from.20match.20statement.html#207047427">(Aug 16 2020 at 00:54)</a>:</h4>
<p>the inferred type also depends on the context, but with no context it's indeed nat</p>



<a name="207047430"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lemma%20from%20match%20statement/near/207047430" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Viteri <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/lemma.20from.20match.20statement.html#207047430">(Aug 16 2020 at 00:54)</a>:</h4>
<p>oh really</p>



<a name="207047443"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lemma%20from%20match%20statement/near/207047443" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Viteri <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/lemma.20from.20match.20statement.html#207047443">(Aug 16 2020 at 00:55)</a>:</h4>
<p>so there is some code to do this context inference somewhere in the c++?</p>



<a name="207047498"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lemma%20from%20match%20statement/near/207047498" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/lemma.20from.20match.20statement.html#207047498">(Aug 16 2020 at 00:56)</a>:</h4>
<p>Writing <code>#check 2000000000000000</code> works fine, so obviously in this situation Lean did not build a unary representation of the number behind the scenes</p>



<a name="207047514"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lemma%20from%20match%20statement/near/207047514" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Viteri <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/lemma.20from.20match.20statement.html#207047514">(Aug 16 2020 at 00:57)</a>:</h4>
<p>haha right</p>



<a name="207047558"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lemma%20from%20match%20statement/near/207047558" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Viteri <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/lemma.20from.20match.20statement.html#207047558">(Aug 16 2020 at 00:58)</a>:</h4>
<p>It can't be so hard to rewrite char using hexadecimal nat explicitly written as an inductive datatype, no?</p>



<a name="207047619"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lemma%20from%20match%20statement/near/207047619" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/lemma.20from.20match.20statement.html#207047619">(Aug 16 2020 at 01:01)</a>:</h4>
<p>It would be possible but there's no real application I can think of</p>



<a name="207047624"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lemma%20from%20match%20statement/near/207047624" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/lemma.20from.20match.20statement.html#207047624">(Aug 16 2020 at 01:01)</a>:</h4>
<p>and it would complicate making <code>#eval</code> treat them efficiently</p>



<a name="207047678"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lemma%20from%20match%20statement/near/207047678" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/lemma.20from.20match.20statement.html#207047678">(Aug 16 2020 at 01:03)</a>:</h4>
<p>for syntax trees you shouldn't really be using <code>string</code> in the first place--make an inductive type with the values you care about</p>



<a name="207047683"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lemma%20from%20match%20statement/near/207047683" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Viteri <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/lemma.20from.20match.20statement.html#207047683">(Aug 16 2020 at 01:03)</a>:</h4>
<p>In this context I want to simulate an open type</p>



<a name="207047713"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lemma%20from%20match%20statement/near/207047713" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Viteri <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/lemma.20from.20match.20statement.html#207047713">(Aug 16 2020 at 01:04)</a>:</h4>
<p>I'm adding smt theories dynamically</p>



<a name="207047748"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lemma%20from%20match%20statement/near/207047748" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Viteri <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/lemma.20from.20match.20statement.html#207047748">(Aug 16 2020 at 01:05)</a>:</h4>
<p>I really don't want support them all in one big inductive term/sort datastructure, and then edit any def that uses them upon each addition</p>



<a name="207047796"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lemma%20from%20match%20statement/near/207047796" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Viteri <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/lemma.20from.20match.20statement.html#207047796">(Aug 16 2020 at 01:06)</a>:</h4>
<p>Now I could replace string matching with nat here, but that will make things more difficult to read</p>



<a name="207047803"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lemma%20from%20match%20statement/near/207047803" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/lemma.20from.20match.20statement.html#207047803">(Aug 16 2020 at 01:06)</a>:</h4>
<p>or use a type variable</p>



<a name="207047811"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lemma%20from%20match%20statement/near/207047811" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/lemma.20from.20match.20statement.html#207047811">(Aug 16 2020 at 01:07)</a>:</h4>
<p>but I agree this is a bit more complicated</p>



<a name="207047813"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lemma%20from%20match%20statement/near/207047813" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Viteri <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/lemma.20from.20match.20statement.html#207047813">(Aug 16 2020 at 01:07)</a>:</h4>
<p>do you mean if I set the different sorts up as types?</p>



<a name="207047855"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lemma%20from%20match%20statement/near/207047855" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Viteri <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/lemma.20from.20match.20statement.html#207047855">(Aug 16 2020 at 01:08)</a>:</h4>
<p>and pattern match on which type</p>



<a name="207047859"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lemma%20from%20match%20statement/near/207047859" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Viteri <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/lemma.20from.20match.20statement.html#207047859">(Aug 16 2020 at 01:08)</a>:</h4>
<p>Actually I am unsure what you mean</p>



<a name="207047864"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lemma%20from%20match%20statement/near/207047864" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/lemma.20from.20match.20statement.html#207047864">(Aug 16 2020 at 01:08)</a>:</h4>
<p>well, I'd have to think about it more but I'm pretty sure there is always a better option than <code>string</code></p>



<a name="207047871"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lemma%20from%20match%20statement/near/207047871" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Viteri <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/lemma.20from.20match.20statement.html#207047871">(Aug 16 2020 at 01:09)</a>:</h4>
<p>fair enough</p>



<a name="207047925"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lemma%20from%20match%20statement/near/207047925" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Viteri <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/lemma.20from.20match.20statement.html#207047925">(Aug 16 2020 at 01:10)</a>:</h4>
<p>this is the kind of example that I am looking at</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">sortof_aux</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">option</span> <span class="n">sort</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">const</span> <span class="n">str</span> <span class="n">s</span><span class="o">)</span> <span class="o">:=</span>
  <span class="k">match</span> <span class="n">str</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="s2">&quot;bot&quot;</span> <span class="o">:=</span> <span class="n">boolsort</span>
  <span class="bp">|</span> <span class="s2">&quot;not&quot;</span> <span class="o">:=</span> <span class="o">(</span><span class="n">arrow</span> <span class="n">boolsort</span> <span class="n">boolsort</span><span class="o">)</span>
  <span class="bp">|</span> <span class="s2">&quot;or&quot;</span>  <span class="o">:=</span> <span class="o">(</span><span class="n">arrow</span> <span class="n">boolsort</span> <span class="o">(</span><span class="n">arrow</span> <span class="n">boolsort</span> <span class="n">boolsort</span><span class="o">))</span>
  <span class="bp">|</span> <span class="s2">&quot;and&quot;</span>  <span class="o">:=</span> <span class="o">(</span><span class="n">arrow</span> <span class="n">boolsort</span> <span class="o">(</span><span class="n">arrow</span> <span class="n">boolsort</span> <span class="n">boolsort</span><span class="o">))</span>
  <span class="bp">|</span> <span class="s2">&quot;implies&quot;</span>  <span class="o">:=</span> <span class="o">(</span><span class="n">arrow</span> <span class="n">boolsort</span> <span class="o">(</span><span class="n">arrow</span> <span class="n">boolsort</span> <span class="n">boolsort</span><span class="o">))</span>
  <span class="bp">|</span> <span class="s2">&quot;xor&quot;</span>  <span class="o">:=</span> <span class="o">(</span><span class="n">arrow</span> <span class="n">boolsort</span> <span class="o">(</span><span class="n">arrow</span> <span class="n">boolsort</span> <span class="n">boolsort</span><span class="o">))</span>
  <span class="bp">|</span> <span class="s2">&quot;iff&quot;</span>  <span class="o">:=</span> <span class="o">(</span><span class="n">arrow</span> <span class="n">boolsort</span> <span class="o">(</span><span class="n">arrow</span> <span class="n">boolsort</span> <span class="n">boolsort</span><span class="o">))</span>
  <span class="bp">|</span> <span class="bp">_</span>      <span class="o">:=</span> <span class="n">s</span>
  <span class="kn">end</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">const</span> <span class="n">str</span> <span class="o">(</span><span class="n">option</span><span class="bp">.</span><span class="n">some</span> <span class="n">constructor</span><span class="o">)</span> <span class="err">•</span> <span class="n">t₁</span> <span class="err">•</span> <span class="n">t₂</span><span class="o">)</span> <span class="o">:=</span>
  <span class="k">if</span> <span class="n">str</span> <span class="bp">=</span> <span class="s2">&quot;eq&quot;</span> <span class="k">then</span>
    <span class="n">do</span> <span class="n">s₁</span> <span class="err">←</span> <span class="n">sortof_aux</span> <span class="n">t₁</span><span class="o">,</span> <span class="n">s₂</span> <span class="err">←</span> <span class="n">sortof_aux</span> <span class="n">t₂</span><span class="o">,</span>
      <span class="k">if</span> <span class="n">s₁</span> <span class="bp">=</span> <span class="n">s₂</span> <span class="k">then</span> <span class="n">boolsort</span> <span class="k">else</span> <span class="n">option</span><span class="bp">.</span><span class="n">none</span>
  <span class="k">else</span> <span class="n">option</span><span class="bp">.</span><span class="n">none</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">const</span> <span class="n">str</span> <span class="o">(</span><span class="n">option</span><span class="bp">.</span><span class="n">some</span> <span class="n">constructor</span><span class="o">)</span> <span class="err">•</span> <span class="n">t₁</span> <span class="err">•</span> <span class="n">t₂</span> <span class="err">•</span> <span class="n">t₃</span><span class="o">)</span> <span class="o">:=</span>
  <span class="k">if</span> <span class="n">str</span> <span class="bp">=</span> <span class="s2">&quot;f_ite&quot;</span> <span class="k">then</span>
    <span class="o">(</span><span class="n">do</span> <span class="n">s₁</span> <span class="err">←</span> <span class="n">sortof_aux</span> <span class="n">t₁</span><span class="o">,</span> <span class="n">s₂</span> <span class="err">←</span> <span class="n">sortof_aux</span> <span class="n">t₂</span><span class="o">,</span> <span class="n">s₃</span> <span class="err">←</span> <span class="n">sortof_aux</span> <span class="n">t₂</span><span class="o">,</span>
        <span class="k">if</span> <span class="n">s₁</span> <span class="bp">=</span> <span class="n">boolsort</span> <span class="bp">∧</span> <span class="n">s₂</span> <span class="bp">=</span> <span class="n">s₃</span> <span class="k">then</span> <span class="n">s₂</span> <span class="k">else</span> <span class="n">option</span><span class="bp">.</span><span class="n">none</span><span class="o">)</span>
  <span class="k">else</span> <span class="n">option</span><span class="bp">.</span><span class="n">none</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">f</span> <span class="err">•</span> <span class="n">t</span><span class="o">)</span>  <span class="o">:=</span>
  <span class="n">do</span> <span class="n">sf</span> <span class="err">←</span> <span class="n">sortof_aux</span> <span class="n">f</span><span class="o">,</span> <span class="n">s</span> <span class="err">←</span> <span class="n">sortof_aux</span> <span class="n">t</span><span class="o">,</span>
    <span class="k">match</span> <span class="n">sf</span> <span class="k">with</span>
    <span class="bp">|</span> <span class="o">(</span><span class="n">arrow</span> <span class="n">s1</span> <span class="n">s2</span><span class="o">)</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">s1</span> <span class="bp">=</span> <span class="n">s</span> <span class="k">then</span> <span class="n">s2</span> <span class="k">else</span> <span class="n">option</span><span class="bp">.</span><span class="n">none</span>
    <span class="bp">|</span> <span class="bp">_</span> <span class="o">:=</span> <span class="n">option</span><span class="bp">.</span><span class="n">none</span>
    <span class="kn">end</span>

<span class="n">def</span> <span class="n">sortof</span> <span class="o">:</span> <span class="n">option</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">option</span> <span class="n">sort</span> <span class="o">:=</span>
 <span class="o">(</span><span class="n">flip</span> <span class="n">option</span><span class="bp">.</span><span class="n">bind</span><span class="o">)</span> <span class="n">sortof_aux</span>

<span class="n">def</span> <span class="n">x₁</span> <span class="o">:=</span> <span class="n">const</span> <span class="s2">&quot;x₁&quot;</span> <span class="n">boolsort</span>
<span class="bp">#</span><span class="n">reduce</span> <span class="o">(</span><span class="n">sortof</span> <span class="n">x₁</span><span class="o">)</span> <span class="c1">-- recursion error</span>
</code></pre></div>



<a name="207047929"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lemma%20from%20match%20statement/near/207047929" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Viteri <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/lemma.20from.20match.20statement.html#207047929">(Aug 16 2020 at 01:10)</a>:</h4>
<p>doesn't work because comparing strings</p>



<a name="207047939"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lemma%20from%20match%20statement/near/207047939" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/lemma.20from.20match.20statement.html#207047939">(Aug 16 2020 at 01:11)</a>:</h4>
<p>does <code>#eval</code> work?</p>



<a name="207047949"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lemma%20from%20match%20statement/near/207047949" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Viteri <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/lemma.20from.20match.20statement.html#207047949">(Aug 16 2020 at 01:11)</a>:</h4>
<p>yes</p>



<a name="207047953"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lemma%20from%20match%20statement/near/207047953" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Viteri <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/lemma.20from.20match.20statement.html#207047953">(Aug 16 2020 at 01:11)</a>:</h4>
<p><code>#eval (sortof x₁)</code> -- (some bool)</p>



<a name="207047956"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lemma%20from%20match%20statement/near/207047956" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/lemma.20from.20match.20statement.html#207047956">(Aug 16 2020 at 01:11)</a>:</h4>
<p>Another option to represent an "open type" would be <code>num</code></p>



<a name="207047994"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lemma%20from%20match%20statement/near/207047994" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/lemma.20from.20match.20statement.html#207047994">(Aug 16 2020 at 01:12)</a>:</h4>
<p>just define <code>bot := 0</code> and <code>not := 1</code> and so on</p>



<a name="207048006"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lemma%20from%20match%20statement/near/207048006" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/lemma.20from.20match.20statement.html#207048006">(Aug 16 2020 at 01:13)</a>:</h4>
<p>You should be able to handle at least a few thousand constructors that way in the kernel</p>



<a name="207048020"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lemma%20from%20match%20statement/near/207048020" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Viteri <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/lemma.20from.20match.20statement.html#207048020">(Aug 16 2020 at 01:13)</a>:</h4>
<p>Ok I'm looking at num now</p>



<a name="207048061"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lemma%20from%20match%20statement/near/207048061" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Viteri <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/lemma.20from.20match.20statement.html#207048061">(Aug 16 2020 at 01:14)</a>:</h4>
<p>it is zero or pos, and if pos seems to have a binary encoding of nat</p>



<a name="207048064"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lemma%20from%20match%20statement/near/207048064" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Viteri <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/lemma.20from.20match.20statement.html#207048064">(Aug 16 2020 at 01:14)</a>:</h4>
<p>why is this better than using nat</p>



<a name="207048069"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lemma%20from%20match%20statement/near/207048069" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Viteri <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/lemma.20from.20match.20statement.html#207048069">(Aug 16 2020 at 01:14)</a>:</h4>
<p>efficiency?</p>



<a name="207048133"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lemma%20from%20match%20statement/near/207048133" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/lemma.20from.20match.20statement.html#207048133">(Aug 16 2020 at 01:16)</a>:</h4>
<p>Yes, you can <code>#reduce (200000000000000 : num)</code> in the kernel without too much trouble</p>



<a name="207048142"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lemma%20from%20match%20statement/near/207048142" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Viteri <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/lemma.20from.20match.20statement.html#207048142">(Aug 16 2020 at 01:17)</a>:</h4>
<p>I could use a map from strings to their corresponding nums to make it more readable, but I feel like this runs into the same issues as before</p>



<a name="207048151"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lemma%20from%20match%20statement/near/207048151" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/lemma.20from.20match.20statement.html#207048151">(Aug 16 2020 at 01:17)</a>:</h4>
<p>actually I lied, lean can only go up to about <code>(20000 : num)</code>, although this is farther than you can go on <code>nat</code></p>



<a name="207048196"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lemma%20from%20match%20statement/near/207048196" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/lemma.20from.20match.20statement.html#207048196">(Aug 16 2020 at 01:18)</a>:</h4>
<p>In Coq it's pretty common to use <code>pos_num</code> for maps and things in the kernel</p>



<a name="207048197"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lemma%20from%20match%20statement/near/207048197" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Viteri <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/lemma.20from.20match.20statement.html#207048197">(Aug 16 2020 at 01:18)</a>:</h4>
<p>I mean 20000 is good enough</p>



<a name="207048206"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lemma%20from%20match%20statement/near/207048206" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/lemma.20from.20match.20statement.html#207048206">(Aug 16 2020 at 01:19)</a>:</h4>
<p>basically you should think of a function out of <code>pos_num</code> as an infinite binary tree</p>



<a name="207048246"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lemma%20from%20match%20statement/near/207048246" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/lemma.20from.20match.20statement.html#207048246">(Aug 16 2020 at 01:20)</a>:</h4>
<p>whereas a function out of <code>nat</code> is more like a list</p>



<a name="207048252"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lemma%20from%20match%20statement/near/207048252" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/lemma.20from.20match.20statement.html#207048252">(Aug 16 2020 at 01:20)</a>:</h4>
<p>so it is easier to store more data, more easily accessible, on the tree representation</p>



<a name="207048271"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lemma%20from%20match%20statement/near/207048271" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/lemma.20from.20match.20statement.html#207048271">(Aug 16 2020 at 01:21)</a>:</h4>
<p>can you pattern match on <code>num</code>?</p>



<a name="207048308"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lemma%20from%20match%20statement/near/207048308" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Viteri <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/lemma.20from.20match.20statement.html#207048308">(Aug 16 2020 at 01:22)</a>:</h4>
<p>I don't see why not</p>



<a name="207048309"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lemma%20from%20match%20statement/near/207048309" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Viteri <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/lemma.20from.20match.20statement.html#207048309">(Aug 16 2020 at 01:22)</a>:</h4>
<p>it will be a nested pattern match if it is pos</p>



<a name="207048311"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lemma%20from%20match%20statement/near/207048311" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Viteri <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/lemma.20from.20match.20statement.html#207048311">(Aug 16 2020 at 01:23)</a>:</h4>
<p>does pattern match not work on all inductive types?</p>



<a name="207048363"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lemma%20from%20match%20statement/near/207048363" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/lemma.20from.20match.20statement.html#207048363">(Aug 16 2020 at 01:24)</a>:</h4>
<p>right, I guess it should work fine</p>



<a name="207048368"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lemma%20from%20match%20statement/near/207048368" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/lemma.20from.20match.20statement.html#207048368">(Aug 16 2020 at 01:24)</a>:</h4>
<p>in that case, you don't need to make a fancy map or anything, you can just write <code>@[pattern] def bot : num = 1</code> like Mario suggested</p>



<a name="207048384"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lemma%20from%20match%20statement/near/207048384" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Viteri <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/lemma.20from.20match.20statement.html#207048384">(Aug 16 2020 at 01:25)</a>:</h4>
<p>Oh</p>



<a name="207048422"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lemma%20from%20match%20statement/near/207048422" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Viteri <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/lemma.20from.20match.20statement.html#207048422">(Aug 16 2020 at 01:26)</a>:</h4>
<p>I didn't understand the suggestion</p>



<a name="207048425"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lemma%20from%20match%20statement/near/207048425" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Viteri <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/lemma.20from.20match.20statement.html#207048425">(Aug 16 2020 at 01:26)</a>:</h4>
<p>that makes total sense</p>



<a name="207048426"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lemma%20from%20match%20statement/near/207048426" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Viteri <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/lemma.20from.20match.20statement.html#207048426">(Aug 16 2020 at 01:26)</a>:</h4>
<p>Thanks!</p>



<a name="207048428"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lemma%20from%20match%20statement/near/207048428" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/lemma.20from.20match.20statement.html#207048428">(Aug 16 2020 at 01:26)</a>:</h4>
<p>actually <code>pos_num</code> is better than <code>num</code> for this</p>



<a name="207048440"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lemma%20from%20match%20statement/near/207048440" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/lemma.20from.20match.20statement.html#207048440">(Aug 16 2020 at 01:27)</a>:</h4>
<p>you don't need 0 here so the pure tree structure is simpler</p>



<a name="207048448"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lemma%20from%20match%20statement/near/207048448" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Viteri <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/lemma.20from.20match.20statement.html#207048448">(Aug 16 2020 at 01:27)</a>:</h4>
<p>yeah</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
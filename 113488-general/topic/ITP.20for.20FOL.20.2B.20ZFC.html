---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html">ITP for FOL + ZFC</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="266648402"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/266648402" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#266648402">(Jan 03 2022 at 03:30)</a>:</h4>
<p>This is a translation of the core of the code for the interactive theorem prover described in "Handbook of Practical Logic and Automated Reasoning" by John Harrison [https://www.cl.cam.ac.uk/~jrh13/atp/index.html]. I'm wondering if I have done this correctly and if it can be extended for theorems in ZFC by adding the axioms for ZFC in the manner that I have added the first. Also, I am not certain if I am missing something, but the code for axiomExistsEq does not seem to match its 'x not free in t' comment.</p>
<div class="codehilite" data-code-language="Haskell"><pre><span></span><code><span class="kr">import</span> <span class="nn">Data.List</span>
<span class="kr">import</span> <span class="nn">Prelude</span> <span class="k">hiding</span> <span class="p">(</span><span class="kt">False</span><span class="p">,</span> <span class="kt">True</span><span class="p">)</span>
<span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Prelude</span> <span class="p">(</span><span class="kt">Bool</span><span class="p">(</span><span class="o">..</span><span class="p">))</span>

<span class="kr">data</span> <span class="kt">Formula</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">False</span>
               <span class="o">|</span> <span class="kt">True</span>
               <span class="o">|</span> <span class="kt">Atom</span> <span class="n">a</span>
               <span class="o">|</span> <span class="kt">Not</span> <span class="p">(</span><span class="kt">Formula</span> <span class="n">a</span><span class="p">)</span>
               <span class="o">|</span> <span class="kt">And</span> <span class="p">(</span><span class="kt">Formula</span> <span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="kt">Formula</span> <span class="n">a</span><span class="p">)</span>
               <span class="o">|</span> <span class="kt">Or</span> <span class="p">(</span><span class="kt">Formula</span> <span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="kt">Formula</span> <span class="n">a</span><span class="p">)</span>
               <span class="o">|</span> <span class="kt">Imp</span> <span class="p">(</span><span class="kt">Formula</span> <span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="kt">Formula</span> <span class="n">a</span><span class="p">)</span>
               <span class="o">|</span> <span class="kt">Iff</span> <span class="p">(</span><span class="kt">Formula</span> <span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="kt">Formula</span> <span class="n">a</span><span class="p">)</span>
               <span class="o">|</span> <span class="kt">Forall</span> <span class="kt">String</span> <span class="p">(</span><span class="kt">Formula</span> <span class="n">a</span><span class="p">)</span>
               <span class="o">|</span> <span class="kt">Exists</span> <span class="kt">String</span> <span class="p">(</span><span class="kt">Formula</span> <span class="n">a</span><span class="p">)</span>
                 <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">)</span>

<span class="c1">-- Func "c" [] : A constant named c</span>
<span class="kr">data</span> <span class="kt">Term</span> <span class="ow">=</span> <span class="kt">Var</span> <span class="kt">String</span>
          <span class="o">|</span> <span class="kt">Func</span> <span class="kt">String</span> <span class="p">[</span><span class="kt">Term</span><span class="p">]</span>
            <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">)</span>

<span class="c1">-- Pred "P" [] : A propositional variable named P</span>
<span class="kr">data</span> <span class="kt">FOL</span> <span class="ow">=</span> <span class="kt">Pred</span> <span class="kt">String</span> <span class="p">[</span><span class="kt">Term</span><span class="p">]</span>
           <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">)</span>

<span class="kr">type</span> <span class="kt">Thm</span> <span class="ow">=</span> <span class="kt">Formula</span> <span class="kt">FOL</span>


<span class="nf">mkEq</span> <span class="ow">::</span> <span class="kt">Term</span> <span class="ow">-&gt;</span> <span class="kt">Term</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Formula</span> <span class="kt">FOL</span><span class="p">)</span>
<span class="nf">mkEq</span> <span class="n">s</span> <span class="n">t</span> <span class="ow">=</span> <span class="kt">Atom</span> <span class="p">(</span><span class="kt">Pred</span> <span class="s">"="</span> <span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">])</span>

<span class="nf">occursIn</span> <span class="ow">::</span> <span class="kt">Term</span> <span class="ow">-&gt;</span> <span class="kt">Term</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">occursIn</span> <span class="n">s</span> <span class="n">t</span> <span class="o">|</span> <span class="n">s</span> <span class="o">==</span> <span class="n">t</span> <span class="ow">=</span> <span class="kt">Prelude</span><span class="o">.</span><span class="kt">True</span>
<span class="nf">occursIn</span> <span class="kr">_</span> <span class="p">(</span><span class="kt">Var</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Prelude</span><span class="o">.</span><span class="kt">False</span>
<span class="nf">occursIn</span> <span class="n">s</span> <span class="p">(</span><span class="kt">Func</span> <span class="kr">_</span> <span class="n">args</span><span class="p">)</span> <span class="ow">=</span> <span class="n">any</span> <span class="p">(</span><span class="n">occursIn</span> <span class="n">s</span><span class="p">)</span> <span class="n">args</span>

<span class="nf">freeIn</span> <span class="ow">::</span> <span class="kt">Term</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Formula</span> <span class="kt">FOL</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">freeIn</span> <span class="kr">_</span> <span class="kt">False</span> <span class="ow">=</span> <span class="kt">Prelude</span><span class="o">.</span><span class="kt">False</span>
<span class="nf">freeIn</span> <span class="kr">_</span> <span class="kt">True</span> <span class="ow">=</span> <span class="kt">Prelude</span><span class="o">.</span><span class="kt">False</span>
<span class="nf">freeIn</span> <span class="n">t</span> <span class="p">(</span><span class="kt">Atom</span> <span class="p">(</span><span class="kt">Pred</span> <span class="kr">_</span> <span class="n">args</span><span class="p">))</span> <span class="ow">=</span> <span class="n">any</span> <span class="p">(</span><span class="n">occursIn</span> <span class="n">t</span><span class="p">)</span> <span class="n">args</span>
<span class="nf">freeIn</span> <span class="n">t</span> <span class="p">(</span><span class="kt">Not</span> <span class="n">p</span><span class="p">)</span> <span class="ow">=</span> <span class="n">freeIn</span> <span class="n">t</span> <span class="n">p</span>
<span class="nf">freeIn</span> <span class="n">t</span> <span class="p">(</span><span class="kt">And</span> <span class="n">p</span> <span class="n">q</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="n">freeIn</span> <span class="n">t</span> <span class="n">p</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">freeIn</span> <span class="n">t</span> <span class="n">q</span><span class="p">)</span>
<span class="nf">freeIn</span> <span class="n">t</span> <span class="p">(</span><span class="kt">Or</span> <span class="n">p</span> <span class="n">q</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="n">freeIn</span> <span class="n">t</span> <span class="n">p</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">freeIn</span> <span class="n">t</span> <span class="n">q</span><span class="p">)</span>
<span class="nf">freeIn</span> <span class="n">t</span> <span class="p">(</span><span class="kt">Imp</span> <span class="n">p</span> <span class="n">q</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="n">freeIn</span> <span class="n">t</span> <span class="n">p</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">freeIn</span> <span class="n">t</span> <span class="n">q</span><span class="p">)</span>
<span class="nf">freeIn</span> <span class="n">t</span> <span class="p">(</span><span class="kt">Iff</span> <span class="n">p</span> <span class="n">q</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="n">freeIn</span> <span class="n">t</span> <span class="n">p</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">freeIn</span> <span class="n">t</span> <span class="n">q</span><span class="p">)</span>
<span class="nf">freeIn</span> <span class="n">t</span> <span class="p">(</span><span class="kt">Forall</span> <span class="n">y</span> <span class="n">p</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="n">not</span> <span class="p">(</span><span class="n">occursIn</span> <span class="p">(</span><span class="kt">Var</span> <span class="n">y</span><span class="p">)</span> <span class="n">t</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">freeIn</span> <span class="n">t</span> <span class="n">p</span><span class="p">)</span>
<span class="nf">freeIn</span> <span class="n">t</span> <span class="p">(</span><span class="kt">Exists</span> <span class="n">y</span> <span class="n">p</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="n">not</span> <span class="p">(</span><span class="n">occursIn</span> <span class="p">(</span><span class="kt">Var</span> <span class="n">y</span><span class="p">)</span> <span class="n">t</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">freeIn</span> <span class="n">t</span> <span class="n">p</span><span class="p">)</span>

<span class="nf">itList2</span> <span class="ow">::</span> <span class="p">(</span><span class="n">t1</span> <span class="ow">-&gt;</span> <span class="n">t2</span> <span class="ow">-&gt;</span> <span class="n">t3</span> <span class="ow">-&gt;</span> <span class="n">t3</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">t1</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">t2</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">t3</span> <span class="ow">-&gt;</span> <span class="n">t3</span>
<span class="nf">itList2</span> <span class="kr">_</span> <span class="kt">[]</span> <span class="kt">[]</span> <span class="n">b</span> <span class="ow">=</span> <span class="n">b</span>
<span class="nf">itList2</span> <span class="n">f</span> <span class="p">(</span><span class="n">h1</span> <span class="kt">:</span> <span class="n">t1</span><span class="p">)</span> <span class="p">(</span><span class="n">h2</span> <span class="kt">:</span> <span class="n">t2</span><span class="p">)</span> <span class="n">b</span> <span class="ow">=</span> <span class="n">f</span> <span class="n">h1</span> <span class="n">h2</span> <span class="p">(</span><span class="n">itList2</span> <span class="n">f</span> <span class="n">t1</span> <span class="n">t2</span> <span class="n">b</span><span class="p">)</span>
<span class="nf">itList2</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span> <span class="ow">=</span> <span class="ne">error</span> <span class="s">"itList2"</span>


<span class="c1">-- if |- p ==&gt; q and |- p then |- q</span>
<span class="nf">modusPonens</span> <span class="ow">::</span> <span class="kt">Thm</span> <span class="ow">-&gt;</span> <span class="kt">Thm</span> <span class="ow">-&gt;</span> <span class="kt">Thm</span>
<span class="nf">modusPonens</span> <span class="p">(</span><span class="kt">Imp</span> <span class="n">p'</span> <span class="n">q</span><span class="p">)</span> <span class="n">p</span> <span class="o">|</span> <span class="n">p</span> <span class="o">==</span> <span class="n">p'</span> <span class="ow">=</span> <span class="n">q</span>
                         <span class="o">|</span> <span class="n">otherwise</span> <span class="ow">=</span> <span class="ne">error</span> <span class="s">"modusPonens: p != p'"</span>
<span class="nf">modusPonens</span> <span class="kr">_</span> <span class="kr">_</span> <span class="ow">=</span> <span class="ne">error</span> <span class="s">"modusPonens: pattern match"</span>

<span class="c1">-- if |- p then |- forall x. p</span>
<span class="nf">gen</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Thm</span> <span class="ow">-&gt;</span> <span class="kt">Thm</span>
<span class="nf">gen</span> <span class="n">x</span> <span class="n">p</span> <span class="ow">=</span> <span class="kt">Forall</span> <span class="n">x</span> <span class="n">p</span>

<span class="c1">-- |- p ==&gt; (q ==&gt; p)</span>
<span class="nf">axiomAddImp</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Formula</span> <span class="kt">FOL</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Formula</span> <span class="kt">FOL</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Thm</span>
<span class="nf">axiomAddImp</span> <span class="n">p</span> <span class="n">q</span> <span class="ow">=</span> <span class="kt">Imp</span> <span class="n">p</span> <span class="p">(</span><span class="kt">Imp</span> <span class="n">q</span> <span class="n">p</span><span class="p">)</span>

<span class="c1">-- |- (p ==&gt; q ==&gt; r) ==&gt; (p ==&gt; q) ==&gt; (p ==&gt; r)</span>
<span class="nf">axiomDistribImp</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Formula</span> <span class="kt">FOL</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Formula</span> <span class="kt">FOL</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Formula</span> <span class="kt">FOL</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Thm</span>
<span class="nf">axiomDistribImp</span> <span class="n">p</span> <span class="n">q</span> <span class="n">r</span> <span class="ow">=</span> <span class="kt">Imp</span> <span class="p">(</span><span class="kt">Imp</span> <span class="n">p</span> <span class="p">(</span><span class="kt">Imp</span> <span class="n">q</span> <span class="n">r</span><span class="p">))</span> <span class="p">(</span><span class="kt">Imp</span> <span class="p">(</span><span class="kt">Imp</span> <span class="n">p</span> <span class="n">q</span><span class="p">)</span> <span class="p">(</span><span class="kt">Imp</span> <span class="n">p</span> <span class="n">r</span><span class="p">))</span>

<span class="c1">-- |- ((p ==&gt; false) ==&gt; false) ==&gt; p</span>
<span class="nf">axiomDoubleNeg</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Formula</span> <span class="kt">FOL</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Thm</span>
<span class="nf">axiomDoubleNeg</span> <span class="n">p</span> <span class="ow">=</span> <span class="kt">Imp</span> <span class="p">(</span><span class="kt">Imp</span> <span class="p">(</span><span class="kt">Imp</span> <span class="n">p</span> <span class="kt">False</span><span class="p">)</span> <span class="kt">False</span><span class="p">)</span> <span class="n">p</span>

<span class="c1">-- |- (forall x. p ==&gt; q) ==&gt; (forall x. p) ==&gt; (forall x. q)</span>
<span class="nf">axiomAllImp</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Formula</span> <span class="kt">FOL</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Formula</span> <span class="kt">FOL</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Thm</span>
<span class="nf">axiomAllImp</span> <span class="n">x</span> <span class="n">p</span> <span class="n">q</span> <span class="ow">=</span> <span class="kt">Imp</span> <span class="p">(</span><span class="kt">Forall</span> <span class="n">x</span> <span class="p">(</span><span class="kt">Imp</span> <span class="n">p</span> <span class="n">q</span><span class="p">))</span> <span class="p">(</span><span class="kt">Imp</span> <span class="p">(</span><span class="kt">Forall</span> <span class="n">x</span> <span class="n">p</span><span class="p">)</span> <span class="p">(</span><span class="kt">Forall</span> <span class="n">x</span> <span class="n">q</span><span class="p">))</span>

<span class="c1">-- |- p ==&gt; forall x. p [x not free in p]</span>
<span class="nf">axiomImpAll</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Formula</span> <span class="kt">FOL</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Thm</span>
<span class="nf">axiomImpAll</span> <span class="n">x</span> <span class="n">p</span> <span class="ow">=</span> <span class="kr">if</span> <span class="n">not</span> <span class="p">(</span><span class="n">freeIn</span> <span class="p">(</span><span class="kt">Var</span> <span class="n">x</span><span class="p">)</span> <span class="n">p</span><span class="p">)</span>
                  <span class="kr">then</span> <span class="p">(</span><span class="kt">Imp</span> <span class="n">p</span> <span class="p">(</span><span class="kt">Forall</span> <span class="n">x</span> <span class="n">p</span><span class="p">))</span>
                  <span class="kr">else</span> <span class="ne">error</span> <span class="s">"axiomImpAll: variable free in formula"</span>

<span class="c1">-- |- exists x. x = t [x not free in t]</span>
<span class="nf">axiomExistsEq</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Term</span> <span class="ow">-&gt;</span> <span class="kt">Thm</span>
<span class="nf">axiomExistsEq</span> <span class="n">x</span> <span class="n">t</span> <span class="ow">=</span> <span class="kr">if</span> <span class="n">not</span> <span class="p">(</span><span class="n">occursIn</span> <span class="p">(</span><span class="kt">Var</span> <span class="n">x</span><span class="p">)</span> <span class="n">t</span><span class="p">)</span>
                    <span class="kr">then</span> <span class="p">(</span><span class="kt">Exists</span> <span class="n">x</span> <span class="p">(</span><span class="n">mkEq</span> <span class="p">(</span><span class="kt">Var</span> <span class="n">x</span><span class="p">)</span> <span class="n">t</span><span class="p">))</span>
                    <span class="kr">else</span> <span class="ne">error</span> <span class="s">"axiomExistsEq: variable free in term"</span>

<span class="c1">-- |- t = t</span>
<span class="nf">axiomEqRefl</span> <span class="ow">::</span> <span class="kt">Term</span> <span class="ow">-&gt;</span> <span class="kt">Thm</span>
<span class="nf">axiomEqRefl</span> <span class="n">t</span> <span class="ow">=</span> <span class="n">mkEq</span> <span class="n">t</span> <span class="n">t</span>

<span class="c1">-- |- s1 = t1 ==&gt; ... ==&gt; sn = tn ==&gt; f(s1,..,sn) = f(t1,..,tn)</span>
<span class="nf">axiomFunCong</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Term</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Term</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Thm</span>
<span class="nf">axiomFunCong</span> <span class="n">f</span> <span class="n">lefts</span> <span class="n">rights</span> <span class="ow">=</span>
       <span class="n">itList2</span> <span class="p">(</span><span class="nf">\</span><span class="n">s</span> <span class="n">t</span> <span class="n">p</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Imp</span> <span class="p">(</span><span class="n">mkEq</span> <span class="n">s</span> <span class="n">t</span><span class="p">)</span> <span class="n">p</span><span class="p">))</span> <span class="n">lefts</span> <span class="n">rights</span>
               <span class="p">(</span><span class="n">mkEq</span> <span class="p">(</span><span class="kt">Func</span> <span class="n">f</span> <span class="n">lefts</span><span class="p">)</span> <span class="p">(</span><span class="kt">Func</span> <span class="n">f</span> <span class="n">rights</span><span class="p">))</span>

<span class="c1">-- |- s1 = t1 ==&gt; ... ==&gt; sn = tn ==&gt; P(s1,..,sn) ==&gt; P(t1,..,tn)</span>
<span class="nf">axiomPredCong</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Term</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Term</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Thm</span>
<span class="nf">axiomPredCong</span> <span class="n">p</span> <span class="n">lefts</span> <span class="n">rights</span> <span class="ow">=</span>
       <span class="n">itList2</span> <span class="p">(</span><span class="nf">\</span><span class="n">s</span> <span class="n">t</span> <span class="n">p</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Imp</span> <span class="p">(</span><span class="n">mkEq</span> <span class="n">s</span> <span class="n">t</span><span class="p">)</span> <span class="n">p</span><span class="p">))</span> <span class="n">lefts</span> <span class="n">rights</span>
               <span class="p">(</span><span class="kt">Imp</span> <span class="p">(</span><span class="kt">Atom</span> <span class="p">(</span><span class="kt">Pred</span> <span class="n">p</span> <span class="n">lefts</span><span class="p">))</span> <span class="p">(</span><span class="kt">Atom</span> <span class="p">(</span><span class="kt">Pred</span> <span class="n">p</span> <span class="n">rights</span><span class="p">)))</span>

<span class="c1">-- |- (p &lt;=&gt; q) ==&gt; p ==&gt; q</span>
<span class="nf">axiomIffImp1</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Formula</span> <span class="kt">FOL</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Formula</span> <span class="kt">FOL</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Thm</span>
<span class="nf">axiomIffImp1</span> <span class="n">p</span> <span class="n">q</span> <span class="ow">=</span> <span class="kt">Imp</span> <span class="p">(</span><span class="kt">Iff</span> <span class="n">p</span> <span class="n">q</span><span class="p">)</span> <span class="p">(</span><span class="kt">Imp</span> <span class="n">p</span> <span class="n">q</span><span class="p">)</span>

<span class="c1">-- |- (p &lt;=&gt; q) ==&gt; q ==&gt; p</span>
<span class="nf">axiomIffImp2</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Formula</span> <span class="kt">FOL</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Formula</span> <span class="kt">FOL</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Thm</span>
<span class="nf">axiomIffImp2</span> <span class="n">p</span> <span class="n">q</span> <span class="ow">=</span> <span class="kt">Imp</span> <span class="p">(</span><span class="kt">Iff</span> <span class="n">p</span> <span class="n">q</span><span class="p">)</span> <span class="p">(</span><span class="kt">Imp</span> <span class="n">q</span> <span class="n">p</span><span class="p">)</span>

<span class="c1">-- |- (p ==&gt; q) ==&gt; (q ==&gt; p) ==&gt; (p &lt;=&gt; q)</span>
<span class="nf">axiomImpIff</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Formula</span> <span class="kt">FOL</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Formula</span> <span class="kt">FOL</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Thm</span>
<span class="nf">axiomImpIff</span> <span class="n">p</span> <span class="n">q</span> <span class="ow">=</span> <span class="kt">Imp</span> <span class="p">(</span><span class="kt">Imp</span> <span class="n">p</span> <span class="n">q</span><span class="p">)</span> <span class="p">(</span><span class="kt">Imp</span> <span class="p">(</span><span class="kt">Imp</span> <span class="n">q</span> <span class="n">p</span><span class="p">)</span> <span class="p">(</span><span class="kt">Iff</span> <span class="n">p</span> <span class="n">q</span><span class="p">))</span>

<span class="c1">-- |- true &lt;=&gt; (false ==&gt; false)</span>
<span class="nf">axiomTrue</span> <span class="ow">::</span> <span class="kt">Thm</span>
<span class="nf">axiomTrue</span> <span class="ow">=</span> <span class="kt">Iff</span> <span class="kt">True</span> <span class="p">(</span><span class="kt">Imp</span> <span class="kt">False</span> <span class="kt">False</span><span class="p">)</span>

<span class="c1">-- |- ~p &lt;=&gt; (p ==&gt; false)</span>
<span class="nf">axiomNot</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Formula</span> <span class="kt">FOL</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Thm</span>
<span class="nf">axiomNot</span> <span class="n">p</span> <span class="ow">=</span> <span class="kt">Iff</span> <span class="p">(</span><span class="kt">Not</span> <span class="n">p</span><span class="p">)</span> <span class="p">(</span><span class="kt">Imp</span> <span class="n">p</span> <span class="kt">False</span><span class="p">)</span>

<span class="c1">-- |- p /\ q &lt;=&gt; (p ==&gt; q ==&gt; false) ==&gt; false</span>
<span class="nf">axiomAnd</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Formula</span> <span class="kt">FOL</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Formula</span> <span class="kt">FOL</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Thm</span>
<span class="nf">axiomAnd</span> <span class="n">p</span> <span class="n">q</span> <span class="ow">=</span> <span class="kt">Iff</span> <span class="p">(</span><span class="kt">And</span> <span class="n">p</span> <span class="n">q</span><span class="p">)</span> <span class="p">(</span><span class="kt">Imp</span> <span class="p">(</span><span class="kt">Imp</span> <span class="n">p</span> <span class="p">(</span><span class="kt">Imp</span> <span class="n">q</span> <span class="kt">False</span><span class="p">))</span> <span class="kt">False</span><span class="p">)</span>

<span class="c1">-- |- p \/ q &lt;=&gt; ~(~p /\ ~q)</span>
<span class="nf">axiomOr</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Formula</span> <span class="kt">FOL</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Formula</span> <span class="kt">FOL</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Thm</span>
<span class="nf">axiomOr</span> <span class="n">p</span> <span class="n">q</span> <span class="ow">=</span> <span class="kt">Iff</span> <span class="p">(</span><span class="kt">Or</span> <span class="n">p</span> <span class="n">q</span><span class="p">)</span> <span class="p">(</span><span class="kt">Not</span> <span class="p">(</span><span class="kt">And</span> <span class="p">(</span><span class="kt">Not</span> <span class="n">p</span><span class="p">)</span> <span class="p">(</span><span class="kt">Not</span> <span class="n">q</span><span class="p">)))</span>

<span class="c1">-- |- (exists x. p) &lt;=&gt; ~(forall x. ~p)</span>
<span class="nf">axiomExists</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Formula</span> <span class="kt">FOL</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Thm</span>
<span class="nf">axiomExists</span> <span class="n">x</span> <span class="n">p</span> <span class="ow">=</span> <span class="kt">Iff</span> <span class="p">(</span><span class="kt">Exists</span> <span class="n">x</span> <span class="n">p</span><span class="p">)</span> <span class="p">(</span><span class="kt">Not</span> <span class="p">(</span><span class="kt">Forall</span> <span class="n">x</span> <span class="p">(</span><span class="kt">Not</span> <span class="n">p</span><span class="p">)))</span>

<span class="nf">concl</span> <span class="ow">::</span> <span class="kt">Thm</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Formula</span> <span class="kt">FOL</span><span class="p">)</span>
<span class="nf">concl</span> <span class="n">c</span> <span class="ow">=</span> <span class="n">c</span>


<span class="c1">-- ZFC</span>

<span class="nf">mkElem</span> <span class="ow">::</span> <span class="kt">Term</span> <span class="ow">-&gt;</span> <span class="kt">Term</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Formula</span> <span class="kt">FOL</span><span class="p">)</span>
<span class="nf">mkElem</span> <span class="n">s</span> <span class="n">t</span> <span class="ow">=</span> <span class="kt">Atom</span> <span class="p">(</span><span class="kt">Pred</span> <span class="s">"in"</span> <span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">])</span>

<span class="c1">-- |- forall x. forall y. forall z. (z \in x &lt;==&gt; z \in y) =&gt; (x = y)</span>
<span class="nf">axiomExtensionality</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Thm</span>
<span class="nf">axiomExtensionality</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="ow">=</span> <span class="kt">Imp</span> <span class="p">(</span><span class="kt">Forall</span> <span class="n">x</span> <span class="p">(</span><span class="kt">Forall</span> <span class="n">y</span> <span class="p">(</span><span class="kt">Forall</span> <span class="n">z</span> <span class="p">(</span><span class="kt">Iff</span> <span class="p">(</span><span class="n">mkElem</span> <span class="p">(</span><span class="kt">Var</span> <span class="n">z</span><span class="p">)</span> <span class="p">(</span><span class="kt">Func</span> <span class="n">x</span> <span class="kt">[]</span><span class="p">))</span> <span class="p">(</span><span class="n">mkElem</span> <span class="p">(</span><span class="kt">Var</span> <span class="n">z</span><span class="p">)</span> <span class="p">(</span><span class="kt">Func</span> <span class="n">y</span> <span class="kt">[]</span><span class="p">))))))</span> <span class="p">(</span><span class="n">mkEq</span> <span class="p">(</span><span class="kt">Var</span> <span class="n">x</span><span class="p">)</span> <span class="p">(</span><span class="kt">Var</span> <span class="n">y</span><span class="p">))</span>


<span class="c1">-- Derived</span>

<span class="nf">impRefl</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Formula</span> <span class="kt">FOL</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Thm</span>
<span class="nf">impRefl</span> <span class="n">p</span> <span class="ow">=</span> <span class="n">modusPonens</span> <span class="p">(</span><span class="n">modusPonens</span> <span class="p">(</span><span class="n">axiomDistribImp</span> <span class="n">p</span> <span class="p">(</span><span class="kt">Imp</span> <span class="n">p</span> <span class="n">p</span><span class="p">)</span> <span class="n">p</span><span class="p">)</span> <span class="p">(</span><span class="n">axiomAddImp</span> <span class="n">p</span> <span class="p">(</span><span class="kt">Imp</span> <span class="n">p</span> <span class="n">p</span><span class="p">)))</span> <span class="p">(</span><span class="n">axiomAddImp</span> <span class="n">p</span> <span class="n">p</span><span class="p">)</span>


<span class="c1">-- Example: *Main&gt; impRefl (Atom (Pred "P" []))</span>
</code></pre></div>



<a name="266649962"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/266649962" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Huỳnh Trần Khanh <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#266649962">(Jan 03 2022 at 04:07)</a>:</h4>
<p>man this code is so cool!!! it's very clean and readable <span aria-label="heart eyes" class="emoji emoji-1f60d" role="img" title="heart eyes">:heart_eyes:</span> I have a suggestion though: you don't need to use String to represent bound variables <span aria-label="joy" class="emoji emoji-1f602" role="img" title="joy">:joy:</span> in fact you can use something similar to <a href="https://en.m.wikipedia.org/wiki/De_Bruijn_index">de Bruijn indexing</a>. this would simplify the implementation even more</p>



<a name="266650130"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/266650130" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#266650130">(Jan 03 2022 at 04:10)</a>:</h4>
<p>Thank you. It is pretty much just a direct translation from the book (I hope).</p>



<a name="266712277"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/266712277" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#266712277">(Jan 03 2022 at 17:24)</a>:</h4>
<p>It seems that FOL and set theory define different notions of predicates and functions, the latter being in terms of subsets of sets. How are these reconciled in FOL + ZFC?</p>



<a name="266716028"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/266716028" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#266716028">(Jan 03 2022 at 17:52)</a>:</h4>
<p>Well, these exist on different levels: a FOL predicate is a piece of syntax, while a subset in ZFC is something internal. So I'm not sure in what sense they could or should be reconciled. Of course they are related by some axioms, such as the axiom schema of separation.</p>



<a name="266716131"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/266716131" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#266716131">(Jan 03 2022 at 17:53)</a>:</h4>
<p>Note that in the context of ZFC, a "class" is really just a FOL predicate with one free variable.</p>



<a name="266716794"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/266716794" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#266716794">(Jan 03 2022 at 17:59)</a>:</h4>
<p>I guess my core question is, how can I create code in a similar manner as above, but for proving theorems in ZFC (or the set theory most often used in textbooks, I think it is ZFC?)</p>



<a name="266718018"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/266718018" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Johnson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#266718018">(Jan 03 2022 at 18:09)</a>:</h4>
<p>Maybe you can find <a href="https://github.com/flypitch/flypitch/blob/master/src/zfc.lean">this</a> helpful. It has been used to prove the independence of the continuum hypothesis.</p>



<a name="266718457"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/266718457" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#266718457">(Jan 03 2022 at 18:11)</a>:</h4>
<p><span class="user-mention silent" data-user-id="139442">Patrick Thomas</span> <a href="#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/266716794">said</a>:</p>
<blockquote>
<p>I guess my core question is, how can I create code in a similar manner as above, but for proving theorems in ZFC (or the set theory most often used in textbooks, I think it is ZFC?)</p>
</blockquote>
<p>In principle you just add the axioms of ZFC, and then the theorems you can prove from those axioms are the theorems of ZFC.<br>
In practice, I guess you would pretty quickly learn the origin of the phrase "proof assistant".</p>



<a name="266720348"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/266720348" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Huỳnh Trần Khanh <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#266720348">(Jan 03 2022 at 18:28)</a>:</h4>
<p>you might want to take a look <a href="https://github.com/been-jamming/CORE">https://github.com/been-jamming/CORE</a> <a href="http://been-jamming.github.io/CORE/">been-jamming.github.io/CORE/</a></p>
<p>fair warning: code isn't production quality though</p>



<a name="266720469"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/266720469" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#266720469">(Jan 03 2022 at 18:29)</a>:</h4>
<p>How does the axiom of replacement get translated, since we do not have quantification over formulas in FOL?</p>



<a name="266721072"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/266721072" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Huỳnh Trần Khanh <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#266721072">(Jan 03 2022 at 18:35)</a>:</h4>
<p><span class="user-mention silent" data-user-id="139442">Patrick Thomas</span> <a href="#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/266720469">said</a>:</p>
<blockquote>
<p>How does the axiom of replacement get translated, since we do not have quantification over formulas in FOL?</p>
</blockquote>
<p>in CORE, a toy theorem prover I linked, it does allow quantification over formulas <span aria-label="joy" class="emoji emoji-1f602" role="img" title="joy">:joy:</span> so maybe if you want a ZFC theorem prover that works you can just do whatever CORE does <span aria-label="joy" class="emoji emoji-1f602" role="img" title="joy">:joy:</span> but I'm not an expert so I'm not sure whether that's an orthodox way of doing things or not</p>



<a name="266721362"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/266721362" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#266721362">(Jan 03 2022 at 18:38)</a>:</h4>
<p>Same way you implemented the rest of the axioms, which (like replacement) are actually axiom schemas--the quantification is at the meta level, not internal.</p>



<a name="266721527"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/266721527" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#266721527">(Jan 03 2022 at 18:40)</a>:</h4>
<p>Does the grammar get changed to this:</p>
<div class="codehilite" data-code-language="Haskell"><pre><span></span><code><span class="kr">type</span> <span class="kt">Var</span> <span class="ow">=</span> <span class="kt">String</span>

<span class="kr">data</span> <span class="kt">Formula</span> <span class="ow">=</span> <span class="kt">False</span>
             <span class="o">|</span> <span class="kt">True</span>
             <span class="o">|</span> <span class="kt">Eq</span> <span class="kt">Var</span> <span class="kt">Var</span>
             <span class="o">|</span> <span class="kt">In</span> <span class="kt">Var</span> <span class="kt">Var</span>
             <span class="o">|</span> <span class="kt">Not</span> <span class="kt">Formula</span>
             <span class="o">|</span> <span class="kt">And</span> <span class="kt">Formula</span> <span class="kt">Formula</span>
             <span class="o">|</span> <span class="kt">Or</span> <span class="kt">Formula</span> <span class="kt">Formula</span>
             <span class="o">|</span> <span class="kt">Imp</span> <span class="kt">Formula</span> <span class="kt">Formula</span>
             <span class="o">|</span> <span class="kt">Iff</span> <span class="kt">Formula</span> <span class="kt">Formula</span>
             <span class="o">|</span> <span class="kt">Forall</span> <span class="kt">Var</span> <span class="kt">Formula</span>
             <span class="o">|</span> <span class="kt">Exists</span> <span class="kt">Var</span> <span class="kt">Formula</span>
               <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">)</span>

<span class="kr">type</span> <span class="kt">Thm</span> <span class="ow">=</span> <span class="kt">Formula</span>
</code></pre></div>



<a name="266721790"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/266721790" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#266721790">(Jan 03 2022 at 18:43)</a>:</h4>
<p>Oh yes, you need to add the signature of the theory (here just the binary relation <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∈</mo></mrow><annotation encoding="application/x-tex">\in</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">∈</span></span></span></span>) to the language, and then maybe add axioms saying that it is preserved by replacing things by equal things?<br>
I didn't notice before that the statement of <code>axiomExtensionality</code> was nonsense, it needs to be an axiom about <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∈</mo></mrow><annotation encoding="application/x-tex">\in</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">∈</span></span></span></span>, of course!</p>



<a name="266721978"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/266721978" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#266721978">(Jan 03 2022 at 18:45)</a>:</h4>
<p>I think it looks right now--since there aren't any function symbols, a "term" can only possibly be a variable.</p>



<a name="266722052"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/266722052" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#266722052">(Jan 03 2022 at 18:46)</a>:</h4>
<div class="codehilite" data-code-language="Haskell"><pre><span></span><code><span class="kr">type</span> <span class="kt">Thm</span> <span class="ow">=</span> <span class="kt">Formula</span>
</code></pre></div>
<p>Normally one would use something more robust than a type synonym to dissuade the user from treating an arbitrary formula as a theorem.</p>



<a name="266722225"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/266722225" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#266722225">(Jan 03 2022 at 18:48)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/266722052">said</a>:</p>
<blockquote>
<div class="codehilite" data-code-language="Haskell"><pre><span></span><code><span class="kr">type</span> <span class="kt">Thm</span> <span class="ow">=</span> <span class="kt">Formula</span>
</code></pre></div>
<p>Normally one would use something more robust than a type synonym to dissuade the user from treating an arbitrary formula as a theorem.</p>
</blockquote>
<p>Yeah, I'm not sure how to do that in Haskell yet.</p>



<a name="266722294"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/266722294" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Huỳnh Trần Khanh <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#266722294">(Jan 03 2022 at 18:48)</a>:</h4>
<p>you probably want a newtype, not just a type alias</p>



<a name="266722658"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/266722658" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#266722658">(Jan 03 2022 at 18:51)</a>:</h4>
<p>The usual way is to put everything that can construct judgments (like <code>Thm</code>) in a single module, make <code>Thm</code> a newtype, export <code>Thm</code> and the field selector from that module, but don't export the constructor of <code>Thm</code>.</p>



<a name="266722732"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/266722732" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#266722732">(Jan 03 2022 at 18:52)</a>:</h4>
<p>I see.</p>



<a name="266723253"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/266723253" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#266723253">(Jan 03 2022 at 18:56)</a>:</h4>
<p>Then you have a guarantee that (barring the use of stuff like <code>unsafeCoerce</code>) the only way to construct values of type <code>Thm</code> is using the methods exported from that module, and so once you check that they really correspond to the axioms of whatever system you're interested in, then you know that any <code>t :: Thm</code> constructed anywhere in the program must be a valid theorem. This is the "LCF approach" as I understand it.</p>



<a name="266723522"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/266723522" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#266723522">(Jan 03 2022 at 18:58)</a>:</h4>
<p>Something like this?</p>
<div class="codehilite" data-code-language="Haskell"><pre><span></span><code><span class="kr">import</span> <span class="nn">Prelude</span> <span class="k">hiding</span> <span class="p">(</span><span class="kt">False</span><span class="p">,</span> <span class="kt">True</span><span class="p">)</span>
<span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Prelude</span> <span class="p">(</span><span class="kt">Bool</span><span class="p">(</span><span class="o">..</span><span class="p">))</span>

<span class="kr">module</span> <span class="nn">ITP</span> <span class="p">(</span><span class="kt">Theorem</span><span class="p">,</span> <span class="nf">modusPonens</span><span class="p">,</span> <span class="nf">etc</span><span class="o">.</span><span class="p">)</span>

<span class="kr">type</span> <span class="kt">Var</span> <span class="ow">=</span> <span class="kt">String</span>

<span class="kr">data</span> <span class="kt">Formula</span> <span class="ow">=</span> <span class="kt">False</span>
             <span class="o">|</span> <span class="kt">True</span>
             <span class="o">|</span> <span class="kt">Eq</span> <span class="kt">Var</span> <span class="kt">Var</span> <span class="c1">-- Var = Var</span>
             <span class="o">|</span> <span class="kt">In</span> <span class="kt">Var</span> <span class="kt">Var</span> <span class="c1">-- Var ∈ Var</span>
             <span class="o">|</span> <span class="kt">Not</span> <span class="kt">Formula</span> <span class="c1">-- ¬ Formula</span>
             <span class="o">|</span> <span class="kt">And</span> <span class="kt">Formula</span> <span class="kt">Formula</span> <span class="c1">-- Formula ∧ Formula</span>
             <span class="o">|</span> <span class="kt">Or</span> <span class="kt">Formula</span> <span class="kt">Formula</span> <span class="c1">-- Formula ∨ Formula</span>
             <span class="o">|</span> <span class="kt">Imp</span> <span class="kt">Formula</span> <span class="kt">Formula</span> <span class="c1">-- Formula → Formula</span>
             <span class="o">|</span> <span class="kt">Iff</span> <span class="kt">Formula</span> <span class="kt">Formula</span> <span class="c1">-- Formula ↔ Formula</span>
             <span class="o">|</span> <span class="kt">Forall</span> <span class="kt">Var</span> <span class="kt">Formula</span> <span class="c1">-- ∀ Var. Formula</span>
             <span class="o">|</span> <span class="kt">Exists</span> <span class="kt">Var</span> <span class="kt">Formula</span> <span class="c1">-- ∃ Var. Formula</span>
               <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">)</span>

<span class="kr">newtype</span> <span class="kt">Theorem</span> <span class="ow">=</span> <span class="kt">Theorem</span> <span class="kt">Formula</span>
</code></pre></div>



<a name="266723716"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/266723716" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#266723716">(Jan 03 2022 at 19:00)</a>:</h4>
<p>Right, except you probably also want to export a function <code>Theorem -&gt; Formula</code>, so that you can check what you proved</p>



<a name="266723836"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/266723836" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#266723836">(Jan 03 2022 at 19:00)</a>:</h4>
<p>And you want to export <code>Formula(..)</code> too</p>



<a name="266723862"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/266723862" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#266723862">(Jan 03 2022 at 19:00)</a>:</h4>
<p>You will need it to apply axiom schemas</p>



<a name="266723915"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/266723915" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#266723915">(Jan 03 2022 at 19:01)</a>:</h4>
<p>Of course for the moment there's no need to worry about any of this.</p>



<a name="266724064"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/266724064" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#266724064">(Jan 03 2022 at 19:02)</a>:</h4>
<p>Ok.</p>



<a name="266846177"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/266846177" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#266846177">(Jan 04 2022 at 18:34)</a>:</h4>
<p>I looked at the way that metamath implements the axiom schemes. I'm not sure I understand why the set variables are required to be distinct.<br>
<a href="http://cn.metamath.org/mpeuni/mmset.html#staxioms">http://cn.metamath.org/mpeuni/mmset.html#staxioms</a></p>



<a name="266846719"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/266846719" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#266846719">(Jan 04 2022 at 18:39)</a>:</h4>
<p>In order for metamath expressions to act like standard FOL expressions, you usually want all textually distinct variables to have distinctness conditions, because otherwise you get bound variable collapse issues when <code>\forall x, \exists y, P(x, y)</code> becomes <code>\forall x, \exists x, P(x, x)</code> (which is equivalent to <code>\forall x, \exists y, P(y, y)</code>)</p>



<a name="266846831"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/266846831" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#266846831">(Jan 04 2022 at 18:40)</a>:</h4>
<p>In some cases the distinctness is not required, but the safest thing is to assume it in the axioms and maybe prove the non-distinct version as a derived theorem</p>



<a name="266846954"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/266846954" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#266846954">(Jan 04 2022 at 18:41)</a>:</h4>
<p>Note that this is not distinctness in the sense that the set values are unequal (what you would write <code>x != y</code> in ZFC or lean), but rather that the <em>variables</em> are not the same variable</p>



<a name="266855326"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/266855326" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#266855326">(Jan 04 2022 at 19:58)</a>:</h4>
<p>I see. Thank you.</p>



<a name="266874460"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/266874460" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#266874460">(Jan 04 2022 at 22:41)</a>:</h4>
<p>Can the lambda calculus be formulated in such a way that the Curry–Howard correspondence has the same first order logic as that used with axiomatic set theory, that is, no functions and just the equality and member of predicates?</p>



<a name="266895878"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/266895878" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#266895878">(Jan 05 2022 at 04:08)</a>:</h4>
<p>Is this correct for the logic of ZFC?</p>
<div class="codehilite" data-code-language="Haskell"><pre><span></span><code><span class="kr">type</span> <span class="kt">Var</span> <span class="ow">=</span> <span class="kt">String</span>

<span class="kr">data</span> <span class="kt">Formula</span> <span class="ow">=</span> <span class="kt">Not</span> <span class="kt">Formula</span> <span class="c1">-- ~ Formula</span>
             <span class="o">|</span> <span class="kt">Imp</span> <span class="kt">Formula</span> <span class="kt">Formula</span> <span class="c1">-- Formula -&gt; Formula</span>
             <span class="o">|</span> <span class="kt">Forall</span> <span class="kt">Var</span> <span class="kt">Formula</span> <span class="c1">-- forall Var. Formula</span>
             <span class="o">|</span> <span class="kt">Eq</span> <span class="kt">Var</span> <span class="kt">Var</span> <span class="c1">-- Var = Var</span>
             <span class="o">|</span> <span class="kt">In</span> <span class="kt">Var</span> <span class="kt">Var</span> <span class="c1">-- Var \in Var</span>
               <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">)</span>

<span class="kr">newtype</span> <span class="kt">Theorem</span> <span class="ow">=</span> <span class="kt">Theorem</span> <span class="kt">Formula</span>


<span class="nf">subFor</span> <span class="ow">::</span> <span class="kt">Var</span> <span class="ow">-&gt;</span> <span class="kt">Var</span> <span class="ow">-&gt;</span> <span class="kt">Formula</span> <span class="ow">-&gt;</span> <span class="kt">Formula</span>
<span class="nf">subFor</span> <span class="n">y</span> <span class="n">x</span> <span class="p">(</span><span class="kt">Not</span> <span class="n">p</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Not</span> <span class="p">(</span><span class="n">subFor</span> <span class="n">y</span> <span class="n">x</span> <span class="n">p</span><span class="p">)</span>
<span class="nf">subFor</span> <span class="n">y</span> <span class="n">x</span> <span class="p">(</span><span class="kt">Imp</span> <span class="n">p</span> <span class="n">q</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Imp</span> <span class="p">(</span><span class="n">subFor</span> <span class="n">y</span> <span class="n">x</span> <span class="n">p</span><span class="p">)</span> <span class="p">(</span><span class="n">subFor</span> <span class="n">y</span> <span class="n">x</span> <span class="n">q</span><span class="p">)</span>
<span class="nf">subFor</span> <span class="n">y</span> <span class="n">x</span> <span class="p">(</span><span class="kt">Forall</span> <span class="n">z</span> <span class="n">p</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">if</span> <span class="n">z</span> <span class="o">/=</span> <span class="n">x</span> <span class="o">&amp;&amp;</span> <span class="n">z</span> <span class="o">/=</span> <span class="n">y</span> <span class="kr">then</span> <span class="kt">Forall</span> <span class="n">z</span> <span class="p">(</span><span class="n">subFor</span> <span class="n">y</span> <span class="n">x</span> <span class="n">p</span><span class="p">)</span> <span class="kr">else</span> <span class="ne">error</span> <span class="s">"subFor"</span>
<span class="nf">subFor</span> <span class="n">y</span> <span class="n">x</span> <span class="p">(</span><span class="kt">Eq</span> <span class="n">s</span> <span class="n">t</span><span class="p">)</span> <span class="o">|</span> <span class="n">x</span> <span class="o">/=</span> <span class="n">s</span> <span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="o">/=</span> <span class="n">t</span> <span class="ow">=</span> <span class="kt">Eq</span> <span class="n">s</span> <span class="n">t</span>
                    <span class="o">|</span> <span class="n">x</span> <span class="o">==</span> <span class="n">s</span> <span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="o">/=</span> <span class="n">t</span> <span class="ow">=</span> <span class="kt">Eq</span> <span class="n">y</span> <span class="n">t</span>
                    <span class="o">|</span> <span class="n">x</span> <span class="o">/=</span> <span class="n">s</span> <span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="o">==</span> <span class="n">t</span> <span class="ow">=</span> <span class="kt">Eq</span> <span class="n">s</span> <span class="n">y</span>
                    <span class="o">|</span> <span class="n">otherwise</span> <span class="ow">=</span> <span class="kt">Eq</span> <span class="n">y</span> <span class="n">y</span>
<span class="nf">subFor</span> <span class="n">y</span> <span class="n">x</span> <span class="p">(</span><span class="kt">In</span> <span class="n">s</span> <span class="n">t</span><span class="p">)</span> <span class="o">|</span> <span class="n">x</span> <span class="o">/=</span> <span class="n">s</span> <span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="o">/=</span> <span class="n">t</span> <span class="ow">=</span> <span class="kt">In</span> <span class="n">s</span> <span class="n">t</span>
                    <span class="o">|</span> <span class="n">x</span> <span class="o">==</span> <span class="n">s</span> <span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="o">/=</span> <span class="n">t</span> <span class="ow">=</span> <span class="kt">In</span> <span class="n">y</span> <span class="n">t</span>
                    <span class="o">|</span> <span class="n">x</span> <span class="o">/=</span> <span class="n">s</span> <span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="o">==</span> <span class="n">t</span> <span class="ow">=</span> <span class="kt">In</span> <span class="n">s</span> <span class="n">y</span>
                    <span class="o">|</span> <span class="n">otherwise</span> <span class="ow">=</span> <span class="kt">In</span> <span class="n">y</span> <span class="n">y</span>


<span class="nf">freeIn</span> <span class="ow">::</span> <span class="kt">Var</span> <span class="ow">-&gt;</span> <span class="kt">Formula</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">freeIn</span> <span class="n">x</span> <span class="p">(</span><span class="kt">Not</span> <span class="n">p</span><span class="p">)</span> <span class="ow">=</span> <span class="n">freeIn</span> <span class="n">x</span> <span class="n">p</span>
<span class="nf">freeIn</span> <span class="n">x</span> <span class="p">(</span><span class="kt">Imp</span> <span class="n">p</span> <span class="n">q</span><span class="p">)</span> <span class="ow">=</span> <span class="n">freeIn</span> <span class="n">x</span> <span class="n">p</span> <span class="o">||</span> <span class="n">freeIn</span> <span class="n">x</span> <span class="n">q</span>
<span class="nf">freeIn</span> <span class="n">x</span> <span class="p">(</span><span class="kt">Forall</span> <span class="n">y</span> <span class="n">p</span><span class="p">)</span> <span class="ow">=</span> <span class="n">x</span> <span class="o">/=</span> <span class="n">y</span> <span class="o">&amp;&amp;</span> <span class="n">freeIn</span> <span class="n">x</span> <span class="n">p</span>
<span class="nf">freeIn</span> <span class="n">x</span> <span class="p">(</span><span class="kt">Eq</span> <span class="n">s</span> <span class="n">t</span><span class="p">)</span> <span class="ow">=</span> <span class="n">x</span> <span class="o">==</span> <span class="n">s</span> <span class="o">||</span> <span class="n">x</span> <span class="o">==</span> <span class="n">t</span>
<span class="nf">freeIn</span> <span class="n">x</span> <span class="p">(</span><span class="kt">In</span> <span class="n">s</span> <span class="n">t</span><span class="p">)</span> <span class="ow">=</span> <span class="n">x</span> <span class="o">==</span> <span class="n">s</span> <span class="o">||</span> <span class="n">x</span> <span class="o">==</span> <span class="n">t</span>


<span class="c1">-- Propositional calculus</span>

<span class="c1">-- |- (p -&gt; (q -&gt; p))</span>
<span class="nf">prop_1</span> <span class="ow">::</span> <span class="kt">Formula</span> <span class="ow">-&gt;</span> <span class="kt">Formula</span> <span class="ow">-&gt;</span> <span class="kt">Theorem</span>
<span class="nf">prop_1</span> <span class="n">p</span> <span class="n">q</span> <span class="ow">=</span> <span class="kt">Theorem</span> <span class="p">(</span><span class="kt">Imp</span> <span class="n">p</span> <span class="p">(</span><span class="kt">Imp</span> <span class="n">q</span> <span class="n">p</span><span class="p">))</span>

<span class="c1">-- |- ((p -&gt; (q -&gt; r)) -&gt; ((p -&gt; q) -&gt; (p -&gt; r)))</span>
<span class="nf">prop_2</span> <span class="ow">::</span> <span class="kt">Formula</span> <span class="ow">-&gt;</span> <span class="kt">Formula</span> <span class="ow">-&gt;</span> <span class="kt">Formula</span> <span class="ow">-&gt;</span> <span class="kt">Theorem</span>
<span class="nf">prop_2</span> <span class="n">p</span> <span class="n">q</span> <span class="n">r</span> <span class="ow">=</span> <span class="kt">Theorem</span> <span class="p">(</span><span class="kt">Imp</span> <span class="p">(</span><span class="kt">Imp</span> <span class="n">p</span> <span class="p">(</span><span class="kt">Imp</span> <span class="n">q</span> <span class="n">r</span><span class="p">))</span> <span class="p">(</span><span class="kt">Imp</span> <span class="p">(</span><span class="kt">Imp</span> <span class="n">p</span> <span class="n">q</span><span class="p">)</span> <span class="p">(</span><span class="kt">Imp</span> <span class="n">p</span> <span class="n">r</span><span class="p">)))</span>

<span class="c1">-- |- ((~p -&gt; ~q) -&gt; (q -&gt; p))</span>
<span class="nf">prop_3</span> <span class="ow">::</span> <span class="kt">Formula</span> <span class="ow">-&gt;</span> <span class="kt">Formula</span> <span class="ow">-&gt;</span> <span class="kt">Theorem</span>
<span class="nf">prop_3</span> <span class="n">p</span> <span class="n">q</span> <span class="ow">=</span> <span class="kt">Theorem</span> <span class="p">(</span><span class="kt">Imp</span> <span class="p">(</span><span class="kt">Imp</span> <span class="p">(</span><span class="kt">Not</span> <span class="n">p</span><span class="p">)</span> <span class="p">(</span><span class="kt">Not</span> <span class="n">q</span><span class="p">))</span> <span class="p">(</span><span class="kt">Imp</span> <span class="n">q</span> <span class="n">p</span><span class="p">))</span>

<span class="c1">-- |- p &amp; |- (p -&gt; q) =&gt; |- q</span>
<span class="nf">mp</span> <span class="ow">::</span> <span class="kt">Theorem</span> <span class="ow">-&gt;</span> <span class="kt">Theorem</span> <span class="ow">-&gt;</span> <span class="kt">Theorem</span>
<span class="nf">mp</span> <span class="p">(</span><span class="kt">Theorem</span> <span class="n">p</span><span class="p">)</span> <span class="p">(</span><span class="kt">Theorem</span> <span class="p">(</span><span class="kt">Imp</span> <span class="n">p'</span> <span class="n">q</span><span class="p">))</span> <span class="ow">=</span> <span class="kr">if</span> <span class="n">p</span> <span class="o">==</span> <span class="n">p'</span> <span class="kr">then</span> <span class="kt">Theorem</span> <span class="n">q</span> <span class="kr">else</span> <span class="ne">error</span> <span class="s">"mp"</span>
<span class="nf">mp</span> <span class="kr">_</span> <span class="kr">_</span> <span class="ow">=</span> <span class="ne">error</span> <span class="s">"mp"</span>


<span class="c1">-- Predicate calculus</span>

<span class="c1">-- |- p =&gt; |- forall x. p</span>
<span class="nf">gen</span> <span class="ow">::</span> <span class="kt">Theorem</span> <span class="ow">-&gt;</span> <span class="kt">Var</span> <span class="ow">-&gt;</span> <span class="kt">Theorem</span>
<span class="nf">gen</span> <span class="p">(</span><span class="kt">Theorem</span> <span class="n">p</span><span class="p">)</span> <span class="n">x</span> <span class="ow">=</span> <span class="kt">Theorem</span> <span class="p">(</span><span class="kt">Forall</span> <span class="n">x</span> <span class="n">p</span><span class="p">)</span>

<span class="c1">-- |- ((forall x. (p -&gt; q)) -&gt; (forall x. p) -&gt; (forall x. q))</span>
<span class="nf">pred_1</span> <span class="ow">::</span> <span class="kt">Var</span> <span class="ow">-&gt;</span> <span class="kt">Formula</span> <span class="ow">-&gt;</span> <span class="kt">Formula</span> <span class="ow">-&gt;</span> <span class="kt">Theorem</span>
<span class="nf">pred_1</span> <span class="n">x</span> <span class="n">p</span> <span class="n">q</span> <span class="ow">=</span> <span class="kt">Theorem</span> <span class="p">(</span><span class="kt">Imp</span> <span class="p">(</span><span class="kt">Forall</span> <span class="n">x</span> <span class="p">(</span><span class="kt">Imp</span> <span class="n">p</span> <span class="n">q</span><span class="p">))</span> <span class="p">(</span><span class="kt">Imp</span> <span class="p">(</span><span class="kt">Forall</span> <span class="n">x</span> <span class="n">p</span><span class="p">)</span> <span class="p">(</span><span class="kt">Forall</span> <span class="n">x</span> <span class="n">q</span><span class="p">)))</span>

<span class="c1">-- |- (forall x. p -&gt; p [y/x]) provided p admits y for x</span>
<span class="nf">pred_2</span> <span class="ow">::</span> <span class="kt">Var</span> <span class="ow">-&gt;</span> <span class="kt">Var</span> <span class="ow">-&gt;</span> <span class="kt">Formula</span> <span class="ow">-&gt;</span> <span class="kt">Theorem</span>
<span class="nf">pred_2</span> <span class="n">x</span> <span class="n">y</span> <span class="n">p</span> <span class="ow">=</span> <span class="kt">Theorem</span> <span class="p">(</span><span class="kt">Imp</span> <span class="p">(</span><span class="kt">Forall</span> <span class="n">x</span> <span class="n">p</span><span class="p">)</span> <span class="p">(</span><span class="n">subFor</span> <span class="n">y</span> <span class="n">x</span> <span class="n">p</span><span class="p">))</span>

<span class="c1">-- |- (p -&gt; forall x. p) provided x is not free in p</span>
<span class="nf">pred_3</span> <span class="ow">::</span> <span class="kt">Var</span> <span class="ow">-&gt;</span> <span class="kt">Formula</span> <span class="ow">-&gt;</span> <span class="kt">Theorem</span>
<span class="nf">pred_3</span> <span class="n">x</span> <span class="n">p</span> <span class="ow">=</span> <span class="kr">if</span> <span class="n">not</span> <span class="p">(</span><span class="n">freeIn</span> <span class="n">x</span> <span class="n">p</span><span class="p">)</span> <span class="kr">then</span> <span class="kt">Theorem</span> <span class="p">(</span><span class="kt">Imp</span> <span class="n">p</span> <span class="p">(</span><span class="kt">Forall</span> <span class="n">x</span> <span class="n">p</span><span class="p">))</span> <span class="kr">else</span> <span class="ne">error</span> <span class="s">"pred_3"</span>


<span class="c1">-- Equality</span>

<span class="c1">-- |- forall x. x = x</span>
<span class="nf">eq_1</span> <span class="ow">::</span> <span class="kt">Var</span> <span class="ow">-&gt;</span> <span class="kt">Theorem</span>
<span class="nf">eq_1</span> <span class="n">x</span> <span class="ow">=</span> <span class="kt">Theorem</span> <span class="p">(</span><span class="kt">Forall</span> <span class="n">x</span> <span class="p">(</span><span class="kt">Eq</span> <span class="n">x</span> <span class="n">x</span><span class="p">))</span>

<span class="c1">-- |- (x = y -&gt; (x = z -&gt; y = z))</span>
<span class="nf">eq_2</span> <span class="ow">::</span> <span class="kt">Var</span> <span class="ow">-&gt;</span> <span class="kt">Var</span> <span class="ow">-&gt;</span> <span class="kt">Var</span> <span class="ow">-&gt;</span> <span class="kt">Theorem</span>
<span class="nf">eq_2</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="ow">=</span> <span class="kt">Theorem</span> <span class="p">(</span><span class="kt">Imp</span> <span class="p">(</span><span class="kt">Eq</span> <span class="n">x</span> <span class="n">y</span><span class="p">)</span> <span class="p">(</span><span class="kt">Imp</span> <span class="p">(</span><span class="kt">Eq</span> <span class="n">x</span> <span class="n">z</span><span class="p">)</span> <span class="p">(</span><span class="kt">Eq</span> <span class="n">y</span> <span class="n">z</span><span class="p">)))</span>

<span class="c1">-- |- (x = y -&gt; (x \in z -&gt; y \in z))</span>
<span class="nf">eq_3</span> <span class="ow">::</span> <span class="kt">Var</span> <span class="ow">-&gt;</span> <span class="kt">Var</span> <span class="ow">-&gt;</span> <span class="kt">Var</span> <span class="ow">-&gt;</span> <span class="kt">Theorem</span>
<span class="nf">eq_3</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="ow">=</span> <span class="kt">Theorem</span> <span class="p">(</span><span class="kt">Imp</span> <span class="p">(</span><span class="kt">Eq</span> <span class="n">x</span> <span class="n">y</span><span class="p">)</span> <span class="p">(</span><span class="kt">Imp</span> <span class="p">(</span><span class="kt">In</span> <span class="n">x</span> <span class="n">z</span><span class="p">)</span> <span class="p">(</span><span class="kt">In</span> <span class="n">y</span> <span class="n">z</span><span class="p">)))</span>

<span class="c1">-- |- (x = y -&gt; (z \in x -&gt; z \in y))</span>
<span class="nf">eq_4</span> <span class="ow">::</span> <span class="kt">Var</span> <span class="ow">-&gt;</span> <span class="kt">Var</span> <span class="ow">-&gt;</span> <span class="kt">Var</span> <span class="ow">-&gt;</span> <span class="kt">Theorem</span>
<span class="nf">eq_4</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="ow">=</span> <span class="kt">Theorem</span> <span class="p">(</span><span class="kt">Imp</span> <span class="p">(</span><span class="kt">Eq</span> <span class="n">x</span> <span class="n">y</span><span class="p">)</span> <span class="p">(</span><span class="kt">Imp</span> <span class="p">(</span><span class="kt">In</span> <span class="n">z</span> <span class="n">x</span><span class="p">)</span> <span class="p">(</span><span class="kt">In</span> <span class="n">z</span> <span class="n">y</span><span class="p">)))</span>
</code></pre></div>



<a name="266895978"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/266895978" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#266895978">(Jan 05 2022 at 04:10)</a>:</h4>
<p>No, wait, I think the subFor function is wrong.</p>



<a name="266896146"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/266896146" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#266896146">(Jan 05 2022 at 04:14)</a>:</h4>
<p>Amended (I think).</p>
<div class="codehilite" data-code-language="Haskell"><pre><span></span><code><span class="kr">type</span> <span class="kt">Var</span> <span class="ow">=</span> <span class="kt">String</span>

<span class="kr">data</span> <span class="kt">Formula</span> <span class="ow">=</span> <span class="kt">Not</span> <span class="kt">Formula</span> <span class="c1">-- ~ Formula</span>
             <span class="o">|</span> <span class="kt">Imp</span> <span class="kt">Formula</span> <span class="kt">Formula</span> <span class="c1">-- Formula -&gt; Formula</span>
             <span class="o">|</span> <span class="kt">Forall</span> <span class="kt">Var</span> <span class="kt">Formula</span> <span class="c1">-- forall Var. Formula</span>
             <span class="o">|</span> <span class="kt">Eq</span> <span class="kt">Var</span> <span class="kt">Var</span> <span class="c1">-- Var = Var</span>
             <span class="o">|</span> <span class="kt">In</span> <span class="kt">Var</span> <span class="kt">Var</span> <span class="c1">-- Var \in Var</span>
               <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">)</span>

<span class="kr">newtype</span> <span class="kt">Theorem</span> <span class="ow">=</span> <span class="kt">Theorem</span> <span class="kt">Formula</span>


<span class="nf">subFor</span> <span class="ow">::</span> <span class="kt">Var</span> <span class="ow">-&gt;</span> <span class="kt">Var</span> <span class="ow">-&gt;</span> <span class="kt">Formula</span> <span class="ow">-&gt;</span> <span class="kt">Formula</span>
<span class="nf">subFor</span> <span class="n">y</span> <span class="n">x</span> <span class="p">(</span><span class="kt">Not</span> <span class="n">p</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Not</span> <span class="p">(</span><span class="n">subFor</span> <span class="n">y</span> <span class="n">x</span> <span class="n">p</span><span class="p">)</span>
<span class="nf">subFor</span> <span class="n">y</span> <span class="n">x</span> <span class="p">(</span><span class="kt">Imp</span> <span class="n">p</span> <span class="n">q</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Imp</span> <span class="p">(</span><span class="n">subFor</span> <span class="n">y</span> <span class="n">x</span> <span class="n">p</span><span class="p">)</span> <span class="p">(</span><span class="n">subFor</span> <span class="n">y</span> <span class="n">x</span> <span class="n">q</span><span class="p">)</span>
<span class="nf">subFor</span> <span class="n">y</span> <span class="n">x</span> <span class="p">(</span><span class="kt">Forall</span> <span class="n">z</span> <span class="n">p</span><span class="p">)</span> <span class="o">|</span> <span class="n">z</span> <span class="o">==</span> <span class="n">x</span> <span class="ow">=</span> <span class="kt">Forall</span> <span class="n">z</span> <span class="n">p</span>
                        <span class="o">|</span> <span class="n">otherwise</span> <span class="ow">=</span> <span class="kr">if</span> <span class="n">z</span> <span class="o">/=</span> <span class="n">y</span> <span class="kr">then</span> <span class="kt">Forall</span> <span class="n">z</span> <span class="p">(</span><span class="n">subFor</span> <span class="n">y</span> <span class="n">x</span> <span class="n">p</span><span class="p">)</span> <span class="kr">else</span> <span class="ne">error</span> <span class="s">"subFor"</span>
<span class="nf">subFor</span> <span class="n">y</span> <span class="n">x</span> <span class="p">(</span><span class="kt">Eq</span> <span class="n">s</span> <span class="n">t</span><span class="p">)</span> <span class="o">|</span> <span class="n">x</span> <span class="o">/=</span> <span class="n">s</span> <span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="o">/=</span> <span class="n">t</span> <span class="ow">=</span> <span class="kt">Eq</span> <span class="n">s</span> <span class="n">t</span>
                    <span class="o">|</span> <span class="n">x</span> <span class="o">==</span> <span class="n">s</span> <span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="o">/=</span> <span class="n">t</span> <span class="ow">=</span> <span class="kt">Eq</span> <span class="n">y</span> <span class="n">t</span>
                    <span class="o">|</span> <span class="n">x</span> <span class="o">/=</span> <span class="n">s</span> <span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="o">==</span> <span class="n">t</span> <span class="ow">=</span> <span class="kt">Eq</span> <span class="n">s</span> <span class="n">y</span>
                    <span class="o">|</span> <span class="n">otherwise</span> <span class="ow">=</span> <span class="kt">Eq</span> <span class="n">y</span> <span class="n">y</span>
<span class="nf">subFor</span> <span class="n">y</span> <span class="n">x</span> <span class="p">(</span><span class="kt">In</span> <span class="n">s</span> <span class="n">t</span><span class="p">)</span> <span class="o">|</span> <span class="n">x</span> <span class="o">/=</span> <span class="n">s</span> <span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="o">/=</span> <span class="n">t</span> <span class="ow">=</span> <span class="kt">In</span> <span class="n">s</span> <span class="n">t</span>
                    <span class="o">|</span> <span class="n">x</span> <span class="o">==</span> <span class="n">s</span> <span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="o">/=</span> <span class="n">t</span> <span class="ow">=</span> <span class="kt">In</span> <span class="n">y</span> <span class="n">t</span>
                    <span class="o">|</span> <span class="n">x</span> <span class="o">/=</span> <span class="n">s</span> <span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="o">==</span> <span class="n">t</span> <span class="ow">=</span> <span class="kt">In</span> <span class="n">s</span> <span class="n">y</span>
                    <span class="o">|</span> <span class="n">otherwise</span> <span class="ow">=</span> <span class="kt">In</span> <span class="n">y</span> <span class="n">y</span>


<span class="nf">freeIn</span> <span class="ow">::</span> <span class="kt">Var</span> <span class="ow">-&gt;</span> <span class="kt">Formula</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">freeIn</span> <span class="n">x</span> <span class="p">(</span><span class="kt">Not</span> <span class="n">p</span><span class="p">)</span> <span class="ow">=</span> <span class="n">freeIn</span> <span class="n">x</span> <span class="n">p</span>
<span class="nf">freeIn</span> <span class="n">x</span> <span class="p">(</span><span class="kt">Imp</span> <span class="n">p</span> <span class="n">q</span><span class="p">)</span> <span class="ow">=</span> <span class="n">freeIn</span> <span class="n">x</span> <span class="n">p</span> <span class="o">||</span> <span class="n">freeIn</span> <span class="n">x</span> <span class="n">q</span>
<span class="nf">freeIn</span> <span class="n">x</span> <span class="p">(</span><span class="kt">Forall</span> <span class="n">y</span> <span class="n">p</span><span class="p">)</span> <span class="ow">=</span> <span class="n">x</span> <span class="o">/=</span> <span class="n">y</span> <span class="o">&amp;&amp;</span> <span class="n">freeIn</span> <span class="n">x</span> <span class="n">p</span>
<span class="nf">freeIn</span> <span class="n">x</span> <span class="p">(</span><span class="kt">Eq</span> <span class="n">s</span> <span class="n">t</span><span class="p">)</span> <span class="ow">=</span> <span class="n">x</span> <span class="o">==</span> <span class="n">s</span> <span class="o">||</span> <span class="n">x</span> <span class="o">==</span> <span class="n">t</span>
<span class="nf">freeIn</span> <span class="n">x</span> <span class="p">(</span><span class="kt">In</span> <span class="n">s</span> <span class="n">t</span><span class="p">)</span> <span class="ow">=</span> <span class="n">x</span> <span class="o">==</span> <span class="n">s</span> <span class="o">||</span> <span class="n">x</span> <span class="o">==</span> <span class="n">t</span>


<span class="c1">-- Propositional calculus</span>

<span class="c1">-- |- (p -&gt; (q -&gt; p))</span>
<span class="nf">prop_1</span> <span class="ow">::</span> <span class="kt">Formula</span> <span class="ow">-&gt;</span> <span class="kt">Formula</span> <span class="ow">-&gt;</span> <span class="kt">Theorem</span>
<span class="nf">prop_1</span> <span class="n">p</span> <span class="n">q</span> <span class="ow">=</span> <span class="kt">Theorem</span> <span class="p">(</span><span class="kt">Imp</span> <span class="n">p</span> <span class="p">(</span><span class="kt">Imp</span> <span class="n">q</span> <span class="n">p</span><span class="p">))</span>

<span class="c1">-- |- ((p -&gt; (q -&gt; r)) -&gt; ((p -&gt; q) -&gt; (p -&gt; r)))</span>
<span class="nf">prop_2</span> <span class="ow">::</span> <span class="kt">Formula</span> <span class="ow">-&gt;</span> <span class="kt">Formula</span> <span class="ow">-&gt;</span> <span class="kt">Formula</span> <span class="ow">-&gt;</span> <span class="kt">Theorem</span>
<span class="nf">prop_2</span> <span class="n">p</span> <span class="n">q</span> <span class="n">r</span> <span class="ow">=</span> <span class="kt">Theorem</span> <span class="p">(</span><span class="kt">Imp</span> <span class="p">(</span><span class="kt">Imp</span> <span class="n">p</span> <span class="p">(</span><span class="kt">Imp</span> <span class="n">q</span> <span class="n">r</span><span class="p">))</span> <span class="p">(</span><span class="kt">Imp</span> <span class="p">(</span><span class="kt">Imp</span> <span class="n">p</span> <span class="n">q</span><span class="p">)</span> <span class="p">(</span><span class="kt">Imp</span> <span class="n">p</span> <span class="n">r</span><span class="p">)))</span>

<span class="c1">-- |- ((~p -&gt; ~q) -&gt; (q -&gt; p))</span>
<span class="nf">prop_3</span> <span class="ow">::</span> <span class="kt">Formula</span> <span class="ow">-&gt;</span> <span class="kt">Formula</span> <span class="ow">-&gt;</span> <span class="kt">Theorem</span>
<span class="nf">prop_3</span> <span class="n">p</span> <span class="n">q</span> <span class="ow">=</span> <span class="kt">Theorem</span> <span class="p">(</span><span class="kt">Imp</span> <span class="p">(</span><span class="kt">Imp</span> <span class="p">(</span><span class="kt">Not</span> <span class="n">p</span><span class="p">)</span> <span class="p">(</span><span class="kt">Not</span> <span class="n">q</span><span class="p">))</span> <span class="p">(</span><span class="kt">Imp</span> <span class="n">q</span> <span class="n">p</span><span class="p">))</span>

<span class="c1">-- |- p &amp; |- (p -&gt; q) =&gt; |- q</span>
<span class="nf">mp</span> <span class="ow">::</span> <span class="kt">Theorem</span> <span class="ow">-&gt;</span> <span class="kt">Theorem</span> <span class="ow">-&gt;</span> <span class="kt">Theorem</span>
<span class="nf">mp</span> <span class="p">(</span><span class="kt">Theorem</span> <span class="n">p</span><span class="p">)</span> <span class="p">(</span><span class="kt">Theorem</span> <span class="p">(</span><span class="kt">Imp</span> <span class="n">p'</span> <span class="n">q</span><span class="p">))</span> <span class="ow">=</span> <span class="kr">if</span> <span class="n">p</span> <span class="o">==</span> <span class="n">p'</span> <span class="kr">then</span> <span class="kt">Theorem</span> <span class="n">q</span> <span class="kr">else</span> <span class="ne">error</span> <span class="s">"mp"</span>
<span class="nf">mp</span> <span class="kr">_</span> <span class="kr">_</span> <span class="ow">=</span> <span class="ne">error</span> <span class="s">"mp"</span>


<span class="c1">-- Predicate calculus</span>

<span class="c1">-- |- p =&gt; |- forall x. p</span>
<span class="nf">gen</span> <span class="ow">::</span> <span class="kt">Theorem</span> <span class="ow">-&gt;</span> <span class="kt">Var</span> <span class="ow">-&gt;</span> <span class="kt">Theorem</span>
<span class="nf">gen</span> <span class="p">(</span><span class="kt">Theorem</span> <span class="n">p</span><span class="p">)</span> <span class="n">x</span> <span class="ow">=</span> <span class="kt">Theorem</span> <span class="p">(</span><span class="kt">Forall</span> <span class="n">x</span> <span class="n">p</span><span class="p">)</span>

<span class="c1">-- |- ((forall x. (p -&gt; q)) -&gt; (forall x. p) -&gt; (forall x. q))</span>
<span class="nf">pred_1</span> <span class="ow">::</span> <span class="kt">Var</span> <span class="ow">-&gt;</span> <span class="kt">Formula</span> <span class="ow">-&gt;</span> <span class="kt">Formula</span> <span class="ow">-&gt;</span> <span class="kt">Theorem</span>
<span class="nf">pred_1</span> <span class="n">x</span> <span class="n">p</span> <span class="n">q</span> <span class="ow">=</span> <span class="kt">Theorem</span> <span class="p">(</span><span class="kt">Imp</span> <span class="p">(</span><span class="kt">Forall</span> <span class="n">x</span> <span class="p">(</span><span class="kt">Imp</span> <span class="n">p</span> <span class="n">q</span><span class="p">))</span> <span class="p">(</span><span class="kt">Imp</span> <span class="p">(</span><span class="kt">Forall</span> <span class="n">x</span> <span class="n">p</span><span class="p">)</span> <span class="p">(</span><span class="kt">Forall</span> <span class="n">x</span> <span class="n">q</span><span class="p">)))</span>

<span class="c1">-- |- (forall x. p -&gt; p [y/x]) provided p admits y for x</span>
<span class="nf">pred_2</span> <span class="ow">::</span> <span class="kt">Var</span> <span class="ow">-&gt;</span> <span class="kt">Var</span> <span class="ow">-&gt;</span> <span class="kt">Formula</span> <span class="ow">-&gt;</span> <span class="kt">Theorem</span>
<span class="nf">pred_2</span> <span class="n">x</span> <span class="n">y</span> <span class="n">p</span> <span class="ow">=</span> <span class="kt">Theorem</span> <span class="p">(</span><span class="kt">Imp</span> <span class="p">(</span><span class="kt">Forall</span> <span class="n">x</span> <span class="n">p</span><span class="p">)</span> <span class="p">(</span><span class="n">subFor</span> <span class="n">y</span> <span class="n">x</span> <span class="n">p</span><span class="p">))</span>

<span class="c1">-- |- (p -&gt; forall x. p) provided x is not free in p</span>
<span class="nf">pred_3</span> <span class="ow">::</span> <span class="kt">Var</span> <span class="ow">-&gt;</span> <span class="kt">Formula</span> <span class="ow">-&gt;</span> <span class="kt">Theorem</span>
<span class="nf">pred_3</span> <span class="n">x</span> <span class="n">p</span> <span class="ow">=</span> <span class="kr">if</span> <span class="n">not</span> <span class="p">(</span><span class="n">freeIn</span> <span class="n">x</span> <span class="n">p</span><span class="p">)</span> <span class="kr">then</span> <span class="kt">Theorem</span> <span class="p">(</span><span class="kt">Imp</span> <span class="n">p</span> <span class="p">(</span><span class="kt">Forall</span> <span class="n">x</span> <span class="n">p</span><span class="p">))</span> <span class="kr">else</span> <span class="ne">error</span> <span class="s">"pred_3"</span>


<span class="c1">-- Equality</span>

<span class="c1">-- |- forall x. x = x</span>
<span class="nf">eq_1</span> <span class="ow">::</span> <span class="kt">Var</span> <span class="ow">-&gt;</span> <span class="kt">Theorem</span>
<span class="nf">eq_1</span> <span class="n">x</span> <span class="ow">=</span> <span class="kt">Theorem</span> <span class="p">(</span><span class="kt">Forall</span> <span class="n">x</span> <span class="p">(</span><span class="kt">Eq</span> <span class="n">x</span> <span class="n">x</span><span class="p">))</span>

<span class="c1">-- |- (x = y -&gt; (x = z -&gt; y = z))</span>
<span class="nf">eq_2</span> <span class="ow">::</span> <span class="kt">Var</span> <span class="ow">-&gt;</span> <span class="kt">Var</span> <span class="ow">-&gt;</span> <span class="kt">Var</span> <span class="ow">-&gt;</span> <span class="kt">Theorem</span>
<span class="nf">eq_2</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="ow">=</span> <span class="kt">Theorem</span> <span class="p">(</span><span class="kt">Imp</span> <span class="p">(</span><span class="kt">Eq</span> <span class="n">x</span> <span class="n">y</span><span class="p">)</span> <span class="p">(</span><span class="kt">Imp</span> <span class="p">(</span><span class="kt">Eq</span> <span class="n">x</span> <span class="n">z</span><span class="p">)</span> <span class="p">(</span><span class="kt">Eq</span> <span class="n">y</span> <span class="n">z</span><span class="p">)))</span>

<span class="c1">-- |- (x = y -&gt; (x \in z -&gt; y \in z))</span>
<span class="nf">eq_3</span> <span class="ow">::</span> <span class="kt">Var</span> <span class="ow">-&gt;</span> <span class="kt">Var</span> <span class="ow">-&gt;</span> <span class="kt">Var</span> <span class="ow">-&gt;</span> <span class="kt">Theorem</span>
<span class="nf">eq_3</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="ow">=</span> <span class="kt">Theorem</span> <span class="p">(</span><span class="kt">Imp</span> <span class="p">(</span><span class="kt">Eq</span> <span class="n">x</span> <span class="n">y</span><span class="p">)</span> <span class="p">(</span><span class="kt">Imp</span> <span class="p">(</span><span class="kt">In</span> <span class="n">x</span> <span class="n">z</span><span class="p">)</span> <span class="p">(</span><span class="kt">In</span> <span class="n">y</span> <span class="n">z</span><span class="p">)))</span>

<span class="c1">-- |- (x = y -&gt; (z \in x -&gt; z \in y))</span>
<span class="nf">eq_4</span> <span class="ow">::</span> <span class="kt">Var</span> <span class="ow">-&gt;</span> <span class="kt">Var</span> <span class="ow">-&gt;</span> <span class="kt">Var</span> <span class="ow">-&gt;</span> <span class="kt">Theorem</span>
<span class="nf">eq_4</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="ow">=</span> <span class="kt">Theorem</span> <span class="p">(</span><span class="kt">Imp</span> <span class="p">(</span><span class="kt">Eq</span> <span class="n">x</span> <span class="n">y</span><span class="p">)</span> <span class="p">(</span><span class="kt">Imp</span> <span class="p">(</span><span class="kt">In</span> <span class="n">z</span> <span class="n">x</span><span class="p">)</span> <span class="p">(</span><span class="kt">In</span> <span class="n">z</span> <span class="n">y</span><span class="p">)))</span>
</code></pre></div>



<a name="266896458"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/266896458" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#266896458">(Jan 05 2022 at 04:20)</a>:</h4>
<p>Hmm, no, still wrong. Sorry for the spam.</p>



<a name="266902993"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/266902993" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#266902993">(Jan 05 2022 at 06:44)</a>:</h4>
<p>Is this correct for the logic of ZFC?</p>
<div class="codehilite" data-code-language="Haskell"><pre><span></span><code><span class="kr">type</span> <span class="kt">Var</span> <span class="ow">=</span> <span class="kt">String</span>

<span class="kr">data</span> <span class="kt">Formula</span> <span class="ow">=</span> <span class="kt">Not</span> <span class="kt">Formula</span> <span class="c1">-- ~ Formula</span>
             <span class="o">|</span> <span class="kt">Imp</span> <span class="kt">Formula</span> <span class="kt">Formula</span> <span class="c1">-- Formula -&gt; Formula</span>
             <span class="o">|</span> <span class="kt">Forall</span> <span class="kt">Var</span> <span class="kt">Formula</span> <span class="c1">-- forall Var. Formula</span>
             <span class="o">|</span> <span class="kt">Eq</span> <span class="kt">Var</span> <span class="kt">Var</span> <span class="c1">-- Var = Var</span>
             <span class="o">|</span> <span class="kt">In</span> <span class="kt">Var</span> <span class="kt">Var</span> <span class="c1">-- Var \in Var</span>
               <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">)</span>

<span class="kr">newtype</span> <span class="kt">Theorem</span> <span class="ow">=</span> <span class="kt">Theorem</span> <span class="kt">Formula</span>


<span class="cm">{-</span>
<span class="cm">An occurrence of a variable $v$ in a formula $P$ is bound if and only if</span>
<span class="cm">it occurs in a subformula of $P$ of the form $\forall v Q$. An occurrence</span>
<span class="cm">of $v$ in $P$ is free if and only if it is not a bound occurrence. The</span>
<span class="cm">variable $v$ is free or bound in $P$ according as it has a free or bound</span>
<span class="cm"> occurrence in $P$.</span>

<span class="cm">If $P$ is a formula, $v$ is a variable, and $t$ is a term, then $P(t/v)$ is</span>
<span class="cm">the result of replacing each free occurrence of $v$ in $P$ by an occurrence</span>
<span class="cm">of $t$.</span>

<span class="cm">If $v$ and $u$ are variables and $P$ is a formula, then $P$ admits $u$ for $v$</span>
<span class="cm">if and only if there is no free occurrence of $v$ in $P$ that becomes a</span>
<span class="cm">bound occurrence of $u$ in $P(u/v)$. If $t$ is a term, then $P$ admits $t$ for</span>
<span class="cm">$v$ if and only if $P$ admits for $v$ every variable in $t$.</span>
<span class="cm">-}</span>

<span class="c1">-- occursIn v p = v occurs in p</span>
<span class="nf">occursIn</span> <span class="ow">::</span> <span class="kt">Var</span> <span class="ow">-&gt;</span> <span class="kt">Formula</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">occursIn</span> <span class="n">v</span> <span class="p">(</span><span class="kt">Not</span> <span class="n">p</span><span class="p">)</span> <span class="ow">=</span> <span class="n">occursIn</span> <span class="n">v</span> <span class="n">p</span>
<span class="nf">occursIn</span> <span class="n">v</span> <span class="p">(</span><span class="kt">Imp</span> <span class="n">p</span> <span class="n">q</span><span class="p">)</span> <span class="ow">=</span> <span class="n">occursIn</span> <span class="n">v</span> <span class="n">p</span> <span class="o">||</span> <span class="n">occursIn</span> <span class="n">v</span> <span class="n">q</span>
<span class="nf">occursIn</span> <span class="n">v</span> <span class="p">(</span><span class="kt">Forall</span> <span class="kr">_</span> <span class="n">p</span><span class="p">)</span> <span class="ow">=</span> <span class="n">occursIn</span> <span class="n">v</span> <span class="n">p</span>
<span class="nf">occursIn</span> <span class="n">v</span> <span class="p">(</span><span class="kt">Eq</span> <span class="n">x</span> <span class="n">y</span><span class="p">)</span> <span class="ow">=</span> <span class="n">v</span> <span class="o">==</span> <span class="n">x</span> <span class="o">||</span> <span class="n">v</span> <span class="o">==</span> <span class="n">y</span>
<span class="nf">occursIn</span> <span class="n">v</span> <span class="p">(</span><span class="kt">In</span> <span class="n">x</span> <span class="n">y</span><span class="p">)</span> <span class="ow">=</span> <span class="n">v</span> <span class="o">==</span> <span class="n">x</span> <span class="o">||</span> <span class="n">v</span> <span class="o">==</span> <span class="n">y</span>

<span class="c1">-- freeIn v p = there exists an occurrence of v in p that is free.</span>
<span class="nf">freeIn</span> <span class="ow">::</span> <span class="kt">Var</span> <span class="ow">-&gt;</span> <span class="kt">Formula</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">freeIn</span> <span class="n">v</span> <span class="p">(</span><span class="kt">Not</span> <span class="n">p</span><span class="p">)</span> <span class="ow">=</span> <span class="n">freeIn</span> <span class="n">v</span> <span class="n">p</span>
<span class="nf">freeIn</span> <span class="n">v</span> <span class="p">(</span><span class="kt">Imp</span> <span class="n">p</span> <span class="n">q</span><span class="p">)</span> <span class="ow">=</span> <span class="n">freeIn</span> <span class="n">v</span> <span class="n">p</span> <span class="o">||</span> <span class="n">freeIn</span> <span class="n">v</span> <span class="n">q</span>
<span class="nf">freeIn</span> <span class="n">v</span> <span class="p">(</span><span class="kt">Forall</span> <span class="n">x</span> <span class="n">p</span><span class="p">)</span> <span class="ow">=</span> <span class="n">v</span> <span class="o">/=</span> <span class="n">x</span> <span class="o">&amp;&amp;</span> <span class="n">freeIn</span> <span class="n">v</span> <span class="n">p</span>
<span class="nf">freeIn</span> <span class="n">v</span> <span class="p">(</span><span class="kt">Eq</span> <span class="n">x</span> <span class="n">y</span><span class="p">)</span> <span class="ow">=</span> <span class="n">v</span> <span class="o">==</span> <span class="n">x</span> <span class="o">||</span> <span class="n">v</span> <span class="o">==</span> <span class="n">y</span>
<span class="nf">freeIn</span> <span class="n">v</span> <span class="p">(</span><span class="kt">In</span> <span class="n">x</span> <span class="n">y</span><span class="p">)</span> <span class="ow">=</span> <span class="n">v</span> <span class="o">==</span> <span class="n">x</span> <span class="o">||</span> <span class="n">v</span> <span class="o">==</span> <span class="n">y</span>

<span class="c1">-- admitsFor p u v [] = p admits u for v = there is no free occurrence of</span>
<span class="c1">-- v in p that becomes a bound occurrence of u in p(u/v).</span>
<span class="c1">-- xs is the list of binding variables that p is in the scope of.</span>
<span class="nf">admitsFor</span> <span class="ow">::</span> <span class="kt">Formula</span> <span class="ow">-&gt;</span> <span class="kt">Var</span> <span class="ow">-&gt;</span> <span class="kt">Var</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Var</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">admitsFor</span> <span class="p">(</span><span class="kt">Not</span> <span class="n">p</span><span class="p">)</span> <span class="n">u</span> <span class="n">v</span> <span class="n">xs</span> <span class="ow">=</span> <span class="n">admitsFor</span> <span class="n">p</span> <span class="n">u</span> <span class="n">v</span> <span class="n">xs</span>
<span class="nf">admitsFor</span> <span class="p">(</span><span class="kt">Imp</span> <span class="n">p</span> <span class="n">q</span><span class="p">)</span> <span class="n">u</span> <span class="n">v</span> <span class="n">xs</span> <span class="ow">=</span> <span class="n">admitsFor</span> <span class="n">p</span> <span class="n">u</span> <span class="n">v</span> <span class="n">xs</span> <span class="o">&amp;&amp;</span> <span class="n">admitsFor</span> <span class="n">q</span> <span class="n">u</span> <span class="n">v</span> <span class="n">xs</span>
<span class="nf">admitsFor</span> <span class="p">(</span><span class="kt">Forall</span> <span class="n">x</span> <span class="n">p</span><span class="p">)</span> <span class="n">u</span> <span class="n">v</span> <span class="n">xs</span> <span class="ow">=</span> <span class="n">admitsFor</span> <span class="n">p</span> <span class="n">u</span> <span class="n">v</span> <span class="p">(</span><span class="n">x</span> <span class="kt">:</span> <span class="n">xs</span><span class="p">)</span>
<span class="nf">admitsFor</span> <span class="p">(</span><span class="kt">Eq</span> <span class="n">x</span> <span class="n">y</span><span class="p">)</span> <span class="n">u</span> <span class="n">v</span> <span class="n">xs</span> <span class="ow">=</span> <span class="p">(</span><span class="n">v</span> <span class="o">/=</span> <span class="n">x</span> <span class="o">||</span> <span class="n">elem</span> <span class="n">v</span> <span class="n">xs</span> <span class="o">||</span> <span class="n">not</span> <span class="p">(</span><span class="n">elem</span> <span class="n">u</span> <span class="n">xs</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
                            <span class="p">(</span><span class="n">v</span> <span class="o">/=</span> <span class="n">y</span> <span class="o">||</span> <span class="n">elem</span> <span class="n">v</span> <span class="n">xs</span> <span class="o">||</span> <span class="n">not</span> <span class="p">(</span><span class="n">elem</span> <span class="n">u</span> <span class="n">xs</span><span class="p">))</span>
<span class="nf">admitsFor</span> <span class="p">(</span><span class="kt">In</span> <span class="n">x</span> <span class="n">y</span><span class="p">)</span> <span class="n">u</span> <span class="n">v</span> <span class="n">xs</span> <span class="ow">=</span> <span class="p">(</span><span class="n">v</span> <span class="o">/=</span> <span class="n">x</span> <span class="o">||</span> <span class="n">elem</span> <span class="n">v</span> <span class="n">xs</span> <span class="o">||</span> <span class="n">not</span> <span class="p">(</span><span class="n">elem</span> <span class="n">u</span> <span class="n">xs</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
                            <span class="p">(</span><span class="n">v</span> <span class="o">/=</span> <span class="n">y</span> <span class="o">||</span> <span class="n">elem</span> <span class="n">v</span> <span class="n">xs</span> <span class="o">||</span> <span class="n">not</span> <span class="p">(</span><span class="n">elem</span> <span class="n">u</span> <span class="n">xs</span><span class="p">))</span>

<span class="c1">-- subFor t v p = p(v/t) = the result of replacing each free occurrence of</span>
<span class="c1">-- v in P by an occurrence of t.</span>
<span class="nf">subFor</span> <span class="ow">::</span> <span class="kt">Var</span> <span class="ow">-&gt;</span> <span class="kt">Var</span> <span class="ow">-&gt;</span> <span class="kt">Formula</span> <span class="ow">-&gt;</span> <span class="kt">Formula</span>
<span class="nf">subFor</span> <span class="n">t</span> <span class="n">v</span> <span class="p">(</span><span class="kt">Not</span> <span class="n">p</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Not</span> <span class="p">(</span><span class="n">subFor</span> <span class="n">t</span> <span class="n">v</span> <span class="n">p</span><span class="p">)</span>
<span class="nf">subFor</span> <span class="n">t</span> <span class="n">v</span> <span class="p">(</span><span class="kt">Imp</span> <span class="n">p</span> <span class="n">q</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Imp</span> <span class="p">(</span><span class="n">subFor</span> <span class="n">t</span> <span class="n">v</span> <span class="n">p</span><span class="p">)</span> <span class="p">(</span><span class="n">subFor</span> <span class="n">t</span> <span class="n">v</span> <span class="n">q</span><span class="p">)</span>
<span class="nf">subFor</span> <span class="n">t</span> <span class="n">v</span> <span class="p">(</span><span class="kt">Forall</span> <span class="n">x</span> <span class="n">p</span><span class="p">)</span> <span class="o">|</span> <span class="n">v</span> <span class="o">==</span> <span class="n">x</span> <span class="ow">=</span> <span class="kt">Forall</span> <span class="n">x</span> <span class="n">p</span>
                        <span class="o">|</span> <span class="n">otherwise</span> <span class="ow">=</span> <span class="kt">Forall</span> <span class="n">x</span> <span class="p">(</span><span class="n">subFor</span> <span class="n">t</span> <span class="n">v</span> <span class="n">p</span><span class="p">)</span>
<span class="nf">subFor</span> <span class="n">t</span> <span class="n">v</span> <span class="p">(</span><span class="kt">Eq</span> <span class="n">x</span> <span class="n">y</span><span class="p">)</span> <span class="o">|</span> <span class="n">v</span> <span class="o">==</span> <span class="n">x</span> <span class="o">&amp;&amp;</span> <span class="n">v</span> <span class="o">==</span> <span class="n">y</span> <span class="ow">=</span> <span class="kt">Eq</span> <span class="n">t</span> <span class="n">t</span>
                    <span class="o">|</span> <span class="n">v</span> <span class="o">==</span> <span class="n">x</span> <span class="o">&amp;&amp;</span> <span class="n">v</span> <span class="o">/=</span> <span class="n">y</span> <span class="ow">=</span> <span class="kt">Eq</span> <span class="n">t</span> <span class="n">y</span>
                    <span class="o">|</span> <span class="n">v</span> <span class="o">/=</span> <span class="n">x</span> <span class="o">&amp;&amp;</span> <span class="n">v</span> <span class="o">==</span> <span class="n">y</span> <span class="ow">=</span> <span class="kt">Eq</span> <span class="n">x</span> <span class="n">t</span>
                    <span class="o">|</span> <span class="n">otherwise</span> <span class="ow">=</span> <span class="kt">Eq</span> <span class="n">x</span> <span class="n">y</span>
<span class="nf">subFor</span> <span class="n">t</span> <span class="n">v</span> <span class="p">(</span><span class="kt">In</span> <span class="n">x</span> <span class="n">y</span><span class="p">)</span> <span class="o">|</span> <span class="n">v</span> <span class="o">==</span> <span class="n">x</span> <span class="o">&amp;&amp;</span> <span class="n">v</span> <span class="o">==</span> <span class="n">y</span> <span class="ow">=</span> <span class="kt">In</span> <span class="n">t</span> <span class="n">t</span>
                    <span class="o">|</span> <span class="n">v</span> <span class="o">==</span> <span class="n">x</span> <span class="o">&amp;&amp;</span> <span class="n">v</span> <span class="o">/=</span> <span class="n">y</span> <span class="ow">=</span> <span class="kt">In</span> <span class="n">t</span> <span class="n">y</span>
                    <span class="o">|</span> <span class="n">v</span> <span class="o">/=</span> <span class="n">x</span> <span class="o">&amp;&amp;</span> <span class="n">v</span> <span class="o">==</span> <span class="n">y</span> <span class="ow">=</span> <span class="kt">In</span> <span class="n">x</span> <span class="n">t</span>
                    <span class="o">|</span> <span class="n">otherwise</span> <span class="ow">=</span> <span class="kt">In</span> <span class="n">x</span> <span class="n">y</span>


<span class="c1">-- Propositional calculus</span>

<span class="c1">-- |- (p -&gt; (q -&gt; p))</span>
<span class="nf">prop_1</span> <span class="ow">::</span> <span class="kt">Formula</span> <span class="ow">-&gt;</span> <span class="kt">Formula</span> <span class="ow">-&gt;</span> <span class="kt">Theorem</span>
<span class="nf">prop_1</span> <span class="n">p</span> <span class="n">q</span> <span class="ow">=</span> <span class="kt">Theorem</span> <span class="p">(</span><span class="kt">Imp</span> <span class="n">p</span> <span class="p">(</span><span class="kt">Imp</span> <span class="n">q</span> <span class="n">p</span><span class="p">))</span>

<span class="c1">-- |- ((p -&gt; (q -&gt; r)) -&gt; ((p -&gt; q) -&gt; (p -&gt; r)))</span>
<span class="nf">prop_2</span> <span class="ow">::</span> <span class="kt">Formula</span> <span class="ow">-&gt;</span> <span class="kt">Formula</span> <span class="ow">-&gt;</span> <span class="kt">Formula</span> <span class="ow">-&gt;</span> <span class="kt">Theorem</span>
<span class="nf">prop_2</span> <span class="n">p</span> <span class="n">q</span> <span class="n">r</span> <span class="ow">=</span> <span class="kt">Theorem</span> <span class="p">(</span><span class="kt">Imp</span> <span class="p">(</span><span class="kt">Imp</span> <span class="n">p</span> <span class="p">(</span><span class="kt">Imp</span> <span class="n">q</span> <span class="n">r</span><span class="p">))</span> <span class="p">(</span><span class="kt">Imp</span> <span class="p">(</span><span class="kt">Imp</span> <span class="n">p</span> <span class="n">q</span><span class="p">)</span> <span class="p">(</span><span class="kt">Imp</span> <span class="n">p</span> <span class="n">r</span><span class="p">)))</span>

<span class="c1">-- |- ((~p -&gt; ~q) -&gt; (q -&gt; p))</span>
<span class="nf">prop_3</span> <span class="ow">::</span> <span class="kt">Formula</span> <span class="ow">-&gt;</span> <span class="kt">Formula</span> <span class="ow">-&gt;</span> <span class="kt">Theorem</span>
<span class="nf">prop_3</span> <span class="n">p</span> <span class="n">q</span> <span class="ow">=</span> <span class="kt">Theorem</span> <span class="p">(</span><span class="kt">Imp</span> <span class="p">(</span><span class="kt">Imp</span> <span class="p">(</span><span class="kt">Not</span> <span class="n">p</span><span class="p">)</span> <span class="p">(</span><span class="kt">Not</span> <span class="n">q</span><span class="p">))</span> <span class="p">(</span><span class="kt">Imp</span> <span class="n">q</span> <span class="n">p</span><span class="p">))</span>

<span class="c1">-- |- p &amp; |- (p -&gt; q) =&gt; |- q</span>
<span class="nf">mp</span> <span class="ow">::</span> <span class="kt">Theorem</span> <span class="ow">-&gt;</span> <span class="kt">Theorem</span> <span class="ow">-&gt;</span> <span class="kt">Theorem</span>
<span class="nf">mp</span> <span class="p">(</span><span class="kt">Theorem</span> <span class="n">p</span><span class="p">)</span> <span class="p">(</span><span class="kt">Theorem</span> <span class="p">(</span><span class="kt">Imp</span> <span class="n">p'</span> <span class="n">q</span><span class="p">))</span> <span class="ow">=</span> <span class="kr">if</span> <span class="n">p</span> <span class="o">==</span> <span class="n">p'</span> <span class="kr">then</span> <span class="kt">Theorem</span> <span class="n">q</span> <span class="kr">else</span> <span class="ne">error</span> <span class="s">"mp"</span>
<span class="nf">mp</span> <span class="kr">_</span> <span class="kr">_</span> <span class="ow">=</span> <span class="ne">error</span> <span class="s">"mp"</span>


<span class="c1">-- Predicate calculus</span>

<span class="c1">-- |- p =&gt; |- forall v. p</span>
<span class="nf">gen</span> <span class="ow">::</span> <span class="kt">Theorem</span> <span class="ow">-&gt;</span> <span class="kt">Var</span> <span class="ow">-&gt;</span> <span class="kt">Theorem</span>
<span class="nf">gen</span> <span class="p">(</span><span class="kt">Theorem</span> <span class="n">p</span><span class="p">)</span> <span class="n">v</span> <span class="ow">=</span> <span class="kt">Theorem</span> <span class="p">(</span><span class="kt">Forall</span> <span class="n">v</span> <span class="n">p</span><span class="p">)</span>

<span class="c1">-- |- ((forall v. (p -&gt; q)) -&gt; (forall v. p) -&gt; (forall v. q))</span>
<span class="nf">pred_1</span> <span class="ow">::</span> <span class="kt">Var</span> <span class="ow">-&gt;</span> <span class="kt">Formula</span> <span class="ow">-&gt;</span> <span class="kt">Formula</span> <span class="ow">-&gt;</span> <span class="kt">Theorem</span>
<span class="nf">pred_1</span> <span class="n">v</span> <span class="n">p</span> <span class="n">q</span> <span class="ow">=</span> <span class="kt">Theorem</span> <span class="p">(</span><span class="kt">Imp</span> <span class="p">(</span><span class="kt">Forall</span> <span class="n">v</span> <span class="p">(</span><span class="kt">Imp</span> <span class="n">p</span> <span class="n">q</span><span class="p">))</span> <span class="p">(</span><span class="kt">Imp</span> <span class="p">(</span><span class="kt">Forall</span> <span class="n">v</span> <span class="n">p</span><span class="p">)</span> <span class="p">(</span><span class="kt">Forall</span> <span class="n">v</span> <span class="n">q</span><span class="p">)))</span>

<span class="c1">-- |- (forall v. p -&gt; p [t/v]) provided p admits t for v</span>
<span class="nf">pred_2</span> <span class="ow">::</span> <span class="kt">Var</span> <span class="ow">-&gt;</span> <span class="kt">Var</span> <span class="ow">-&gt;</span> <span class="kt">Formula</span> <span class="ow">-&gt;</span> <span class="kt">Theorem</span>
<span class="nf">pred_2</span> <span class="n">t</span> <span class="n">v</span> <span class="n">p</span> <span class="ow">=</span> <span class="kr">if</span> <span class="n">admitsFor</span> <span class="n">p</span> <span class="n">t</span> <span class="n">v</span> <span class="kt">[]</span>
               <span class="kr">then</span> <span class="kt">Theorem</span> <span class="p">(</span><span class="kt">Imp</span> <span class="p">(</span><span class="kt">Forall</span> <span class="n">v</span> <span class="n">p</span><span class="p">)</span> <span class="p">(</span><span class="n">subFor</span> <span class="n">t</span> <span class="n">v</span> <span class="n">p</span><span class="p">))</span>
               <span class="kr">else</span> <span class="ne">error</span> <span class="s">"pred_2"</span>

<span class="c1">-- |- (p -&gt; forall v. p) provided v is not free in p</span>
<span class="nf">pred_3</span> <span class="ow">::</span> <span class="kt">Var</span> <span class="ow">-&gt;</span> <span class="kt">Formula</span> <span class="ow">-&gt;</span> <span class="kt">Theorem</span>
<span class="nf">pred_3</span> <span class="n">v</span> <span class="n">p</span> <span class="ow">=</span> <span class="kr">if</span> <span class="n">not</span> <span class="p">(</span><span class="n">freeIn</span> <span class="n">v</span> <span class="n">p</span><span class="p">)</span>
             <span class="kr">then</span> <span class="kt">Theorem</span> <span class="p">(</span><span class="kt">Imp</span> <span class="n">p</span> <span class="p">(</span><span class="kt">Forall</span> <span class="n">v</span> <span class="n">p</span><span class="p">))</span>
             <span class="kr">else</span> <span class="ne">error</span> <span class="s">"pred_3"</span>


<span class="c1">-- Equality</span>

<span class="c1">-- |- forall x. x = x</span>
<span class="nf">eq_1</span> <span class="ow">::</span> <span class="kt">Var</span> <span class="ow">-&gt;</span> <span class="kt">Theorem</span>
<span class="nf">eq_1</span> <span class="n">x</span> <span class="ow">=</span> <span class="kt">Theorem</span> <span class="p">(</span><span class="kt">Forall</span> <span class="n">x</span> <span class="p">(</span><span class="kt">Eq</span> <span class="n">x</span> <span class="n">x</span><span class="p">))</span>

<span class="c1">-- |- (x = y -&gt; (x = z -&gt; y = z))</span>
<span class="nf">eq_2</span> <span class="ow">::</span> <span class="kt">Var</span> <span class="ow">-&gt;</span> <span class="kt">Var</span> <span class="ow">-&gt;</span> <span class="kt">Var</span> <span class="ow">-&gt;</span> <span class="kt">Theorem</span>
<span class="nf">eq_2</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="ow">=</span> <span class="kt">Theorem</span> <span class="p">(</span><span class="kt">Imp</span> <span class="p">(</span><span class="kt">Eq</span> <span class="n">x</span> <span class="n">y</span><span class="p">)</span> <span class="p">(</span><span class="kt">Imp</span> <span class="p">(</span><span class="kt">Eq</span> <span class="n">x</span> <span class="n">z</span><span class="p">)</span> <span class="p">(</span><span class="kt">Eq</span> <span class="n">y</span> <span class="n">z</span><span class="p">)))</span>

<span class="c1">-- |- (x = y -&gt; (x \in z -&gt; y \in z))</span>
<span class="nf">eq_3</span> <span class="ow">::</span> <span class="kt">Var</span> <span class="ow">-&gt;</span> <span class="kt">Var</span> <span class="ow">-&gt;</span> <span class="kt">Var</span> <span class="ow">-&gt;</span> <span class="kt">Theorem</span>
<span class="nf">eq_3</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="ow">=</span> <span class="kt">Theorem</span> <span class="p">(</span><span class="kt">Imp</span> <span class="p">(</span><span class="kt">Eq</span> <span class="n">x</span> <span class="n">y</span><span class="p">)</span> <span class="p">(</span><span class="kt">Imp</span> <span class="p">(</span><span class="kt">In</span> <span class="n">x</span> <span class="n">z</span><span class="p">)</span> <span class="p">(</span><span class="kt">In</span> <span class="n">y</span> <span class="n">z</span><span class="p">)))</span>

<span class="c1">-- |- (x = y -&gt; (z \in x -&gt; z \in y))</span>
<span class="nf">eq_4</span> <span class="ow">::</span> <span class="kt">Var</span> <span class="ow">-&gt;</span> <span class="kt">Var</span> <span class="ow">-&gt;</span> <span class="kt">Var</span> <span class="ow">-&gt;</span> <span class="kt">Theorem</span>
<span class="nf">eq_4</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="ow">=</span> <span class="kt">Theorem</span> <span class="p">(</span><span class="kt">Imp</span> <span class="p">(</span><span class="kt">Eq</span> <span class="n">x</span> <span class="n">y</span><span class="p">)</span> <span class="p">(</span><span class="kt">Imp</span> <span class="p">(</span><span class="kt">In</span> <span class="n">z</span> <span class="n">x</span><span class="p">)</span> <span class="p">(</span><span class="kt">In</span> <span class="n">z</span> <span class="n">y</span><span class="p">)))</span>
</code></pre></div>



<a name="266967586"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/266967586" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Trebor Huang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#266967586">(Jan 05 2022 at 17:54)</a>:</h4>
<p>This code is soooo cool! One thing: you can use pattern synonyms to define <code>mkEq</code>, and it will not only serve as a function but it can <em>also</em> be used to pattern match</p>



<a name="266972249"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/266972249" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#266972249">(Jan 05 2022 at 18:32)</a>:</h4>
<p>Thank you. It is in large part just a translation from the OCaml code in  "Handbook of Practical Logic and Automated Reasoning" by John Harrison [https://www.cl.cam.ac.uk/~jrh13/atp/index.html].</p>



<a name="266982887"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/266982887" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#266982887">(Jan 05 2022 at 19:56)</a>:</h4>
<p>I'm not sure how the axioms change if I change to De Bruijn indexing or locally nameless variables. Do they? Do pred_2 and pred_3 change?</p>



<a name="266997646"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/266997646" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Trebor Huang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#266997646">(Jan 05 2022 at 22:02)</a>:</h4>
<p>You are probably going to have to figure out several subtleties if you go to dBI</p>



<a name="266997819"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/266997819" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Trebor Huang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#266997819">(Jan 05 2022 at 22:03)</a>:</h4>
<p>The tradition in first order logic is to use named variables, and there're lots of irks and quirks that are well-studied, like eigenvariables and stuff</p>



<a name="266998132"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/266998132" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Trebor Huang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#266998132">(Jan 05 2022 at 22:06)</a>:</h4>
<p>This is because variables never go into context. In type theories like Lean's, there may be something like <code>x : nat</code> before the turnstile; In first order logic, only propositions ever do. Hilbert-style systems even don't allow anything to go "before the turnstile", in some sense</p>



<a name="266998463"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/266998463" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Trebor Huang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#266998463">(Jan 05 2022 at 22:09)</a>:</h4>
<p>A lot of the weird restrictions on free variable occurence in FOL can be very well explained by writing them out in type theoretic (aka higher order logic) style, and realizing that they do no more than implicitly handling non-propositional terms in the context</p>



<a name="267000601"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/267000601" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#267000601">(Jan 05 2022 at 22:26)</a>:</h4>
<p>I don't think non-propositional terms themselves account for free variable restrictions. The analogue of free variable restrictions in type theory is scope restriction: an expression can only depend on the variables in scope (it carries its context with it, and can't be used in a context which does not extend the original). Also, substitution needs to know to avoid variables under a lambda</p>



<a name="267001039"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/267001039" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#267001039">(Jan 05 2022 at 22:29)</a>:</h4>
<p>Here's a standard example of scope violation:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">existsi</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">intro</span> <span class="n">y</span><span class="o">,</span>
  <span class="n">refl</span>
<span class="kd">end</span>
</code></pre></div>
<p>The proof by <code>refl</code> (to prove <code>?m = y</code>) would work if not for the fact that <code>?m</code> has a scope that does not include <code>y</code></p>



<a name="267004153"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/267004153" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#267004153">(Jan 05 2022 at 23:00)</a>:</h4>
<p>Is the code correct as is?</p>



<a name="267006575"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/267006575" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#267006575">(Jan 05 2022 at 23:26)</a>:</h4>
<p>no, it gives an error at <code>refl</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">invalid</span> <span class="n">apply</span> <span class="n">tactic</span><span class="o">,</span> <span class="n">failed</span> <span class="n">to</span> <span class="n">unify</span>
  <span class="bp">?</span><span class="n">m_1</span> <span class="bp">=</span> <span class="n">y</span>
<span class="k">with</span>
  <span class="bp">?</span><span class="n">m_3</span> <span class="bp">=</span> <span class="bp">?</span><span class="n">m_3</span>
</code></pre></div>



<a name="267006833"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/267006833" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#267006833">(Jan 05 2022 at 23:28)</a>:</h4>
<p>I'm sorry, I meant the Haskell code.</p>



<a name="267328206"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/267328206" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#267328206">(Jan 09 2022 at 01:43)</a>:</h4>
<p>I have code to define formulas with locally nameless variables and convert them to and from named variables, but I'm not sure how to define substitution for them, that is, the result of replacing one term by another in a formula. I'm not sure I understand the advantage of the locally nameless terms in this case, because if you are trying to replace a free variable by one that will become bound, then don't you still have to check and alpha convert for that?</p>
<div class="codehilite" data-code-language="Haskell"><pre><span></span><code><span class="c1">-- Adapted from https://boarders.github.io/posts/locally-nameless/</span>

<span class="kr">import</span> <span class="nn">Prelude</span> <span class="k">hiding</span> <span class="p">(</span><span class="kt">False</span><span class="p">,</span> <span class="kt">True</span><span class="p">)</span>
<span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Prelude</span> <span class="p">(</span><span class="kt">Bool</span><span class="p">(</span><span class="o">..</span><span class="p">))</span>

<span class="kr">import</span> <span class="nn">Data.List</span>
<span class="kr">import</span> <span class="nn">Data.Map</span>


<span class="c1">-- Func "c" [] : A constant named c</span>
<span class="kr">data</span> <span class="kt">Term</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Var</span> <span class="n">a</span>
            <span class="o">|</span> <span class="kt">Func</span> <span class="kt">String</span> <span class="p">[</span><span class="kt">Term</span> <span class="n">a</span><span class="p">]</span>
              <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">)</span>

<span class="kr">data</span> <span class="kt">Formula</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">False</span>
               <span class="o">|</span> <span class="kt">True</span>
               <span class="o">|</span> <span class="kt">Pred</span> <span class="kt">String</span> <span class="p">[</span><span class="kt">Term</span> <span class="n">a</span><span class="p">]</span>        <span class="c1">-- Pred "P" [] : A propositional variable named P</span>
               <span class="o">|</span> <span class="kt">Not</span> <span class="p">(</span><span class="kt">Formula</span> <span class="n">a</span><span class="p">)</span>             <span class="c1">-- ~ Formula</span>
               <span class="o">|</span> <span class="kt">And</span> <span class="p">(</span><span class="kt">Formula</span> <span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="kt">Formula</span> <span class="n">a</span><span class="p">)</span> <span class="c1">-- Formula /\ Formula</span>
               <span class="o">|</span> <span class="kt">Or</span> <span class="p">(</span><span class="kt">Formula</span> <span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="kt">Formula</span> <span class="n">a</span><span class="p">)</span>  <span class="c1">-- Formula \/ Formula</span>
               <span class="o">|</span> <span class="kt">Imp</span> <span class="p">(</span><span class="kt">Formula</span> <span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="kt">Formula</span> <span class="n">a</span><span class="p">)</span> <span class="c1">-- Formula -&gt; Formula</span>
               <span class="o">|</span> <span class="kt">Iff</span> <span class="p">(</span><span class="kt">Formula</span> <span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="kt">Formula</span> <span class="n">a</span><span class="p">)</span> <span class="c1">-- Formula &lt;-&gt; Formula</span>
               <span class="o">|</span> <span class="kt">Forall</span> <span class="n">a</span> <span class="p">(</span><span class="kt">Formula</span> <span class="n">a</span><span class="p">)</span>        <span class="c1">-- forall Var. Formula</span>
               <span class="o">|</span> <span class="kt">Exists</span> <span class="n">a</span> <span class="p">(</span><span class="kt">Formula</span> <span class="n">a</span><span class="p">)</span>        <span class="c1">-- exists Var. Formula</span>
                 <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">)</span>


<span class="c1">-- The type of named variables.</span>
<span class="kr">type</span> <span class="kt">NV</span> <span class="ow">=</span> <span class="kt">String</span>


<span class="c1">-- The type of locally nameless variables.</span>
<span class="kr">data</span> <span class="kt">LN</span> <span class="ow">=</span> <span class="kt">F</span> <span class="kt">String</span> <span class="c1">-- The name of a free variable or a binding variable.</span>
        <span class="o">|</span> <span class="kt">B</span> <span class="kt">Int</span>    <span class="c1">-- The De Bruijn index of a bound variable.</span>
          <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Show</span><span class="p">)</span>


<span class="cm">{-</span>
<span class="cm">Translates a named variable formula to a locally nameless formula.</span>
<span class="cm">Keeps the name of each free variable and binding variable. Changes the name of</span>
<span class="cm">each bound variable to its De Bruijn index.</span>
<span class="cm">-}</span>
<span class="nf">formulaToLN</span> <span class="ow">::</span> <span class="kt">Formula</span> <span class="kt">NV</span> <span class="ow">-&gt;</span> <span class="kt">Formula</span> <span class="kt">LN</span>
<span class="nf">formulaToLN</span> <span class="n">formula</span> <span class="ow">=</span> <span class="n">go</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">Map</span><span class="o">.</span><span class="n">empty</span> <span class="n">formula</span>
  <span class="kr">where</span>
    <span class="cm">{-</span>
<span class="cm">    The mapping is from the name of each binding variable to its De Bruijn</span>
<span class="cm">    index at the current depth.</span>
<span class="cm">    -}</span>
    <span class="n">go</span> <span class="ow">::</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">Map</span><span class="o">.</span><span class="kt">Map</span> <span class="kt">String</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Formula</span> <span class="kt">NV</span> <span class="ow">-&gt;</span> <span class="kt">Formula</span> <span class="kt">LN</span>
    <span class="n">go</span> <span class="kr">_</span> <span class="kt">False</span> <span class="ow">=</span> <span class="kt">False</span>
    <span class="n">go</span> <span class="kr">_</span> <span class="kt">True</span> <span class="ow">=</span> <span class="kt">True</span>
    <span class="n">go</span> <span class="n">env</span> <span class="p">(</span><span class="kt">Pred</span> <span class="n">name</span> <span class="n">terms</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Pred</span> <span class="n">name</span> <span class="p">(</span><span class="kt">Data</span><span class="o">.</span><span class="kt">List</span><span class="o">.</span><span class="n">map</span> <span class="p">(</span><span class="n">termToLN</span> <span class="n">env</span><span class="p">)</span> <span class="n">terms</span><span class="p">)</span>
      <span class="kr">where</span>
        <span class="c1">-- Translates a named variable term to a locally nameless term.</span>
        <span class="cm">{-</span>
<span class="cm">        The mapping is from the name of each binding variable to its De Bruijn</span>
<span class="cm">        index at the current depth.</span>
<span class="cm">        -}</span>
        <span class="n">termToLN</span> <span class="ow">::</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">Map</span><span class="o">.</span><span class="kt">Map</span> <span class="kt">String</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Term</span> <span class="kt">NV</span> <span class="ow">-&gt;</span> <span class="kt">Term</span> <span class="kt">LN</span>
        <span class="n">termToLN</span> <span class="n">env</span> <span class="p">(</span><span class="kt">Var</span> <span class="n">name</span><span class="p">)</span> <span class="ow">=</span>
          <span class="kr">case</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">Map</span><span class="o">.</span><span class="n">lookup</span> <span class="n">name</span> <span class="n">env</span> <span class="kr">of</span>
            <span class="cm">{-</span>
<span class="cm">            The variable name is a key in the map. Therefore it has the same</span>
<span class="cm">            name as a binding variable. Therefore it is a bound variable.</span>
<span class="cm">            Then the De Bruijn index of the binding variable it matches is</span>
<span class="cm">            used.</span>
<span class="cm">            -}</span>
            <span class="kt">Just</span> <span class="n">index</span> <span class="ow">-&gt;</span> <span class="kt">Var</span> <span class="p">(</span><span class="kt">B</span> <span class="n">index</span><span class="p">)</span>
            <span class="cm">{-</span>
<span class="cm">            The variable name is not a key in the map. Therefore it is a free</span>
<span class="cm">            variable. Then its name is kept.</span>
<span class="cm">            -}</span>
            <span class="kt">Nothing</span> <span class="ow">-&gt;</span> <span class="kt">Var</span> <span class="p">(</span><span class="kt">F</span> <span class="n">name</span><span class="p">)</span>
        <span class="n">termToLN</span> <span class="n">env</span> <span class="p">(</span><span class="kt">Func</span> <span class="n">name</span> <span class="n">terms</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Func</span> <span class="n">name</span> <span class="p">(</span><span class="kt">Data</span><span class="o">.</span><span class="kt">List</span><span class="o">.</span><span class="n">map</span> <span class="p">(</span><span class="n">termToLN</span> <span class="n">env</span><span class="p">)</span> <span class="n">terms</span><span class="p">)</span>
    <span class="n">go</span> <span class="n">env</span> <span class="p">(</span><span class="kt">Not</span> <span class="n">p</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Not</span> <span class="p">(</span><span class="n">go</span> <span class="n">env</span> <span class="n">p</span><span class="p">)</span>
    <span class="n">go</span> <span class="n">env</span> <span class="p">(</span><span class="kt">And</span> <span class="n">p</span> <span class="n">q</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">And</span> <span class="p">(</span><span class="n">go</span> <span class="n">env</span> <span class="n">p</span><span class="p">)</span> <span class="p">(</span><span class="n">go</span> <span class="n">env</span> <span class="n">q</span><span class="p">)</span>
    <span class="n">go</span> <span class="n">env</span> <span class="p">(</span><span class="kt">Or</span> <span class="n">p</span> <span class="n">q</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Or</span> <span class="p">(</span><span class="n">go</span> <span class="n">env</span> <span class="n">p</span><span class="p">)</span> <span class="p">(</span><span class="n">go</span> <span class="n">env</span> <span class="n">q</span><span class="p">)</span>
    <span class="n">go</span> <span class="n">env</span> <span class="p">(</span><span class="kt">Imp</span> <span class="n">p</span> <span class="n">q</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Imp</span> <span class="p">(</span><span class="n">go</span> <span class="n">env</span> <span class="n">p</span><span class="p">)</span> <span class="p">(</span><span class="n">go</span> <span class="n">env</span> <span class="n">q</span><span class="p">)</span>
    <span class="n">go</span> <span class="n">env</span> <span class="p">(</span><span class="kt">Iff</span> <span class="n">p</span> <span class="n">q</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Iff</span> <span class="p">(</span><span class="n">go</span> <span class="n">env</span> <span class="n">p</span><span class="p">)</span> <span class="p">(</span><span class="n">go</span> <span class="n">env</span> <span class="n">q</span><span class="p">)</span>
    <span class="n">go</span> <span class="n">env</span> <span class="p">(</span><span class="kt">Forall</span> <span class="n">name</span> <span class="n">p</span><span class="p">)</span> <span class="ow">=</span>
      <span class="cm">{-</span>
<span class="cm">      Since a binding variable has been gone under, the De Bruijn index of</span>
<span class="cm">      each binding variable at the current depth is increased by 1 and the</span>
<span class="cm">      De Bruijn index of the encountered binding variable at the current</span>
<span class="cm">      depth is set to 0.</span>
<span class="cm">      -}</span>
      <span class="kr">let</span> <span class="n">env'</span> <span class="ow">=</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">Map</span><span class="o">.</span><span class="n">insert</span> <span class="n">name</span> <span class="mi">0</span> <span class="p">(</span><span class="kt">Data</span><span class="o">.</span><span class="kt">Map</span><span class="o">.</span><span class="n">map</span> <span class="p">(</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="n">env</span><span class="p">)</span> <span class="kr">in</span>
      <span class="kt">Forall</span> <span class="p">(</span><span class="kt">F</span> <span class="n">name</span><span class="p">)</span> <span class="p">(</span><span class="n">go</span> <span class="n">env'</span> <span class="n">p</span><span class="p">)</span> <span class="c1">-- The name of the binding variable is kept.</span>
    <span class="n">go</span> <span class="n">env</span> <span class="p">(</span><span class="kt">Exists</span> <span class="n">name</span> <span class="n">p</span><span class="p">)</span> <span class="ow">=</span>
      <span class="kr">let</span> <span class="n">env'</span> <span class="ow">=</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">Map</span><span class="o">.</span><span class="n">insert</span> <span class="n">name</span> <span class="mi">0</span> <span class="p">(</span><span class="kt">Data</span><span class="o">.</span><span class="kt">Map</span><span class="o">.</span><span class="n">map</span> <span class="p">(</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="n">env</span><span class="p">)</span> <span class="kr">in</span>
      <span class="kt">Exists</span> <span class="p">(</span><span class="kt">F</span> <span class="n">name</span><span class="p">)</span> <span class="p">(</span><span class="n">go</span> <span class="n">env'</span> <span class="n">p</span><span class="p">)</span> <span class="c1">-- The name of the binding variable is kept.</span>


<span class="c1">-- Translates a locally nameless formula to a named variable formula.</span>
<span class="nf">formulaFromLN</span> <span class="ow">::</span> <span class="kt">Formula</span> <span class="kt">LN</span> <span class="ow">-&gt;</span> <span class="kt">Formula</span> <span class="kt">NV</span>
<span class="nf">formulaFromLN</span> <span class="n">formula</span> <span class="ow">=</span> <span class="n">go</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">Map</span><span class="o">.</span><span class="n">empty</span> <span class="n">formula</span>
  <span class="kr">where</span>
    <span class="cm">{-</span>
<span class="cm">    The mapping is from the De Bruijn index of each binding variable at the</span>
<span class="cm">    current depth to its name.</span>
<span class="cm">    -}</span>
    <span class="n">go</span> <span class="ow">::</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">Map</span><span class="o">.</span><span class="kt">Map</span> <span class="kt">Int</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Formula</span> <span class="kt">LN</span> <span class="ow">-&gt;</span> <span class="kt">Formula</span> <span class="kt">NV</span>
    <span class="n">go</span> <span class="kr">_</span> <span class="kt">False</span> <span class="ow">=</span> <span class="kt">False</span>
    <span class="n">go</span> <span class="kr">_</span> <span class="kt">True</span> <span class="ow">=</span> <span class="kt">True</span>
    <span class="n">go</span> <span class="n">env</span> <span class="p">(</span><span class="kt">Pred</span> <span class="n">name</span> <span class="n">terms</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Pred</span> <span class="n">name</span> <span class="p">(</span><span class="kt">Data</span><span class="o">.</span><span class="kt">List</span><span class="o">.</span><span class="n">map</span> <span class="p">(</span><span class="n">termFromLN</span> <span class="n">env</span><span class="p">)</span> <span class="n">terms</span><span class="p">)</span>
      <span class="kr">where</span>
        <span class="c1">-- Translates a locally nameless term to a named variable term.</span>
        <span class="cm">{-</span>
<span class="cm">        The mapping is from the De Bruijn index of each binding variable at the</span>
<span class="cm">        current depth to its name.</span>
<span class="cm">        -}</span>
        <span class="n">termFromLN</span> <span class="ow">::</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">Map</span><span class="o">.</span><span class="kt">Map</span> <span class="kt">Int</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Term</span> <span class="kt">LN</span> <span class="ow">-&gt;</span> <span class="kt">Term</span> <span class="kt">NV</span>
        <span class="n">termFromLN</span> <span class="n">env</span> <span class="p">(</span><span class="kt">Var</span> <span class="n">v</span><span class="p">)</span> <span class="ow">=</span>
          <span class="kr">case</span> <span class="n">v</span> <span class="kr">of</span>
            <span class="c1">-- This is a free variable.</span>
            <span class="kt">F</span> <span class="n">name</span>  <span class="ow">-&gt;</span> <span class="kt">Var</span> <span class="n">name</span>
            <span class="c1">-- This is a bound variable.</span>
            <span class="kt">B</span> <span class="n">index</span> <span class="ow">-&gt;</span> <span class="kr">case</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">Map</span><span class="o">.</span><span class="n">lookup</span> <span class="n">index</span> <span class="n">env</span> <span class="kr">of</span>
                         <span class="kt">Just</span> <span class="n">name</span> <span class="ow">-&gt;</span> <span class="kt">Var</span> <span class="n">name</span>
                         <span class="kt">Nothing</span> <span class="ow">-&gt;</span> <span class="ne">error</span> <span class="s">"Bound variable has no binder."</span>
        <span class="n">termFromLN</span> <span class="n">env</span> <span class="p">(</span><span class="kt">Func</span> <span class="n">name</span> <span class="n">terms</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Func</span> <span class="n">name</span> <span class="p">(</span><span class="kt">Data</span><span class="o">.</span><span class="kt">List</span><span class="o">.</span><span class="n">map</span> <span class="p">(</span><span class="n">termFromLN</span> <span class="n">env</span><span class="p">)</span> <span class="n">terms</span><span class="p">)</span>
    <span class="n">go</span> <span class="n">env</span> <span class="p">(</span><span class="kt">Not</span> <span class="n">p</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Not</span> <span class="p">(</span><span class="n">go</span> <span class="n">env</span> <span class="n">p</span><span class="p">)</span>
    <span class="n">go</span> <span class="n">env</span> <span class="p">(</span><span class="kt">And</span> <span class="n">p</span> <span class="n">q</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">And</span> <span class="p">(</span><span class="n">go</span> <span class="n">env</span> <span class="n">p</span><span class="p">)</span> <span class="p">(</span><span class="n">go</span> <span class="n">env</span> <span class="n">q</span><span class="p">)</span>
    <span class="n">go</span> <span class="n">env</span> <span class="p">(</span><span class="kt">Or</span> <span class="n">p</span> <span class="n">q</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Or</span> <span class="p">(</span><span class="n">go</span> <span class="n">env</span> <span class="n">p</span><span class="p">)</span> <span class="p">(</span><span class="n">go</span> <span class="n">env</span> <span class="n">q</span><span class="p">)</span>
    <span class="n">go</span> <span class="n">env</span> <span class="p">(</span><span class="kt">Imp</span> <span class="n">p</span> <span class="n">q</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Imp</span> <span class="p">(</span><span class="n">go</span> <span class="n">env</span> <span class="n">p</span><span class="p">)</span> <span class="p">(</span><span class="n">go</span> <span class="n">env</span> <span class="n">q</span><span class="p">)</span>
    <span class="n">go</span> <span class="n">env</span> <span class="p">(</span><span class="kt">Iff</span> <span class="n">p</span> <span class="n">q</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Iff</span> <span class="p">(</span><span class="n">go</span> <span class="n">env</span> <span class="n">p</span><span class="p">)</span> <span class="p">(</span><span class="n">go</span> <span class="n">env</span> <span class="n">q</span><span class="p">)</span>
    <span class="n">go</span> <span class="n">env</span> <span class="p">(</span><span class="kt">Forall</span> <span class="n">v</span> <span class="n">p</span><span class="p">)</span> <span class="ow">=</span>
      <span class="kr">case</span> <span class="n">v</span> <span class="kr">of</span>
        <span class="kt">B</span> <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="ne">error</span> <span class="s">"Bound variable at binding site."</span>
        <span class="cm">{-</span>
<span class="cm">        Since a binding variable has been gone under, the</span>
<span class="cm">        De Bruijn index of each binding variable at the</span>
<span class="cm">        current depth is increased by 1 and the De Bruijn</span>
<span class="cm">        index of the encountered binding variable at the</span>
<span class="cm">        current depth is set to 0.</span>
<span class="cm">        -}</span>
        <span class="kt">F</span> <span class="n">name</span> <span class="ow">-&gt;</span> <span class="kr">let</span> <span class="n">env'</span> <span class="ow">=</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">Map</span><span class="o">.</span><span class="n">insert</span> <span class="mi">0</span> <span class="n">name</span> <span class="p">(</span><span class="kt">Data</span><span class="o">.</span><span class="kt">Map</span><span class="o">.</span><span class="n">mapKeysMonotonic</span> <span class="p">(</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="n">env</span><span class="p">)</span> <span class="kr">in</span>
                             <span class="kt">Forall</span> <span class="n">name</span> <span class="p">(</span><span class="n">go</span> <span class="n">env'</span> <span class="n">p</span><span class="p">)</span>
    <span class="n">go</span> <span class="n">env</span> <span class="p">(</span><span class="kt">Exists</span> <span class="n">v</span> <span class="n">p</span><span class="p">)</span> <span class="ow">=</span>
      <span class="kr">case</span> <span class="n">v</span> <span class="kr">of</span>
        <span class="kt">B</span> <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="ne">error</span> <span class="s">"Bound variable at binding site."</span>
        <span class="kt">F</span> <span class="n">name</span> <span class="ow">-&gt;</span> <span class="kr">let</span> <span class="n">env'</span> <span class="ow">=</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">Map</span><span class="o">.</span><span class="n">insert</span> <span class="mi">0</span> <span class="n">name</span> <span class="p">(</span><span class="kt">Data</span><span class="o">.</span><span class="kt">Map</span><span class="o">.</span><span class="n">mapKeysMonotonic</span> <span class="p">(</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="n">env</span><span class="p">)</span> <span class="kr">in</span>
                             <span class="kt">Exists</span> <span class="n">name</span> <span class="p">(</span><span class="n">go</span> <span class="n">env'</span> <span class="n">p</span><span class="p">)</span>
</code></pre></div>



<a name="267328262"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/267328262" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#267328262">(Jan 09 2022 at 01:44)</a>:</h4>
<p>Or do you only replace bound variables, even in the natural deduction rules?</p>



<a name="267328399"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/267328399" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#267328399">(Jan 09 2022 at 01:46)</a>:</h4>
<p>That is, the <code>a[b/c]</code> instances in these rules:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">ForallIntro</span><span class="o">:</span> <span class="o">(</span><span class="n">gamma</span> <span class="bp">|-</span> <span class="n">p</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="n">not</span> <span class="n">free</span> <span class="k">in</span> <span class="n">gamma</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="n">gamma</span> <span class="bp">|-</span> <span class="k">forall</span> <span class="n">x.</span> <span class="n">p</span><span class="o">)</span>
<span class="n">ForallElim</span><span class="o">:</span> <span class="o">(</span><span class="n">gamma</span> <span class="bp">|-</span> <span class="k">forall</span> <span class="n">x.</span> <span class="n">p</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="n">admits</span> <span class="n">t</span> <span class="n">for</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="n">gamma</span> <span class="bp">|-</span> <span class="n">p</span><span class="o">[</span><span class="n">t</span><span class="bp">/</span><span class="n">x</span><span class="o">])</span>
<span class="n">ExistsIntro</span><span class="o">:</span> <span class="o">(</span><span class="n">gamma</span> <span class="bp">|-</span> <span class="n">p</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="n">admits</span> <span class="n">x</span> <span class="n">for</span> <span class="n">t</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="n">gamma</span> <span class="bp">|-</span> <span class="n">exists</span> <span class="n">x.</span> <span class="n">p</span> <span class="o">[</span><span class="n">x</span><span class="bp">/</span><span class="n">t</span><span class="o">])</span>
<span class="n">ExistsElim</span><span class="o">:</span> <span class="o">(</span><span class="n">gamma</span> <span class="bp">|-</span> <span class="n">exists</span> <span class="n">x.</span> <span class="n">p</span><span class="o">)</span> <span class="o">(</span><span class="n">gamma</span><span class="o">,</span> <span class="n">p</span> <span class="o">[</span><span class="n">y</span><span class="bp">/</span><span class="n">x</span><span class="o">]</span> <span class="bp">|-</span> <span class="n">q</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="n">not</span> <span class="n">free</span> <span class="k">in</span> <span class="n">q</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="n">not</span> <span class="n">free</span> <span class="k">in</span> <span class="n">gamma</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="n">gamma</span> <span class="bp">|-</span> <span class="n">q</span><span class="o">)</span>
<span class="n">Substitution</span><span class="o">:</span> <span class="o">(</span><span class="n">gamma</span> <span class="bp">|-</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">t</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="n">gamma</span> <span class="bp">|-</span> <span class="n">p</span> <span class="bp">=</span> <span class="n">p</span> <span class="o">[</span><span class="n">t</span><span class="bp">/</span><span class="n">s</span><span class="o">])</span>
</code></pre></div>



<a name="267328475"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/267328475" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#267328475">(Jan 09 2022 at 01:48)</a>:</h4>
<p>The full code for reference:<br>
<a href="/user_uploads/3121/U_K1bfiA6zq-1hP6s5Qybd1L/nd.hs">nd.hs</a></p>



<a name="267340670"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/267340670" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Trebor Huang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#267340670">(Jan 09 2022 at 07:02)</a>:</h4>
<p>You can read the paper by Conor McBride on locally nameless. It's easily understandable, and demonstrates exactly how it is beneficial.</p>



<a name="267340688"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/267340688" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Trebor Huang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#267340688">(Jan 09 2022 at 07:03)</a>:</h4>
<p>In particular, every time you move inside a binder, you generate a free name (which, remarkably, doesn't require a monad or anything whatsoever) and substitute every occurence of the variable being unbound.</p>



<a name="267340743"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/267340743" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Trebor Huang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#267340743">(Jan 09 2022 at 07:05)</a>:</h4>
<p>And when you move out, you abstract one named variable into an unnamed one, and bind it. This pair of <code>instantiate</code> and <code>abstract</code> functions enables clean and intuitive manipulation.</p>



<a name="267343155"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/267343155" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stuart Presnell <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#267343155">(Jan 09 2022 at 08:00)</a>:</h4>
<p>Is that McBride &amp; McKinna, “I am not a Number—I am a Free Variable” (<a href="https://www.cs.ru.nl/~james/RESEARCH/haskell2004.pdf">https://www.cs.ru.nl/~james/RESEARCH/haskell2004.pdf</a>)?</p>



<a name="267347546"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/267347546" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Trebor Huang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#267347546">(Jan 09 2022 at 09:08)</a>:</h4>
<p>yep</p>



<a name="267347598"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/267347598" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Trebor Huang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#267347598">(Jan 09 2022 at 09:09)</a>:</h4>
<p>The functional pearl version is slightly better in terms of formatting and convention, but that's a matter of taste.</p>



<a name="267363509"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/267363509" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#267363509">(Jan 09 2022 at 15:38)</a>:</h4>
<p>In the lambda calculus you are only substituting for variables bound by a lambda, correct? But in the rules for natural deduction, you are also substituting for variables that are not bound (by a forall or exists), like in the ExistsElim and Substitution rules listed above?</p>



<a name="267377770"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/267377770" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#267377770">(Jan 09 2022 at 21:07)</a>:</h4>
<p>Can the natural deduction rules be derived from the axioms of the first system?</p>



<a name="267379103"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/267379103" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#267379103">(Jan 09 2022 at 21:38)</a>:</h4>
<p>Are there any forums that are more broadly dedicated to mathematical logic and,or its implementation in code that would be better suited to these kinds of questions? I only know of this and <a href="https://math.stackexchange.com/">https://math.stackexchange.com/</a>.</p>



<a name="267398777"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/267398777" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#267398777">(Jan 10 2022 at 06:02)</a>:</h4>
<p>Updated to full classical FOL + equality:</p>
<div class="codehilite" data-code-language="Haskell"><pre><span></span><code><span class="kr">import</span> <span class="nn">Data.List</span>


<span class="kr">data</span> <span class="kt">Term</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Var</span> <span class="n">a</span>
            <span class="o">|</span> <span class="kt">Func</span> <span class="kt">String</span> <span class="p">[</span><span class="kt">Term</span> <span class="n">a</span><span class="p">]</span> <span class="c1">-- Func "c" [] : A constant named "c" ; -- Func "f" [v] : A function named "f" of one variable v</span>
              <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">)</span>

<span class="kr">data</span> <span class="kt">Formula</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Pred</span> <span class="kt">String</span> <span class="p">[</span><span class="kt">Term</span> <span class="n">a</span><span class="p">]</span> <span class="c1">-- Pred "P" [] : A propositional variable named "P" ; Pred "Eq" [s, t] : s = t</span>
               <span class="o">|</span> <span class="kt">Not</span> <span class="p">(</span><span class="kt">Formula</span> <span class="n">a</span><span class="p">)</span>
               <span class="o">|</span> <span class="kt">Imp</span> <span class="p">(</span><span class="kt">Formula</span> <span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="kt">Formula</span> <span class="n">a</span><span class="p">)</span>
               <span class="o">|</span> <span class="kt">Forall</span> <span class="n">a</span> <span class="p">(</span><span class="kt">Formula</span> <span class="n">a</span><span class="p">)</span>
                 <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">)</span>

<span class="kr">newtype</span> <span class="kt">Theorem</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Theorem</span> <span class="p">(</span><span class="kt">Formula</span> <span class="n">a</span><span class="p">)</span>
                    <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">)</span>

<span class="cm">{-</span>
<span class="cm">From "First Order Mathematical Logic" by Angelo Margaris:</span>

<span class="cm">An occurrence of a variable $v$ in a formula $P$ is bound if and only if</span>
<span class="cm">it occurs in a subformula of $P$ of the form $\forall v Q$. An occurrence</span>
<span class="cm">of $v$ in $P$ is free if and only if it is not a bound occurrence. The</span>
<span class="cm">variable $v$ is free or bound in $P$ according as it has a free or bound</span>
<span class="cm"> occurrence in $P$.</span>

<span class="cm">If $P$ is a formula, $v$ is a variable, and $t$ is a term, then $P(t/v)$ is</span>
<span class="cm">the result of replacing each free occurrence of $v$ in $P$ by an occurrence</span>
<span class="cm">of $t$.</span>

<span class="cm">If $v$ and $u$ are variables and $P$ is a formula, then $P$ admits $u$ for $v$</span>
<span class="cm">if and only if there is no free occurrence of $v$ in $P$ that becomes a</span>
<span class="cm">bound occurrence of $u$ in $P(u/v)$. If $t$ is a term, then $P$ admits $t$ for</span>
<span class="cm">$v$ if and only if $P$ admits for $v$ every variable in $t$.</span>
<span class="cm">-}</span>


<span class="c1">-- occursInTerm v t = there exists an occurrence of v in t.</span>
<span class="nf">occursInTerm</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Term</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">occursInTerm</span> <span class="n">v</span> <span class="p">(</span><span class="kt">Var</span> <span class="n">v'</span><span class="p">)</span> <span class="ow">=</span> <span class="n">v</span> <span class="o">==</span> <span class="n">v'</span>
<span class="nf">occursInTerm</span> <span class="n">v</span> <span class="p">(</span><span class="kt">Func</span> <span class="kr">_</span> <span class="n">terms</span><span class="p">)</span> <span class="ow">=</span> <span class="n">any</span> <span class="p">(</span><span class="n">occursInTerm</span> <span class="n">v</span><span class="p">)</span> <span class="n">terms</span>

<span class="c1">-- freeIn v p = there exists an occurrence of v in p that is free.</span>
<span class="nf">freeIn</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Formula</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">freeIn</span> <span class="n">v</span> <span class="p">(</span><span class="kt">Pred</span> <span class="kr">_</span> <span class="n">terms</span><span class="p">)</span> <span class="ow">=</span> <span class="n">any</span> <span class="p">(</span><span class="n">occursInTerm</span> <span class="n">v</span><span class="p">)</span> <span class="n">terms</span>
<span class="nf">freeIn</span> <span class="n">v</span> <span class="p">(</span><span class="kt">Not</span> <span class="n">p</span><span class="p">)</span> <span class="ow">=</span> <span class="n">freeIn</span> <span class="n">v</span> <span class="n">p</span>
<span class="nf">freeIn</span> <span class="n">v</span> <span class="p">(</span><span class="kt">Imp</span> <span class="n">p</span> <span class="n">q</span><span class="p">)</span> <span class="ow">=</span> <span class="n">freeIn</span> <span class="n">v</span> <span class="n">p</span> <span class="o">||</span> <span class="n">freeIn</span> <span class="n">v</span> <span class="n">q</span>
<span class="nf">freeIn</span> <span class="n">v</span> <span class="p">(</span><span class="kt">Forall</span> <span class="n">v'</span> <span class="n">p</span><span class="p">)</span> <span class="ow">=</span> <span class="n">v</span> <span class="o">/=</span> <span class="n">v'</span> <span class="o">&amp;&amp;</span> <span class="n">freeIn</span> <span class="n">v</span> <span class="n">p</span>


<span class="cm">{-</span>
<span class="cm">subInFormula p t v = p(t/v) = the result of replacing each free occurrence of</span>
<span class="cm">v in p by an occurrence of t.</span>
<span class="cm">-}</span>
<span class="nf">subInFormula</span> <span class="ow">::</span> <span class="kt">Formula</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Term</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Formula</span> <span class="kt">String</span>
<span class="nf">subInFormula</span> <span class="p">(</span><span class="kt">Pred</span> <span class="n">name</span> <span class="n">terms</span><span class="p">)</span> <span class="n">t</span> <span class="n">v</span> <span class="ow">=</span> <span class="kt">Pred</span> <span class="n">name</span> <span class="p">(</span><span class="kt">Data</span><span class="o">.</span><span class="kt">List</span><span class="o">.</span><span class="n">map</span> <span class="p">(</span><span class="nf">\</span><span class="n">t'</span> <span class="ow">-&gt;</span> <span class="n">subInTerm</span> <span class="n">t'</span> <span class="n">t</span> <span class="n">v</span><span class="p">)</span> <span class="n">terms</span><span class="p">)</span>
  <span class="kr">where</span>
    <span class="cm">{-</span>
<span class="cm">    subInTerm s t v = the result of replacing each occurrence of v in s by</span>
<span class="cm">    an occurrence of t.</span>
<span class="cm">    -}</span>
    <span class="n">subInTerm</span> <span class="ow">::</span> <span class="kt">Term</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Term</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Term</span> <span class="kt">String</span>
    <span class="n">subInTerm</span> <span class="p">(</span><span class="kt">Var</span> <span class="n">v'</span><span class="p">)</span> <span class="n">t</span> <span class="n">v</span> <span class="ow">=</span> <span class="kr">if</span> <span class="n">v</span> <span class="o">==</span> <span class="n">v'</span> <span class="kr">then</span> <span class="n">t</span> <span class="kr">else</span> <span class="kt">Var</span> <span class="n">v'</span>
    <span class="n">subInTerm</span> <span class="p">(</span><span class="kt">Func</span> <span class="n">name</span> <span class="n">terms</span><span class="p">)</span> <span class="n">t</span> <span class="n">v</span> <span class="ow">=</span> <span class="kt">Func</span> <span class="n">name</span> <span class="p">(</span><span class="kt">Data</span><span class="o">.</span><span class="kt">List</span><span class="o">.</span><span class="n">map</span> <span class="p">(</span><span class="nf">\</span><span class="n">t'</span> <span class="ow">-&gt;</span> <span class="n">subInTerm</span> <span class="n">t'</span> <span class="n">t</span> <span class="n">v</span><span class="p">)</span> <span class="n">terms</span><span class="p">)</span>
<span class="nf">subInFormula</span> <span class="p">(</span><span class="kt">Not</span> <span class="n">p</span><span class="p">)</span> <span class="n">t</span> <span class="n">v</span> <span class="ow">=</span> <span class="kt">Not</span> <span class="p">(</span><span class="n">subInFormula</span> <span class="n">p</span> <span class="n">t</span> <span class="n">v</span><span class="p">)</span>
<span class="nf">subInFormula</span> <span class="p">(</span><span class="kt">Imp</span> <span class="n">p</span> <span class="n">q</span><span class="p">)</span> <span class="n">t</span> <span class="n">v</span> <span class="ow">=</span> <span class="kt">Imp</span> <span class="p">(</span><span class="n">subInFormula</span> <span class="n">p</span> <span class="n">t</span> <span class="n">v</span><span class="p">)</span> <span class="p">(</span><span class="n">subInFormula</span> <span class="n">q</span> <span class="n">t</span> <span class="n">v</span><span class="p">)</span>
<span class="nf">subInFormula</span> <span class="p">(</span><span class="kt">Forall</span> <span class="n">v'</span> <span class="n">p</span><span class="p">)</span> <span class="n">t</span> <span class="n">v</span> <span class="ow">=</span> <span class="kr">if</span> <span class="n">v</span> <span class="o">==</span> <span class="n">v'</span> <span class="kr">then</span> <span class="kt">Forall</span> <span class="n">v'</span> <span class="n">p</span> <span class="kr">else</span> <span class="kt">Forall</span> <span class="n">v'</span> <span class="p">(</span><span class="n">subInFormula</span> <span class="n">p</span> <span class="n">t</span> <span class="n">v</span><span class="p">)</span>


<span class="cm">{-</span>
<span class="cm">admitsVar p u v = p admits u for v = there is no free occurrence of</span>
<span class="cm">v in p that becomes a bound occurrence of u in p(u/v).</span>
<span class="cm">-}</span>
<span class="nf">admitsVar</span> <span class="ow">::</span> <span class="kt">Formula</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">admitsVar</span> <span class="n">p</span> <span class="n">u</span> <span class="n">v</span> <span class="ow">=</span> <span class="n">go</span> <span class="n">p</span> <span class="n">u</span> <span class="n">v</span> <span class="kt">[]</span>
  <span class="kr">where</span>
    <span class="n">go</span> <span class="ow">::</span> <span class="kt">Formula</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
    <span class="n">go</span> <span class="p">(</span><span class="kt">Pred</span> <span class="kr">_</span> <span class="n">terms</span><span class="p">)</span> <span class="n">u</span> <span class="n">v</span> <span class="n">binders</span> <span class="ow">=</span> <span class="n">not</span> <span class="p">(</span><span class="n">any</span> <span class="p">(</span><span class="n">occursInTerm</span> <span class="n">v</span><span class="p">)</span> <span class="n">terms</span><span class="p">)</span> <span class="o">||</span> <span class="n">elem</span> <span class="n">v</span> <span class="n">binders</span> <span class="o">||</span> <span class="n">notElem</span> <span class="n">u</span> <span class="n">binders</span>
    <span class="n">go</span> <span class="p">(</span><span class="kt">Not</span> <span class="n">p</span><span class="p">)</span> <span class="n">u</span> <span class="n">v</span> <span class="n">binders</span> <span class="ow">=</span> <span class="n">go</span> <span class="n">p</span> <span class="n">u</span> <span class="n">v</span> <span class="n">binders</span>
    <span class="n">go</span> <span class="p">(</span><span class="kt">Imp</span> <span class="n">p</span> <span class="n">q</span><span class="p">)</span> <span class="n">u</span> <span class="n">v</span> <span class="n">binders</span> <span class="ow">=</span> <span class="n">go</span> <span class="n">p</span> <span class="n">u</span> <span class="n">v</span> <span class="n">binders</span> <span class="o">&amp;&amp;</span> <span class="n">go</span> <span class="n">q</span> <span class="n">u</span> <span class="n">v</span> <span class="n">binders</span>
    <span class="n">go</span> <span class="p">(</span><span class="kt">Forall</span> <span class="n">v'</span> <span class="n">p</span><span class="p">)</span> <span class="n">u</span> <span class="n">v</span> <span class="n">binders</span> <span class="ow">=</span> <span class="n">go</span> <span class="n">p</span> <span class="n">u</span> <span class="n">v</span> <span class="p">(</span><span class="n">v'</span> <span class="kt">:</span> <span class="n">binders</span><span class="p">)</span>

<span class="cm">{-</span>
<span class="cm">admitsTerm p t v = p admits for v every variable in t.</span>
<span class="cm">-}</span>
<span class="nf">admitsTerm</span> <span class="ow">::</span> <span class="kt">Formula</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Term</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">admitsTerm</span> <span class="n">p</span> <span class="p">(</span><span class="kt">Var</span> <span class="n">u</span><span class="p">)</span> <span class="n">v</span> <span class="ow">=</span> <span class="n">admitsVar</span> <span class="n">p</span> <span class="n">u</span> <span class="n">v</span>
<span class="nf">admitsTerm</span> <span class="n">p</span> <span class="p">(</span><span class="kt">Func</span> <span class="kr">_</span> <span class="n">terms</span><span class="p">)</span> <span class="n">v</span> <span class="ow">=</span> <span class="n">all</span> <span class="p">(</span><span class="nf">\</span><span class="n">t</span> <span class="ow">-&gt;</span> <span class="n">admitsTerm</span> <span class="n">p</span> <span class="n">t</span> <span class="n">v</span><span class="p">)</span> <span class="n">terms</span>


<span class="c1">-- Propositional calculus</span>

<span class="c1">-- |- (p -&gt; (q -&gt; p))</span>
<span class="nf">prop_1</span> <span class="ow">::</span> <span class="kt">Formula</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Formula</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Theorem</span> <span class="kt">String</span>
<span class="nf">prop_1</span> <span class="n">p</span> <span class="n">q</span> <span class="ow">=</span> <span class="kt">Theorem</span> <span class="p">(</span><span class="kt">Imp</span> <span class="n">p</span> <span class="p">(</span><span class="kt">Imp</span> <span class="n">q</span> <span class="n">p</span><span class="p">))</span>

<span class="c1">-- |- ((p -&gt; (q -&gt; r)) -&gt; ((p -&gt; q) -&gt; (p -&gt; r)))</span>
<span class="nf">prop_2</span> <span class="ow">::</span> <span class="kt">Formula</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Formula</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Formula</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Theorem</span> <span class="kt">String</span>
<span class="nf">prop_2</span> <span class="n">p</span> <span class="n">q</span> <span class="n">r</span> <span class="ow">=</span> <span class="kt">Theorem</span> <span class="p">(</span><span class="kt">Imp</span> <span class="p">(</span><span class="kt">Imp</span> <span class="n">p</span> <span class="p">(</span><span class="kt">Imp</span> <span class="n">q</span> <span class="n">r</span><span class="p">))</span> <span class="p">(</span><span class="kt">Imp</span> <span class="p">(</span><span class="kt">Imp</span> <span class="n">p</span> <span class="n">q</span><span class="p">)</span> <span class="p">(</span><span class="kt">Imp</span> <span class="n">p</span> <span class="n">r</span><span class="p">)))</span>

<span class="c1">-- |- ((~p -&gt; ~q) -&gt; (q -&gt; p))</span>
<span class="nf">prop_3</span> <span class="ow">::</span> <span class="kt">Formula</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Formula</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Theorem</span> <span class="kt">String</span>
<span class="nf">prop_3</span> <span class="n">p</span> <span class="n">q</span> <span class="ow">=</span> <span class="kt">Theorem</span> <span class="p">(</span><span class="kt">Imp</span> <span class="p">(</span><span class="kt">Imp</span> <span class="p">(</span><span class="kt">Not</span> <span class="n">p</span><span class="p">)</span> <span class="p">(</span><span class="kt">Not</span> <span class="n">q</span><span class="p">))</span> <span class="p">(</span><span class="kt">Imp</span> <span class="n">q</span> <span class="n">p</span><span class="p">))</span>

<span class="c1">-- |- p &amp; |- (p -&gt; q) =&gt; |- q</span>
<span class="nf">mp</span> <span class="ow">::</span> <span class="kt">Theorem</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Theorem</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Theorem</span> <span class="kt">String</span>
<span class="nf">mp</span> <span class="p">(</span><span class="kt">Theorem</span> <span class="n">p</span><span class="p">)</span> <span class="p">(</span><span class="kt">Theorem</span> <span class="p">(</span><span class="kt">Imp</span> <span class="n">p'</span> <span class="n">q</span><span class="p">))</span> <span class="ow">=</span> <span class="kr">if</span> <span class="n">p</span> <span class="o">==</span> <span class="n">p'</span> <span class="kr">then</span> <span class="kt">Theorem</span> <span class="n">q</span> <span class="kr">else</span> <span class="ne">error</span> <span class="s">"mp"</span>
<span class="nf">mp</span> <span class="kr">_</span> <span class="kr">_</span> <span class="ow">=</span> <span class="ne">error</span> <span class="s">"mp"</span>


<span class="c1">-- Predicate calculus</span>

<span class="c1">-- |- p =&gt; |- forall v. p</span>
<span class="nf">gen</span> <span class="ow">::</span> <span class="kt">Theorem</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Theorem</span> <span class="kt">String</span>
<span class="nf">gen</span> <span class="p">(</span><span class="kt">Theorem</span> <span class="n">p</span><span class="p">)</span> <span class="n">v</span> <span class="ow">=</span> <span class="kt">Theorem</span> <span class="p">(</span><span class="kt">Forall</span> <span class="n">v</span> <span class="n">p</span><span class="p">)</span>

<span class="c1">-- |- ((forall v. (p -&gt; q)) -&gt; (forall v. p) -&gt; (forall v. q))</span>
<span class="nf">pred_1</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Formula</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Formula</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Theorem</span> <span class="kt">String</span>
<span class="nf">pred_1</span> <span class="n">v</span> <span class="n">p</span> <span class="n">q</span> <span class="ow">=</span> <span class="kt">Theorem</span> <span class="p">(</span><span class="kt">Imp</span> <span class="p">(</span><span class="kt">Forall</span> <span class="n">v</span> <span class="p">(</span><span class="kt">Imp</span> <span class="n">p</span> <span class="n">q</span><span class="p">))</span> <span class="p">(</span><span class="kt">Imp</span> <span class="p">(</span><span class="kt">Forall</span> <span class="n">v</span> <span class="n">p</span><span class="p">)</span> <span class="p">(</span><span class="kt">Forall</span> <span class="n">v</span> <span class="n">q</span><span class="p">)))</span>

<span class="c1">-- |- (forall v. p -&gt; p [t/v]) provided p admits t for v</span>
<span class="nf">pred_2</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Formula</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Term</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Theorem</span> <span class="kt">String</span>
<span class="nf">pred_2</span> <span class="n">v</span> <span class="n">p</span> <span class="n">t</span> <span class="ow">=</span> <span class="kr">if</span> <span class="n">admitsTerm</span> <span class="n">p</span> <span class="n">t</span> <span class="n">v</span> <span class="kr">then</span> <span class="kt">Theorem</span> <span class="p">(</span><span class="kt">Imp</span> <span class="p">(</span><span class="kt">Forall</span> <span class="n">v</span> <span class="n">p</span><span class="p">)</span> <span class="p">(</span><span class="n">subInFormula</span> <span class="n">p</span> <span class="n">t</span> <span class="n">v</span><span class="p">))</span> <span class="kr">else</span> <span class="ne">error</span> <span class="s">"pred_2"</span>

<span class="c1">-- |- (p -&gt; forall v. p) provided v is not free in p</span>
<span class="nf">pred_3</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Formula</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Theorem</span> <span class="kt">String</span>
<span class="nf">pred_3</span> <span class="n">v</span> <span class="n">p</span> <span class="ow">=</span> <span class="kr">if</span> <span class="n">not</span> <span class="p">(</span><span class="n">freeIn</span> <span class="n">v</span> <span class="n">p</span><span class="p">)</span> <span class="kr">then</span> <span class="kt">Theorem</span> <span class="p">(</span><span class="kt">Imp</span> <span class="n">p</span> <span class="p">(</span><span class="kt">Forall</span> <span class="n">v</span> <span class="n">p</span><span class="p">))</span> <span class="kr">else</span> <span class="ne">error</span> <span class="s">"pred_3"</span>


<span class="c1">-- Equality</span>

<span class="nf">itList2</span> <span class="ow">::</span> <span class="p">(</span><span class="n">t1</span> <span class="ow">-&gt;</span> <span class="n">t2</span> <span class="ow">-&gt;</span> <span class="n">t3</span> <span class="ow">-&gt;</span> <span class="n">t3</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">t1</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">t2</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">t3</span> <span class="ow">-&gt;</span> <span class="n">t3</span>
<span class="nf">itList2</span> <span class="kr">_</span> <span class="kt">[]</span> <span class="kt">[]</span> <span class="n">b</span> <span class="ow">=</span> <span class="n">b</span>
<span class="nf">itList2</span> <span class="n">f</span> <span class="p">(</span><span class="n">h1</span> <span class="kt">:</span> <span class="n">t1</span><span class="p">)</span> <span class="p">(</span><span class="n">h2</span> <span class="kt">:</span> <span class="n">t2</span><span class="p">)</span> <span class="n">b</span> <span class="ow">=</span> <span class="n">f</span> <span class="n">h1</span> <span class="n">h2</span> <span class="p">(</span><span class="n">itList2</span> <span class="n">f</span> <span class="n">t1</span> <span class="n">t2</span> <span class="n">b</span><span class="p">)</span>
<span class="nf">itList2</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span> <span class="ow">=</span> <span class="ne">error</span> <span class="s">"itList2"</span>

<span class="c1">-- |- t = t</span>
<span class="nf">eq_1</span> <span class="ow">::</span> <span class="kt">Term</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Theorem</span> <span class="kt">String</span>
<span class="nf">eq_1</span> <span class="n">t</span> <span class="ow">=</span> <span class="kt">Theorem</span> <span class="p">(</span><span class="kt">Pred</span> <span class="s">"Eq"</span> <span class="p">[</span><span class="n">t</span><span class="p">,</span> <span class="n">t</span><span class="p">])</span>

<span class="c1">-- |- s1 = t1 ==&gt; ... ==&gt; sn = tn ==&gt; f(s1,..,sn) = f(t1,..,tn)</span>
<span class="nf">eq_2</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Term</span> <span class="kt">String</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Term</span> <span class="kt">String</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Theorem</span> <span class="kt">String</span>
<span class="nf">eq_2</span> <span class="n">f</span> <span class="n">lefts</span> <span class="n">rights</span> <span class="ow">=</span> <span class="kt">Theorem</span> <span class="p">(</span>
       <span class="n">itList2</span> <span class="p">(</span><span class="nf">\</span><span class="n">s</span> <span class="n">t</span> <span class="n">p</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Imp</span> <span class="p">(</span><span class="kt">Pred</span> <span class="s">"Eq"</span> <span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">])</span> <span class="n">p</span><span class="p">))</span> <span class="n">lefts</span> <span class="n">rights</span>
               <span class="p">(</span><span class="kt">Pred</span> <span class="s">"Eq"</span> <span class="p">[(</span><span class="kt">Func</span> <span class="n">f</span> <span class="n">lefts</span><span class="p">),</span> <span class="p">(</span><span class="kt">Func</span> <span class="n">f</span> <span class="n">rights</span><span class="p">)])</span>
       <span class="p">)</span>

<span class="c1">-- |- s1 = t1 ==&gt; ... ==&gt; sn = tn ==&gt; P(s1,..,sn) ==&gt; P(t1,..,tn)</span>
<span class="nf">eq_3</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Term</span> <span class="kt">String</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Term</span> <span class="kt">String</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Theorem</span> <span class="kt">String</span>
<span class="nf">eq_3</span> <span class="n">p</span> <span class="n">lefts</span> <span class="n">rights</span> <span class="ow">=</span> <span class="kt">Theorem</span> <span class="p">(</span>
       <span class="n">itList2</span> <span class="p">(</span><span class="nf">\</span><span class="n">s</span> <span class="n">t</span> <span class="n">p</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Imp</span> <span class="p">(</span><span class="kt">Pred</span> <span class="s">"Eq"</span> <span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">])</span> <span class="n">p</span><span class="p">))</span> <span class="n">lefts</span> <span class="n">rights</span>
               <span class="p">(</span><span class="kt">Imp</span> <span class="p">(</span><span class="kt">Pred</span> <span class="n">p</span> <span class="n">lefts</span><span class="p">)</span> <span class="p">(</span><span class="kt">Pred</span> <span class="n">p</span> <span class="n">rights</span><span class="p">))</span>
       <span class="p">)</span>
</code></pre></div>



<a name="267399031"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/267399031" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#267399031">(Jan 10 2022 at 06:07)</a>:</h4>
<p>I'm not certain how this code gets changed if de Bruijn indexes are used instead, especially the axioms.</p>



<a name="267399471"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/267399471" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Trebor Huang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#267399471">(Jan 10 2022 at 06:17)</a>:</h4>
<p>For dBI's you get rid of all the occurence-related stuff, so all the <code>admits</code> disappear. (Or rather, takes another form.)</p>



<a name="267399555"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/267399555" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#267399555">(Jan 10 2022 at 06:18)</a>:</h4>
<p>Why do they disappear, or what other form do they take?</p>



<a name="267400321"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/267400321" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Trebor Huang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#267400321">(Jan 10 2022 at 06:35)</a>:</h4>
<p>You can change <code>admitsTerm</code> to a constant <code>True</code>, because with dBI, accidental binding <em>never</em> happens.</p>



<a name="267400709"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/267400709" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#267400709">(Jan 10 2022 at 06:44)</a>:</h4>
<p>So it is safe in the logic to make all alpha equivalent terms equal? (Which I think happens in dBI?)</p>



<a name="267400742"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/267400742" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#267400742">(Jan 10 2022 at 06:45)</a>:</h4>
<p>The substitution just changes to different alpha equivalent terms to avoid accidental bindings right?</p>



<a name="267401203"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/267401203" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Trebor Huang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#267401203">(Jan 10 2022 at 06:55)</a>:</h4>
<p>There is no alpha equivalence with dBI, there is only strict equality.</p>



<a name="267401261"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/267401261" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Trebor Huang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#267401261">(Jan 10 2022 at 06:56)</a>:</h4>
<p>Substitution don't need to care about accidental bindings, there are none.</p>



<a name="267401368"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/267401368" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#267401368">(Jan 10 2022 at 07:00)</a>:</h4>
<p>I think I see. Thank you.</p>



<a name="267524987"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/267524987" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#267524987">(Jan 11 2022 at 01:15)</a>:</h4>
<p>How do you check if an arbitrary variable is free in a formula using de Bruijn indexes? That is, how do you implement the <code>freeIn</code> function that is used in <code>pred_3</code>?</p>



<a name="267526984"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/267526984" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#267526984">(Jan 11 2022 at 01:43)</a>:</h4>
<p><span class="user-mention" data-user-id="139442">@Patrick Thomas</span> something like this:</p>
<div class="codehilite" data-code-language="Haskell"><pre><span></span><code><span class="nf">freeIn</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Formula</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">freeIn</span> <span class="n">v</span> <span class="p">(</span><span class="kt">Pred</span> <span class="kr">_</span> <span class="n">terms</span><span class="p">)</span> <span class="ow">=</span> <span class="n">any</span> <span class="p">(</span><span class="n">occursInTerm</span> <span class="n">v</span><span class="p">)</span> <span class="n">terms</span>
<span class="nf">freeIn</span> <span class="n">v</span> <span class="p">(</span><span class="kt">Not</span> <span class="n">p</span><span class="p">)</span> <span class="ow">=</span> <span class="n">freeIn</span> <span class="n">v</span> <span class="n">p</span>
<span class="nf">freeIn</span> <span class="n">v</span> <span class="p">(</span><span class="kt">Imp</span> <span class="n">p</span> <span class="n">q</span><span class="p">)</span> <span class="ow">=</span> <span class="n">freeIn</span> <span class="n">v</span> <span class="n">p</span> <span class="o">||</span> <span class="n">freeIn</span> <span class="n">v</span> <span class="n">q</span>
<span class="nf">freeIn</span> <span class="n">v</span> <span class="p">(</span><span class="kt">Forall</span> <span class="n">p</span><span class="p">)</span> <span class="ow">=</span> <span class="n">freeIn</span> <span class="p">(</span><span class="n">v</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="n">p</span>
</code></pre></div>



<a name="267527288"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/267527288" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#267527288">(Jan 11 2022 at 01:48)</a>:</h4>
<p>Should there be an underscore after <code>Forall</code>, ie, <code>freeIn v (Forall _ p) = freeIn (v + 1) p</code>?</p>



<a name="267527331"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/267527331" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#267527331">(Jan 11 2022 at 01:49)</a>:</h4>
<p>No, I guess there wouldn't be, would there.</p>



<a name="267527595"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/267527595" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#267527595">(Jan 11 2022 at 01:54)</a>:</h4>
<p>only if you want to track the variable name as metadata, it's not part of the main de bruijn implementation</p>



<a name="267527729"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/267527729" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#267527729">(Jan 11 2022 at 01:57)</a>:</h4>
<p>So if a standalone variable becomes bound, its "name" before becoming bound is irrecoverably lost, because it gets changed to the index of its new binder?</p>



<a name="267527832"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/267527832" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#267527832">(Jan 11 2022 at 01:58)</a>:</h4>
<p>In pure de bruijn there are no names to begin with, so nothing is lost. In locally nameless, the variable name is lost when you abstract a named variable, so you put it in the binder's metadata (the <code>var_name</code> field in <a href="https://leanprover-community.github.io/mathlib_docs/find/expr.pi/src">src#expr.pi</a>)</p>



<a name="267528065"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/267528065" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#267528065">(Jan 11 2022 at 02:01)</a>:</h4>
<p>I'm not sure I understand. If there are no names to begin with, how do you compare variables? The <code>v</code> in the function <code>freeIn</code> isn't the name?</p>



<a name="267528151"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/267528151" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#267528151">(Jan 11 2022 at 02:02)</a>:</h4>
<p>Or maybe identifier is a better term than name?</p>



<a name="267528267"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/267528267" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#267528267">(Jan 11 2022 at 02:05)</a>:</h4>
<p>If you want to consider the numbers in de bruijn variables as "names", then it's not true that they are lost when abstracting, they just get bumped up by 1</p>



<a name="267528290"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/267528290" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#267528290">(Jan 11 2022 at 02:05)</a>:</h4>
<p>free variables in de bruijn are represented as variables with numbers greater than the current binder depth</p>



<a name="267528486"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/267528486" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#267528486">(Jan 11 2022 at 02:09)</a>:</h4>
<p>But if the get bound, they are lost right? For example, we start out with the standalone variable "5". If we want to bind it, it becomes <code>lam 1</code>?</p>



<a name="267528553"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/267528553" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#267528553">(Jan 11 2022 at 02:10)</a>:</h4>
<p>As in, x -&gt; forall x.</p>



<a name="267528584"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/267528584" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#267528584">(Jan 11 2022 at 02:11)</a>:</h4>
<p><code>lam 0</code>, but yes</p>



<a name="267528640"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/267528640" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#267528640">(Jan 11 2022 at 02:12)</a>:</h4>
<p>If it's about to be bound then it should already be variable 0</p>



<a name="267528670"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/267528670" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#267528670">(Jan 11 2022 at 02:13)</a>:</h4>
<p>so all you have to do is put the <code>lam</code> constructor on</p>



<a name="267528695"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/267528695" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#267528695">(Jan 11 2022 at 02:13)</a>:</h4>
<p>Why would it already be zero?</p>



<a name="267528753"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/267528753" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#267528753">(Jan 11 2022 at 02:14)</a>:</h4>
<p>because you already know the order that variables will be bound and have arranged the free vars to come in that order</p>



<a name="267528765"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/267528765" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#267528765">(Jan 11 2022 at 02:14)</a>:</h4>
<p>if you can't do that then de bruijn doesn't have any extra advantages compared to locally nameless</p>



<a name="267528804"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/267528804" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#267528804">(Jan 11 2022 at 02:15)</a>:</h4>
<p>but for example if you are generating the term by traversing an expression from the outside in, it is not hard to arrange things so that you know what variable is the next one to be bound</p>



<a name="267528884"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/267528884" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#267528884">(Jan 11 2022 at 02:16)</a>:</h4>
<p>You mean in going from named variables to de bruijn?</p>



<a name="267528896"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/267528896" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#267528896">(Jan 11 2022 at 02:17)</a>:</h4>
<p>yes</p>



<a name="267528918"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/267528918" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#267528918">(Jan 11 2022 at 02:17)</a>:</h4>
<p>which is probably something you have to do if you are writing a proof assistant and users write terms with named variables</p>



<a name="267529097"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/267529097" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#267529097">(Jan 11 2022 at 02:21)</a>:</h4>
<p>Do you have to keep track of all of this as a global state for the entire proof, or just individually for each separate term?</p>



<a name="267529175"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/267529175" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#267529175">(Jan 11 2022 at 02:23)</a>:</h4>
<p>Just for each term right?</p>



<a name="267529471"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/267529471" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#267529471">(Jan 11 2022 at 02:29)</a>:</h4>
<p>Would this be a useful kernal for a proof assistant? What would its drawbacks be in comparison to others? Are there any advantages?</p>



<a name="267687122"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/267687122" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#267687122">(Jan 12 2022 at 06:35)</a>:</h4>
<p>How do <code>gen</code> and <code>pred_3</code> get modified? Do you no longer specify which variable to bind with the forall?</p>



<a name="267687292"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/267687292" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#267687292">(Jan 12 2022 at 06:39)</a>:</h4>
<p>Is that going to break the logic, that you can no longer pick which variable to bind?</p>



<a name="267692348"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/267692348" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Trebor Huang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#267692348">(Jan 12 2022 at 08:09)</a>:</h4>
<p>You still get to specify a name, because free variables have names.</p>



<a name="267692467"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/267692467" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Trebor Huang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#267692467">(Jan 12 2022 at 08:11)</a>:</h4>
<p>For <code>pred_3</code>, since <code>v</code> is not free, it doesn't matter.</p>



<a name="267692615"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/267692615" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Trebor Huang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#267692615">(Jan 12 2022 at 08:13)</a>:</h4>
<p>In McBride's terminology, if you want to generalize the variable with name <code>"x"</code> in <code>p</code>, you simply compute <code>p1 = abstract "x" p</code>, and then the resulting formula is just <code>Forall p1</code></p>



<a name="267692734"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/267692734" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Trebor Huang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#267692734">(Jan 12 2022 at 08:14)</a>:</h4>
<p>The rule of thumb: Free variables always have names, bound variables always have no name; The only exception is when a variable is in the process of becoming bound/free, in which case it is free but has no name.</p>



<a name="267740743"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/267740743" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#267740743">(Jan 12 2022 at 15:34)</a>:</h4>
<p>Thank you.</p>



<a name="267741269"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/267741269" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#267741269">(Jan 12 2022 at 15:38)</a>:</h4>
<p>Oh, sorry, I meant using de bruijn indexes.</p>



<a name="267742782"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/267742782" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Trebor Huang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#267742782">(Jan 12 2022 at 15:48)</a>:</h4>
<p>Pure de Bruijn indexes are indeed more difficult, but if you do some free variable permutation it should still work out. (Disclaimer: I never wrote anything in pure dBI)</p>



<a name="267749598"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/267749598" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#267749598">(Jan 12 2022 at 16:34)</a>:</h4>
<p>I see.</p>



<a name="267811530"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/267811530" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#267811530">(Jan 13 2022 at 01:12)</a>:</h4>
<p>Am I better off than using locally nameless?</p>



<a name="267822478"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/267822478" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#267822478">(Jan 13 2022 at 04:24)</a>:</h4>
<p>The other way to handle free variables in pure de bruijn is to never abstract them. So for example let's say you have a haskell like setup where there are some global definitions and a lambda operator, then the global definitions can be free de bruijn variables with arbitrary values, and the local variables are all bound in some scope. Then for the bound variables you always use numbers 0, 1, 2, .. based on binder depth, and for the free variables it doesn't matter what number you use since they will never be abstracted</p>



<a name="267823202"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/267823202" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#267823202">(Jan 13 2022 at 04:39)</a>:</h4>
<p>I'm sorry, I'm not sure I follow what you mean. This is for a proof checker? This changes the axioms somehow?</p>



<a name="267828699"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/267828699" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#267828699">(Jan 13 2022 at 06:22)</a>:</h4>
<p>If you want to construct a bunch of terms in lambda calculus like this (FOL terms work just the same way)</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">app</span> <span class="bp">=</span> <span class="bp">\</span><span class="n">x</span> <span class="n">y</span> <span class="bp">-&gt;</span> <span class="n">x</span> <span class="n">y</span>
<span class="n">foo</span> <span class="bp">=</span> <span class="n">app</span> <span class="o">(</span><span class="bp">\</span><span class="n">x</span> <span class="bp">-&gt;</span> <span class="n">app</span> <span class="n">x</span><span class="o">)</span> <span class="n">app</span>
<span class="n">bar</span> <span class="bp">=</span> <span class="bp">\</span><span class="n">x</span> <span class="bp">-&gt;</span> <span class="n">foo</span> <span class="n">x</span>
</code></pre></div>
<p>then you can do that by setting, say <code>app = #0</code>, <code>foo = #1</code> and <code>bar = #2</code> and you get the de bruijn terms:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">app</span> <span class="bp">=</span> <span class="n">lam</span> <span class="o">(</span><span class="n">lam</span> <span class="o">(</span><span class="bp">#</span><span class="mi">1</span> <span class="bp">#</span><span class="mi">0</span><span class="o">))</span>
<span class="n">foo</span> <span class="bp">=</span> <span class="bp">#</span><span class="mi">0</span> <span class="o">(</span><span class="n">lam</span> <span class="o">(</span><span class="bp">#</span><span class="mi">1</span> <span class="bp">#</span><span class="mi">0</span><span class="o">))</span> <span class="bp">#</span><span class="mi">0</span>
<span class="n">bar</span> <span class="bp">=</span> <span class="n">lam</span> <span class="o">(</span><span class="bp">#</span><span class="mi">2</span> <span class="bp">#</span><span class="mi">0</span><span class="o">)</span>
</code></pre></div>



<a name="267828823"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/267828823" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#267828823">(Jan 13 2022 at 06:24)</a>:</h4>
<p>so in this example <code>#0 (lam (#1 #0)) #0</code> references the free variable <code>#0</code> which is <code>app</code>, and we're never going to abstract it so we could do the same thing if it was some other number; if <code>app</code> was instead <code>#n</code> then the term would be <code>#n (lam (#(n+1) #0)) #n</code></p>



<a name="267828854"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/267828854" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#267828854">(Jan 13 2022 at 06:25)</a>:</h4>
<p>so this is handling global definitions and definitions with bound variables using only pure de bruijn, not locally nameless</p>



<a name="267877116"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/267877116" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#267877116">(Jan 13 2022 at 14:36)</a>:</h4>
<p>How do we know that we are never going to abstract <code>app</code>?</p>



<a name="267972889"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/267972889" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#267972889">(Jan 14 2022 at 05:03)</a>:</h4>
<p>In the "I am not a number - I am a free variable" paper (<a href="https://www.cs.ru.nl/~james/RESEARCH/haskell2004.pdf">https://www.cs.ru.nl/~james/RESEARCH/haskell2004.pdf</a>), what does being a closed expression mean in the sentence "From now on, outside of these operations, we maintain the invariant that Expr is only used for closed expressions and that Scopes have just one dangling index." I understand the usual meaning to be no free variables, but earlier they say "Meanwhile, instantiate image turns a scope into an expression by replacing the outer de Bruijn index (initially B 0) with image, which we presume is closed. Of course, F name is closed, so we can use instantiate (F name) to invert abstract name." but F name is a free variable right?</p>



<a name="267973628"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/267973628" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#267973628">(Jan 14 2022 at 05:17)</a>:</h4>
<p>Also, how does pred_3 get implemented in the manner described in the paper, if v is not free in p, and thus has no name to refer to and may not even occur in p.</p>



<a name="267973993"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/267973993" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#267973993">(Jan 14 2022 at 05:24)</a>:</h4>
<p>pred_3 is basically saying you can go from <code>forall x. (x = y)</code> to <code>forall x. (forall x. (x = y))</code> right? But now <code>x</code> has two binders, and I don't see how that can be expressed in either de bruijn or the method of the paper.</p>



<a name="267976727"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/267976727" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Trebor Huang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#267976727">(Jan 14 2022 at 06:27)</a>:</h4>
<p>No, <code>x</code> doesn't have two binders. The two <code>x</code> are different. And this axiom is but an awkward way we dealt with binders back in the day when dBI's were not invented.</p>



<a name="267976897"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/267976897" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Trebor Huang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#267976897">(Jan 14 2022 at 06:31)</a>:</h4>
<p>I think it is really worth writing something McBride-style to reformulate FOL with locally nameless. I'll search for related literature when I'm free.</p>



<a name="267978804"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/267978804" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#267978804">(Jan 14 2022 at 07:13)</a>:</h4>
<p><span class="user-mention silent" data-user-id="139442">Patrick Thomas</span> <a href="#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/267972889">said</a>:</p>
<blockquote>
<p>In the "I am not a number - I am a free variable" paper (<a href="https://www.cs.ru.nl/~james/RESEARCH/haskell2004.pdf">https://www.cs.ru.nl/~james/RESEARCH/haskell2004.pdf</a>), what does being a closed expression mean in the sentence "From now on, outside of these operations, we maintain the invariant that Expr is only used for closed expressions and that Scopes have just one dangling index."</p>
</blockquote>
<p>They explain this sentence a bit more elsewhere:</p>
<blockquote>
<p>For the most part, we shall pretend that Expr is the type of closed expressions—those with no ‘dangling’ bound variables pointing out of scope, and that Scope has one dangling bound variable, called B 0 at the top level.</p>
</blockquote>
<p>So "closed" here means having no free <code>B</code> variables; free <code>F</code> variables are allowed</p>



<a name="267980434"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/267980434" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#267980434">(Jan 14 2022 at 07:42)</a>:</h4>
<p>The equivalent of <code>pred_3</code> says that <code>imp p (forall p)</code> where <code>p</code> is an <code>Expr</code>, i.e. it is a "closed" expression containing no free <code>B</code> variables. There are no side conditions required because the closedness of <code>p</code> suffices, and this is ensured using typing and good discipline in the McBride formulation</p>



<a name="267980827"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/267980827" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#267980827">(Jan 14 2022 at 07:49)</a>:</h4>
<p><span class="user-mention silent" data-user-id="404479">Trebor Huang</span> <a href="#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/267976727">said</a>:</p>
<blockquote>
<p>No, <code>x</code> doesn't have two binders. The two <code>x</code> are different. And this axiom is but an awkward way we dealt with binders back in the day when dBI's were not invented.</p>
</blockquote>
<p>By the way, I'm still in favor of using named variables for theorem proving, I don't think that it is simply an outdated technology. The reason is because the <code>abstract</code> and <code>instantiate</code> operations are linear in the size of the expression, and locally nameless has you doing those operations all the time, to inspect an expression or really do anything at all with it. That means that most basic operations are somewhere around O(n^2) which isn't great.</p>
<p>What's more, that's O(n^2) in the <em>tree form</em> of the expression, meaning that if your expression has high duplication (which is very common in dependent type theory) then you can get an exponential blowup here. I believe it is possible to treat the expression in a DAG-like way, but it is quite difficult to do so because the same subexpression can mean different things depending on what binders it is under (the same numbers can refer to different binders), so caching the result of an analysis or transformation has to include a large amount of context and if you aren't careful you will end up having so many contexts that you are back to exponential time.</p>



<a name="267981310"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/267981310" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#267981310">(Jan 14 2022 at 07:56)</a>:</h4>
<p><span class="user-mention silent" data-user-id="139442">Patrick Thomas</span> <a href="#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/267877116">said</a>:</p>
<blockquote>
<p>How do we know that we are never going to abstract <code>app</code>?</p>
</blockquote>
<p>Because we always know, at the point we read an <code>app</code> token, whether it is referring to a free or bound variable. If we had an expression like</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">baz</span> <span class="bp">=</span> <span class="bp">\</span><span class="n">app</span> <span class="bp">-&gt;</span> <span class="n">app</span>
</code></pre></div>
<p>then we would first encounter the <code>app</code> binder, record that <code>app</code> is local variable <code>#0</code>, and then when we see the reference to <code>app</code> later we use <code>#0</code> (so the generated term is <code>lam #0</code>). By comparison, if we had</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">baz</span> <span class="bp">=</span> <span class="bp">\</span><span class="n">x</span> <span class="bp">-&gt;</span> <span class="n">app</span>
</code></pre></div>
<p>we would record that <code>x</code> is local variable <code>#0</code> (and the binder depth is 1), and when we see a reference to <code>app</code> we search the context, see that it is not present, but find <code>app</code> in the global context (with number <code>#0</code>), so we increment that by the binder depth and produce <code>lam #1</code>.</p>



<a name="268101612"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268101612" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268101612">(Jan 15 2022 at 03:26)</a>:</h4>
<p><span class="user-mention silent" data-user-id="404479">Trebor Huang</span> <a href="#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/267976727">said</a>:</p>
<blockquote>
<p>No, <code>x</code> doesn't have two binders. The two <code>x</code> are different. And this axiom is but an awkward way we dealt with binders back in the day when dBI's were not invented.</p>
</blockquote>
<p>The two <code>x</code> are different? Why? Is that an implied specification in the logic?</p>



<a name="268101618"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268101618" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268101618">(Jan 15 2022 at 03:27)</a>:</h4>
<p>To be honest, I'm not sure I understand what <code>gen</code> and <code>pred_3</code> do differently, or how they are used.</p>



<a name="268101622"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268101622" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268101622">(Jan 15 2022 at 03:27)</a>:</h4>
<p>I think MetaMath avoids the issues of free and bound variables by somehow finding a set of axioms that don't require conditions involving them? And then these axioms that I have can somehow be derived from those? And vice versa maybe?</p>



<a name="268101661"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268101661" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268101661">(Jan 15 2022 at 03:28)</a>:</h4>
<p>Kind of an aside, but I can see coming up with a set of tautologies, or statements that are valid in every model (if I remember the terminology right), but how did they go about figuring out axioms that also made the theory complete, even for propositional calculus, let alone predicate calculus?</p>



<a name="268101918"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268101918" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268101918">(Jan 15 2022 at 03:34)</a>:</h4>
<p><span class="user-mention silent" data-user-id="139442">Patrick Thomas</span> <a href="#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/268101618">said</a>:</p>
<blockquote>
<p>To be honest, I'm not sure I understand what <code>gen</code> and <code>pred_3</code> do differently, or how they are used.</p>
</blockquote>
<p>I mean, I think one (I'm not sure which) is used to do something like:<br>
Let x be any set that satisfies some condition. Prove x has some property. Obtain that all sets under the condition have that property.<br>
But I'm not sure about the other.</p>



<a name="268105897"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268105897" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Trebor Huang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268105897">(Jan 15 2022 at 05:17)</a>:</h4>
<ul>
<li>The propositional axioms remain the same, which should be clear to you.</li>
<li><code>gen</code> goes from <code>p</code> to <code>Forall (abstract v p)</code>, note that the <code>Forall</code> constructor does not take a variable name; instead it takes a <code>Scope</code> in McBride's terminology.</li>
<li><code>pred_1</code> shouldn't be a problem.</li>
<li><code>pred_2</code> goes from <code>Forall p</code> to <code>instantiate t p</code>, no additional check needed.</li>
<li><code>pred_3</code> goes from <code>p</code> to <code>Forall p</code>, no check needed, no additional computation needed.</li>
</ul>



<a name="268106479"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268106479" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268106479">(Jan 15 2022 at 05:33)</a>:</h4>
<p>Thank you!</p>



<a name="268107292"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268107292" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268107292">(Jan 15 2022 at 05:55)</a>:</h4>
<p>Now I just need to understand why that works for <code>pred_3</code> :)</p>



<a name="268107411"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268107411" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268107411">(Jan 15 2022 at 05:58)</a>:</h4>
<p>In <code>pred_3</code>, <code>p</code> is an <code>Expr</code>, meaning that it has no free <code>B</code> variables and in particular no <code>B 0</code>. Therefore <code>Forall p</code> will introduce a bound variable which has no occurrences in <code>p</code>, which is what we want. No variable lifting is required because everything is numbered from the innermost quantifiers out.</p>



<a name="268107545"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268107545" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268107545">(Jan 15 2022 at 06:00)</a>:</h4>
<p>Regarding completeness of propositional and predicate calculus, I don't think they were easy theorems to find but the theory was all worked out in the 40s or so</p>



<a name="268107565"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268107565" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268107565">(Jan 15 2022 at 06:00)</a>:</h4>
<p>Completeness of propositional calculus is pretty easy</p>



<a name="268107605"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268107605" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268107605">(Jan 15 2022 at 06:01)</a>:</h4>
<p>See <a href="https://en.wikipedia.org/wiki/G%C3%B6del%27s_completeness_theorem">https://en.wikipedia.org/wiki/G%C3%B6del%27s_completeness_theorem</a></p>



<a name="268107643"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268107643" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268107643">(Jan 15 2022 at 06:02)</a>:</h4>
<p>Why do we want a bound variable that has no occurrence in p? Isn't the condition that it just not be free in p?</p>



<a name="268107650"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268107650" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268107650">(Jan 15 2022 at 06:02)</a>:</h4>
<p>I mean not free</p>



<a name="268107666"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268107666" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268107666">(Jan 15 2022 at 06:03)</a>:</h4>
<p>In de bruijn that means that outside the scope of binders there are no <code>B</code>'s, under 1 binder there is only <code>B 0</code>, under 2 binders there are <code>B 0</code> and <code>B 1</code> and so on</p>



<a name="268107749"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268107749" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268107749">(Jan 15 2022 at 06:04)</a>:</h4>
<p>The haskell type system doesn't enforce this in McBride's presentation, so you have to just maintain it as a discipline</p>



<a name="268107768"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268107768" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268107768">(Jan 15 2022 at 06:05)</a>:</h4>
<p>similarly for <code>Scope</code>, which is like <code>Expr</code> except it allows <code>B 0</code> outside binders, <code>B 0, B 1</code> under 1 binder and so on</p>



<a name="268107926"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268107926" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268107926">(Jan 15 2022 at 06:08)</a>:</h4>
<p>So in the statement as given, v can not be free in p right/ So this means it either falls under the scope of a forall v p, or does not occur in p at all right?</p>



<a name="268107927"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268107927" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268107927">(Jan 15 2022 at 06:08)</a>:</h4>
<p><span class="user-mention silent" data-user-id="139442">Patrick Thomas</span> <a href="#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/268107643">said</a>:</p>
<blockquote>
<p>Why do we want a bound variable that has no occurrence in p? Isn't the condition that it just not be free in p?</p>
</blockquote>
<p>Actually de bruijn doesn't really make a distinction here. There are no <code>B</code> variables in <code>p</code> that would refer to the variable introduced in <code>Forall p</code></p>



<a name="268107962"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268107962" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268107962">(Jan 15 2022 at 06:09)</a>:</h4>
<p>Wait, oops, sorry, I thought we were talking about locally nameless...</p>



<a name="268107965"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268107965" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268107965">(Jan 15 2022 at 06:09)</a>:</h4>
<p>I am</p>



<a name="268107971"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268107971" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268107971">(Jan 15 2022 at 06:09)</a>:</h4>
<p>sorry to confuse</p>



<a name="268107979"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268107979" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268107979">(Jan 15 2022 at 06:09)</a>:</h4>
<p>No problem.</p>



<a name="268107980"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268107980" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268107980">(Jan 15 2022 at 06:09)</a>:</h4>
<p>the <code>F</code> variables don't really play a role here</p>



<a name="268108038"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268108038" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268108038">(Jan 15 2022 at 06:10)</a>:</h4>
<p>The "v not free in p" condition is expressed by the fact that <code>p</code> is an <code>Expr</code> even though <code>Forall</code> normally takes a <code>Scope</code>as its argument</p>



<a name="268108076"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268108076" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268108076">(Jan 15 2022 at 06:11)</a>:</h4>
<p>every <code>Expr</code> is a <code>Scope</code>, but not vice versa; the <code>Scope</code>s that are not <code>Expr</code>s are exactly those with a free occurrence of <code>B 0</code></p>



<a name="268108179"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268108179" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268108179">(Jan 15 2022 at 06:14)</a>:</h4>
<p>Isn't that a different definition of free? The named variable version means is not in the scope of a forall v or v not occurring. The locally nameless is that that there is no B0. I think?</p>



<a name="268108246"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268108246" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268108246">(Jan 15 2022 at 06:15)</a>:</h4>
<p>remember that when I say <code>B 0</code>, I mean <code>B 1</code> when under a binder, <code>B 2</code> under two binders and so on. Anything that would be interpreted as referring to the outer <code>Forall</code> binder we're introducing</p>



<a name="268108261"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268108261" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268108261">(Jan 15 2022 at 06:15)</a>:</h4>
<p>We don't have to worry about name clashes with a "forall v" somewhere in the term because that's the whole point of de bruijn variables</p>



<a name="268108335"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268108335" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268108335">(Jan 15 2022 at 06:16)</a>:</h4>
<p>If you had something like <code>forall v, v</code> this would be rendered in LN as <code>Forall (B 0)</code>, which does not contain any free <code>B 0</code> (because the only variable that appears is under 1 binder, and is not <code>B 1</code>)</p>



<a name="268108356"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268108356" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268108356">(Jan 15 2022 at 06:17)</a>:</h4>
<p>on the other hand <code>forall w, v</code> would be <code>Forall (B 1)</code> which does contain a free <code>B 0</code></p>



<a name="268108414"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268108414" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268108414">(Jan 15 2022 at 06:18)</a>:</h4>
<p>(in locally nameless you might also translate that as <code>Forall (F "v")</code> but let's suppose this is a <code>Scope</code>)</p>



<a name="268108513"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268108513" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268108513">(Jan 15 2022 at 06:20)</a>:</h4>
<p>In the latter case it still does not contain a free <code>B 0</code>, so we would be allowed to use the <code>pred_3</code> rule and get <code>Forall (F "v") -&gt; Forall (Forall (F "v"))</code> which would be rendered as <code>forall x, v -&gt; forall y, forall x, v</code></p>



<a name="268108616"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268108616" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268108616">(Jan 15 2022 at 06:22)</a>:</h4>
<p>(deleted)</p>



<a name="268108709"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268108709" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268108709">(Jan 15 2022 at 06:25)</a>:</h4>
<p>(deleted)</p>



<a name="268109152"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268109152" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268109152">(Jan 15 2022 at 06:34)</a>:</h4>
<p>In the named variable version, we can use <code>pred_3</code> to get <code>Forall x. (Pred P x) -&gt; Forall x. Forall x. (Pred P x)</code> right? What does this actually mean? Trebor says the two x are different?</p>



<a name="268109412"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268109412" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Trebor Huang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268109412">(Jan 15 2022 at 06:40)</a>:</h4>
<p>In locally nameless that's <code>Forall (Pred P (B 0)) -&gt; Forall (Forall (Pred P (B 0)))</code>.</p>



<a name="268109427"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268109427" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Trebor Huang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268109427">(Jan 15 2022 at 06:41)</a>:</h4>
<p>The variable <code>x</code> refers to the inner <code>Forall</code>, hence <code>B 0</code>.</p>



<a name="268109493"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268109493" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268109493">(Jan 15 2022 at 06:42)</a>:</h4>
<p>And the x in the named version is only bound by the inside forall x?</p>



<a name="268109513"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268109513" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Trebor Huang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268109513">(Jan 15 2022 at 06:43)</a>:</h4>
<p>Yes.</p>



<a name="268109518"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268109518" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268109518">(Jan 15 2022 at 06:43)</a>:</h4>
<p>Hmm.</p>



<a name="268109575"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268109575" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Trebor Huang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268109575">(Jan 15 2022 at 06:44)</a>:</h4>
<p>(deleted)</p>



<a name="268109592"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268109592" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268109592">(Jan 15 2022 at 06:45)</a>:</h4>
<p>So forall x, forall x, x is the same as forall y, forall x, x (in the named version)?</p>



<a name="268109594"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268109594" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Trebor Huang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268109594">(Jan 15 2022 at 06:45)</a>:</h4>
<p>Yep.</p>



<a name="268109646"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268109646" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268109646">(Jan 15 2022 at 06:46)</a>:</h4>
<p>Hmm.</p>



<a name="268109647"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268109647" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Trebor Huang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268109647">(Jan 15 2022 at 06:46)</a>:</h4>
<p>Think of the indices as lines connecting the nameless variable to the binders. So in this case, <code>B 0</code> means "A nameless variable with a line connecting it to the inner <code>Forall</code>. And think of named variables in the usual way. Then, a <code>Scope</code> would have some dangling lines.</p>
<p>Then <code>abstract</code> just takes a variable name, searches for all occurences of that variable, make them nameless, and draw a bunch of lines from them, so if you put the result under a <code>Forall</code>, you just collect the dangling lines and connect the other side to the <code>Forall</code>.</p>
<p><code>instantiate</code> takes a <code>Scope</code>, which has dangling lines, and replace the other end of the dangling lines with the expression you give.</p>



<a name="268109734"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268109734" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268109734">(Jan 15 2022 at 06:49)</a>:</h4>
<p>So (in the named version) is the 'v not free in p' condition the same as 'v does not occur in p', given that forall x, forall x, x is the same as forall y, forall x, x.</p>



<a name="268109780"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268109780" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Trebor Huang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268109780">(Jan 15 2022 at 06:50)</a>:</h4>
<p>Yep, that's the crux of alpha equivalence.</p>



<a name="268109797"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268109797" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Trebor Huang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268109797">(Jan 15 2022 at 06:51)</a>:</h4>
<p>You can change the variable names anyway you like, as long as they still refer to the same things.</p>



<a name="268109869"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268109869" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268109869">(Jan 15 2022 at 06:52)</a>:</h4>
<p>Why doesn't the named version just state "does not occur in" instead of "not free in"?</p>



<a name="268109900"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268109900" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268109900">(Jan 15 2022 at 06:54)</a>:</h4>
<p>I mean, could it? Would it be the same logic?</p>



<a name="268109955"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268109955" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Trebor Huang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268109955">(Jan 15 2022 at 06:54)</a>:</h4>
<p>Some versions do that, but then you need to additionally state the rules to make variable changes like <code>forall x. forall x. P(x)</code> to <code>forall y. forall x. P(x)</code></p>



<a name="268109967"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268109967" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268109967">(Jan 15 2022 at 06:55)</a>:</h4>
<p>I see. A rule for alpha conversion?</p>



<a name="268109974"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268109974" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Trebor Huang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268109974">(Jan 15 2022 at 06:55)</a>:</h4>
<p>Yes. I think one of the papers linked from the metamath homepage discusses that, but I can't remember which.</p>



<a name="268110245"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268110245" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268110245">(Jan 15 2022 at 07:01)</a>:</h4>
<p>I think I might see then. If there is no dangling B0 in p (required if p is an expression), then forall p does not bind any variable that occurs in p, because it just binds dangling B0's?</p>



<a name="268110254"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268110254" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Trebor Huang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268110254">(Jan 15 2022 at 07:01)</a>:</h4>
<p>Yes that's right.</p>



<a name="268110307"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268110307" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268110307">(Jan 15 2022 at 07:02)</a>:</h4>
<p>Hence it is equivalent to the named version, given alpha equivalence?</p>



<a name="268110417"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268110417" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Trebor Huang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268110417">(Jan 15 2022 at 07:05)</a>:</h4>
<p>Yeah, actually it is very much like quotienting the alpha equivalence</p>



<a name="268110431"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268110431" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268110431">(Jan 15 2022 at 07:06)</a>:</h4>
<p>Cool! Thank you!</p>



<a name="268110482"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268110482" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Trebor Huang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268110482">(Jan 15 2022 at 07:06)</a>:</h4>
<p>It's like how the set of irreducible fractions corresponds to the equivalence classes of fractions under <code>a/b ~ c/d</code> where <code>ad = bc</code></p>



<a name="268110590"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268110590" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268110590">(Jan 15 2022 at 07:09)</a>:</h4>
<p>Aside question: What does the octopus emoji mean?</p>



<a name="268110648"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268110648" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Huỳnh Trần Khanh <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268110648">(Jan 15 2022 at 07:10)</a>:</h4>
<p>It means congratulations.</p>



<a name="268110678"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268110678" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268110678">(Jan 15 2022 at 07:11)</a>:</h4>
<p>Huh. Ok. Thank you!</p>



<a name="268114845"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268114845" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268114845">(Jan 15 2022 at 08:46)</a>:</h4>
<p>"Impressive". It does a victory dance</p>



<a name="268155721"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268155721" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268155721">(Jan 16 2022 at 00:39)</a>:</h4>
<p>Is this a correct translation?</p>
<div class="codehilite" data-code-language="Haskell"><pre><span></span><code><span class="cm">{-</span>
<span class="cm">First order mathematical logic using locally nameless variables.</span>

<span class="cm">Modified from "Functional Pearl: I am not a Number—I am a Free Variable"</span>
<span class="cm">by Conor McBride and James McKinna.</span>
<span class="cm">https://www.cs.ru.nl/~james/RESEARCH/haskell2004.pdf</span>
<span class="cm">-}</span>

<span class="kr">import</span> <span class="nn">Data.List</span>

<span class="cm">{-</span>
<span class="cm">Func "c" [] : A constant named "c"</span>
<span class="cm">Func "f" [v] : A function named "f" of one variable v</span>
<span class="cm">-}</span>
<span class="kr">data</span> <span class="kt">Term</span> <span class="ow">=</span> <span class="kt">F</span> <span class="kt">String</span> <span class="c1">-- A free variable</span>
          <span class="o">|</span> <span class="kt">B</span> <span class="kt">Int</span> <span class="c1">-- A De Bruijn indexed bound variable</span>
          <span class="o">|</span> <span class="kt">Func</span> <span class="kt">String</span> <span class="p">[</span><span class="kt">Term</span><span class="p">]</span>
            <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">)</span>

<span class="cm">{-</span>
<span class="cm">Assumed not to have any bound variables out of scope.</span>

<span class="cm">Pred "P" [] : A propositional variable named "P"</span>
<span class="cm">Pred "Eq" [s, t] : s = t</span>
<span class="cm">-}</span>
<span class="kr">data</span> <span class="kt">Formula</span> <span class="ow">=</span> <span class="kt">Pred</span> <span class="kt">String</span> <span class="p">[</span><span class="kt">Term</span><span class="p">]</span>
             <span class="o">|</span> <span class="kt">Not</span> <span class="kt">Formula</span>
             <span class="o">|</span> <span class="kt">Imp</span> <span class="kt">Formula</span> <span class="kt">Formula</span>
             <span class="o">|</span> <span class="kt">Forall</span> <span class="kt">Scope</span>
               <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">)</span>

<span class="cm">{-</span>
<span class="cm">May have bound variables indexed one greater than the number of binders</span>
<span class="cm">above it.</span>
<span class="cm">-}</span>
<span class="kr">newtype</span> <span class="kt">Scope</span> <span class="ow">=</span> <span class="kt">Scope</span> <span class="kt">Formula</span>
                <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">)</span>

<span class="kr">newtype</span> <span class="kt">Theorem</span> <span class="ow">=</span> <span class="kt">Theorem</span> <span class="kt">Formula</span>
                  <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">)</span>

<span class="cm">{-</span>
<span class="cm">abstract v p = The result of changing each free variable named v in the formula</span>
<span class="cm">p to a bound variable indexed one greater than the number of binders above it.</span>
<span class="cm">-}</span>
<span class="nf">abstract</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Formula</span> <span class="ow">-&gt;</span> <span class="kt">Scope</span>
<span class="nf">abstract</span> <span class="n">v</span> <span class="n">p</span> <span class="ow">=</span> <span class="kt">Scope</span> <span class="p">(</span><span class="n">nameTo</span> <span class="mi">0</span> <span class="n">v</span> <span class="n">p</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">nameTo</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Formula</span> <span class="ow">-&gt;</span> <span class="kt">Formula</span>
  <span class="n">nameTo</span> <span class="n">outer</span> <span class="n">v</span> <span class="p">(</span><span class="kt">Pred</span> <span class="n">name</span> <span class="n">terms</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Pred</span> <span class="n">name</span> <span class="p">(</span><span class="kt">Data</span><span class="o">.</span><span class="kt">List</span><span class="o">.</span><span class="n">map</span> <span class="p">(</span><span class="n">nameTo'</span> <span class="n">outer</span> <span class="n">v</span><span class="p">)</span> <span class="n">terms</span><span class="p">)</span> <span class="kr">where</span>
    <span class="n">nameTo'</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Term</span> <span class="ow">-&gt;</span> <span class="kt">Term</span>
    <span class="n">nameTo'</span> <span class="n">outer</span> <span class="n">v</span> <span class="p">(</span><span class="kt">F</span> <span class="n">v'</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">if</span> <span class="n">v</span> <span class="o">==</span> <span class="n">v'</span> <span class="kr">then</span> <span class="kt">B</span> <span class="n">outer</span> <span class="kr">else</span> <span class="kt">F</span> <span class="n">v'</span>
    <span class="n">nameTo'</span> <span class="kr">_</span> <span class="kr">_</span> <span class="p">(</span><span class="kt">B</span> <span class="n">index</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">B</span> <span class="n">index</span>
    <span class="n">nameTo'</span> <span class="n">outer</span> <span class="n">v</span> <span class="p">(</span><span class="kt">Func</span> <span class="n">name</span> <span class="n">terms</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Func</span> <span class="n">name</span> <span class="p">(</span><span class="kt">Data</span><span class="o">.</span><span class="kt">List</span><span class="o">.</span><span class="n">map</span> <span class="p">(</span><span class="n">nameTo'</span> <span class="n">outer</span> <span class="n">v</span><span class="p">)</span> <span class="n">terms</span><span class="p">)</span>
  <span class="n">nameTo</span> <span class="n">outer</span> <span class="n">v</span> <span class="p">(</span><span class="kt">Not</span> <span class="n">p</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Not</span> <span class="p">(</span><span class="n">nameTo</span> <span class="n">outer</span> <span class="n">v</span> <span class="n">p</span><span class="p">)</span>
  <span class="n">nameTo</span> <span class="n">outer</span> <span class="n">v</span> <span class="p">(</span><span class="kt">Imp</span> <span class="n">p</span> <span class="n">q</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Imp</span> <span class="p">(</span><span class="n">nameTo</span> <span class="n">outer</span> <span class="n">v</span> <span class="n">p</span><span class="p">)</span> <span class="p">(</span><span class="n">nameTo</span> <span class="n">outer</span> <span class="n">v</span> <span class="n">q</span><span class="p">)</span>
  <span class="n">nameTo</span> <span class="n">outer</span> <span class="n">v</span> <span class="p">(</span><span class="kt">Forall</span> <span class="p">(</span><span class="kt">Scope</span> <span class="n">p</span><span class="p">))</span> <span class="ow">=</span> <span class="kt">Forall</span> <span class="p">(</span><span class="kt">Scope</span> <span class="p">(</span><span class="n">nameTo</span> <span class="p">(</span><span class="n">outer</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="n">v</span> <span class="n">p</span><span class="p">))</span>

<span class="cm">{-</span>
<span class="cm">instantiate t (Scope p) = The result of replacing each bound variable in the</span>
<span class="cm">formula p that has an index one greater than the number of binders above it</span>
<span class="cm">by the term t.</span>
<span class="cm">-}</span>
<span class="nf">instantiate</span> <span class="ow">::</span> <span class="kt">Term</span> <span class="ow">-&gt;</span> <span class="kt">Scope</span> <span class="ow">-&gt;</span> <span class="kt">Formula</span>
<span class="nf">instantiate</span> <span class="n">t</span> <span class="p">(</span><span class="kt">Scope</span> <span class="n">p</span><span class="p">)</span> <span class="ow">=</span> <span class="n">replace</span> <span class="mi">0</span> <span class="n">t</span> <span class="n">p</span> <span class="kr">where</span>
  <span class="n">replace</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Term</span> <span class="ow">-&gt;</span> <span class="kt">Formula</span> <span class="ow">-&gt;</span> <span class="kt">Formula</span>
  <span class="n">replace</span> <span class="n">outer</span> <span class="n">t</span> <span class="p">(</span><span class="kt">Pred</span> <span class="n">name</span> <span class="n">terms</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Pred</span> <span class="n">name</span> <span class="p">(</span><span class="kt">Data</span><span class="o">.</span><span class="kt">List</span><span class="o">.</span><span class="n">map</span> <span class="p">(</span><span class="n">replace'</span> <span class="n">outer</span> <span class="n">t</span><span class="p">)</span> <span class="n">terms</span><span class="p">)</span> <span class="kr">where</span>
    <span class="n">replace'</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Term</span> <span class="ow">-&gt;</span> <span class="kt">Term</span> <span class="ow">-&gt;</span> <span class="kt">Term</span>
    <span class="n">replace'</span> <span class="kr">_</span> <span class="kr">_</span> <span class="p">(</span><span class="kt">F</span> <span class="n">name</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">F</span> <span class="n">name</span>
    <span class="n">replace'</span> <span class="n">outer</span> <span class="n">t</span> <span class="p">(</span><span class="kt">B</span> <span class="n">index</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">if</span> <span class="n">outer</span> <span class="o">==</span> <span class="n">index</span> <span class="kr">then</span> <span class="n">t</span> <span class="kr">else</span> <span class="kt">B</span> <span class="n">index</span>
    <span class="n">replace'</span> <span class="n">outer</span> <span class="n">t</span> <span class="p">(</span><span class="kt">Func</span> <span class="n">name</span> <span class="n">terms</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Func</span> <span class="n">name</span> <span class="p">(</span><span class="kt">Data</span><span class="o">.</span><span class="kt">List</span><span class="o">.</span><span class="n">map</span> <span class="p">(</span><span class="n">replace'</span> <span class="n">outer</span> <span class="n">t</span><span class="p">)</span> <span class="n">terms</span><span class="p">)</span>
  <span class="n">replace</span> <span class="n">outer</span> <span class="n">t</span> <span class="p">(</span><span class="kt">Not</span> <span class="n">p</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Not</span> <span class="p">(</span><span class="n">replace</span> <span class="n">outer</span> <span class="n">t</span> <span class="n">p</span><span class="p">)</span>
  <span class="n">replace</span> <span class="n">outer</span> <span class="n">t</span> <span class="p">(</span><span class="kt">Imp</span> <span class="n">p</span> <span class="n">q</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Imp</span> <span class="p">(</span><span class="n">replace</span> <span class="n">outer</span> <span class="n">t</span> <span class="n">p</span><span class="p">)</span> <span class="p">(</span><span class="n">replace</span> <span class="n">outer</span> <span class="n">t</span> <span class="n">q</span><span class="p">)</span>
  <span class="n">replace</span> <span class="n">outer</span> <span class="n">t</span> <span class="p">(</span><span class="kt">Forall</span> <span class="p">(</span><span class="kt">Scope</span> <span class="n">p</span><span class="p">))</span> <span class="ow">=</span> <span class="kt">Forall</span> <span class="p">(</span><span class="kt">Scope</span> <span class="p">(</span><span class="n">replace</span> <span class="p">(</span><span class="n">outer</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="n">t</span> <span class="n">p</span><span class="p">))</span>
</code></pre></div>



<a name="268158261"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268158261" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268158261">(Jan 16 2022 at 01:50)</a>:</h4>
<p>FYI <code>nameTo</code> does not need the <code>v</code> argument and <code>nameTo'</code> does not need <code>outer</code> or <code>v</code> because they are already in scope</p>



<a name="268158309"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268158309" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268158309">(Jan 16 2022 at 01:52)</a>:</h4>
<p>I see. Thank you.</p>



<a name="268158380"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268158380" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268158380">(Jan 16 2022 at 01:55)</a>:</h4>
<p><code>t</code> needs to be a closed term in <code>instantiate</code> for this implementation to be correct; I guess that's a precondition but it should be spelled out in the comment</p>



<a name="268158447"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268158447" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268158447">(Jan 16 2022 at 01:57)</a>:</h4>
<p>Closed in the sense of no bound variables with indexes greater than the number of binders they are under?</p>



<a name="268158515"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268158515" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268158515">(Jan 16 2022 at 01:59)</a>:</h4>
<p><code>pred_1</code> should take two <code>Scope</code>s, or else the quantifiers are useless</p>



<a name="268158524"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268158524" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268158524">(Jan 16 2022 at 01:59)</a>:</h4>
<p><code>pred_2</code> should also take a <code>Scope</code></p>



<a name="268158680"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268158680" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268158680">(Jan 16 2022 at 02:01)</a>:</h4>
<p><span class="user-mention" data-user-id="139442">@Patrick Thomas</span> Closed in the sense of no bound variables at all</p>



<a name="268158726"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268158726" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268158726">(Jan 16 2022 at 02:02)</a>:</h4>
<p>i.e. what you said for binders = 0</p>



<a name="268158808"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268158808" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268158808">(Jan 16 2022 at 02:04)</a>:</h4>
<p>Should I make a check in the code for that each time a term is taken as an argument?</p>



<a name="268158870"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268158870" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268158870">(Jan 16 2022 at 02:05)</a>:</h4>
<p>No bound variables with indexes greater than 0, or just no bound variables altogether?</p>



<a name="268158890"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268158890" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268158890">(Jan 16 2022 at 02:06)</a>:</h4>
<p>Well, in LN this is an invariant, so you would only need it as a debug assertion</p>



<a name="268159006"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268159006" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268159006">(Jan 16 2022 at 02:08)</a>:</h4>
<p>A term shouldn't have any bound variables right? Since there are no binders in a term?</p>



<a name="268159023"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268159023" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268159023">(Jan 16 2022 at 02:08)</a>:</h4>
<p>That is the invariant?</p>



<a name="268159037"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268159037" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268159037">(Jan 16 2022 at 02:09)</a>:</h4>
<p>in LN there is only one interesting notion of closed: under <code>k</code> binders, no <code>B n</code> appears for <code>n &gt;= k</code> (closed term, <code>Term</code>, <code>Formula</code>) or for <code>n &gt;= k + 1</code> (term/formula with one free variable, <code>Scope</code>). General open terms (no restriction on the <code>B</code>'s) only appear in the definition of <code>abstract</code> and <code>instantiate</code>.</p>



<a name="268159103"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268159103" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268159103">(Jan 16 2022 at 02:10)</a>:</h4>
<p>For a <code>Term</code> to be closed that means it has no <code>B</code> variables at all though since there are no binders in the term grammar</p>



<a name="268159123"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268159123" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268159123">(Jan 16 2022 at 02:11)</a>:</h4>
<p>Every top level function you have there which has a <code>Term</code> in its type signature requires a closed term</p>



<a name="268159167"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268159167" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268159167">(Jan 16 2022 at 02:12)</a>:</h4>
<p>similarly for every <code>Formula</code> and <code>Theorem</code></p>



<a name="268159250"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268159250" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268159250">(Jan 16 2022 at 02:15)</a>:</h4>
<p>Thank you.</p>



<a name="268159253"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268159253" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268159253">(Jan 16 2022 at 02:15)</a>:</h4>
<p>Does <code>pred_3</code> also need to take a scope?</p>



<a name="268159259"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268159259" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268159259">(Jan 16 2022 at 02:15)</a>:</h4>
<p>No, that one specifically should not</p>



<a name="268159300"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268159300" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268159300">(Jan 16 2022 at 02:16)</a>:</h4>
<p>that's the not free condition we talked about</p>



<a name="268159323"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268159323" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268159323">(Jan 16 2022 at 02:17)</a>:</h4>
<p>I see.</p>



<a name="268161293"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268161293" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268161293">(Jan 16 2022 at 03:09)</a>:</h4>
<p>Is there a way to avoid putting the check for each term, formula, theorem and scope at each pattern match? Maybe a way to associate it with the data type?</p>



<a name="268170318"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268170318" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268170318">(Jan 16 2022 at 07:25)</a>:</h4>
<p>If you make <code>checkBounds'</code> a global function, you can define <code>checkTerm</code> as <code>checkBounds' 0</code>. Yes these are the invariants</p>



<a name="268171142"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268171142" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268171142">(Jan 16 2022 at 07:49)</a>:</h4>
<div class="codehilite" data-code-language="Haskell"><pre><span></span><code><span class="cm">{-</span>
<span class="cm">Hilbert style first order mathematical logic with equality using locally nameless variables.</span>

<span class="cm">Modified from "Functional Pearl: I am not a Number—I am a Free Variable"</span>
<span class="cm">by Conor McBride and James McKinna.</span>
<span class="cm">https://www.cs.ru.nl/~james/RESEARCH/haskell2004.pdf</span>
<span class="cm">-}</span>

<span class="kr">import</span> <span class="nn">Data.List</span>
<span class="kr">import</span> <span class="nn">Control.Exception</span>


<span class="cm">{-</span>
<span class="cm">Func "c" [] : A constant named "c"</span>
<span class="cm">Func "f" [v] : A function named "f" of one variable v</span>
<span class="cm">-}</span>
<span class="kr">data</span> <span class="kt">Term</span> <span class="ow">=</span> <span class="kt">F</span> <span class="kt">String</span> <span class="c1">-- A named free variable</span>
          <span class="o">|</span> <span class="kt">B</span> <span class="kt">Int</span> <span class="c1">-- A De Bruijn indexed bound variable</span>
          <span class="o">|</span> <span class="kt">Func</span> <span class="kt">String</span> <span class="p">[</span><span class="kt">Term</span><span class="p">]</span>
            <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">)</span>

<span class="cm">{-</span>
<span class="cm">Pred "P" [] : A propositional variable named "P"</span>
<span class="cm">Pred "Eq" [s, t] : s = t</span>
<span class="cm">-}</span>
<span class="kr">data</span> <span class="kt">Formula</span> <span class="ow">=</span> <span class="kt">Pred</span> <span class="kt">String</span> <span class="p">[</span><span class="kt">Term</span><span class="p">]</span>
             <span class="o">|</span> <span class="kt">Not</span> <span class="kt">Formula</span>
             <span class="o">|</span> <span class="kt">Imp</span> <span class="kt">Formula</span> <span class="kt">Formula</span>
             <span class="o">|</span> <span class="kt">Forall</span> <span class="kt">Scope</span>
               <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">)</span>

<span class="kr">newtype</span> <span class="kt">Scope</span> <span class="ow">=</span> <span class="kt">Scope</span> <span class="kt">Formula</span>
                <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">)</span>

<span class="kr">newtype</span> <span class="kt">Theorem</span> <span class="ow">=</span> <span class="kt">Theorem</span> <span class="kt">Formula</span>
                  <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">)</span>


<span class="cm">{-</span>
<span class="cm">abstract v p = The result of changing each free variable named v in the formula</span>
<span class="cm">p to a bound variable that has an index equal to the number of binders above it.</span>
<span class="cm">-}</span>
<span class="nf">abstract</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Formula</span> <span class="ow">-&gt;</span> <span class="kt">Scope</span>
<span class="nf">abstract</span> <span class="n">v</span> <span class="n">p</span> <span class="ow">=</span> <span class="kt">Scope</span> <span class="p">(</span><span class="n">nameTo</span> <span class="mi">0</span> <span class="n">v</span> <span class="n">p</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">nameTo</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Formula</span> <span class="ow">-&gt;</span> <span class="kt">Formula</span>
  <span class="n">nameTo</span> <span class="n">outer</span> <span class="n">v</span> <span class="p">(</span><span class="kt">Pred</span> <span class="n">name</span> <span class="n">terms</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Pred</span> <span class="n">name</span> <span class="p">(</span><span class="kt">Data</span><span class="o">.</span><span class="kt">List</span><span class="o">.</span><span class="n">map</span> <span class="p">(</span><span class="n">nameTo'</span> <span class="n">outer</span> <span class="n">v</span><span class="p">)</span> <span class="n">terms</span><span class="p">)</span> <span class="kr">where</span>
    <span class="n">nameTo'</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Term</span> <span class="ow">-&gt;</span> <span class="kt">Term</span>
    <span class="n">nameTo'</span> <span class="n">outer</span> <span class="n">v</span> <span class="p">(</span><span class="kt">F</span> <span class="n">v'</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">if</span> <span class="n">v</span> <span class="o">==</span> <span class="n">v'</span> <span class="kr">then</span> <span class="kt">B</span> <span class="n">outer</span> <span class="kr">else</span> <span class="kt">F</span> <span class="n">v'</span>
    <span class="n">nameTo'</span> <span class="kr">_</span> <span class="kr">_</span> <span class="p">(</span><span class="kt">B</span> <span class="n">index</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">B</span> <span class="n">index</span>
    <span class="n">nameTo'</span> <span class="n">outer</span> <span class="n">v</span> <span class="p">(</span><span class="kt">Func</span> <span class="n">name</span> <span class="n">terms</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Func</span> <span class="n">name</span> <span class="p">(</span><span class="kt">Data</span><span class="o">.</span><span class="kt">List</span><span class="o">.</span><span class="n">map</span> <span class="p">(</span><span class="n">nameTo'</span> <span class="n">outer</span> <span class="n">v</span><span class="p">)</span> <span class="n">terms</span><span class="p">)</span>
  <span class="n">nameTo</span> <span class="n">outer</span> <span class="n">v</span> <span class="p">(</span><span class="kt">Not</span> <span class="n">p</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Not</span> <span class="p">(</span><span class="n">nameTo</span> <span class="n">outer</span> <span class="n">v</span> <span class="n">p</span><span class="p">)</span>
  <span class="n">nameTo</span> <span class="n">outer</span> <span class="n">v</span> <span class="p">(</span><span class="kt">Imp</span> <span class="n">p</span> <span class="n">q</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Imp</span> <span class="p">(</span><span class="n">nameTo</span> <span class="n">outer</span> <span class="n">v</span> <span class="n">p</span><span class="p">)</span> <span class="p">(</span><span class="n">nameTo</span> <span class="n">outer</span> <span class="n">v</span> <span class="n">q</span><span class="p">)</span>
  <span class="n">nameTo</span> <span class="n">outer</span> <span class="n">v</span> <span class="p">(</span><span class="kt">Forall</span> <span class="p">(</span><span class="kt">Scope</span> <span class="n">p</span><span class="p">))</span> <span class="ow">=</span> <span class="kt">Forall</span> <span class="p">(</span><span class="kt">Scope</span> <span class="p">(</span><span class="n">nameTo</span> <span class="p">(</span><span class="n">outer</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="n">v</span> <span class="n">p</span><span class="p">))</span>

<span class="cm">{-</span>
<span class="cm">instantiate t (Scope p) = The result of replacing each bound variable that has</span>
<span class="cm">an index equal to the number of binders above it in the formula p by the term t.</span>
<span class="cm">-}</span>
<span class="nf">instantiate</span> <span class="ow">::</span> <span class="kt">Term</span> <span class="ow">-&gt;</span> <span class="kt">Scope</span> <span class="ow">-&gt;</span> <span class="kt">Formula</span>
<span class="nf">instantiate</span> <span class="n">t</span> <span class="p">(</span><span class="kt">Scope</span> <span class="n">p</span><span class="p">)</span> <span class="ow">=</span> <span class="n">replace</span> <span class="mi">0</span> <span class="n">t</span> <span class="n">p</span> <span class="kr">where</span>
  <span class="n">replace</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Term</span> <span class="ow">-&gt;</span> <span class="kt">Formula</span> <span class="ow">-&gt;</span> <span class="kt">Formula</span>
  <span class="n">replace</span> <span class="n">outer</span> <span class="n">t</span> <span class="p">(</span><span class="kt">Pred</span> <span class="n">name</span> <span class="n">terms</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Pred</span> <span class="n">name</span> <span class="p">(</span><span class="kt">Data</span><span class="o">.</span><span class="kt">List</span><span class="o">.</span><span class="n">map</span> <span class="p">(</span><span class="n">replace'</span> <span class="n">outer</span> <span class="n">t</span><span class="p">)</span> <span class="n">terms</span><span class="p">)</span> <span class="kr">where</span>
    <span class="n">replace'</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Term</span> <span class="ow">-&gt;</span> <span class="kt">Term</span> <span class="ow">-&gt;</span> <span class="kt">Term</span>
    <span class="n">replace'</span> <span class="kr">_</span> <span class="kr">_</span> <span class="p">(</span><span class="kt">F</span> <span class="n">name</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">F</span> <span class="n">name</span>
    <span class="n">replace'</span> <span class="n">outer</span> <span class="n">t</span> <span class="p">(</span><span class="kt">B</span> <span class="n">index</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">if</span> <span class="n">outer</span> <span class="o">==</span> <span class="n">index</span> <span class="kr">then</span> <span class="n">t</span> <span class="kr">else</span> <span class="kt">B</span> <span class="n">index</span>
    <span class="n">replace'</span> <span class="n">outer</span> <span class="n">t</span> <span class="p">(</span><span class="kt">Func</span> <span class="n">name</span> <span class="n">terms</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Func</span> <span class="n">name</span> <span class="p">(</span><span class="kt">Data</span><span class="o">.</span><span class="kt">List</span><span class="o">.</span><span class="n">map</span> <span class="p">(</span><span class="n">replace'</span> <span class="n">outer</span> <span class="n">t</span><span class="p">)</span> <span class="n">terms</span><span class="p">)</span>
  <span class="n">replace</span> <span class="n">outer</span> <span class="n">t</span> <span class="p">(</span><span class="kt">Not</span> <span class="n">p</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Not</span> <span class="p">(</span><span class="n">replace</span> <span class="n">outer</span> <span class="n">t</span> <span class="n">p</span><span class="p">)</span>
  <span class="n">replace</span> <span class="n">outer</span> <span class="n">t</span> <span class="p">(</span><span class="kt">Imp</span> <span class="n">p</span> <span class="n">q</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Imp</span> <span class="p">(</span><span class="n">replace</span> <span class="n">outer</span> <span class="n">t</span> <span class="n">p</span><span class="p">)</span> <span class="p">(</span><span class="n">replace</span> <span class="n">outer</span> <span class="n">t</span> <span class="n">q</span><span class="p">)</span>
  <span class="n">replace</span> <span class="n">outer</span> <span class="n">t</span> <span class="p">(</span><span class="kt">Forall</span> <span class="p">(</span><span class="kt">Scope</span> <span class="n">p</span><span class="p">))</span> <span class="ow">=</span> <span class="kt">Forall</span> <span class="p">(</span><span class="kt">Scope</span> <span class="p">(</span><span class="n">replace</span> <span class="p">(</span><span class="n">outer</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="n">t</span> <span class="n">p</span><span class="p">))</span>

<span class="cm">{-</span>
<span class="cm">checkTermBounds outer t = The index of each bound variable in term t is</span>
<span class="cm">less than outer.</span>
<span class="cm">-}</span>
<span class="nf">checkTermBounds</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Term</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">checkTermBounds</span> <span class="kr">_</span> <span class="p">(</span><span class="kt">F</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">True</span>
<span class="nf">checkTermBounds</span> <span class="n">outer</span> <span class="p">(</span><span class="kt">B</span> <span class="n">index</span><span class="p">)</span> <span class="ow">=</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">outer</span>
<span class="nf">checkTermBounds</span> <span class="n">outer</span> <span class="p">(</span><span class="kt">Func</span> <span class="kr">_</span> <span class="n">terms</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">List</span><span class="o">.</span><span class="n">all</span> <span class="p">(</span><span class="n">checkTermBounds</span> <span class="n">outer</span><span class="p">)</span> <span class="n">terms</span>

<span class="cm">{-</span>
<span class="cm">checkFormulaBounds outer p = The index of each bound variable in formula p is</span>
<span class="cm">less than the number of binders above it plus outer.</span>
<span class="cm">-}</span>
<span class="nf">checkFormulaBounds</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Formula</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">checkFormulaBounds</span> <span class="n">outer</span> <span class="p">(</span><span class="kt">Pred</span> <span class="kr">_</span> <span class="n">terms</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">List</span><span class="o">.</span><span class="n">all</span> <span class="p">(</span><span class="n">checkTermBounds</span> <span class="n">outer</span><span class="p">)</span> <span class="n">terms</span>
<span class="nf">checkFormulaBounds</span> <span class="n">outer</span> <span class="p">(</span><span class="kt">Not</span> <span class="n">p</span><span class="p">)</span> <span class="ow">=</span> <span class="n">checkFormulaBounds</span> <span class="n">outer</span> <span class="n">p</span>
<span class="nf">checkFormulaBounds</span> <span class="n">outer</span> <span class="p">(</span><span class="kt">Imp</span> <span class="n">p</span> <span class="n">q</span><span class="p">)</span> <span class="ow">=</span> <span class="n">checkFormulaBounds</span> <span class="n">outer</span> <span class="n">p</span> <span class="o">&amp;&amp;</span> <span class="n">checkFormulaBounds</span> <span class="n">outer</span> <span class="n">q</span>
<span class="nf">checkFormulaBounds</span> <span class="n">outer</span> <span class="p">(</span><span class="kt">Forall</span> <span class="p">(</span><span class="kt">Scope</span> <span class="n">p</span><span class="p">))</span> <span class="ow">=</span> <span class="n">checkFormulaBounds</span> <span class="p">(</span><span class="n">outer</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="n">p</span>

<span class="cm">{-</span>
<span class="cm">checkTerm t = There is no bound variable in t.</span>
<span class="cm">-}</span>
<span class="nf">checkTerm</span> <span class="ow">::</span> <span class="kt">Term</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">checkTerm</span> <span class="n">t</span> <span class="ow">=</span> <span class="n">checkTermBounds</span> <span class="mi">0</span> <span class="n">t</span>

<span class="cm">{-</span>
<span class="cm">checkFormula p = The index of each bound variable in the formula p is</span>
<span class="cm">less than the number of binders above it.</span>
<span class="cm">-}</span>
<span class="nf">checkFormula</span> <span class="ow">::</span> <span class="kt">Formula</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">checkFormula</span> <span class="n">p</span> <span class="ow">=</span> <span class="n">checkFormulaBounds</span> <span class="mi">0</span> <span class="n">p</span>

<span class="cm">{-</span>
<span class="cm">checkScope (Scope p) = The index of each bound variable in the formula p is</span>
<span class="cm">less than the number of binders above it plus one.</span>
<span class="cm">-}</span>
<span class="nf">checkScope</span> <span class="ow">::</span> <span class="kt">Scope</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">checkScope</span> <span class="p">(</span><span class="kt">Scope</span> <span class="n">p</span><span class="p">)</span> <span class="ow">=</span> <span class="n">checkFormulaBounds</span> <span class="mi">1</span> <span class="n">p</span>


<span class="c1">-- Propositional calculus</span>

<span class="c1">-- |- (p -&gt; (q -&gt; p))</span>
<span class="nf">prop_1</span> <span class="ow">::</span> <span class="kt">Formula</span> <span class="ow">-&gt;</span> <span class="kt">Formula</span> <span class="ow">-&gt;</span> <span class="kt">Theorem</span>
<span class="nf">prop_1</span> <span class="n">p</span> <span class="n">q</span> <span class="ow">=</span>
  <span class="n">assert</span> <span class="p">(</span><span class="n">all</span> <span class="n">checkFormula</span> <span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">])</span> <span class="o">$</span>
  <span class="kt">Theorem</span> <span class="p">(</span><span class="n">p</span> <span class="p">`</span><span class="kt">Imp</span><span class="p">`</span> <span class="p">(</span><span class="n">q</span> <span class="p">`</span><span class="kt">Imp</span><span class="p">`</span> <span class="n">p</span><span class="p">))</span>

<span class="c1">-- |- ((p -&gt; (q -&gt; r)) -&gt; ((p -&gt; q) -&gt; (p -&gt; r)))</span>
<span class="nf">prop_2</span> <span class="ow">::</span> <span class="kt">Formula</span> <span class="ow">-&gt;</span> <span class="kt">Formula</span> <span class="ow">-&gt;</span> <span class="kt">Formula</span> <span class="ow">-&gt;</span> <span class="kt">Theorem</span>
<span class="nf">prop_2</span> <span class="n">p</span> <span class="n">q</span> <span class="n">r</span> <span class="ow">=</span>
  <span class="n">assert</span> <span class="p">(</span><span class="n">all</span> <span class="n">checkFormula</span> <span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">r</span><span class="p">])</span> <span class="o">$</span>
  <span class="kt">Theorem</span> <span class="p">((</span><span class="n">p</span> <span class="p">`</span><span class="kt">Imp</span><span class="p">`</span> <span class="p">(</span><span class="n">q</span> <span class="p">`</span><span class="kt">Imp</span><span class="p">`</span> <span class="n">r</span><span class="p">))</span> <span class="p">`</span><span class="kt">Imp</span><span class="p">`</span> <span class="p">((</span><span class="n">p</span> <span class="p">`</span><span class="kt">Imp</span><span class="p">`</span> <span class="n">q</span><span class="p">)</span> <span class="p">`</span><span class="kt">Imp</span><span class="p">`</span> <span class="p">(</span><span class="n">p</span> <span class="p">`</span><span class="kt">Imp</span><span class="p">`</span> <span class="n">r</span><span class="p">)))</span>

<span class="c1">-- |- ((~p -&gt; ~q) -&gt; (q -&gt; p))</span>
<span class="nf">prop_3</span> <span class="ow">::</span> <span class="kt">Formula</span> <span class="ow">-&gt;</span> <span class="kt">Formula</span> <span class="ow">-&gt;</span> <span class="kt">Theorem</span>
<span class="nf">prop_3</span> <span class="n">p</span> <span class="n">q</span> <span class="ow">=</span>
  <span class="n">assert</span> <span class="p">(</span><span class="n">all</span> <span class="n">checkFormula</span> <span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">])</span> <span class="o">$</span>
  <span class="kt">Theorem</span> <span class="p">(((</span><span class="kt">Not</span> <span class="n">p</span><span class="p">)</span> <span class="p">`</span><span class="kt">Imp</span><span class="p">`</span> <span class="p">(</span><span class="kt">Not</span> <span class="n">q</span><span class="p">))</span> <span class="p">`</span><span class="kt">Imp</span><span class="p">`</span> <span class="p">(</span><span class="n">q</span> <span class="p">`</span><span class="kt">Imp</span><span class="p">`</span> <span class="n">p</span><span class="p">))</span>

<span class="c1">-- |- p &amp; |- (p -&gt; q) =&gt; |- q</span>
<span class="nf">mp</span> <span class="ow">::</span> <span class="kt">Theorem</span> <span class="ow">-&gt;</span> <span class="kt">Theorem</span> <span class="ow">-&gt;</span> <span class="kt">Theorem</span>
<span class="nf">mp</span> <span class="p">(</span><span class="kt">Theorem</span> <span class="n">p</span><span class="p">)</span> <span class="p">(</span><span class="kt">Theorem</span> <span class="p">(</span><span class="n">p'</span> <span class="p">`</span><span class="kt">Imp</span><span class="p">`</span> <span class="n">q</span><span class="p">))</span> <span class="ow">=</span>
  <span class="n">assert</span> <span class="p">(</span><span class="n">all</span> <span class="n">checkFormula</span> <span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="n">p'</span><span class="p">,</span> <span class="n">q</span><span class="p">])</span> <span class="o">$</span>
  <span class="kr">if</span> <span class="n">p</span> <span class="o">==</span> <span class="n">p'</span> <span class="kr">then</span> <span class="kt">Theorem</span> <span class="n">q</span> <span class="kr">else</span> <span class="ne">error</span> <span class="s">"mp"</span>
<span class="nf">mp</span> <span class="kr">_</span> <span class="kr">_</span> <span class="ow">=</span> <span class="ne">error</span> <span class="s">"mp"</span>


<span class="c1">-- Predicate calculus</span>

<span class="c1">-- |- p =&gt; |- forall v. p</span>
<span class="nf">gen</span> <span class="ow">::</span> <span class="kt">Theorem</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Theorem</span>
<span class="nf">gen</span> <span class="p">(</span><span class="kt">Theorem</span> <span class="n">p</span><span class="p">)</span> <span class="n">v</span> <span class="ow">=</span>
  <span class="n">assert</span> <span class="p">(</span><span class="n">checkFormula</span> <span class="n">p</span><span class="p">)</span> <span class="o">$</span>
  <span class="kt">Theorem</span> <span class="p">(</span><span class="kt">Forall</span> <span class="p">(</span><span class="n">abstract</span> <span class="n">v</span> <span class="n">p</span><span class="p">))</span>

<span class="c1">-- |- ((forall v. (p -&gt; q)) -&gt; (forall v. p) -&gt; (forall v. q))</span>
<span class="nf">pred_1</span> <span class="ow">::</span> <span class="kt">Scope</span> <span class="ow">-&gt;</span> <span class="kt">Scope</span> <span class="ow">-&gt;</span> <span class="kt">Theorem</span>
<span class="nf">pred_1</span> <span class="p">(</span><span class="kt">Scope</span> <span class="n">p</span><span class="p">)</span> <span class="p">(</span><span class="kt">Scope</span> <span class="n">q</span><span class="p">)</span> <span class="ow">=</span>
  <span class="n">assert</span> <span class="p">(</span><span class="n">all</span> <span class="n">checkScope</span> <span class="p">[(</span><span class="kt">Scope</span> <span class="n">p</span><span class="p">),</span> <span class="p">(</span><span class="kt">Scope</span> <span class="n">q</span><span class="p">)])</span> <span class="o">$</span>
  <span class="kt">Theorem</span> <span class="p">((</span><span class="kt">Forall</span> <span class="p">(</span><span class="kt">Scope</span> <span class="p">(</span><span class="n">p</span> <span class="p">`</span><span class="kt">Imp</span><span class="p">`</span> <span class="n">q</span><span class="p">)))</span> <span class="p">`</span><span class="kt">Imp</span><span class="p">`</span> <span class="p">((</span><span class="kt">Forall</span> <span class="p">(</span><span class="kt">Scope</span> <span class="n">p</span><span class="p">))</span> <span class="p">`</span><span class="kt">Imp</span><span class="p">`</span> <span class="p">(</span><span class="kt">Forall</span> <span class="p">(</span><span class="kt">Scope</span> <span class="n">q</span><span class="p">))))</span>

<span class="c1">-- |- (forall v. p -&gt; p [t/v]) provided p admits t for v</span>
<span class="nf">pred_2</span> <span class="ow">::</span> <span class="kt">Scope</span> <span class="ow">-&gt;</span> <span class="kt">Term</span> <span class="ow">-&gt;</span> <span class="kt">Theorem</span>
<span class="nf">pred_2</span> <span class="n">p</span> <span class="n">t</span> <span class="ow">=</span>
  <span class="n">assert</span> <span class="p">(</span><span class="n">checkScope</span> <span class="n">p</span><span class="p">)</span> <span class="o">$</span>
  <span class="n">assert</span> <span class="p">(</span><span class="n">checkTerm</span> <span class="n">t</span><span class="p">)</span> <span class="o">$</span>
  <span class="kt">Theorem</span> <span class="p">((</span><span class="kt">Forall</span> <span class="n">p</span><span class="p">)</span> <span class="p">`</span><span class="kt">Imp</span><span class="p">`</span> <span class="p">(</span><span class="n">instantiate</span> <span class="n">t</span> <span class="n">p</span><span class="p">))</span>

<span class="c1">-- |- (p -&gt; forall v. p) provided v is not free in p</span>
<span class="nf">pred_3</span> <span class="ow">::</span> <span class="kt">Formula</span> <span class="ow">-&gt;</span> <span class="kt">Theorem</span>
<span class="nf">pred_3</span> <span class="n">p</span> <span class="ow">=</span>
  <span class="n">assert</span> <span class="p">(</span><span class="n">checkFormula</span> <span class="n">p</span><span class="p">)</span> <span class="o">$</span>
  <span class="kt">Theorem</span> <span class="p">(</span><span class="n">p</span> <span class="p">`</span><span class="kt">Imp</span><span class="p">`</span> <span class="p">(</span><span class="kt">Forall</span> <span class="p">(</span><span class="kt">Scope</span> <span class="n">p</span><span class="p">)))</span>


<span class="c1">-- Equality</span>

<span class="c1">-- |- t = t</span>
<span class="nf">eq_1</span> <span class="ow">::</span> <span class="kt">Term</span> <span class="ow">-&gt;</span> <span class="kt">Theorem</span>
<span class="nf">eq_1</span> <span class="n">t</span> <span class="ow">=</span>
  <span class="n">assert</span> <span class="p">(</span><span class="n">checkTerm</span> <span class="n">t</span><span class="p">)</span> <span class="o">$</span>
  <span class="kt">Theorem</span> <span class="p">(</span><span class="kt">Pred</span> <span class="s">"Eq"</span> <span class="p">[</span><span class="n">t</span><span class="p">,</span> <span class="n">t</span><span class="p">])</span>

<span class="c1">-- |- s1 = t1 ==&gt; ... ==&gt; sn = tn ==&gt; f(s1,..,sn) = f(t1,..,tn)</span>
<span class="nf">eq_2</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Term</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Term</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Theorem</span>
<span class="nf">eq_2</span> <span class="n">f</span> <span class="n">ss</span> <span class="n">ts</span> <span class="ow">=</span>
  <span class="n">assert</span> <span class="p">(</span><span class="n">all</span> <span class="n">checkTerm</span> <span class="n">ss</span><span class="p">)</span> <span class="o">$</span>
  <span class="n">assert</span> <span class="p">(</span><span class="n">all</span> <span class="n">checkTerm</span> <span class="n">ts</span><span class="p">)</span> <span class="o">$</span>
  <span class="kr">if</span> <span class="p">(</span><span class="kt">Data</span><span class="o">.</span><span class="kt">List</span><span class="o">.</span><span class="n">length</span> <span class="n">ss</span> <span class="o">==</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">List</span><span class="o">.</span><span class="n">length</span> <span class="n">ts</span><span class="p">)</span> <span class="kr">then</span>
  <span class="c1">-- eqs = [s1 = t1, ..., sn = tn]</span>
  <span class="kr">let</span> <span class="n">eqs</span> <span class="ow">=</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">List</span><span class="o">.</span><span class="n">zipWith</span> <span class="p">(</span><span class="nf">\</span><span class="n">s</span> <span class="n">t</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Pred</span> <span class="s">"Eq"</span> <span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">]))</span> <span class="n">ss</span> <span class="n">ts</span> <span class="kr">in</span>
  <span class="c1">-- z = f(s1,..,sn) = f(t1,..,tn)</span>
  <span class="kr">let</span> <span class="n">z</span> <span class="ow">=</span> <span class="kt">Pred</span> <span class="s">"Eq"</span> <span class="p">[(</span><span class="kt">Func</span> <span class="n">f</span> <span class="n">ss</span><span class="p">),</span> <span class="p">(</span><span class="kt">Func</span> <span class="n">f</span> <span class="n">ts</span><span class="p">)]</span> <span class="kr">in</span>
  <span class="kt">Theorem</span> <span class="p">(</span><span class="kt">Data</span><span class="o">.</span><span class="kt">List</span><span class="o">.</span><span class="n">foldr</span> <span class="kt">Imp</span> <span class="n">z</span> <span class="n">eqs</span><span class="p">)</span>
  <span class="kr">else</span> <span class="ne">error</span> <span class="s">"eq_2"</span>

<span class="c1">-- |- s1 = t1 ==&gt; ... ==&gt; sn = tn ==&gt; P(s1,..,sn) ==&gt; P(t1,..,tn)</span>
<span class="nf">eq_3</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Term</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Term</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Theorem</span>
<span class="nf">eq_3</span> <span class="n">p</span> <span class="n">ss</span> <span class="n">ts</span> <span class="ow">=</span>
  <span class="n">assert</span> <span class="p">(</span><span class="n">all</span> <span class="n">checkTerm</span> <span class="n">ss</span><span class="p">)</span> <span class="o">$</span>
  <span class="n">assert</span> <span class="p">(</span><span class="n">all</span> <span class="n">checkTerm</span> <span class="n">ts</span><span class="p">)</span> <span class="o">$</span>
  <span class="kr">if</span> <span class="p">(</span><span class="kt">Data</span><span class="o">.</span><span class="kt">List</span><span class="o">.</span><span class="n">length</span> <span class="n">ss</span> <span class="o">==</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">List</span><span class="o">.</span><span class="n">length</span> <span class="n">ts</span><span class="p">)</span> <span class="kr">then</span>
  <span class="c1">-- eqs = [s1 = t1, ..., sn = tn]</span>
  <span class="kr">let</span> <span class="n">eqs</span> <span class="ow">=</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">List</span><span class="o">.</span><span class="n">zipWith</span> <span class="p">(</span><span class="nf">\</span><span class="n">s</span> <span class="n">t</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Pred</span> <span class="s">"Eq"</span> <span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">]))</span> <span class="n">ss</span> <span class="n">ts</span> <span class="kr">in</span>
  <span class="c1">-- z = P(s1,..,sn) ==&gt; P(t1,..,tn)</span>
  <span class="kr">let</span> <span class="n">z</span> <span class="ow">=</span> <span class="p">(</span><span class="kt">Pred</span> <span class="n">p</span> <span class="n">ss</span><span class="p">)</span> <span class="p">`</span><span class="kt">Imp</span><span class="p">`</span> <span class="p">(</span><span class="kt">Pred</span> <span class="n">p</span> <span class="n">ts</span><span class="p">)</span> <span class="kr">in</span>
  <span class="kt">Theorem</span> <span class="p">(</span><span class="kt">Data</span><span class="o">.</span><span class="kt">List</span><span class="o">.</span><span class="n">foldr</span> <span class="kt">Imp</span> <span class="n">z</span> <span class="n">eqs</span><span class="p">)</span>
  <span class="kr">else</span> <span class="ne">error</span> <span class="s">"eq_3"</span>
</code></pre></div>



<a name="268175284"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268175284" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268175284">(Jan 16 2022 at 09:38)</a>:</h4>
<p>Am I on the right track here? This is an attempt at implementing a proof checker for natural deduction, but I am not sure I have the predicate and equality rules right. For example, in the exists introduction, are we substituting a variable in for a term?</p>
<div class="codehilite" data-code-language="Haskell"><pre><span></span><code><span class="c1">--import Data.List</span>


<span class="cm">{-</span>
<span class="cm">Func "c" [] : A constant named "c"</span>
<span class="cm">Func "f" [v] : A function named "f" of one variable v</span>
<span class="cm">-}</span>
<span class="kr">data</span> <span class="kt">Term</span> <span class="ow">=</span> <span class="kt">Var</span> <span class="kt">String</span>
          <span class="o">|</span> <span class="kt">Func</span> <span class="kt">String</span> <span class="p">[</span><span class="kt">Term</span><span class="p">]</span>
            <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">)</span>

<span class="cm">{-</span>
<span class="cm">Pred "P" [] : A propositional variable named "P"</span>
<span class="cm">Pred "Eq" [s, t] : s = t</span>
<span class="cm">-}</span>
<span class="kr">data</span> <span class="kt">Formula</span> <span class="ow">=</span> <span class="kt">Bottom</span> <span class="c1">-- False</span>
             <span class="o">|</span> <span class="kt">Top</span> <span class="c1">-- True</span>
             <span class="o">|</span> <span class="kt">Pred</span> <span class="kt">String</span> <span class="p">[</span><span class="kt">Term</span><span class="p">]</span>
             <span class="o">|</span> <span class="kt">Not</span> <span class="kt">Formula</span>
             <span class="o">|</span> <span class="kt">And</span> <span class="kt">Formula</span> <span class="kt">Formula</span>
             <span class="o">|</span> <span class="kt">Or</span> <span class="kt">Formula</span> <span class="kt">Formula</span>
             <span class="o">|</span> <span class="kt">Imp</span> <span class="kt">Formula</span> <span class="kt">Formula</span>
             <span class="o">|</span> <span class="kt">Iff</span> <span class="kt">Formula</span> <span class="kt">Formula</span>
             <span class="o">|</span> <span class="kt">Forall</span> <span class="kt">String</span> <span class="kt">Formula</span>
             <span class="o">|</span> <span class="kt">Exists</span> <span class="kt">String</span> <span class="kt">Formula</span>
               <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">)</span>

<span class="kr">data</span> <span class="kt">Proof</span> <span class="ow">=</span> <span class="kt">Assumption</span>
           <span class="o">|</span> <span class="kt">ImpIntro</span> <span class="kt">Proof</span>
           <span class="o">|</span> <span class="kt">ImpElim</span> <span class="kt">Formula</span> <span class="kt">Proof</span> <span class="kt">Proof</span>
           <span class="o">|</span> <span class="kt">AndIntro</span> <span class="kt">Proof</span> <span class="kt">Proof</span>
           <span class="o">|</span> <span class="kt">AndElimLeft</span> <span class="kt">Formula</span> <span class="kt">Proof</span>
           <span class="o">|</span> <span class="kt">AndElimRight</span> <span class="kt">Formula</span> <span class="kt">Proof</span>
           <span class="o">|</span> <span class="kt">NotIntro</span> <span class="kt">Proof</span>
           <span class="o">|</span> <span class="kt">NotElim</span> <span class="kt">Formula</span> <span class="kt">Proof</span> <span class="kt">Proof</span>
           <span class="o">|</span> <span class="kt">OrIntroLeft</span> <span class="kt">Proof</span>
           <span class="o">|</span> <span class="kt">OrIntroRight</span> <span class="kt">Proof</span>
           <span class="o">|</span> <span class="kt">OrElim</span> <span class="kt">Formula</span> <span class="kt">Formula</span> <span class="kt">Proof</span> <span class="kt">Proof</span> <span class="kt">Proof</span>
           <span class="o">|</span> <span class="kt">BottomElim</span> <span class="kt">Proof</span>
           <span class="o">|</span> <span class="kt">TopIntro</span>
           <span class="o">|</span> <span class="kt">IffIntro</span> <span class="kt">Proof</span> <span class="kt">Proof</span>
           <span class="o">|</span> <span class="kt">IffElimLeft</span> <span class="kt">Formula</span> <span class="kt">Proof</span> <span class="kt">Proof</span>
           <span class="o">|</span> <span class="kt">IffElimRight</span> <span class="kt">Formula</span> <span class="kt">Proof</span> <span class="kt">Proof</span>
           <span class="o">|</span> <span class="kt">Contradiction</span> <span class="kt">Proof</span>
           <span class="o">|</span> <span class="kt">ForallIntro</span> <span class="kt">Proof</span>
           <span class="o">|</span> <span class="kt">ForallElim</span> <span class="kt">Formula</span> <span class="kt">Term</span> <span class="kt">String</span> <span class="kt">Proof</span>
           <span class="o">|</span> <span class="kt">ExistsIntro</span> <span class="kt">Formula</span> <span class="kt">Term</span> <span class="kt">Proof</span>
           <span class="o">|</span> <span class="kt">ExistsElim</span> <span class="kt">Formula</span> <span class="kt">String</span> <span class="kt">String</span> <span class="kt">Proof</span> <span class="kt">Proof</span>
           <span class="o">|</span> <span class="kt">Reflexivity</span>
           <span class="o">|</span> <span class="kt">Substitution</span> <span class="kt">Term</span> <span class="kt">Term</span> <span class="kt">Proof</span>
             <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">)</span>

<span class="kr">type</span> <span class="kt">Context</span> <span class="ow">=</span> <span class="p">[</span><span class="kt">Formula</span><span class="p">]</span>


<span class="nf">occursIn</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Term</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">occursIn</span> <span class="n">v</span> <span class="p">(</span><span class="kt">Var</span> <span class="n">name</span><span class="p">)</span> <span class="ow">=</span> <span class="n">v</span> <span class="o">==</span> <span class="n">name</span>
<span class="nf">occursIn</span> <span class="n">v</span> <span class="p">(</span><span class="kt">Func</span> <span class="kr">_</span> <span class="n">terms</span><span class="p">)</span> <span class="ow">=</span> <span class="n">any</span> <span class="p">(</span><span class="n">occursIn</span> <span class="n">v</span><span class="p">)</span> <span class="n">terms</span>


<span class="c1">-- freeIn v p = there exists an occurrence of v in p that is free.</span>
<span class="nf">freeIn</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Formula</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">freeIn</span> <span class="kr">_</span> <span class="kt">Bottom</span> <span class="ow">=</span> <span class="kt">False</span>
<span class="nf">freeIn</span> <span class="kr">_</span> <span class="kt">Top</span> <span class="ow">=</span> <span class="kt">False</span>
<span class="nf">freeIn</span> <span class="n">v</span> <span class="p">(</span><span class="kt">Pred</span> <span class="kr">_</span> <span class="n">terms</span><span class="p">)</span> <span class="ow">=</span> <span class="n">any</span> <span class="p">(</span><span class="n">occursIn</span> <span class="n">v</span><span class="p">)</span> <span class="n">terms</span>
<span class="nf">freeIn</span> <span class="n">v</span> <span class="p">(</span><span class="kt">Not</span> <span class="n">p</span><span class="p">)</span> <span class="ow">=</span> <span class="n">freeIn</span> <span class="n">v</span> <span class="n">p</span>
<span class="nf">freeIn</span> <span class="n">v</span> <span class="p">(</span><span class="kt">And</span> <span class="n">p</span> <span class="n">q</span><span class="p">)</span> <span class="ow">=</span> <span class="n">freeIn</span> <span class="n">v</span> <span class="n">p</span> <span class="o">||</span> <span class="n">freeIn</span> <span class="n">v</span> <span class="n">q</span>
<span class="nf">freeIn</span> <span class="n">v</span> <span class="p">(</span><span class="kt">Or</span> <span class="n">p</span> <span class="n">q</span><span class="p">)</span> <span class="ow">=</span> <span class="n">freeIn</span> <span class="n">v</span> <span class="n">p</span> <span class="o">||</span> <span class="n">freeIn</span> <span class="n">v</span> <span class="n">q</span>
<span class="nf">freeIn</span> <span class="n">v</span> <span class="p">(</span><span class="kt">Imp</span> <span class="n">p</span> <span class="n">q</span><span class="p">)</span> <span class="ow">=</span> <span class="n">freeIn</span> <span class="n">v</span> <span class="n">p</span> <span class="o">||</span> <span class="n">freeIn</span> <span class="n">v</span> <span class="n">q</span>
<span class="nf">freeIn</span> <span class="n">v</span> <span class="p">(</span><span class="kt">Iff</span> <span class="n">p</span> <span class="n">q</span><span class="p">)</span> <span class="ow">=</span> <span class="n">freeIn</span> <span class="n">v</span> <span class="n">p</span> <span class="o">||</span> <span class="n">freeIn</span> <span class="n">v</span> <span class="n">q</span>
<span class="nf">freeIn</span> <span class="n">v</span> <span class="p">(</span><span class="kt">Forall</span> <span class="n">x</span> <span class="n">p</span><span class="p">)</span> <span class="ow">=</span> <span class="n">v</span> <span class="o">/=</span> <span class="n">x</span> <span class="o">&amp;&amp;</span> <span class="n">freeIn</span> <span class="n">v</span> <span class="n">p</span>
<span class="nf">freeIn</span> <span class="n">v</span> <span class="p">(</span><span class="kt">Exists</span> <span class="n">x</span> <span class="n">p</span><span class="p">)</span> <span class="ow">=</span> <span class="n">v</span> <span class="o">/=</span> <span class="n">x</span> <span class="o">&amp;&amp;</span> <span class="n">freeIn</span> <span class="n">v</span> <span class="n">p</span>


<span class="c1">-- Placeholders</span>
<span class="nf">sub</span> <span class="n">p</span> <span class="kr">_</span> <span class="kr">_</span> <span class="ow">=</span> <span class="n">p</span>
<span class="nf">admits</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">True</span>


<span class="c1">-- isProofOf a (b, c) = a is a proof of b |- c</span>
<span class="nf">isProofOf</span> <span class="ow">::</span> <span class="kt">Proof</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Context</span><span class="p">,</span> <span class="kt">Formula</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>

<span class="cm">{-</span>
<span class="cm">Assumption:</span>
<span class="cm">(gamma |- p) if p is in gamma</span>
<span class="cm">-}</span>
<span class="nf">isProofOf</span> <span class="kt">Assumption</span> <span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="ow">=</span> <span class="n">elem</span> <span class="n">p</span> <span class="n">gamma</span>


<span class="cm">{-</span>
<span class="cm">Implication introduction:</span>
<span class="cm">(gamma, p |- q) =&gt; (gamma |- p -&gt; q)</span>
<span class="cm">-}</span>
<span class="nf">isProofOf</span> <span class="p">(</span><span class="kt">ImpIntro</span> <span class="n">sub_proof</span><span class="p">)</span> <span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="p">(</span><span class="kt">Imp</span> <span class="n">p</span> <span class="n">q</span><span class="p">))</span> <span class="ow">=</span>
  <span class="n">isProofOf</span> <span class="n">sub_proof</span> <span class="p">((</span><span class="n">p</span> <span class="kt">:</span> <span class="n">gamma</span><span class="p">),</span> <span class="n">q</span><span class="p">)</span>

<span class="cm">{-</span>
<span class="cm">Implication elimination:</span>
<span class="cm">(gamma |- p -&gt; q) &amp;&amp; (gamma |- p) =&gt; (gamma |- q)</span>
<span class="cm">-}</span>
<span class="nf">isProofOf</span> <span class="p">(</span><span class="kt">ImpElim</span> <span class="n">p</span> <span class="n">sub_proof_1</span> <span class="n">sub_proof_2</span><span class="p">)</span> <span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span> <span class="ow">=</span>
  <span class="n">isProofOf</span> <span class="n">sub_proof_1</span> <span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="p">(</span><span class="kt">Imp</span> <span class="n">p</span> <span class="n">q</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
  <span class="n">isProofOf</span> <span class="n">sub_proof_2</span> <span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>


<span class="cm">{-</span>
<span class="cm">And introduction:</span>
<span class="cm">(gamma |- p) &amp;&amp; (gamma |- q) =&gt; (gamma |- p /\ q)</span>
<span class="cm">-}</span>
<span class="nf">isProofOf</span> <span class="p">(</span><span class="kt">AndIntro</span> <span class="n">sub_proof_1</span> <span class="n">sub_proof_2</span><span class="p">)</span> <span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="p">(</span><span class="kt">And</span> <span class="n">p</span> <span class="n">q</span><span class="p">))</span> <span class="ow">=</span>
  <span class="n">isProofOf</span> <span class="n">sub_proof_1</span> <span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
  <span class="n">isProofOf</span> <span class="n">sub_proof_2</span> <span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>

<span class="cm">{-</span>
<span class="cm">And elimination left:</span>
<span class="cm">(gamma |- p /\ q) =&gt; (gamma |- p)</span>
<span class="cm">-}</span>
<span class="nf">isProofOf</span> <span class="p">(</span><span class="kt">AndElimLeft</span> <span class="n">q</span> <span class="n">sub_proof</span><span class="p">)</span> <span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="ow">=</span>
  <span class="n">isProofOf</span> <span class="n">sub_proof</span> <span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="p">(</span><span class="kt">And</span> <span class="n">p</span> <span class="n">q</span><span class="p">))</span>

<span class="cm">{-</span>
<span class="cm">And elimination right:</span>
<span class="cm">(gamma |- p /\ q) =&gt; (gamma |- q)</span>
<span class="cm">-}</span>
<span class="nf">isProofOf</span> <span class="p">(</span><span class="kt">AndElimRight</span> <span class="n">p</span> <span class="n">sub_proof</span><span class="p">)</span> <span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span> <span class="ow">=</span>
  <span class="n">isProofOf</span> <span class="n">sub_proof</span> <span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="p">(</span><span class="kt">And</span> <span class="n">p</span> <span class="n">q</span><span class="p">))</span>


<span class="cm">{-</span>
<span class="cm">Not introduction:</span>
<span class="cm">(gamma, p |- False) =&gt; (gamma |- ~p)</span>
<span class="cm">-}</span>
<span class="nf">isProofOf</span> <span class="p">(</span><span class="kt">NotIntro</span> <span class="n">sub_proof</span><span class="p">)</span> <span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="p">(</span><span class="kt">Not</span> <span class="n">p</span><span class="p">))</span> <span class="ow">=</span>
  <span class="n">isProofOf</span> <span class="n">sub_proof</span> <span class="p">((</span><span class="n">p</span> <span class="kt">:</span> <span class="n">gamma</span><span class="p">),</span> <span class="kt">Bottom</span><span class="p">)</span>

<span class="cm">{-</span>
<span class="cm">Not elimination:</span>
<span class="cm">(gamma |- ~p) &amp;&amp; (gamma |- p) =&gt; (gamma |- False)</span>
<span class="cm">-}</span>
<span class="nf">isProofOf</span> <span class="p">(</span><span class="kt">NotElim</span> <span class="n">p</span> <span class="n">sub_proof_1</span> <span class="n">sub_proof_2</span><span class="p">)</span> <span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="kt">Bottom</span><span class="p">)</span> <span class="ow">=</span>
  <span class="n">isProofOf</span> <span class="n">sub_proof_1</span> <span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="p">(</span><span class="kt">Not</span> <span class="n">p</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
  <span class="n">isProofOf</span> <span class="n">sub_proof_2</span> <span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>


<span class="cm">{-</span>
<span class="cm">Or introduction left:</span>
<span class="cm">(gamma |- p) =&gt; (gamma |- p \/ q)</span>
<span class="cm">-}</span>
<span class="nf">isProofOf</span> <span class="p">(</span><span class="kt">OrIntroLeft</span> <span class="n">sub_proof</span><span class="p">)</span> <span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="p">(</span><span class="kt">Or</span> <span class="n">p</span> <span class="kr">_</span><span class="p">))</span> <span class="ow">=</span>
  <span class="n">isProofOf</span> <span class="n">sub_proof</span> <span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>

<span class="cm">{-</span>
<span class="cm">Or introduction right:</span>
<span class="cm">(gamma |- q) =&gt; (gamma |- p \/ q)</span>
<span class="cm">-}</span>
<span class="nf">isProofOf</span> <span class="p">(</span><span class="kt">OrIntroRight</span> <span class="n">sub_proof</span><span class="p">)</span> <span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="p">(</span><span class="kt">Or</span> <span class="kr">_</span> <span class="n">q</span><span class="p">))</span> <span class="ow">=</span>
  <span class="n">isProofOf</span> <span class="n">sub_proof</span> <span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>

<span class="cm">{-</span>
<span class="cm">Or elimination:</span>
<span class="cm">(gamma |- p \/ q) &amp;&amp;</span>
<span class="cm">(gamma, p |- r) &amp;&amp;</span>
<span class="cm">(gamma, q |- r) =&gt;</span>
<span class="cm">(gamma |- r)</span>
<span class="cm">-}</span>
<span class="nf">isProofOf</span> <span class="p">(</span><span class="kt">OrElim</span> <span class="n">p</span> <span class="n">q</span> <span class="n">sub_proof_1</span> <span class="n">sub_proof_2</span> <span class="n">sub_proof_3</span><span class="p">)</span> <span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="ow">=</span>
  <span class="n">isProofOf</span> <span class="n">sub_proof_1</span> <span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="p">(</span><span class="kt">Or</span> <span class="n">p</span> <span class="n">q</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
  <span class="n">isProofOf</span> <span class="n">sub_proof_2</span> <span class="p">((</span><span class="n">p</span> <span class="kt">:</span> <span class="n">gamma</span><span class="p">),</span> <span class="n">r</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
  <span class="n">isProofOf</span> <span class="n">sub_proof_3</span> <span class="p">((</span><span class="n">q</span> <span class="kt">:</span> <span class="n">gamma</span><span class="p">),</span> <span class="n">r</span><span class="p">)</span>


<span class="cm">{-</span>
<span class="cm">Bottom elimination:</span>
<span class="cm">(gamma |- False) =&gt; (gamma |- p)</span>
<span class="cm">-}</span>
<span class="nf">isProofOf</span> <span class="p">(</span><span class="kt">BottomElim</span> <span class="n">sub_proof</span><span class="p">)</span> <span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span>
  <span class="n">isProofOf</span> <span class="n">sub_proof</span> <span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="kt">Bottom</span><span class="p">)</span>


<span class="cm">{-</span>
<span class="cm">Top introduction:</span>
<span class="cm">(gamma |- True)</span>
<span class="cm">-}</span>
<span class="nf">isProofOf</span> <span class="kt">TopIntro</span> <span class="p">(</span><span class="kr">_</span><span class="p">,</span> <span class="kt">Top</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">True</span>


<span class="cm">{-</span>
<span class="cm">Iff introduction:</span>
<span class="cm">(gamma, p |- q) &amp;&amp; (gamma, q |- p) =&gt; (gamma |- p &lt;=&gt; q)</span>
<span class="cm">-}</span>
<span class="nf">isProofOf</span> <span class="p">(</span><span class="kt">IffIntro</span> <span class="n">sub_proof_1</span> <span class="n">sub_proof_2</span><span class="p">)</span> <span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="p">(</span><span class="kt">Iff</span> <span class="n">p</span> <span class="n">q</span><span class="p">))</span> <span class="ow">=</span>
  <span class="n">isProofOf</span> <span class="n">sub_proof_1</span> <span class="p">((</span><span class="n">p</span> <span class="kt">:</span> <span class="n">gamma</span><span class="p">),</span> <span class="n">q</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
  <span class="n">isProofOf</span> <span class="n">sub_proof_2</span> <span class="p">((</span><span class="n">q</span> <span class="kt">:</span> <span class="n">gamma</span><span class="p">),</span> <span class="n">p</span><span class="p">)</span>

<span class="cm">{-</span>
<span class="cm">Iff elimination left:</span>
<span class="cm">(gamma |- p &lt;-&gt; q) &amp;&amp; (gamma |- p) =&gt; (gamma |- q)</span>
<span class="cm">-}</span>
<span class="nf">isProofOf</span> <span class="p">(</span><span class="kt">IffElimLeft</span> <span class="n">p</span> <span class="n">sub_proof_1</span> <span class="n">sub_proof_2</span><span class="p">)</span> <span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span> <span class="ow">=</span>
  <span class="n">isProofOf</span> <span class="n">sub_proof_1</span> <span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="p">(</span><span class="kt">Iff</span> <span class="n">p</span> <span class="n">q</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
  <span class="n">isProofOf</span> <span class="n">sub_proof_2</span> <span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>

<span class="cm">{-</span>
<span class="cm">Iff elimination right:</span>
<span class="cm">(gamma |- p &lt;-&gt; q) &amp;&amp; (gamma |- q) =&gt; (gamma |- p)</span>
<span class="cm">-}</span>
<span class="nf">isProofOf</span> <span class="p">(</span><span class="kt">IffElimRight</span> <span class="n">q</span> <span class="n">sub_proof_1</span> <span class="n">sub_proof_2</span><span class="p">)</span> <span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="ow">=</span>
  <span class="n">isProofOf</span> <span class="n">sub_proof_1</span> <span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="p">(</span><span class="kt">Iff</span> <span class="n">p</span> <span class="n">q</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
  <span class="n">isProofOf</span> <span class="n">sub_proof_2</span> <span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>


<span class="cm">{-</span>
<span class="cm">Contradiction:</span>
<span class="cm">(gamma, ~p |- False) =&gt; (gamma |- p)</span>
<span class="cm">-}</span>
<span class="nf">isProofOf</span> <span class="p">(</span><span class="kt">Contradiction</span> <span class="n">sub_proof</span><span class="p">)</span> <span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="ow">=</span>
  <span class="n">isProofOf</span> <span class="n">sub_proof</span> <span class="p">(((</span><span class="kt">Not</span> <span class="n">p</span><span class="p">)</span> <span class="kt">:</span> <span class="n">gamma</span><span class="p">),</span> <span class="kt">Bottom</span><span class="p">)</span>


<span class="cm">{-</span>
<span class="cm">Forall introduction:</span>
<span class="cm">(gamma |- p) &amp;&amp;</span>
<span class="cm">(x not free in gamma) =&gt;</span>
<span class="cm">(gamma |- forall x. p)</span>
<span class="cm">-}</span>
<span class="nf">isProofOf</span> <span class="p">(</span><span class="kt">ForallIntro</span> <span class="n">sub_proof</span><span class="p">)</span> <span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="p">(</span><span class="kt">Forall</span> <span class="n">x</span> <span class="n">p</span><span class="p">))</span> <span class="ow">=</span>
  <span class="n">isProofOf</span> <span class="n">sub_proof</span> <span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
  <span class="n">not</span> <span class="p">(</span><span class="n">any</span> <span class="p">(</span><span class="n">freeIn</span> <span class="n">x</span><span class="p">)</span> <span class="n">gamma</span><span class="p">)</span>

<span class="cm">{-</span>
<span class="cm">Forall elimination:</span>
<span class="cm">(gamma |- forall x. p) &amp;&amp;</span>
<span class="cm">(p admits t for x) =&gt;</span>
<span class="cm">(gamma |- p[t/x])</span>
<span class="cm">-}</span>
<span class="nf">isProofOf</span> <span class="p">(</span><span class="kt">ForallElim</span> <span class="n">p</span> <span class="n">t</span> <span class="n">x</span> <span class="n">sub_proof</span><span class="p">)</span> <span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="n">p'</span><span class="p">)</span> <span class="ow">=</span>
  <span class="n">isProofOf</span> <span class="n">sub_proof</span> <span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="p">(</span><span class="kt">Forall</span> <span class="n">x</span> <span class="n">p</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
  <span class="n">admits</span> <span class="n">p</span> <span class="n">t</span> <span class="n">x</span> <span class="o">&amp;&amp;</span>
  <span class="n">p'</span> <span class="o">==</span> <span class="p">(</span><span class="n">sub</span> <span class="n">p</span> <span class="n">t</span> <span class="n">x</span><span class="p">)</span>


<span class="cm">{-</span>
<span class="cm">Exists introduction:</span>
<span class="cm">(gamma |- p) &amp;&amp;</span>
<span class="cm">(p admits x for t) =&gt;</span>
<span class="cm">(gamma |- exists x. p [x/t])</span>
<span class="cm">-}</span>
<span class="nf">isProofOf</span> <span class="p">(</span><span class="kt">ExistsIntro</span> <span class="n">p</span> <span class="n">t</span> <span class="n">sub_proof</span><span class="p">)</span> <span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="p">(</span><span class="kt">Exists</span> <span class="n">x</span> <span class="n">p'</span><span class="p">))</span> <span class="ow">=</span>
  <span class="n">isProofOf</span> <span class="n">sub_proof</span> <span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
  <span class="n">admits</span> <span class="n">p</span> <span class="n">x</span> <span class="n">t</span> <span class="o">&amp;&amp;</span>
  <span class="n">p'</span> <span class="o">==</span> <span class="p">(</span><span class="n">sub</span> <span class="n">p</span> <span class="n">x</span> <span class="n">t</span><span class="p">)</span>

<span class="cm">{-</span>
<span class="cm">Exists elimination:</span>
<span class="cm">(gamma |- exists x. p) &amp;&amp;</span>
<span class="cm">(gamma, p [y/x] |- q) &amp;&amp;</span>
<span class="cm">(y not free in q) &amp;&amp;</span>
<span class="cm">(y not free in gamma) =&gt;</span>
<span class="cm">(gamma |- q)</span>
<span class="cm">-}</span>
<span class="nf">isProofOf</span> <span class="p">(</span><span class="kt">ExistsElim</span> <span class="n">p</span> <span class="n">y</span> <span class="n">x</span> <span class="n">sub_proof_1</span> <span class="n">sub_proof_2</span><span class="p">)</span> <span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span> <span class="ow">=</span>
  <span class="n">isProofOf</span> <span class="n">sub_proof_1</span> <span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="p">(</span><span class="kt">Exists</span> <span class="n">x</span> <span class="n">p</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
  <span class="n">isProofOf</span> <span class="n">sub_proof_2</span> <span class="p">(((</span><span class="n">sub</span> <span class="n">p</span> <span class="p">(</span><span class="kt">Var</span> <span class="n">y</span><span class="p">)</span> <span class="n">x</span><span class="p">)</span> <span class="kt">:</span> <span class="n">gamma</span><span class="p">),</span> <span class="n">q</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
  <span class="n">not</span> <span class="p">(</span><span class="n">freeIn</span> <span class="n">y</span> <span class="n">q</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
  <span class="n">not</span> <span class="p">(</span><span class="n">any</span> <span class="p">(</span><span class="n">freeIn</span> <span class="n">y</span><span class="p">)</span> <span class="n">gamma</span><span class="p">)</span>


<span class="cm">{-</span>
<span class="cm">Reflexivity:</span>
<span class="cm">(gamma |- t = t)</span>
<span class="cm">-}</span>
<span class="nf">isProofOf</span> <span class="kt">Reflexivity</span> <span class="p">(</span><span class="kr">_</span><span class="p">,</span> <span class="p">(</span><span class="kt">Pred</span> <span class="s">"Eq"</span> <span class="p">[</span><span class="n">t</span><span class="p">,</span> <span class="n">t'</span><span class="p">]))</span> <span class="ow">=</span> <span class="n">t</span> <span class="o">==</span> <span class="n">t'</span>

<span class="cm">{-</span>
<span class="cm">Substitution:</span>
<span class="cm">(gamma |- s = t) =&gt; (gamma |- p = p [t/s])</span>
<span class="cm">-}</span>
<span class="nf">isProofOf</span> <span class="p">(</span><span class="kt">Substitution</span> <span class="n">s</span> <span class="n">t</span> <span class="n">sub_proof</span><span class="p">)</span> <span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="p">(</span><span class="kt">Pred</span> <span class="s">"Eq"</span> <span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="n">p'</span><span class="p">]))</span> <span class="ow">=</span>
  <span class="n">isProofOf</span> <span class="n">sub_proof</span> <span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="p">(</span><span class="kt">Pred</span> <span class="s">"Eq"</span> <span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">]))</span> <span class="o">&amp;&amp;</span>
  <span class="n">p'</span> <span class="o">==</span> <span class="p">(</span><span class="n">sub</span> <span class="n">p</span> <span class="n">t</span> <span class="n">s</span><span class="p">)</span>

<span class="nf">isProofOf</span> <span class="kr">_</span> <span class="p">(</span><span class="kr">_</span><span class="p">,</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">False</span>
</code></pre></div>



<a name="268179806"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268179806" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268179806">(Jan 16 2022 at 11:43)</a>:</h4>
<p>Your rule for <code>ForallIntro</code> is problematic because you don't have a weakening rule: you won't be able to prove e.g. <code>x = x |- forall x. True</code>. One way to fix it is instead of checking <code>not (any (freeIn x) gamma)</code> you filter out everything from <code>gamma</code> which has a free <code>x</code> in the subproof.</p>



<a name="268179881"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268179881" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268179881">(Jan 16 2022 at 11:45)</a>:</h4>
<p>Your rule for <code>ExistsIntro</code> is backwards. You still want "p admits t for x" but the substitution is in the hypothesis, not the conclusion:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">Exists</span> <span class="n">introduction</span><span class="o">:</span>
<span class="o">(</span><span class="n">gamma</span> <span class="bp">|-</span> <span class="n">p</span> <span class="o">[</span><span class="n">t</span><span class="bp">/</span><span class="n">x</span><span class="o">])</span> <span class="bp">&amp;&amp;</span>
<span class="o">(</span><span class="n">p</span> <span class="n">admits</span> <span class="n">t</span> <span class="n">for</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=&gt;</span>
<span class="o">(</span><span class="n">gamma</span> <span class="bp">|-</span> <span class="n">exists</span> <span class="n">x.</span> <span class="n">p</span><span class="o">)</span>
</code></pre></div>



<a name="268179922"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268179922" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268179922">(Jan 16 2022 at 11:46)</a>:</h4>
<p>Alternatively you can just add a weakening rule <code>Weakening gamma' subproof</code> that checks that <code>gamma'</code> is a subset of the input context <code>gamma</code></p>



<a name="268193213"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268193213" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268193213">(Jan 16 2022 at 16:13)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/268179806">said</a>:</p>
<blockquote>
<p>Your rule for <code>ForallIntro</code> is problematic because you don't have a weakening rule: you won't be able to prove e.g. <code>x = x |- forall x. True</code>. One way to fix it is instead of checking <code>not (any (freeIn x) gamma)</code> you filter out everything from <code>gamma</code> which has a free <code>x</code> in the subproof.</p>
</blockquote>
<p>Hmm. I was attempting to interpret the statement in Logic and Proof (<a href="https://leanprover.github.io/logic_and_proof/first_order_logic.html#the-universal-quantifier">https://leanprover.github.io/logic_and_proof/first_order_logic.html#the-universal-quantifier</a>) <code>A(x) =&gt; Forall x. A(x) provided x is not free in any uncancelled hypothesis</code>. Did I interpret it wrong, or did I miss something in the text?</p>



<a name="268194377"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268194377" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268194377">(Jan 16 2022 at 16:39)</a>:</h4>
<p>I guess I was not sure how "not free in any uncancelled hypothesis" should translate. I'm not sure what you mean by "filter out everything from gamma which has a free x in the subproof.".</p>



<a name="268194627"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268194627" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268194627">(Jan 16 2022 at 16:45)</a>:</h4>
<p>That is, how do you code a check for a variable being free in a subproof?</p>



<a name="268195193"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268195193" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268195193">(Jan 16 2022 at 16:57)</a>:</h4>
<p>Is it the same as checking "if x is a free variable in p, then x is not free in any formula in gamma"?</p>



<a name="268209895"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268209895" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268209895">(Jan 16 2022 at 22:11)</a>:</h4>
<p>I guess you write a function pattern matching on the <code>Proof</code> type?</p>



<a name="268211328"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268211328" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268211328">(Jan 16 2022 at 22:47)</a>:</h4>
<p>I'm confused though, doesn't the gamma hold all of the uncancelled hypothesis?  So why is it not, according to "Logic and Proof", just a check that x is not free in gamma?</p>



<a name="268211365"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268211365" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268211365">(Jan 16 2022 at 22:48)</a>:</h4>
<p>Is there a missing axiom in "Logic and Proof"?</p>



<a name="268226969"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268226969" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Trebor Huang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268226969">(Jan 17 2022 at 04:39)</a>:</h4>
<p>Usually logic books treat <code>gamma</code> as a set, but you used a list. That's the difference.</p>



<a name="268227032"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268227032" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Trebor Huang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268227032">(Jan 17 2022 at 04:40)</a>:</h4>
<p>Some books treat it as a list, and additionally includes what's called <strong>structural</strong> rules. Removing some of those gives you substructural logcis like affine, relevant, linear, noncommutive etc.</p>



<a name="268227174"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268227174" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268227174">(Jan 17 2022 at 04:43)</a>:</h4>
<p>So I don't need a weakening rule if I use a set instead of a list?</p>



<a name="268227260"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268227260" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268227260">(Jan 17 2022 at 04:44)</a>:</h4>
<p>If so, I'm not sure I see why that solves the example Mario posted?</p>



<a name="268227329"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268227329" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Trebor Huang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268227329">(Jan 17 2022 at 04:46)</a>:</h4>
<p>You do need an additional weakening rule, because the <code>not free in gamma</code> requirements do not respect weakening.</p>



<a name="268227366"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268227366" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Trebor Huang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268227366">(Jan 17 2022 at 04:47)</a>:</h4>
<p>All the other rules respect weakening, so using only those rules, if <code>gamma |- p</code> is provable, then starting the proof all over again with <code>gamma ++ delta</code> instead still gives you a proof.</p>



<a name="268227529"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268227529" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Trebor Huang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268227529">(Jan 17 2022 at 04:50)</a>:</h4>
<p>The alternative as Mario points out, is, eg</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="o">(</span><span class="n">gamma</span> <span class="bp">|-</span> <span class="n">p</span><span class="o">)</span>
<span class="bp">=&gt;</span> <span class="o">(</span><span class="n">gamma</span> <span class="bp">++</span> <span class="n">delta</span> <span class="bp">|-</span> <span class="n">p</span><span class="o">)</span>
</code></pre></div>



<a name="268227544"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268227544" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268227544">(Jan 17 2022 at 04:50)</a>:</h4>
<p>So regardless if gamma is a set or a list, I need a weakening rule, correct? I guess I can see why it might be needed, but I'm curious why I haven't seen it listed in what I have been able to find for predicate calculus in natural deduction.</p>



<a name="268227608"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268227608" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268227608">(Jan 17 2022 at 04:52)</a>:</h4>
<p>Would you happen to have a reference that includes it?</p>



<a name="268227628"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268227628" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Trebor Huang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268227628">(Jan 17 2022 at 04:52)</a>:</h4>
<p>In pure propositional calculus you don't need it, as I argued above. In the "tree form" of natural deduction it is also not needed, because weakening is automatic.</p>



<a name="268227644"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268227644" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268227644">(Jan 17 2022 at 04:52)</a>:</h4>
<p>What is the tree form?</p>



<a name="268227818"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268227818" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Trebor Huang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268227818">(Jan 17 2022 at 04:56)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code> <span class="n">p</span>     <span class="n">q</span>
<span class="c1">-------</span>
  <span class="n">p</span> <span class="bp">&amp;</span> <span class="n">q</span>
</code></pre></div>
<p>Note that this proves <code>p, q |- p &amp; q</code>, but the <code>|-</code> doesn't appear.</p>



<a name="268227836"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268227836" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268227836">(Jan 17 2022 at 04:57)</a>:</h4>
<p>Oh, I thought they were just implicit when I saw that.</p>



<a name="268227911"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268227911" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268227911">(Jan 17 2022 at 04:58)</a>:</h4>
<p>So you don't have assumptions?</p>



<a name="268227934"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268227934" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Trebor Huang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268227934">(Jan 17 2022 at 04:58)</a>:</h4>
<p>You do, the assumptions are exactly the leaves of the derivation tree, <code>p</code> and <code>q</code> in this case.</p>



<a name="268227971"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268227971" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268227971">(Jan 17 2022 at 04:59)</a>:</h4>
<p>Those aren't proofs of p and q?</p>



<a name="268228146"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268228146" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Trebor Huang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268228146">(Jan 17 2022 at 05:01)</a>:</h4>
<p>No.</p>
<p>To formulate this properly, you need the rule for conjunction to be</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="o">(</span><span class="n">gamma</span> <span class="bp">|-</span> <span class="n">p</span><span class="o">)</span> <span class="bp">&amp;&amp;</span>
<span class="o">(</span><span class="n">delta</span> <span class="bp">|-</span> <span class="n">q</span><span class="o">)</span> <span class="bp">=&gt;</span>
<span class="o">(</span><span class="n">gamma</span> <span class="bp">++</span> <span class="n">delta</span> <span class="bp">|-</span> <span class="n">p</span> <span class="n">and</span> <span class="n">q</span><span class="o">)</span>
</code></pre></div>
<p>Because the leaves of the tree sitting on <code>p</code> and <code>q</code>, respectively, are combined.</p>



<a name="268228212"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268228212" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Trebor Huang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268228212">(Jan 17 2022 at 05:02)</a>:</h4>
<p>But you also need to use a set, because, well, leaves don't have an order.</p>



<a name="268228364"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268228364" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268228364">(Jan 17 2022 at 05:05)</a>:</h4>
<p>How would the proof for the example Mario gave work in that instance?</p>



<a name="268228430"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268228430" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268228430">(Jan 17 2022 at 05:07)</a>:</h4>
<p>Somehow combine <code>x = x |- ?</code> and <code>|- forall x, true</code>?</p>



<a name="268228547"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268228547" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268228547">(Jan 17 2022 at 05:09)</a>:</h4>
<p>I wonder if this is a better way to formulate it. I could use functions that take a proof of p and a proof of q and return a proof of p /\ q and not have to compare the gammas.</p>



<a name="268228557"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268228557" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268228557">(Jan 17 2022 at 05:09)</a>:</h4>
<p>Just combine them.</p>



<a name="268228626"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268228626" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268228626">(Jan 17 2022 at 05:10)</a>:</h4>
<p>Forward instead of backwards reasoning I guess.</p>



<a name="268229138"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268229138" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268229138">(Jan 17 2022 at 05:21)</a>:</h4>
<p>Is this Sequent natural deduction?</p>



<a name="268229970"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268229970" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268229970">(Jan 17 2022 at 05:39)</a>:</h4>
<p>What would the set of rules need to be to match the logic in lean?</p>



<a name="268234352"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268234352" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268234352">(Jan 17 2022 at 07:03)</a>:</h4>
<p>What I would like to have or create is a proof assistant for first order logic and axiomatic set theory, that has source code freely and publicly available (Mizar's doesn't seem to be?) that is easy to read and understand (probably preferably Haskell or similar), is close to standard texts or explains the reason for each deviation and why it is valid, and allows proofs to be constructed in a style such as</p>
<ol>
<li>statement, justification from axiom ax_1 using substitutions p, q.</li>
<li>statement, justification from theorem th_1 using substitutions r, s and line 1.</li>
<li>statement, justification from rule_1 using substitutions t, u and line 2.<br>
I think meta math may be the closest to this?, but the last time I tried (admittedly some time ago) I couldn't figure out the gui assistant, and I couldn't find the api that I assumed it used to create my own. I also wish the axioms for the logic were closer to the standard texts, although I think I may understand why they are not. It would be cool if the standard texts could be derived from them and vice versa. I'm not sure if I can write proofs in it in the form shown above? I might not mind working on it to achieve this, if that is possible.<br>
The reason for the Haskell code is in part to help understand the logic rules more clearly, and in part an attempt at a start to create the above.</li>
</ol>



<a name="268234427"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268234427" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268234427">(Jan 17 2022 at 07:04)</a>:</h4>
<p>MM0 has a vscode extension. Maybe that solves your gui issues?</p>



<a name="268234459"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268234459" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268234459">(Jan 17 2022 at 07:05)</a>:</h4>
<p>Maybe. I'll take a look.</p>



<a name="268234483"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268234483" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268234483">(Jan 17 2022 at 07:05)</a>:</h4>
<p>Thank you.</p>



<a name="268235977"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268235977" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268235977">(Jan 17 2022 at 07:31)</a>:</h4>
<p>My initial impression is that it may be more complicated than I had hoped, maybe in part because it starts at a lower level? Nice tutorial video.</p>



<a name="268238894"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268238894" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Trebor Huang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268238894">(Jan 17 2022 at 08:13)</a>:</h4>
<p>An aside: If you do that in Haskell and use the mechanisms of Haskell to create definitions, then during typechecking the definitions definitely will blow up exponentially. So you need something to prevent it from happening...</p>



<a name="268238996"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268238996" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Trebor Huang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268238996">(Jan 17 2022 at 08:14)</a>:</h4>
<p>Like, if you implement a definition hierarchy as described in Metamath or Lean, it will get expanded all the way down when your checker tries to see if two terms are equal.</p>



<a name="268293833"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268293833" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268293833">(Jan 17 2022 at 16:52)</a>:</h4>
<p>So you need something in the axioms of the logic to handle definitions?</p>



<a name="268295575"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268295575" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268295575">(Jan 17 2022 at 17:08)</a>:</h4>
<p>How is it addressed in Lean and MetaMath?</p>



<a name="268296598"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268296598" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Trebor Huang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268296598">(Jan 17 2022 at 17:20)</a>:</h4>
<p>Lean has the reducible/semireducible/opaque distinction, and other well-established stuff in type theory. Metamath does not have "definitions". Every new definition is actually little axioms, with additional checks which are detailed on the website.</p>



<a name="268297941"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268297941" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268297941">(Jan 17 2022 at 17:35)</a>:</h4>
<p>It looks like in mm0 definitions are part of the formal grammar.</p>



<a name="268301192"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268301192" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268301192">(Jan 17 2022 at 18:11)</a>:</h4>
<p>Is there a resource that explains more in depth the theory of definitions in mm0?</p>



<a name="268309235"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268309235" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268309235">(Jan 17 2022 at 19:45)</a>:</h4>
<p>Aside from issues of efficiency, just to ensure my understanding, is this a correct implementation of first order logic with equality? Especially the <code>admitsVar</code> and <code>admitsTerm</code> functions? Thank you.</p>
<div class="codehilite" data-code-language="Haskell"><pre><span></span><code><span class="cm">{-</span>
<span class="cm">Hilbert style first order mathematical logic with equality using named variables.</span>

<span class="cm">Modified from "Handbook of Practical Logic and Automated Reasoning" by John Harrison.</span>
<span class="cm">https://www.cl.cam.ac.uk/~jrh13/atp/index.html</span>
<span class="cm">-}</span>

<span class="kr">import</span> <span class="nn">Data.List</span>

<span class="cm">{-</span>
<span class="cm">Func "c" [] : A constant named "c"</span>
<span class="cm">Func "f" [v] : A function named "f" of one variable v</span>
<span class="cm">-}</span>
<span class="kr">data</span> <span class="kt">Term</span> <span class="ow">=</span> <span class="kt">Var</span> <span class="kt">String</span>
          <span class="o">|</span> <span class="kt">Func</span> <span class="kt">String</span> <span class="p">[</span><span class="kt">Term</span><span class="p">]</span>
            <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">)</span>

<span class="cm">{-</span>
<span class="cm">Pred "P" [] : A propositional variable named "P"</span>
<span class="cm">Pred "Eq" [s, t] : s = t</span>
<span class="cm">-}</span>
<span class="kr">data</span> <span class="kt">Formula</span> <span class="ow">=</span> <span class="kt">Pred</span> <span class="kt">String</span> <span class="p">[</span><span class="kt">Term</span><span class="p">]</span>
             <span class="o">|</span> <span class="kt">Not</span> <span class="kt">Formula</span>
             <span class="o">|</span> <span class="kt">Imp</span> <span class="kt">Formula</span> <span class="kt">Formula</span>
             <span class="o">|</span> <span class="kt">Forall</span> <span class="kt">String</span> <span class="kt">Formula</span>
               <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">)</span>

<span class="kr">newtype</span> <span class="kt">Theorem</span> <span class="ow">=</span> <span class="kt">Theorem</span> <span class="kt">Formula</span>
                  <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">)</span>

<span class="cm">{-</span>
<span class="cm">From "First Order Mathematical Logic" by Angelo Margaris:</span>

<span class="cm">An occurrence of a variable $v$ in a formula $P$ is bound if and only if</span>
<span class="cm">it occurs in a subformula of $P$ of the form $\forall v Q$. An occurrence</span>
<span class="cm">of $v$ in $P$ is free if and only if it is not a bound occurrence. The</span>
<span class="cm">variable $v$ is free or bound in $P$ according as it has a free or bound</span>
<span class="cm">occurrence in $P$.</span>

<span class="cm">If $P$ is a formula, $v$ is a variable, and $t$ is a term, then $P(t/v)$ is</span>
<span class="cm">the result of replacing each free occurrence of $v$ in $P$ by an occurrence</span>
<span class="cm">of $t$.</span>

<span class="cm">If $v$ and $u$ are variables and $P$ is a formula, then $P$ admits $u$ for $v$</span>
<span class="cm">if and only if there is no free occurrence of $v$ in $P$ that becomes a</span>
<span class="cm">bound occurrence of $u$ in $P(u/v)$. If $t$ is a term, then $P$ admits $t$ for</span>
<span class="cm">$v$ if and only if $P$ admits for $v$ every variable in $t$.</span>
<span class="cm">-}</span>

<span class="c1">-- occursIn v t = there exists an occurrence of v in t.</span>
<span class="nf">occursIn</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Term</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">occursIn</span> <span class="n">v</span> <span class="p">(</span><span class="kt">Var</span> <span class="n">v'</span><span class="p">)</span> <span class="ow">=</span> <span class="n">v</span> <span class="o">==</span> <span class="n">v'</span>
<span class="nf">occursIn</span> <span class="n">v</span> <span class="p">(</span><span class="kt">Func</span> <span class="kr">_</span> <span class="n">terms</span><span class="p">)</span> <span class="ow">=</span> <span class="n">any</span> <span class="p">(</span><span class="n">occursIn</span> <span class="n">v</span><span class="p">)</span> <span class="n">terms</span>

<span class="c1">-- freeIn v p = there exists an occurrence of v in p that is free.</span>
<span class="nf">freeIn</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Formula</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">freeIn</span> <span class="n">v</span> <span class="p">(</span><span class="kt">Pred</span> <span class="kr">_</span> <span class="n">terms</span><span class="p">)</span> <span class="ow">=</span> <span class="n">any</span> <span class="p">(</span><span class="n">occursIn</span> <span class="n">v</span><span class="p">)</span> <span class="n">terms</span>
<span class="nf">freeIn</span> <span class="n">v</span> <span class="p">(</span><span class="kt">Not</span> <span class="n">p</span><span class="p">)</span> <span class="ow">=</span> <span class="n">freeIn</span> <span class="n">v</span> <span class="n">p</span>
<span class="nf">freeIn</span> <span class="n">v</span> <span class="p">(</span><span class="kt">Imp</span> <span class="n">p</span> <span class="n">q</span><span class="p">)</span> <span class="ow">=</span> <span class="n">freeIn</span> <span class="n">v</span> <span class="n">p</span> <span class="o">||</span> <span class="n">freeIn</span> <span class="n">v</span> <span class="n">q</span>
<span class="nf">freeIn</span> <span class="n">v</span> <span class="p">(</span><span class="kt">Forall</span> <span class="n">v'</span> <span class="n">p</span><span class="p">)</span> <span class="ow">=</span> <span class="n">v</span> <span class="o">/=</span> <span class="n">v'</span> <span class="o">&amp;&amp;</span> <span class="n">freeIn</span> <span class="n">v</span> <span class="n">p</span>

<span class="cm">{-</span>
<span class="cm">subIn p t v = p(t/v) = the result of replacing each free occurrence of</span>
<span class="cm">v in p by an occurrence of t.</span>
<span class="cm">-}</span>
<span class="nf">subIn</span> <span class="ow">::</span> <span class="kt">Formula</span> <span class="ow">-&gt;</span> <span class="kt">Term</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Formula</span>
<span class="nf">subIn</span> <span class="p">(</span><span class="kt">Pred</span> <span class="n">name</span> <span class="n">terms</span><span class="p">)</span> <span class="n">t</span> <span class="n">v</span> <span class="ow">=</span> <span class="kt">Pred</span> <span class="n">name</span> <span class="p">(</span><span class="kt">Data</span><span class="o">.</span><span class="kt">List</span><span class="o">.</span><span class="n">map</span> <span class="p">(</span><span class="nf">\</span><span class="n">t'</span> <span class="ow">-&gt;</span> <span class="n">subInTerm</span> <span class="n">t'</span> <span class="n">t</span> <span class="n">v</span><span class="p">)</span> <span class="n">terms</span><span class="p">)</span> <span class="kr">where</span>
  <span class="cm">{-</span>
<span class="cm">  subInTerm t' t v = t'(t/v) = the result of replacing each occurrence of</span>
<span class="cm">  v in t' by an occurrence of t.</span>
<span class="cm">  -}</span>
  <span class="n">subInTerm</span> <span class="ow">::</span> <span class="kt">Term</span> <span class="ow">-&gt;</span> <span class="kt">Term</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Term</span>
  <span class="n">subInTerm</span> <span class="p">(</span><span class="kt">Var</span> <span class="n">v'</span><span class="p">)</span> <span class="n">t</span> <span class="n">v</span> <span class="ow">=</span> <span class="kr">if</span> <span class="n">v</span> <span class="o">==</span> <span class="n">v'</span> <span class="kr">then</span> <span class="n">t</span> <span class="kr">else</span> <span class="kt">Var</span> <span class="n">v'</span>
  <span class="n">subInTerm</span> <span class="p">(</span><span class="kt">Func</span> <span class="n">name</span> <span class="n">terms</span><span class="p">)</span> <span class="n">t</span> <span class="n">v</span> <span class="ow">=</span> <span class="kt">Func</span> <span class="n">name</span> <span class="p">(</span><span class="kt">Data</span><span class="o">.</span><span class="kt">List</span><span class="o">.</span><span class="n">map</span> <span class="p">(</span><span class="nf">\</span><span class="n">t'</span> <span class="ow">-&gt;</span> <span class="n">subInTerm</span> <span class="n">t'</span> <span class="n">t</span> <span class="n">v</span><span class="p">)</span> <span class="n">terms</span><span class="p">)</span>
<span class="nf">subIn</span> <span class="p">(</span><span class="kt">Not</span> <span class="n">p</span><span class="p">)</span> <span class="n">t</span> <span class="n">v</span> <span class="ow">=</span> <span class="kt">Not</span> <span class="p">(</span><span class="n">subIn</span> <span class="n">p</span> <span class="n">t</span> <span class="n">v</span><span class="p">)</span>
<span class="nf">subIn</span> <span class="p">(</span><span class="kt">Imp</span> <span class="n">p</span> <span class="n">q</span><span class="p">)</span> <span class="n">t</span> <span class="n">v</span> <span class="ow">=</span> <span class="kt">Imp</span> <span class="p">(</span><span class="n">subIn</span> <span class="n">p</span> <span class="n">t</span> <span class="n">v</span><span class="p">)</span> <span class="p">(</span><span class="n">subIn</span> <span class="n">q</span> <span class="n">t</span> <span class="n">v</span><span class="p">)</span>
<span class="nf">subIn</span> <span class="p">(</span><span class="kt">Forall</span> <span class="n">v'</span> <span class="n">p</span><span class="p">)</span> <span class="n">t</span> <span class="n">v</span> <span class="ow">=</span> <span class="kr">if</span> <span class="n">v</span> <span class="o">==</span> <span class="n">v'</span> <span class="kr">then</span> <span class="kt">Forall</span> <span class="n">v'</span> <span class="n">p</span> <span class="kr">else</span> <span class="kt">Forall</span> <span class="n">v'</span> <span class="p">(</span><span class="n">subIn</span> <span class="n">p</span> <span class="n">t</span> <span class="n">v</span><span class="p">)</span>

<span class="cm">{-</span>
<span class="cm">admitsVar p u v = p admits u for v = there is no free occurrence of</span>
<span class="cm">v in p that becomes a bound occurrence of u in p(u/v).</span>
<span class="cm">-}</span>
<span class="nf">admitsVar</span> <span class="ow">::</span> <span class="kt">Formula</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">admitsVar</span> <span class="n">p</span> <span class="n">u</span> <span class="n">v</span> <span class="ow">=</span> <span class="n">go</span> <span class="n">p</span> <span class="n">u</span> <span class="n">v</span> <span class="kt">[]</span> <span class="kr">where</span>
  <span class="n">go</span> <span class="ow">::</span> <span class="kt">Formula</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
  <span class="n">go</span> <span class="p">(</span><span class="kt">Pred</span> <span class="kr">_</span> <span class="n">terms</span><span class="p">)</span> <span class="n">u</span> <span class="n">v</span> <span class="n">binders</span> <span class="ow">=</span> <span class="n">not</span> <span class="p">(</span><span class="n">any</span> <span class="p">(</span><span class="n">occursIn</span> <span class="n">v</span><span class="p">)</span> <span class="n">terms</span><span class="p">)</span>
                               <span class="o">||</span> <span class="n">elem</span> <span class="n">v</span> <span class="n">binders</span>
                               <span class="o">||</span> <span class="n">notElem</span> <span class="n">u</span> <span class="n">binders</span>
  <span class="n">go</span> <span class="p">(</span><span class="kt">Not</span> <span class="n">p</span><span class="p">)</span> <span class="n">u</span> <span class="n">v</span> <span class="n">binders</span> <span class="ow">=</span> <span class="n">go</span> <span class="n">p</span> <span class="n">u</span> <span class="n">v</span> <span class="n">binders</span>
  <span class="n">go</span> <span class="p">(</span><span class="kt">Imp</span> <span class="n">p</span> <span class="n">q</span><span class="p">)</span> <span class="n">u</span> <span class="n">v</span> <span class="n">binders</span> <span class="ow">=</span> <span class="n">go</span> <span class="n">p</span> <span class="n">u</span> <span class="n">v</span> <span class="n">binders</span> <span class="o">&amp;&amp;</span> <span class="n">go</span> <span class="n">q</span> <span class="n">u</span> <span class="n">v</span> <span class="n">binders</span>
  <span class="n">go</span> <span class="p">(</span><span class="kt">Forall</span> <span class="n">v'</span> <span class="n">p</span><span class="p">)</span> <span class="n">u</span> <span class="n">v</span> <span class="n">binders</span> <span class="ow">=</span> <span class="n">go</span> <span class="n">p</span> <span class="n">u</span> <span class="n">v</span> <span class="p">(</span><span class="n">v'</span> <span class="kt">:</span> <span class="n">binders</span><span class="p">)</span>

<span class="cm">{-</span>
<span class="cm">admitsTerm p t v = p admits for v every variable in t.</span>
<span class="cm">-}</span>
<span class="nf">admitsTerm</span> <span class="ow">::</span> <span class="kt">Formula</span> <span class="ow">-&gt;</span> <span class="kt">Term</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">admitsTerm</span> <span class="n">p</span> <span class="p">(</span><span class="kt">Var</span> <span class="n">u</span><span class="p">)</span> <span class="n">v</span> <span class="ow">=</span> <span class="n">admitsVar</span> <span class="n">p</span> <span class="n">u</span> <span class="n">v</span>
<span class="nf">admitsTerm</span> <span class="n">p</span> <span class="p">(</span><span class="kt">Func</span> <span class="kr">_</span> <span class="n">terms</span><span class="p">)</span> <span class="n">v</span> <span class="ow">=</span> <span class="n">all</span> <span class="p">(</span><span class="nf">\</span><span class="n">t</span> <span class="ow">-&gt;</span> <span class="n">admitsTerm</span> <span class="n">p</span> <span class="n">t</span> <span class="n">v</span><span class="p">)</span> <span class="n">terms</span>


<span class="c1">-- Propositional calculus</span>

<span class="c1">-- |- (p -&gt; (q -&gt; p))</span>
<span class="nf">prop_1</span> <span class="ow">::</span> <span class="kt">Formula</span> <span class="ow">-&gt;</span> <span class="kt">Formula</span> <span class="ow">-&gt;</span> <span class="kt">Theorem</span>
<span class="nf">prop_1</span> <span class="n">p</span> <span class="n">q</span> <span class="ow">=</span> <span class="kt">Theorem</span> <span class="p">(</span><span class="n">p</span> <span class="p">`</span><span class="kt">Imp</span><span class="p">`</span> <span class="p">(</span><span class="n">q</span> <span class="p">`</span><span class="kt">Imp</span><span class="p">`</span> <span class="n">p</span><span class="p">))</span>

<span class="c1">-- |- ((p -&gt; (q -&gt; r)) -&gt; ((p -&gt; q) -&gt; (p -&gt; r)))</span>
<span class="nf">prop_2</span> <span class="ow">::</span> <span class="kt">Formula</span> <span class="ow">-&gt;</span> <span class="kt">Formula</span> <span class="ow">-&gt;</span> <span class="kt">Formula</span> <span class="ow">-&gt;</span> <span class="kt">Theorem</span>
<span class="nf">prop_2</span> <span class="n">p</span> <span class="n">q</span> <span class="n">r</span> <span class="ow">=</span> <span class="kt">Theorem</span> <span class="p">((</span><span class="n">p</span> <span class="p">`</span><span class="kt">Imp</span><span class="p">`</span> <span class="p">(</span><span class="n">q</span> <span class="p">`</span><span class="kt">Imp</span><span class="p">`</span> <span class="n">r</span><span class="p">))</span> <span class="p">`</span><span class="kt">Imp</span><span class="p">`</span> <span class="p">((</span><span class="n">p</span> <span class="p">`</span><span class="kt">Imp</span><span class="p">`</span> <span class="n">q</span><span class="p">)</span> <span class="p">`</span><span class="kt">Imp</span><span class="p">`</span> <span class="p">(</span><span class="n">p</span> <span class="p">`</span><span class="kt">Imp</span><span class="p">`</span> <span class="n">r</span><span class="p">)))</span>

<span class="c1">-- |- ((~p -&gt; ~q) -&gt; (q -&gt; p))</span>
<span class="nf">prop_3</span> <span class="ow">::</span> <span class="kt">Formula</span> <span class="ow">-&gt;</span> <span class="kt">Formula</span> <span class="ow">-&gt;</span> <span class="kt">Theorem</span>
<span class="nf">prop_3</span> <span class="n">p</span> <span class="n">q</span> <span class="ow">=</span> <span class="kt">Theorem</span> <span class="p">(((</span><span class="kt">Not</span> <span class="n">p</span><span class="p">)</span> <span class="p">`</span><span class="kt">Imp</span><span class="p">`</span> <span class="p">(</span><span class="kt">Not</span> <span class="n">q</span><span class="p">))</span> <span class="p">`</span><span class="kt">Imp</span><span class="p">`</span> <span class="p">(</span><span class="n">q</span> <span class="p">`</span><span class="kt">Imp</span><span class="p">`</span> <span class="n">p</span><span class="p">))</span>

<span class="c1">-- |- p &amp; |- (p -&gt; q) =&gt; |- q</span>
<span class="nf">mp</span> <span class="ow">::</span> <span class="kt">Theorem</span> <span class="ow">-&gt;</span> <span class="kt">Theorem</span> <span class="ow">-&gt;</span> <span class="kt">Theorem</span>
<span class="nf">mp</span> <span class="p">(</span><span class="kt">Theorem</span> <span class="n">p</span><span class="p">)</span> <span class="p">(</span><span class="kt">Theorem</span> <span class="p">(</span><span class="n">p'</span> <span class="p">`</span><span class="kt">Imp</span><span class="p">`</span> <span class="n">q</span><span class="p">))</span> <span class="ow">=</span> <span class="kr">if</span> <span class="n">p</span> <span class="o">==</span> <span class="n">p'</span> <span class="kr">then</span> <span class="kt">Theorem</span> <span class="n">q</span> <span class="kr">else</span> <span class="ne">error</span> <span class="s">"mp"</span>
<span class="nf">mp</span> <span class="kr">_</span> <span class="kr">_</span> <span class="ow">=</span> <span class="ne">error</span> <span class="s">"mp"</span>


<span class="c1">-- Predicate calculus</span>

<span class="c1">-- |- p =&gt; |- forall v. p</span>
<span class="nf">gen</span> <span class="ow">::</span> <span class="kt">Theorem</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Theorem</span>
<span class="nf">gen</span> <span class="p">(</span><span class="kt">Theorem</span> <span class="n">p</span><span class="p">)</span> <span class="n">v</span> <span class="ow">=</span> <span class="kt">Theorem</span> <span class="p">(</span><span class="kt">Forall</span> <span class="n">v</span> <span class="n">p</span><span class="p">)</span>

<span class="c1">-- |- ((forall v. (p -&gt; q)) -&gt; (forall v. p) -&gt; (forall v. q))</span>
<span class="nf">pred_1</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Formula</span> <span class="ow">-&gt;</span> <span class="kt">Formula</span> <span class="ow">-&gt;</span> <span class="kt">Theorem</span>
<span class="nf">pred_1</span> <span class="n">v</span> <span class="n">p</span> <span class="n">q</span> <span class="ow">=</span> <span class="kt">Theorem</span> <span class="p">((</span><span class="kt">Forall</span> <span class="n">v</span> <span class="p">(</span><span class="n">p</span> <span class="p">`</span><span class="kt">Imp</span><span class="p">`</span> <span class="n">q</span><span class="p">))</span> <span class="p">`</span><span class="kt">Imp</span><span class="p">`</span> <span class="p">((</span><span class="kt">Forall</span> <span class="n">v</span> <span class="n">p</span><span class="p">)</span> <span class="p">`</span><span class="kt">Imp</span><span class="p">`</span> <span class="p">(</span><span class="kt">Forall</span> <span class="n">v</span> <span class="n">q</span><span class="p">)))</span>

<span class="c1">-- |- (forall v. p -&gt; p [t/v]) provided p admits t for v</span>
<span class="nf">pred_2</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Formula</span> <span class="ow">-&gt;</span> <span class="kt">Term</span> <span class="ow">-&gt;</span> <span class="kt">Theorem</span>
<span class="nf">pred_2</span> <span class="n">v</span> <span class="n">p</span> <span class="n">t</span> <span class="ow">=</span> <span class="kr">if</span> <span class="n">admitsTerm</span> <span class="n">p</span> <span class="n">t</span> <span class="n">v</span> <span class="kr">then</span> <span class="kt">Theorem</span> <span class="p">((</span><span class="kt">Forall</span> <span class="n">v</span> <span class="n">p</span><span class="p">)</span> <span class="p">`</span><span class="kt">Imp</span><span class="p">`</span> <span class="p">(</span><span class="n">subIn</span> <span class="n">p</span> <span class="n">t</span> <span class="n">v</span><span class="p">))</span> <span class="kr">else</span> <span class="ne">error</span> <span class="s">"pred_2"</span>

<span class="c1">-- |- (p -&gt; forall v. p) provided v is not free in p</span>
<span class="nf">pred_3</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Formula</span> <span class="ow">-&gt;</span> <span class="kt">Theorem</span>
<span class="nf">pred_3</span> <span class="n">v</span> <span class="n">p</span> <span class="ow">=</span> <span class="kr">if</span> <span class="n">not</span> <span class="p">(</span><span class="n">freeIn</span> <span class="n">v</span> <span class="n">p</span><span class="p">)</span> <span class="kr">then</span> <span class="kt">Theorem</span> <span class="p">(</span><span class="n">p</span> <span class="p">`</span><span class="kt">Imp</span><span class="p">`</span> <span class="p">(</span><span class="kt">Forall</span> <span class="n">v</span> <span class="n">p</span><span class="p">))</span> <span class="kr">else</span> <span class="ne">error</span> <span class="s">"pred_3"</span>


<span class="c1">-- Equality</span>

<span class="c1">-- |- t = t</span>
<span class="nf">eq_1</span> <span class="ow">::</span> <span class="kt">Term</span> <span class="ow">-&gt;</span> <span class="kt">Theorem</span>
<span class="nf">eq_1</span> <span class="n">t</span> <span class="ow">=</span> <span class="kt">Theorem</span> <span class="p">(</span><span class="kt">Pred</span> <span class="s">"Eq"</span> <span class="p">[</span><span class="n">t</span><span class="p">,</span> <span class="n">t</span><span class="p">])</span>

<span class="c1">-- |- s1 = t1 ==&gt; ... ==&gt; sn = tn ==&gt; f(s1,..,sn) = f(t1,..,tn)</span>
<span class="nf">eq_2</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Term</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Term</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Theorem</span>
<span class="nf">eq_2</span> <span class="n">f</span> <span class="n">ss</span> <span class="n">ts</span> <span class="ow">=</span> <span class="kr">if</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">List</span><span class="o">.</span><span class="n">length</span> <span class="n">ss</span> <span class="o">==</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">List</span><span class="o">.</span><span class="n">length</span> <span class="n">ts</span> <span class="kr">then</span>
               <span class="c1">-- eqs = [s1 = t1, ..., sn = tn]</span>
               <span class="kr">let</span> <span class="n">eqs</span> <span class="ow">=</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">List</span><span class="o">.</span><span class="n">zipWith</span> <span class="p">(</span><span class="nf">\</span><span class="n">s</span> <span class="n">t</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Pred</span> <span class="s">"Eq"</span> <span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">]))</span> <span class="n">ss</span> <span class="n">ts</span> <span class="kr">in</span>
               <span class="c1">-- z = f(s1,..,sn) = f(t1,..,tn)</span>
               <span class="kr">let</span> <span class="n">z</span> <span class="ow">=</span> <span class="kt">Pred</span> <span class="s">"Eq"</span> <span class="p">[(</span><span class="kt">Func</span> <span class="n">f</span> <span class="n">ss</span><span class="p">),</span> <span class="p">(</span><span class="kt">Func</span> <span class="n">f</span> <span class="n">ts</span><span class="p">)]</span> <span class="kr">in</span>
               <span class="kt">Theorem</span> <span class="p">(</span><span class="kt">Data</span><span class="o">.</span><span class="kt">List</span><span class="o">.</span><span class="n">foldr</span> <span class="kt">Imp</span> <span class="n">z</span> <span class="n">eqs</span><span class="p">)</span>
               <span class="kr">else</span> <span class="ne">error</span> <span class="s">"eq_2"</span>

<span class="c1">-- |- s1 = t1 ==&gt; ... ==&gt; sn = tn ==&gt; P(s1,..,sn) ==&gt; P(t1,..,tn)</span>
<span class="nf">eq_3</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Term</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Term</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Theorem</span>
<span class="nf">eq_3</span> <span class="n">p</span> <span class="n">ss</span> <span class="n">ts</span> <span class="ow">=</span> <span class="kr">if</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">List</span><span class="o">.</span><span class="n">length</span> <span class="n">ss</span> <span class="o">==</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">List</span><span class="o">.</span><span class="n">length</span> <span class="n">ts</span> <span class="kr">then</span>
               <span class="c1">-- eqs = [s1 = t1, ..., sn = tn]</span>
               <span class="kr">let</span> <span class="n">eqs</span> <span class="ow">=</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">List</span><span class="o">.</span><span class="n">zipWith</span> <span class="p">(</span><span class="nf">\</span><span class="n">s</span> <span class="n">t</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Pred</span> <span class="s">"Eq"</span> <span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">]))</span> <span class="n">ss</span> <span class="n">ts</span> <span class="kr">in</span>
               <span class="c1">-- z = P(s1,..,sn) ==&gt; P(t1,..,tn)</span>
               <span class="kr">let</span> <span class="n">z</span> <span class="ow">=</span> <span class="p">(</span><span class="kt">Pred</span> <span class="n">p</span> <span class="n">ss</span><span class="p">)</span> <span class="p">`</span><span class="kt">Imp</span><span class="p">`</span> <span class="p">(</span><span class="kt">Pred</span> <span class="n">p</span> <span class="n">ts</span><span class="p">)</span> <span class="kr">in</span>
               <span class="kt">Theorem</span> <span class="p">(</span><span class="kt">Data</span><span class="o">.</span><span class="kt">List</span><span class="o">.</span><span class="n">foldr</span> <span class="kt">Imp</span> <span class="n">z</span> <span class="n">eqs</span><span class="p">)</span>
               <span class="kr">else</span> <span class="ne">error</span> <span class="s">"eq_3"</span>
</code></pre></div>



<a name="268327823"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268327823" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268327823">(Jan 18 2022 at 00:15)</a>:</h4>
<p>The theory of definitions in MM0 is described in the <a href="https://arxiv.org/abs/1910.10703">Metamath Zero paper</a> (Fig. 3, p.11). It's basically a pared-down version of lean's defeq judgment: there is a proof rule that lets you replace an expression with one obtained by unfolding some definition inside the expression.</p>



<a name="268328656"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268328656" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268328656">(Jan 18 2022 at 00:29)</a>:</h4>
<p>Thank you. I saw that, but I had trouble following the notation, and I'm not familiar with multi sorted FOL.</p>



<a name="268328720"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268328720" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268328720">(Jan 18 2022 at 00:30)</a>:</h4>
<p>That is, I don't know if it being multi sorted is part of the notation.</p>



<a name="268331019"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268331019" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268331019">(Jan 18 2022 at 01:10)</a>:</h4>
<p>I guess I should add some context :)</p>
<div class="codehilite" data-code-language="Haskell"><pre><span></span><code><span class="cm">{-</span>
<span class="cm">Hilbert style first order mathematical logic with equality using named variables.</span>

<span class="cm">Modified from "Handbook of Practical Logic and Automated Reasoning" by John Harrison.</span>
<span class="cm">https://www.cl.cam.ac.uk/~jrh13/atp/index.html</span>
<span class="cm">-}</span>


<span class="cm">{-</span>
<span class="cm">Func "c" [] : A constant named "c"</span>
<span class="cm">Func "f" [v] : A function named "f" of one variable v</span>
<span class="cm">-}</span>
<span class="kr">data</span> <span class="kt">Term</span> <span class="ow">=</span> <span class="kt">Var</span> <span class="kt">String</span>
          <span class="o">|</span> <span class="kt">Func</span> <span class="kt">String</span> <span class="p">[</span><span class="kt">Term</span><span class="p">]</span>
            <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">)</span>

<span class="cm">{-</span>
<span class="cm">Pred "P" [] : A propositional variable named "P"</span>
<span class="cm">Pred "Eq" [s, t] : s = t</span>
<span class="cm">-}</span>
<span class="kr">data</span> <span class="kt">Formula</span> <span class="ow">=</span> <span class="kt">Pred</span> <span class="kt">String</span> <span class="p">[</span><span class="kt">Term</span><span class="p">]</span>
             <span class="o">|</span> <span class="kt">Not</span> <span class="kt">Formula</span>
             <span class="o">|</span> <span class="kt">Imp</span> <span class="kt">Formula</span> <span class="kt">Formula</span>
             <span class="o">|</span> <span class="kt">Forall</span> <span class="kt">String</span> <span class="kt">Formula</span>
               <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">)</span>

<span class="kr">type</span> <span class="kt">Context</span> <span class="ow">=</span> <span class="p">[</span><span class="kt">Formula</span><span class="p">]</span>

<span class="kr">data</span> <span class="kt">Theorem</span> <span class="ow">=</span> <span class="kt">Theorem</span> <span class="kt">Context</span> <span class="kt">Formula</span>
               <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">)</span>

<span class="cm">{-</span>
<span class="cm">From "First Order Mathematical Logic" by Angelo Margaris:</span>

<span class="cm">An occurrence of a variable $v$ in a formula $P$ is bound if and only if</span>
<span class="cm">it occurs in a subformula of $P$ of the form $\forall v Q$. An occurrence</span>
<span class="cm">of $v$ in $P$ is free if and only if it is not a bound occurrence. The</span>
<span class="cm">variable $v$ is free or bound in $P$ according as it has a free or bound</span>
<span class="cm">occurrence in $P$.</span>

<span class="cm">If $P$ is a formula, $v$ is a variable, and $t$ is a term, then $P(t/v)$ is</span>
<span class="cm">the result of replacing each free occurrence of $v$ in $P$ by an occurrence</span>
<span class="cm">of $t$.</span>

<span class="cm">If $v$ and $u$ are variables and $P$ is a formula, then $P$ admits $u$ for $v$</span>
<span class="cm">if and only if there is no free occurrence of $v$ in $P$ that becomes a</span>
<span class="cm">bound occurrence of $u$ in $P(u/v)$. If $t$ is a term, then $P$ admits $t$ for</span>
<span class="cm">$v$ if and only if $P$ admits for $v$ every variable in $t$.</span>
<span class="cm">-}</span>

<span class="c1">-- occursIn v t = there exists an occurrence of v in t.</span>
<span class="nf">occursIn</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Term</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">occursIn</span> <span class="n">v</span> <span class="p">(</span><span class="kt">Var</span> <span class="n">v'</span><span class="p">)</span> <span class="ow">=</span> <span class="n">v</span> <span class="o">==</span> <span class="n">v'</span>
<span class="nf">occursIn</span> <span class="n">v</span> <span class="p">(</span><span class="kt">Func</span> <span class="kr">_</span> <span class="n">terms</span><span class="p">)</span> <span class="ow">=</span> <span class="n">any</span> <span class="p">(</span><span class="n">occursIn</span> <span class="n">v</span><span class="p">)</span> <span class="n">terms</span>

<span class="c1">-- freeIn v p = there exists an occurrence of v in p that is free.</span>
<span class="nf">freeIn</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Formula</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">freeIn</span> <span class="n">v</span> <span class="p">(</span><span class="kt">Pred</span> <span class="kr">_</span> <span class="n">terms</span><span class="p">)</span> <span class="ow">=</span> <span class="n">any</span> <span class="p">(</span><span class="n">occursIn</span> <span class="n">v</span><span class="p">)</span> <span class="n">terms</span>
<span class="nf">freeIn</span> <span class="n">v</span> <span class="p">(</span><span class="kt">Not</span> <span class="n">p</span><span class="p">)</span> <span class="ow">=</span> <span class="n">freeIn</span> <span class="n">v</span> <span class="n">p</span>
<span class="nf">freeIn</span> <span class="n">v</span> <span class="p">(</span><span class="kt">Imp</span> <span class="n">p</span> <span class="n">q</span><span class="p">)</span> <span class="ow">=</span> <span class="n">freeIn</span> <span class="n">v</span> <span class="n">p</span> <span class="o">||</span> <span class="n">freeIn</span> <span class="n">v</span> <span class="n">q</span>
<span class="nf">freeIn</span> <span class="n">v</span> <span class="p">(</span><span class="kt">Forall</span> <span class="n">v'</span> <span class="n">p</span><span class="p">)</span> <span class="ow">=</span> <span class="n">v</span> <span class="o">/=</span> <span class="n">v'</span> <span class="o">&amp;&amp;</span> <span class="n">freeIn</span> <span class="n">v</span> <span class="n">p</span>

<span class="cm">{-</span>
<span class="cm">subIn p t v = p(t/v) = the result of replacing each free occurrence of</span>
<span class="cm">v in p by an occurrence of t.</span>
<span class="cm">-}</span>
<span class="nf">subIn</span> <span class="ow">::</span> <span class="kt">Formula</span> <span class="ow">-&gt;</span> <span class="kt">Term</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Formula</span>
<span class="nf">subIn</span> <span class="p">(</span><span class="kt">Pred</span> <span class="n">name</span> <span class="n">terms</span><span class="p">)</span> <span class="n">t</span> <span class="n">v</span> <span class="ow">=</span> <span class="kt">Pred</span> <span class="n">name</span> <span class="p">(</span><span class="n">map</span> <span class="p">(</span><span class="nf">\</span><span class="n">t'</span> <span class="ow">-&gt;</span> <span class="n">subInTerm</span> <span class="n">t'</span> <span class="n">t</span> <span class="n">v</span><span class="p">)</span> <span class="n">terms</span><span class="p">)</span> <span class="kr">where</span>
  <span class="cm">{-</span>
<span class="cm">  subInTerm t' t v = t'(t/v) = the result of replacing each occurrence of</span>
<span class="cm">  v in t' by an occurrence of t.</span>
<span class="cm">  -}</span>
  <span class="n">subInTerm</span> <span class="ow">::</span> <span class="kt">Term</span> <span class="ow">-&gt;</span> <span class="kt">Term</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Term</span>
  <span class="n">subInTerm</span> <span class="p">(</span><span class="kt">Var</span> <span class="n">v'</span><span class="p">)</span> <span class="n">t</span> <span class="n">v</span> <span class="ow">=</span> <span class="kr">if</span> <span class="n">v</span> <span class="o">==</span> <span class="n">v'</span> <span class="kr">then</span> <span class="n">t</span> <span class="kr">else</span> <span class="kt">Var</span> <span class="n">v'</span>
  <span class="n">subInTerm</span> <span class="p">(</span><span class="kt">Func</span> <span class="n">name</span> <span class="n">terms</span><span class="p">)</span> <span class="n">t</span> <span class="n">v</span> <span class="ow">=</span> <span class="kt">Func</span> <span class="n">name</span> <span class="p">(</span><span class="n">map</span> <span class="p">(</span><span class="nf">\</span><span class="n">t'</span> <span class="ow">-&gt;</span> <span class="n">subInTerm</span> <span class="n">t'</span> <span class="n">t</span> <span class="n">v</span><span class="p">)</span> <span class="n">terms</span><span class="p">)</span>
<span class="nf">subIn</span> <span class="p">(</span><span class="kt">Not</span> <span class="n">p</span><span class="p">)</span> <span class="n">t</span> <span class="n">v</span> <span class="ow">=</span> <span class="kt">Not</span> <span class="p">(</span><span class="n">subIn</span> <span class="n">p</span> <span class="n">t</span> <span class="n">v</span><span class="p">)</span>
<span class="nf">subIn</span> <span class="p">(</span><span class="kt">Imp</span> <span class="n">p</span> <span class="n">q</span><span class="p">)</span> <span class="n">t</span> <span class="n">v</span> <span class="ow">=</span> <span class="kt">Imp</span> <span class="p">(</span><span class="n">subIn</span> <span class="n">p</span> <span class="n">t</span> <span class="n">v</span><span class="p">)</span> <span class="p">(</span><span class="n">subIn</span> <span class="n">q</span> <span class="n">t</span> <span class="n">v</span><span class="p">)</span>
<span class="nf">subIn</span> <span class="p">(</span><span class="kt">Forall</span> <span class="n">v'</span> <span class="n">p</span><span class="p">)</span> <span class="n">t</span> <span class="n">v</span> <span class="ow">=</span> <span class="kr">if</span> <span class="n">v</span> <span class="o">==</span> <span class="n">v'</span> <span class="kr">then</span> <span class="kt">Forall</span> <span class="n">v'</span> <span class="n">p</span> <span class="kr">else</span> <span class="kt">Forall</span> <span class="n">v'</span> <span class="p">(</span><span class="n">subIn</span> <span class="n">p</span> <span class="n">t</span> <span class="n">v</span><span class="p">)</span>

<span class="cm">{-</span>
<span class="cm">admitsVar p u v = p admits u for v = there is no free occurrence of</span>
<span class="cm">v in p that becomes a bound occurrence of u in p(u/v).</span>
<span class="cm">-}</span>
<span class="nf">admitsVar</span> <span class="ow">::</span> <span class="kt">Formula</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">admitsVar</span> <span class="n">p</span> <span class="n">u</span> <span class="n">v</span> <span class="ow">=</span> <span class="n">go</span> <span class="n">p</span> <span class="n">u</span> <span class="n">v</span> <span class="kt">[]</span> <span class="kr">where</span>
  <span class="n">go</span> <span class="ow">::</span> <span class="kt">Formula</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
  <span class="n">go</span> <span class="p">(</span><span class="kt">Pred</span> <span class="kr">_</span> <span class="n">terms</span><span class="p">)</span> <span class="n">u</span> <span class="n">v</span> <span class="n">binders</span> <span class="ow">=</span> <span class="n">not</span> <span class="p">(</span><span class="n">any</span> <span class="p">(</span><span class="n">occursIn</span> <span class="n">v</span><span class="p">)</span> <span class="n">terms</span><span class="p">)</span>
                               <span class="o">||</span> <span class="n">elem</span> <span class="n">v</span> <span class="n">binders</span>
                               <span class="o">||</span> <span class="n">notElem</span> <span class="n">u</span> <span class="n">binders</span>
  <span class="n">go</span> <span class="p">(</span><span class="kt">Not</span> <span class="n">p</span><span class="p">)</span> <span class="n">u</span> <span class="n">v</span> <span class="n">binders</span> <span class="ow">=</span> <span class="n">go</span> <span class="n">p</span> <span class="n">u</span> <span class="n">v</span> <span class="n">binders</span>
  <span class="n">go</span> <span class="p">(</span><span class="kt">Imp</span> <span class="n">p</span> <span class="n">q</span><span class="p">)</span> <span class="n">u</span> <span class="n">v</span> <span class="n">binders</span> <span class="ow">=</span> <span class="n">go</span> <span class="n">p</span> <span class="n">u</span> <span class="n">v</span> <span class="n">binders</span> <span class="o">&amp;&amp;</span> <span class="n">go</span> <span class="n">q</span> <span class="n">u</span> <span class="n">v</span> <span class="n">binders</span>
  <span class="n">go</span> <span class="p">(</span><span class="kt">Forall</span> <span class="n">v'</span> <span class="n">p</span><span class="p">)</span> <span class="n">u</span> <span class="n">v</span> <span class="n">binders</span> <span class="ow">=</span> <span class="n">go</span> <span class="n">p</span> <span class="n">u</span> <span class="n">v</span> <span class="p">(</span><span class="n">v'</span> <span class="kt">:</span> <span class="n">binders</span><span class="p">)</span>

<span class="cm">{-</span>
<span class="cm">admitsTerm p t v = p admits for v every variable in t.</span>
<span class="cm">-}</span>
<span class="nf">admitsTerm</span> <span class="ow">::</span> <span class="kt">Formula</span> <span class="ow">-&gt;</span> <span class="kt">Term</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">admitsTerm</span> <span class="n">p</span> <span class="p">(</span><span class="kt">Var</span> <span class="n">u</span><span class="p">)</span> <span class="n">v</span> <span class="ow">=</span> <span class="n">admitsVar</span> <span class="n">p</span> <span class="n">u</span> <span class="n">v</span>
<span class="nf">admitsTerm</span> <span class="n">p</span> <span class="p">(</span><span class="kt">Func</span> <span class="kr">_</span> <span class="n">terms</span><span class="p">)</span> <span class="n">v</span> <span class="ow">=</span> <span class="n">all</span> <span class="p">(</span><span class="nf">\</span><span class="n">t</span> <span class="ow">-&gt;</span> <span class="n">admitsTerm</span> <span class="n">p</span> <span class="n">t</span> <span class="n">v</span><span class="p">)</span> <span class="n">terms</span>


<span class="c1">-- Assumption</span>

<span class="nf">assume</span> <span class="ow">::</span> <span class="kt">Context</span> <span class="ow">-&gt;</span> <span class="kt">Formula</span> <span class="ow">-&gt;</span> <span class="kt">Theorem</span>
<span class="nf">assume</span> <span class="n">gamma</span> <span class="n">p</span> <span class="ow">=</span> <span class="kr">if</span> <span class="n">elem</span> <span class="n">p</span> <span class="n">gamma</span> <span class="kr">then</span> <span class="kt">Theorem</span> <span class="n">gamma</span> <span class="n">p</span> <span class="kr">else</span> <span class="ne">error</span> <span class="s">"assume"</span>


<span class="c1">-- Propositional calculus</span>

<span class="c1">-- |- (p -&gt; (q -&gt; p))</span>
<span class="nf">prop_1</span> <span class="ow">::</span> <span class="kt">Context</span> <span class="ow">-&gt;</span> <span class="kt">Formula</span> <span class="ow">-&gt;</span> <span class="kt">Formula</span> <span class="ow">-&gt;</span> <span class="kt">Theorem</span>
<span class="nf">prop_1</span> <span class="n">gamma</span> <span class="n">p</span> <span class="n">q</span> <span class="ow">=</span> <span class="kt">Theorem</span> <span class="n">gamma</span> <span class="p">(</span><span class="n">p</span> <span class="p">`</span><span class="kt">Imp</span><span class="p">`</span> <span class="p">(</span><span class="n">q</span> <span class="p">`</span><span class="kt">Imp</span><span class="p">`</span> <span class="n">p</span><span class="p">))</span>

<span class="c1">-- |- ((p -&gt; (q -&gt; r)) -&gt; ((p -&gt; q) -&gt; (p -&gt; r)))</span>
<span class="nf">prop_2</span> <span class="ow">::</span> <span class="kt">Context</span> <span class="ow">-&gt;</span> <span class="kt">Formula</span> <span class="ow">-&gt;</span> <span class="kt">Formula</span> <span class="ow">-&gt;</span> <span class="kt">Formula</span> <span class="ow">-&gt;</span> <span class="kt">Theorem</span>
<span class="nf">prop_2</span> <span class="n">gamma</span> <span class="n">p</span> <span class="n">q</span> <span class="n">r</span> <span class="ow">=</span> <span class="kt">Theorem</span> <span class="n">gamma</span> <span class="p">((</span><span class="n">p</span> <span class="p">`</span><span class="kt">Imp</span><span class="p">`</span> <span class="p">(</span><span class="n">q</span> <span class="p">`</span><span class="kt">Imp</span><span class="p">`</span> <span class="n">r</span><span class="p">))</span> <span class="p">`</span><span class="kt">Imp</span><span class="p">`</span> <span class="p">((</span><span class="n">p</span> <span class="p">`</span><span class="kt">Imp</span><span class="p">`</span> <span class="n">q</span><span class="p">)</span> <span class="p">`</span><span class="kt">Imp</span><span class="p">`</span> <span class="p">(</span><span class="n">p</span> <span class="p">`</span><span class="kt">Imp</span><span class="p">`</span> <span class="n">r</span><span class="p">)))</span>

<span class="c1">-- |- ((~p -&gt; ~q) -&gt; (q -&gt; p))</span>
<span class="nf">prop_3</span> <span class="ow">::</span> <span class="kt">Context</span> <span class="ow">-&gt;</span> <span class="kt">Formula</span> <span class="ow">-&gt;</span> <span class="kt">Formula</span> <span class="ow">-&gt;</span> <span class="kt">Theorem</span>
<span class="nf">prop_3</span> <span class="n">gamma</span> <span class="n">p</span> <span class="n">q</span> <span class="ow">=</span> <span class="kt">Theorem</span> <span class="n">gamma</span> <span class="p">(((</span><span class="kt">Not</span> <span class="n">p</span><span class="p">)</span> <span class="p">`</span><span class="kt">Imp</span><span class="p">`</span> <span class="p">(</span><span class="kt">Not</span> <span class="n">q</span><span class="p">))</span> <span class="p">`</span><span class="kt">Imp</span><span class="p">`</span> <span class="p">(</span><span class="n">q</span> <span class="p">`</span><span class="kt">Imp</span><span class="p">`</span> <span class="n">p</span><span class="p">))</span>

<span class="c1">-- |- p &amp; |- (p -&gt; q) =&gt; |- q</span>
<span class="nf">mp</span> <span class="ow">::</span> <span class="kt">Theorem</span> <span class="ow">-&gt;</span> <span class="kt">Theorem</span> <span class="ow">-&gt;</span> <span class="kt">Theorem</span>
<span class="nf">mp</span> <span class="p">(</span><span class="kt">Theorem</span> <span class="n">gamma</span> <span class="n">p</span><span class="p">)</span> <span class="p">(</span><span class="kt">Theorem</span> <span class="n">gamma'</span> <span class="p">(</span><span class="n">p'</span> <span class="p">`</span><span class="kt">Imp</span><span class="p">`</span> <span class="n">q</span><span class="p">))</span>
       <span class="ow">=</span> <span class="kr">if</span> <span class="n">gamma</span> <span class="o">==</span> <span class="n">gamma'</span> <span class="o">&amp;&amp;</span> <span class="n">p</span> <span class="o">==</span> <span class="n">p'</span> <span class="kr">then</span> <span class="kt">Theorem</span> <span class="n">gamma</span> <span class="n">q</span> <span class="kr">else</span> <span class="ne">error</span> <span class="s">"mp"</span>
<span class="nf">mp</span> <span class="kr">_</span> <span class="kr">_</span> <span class="ow">=</span> <span class="ne">error</span> <span class="s">"mp"</span>


<span class="c1">-- Predicate calculus</span>

<span class="c1">-- |- p =&gt; |- forall v. p</span>
<span class="nf">gen</span> <span class="ow">::</span> <span class="kt">Theorem</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Theorem</span>
<span class="nf">gen</span> <span class="p">(</span><span class="kt">Theorem</span> <span class="n">gamma</span> <span class="n">p</span><span class="p">)</span> <span class="n">v</span> <span class="ow">=</span> <span class="kt">Theorem</span> <span class="n">gamma</span> <span class="p">(</span><span class="kt">Forall</span> <span class="n">v</span> <span class="n">p</span><span class="p">)</span>

<span class="c1">-- |- ((forall v. (p -&gt; q)) -&gt; (forall v. p) -&gt; (forall v. q))</span>
<span class="nf">pred_1</span> <span class="ow">::</span> <span class="kt">Context</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Formula</span> <span class="ow">-&gt;</span> <span class="kt">Formula</span> <span class="ow">-&gt;</span> <span class="kt">Theorem</span>
<span class="nf">pred_1</span> <span class="n">gamma</span> <span class="n">v</span> <span class="n">p</span> <span class="n">q</span> <span class="ow">=</span> <span class="kt">Theorem</span> <span class="n">gamma</span> <span class="p">((</span><span class="kt">Forall</span> <span class="n">v</span> <span class="p">(</span><span class="n">p</span> <span class="p">`</span><span class="kt">Imp</span><span class="p">`</span> <span class="n">q</span><span class="p">))</span> <span class="p">`</span><span class="kt">Imp</span><span class="p">`</span> <span class="p">((</span><span class="kt">Forall</span> <span class="n">v</span> <span class="n">p</span><span class="p">)</span> <span class="p">`</span><span class="kt">Imp</span><span class="p">`</span> <span class="p">(</span><span class="kt">Forall</span> <span class="n">v</span> <span class="n">q</span><span class="p">)))</span>

<span class="c1">-- |- (forall v. p -&gt; p [t/v]) provided p admits t for v</span>
<span class="nf">pred_2</span> <span class="ow">::</span> <span class="kt">Context</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Formula</span> <span class="ow">-&gt;</span> <span class="kt">Term</span> <span class="ow">-&gt;</span> <span class="kt">Theorem</span>
<span class="nf">pred_2</span> <span class="n">gamma</span> <span class="n">v</span> <span class="n">p</span> <span class="n">t</span> <span class="ow">=</span> <span class="kr">if</span> <span class="n">admitsTerm</span> <span class="n">p</span> <span class="n">t</span> <span class="n">v</span> <span class="kr">then</span> <span class="kt">Theorem</span> <span class="n">gamma</span> <span class="p">((</span><span class="kt">Forall</span> <span class="n">v</span> <span class="n">p</span><span class="p">)</span> <span class="p">`</span><span class="kt">Imp</span><span class="p">`</span> <span class="p">(</span><span class="n">subIn</span> <span class="n">p</span> <span class="n">t</span> <span class="n">v</span><span class="p">))</span> <span class="kr">else</span> <span class="ne">error</span> <span class="s">"pred_2"</span>

<span class="c1">-- |- (p -&gt; forall v. p) provided v is not free in p</span>
<span class="nf">pred_3</span> <span class="ow">::</span> <span class="kt">Context</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Formula</span> <span class="ow">-&gt;</span> <span class="kt">Theorem</span>
<span class="nf">pred_3</span> <span class="n">gamma</span> <span class="n">v</span> <span class="n">p</span> <span class="ow">=</span> <span class="kr">if</span> <span class="n">not</span> <span class="p">(</span><span class="n">freeIn</span> <span class="n">v</span> <span class="n">p</span><span class="p">)</span> <span class="kr">then</span> <span class="kt">Theorem</span> <span class="n">gamma</span> <span class="p">(</span><span class="n">p</span> <span class="p">`</span><span class="kt">Imp</span><span class="p">`</span> <span class="p">(</span><span class="kt">Forall</span> <span class="n">v</span> <span class="n">p</span><span class="p">))</span> <span class="kr">else</span> <span class="ne">error</span> <span class="s">"pred_3"</span>


<span class="c1">-- Equality</span>

<span class="c1">-- |- t = t</span>
<span class="nf">eq_1</span> <span class="ow">::</span> <span class="kt">Context</span> <span class="ow">-&gt;</span> <span class="kt">Term</span> <span class="ow">-&gt;</span> <span class="kt">Theorem</span>
<span class="nf">eq_1</span> <span class="n">gamma</span> <span class="n">t</span> <span class="ow">=</span> <span class="kt">Theorem</span> <span class="n">gamma</span> <span class="p">(</span><span class="kt">Pred</span> <span class="s">"Eq"</span> <span class="p">[</span><span class="n">t</span><span class="p">,</span> <span class="n">t</span><span class="p">])</span>

<span class="c1">-- |- s1 = t1 ==&gt; ... ==&gt; sn = tn ==&gt; f(s1,..,sn) = f(t1,..,tn)</span>
<span class="nf">eq_2</span> <span class="ow">::</span> <span class="kt">Context</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Term</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Term</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Theorem</span>
<span class="nf">eq_2</span> <span class="n">gamma</span> <span class="n">f</span> <span class="n">ss</span> <span class="n">ts</span> <span class="ow">=</span> <span class="kr">if</span> <span class="n">length</span> <span class="n">ss</span> <span class="o">==</span> <span class="n">length</span> <span class="n">ts</span> <span class="kr">then</span>
                     <span class="c1">-- eqs = [s1 = t1, ..., sn = tn]</span>
                     <span class="kr">let</span> <span class="n">eqs</span> <span class="ow">=</span> <span class="n">zipWith</span> <span class="p">(</span><span class="nf">\</span><span class="n">s</span> <span class="n">t</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Pred</span> <span class="s">"Eq"</span> <span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">]))</span> <span class="n">ss</span> <span class="n">ts</span> <span class="kr">in</span>
                     <span class="c1">-- z = f(s1,..,sn) = f(t1,..,tn)</span>
                     <span class="kr">let</span> <span class="n">z</span> <span class="ow">=</span> <span class="kt">Pred</span> <span class="s">"Eq"</span> <span class="p">[(</span><span class="kt">Func</span> <span class="n">f</span> <span class="n">ss</span><span class="p">),</span> <span class="p">(</span><span class="kt">Func</span> <span class="n">f</span> <span class="n">ts</span><span class="p">)]</span> <span class="kr">in</span>
                     <span class="kt">Theorem</span> <span class="n">gamma</span> <span class="p">(</span><span class="n">foldr</span> <span class="kt">Imp</span> <span class="n">z</span> <span class="n">eqs</span><span class="p">)</span>
                     <span class="kr">else</span> <span class="ne">error</span> <span class="s">"eq_2"</span>

<span class="c1">-- |- s1 = t1 ==&gt; ... ==&gt; sn = tn ==&gt; P(s1,..,sn) ==&gt; P(t1,..,tn)</span>
<span class="nf">eq_3</span> <span class="ow">::</span> <span class="kt">Context</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Term</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Term</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Theorem</span>
<span class="nf">eq_3</span> <span class="n">gamma</span> <span class="n">p</span> <span class="n">ss</span> <span class="n">ts</span> <span class="ow">=</span> <span class="kr">if</span> <span class="n">length</span> <span class="n">ss</span> <span class="o">==</span> <span class="n">length</span> <span class="n">ts</span> <span class="kr">then</span>
                     <span class="c1">-- eqs = [s1 = t1, ..., sn = tn]</span>
                     <span class="kr">let</span> <span class="n">eqs</span> <span class="ow">=</span> <span class="n">zipWith</span> <span class="p">(</span><span class="nf">\</span><span class="n">s</span> <span class="n">t</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Pred</span> <span class="s">"Eq"</span> <span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">]))</span> <span class="n">ss</span> <span class="n">ts</span> <span class="kr">in</span>
                     <span class="c1">-- z = P(s1,..,sn) ==&gt; P(t1,..,tn)</span>
                     <span class="kr">let</span> <span class="n">z</span> <span class="ow">=</span> <span class="p">(</span><span class="kt">Pred</span> <span class="n">p</span> <span class="n">ss</span><span class="p">)</span> <span class="p">`</span><span class="kt">Imp</span><span class="p">`</span> <span class="p">(</span><span class="kt">Pred</span> <span class="n">p</span> <span class="n">ts</span><span class="p">)</span> <span class="kr">in</span>
                     <span class="kt">Theorem</span> <span class="n">gamma</span> <span class="p">(</span><span class="n">foldr</span> <span class="kt">Imp</span> <span class="n">z</span> <span class="n">eqs</span><span class="p">)</span>
                     <span class="kr">else</span> <span class="ne">error</span> <span class="s">"eq_3"</span>
</code></pre></div>



<a name="268331278"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268331278" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268331278">(Jan 18 2022 at 01:14)</a>:</h4>
<p>Do formulas in the context need to be closed, that is have no free variables? Or do the predicate rules have to add a check that a variable is not free in the context?</p>



<a name="268332594"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268332594" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268332594">(Jan 18 2022 at 01:35)</a>:</h4>
<p>For example, I could have:<br>
x = 5 |- x = 5 from assume<br>
x = 5 | forall x. x = 5 from gen<br>
which I don't thing makes sense.</p>



<a name="268333033"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268333033" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268333033">(Jan 18 2022 at 01:42)</a>:</h4>
<p>Sorry, I got pulled away. Here's a variation on that definition schema that may fit better with your formulation:</p>
<div class="codehilite" data-code-language="Haskell"><pre><span></span><code><span class="kr">data</span> <span class="kt">FuncDef</span> <span class="ow">=</span> <span class="kt">FuncDef</span> <span class="p">{</span>
  <span class="n">name</span> <span class="ow">::</span> <span class="kt">String</span><span class="p">,</span>
  <span class="n">arity</span> <span class="ow">::</span> <span class="kt">Integer</span><span class="p">,</span>
  <span class="n">defn</span> <span class="ow">::</span> <span class="kt">Maybe</span> <span class="p">([</span><span class="kt">String</span><span class="p">],</span> <span class="kt">Term</span><span class="p">)</span> <span class="p">}</span>

<span class="kr">data</span> <span class="kt">PredDef</span> <span class="ow">=</span> <span class="kt">PredDef</span> <span class="p">{</span>
  <span class="n">name</span> <span class="ow">::</span> <span class="kt">String</span><span class="p">,</span>
  <span class="n">arity</span> <span class="ow">::</span> <span class="kt">Integer</span><span class="p">,</span>
  <span class="n">defn</span> <span class="ow">::</span> <span class="kt">Maybe</span> <span class="p">([</span><span class="kt">String</span><span class="p">],</span> <span class="kt">Formula</span><span class="p">)</span> <span class="p">}</span>
</code></pre></div>
<ul>
<li>A global context is a <code>(Map String FuncDef, Map String PredDef)</code> tracking definitions of functions and predicates.</li>
<li>For a <code>Term</code> or <code>Formula</code> to be well formed, it must only use functions/predicates in the context and the arity must match.</li>
<li>You can extend the context with a function if:<ul>
<li>The function has not already been defined</li>
<li>The arity is nonnegative</li>
<li>The definition is either<ul>
<li>not provided (it is an axiomatic term constructor), or</li>
<li>the <code>[String]</code> is a list of length <code>arity</code>, and the <code>Term</code> contains no free variables not in the list</li>
</ul>
</li>
</ul>
</li>
<li>(similarly for predicates)</li>
</ul>



<a name="268333268"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268333268" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268333268">(Jan 18 2022 at 01:47)</a>:</h4>
<p>For your last question, you normally wouldn't have a context in the hilbert-style axiomatization you are using. If you want to have one anyway, I would say that the formulas in the context should all be closed, and/or they are treated as universally quantified over everything. In such a situation, <code>x = 5 |- forall x. x = 5</code> is a reasonable derivation</p>



<a name="268333522"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268333522" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268333522">(Jan 18 2022 at 01:50)</a>:</h4>
<p>You certainly don't have to apologize, I really appreciate any of your time.<br>
That is what I had initially assumed, and then I was reminded of the deduction theorem, which while a meta theorem, seems to talk about a Hilbert system with a context?</p>



<a name="268334377"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268334377" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268334377">(Jan 18 2022 at 02:02)</a>:</h4>
<p>So then there is a rule to somehow allow a definition from this global context to be unfolded in a term or formula?</p>



<a name="268334632"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268334632" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268334632">(Jan 18 2022 at 02:07)</a>:</h4>
<p>What do <code>[String]</code> and <code>Term</code> and <code>Formula</code> represent, get used for, in the <code>Maybe</code>s?</p>



<a name="268335503"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268335503" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268335503">(Jan 18 2022 at 02:22)</a>:</h4>
<p>The list of variables occurring in the <code>Term</code> and in the <code>Formula</code>?</p>



<a name="268335774"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268335774" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268335774">(Jan 18 2022 at 02:27)</a>:</h4>
<p>So <code>name</code> is the name of the function/predicate, <code>arity</code> is the number of variables in the function/predicate, <code>[String]</code> in <code>def</code> is the list of variables in the function/predicate, and <code>Term</code>/<code>Formula</code> in <code>def</code> is the actual <code>Function</code> or <code>Formula</code> we are giving a name to? What is the difference in the <code>name</code> in <code>FuncDef</code> and <code>PredDef</code>  and the <code>String</code> in the global context?</p>



<a name="268338126"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268338126" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268338126">(Jan 18 2022 at 03:10)</a>:</h4>
<blockquote>
<p>What is the difference in the name in FuncDef and PredDef and the String in the global context?</p>
</blockquote>
<p>They are the same. You can probably do without <code>name</code> if you like, but it is nice to have it stored explicitly sometimes</p>



<a name="268338226"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268338226" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268338226">(Jan 18 2022 at 03:13)</a>:</h4>
<p>For example, we could define <code>ne</code> as <code>PredDef "ne" 2 (Just (["x", "y"], Not (Pred "eq" [Var "x", Var "y"])))</code></p>



<a name="268338302"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268338302" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268338302">(Jan 18 2022 at 03:15)</a>:</h4>
<p>I see. Why is it a <code>Maybe</code>?</p>



<a name="268338312"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268338312" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268338312">(Jan 18 2022 at 03:15)</a>:</h4>
<p>We would define <code>eq</code> as <code>PredDef "Eq" 2 Nothing</code></p>



<a name="268338384"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268338384" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268338384">(Jan 18 2022 at 03:16)</a>:</h4>
<p>You have to actually check that terms are well formed now, because you don't want definitions to reference themselves or future definitions</p>



<a name="268338394"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268338394" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268338394">(Jan 18 2022 at 03:16)</a>:</h4>
<p>so even axiomatic term constructors like <code>Eq</code> need to have declarations</p>



<a name="268338506"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268338506" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268338506">(Jan 18 2022 at 03:19)</a>:</h4>
<p>I see. So what happens to the definitions of <code>Term</code> and <code>Formula</code>? Do they change?</p>



<a name="268338582"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268338582" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268338582">(Jan 18 2022 at 03:21)</a>:</h4>
<p>I'm guessing not?</p>



<a name="268338764"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268338764" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268338764">(Jan 18 2022 at 03:24)</a>:</h4>
<p>How do these get used, and how does it avoid this:<br>
"<br>
An aside: If you do that in Haskell and use the mechanisms of Haskell to create definitions, then during typechecking the definitions definitely will blow up exponentially. So you need something to prevent it from happening...<br>
"</p>



<a name="268338909"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268338909" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268338909">(Jan 18 2022 at 03:27)</a>:</h4>
<p>The blowup problem is avoided because if you have a definition of something complicated like <code>Pred "IsPerfectoidSpace" [X]</code> then it is represented as just that, not the thing it unfolds to</p>



<a name="268338962"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268338962" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268338962">(Jan 18 2022 at 03:28)</a>:</h4>
<p>things are only unfolded when you need it, via a new primitive unfolding rule</p>



<a name="268338998"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268338998" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268338998">(Jan 18 2022 at 03:29)</a>:</h4>
<p>Oh. I see. If you don't mind, what would that rule look like in my formulation?</p>



<a name="268339078"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268339078" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268339078">(Jan 18 2022 at 03:30)</a>:</h4>
<p>The unfolding rule says <code>P(t1, ... tn) = p[t1/x1, ..., tn/xn]</code> assuming the <code>ti</code> are free for <code>xi</code> in <code>p</code> and <code>P(x1, ..., xn) := p</code></p>



<a name="268339098"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268339098" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268339098">(Jan 18 2022 at 03:31)</a>:</h4>
<p>although if you have substitution rules you can probably get away with just the equality <code>P(x1, ..., xn) = p</code></p>



<a name="268339295"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268339295" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268339295">(Jan 18 2022 at 03:35)</a>:</h4>
<p>The <code>:=</code> means the string <code>p</code> maps to the predicate/function <code>P</code> in the global context?</p>



<a name="268339586"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268339586" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268339586">(Jan 18 2022 at 03:40)</a>:</h4>
<p>Do <code>Formula</code> and <code>Term</code> get extended somehow?</p>



<a name="268339685"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268339685" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268339685">(Jan 18 2022 at 03:42)</a>:</h4>
<p>The other way around; <code>P(x1, ..., xn) := p</code> means <code>lookup (snd globalCtx) P = PredDef P n (Just ([x1, ..., xn], p))</code></p>



<a name="268339703"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268339703" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268339703">(Jan 18 2022 at 03:43)</a>:</h4>
<p><code>Formula</code> and <code>Term</code> are not extended, because we are reusing the <code>Func</code> and <code>Pred</code> constructors already in the grammar to represent definitions</p>



<a name="268339894"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268339894" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268339894">(Jan 18 2022 at 03:46)</a>:</h4>
<p>I'm sorry, would you mind giving an example of how <code>ne</code> is used inside a formula?</p>



<a name="268339928"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268339928" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268339928">(Jan 18 2022 at 03:46)</a>:</h4>
<p>That is, how would you construct a <code>Formula</code> that uses <code>ne</code>?</p>



<a name="268340034"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268340034" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268340034">(Jan 18 2022 at 03:48)</a>:</h4>
<p><code>Pred "ne" [Var "u", Var "v"]</code>?</p>



<a name="268340612"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268340612" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268340612">(Jan 18 2022 at 03:58)</a>:</h4>
<p>Then to unfold it you look up "ne" in the map of predicates, check that its arity is equal to <code>length [Var "u", Var "v"]</code>, check that <code>x</code> admits <code>u</code> and <code>y</code> admits <code>v</code> in <code>Not (Pred "Eq" [Var "x", Var "y"])</code>, then produce <code>Theorem (Pred "Eq" [Pred "ne" [Var "u", Var "v"]], Not (Pred "Eq" [Var "u", Var "v"])])</code>?</p>



<a name="268341099"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268341099" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268341099">(Jan 18 2022 at 04:05)</a>:</h4>
<p>Yes, that's how you construct it. To unfold it, you would use a rule <code>unfold : String -&gt; [Term] -&gt; Theorem</code> such that <code>unfold "ne" [Var "u", Var "v"] = Theorem (Iff (Pred "ne" [Var "u", Var "v"]) (Not (Pred "Eq" [Var "u", Var "v"])))</code></p>



<a name="268341234"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268341234" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268341234">(Jan 18 2022 at 04:07)</a>:</h4>
<p>With the conditions on the matching arity and admits?</p>



<a name="268341331"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268341331" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268341331">(Jan 18 2022 at 04:08)</a>:</h4>
<p>The arity conditions exist on everything - to construct a <code>Term</code> in the first place you have to have the right arity</p>



<a name="268341349"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268341349" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268341349">(Jan 18 2022 at 04:09)</a>:</h4>
<p>one way to do this is to add a "smart constructor" for <code>Pred</code></p>



<a name="268341358"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268341358" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268341358">(Jan 18 2022 at 04:09)</a>:</h4>
<p>not sure what you mean by admits</p>



<a name="268341413"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268341413" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268341413">(Jan 18 2022 at 04:10)</a>:</h4>
<p>I think <code>free for</code> in your terminology.</p>



<a name="268341432"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268341432" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268341432">(Jan 18 2022 at 04:10)</a>:</h4>
<p>ah yes, you need that for the version that does a substitution</p>



<a name="268341447"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268341447" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268341447">(Jan 18 2022 at 04:11)</a>:</h4>
<p>the simpler version can just have the type <code>unfold : String -&gt; Theorem</code> and just uses the list of variables intrinsic to the predicate definition</p>



<a name="268341818"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268341818" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268341818">(Jan 18 2022 at 04:20)</a>:</h4>
<p>So in the simpler version you would just have <code>Theorem (Iff (Pred "ne" [Var "x", Var "y"]) (Not (Pred "Eq" [Var "x", Var "y"])))</code>? How would that then get used to replace the <code>Pred "ne" [Var "u", Var "v"]</code></p>



<a name="268341847"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268341847" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268341847">(Jan 18 2022 at 04:21)</a>:</h4>
<p>Use the equality axioms?</p>



<a name="268341921"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268341921" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268341921">(Jan 18 2022 at 04:22)</a>:</h4>
<p>Then could you just as easily replace <code>Term</code> and <code>Formula</code> by <code>Theorem</code> in the global definition context?</p>



<a name="268341993"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268341993" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268341993">(Jan 18 2022 at 04:24)</a>:</h4>
<p>I guess, how does this differ from just adding definitions as axioms?</p>



<a name="268342073"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268342073" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268342073">(Jan 18 2022 at 04:26)</a>:</h4>
<p>I guess then because they would always be expanded, and then you would get the exponential blowup.</p>



<a name="268342091"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268342091" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268342091">(Jan 18 2022 at 04:27)</a>:</h4>
<p>But I guess you could still replace <code>Term</code> and <code>Formula</code> in the mapped to definition by the resulting <code>Theorem</code>?</p>



<a name="268342188"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268342188" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268342188">(Jan 18 2022 at 04:29)</a>:</h4>
<p>Or does having it done by the rule somehow ensure that the logic remains consistent?</p>



<a name="268343188"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268343188" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268343188">(Jan 18 2022 at 04:50)</a>:</h4>
<p><span class="user-mention silent" data-user-id="139442">Patrick Thomas</span> <a href="#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/268341921">said</a>:</p>
<blockquote>
<p>Then could you just as easily replace <code>Term</code> and <code>Formula</code> by <code>Theorem</code> in the global definition context?</p>
</blockquote>
<p>Sure, you could store it as a <code>Theorem</code> if you want.<br>
<span class="user-mention silent" data-user-id="139442">Patrick Thomas</span> <a href="#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/268341993">said</a>:</p>
<blockquote>
<p>I guess, how does this differ from just adding definitions as axioms?</p>
</blockquote>
<p>Because it's not just any axiom, it has a particular form, namely an equality between the new definition (fully applied to distinct variables) and some expression with no additional free variables. This is checked in the <code>addTermDef : Context -&gt; String -&gt; [String] -&gt; Term -&gt; Context</code> function</p>



<a name="268343611"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268343611" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268343611">(Jan 18 2022 at 04:58)</a>:</h4>
<p>I think I might see. I'll try to add it to my current code sometime in the next week or so and play around with it. Sorry to barrage you with questions, I'm not sure where else to ask. Thank you for your patience!</p>



<a name="268346124"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268346124" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Huỳnh Trần Khanh <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268346124">(Jan 18 2022 at 05:47)</a>:</h4>
<p>thank you for starting this thread too, I've had this question for quite a long time and this thread has been very insightful</p>



<a name="268940638"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268940638" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268940638">(Jan 22 2022 at 06:20)</a>:</h4>
<p>I added support for definitions using the algorithm from Mario. How does this look? Did I follow the algorithm correctly? <a href="/user_uploads/3121/Q89tPxr4vYHjLF7DBCUpHFUh/Hilbert_NV_Def.hs">Hilbert_NV_Def.hs</a></p>



<a name="268942292"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268942292" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268942292">(Jan 22 2022 at 07:00)</a>:</h4>
<p>Is that the right way to unfold the definition of a predicate?</p>



<a name="268968202"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268968202" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268968202">(Jan 22 2022 at 17:29)</a>:</h4>
<p>If I moved this to locally nameless variables would it be a practical kernel for a proof assistant?</p>



<a name="268972570"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268972570" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268972570">(Jan 22 2022 at 19:06)</a>:</h4>
<p>One danger of this approach for an LCF style kernel (i.e. everything in this module is made private except for the API and the user is allowed to call any API functions and should not be able to prove false) is that <code>Term</code> and <code>Theorem</code> have to be valid in a given <code>Context</code> but nothing enforces this. That means that I can prove <code>foo &lt;-&gt; True</code> in a context defining <code>foo = True</code>, and <code>foo &lt;-&gt; False</code> in a different context with <code>foo = False</code>, and then use <code>mp</code> and friends on both <code>Theorem</code>s (since <code>mp</code> doesn't take a <code>Context</code>) to prove <code>True &lt;-&gt; False</code> and hence <code>False</code></p>



<a name="268972897"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268972897" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268972897">(Jan 22 2022 at 19:14)</a>:</h4>
<p>Isabelle handles this by having a global context manager that can be queried to see whether two contexts (which are now IDs into the context manager state) are compatible (i.e. one is obtained by extension from another), and each <code>Term</code> and <code>Theorem</code> is tupled with the context in which it was constructed; any primitive rule which takes more than one <code>Term</code>/<code>Formula</code>/<code>Theorem</code> takes the union of the contexts involved and they must all be compatible.</p>
<p>Metamath handles this by making the context itself global state. <code>Term</code> and <code>Theorem</code> don't carry any context information but should be valid in the current context. There is no context branching in this model, but it makes validity checking a lot easier.</p>



<a name="268973069"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268973069" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268973069">(Jan 22 2022 at 19:19)</a>:</h4>
<p>In Haskell you could probably also use some kind of phantom type/GADT/singleton encoding (really what you want is a phantom dependent type)</p>



<a name="268973225"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268973225" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268973225">(Jan 22 2022 at 19:23)</a>:</h4>
<p>I'm not sure what a phantom dependent type is.</p>



<a name="268973247"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268973247" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Trebor Huang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268973247">(Jan 22 2022 at 19:23)</a>:</h4>
<p>You can look it up on the Haskell wiki, the concept is quite simple.</p>



<a name="268973308"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268973308" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268973308">(Jan 22 2022 at 19:25)</a>:</h4>
<p>Would the metamath approach here be to make <code>Theorem</code> a <code>(Context, Formula)</code> pair and have <code>mp</code> check that the contexts are the same?</p>



<a name="268973694"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268973694" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268973694">(Jan 22 2022 at 19:35)</a>:</h4>
<p>Are you saying we would make the type of <code>Theorem</code> be dependent on <code>Context</code>?</p>



<a name="268973767"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268973767" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268973767">(Jan 22 2022 at 19:37)</a>:</h4>
<p>There are currently no dependent types in Haskell, right?</p>



<a name="268973912"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268973912" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268973912">(Jan 22 2022 at 19:40)</a>:</h4>
<p>What do you mean by a <code>Term</code> being valid in a given <code>Context</code>? I can see <code>Theorem</code> but I'm not sure I understand <code>Term</code>.</p>



<a name="268974150"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268974150" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Trebor Huang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268974150">(Jan 22 2022 at 19:46)</a>:</h4>
<blockquote>
<p>Are you saying we would make the type of <code>Theorem</code> be dependent on <code>Context</code>?</p>
</blockquote>
<p>No.</p>
<blockquote>
<p>There are currently no dependent types in Haskell, right?</p>
</blockquote>
<p>No.</p>



<a name="268974167"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268974167" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Trebor Huang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268974167">(Jan 22 2022 at 19:47)</a>:</h4>
<p>Uh, probably should be "it depends (no pun intended) on how dependent you want it to be"</p>



<a name="268975234"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268975234" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268975234">(Jan 22 2022 at 20:07)</a>:</h4>
<p><span class="user-mention silent" data-user-id="139442">Patrick Thomas</span> <a href="#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/268973308">said</a>:</p>
<blockquote>
<p>Would the metamath approach here be to make <code>Theorem</code> a <code>(Context, Formula)</code> pair and have <code>mp</code> check that the contexts are the same?</p>
</blockquote>
<p>Is this right?</p>



<a name="268975324"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268975324" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268975324">(Jan 22 2022 at 20:09)</a>:</h4>
<p>As I did here, but without the assumption rule? <a href="#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/268331019">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/268331019</a></p>



<a name="268979750"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268979750" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268979750">(Jan 22 2022 at 21:32)</a>:</h4>
<p>I guess the basic question is, what is the simplest way to fix this?</p>



<a name="268982623"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268982623" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268982623">(Jan 22 2022 at 22:36)</a>:</h4>
<p>Does metamath zero use checks on free for and substitution for definitions?</p>



<a name="268990172"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268990172" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268990172">(Jan 23 2022 at 01:41)</a>:</h4>
<p>Updated code, but not sure how to fix definitions, and if the substitution can be removed with definitions.<br>
<a href="/user_uploads/3121/utnEIuEliZzO8xgRUiHyTm9n/Frege.hs">Frege.hs</a></p>



<a name="268991872"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268991872" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268991872">(Jan 23 2022 at 02:24)</a>:</h4>
<p>Is the addition of definitions to this what is known as an extended Frege system?</p>



<a name="268993062"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268993062" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268993062">(Jan 23 2022 at 02:58)</a>:</h4>
<p><span class="user-mention silent" data-user-id="139442">Patrick Thomas</span> <a href="#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/268973308">said</a>:</p>
<blockquote>
<p>Would the metamath approach here be to make <code>Theorem</code> a <code>(Context, Formula)</code> pair and have <code>mp</code> check that the contexts are the same?</p>
</blockquote>
<p>No, in the metamath approach the <code>Theorem</code> is not tupled with a context but instead the context is available in a global data structure, and only grows monotonically (so <code>Theorem</code>s can be created in past versions of the context but not "alternate history" versions). In Haskell the global state part is problematic, but something like <code>ST</code> should be sufficient to localize all the types to a given session, within which the context is stored in a <code>STRef</code></p>



<a name="268993337"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268993337" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268993337">(Jan 23 2022 at 03:05)</a>:</h4>
<p><span class="user-mention silent" data-user-id="139442">Patrick Thomas</span> <a href="#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/268982623">said</a>:</p>
<blockquote>
<p>Does metamath zero use checks on free for and substitution for definitions?</p>
</blockquote>
<p>Not sure exactly what you mean. There are constraints on what you can unfold, for example you don't want a bound variable in the definition to capture a free variable in one of the parameters.</p>



<a name="268993686"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268993686" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268993686">(Jan 23 2022 at 03:14)</a>:</h4>
<p>I mean, I thought the axiom system of metamath was chosen in part to avoid the complexities of substitution, but it seems like they are reintroduced in adding definitions, for example, as you said, in the unfolding.</p>



<a name="268993753"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268993753" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268993753">(Jan 23 2022 at 03:16)</a>:</h4>
<p>I think what I meant in the previous comment was, could you simulate the global data structure by passing it in and out of each axiom scheme function.</p>



<a name="268993827"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268993827" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268993827">(Jan 23 2022 at 03:18)</a>:</h4>
<p>As an aside, is what I am trying to do here a waste of time :( I mean, if it could have been done, it would have?</p>



<a name="268993839"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268993839" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268993839">(Jan 23 2022 at 03:19)</a>:</h4>
<p>Or there are good reasons not to that I am unaware of yet?</p>



<a name="268998560"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268998560" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268998560">(Jan 23 2022 at 05:24)</a>:</h4>
<p>(deleted)</p>



<a name="268999589"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/268999589" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#268999589">(Jan 23 2022 at 05:54)</a>:</h4>
<p>(deleted)</p>



<a name="269007500"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269007500" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Trebor Huang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269007500">(Jan 23 2022 at 09:18)</a>:</h4>
<blockquote>
<p>As an aside, is what I am trying to do here a waste of time :( I mean, if it could have been done, it would have?</p>
</blockquote>
<p>The exact combination of things you're doing probably hasn't. But each part of it has, so it's a great try-out-what-happens project, and uncovers some pitfalls / benefits along this path, I think.</p>



<a name="269007513"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269007513" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Trebor Huang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269007513">(Jan 23 2022 at 09:19)</a>:</h4>
<p>(deleted)</p>



<a name="269023200"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269023200" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269023200">(Jan 23 2022 at 15:19)</a>:</h4>
<p><span class="user-mention silent" data-user-id="139442">Patrick Thomas</span> <a href="#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/268993686">said</a>:</p>
<blockquote>
<p>I mean, I thought the axiom system of metamath was chosen in part to avoid the complexities of substitution, but it seems like they are reintroduced in adding definitions, for example, as you said, in the unfolding.</p>
</blockquote>
<p>Metamath has substitution as a built in primitive: it's basically <em>the</em> rule that everything is built from. Where it differs from other systems is that metamath substitution is always direct but sometimes disallowed, whereas substitution in e.g. HOL is always allowed but sometimes requires bound variable renaming.</p>
<p>It is true, however, that adding definitions to metamath entails some additional knowledge about what it means to be a bound variable that is not present in traditional metamath. This is a fact I discovered when designing MM0. Metamath is able to sidestep the problem because it does not attempt to check conservativity of definitions - every definition is an axiom and you have to be careful not to accidentally introduce a free variable. The first version of these rules came about in the definition checker that is now part of <a href="http://set.mm">set.mm</a> CI, but when we turned it on we did actually discover a few typo'd definitions that could be used to prove a contradiction, so I've come to believe that it's an important part of the verifier even though it is not officially part of the metamath spec.</p>



<a name="269023503"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269023503" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269023503">(Jan 23 2022 at 15:24)</a>:</h4>
<p><span class="user-mention silent" data-user-id="139442">Patrick Thomas</span> <a href="#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/268993753">said</a>:</p>
<blockquote>
<p>I think what I meant in the previous comment was, could you simulate the global data structure by passing it in and out of each axiom scheme function.</p>
</blockquote>
<p>Yes, if you used a state monad you can simulate global state, but a public state monad is not good enough, because you can still snapshot an earlier state and roll back, meaning that you can capture some theorems made in an alternate timeline and use them to mess things up in a different one. <code>ST</code> avoids this problem because it actually uses mutable state, not just a simulation - there is no way to snapshot an old version of the state and roll back - and also types are guarded by the type variable denoting the arena for the state, which can be used to "brand" all the types like <code>Term</code> and <code>Formula</code> so that you can't start two separate sessions and share theorems created in one session with the other.</p>



<a name="269024118"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269024118" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269024118">(Jan 23 2022 at 15:37)</a>:</h4>
<p><span class="user-mention silent" data-user-id="139442">Patrick Thomas</span> <a href="#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/268993827">said</a>:</p>
<blockquote>
<p>As an aside, is what I am trying to do here a waste of time :( I mean, if it could have been done, it would have?</p>
</blockquote>
<p>It's certainly not a waste of time if you are learning. If you want to actually turn this into a product there are a bunch of other things to attend to, but you should know what your goals are and who your audience is. For example, I've been talking about protecting against API violations in the LCF style, but you should consider what your "threat model" is. Metamath is not designed as an LCF style system, which is to say that if you are working in the same codebase as the verifier then you can arbitrarily muck things up. Same thing for lean - you can "easily" bypass the kernel with some C++ code. These systems instead ensure security by parsing their own language, which is more limited / sandboxed in the things you can do.</p>
<p>But if you wanted to parse your own language, then clearly there is a bunch of missing stuff, like a parser and a grammar for that language, how you want to specify proofs, definitions, and so on. In the end, the "kernel" for such a prover might not be as well isolated as yours, because that can sometimes come with a performance penalty. Naturally if the kernel gets too big then people will start to question why it should be trustworthy, so you have to attend to that too. You have to somehow write the code such that it is easy to convince others that it is correct, and there are a variety of strategies for doing this.</p>
<p>Ultimately, the kernel is one of the smaller parts of making a useful verification system. It's probably the most logically interesting part, but there is a whole lot more beyond it.</p>



<a name="269028195"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269028195" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269028195">(Jan 23 2022 at 17:10)</a>:</h4>
<p>Thank you! I think I've got some studying to do on <code>ST</code>.</p>



<a name="269035865"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269035865" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269035865">(Jan 23 2022 at 19:52)</a>:</h4>
<p>I'm having trouble finding examples of this use case. I found examples where everything is done inside of <code>runST</code>, but not where <code>runST</code> calls other functions that take and return a <code>STRef</code> (if I am right and that is what I need to do?). Is the general idea that the type of <code>Term</code>, <code>Formula</code>, and <code>Theorem</code>become dependent on a "thread id", and the axiom,rule functions take the "thread id" as a parameter and require that the <code>Term</code>, <code>Formula</code> and <code>Theorem</code>s passed to them have that same "thread id"?</p>



<a name="269036140"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269036140" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269036140">(Jan 23 2022 at 19:56)</a>:</h4>
<p>And the <code>STRef</code> presumably created in the <code>runST</code> function somehow becomes contained to the "thread id" associated with that call of <code>runST</code>?</p>



<a name="269036680"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269036680" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269036680">(Jan 23 2022 at 20:07)</a>:</h4>
<p>If that is the general idea, how do you add the "thread id" (the variable <code>s</code>) to the datatypes and functions to do this? Is it with the <code>forall</code> somehow?</p>



<a name="269036910"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269036910" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269036910">(Jan 23 2022 at 20:12)</a>:</h4>
<p>Yes, that's right</p>



<a name="269036912"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269036912" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269036912">(Jan 23 2022 at 20:12)</a>:</h4>
<p>I think you can just declare <code>Term</code> as having a type parameter <code>s</code></p>



<a name="269036921"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269036921" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269036921">(Jan 23 2022 at 20:13)</a>:</h4>
<p>even though it doesn't really use it in any interesting way</p>



<a name="269037019"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269037019" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269037019">(Jan 23 2022 at 20:15)</a>:</h4>
<p>There is one call to <code>runST</code> around the entire scope of the program. This represents one "proving session", within which you can add but not remove definitions. The only way to remove definitions is to exit the <code>runST</code> scope and start anew. You can also have two (unrelated) sessions going on in parallel, and the thread id <code>s</code> is being used to keep the two sessions separate</p>



<a name="269037080"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269037080" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269037080">(Jan 23 2022 at 20:16)</a>:</h4>
<p>You don't take and return an <code>STRef</code>, there is only one <code>STRef s (Context s)</code> in use which is passed to any functions that need to read or modify the context</p>



<a name="269037172"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269037172" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269037172">(Jan 23 2022 at 20:18)</a>:</h4>
<p>IIRC the syntax for type variables in <code>data</code> is just <code>data Term s = Var String | Func String [Term s]</code>, you don't need <code>forall</code></p>



<a name="269037337"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269037337" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269037337">(Jan 23 2022 at 20:22)</a>:</h4>
<p>I think I see. How do the functions, for example the ones that don't need to read or modify the context (all but the add definition and unfold definition functions) get associated with <code>s</code> and check that the terms, formulas, theorems passed to them match the same <code>s</code>? Is <code>s</code> passed to them from <code>runST</code>?</p>



<a name="269037349"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269037349" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269037349">(Jan 23 2022 at 20:23)</a>:</h4>
<p>That happens automatically from the type signature</p>



<a name="269037398"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269037398" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269037398">(Jan 23 2022 at 20:24)</a>:</h4>
<p>For example <code>mp</code> will have the type <code>mp :: Theorem s -&gt; Theorem s -&gt; Theorem s</code> which means that you can't use different <code>s</code> for the two inputs</p>



<a name="269037415"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269037415" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269037415">(Jan 23 2022 at 20:24)</a>:</h4>
<p>note that we're talking about <em>different type variables</em> here, not different inhabitants of one type <code>s</code></p>



<a name="269037421"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269037421" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269037421">(Jan 23 2022 at 20:24)</a>:</h4>
<p><code>s</code> itself is only a marker type, it has no content</p>



<a name="269037459"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269037459" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269037459">(Jan 23 2022 at 20:25)</a>:</h4>
<p>but if you have two theorems from two sessions they will have types <code>Theorem s</code> and <code>Theorem  t</code> respectively where <code>s</code> and <code>t</code> are distinct type variables, so <code>mp</code> will not typecheck</p>



<a name="269037617"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269037617" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269037617">(Jan 23 2022 at 20:29)</a>:</h4>
<p>So, for example, how do you create an instance of <code>Term s</code> or <code>Formula s</code> in <code>runST</code>?</p>



<a name="269037753"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269037753" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269037753">(Jan 23 2022 at 20:32)</a>:</h4>
<p>You don't need an <code>s</code> to pass to the data constructor of <code>Term s</code> or <code>Formula s</code>?</p>



<a name="269037790"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269037790" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269037790">(Jan 23 2022 at 20:33)</a>:</h4>
<p>Or do you just leave the <code>s</code> out of the constructor definitions, expect for those that take a <code>Formula</code> or <code>Term</code>?</p>



<a name="269037863"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269037863" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269037863">(Jan 23 2022 at 20:35)</a>:</h4>
<p>Sorry, I guess I should have seen that in your example.</p>



<a name="269037910"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269037910" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269037910">(Jan 23 2022 at 20:36)</a>:</h4>
<p>Thank you!!</p>



<a name="269038325"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269038325" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269038325">(Jan 23 2022 at 20:46)</a>:</h4>
<p>The constructors <code>Var</code> and <code>Func</code> of <code>Term s</code> are private; using them you can construct whatever you like but the external API needs to use <code>mkFunc</code> instead, which will check that you only use functions in the context</p>



<a name="269044825"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269044825" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269044825">(Jan 23 2022 at 23:10)</a>:</h4>
<p>I'm a little uncertain how to implement the <code>mkFunc</code>. Here I want to read from a passed <code>STRef</code> but return a <code>Term s</code>. I can read from the <code>STRef</code> in a do block, but how do I then return a <code>Term s</code>? As a minimal example that expresses the same concept of what I think I need to do (maybe not?):</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">Control.Monad.ST</span>
<span class="kn">import</span> <span class="n">Data.STRef</span>


<span class="n">data</span> <span class="n">Term</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">Var</span> <span class="n">String</span>
            <span class="bp">|</span> <span class="n">Func</span> <span class="n">String</span> <span class="o">[</span><span class="n">Term</span> <span class="n">s</span><span class="o">]</span>
              <span class="n">deriving</span> <span class="o">(</span><span class="n">Show</span><span class="o">,</span> <span class="n">Eq</span><span class="o">)</span>


<span class="n">type</span> <span class="n">Context</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">Int</span>

<span class="n">f</span> <span class="o">::</span> <span class="n">STRef</span> <span class="n">s</span> <span class="o">(</span><span class="n">Context</span> <span class="n">s</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="n">Term</span> <span class="n">s</span>
<span class="n">f</span> <span class="n">ref</span> <span class="bp">=</span> <span class="k">do</span>
  <span class="n">x</span> <span class="bp">&lt;-</span> <span class="n">readSTRef</span> <span class="n">ref</span>
  <span class="c1">-- how to return Var "P"?</span>
</code></pre></div>



<a name="269045013"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269045013" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269045013">(Jan 23 2022 at 23:14)</a>:</h4>
<div class="codehilite" data-code-language="Haskell"><pre><span></span><code><span class="nf">f</span> <span class="ow">::</span> <span class="kt">STRef</span> <span class="n">s</span> <span class="p">(</span><span class="kt">Context</span> <span class="n">s</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">ST</span> <span class="n">s</span> <span class="p">(</span><span class="kt">Term</span> <span class="n">s</span><span class="p">)</span>
</code></pre></div>



<a name="269045075"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269045075" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269045075">(Jan 23 2022 at 23:16)</a>:</h4>
<p>Alternatively, <code>f</code> can have the type <code>Context s -&gt; Term s</code> and push the responsibility to read the context to the caller</p>



<a name="269045078"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269045078" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269045078">(Jan 23 2022 at 23:16)</a>:</h4>
<p>Ahh. Thank you!</p>



<a name="269045182"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269045182" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269045182">(Jan 23 2022 at 23:19)</a>:</h4>
<p>It's okay to let the user have access to objects of type <code>Context s</code>, because they can at worst hold on to old contexts (which are ancestors of the current one, so are still valid to use to construct terms). The only place where you have to be careful is the context extension function must use the latest context, not an old one, so it has to have a type like <code>STRef s (Context s) -&gt; FuncDef -&gt; ST s ()</code></p>



<a name="269045261"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269045261" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269045261">(Jan 23 2022 at 23:21)</a>:</h4>
<p>in fact, you could also make a monad <code>ThmM s a = ReaderT (STRef s (Context s)) (ST s) a</code> and make the constructor private, so the user doesn't have to handle the <code>STRef</code> directly</p>



<a name="269045419"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269045419" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269045419">(Jan 23 2022 at 23:24)</a>:</h4>
<p>Hmm. I'm going to have to do some more reading. Thank you!</p>



<a name="269048474"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269048474" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Zhanrong Qiao <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269048474">(Jan 24 2022 at 00:35)</a>:</h4>
<p>Hello, recently I was also trying to make a "toy" theorem prover based on FOL + ZFC, also using Haskell (and maybe C++ in the future)... Just found this thread really helpful! I have a question though: are there some recommended ways to implement "in/definite descriptions"? I'm deciding between making them into inference rules (i.e. add defining axioms to context if conditions are met) and introducing some kind of "iota &amp; epsilon operators" instead...</p>



<a name="269048522"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269048522" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Zhanrong Qiao <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269048522">(Jan 24 2022 at 00:36)</a>:</h4>
<p>(In case anyone is interested: I used locally nameless, contexts and natural deduction from the very beginning (which makes <a href="https://github.com/bridgekat/apimu/blob/main/lcfstyle/FOLPlus.hs">my verifier code</a> (also <a href="https://github.com/bridgekat/apimu/blob/main/lcfstyle/FOLPlusTest.hs">this part</a>) much longer and probably slower than Patrick's, but also seems to have avoided some problems you were discussing here), and I'm now (coincidentally) trying to implement definitions. I tried to think about the design in the previous months, and came up with some (still premature) ideas including "local definitions" that "interact with scope changes" like in <a href="https://github.com/bridgekat/apimu/blob/main/notes/design.md#natural-deduction-rules">this informal proof.</a> The point is, in principle they can be lifted to the outermost scope, and the rules described <a href="https://en.m.wikipedia.org/wiki/Extension_by_definitions">here</a> will become applicable (although still need to be modified to include the case of "partial" functions/predicates, i.e. definitions inside <code>assume</code> sections)...)</p>



<a name="269049577"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269049577" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269049577">(Jan 24 2022 at 01:00)</a>:</h4>
<p>Does <code>def f</code> open a new scope? As in you can later close the scope and any theorems about <code>f</code> become generalized <code>forall f</code> instead of being about a specific definition</p>



<a name="269050587"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269050587" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Zhanrong Qiao <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269050587">(Jan 24 2022 at 01:21)</a>:</h4>
<p>(deleted)</p>



<a name="269050688"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269050688" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Zhanrong Qiao <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269050688">(Jan 24 2022 at 01:24)</a>:</h4>
<p>No, as I wanted to make the definition of <code>f</code> generalizable (it can escape from <code>any</code> scopes); <code>forall f</code> (I use <code>forallfunc f/n</code> to indicate the type of <code>f</code>) is introduced using <code>anyfunc f/n</code> instead</p>



<a name="269051892"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269051892" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269051892">(Jan 24 2022 at 01:50)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/269045182">said</a>:</p>
<blockquote>
<p>It's okay to let the user have access to objects of type <code>Context s</code>, because they can at worst hold on to old contexts (which are ancestors of the current one, so are still valid to use to construct terms). The only place where you have to be careful is the context extension function must use the latest context, not an old one, so it has to have a type like <code>STRef s (Context s) -&gt; FuncDef -&gt; ST s ()</code></p>
</blockquote>
<p>Should <code>FuncDef</code> take an <code>s</code>? As in <code>STRef s (Context s) -&gt; FuncDef s -&gt; ST s ()</code>?</p>



<a name="269051910"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269051910" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269051910">(Jan 24 2022 at 01:51)</a>:</h4>
<p>Since it has a <code>Term s</code> in the definition?</p>



<a name="269051914"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269051914" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269051914">(Jan 24 2022 at 01:51)</a>:</h4>
<p>yes</p>



<a name="269051922"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269051922" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269051922">(Jan 24 2022 at 01:51)</a>:</h4>
<p>Ok. Thank you.</p>



<a name="269052173"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269052173" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269052173">(Jan 24 2022 at 01:57)</a>:</h4>
<p><span class="user-mention" data-user-id="450398">@Zhanrong Qiao</span> Regarding your question about indefinite description, wouldn't an iota/epsilon operator take you out of the FOL fragment? I see you have some 1.5 order variables going on so I might be wrong about this</p>



<a name="269052526"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269052526" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269052526">(Jan 24 2022 at 02:03)</a>:</h4>
<p>I think it would not be so bad to have a skolem operation in your language: something like <code>any x { idef f :: p(x, f) }</code> will introduce <code>f(x)</code> such that <code>p(x, f(x))</code>. That doesn't leave the first order world, and it doesn't have the drawbacks of long lived existential assumptions you get with a simple axiom of the form <code>forall x. exists y. p(x,y) -&gt; exists f. forall x. p(x, f(x))</code> (not to mention the second order issue here as well)</p>



<a name="269055748"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269055748" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269055748">(Jan 24 2022 at 03:12)</a>:</h4>
<p>I can't pull a <code>Theorem s</code> out of <code>runST</code> right? If I want to do something with it, like show it, do I need to do that in <code>runST</code>?</p>



<a name="269056045"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269056045" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269056045">(Jan 24 2022 at 03:18)</a>:</h4>
<p>yes</p>



<a name="269056170"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269056170" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269056170">(Jan 24 2022 at 03:21)</a>:</h4>
<p>I see. So the whole proof assistant basically runs inside of <code>runST.</code> Is that going to be an issue, do you think?</p>



<a name="269056228"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269056228" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269056228">(Jan 24 2022 at 03:22)</a>:</h4>
<p>It's probably kind of annoying in ghci, but it shouldn't be a problem for regular haskell programming</p>



<a name="269056252"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269056252" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269056252">(Jan 24 2022 at 03:23)</a>:</h4>
<p>Ok. Thank you!</p>



<a name="269056955"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269056955" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269056955">(Jan 24 2022 at 03:40)</a>:</h4>
<p>I can't do <code>IO</code> from inside <code>ST</code> though right? Do I have a function internal to <code>runST</code> that converts <code>Theorem s</code> to a <code>String</code> and somehow return the result of that out of <code>runST</code>?</p>



<a name="269057196"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269057196" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269057196">(Jan 24 2022 at 03:46)</a>:</h4>
<p>Yay!</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">ex_1</span> <span class="n">p</span> <span class="bp">=</span> <span class="n">runST</span> <span class="bp">$</span> <span class="k">do</span>
  <span class="n">ref</span> <span class="bp">&lt;-</span> <span class="n">newSTRef</span> <span class="o">(</span><span class="n">Data.Map.empty</span><span class="o">,</span> <span class="n">Data.Map.empty</span><span class="o">)</span>
  <span class="n">addPredDefST</span> <span class="n">ref</span> <span class="o">(</span><span class="n">PredDef</span> <span class="n">p</span> <span class="mi">0</span> <span class="n">Nothing</span><span class="o">)</span>
  <span class="n">c</span> <span class="bp">&lt;-</span> <span class="n">readSTRef</span> <span class="n">ref</span>
  <span class="k">let</span> <span class="n">p'</span> <span class="bp">=</span> <span class="n">mkPred</span> <span class="n">c</span> <span class="n">p</span> <span class="o">[]</span>
  <span class="k">let</span> <span class="n">s1</span> <span class="bp">=</span> <span class="n">prop_2</span> <span class="n">p'</span> <span class="o">(</span><span class="n">p'</span> <span class="bp">`</span><span class="n">Imp</span><span class="bp">`</span> <span class="n">p'</span><span class="o">)</span> <span class="n">p'</span>
  <span class="k">let</span> <span class="n">s2</span> <span class="bp">=</span> <span class="n">prop_1</span> <span class="n">p'</span> <span class="o">(</span><span class="n">p'</span> <span class="bp">`</span><span class="n">Imp</span><span class="bp">`</span> <span class="n">p'</span><span class="o">)</span>
  <span class="k">let</span> <span class="n">s3</span> <span class="bp">=</span> <span class="n">mp</span> <span class="n">s2</span> <span class="n">s1</span>
  <span class="k">let</span> <span class="n">s4</span> <span class="bp">=</span> <span class="n">prop_1</span> <span class="n">p'</span> <span class="n">p'</span>
  <span class="k">let</span> <span class="n">concl</span> <span class="bp">=</span> <span class="n">mp</span> <span class="n">s4</span> <span class="n">s3</span>
  <span class="n">return</span> <span class="o">(</span><span class="k">show</span> <span class="n">concl</span><span class="o">)</span>

<span class="n">main</span> <span class="o">::</span> <span class="n">IO</span> <span class="o">()</span>
<span class="n">main</span> <span class="bp">=</span> <span class="n">putStrLn</span> <span class="o">(</span><span class="n">ex_1</span> <span class="s2">"P"</span><span class="o">)</span>
</code></pre></div>



<a name="269057203"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269057203" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269057203">(Jan 24 2022 at 03:47)</a>:</h4>
<p><code>Theorem (Imp (Pred "P" []) (Pred "P" []))</code></p>



<a name="269057268"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269057268" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269057268">(Jan 24 2022 at 03:48)</a>:</h4>
<p><a href="/user_uploads/3121/DF0Sq3yTKwlIYl0icvstO7wP/Frege_ST.hs">Frege_ST.hs</a></p>



<a name="269057282"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269057282" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269057282">(Jan 24 2022 at 03:49)</a>:</h4>
<p>Very cool! (If I did it right) :)</p>



<a name="269057473"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269057473" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269057473">(Jan 24 2022 at 03:54)</a>:</h4>
<p>Thank you!!</p>



<a name="269058270"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269058270" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269058270">(Jan 24 2022 at 04:11)</a>:</h4>
<p>So, um, I'm almost afraid to ask :), but is that right? Am I forgetting anything obvious that would make it unsound or incomplete or be an issue later?</p>



<a name="269061574"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269061574" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269061574">(Jan 24 2022 at 05:26)</a>:</h4>
<p>You should put it in a module and expose only the things that are supposed to be public, and ensure that the API is usable enough to prove theorems but not so permissive as to prove false</p>



<a name="269061609"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269061609" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269061609">(Jan 24 2022 at 05:27)</a>:</h4>
<p>That is, right now it is trivially unsound if we think of <code>ex_1</code> as the user code because you can just write <code>Theorem Bottom</code></p>



<a name="269062197"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269062197" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269062197">(Jan 24 2022 at 05:40)</a>:</h4>
<p>That was going to be my next step, that is putting it into a module and hiding what should be internal. I'm not sure how to go about the latter, that is ensure that the API is usable enough to prove theorems but not so permissive as to prove false, without trying to formally prove it, which is probably beyond what I am up for at this point, and may be impossible due to Godel?</p>



<a name="269062320"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269062320" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269062320">(Jan 24 2022 at 05:43)</a>:</h4>
<p>It's certainly very difficult to check that a kernel can't prove false with anything approaching absolute certainty. Even real world theorem provers have to deal with that every once in a while</p>



<a name="269062363"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269062363" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269062363">(Jan 24 2022 at 05:44)</a>:</h4>
<p>I'm soon going to run out of obvious flaws to poke at, so there's that</p>



<a name="269062372"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269062372" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269062372">(Jan 24 2022 at 05:44)</a>:</h4>
<p>:)</p>



<a name="269062404"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269062404" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269062404">(Jan 24 2022 at 05:45)</a>:</h4>
<p>Godel's theorem only comes up if you want to prove the soundness of your kernel using the kernel itself (or something axiomatically weaker than it). You could model this kernel in lean without too much trouble</p>



<a name="269062486"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269062486" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269062486">(Jan 24 2022 at 05:47)</a>:</h4>
<p>Soon? Does that mean you have more in mind :)<br>
How hard would the proofs be once it was in lean? I can't imagine the <code>ST</code>  monad would be easy?</p>



<a name="269062559"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269062559" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269062559">(Jan 24 2022 at 05:48)</a>:</h4>
<p>true, you would have to model haskell in order to get all that right, and once you did you would probably notice that the theorem is false because of e.g. <code>unsafeCoerce</code></p>



<a name="269062648"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269062648" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269062648">(Jan 24 2022 at 05:50)</a>:</h4>
<p>So it is unsound?</p>



<a name="269062663"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269062663" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269062663">(Jan 24 2022 at 05:50)</a>:</h4>
<p>All was for naught?</p>



<a name="269062671"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269062671" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269062671">(Jan 24 2022 at 05:51)</a>:</h4>
<p>It's why I'm generally dubious of the LCF style - every real world programming language is unsound for stupid reasons</p>



<a name="269062692"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269062692" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269062692">(Jan 24 2022 at 05:51)</a>:</h4>
<p>But if you want to prove it sound anyway you can just blithely ignore these issues and assume sensible use of the API</p>



<a name="269062754"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269062754" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269062754">(Jan 24 2022 at 05:52)</a>:</h4>
<p>I'm not sure what the alternative to LCF is? Isn't Lean and Coq LCF?</p>



<a name="269062829"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269062829" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269062829">(Jan 24 2022 at 05:54)</a>:</h4>
<p>No, I mean LCF style in the sense of the HOL / ML-based systems: you have an abstract data type <code>Theorem</code> which may not even carry a proof object, and you use a privacy barrier to ensure that bad <code>Theorem</code> objects are not constructible</p>



<a name="269062836"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269062836" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269062836">(Jan 24 2022 at 05:54)</a>:</h4>
<p>the "small trusted kernel" becomes everything behind the privacy barrier</p>



<a name="269062849"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269062849" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269062849">(Jan 24 2022 at 05:54)</a>:</h4>
<p>Lean and Coq are not LCF style in this sense</p>



<a name="269062855"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269062855" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Trebor Huang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269062855">(Jan 24 2022 at 05:55)</a>:</h4>
<p>Lean and Coq explicitly stores the proof objects, so you get things like <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>m</mi><mi>p</mi><mi>S</mi><mo stretchy="false">(</mo><mi>K</mi><mi>S</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(mp S (K S))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mord mathnormal" style="margin-right:0.05764em;">pS</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mclose">))</span></span></span></span></p>



<a name="269062924"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269062924" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269062924">(Jan 24 2022 at 05:56)</a>:</h4>
<p>I'm sorry, I'm not sure what that means.</p>



<a name="269062941"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269062941" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269062941">(Jan 24 2022 at 05:57)</a>:</h4>
<p>That is, stores the proof objects.</p>



<a name="269062956"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269062956" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269062956">(Jan 24 2022 at 05:57)</a>:</h4>
<p>the LCF style implies that the user will be writing code in the implementation language, hence you have a fundamental tension: it should be a real world language so that the implementation works, but real world languages don't have airtight privacy guarantees because that's not what they were intended for</p>



<a name="269063035"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269063035" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Trebor Huang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269063035">(Jan 24 2022 at 05:59)</a>:</h4>
<p>In Lean, the proof of <code>A -&gt; B -&gt; A /\ B</code> can be printed out (try it!) to something like <code>λ x y, &lt;x, y&gt;</code> (sorry, unicode only partly works on my device).</p>



<a name="269063153"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269063153" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Trebor Huang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269063153">(Jan 24 2022 at 06:00)</a>:</h4>
<p>But in your program (which is approximately LCF-style), you can't print "the proof". Such a thing doesn't even exist. You only have a <code>Theorem</code> which contains only the information of the theorem statement.</p>



<a name="269063304"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269063304" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269063304">(Jan 24 2022 at 06:04)</a>:</h4>
<p>Is the difference that in my program the proof is that a <code>Theorem</code> can be constructed, and in Lean the proof is that a given theorem passes a verifier test?</p>



<a name="269063470"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269063470" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269063470">(Jan 24 2022 at 06:06)</a>:</h4>
<p>it's a lot easier to control the grammar of your verifier language than it is to control what can be constructed, especially if you allow the user to be actively malicious and use the implementation language</p>



<a name="269063777"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269063777" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269063777">(Jan 24 2022 at 06:13)</a>:</h4>
<p>Is it possible to do that for what I was attempting? That is a hilbert system for FOL with equality and ZFC in Haskell?</p>



<a name="269063957"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269063957" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269063957">(Jan 24 2022 at 06:16)</a>:</h4>
<p>I'm not sure what it would look like. Would it take a proof as a series of user given justifications for each step, and check that those justifications all hold?</p>



<a name="269064051"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269064051" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269064051">(Jan 24 2022 at 06:18)</a>:</h4>
<p>For example, <code>P -&gt; (P -&gt; P)</code> holds from an instantiation of <code>prop_1</code> with <code>p</code> and <code>p</code>.</p>



<a name="269064068"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269064068" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269064068">(Jan 24 2022 at 06:19)</a>:</h4>
<p>And the verifier instantiates <code>prop_1</code> with <code>p</code> and <code>p</code> and checks that it matches?</p>



<a name="269065039"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269065039" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269065039">(Jan 24 2022 at 06:39)</a>:</h4>
<p>Or something along the lines of what I was doing for natural deduction earlier?</p>



<a name="269087541"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269087541" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Zhanrong Qiao <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269087541">(Jan 24 2022 at 10:52)</a>:</h4>
<p><span class="user-mention silent" data-user-id="139442">Patrick Thomas</span> <a href="#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/269063957">said</a>:</p>
<blockquote>
<p>I'm not sure what it would look like. Would it take a proof as a series of user given justifications for each step, and check that those justifications all hold?</p>
</blockquote>
<p>Yes, I think what Mario was saying is that you could make a data structure that stores proof steps, then your program could just take a data structure in some format and check if it's a valid proof, which does not rely on the type safety of the implementation language (also, proofs can then be constructed using another program written in arbitrary programming language for example). This is optional</p>



<a name="269088008"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269088008" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Zhanrong Qiao <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269088008">(Jan 24 2022 at 10:55)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/269052173">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="450398">Zhanrong Qiao</span> Regarding your question about indefinite description, wouldn't an iota/epsilon operator take you out of the FOL fragment? I see you have some 1.5 order variables going on so I might be wrong about this</p>
</blockquote>
<p>I thought epsilon operators and Skolem functions are the "same thing" (and the difference is just which one is more convenient)... In principle I could replace every occurrence of an epsilon operator by a definition of a Skolem function...?</p>



<a name="269090690"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269090690" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Zhanrong Qiao <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269090690">(Jan 24 2022 at 11:18)</a>:</h4>
<p>But yes I think the <code>def</code>/<code>idef</code> approach makes it easier to interface with first-order automated proving methods (they don't need to create definitions; no replacing are needed)</p>



<a name="269099675"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269099675" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269099675">(Jan 24 2022 at 12:47)</a>:</h4>
<p><span class="user-mention" data-user-id="450398">@Zhanrong Qiao</span> The difference in this case is that the <code>idef</code> is essentially a monomorphized epsilon operator: you stamp out a new definition every time the rule is invoked, rather than having a single higher order thing called "epsilon" to which you provide a lambda to get a choice function for a particular predicate</p>



<a name="269108296"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269108296" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Zhanrong Qiao <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269108296">(Jan 24 2022 at 13:54)</a>:</h4>
<p>Yes, I guess this is similar to thinking the invocations of the Axiom of Separation as instantiations of an axiom schema instead of applications of a second-order axiom... The syntactic rules are similar or the same but there can be different interpretations</p>



<a name="269216628"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269216628" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269216628">(Jan 25 2022 at 07:04)</a>:</h4>
<p><span class="user-mention silent" data-user-id="450398">Zhanrong Qiao</span> <a href="#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/269087541">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="139442">Patrick Thomas</span> <a href="#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/269063957">said</a>:</p>
<blockquote>
<p>I'm not sure what it would look like. Would it take a proof as a series of user given justifications for each step, and check that those justifications all hold?</p>
</blockquote>
<p>Yes, I think what Mario was saying is that you could make a data structure that stores proof steps, then your program could just take a data structure in some format and check if it's a valid proof, which does not rely on the type safety of the implementation language (also, proofs can then be constructed using another program written in arbitrary programming language for example). This is optional</p>
</blockquote>
<p>Like this as a simple example?</p>
<div class="codehilite" data-code-language="Haskell"><pre><span></span><code><span class="cm">{-</span>
<span class="cm">Func "c" [] : A constant named "c"</span>
<span class="cm">Func "f" [v] : A function named "f" of one variable v</span>
<span class="cm">-}</span><span class="w"></span>
<span class="kr">data</span><span class="w"> </span><span class="kt">Term</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Var</span><span class="w"> </span><span class="kt">String</span><span class="w"></span>
<span class="w">          </span><span class="o">|</span><span class="w"> </span><span class="kt">Func</span><span class="w"> </span><span class="kt">String</span><span class="w"> </span><span class="p">[</span><span class="kt">Term</span><span class="p">]</span><span class="w"></span>
<span class="w">            </span><span class="kr">deriving</span><span class="w"> </span><span class="p">(</span><span class="kt">Show</span><span class="p">,</span><span class="w"> </span><span class="kt">Eq</span><span class="p">)</span><span class="w"></span>

<span class="cm">{-</span>
<span class="cm">Pred "P" [] : A propositional variable named "P"</span>
<span class="cm">Pred "Eq" [s, t] : s = t</span>
<span class="cm">-}</span><span class="w"></span>
<span class="kr">data</span><span class="w"> </span><span class="kt">Formula</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Bottom</span><span class="w"> </span><span class="c1">-- False</span><span class="w"></span>
<span class="w">             </span><span class="o">|</span><span class="w"> </span><span class="kt">Top</span><span class="w"> </span><span class="c1">-- True</span><span class="w"></span>
<span class="w">             </span><span class="o">|</span><span class="w"> </span><span class="kt">Pred</span><span class="w"> </span><span class="kt">String</span><span class="w"> </span><span class="p">[</span><span class="kt">Term</span><span class="p">]</span><span class="w"></span>
<span class="w">             </span><span class="o">|</span><span class="w"> </span><span class="kt">Not</span><span class="w"> </span><span class="kt">Formula</span><span class="w"></span>
<span class="w">             </span><span class="o">|</span><span class="w"> </span><span class="kt">And</span><span class="w"> </span><span class="kt">Formula</span><span class="w"> </span><span class="kt">Formula</span><span class="w"></span>
<span class="w">             </span><span class="o">|</span><span class="w"> </span><span class="kt">Or</span><span class="w"> </span><span class="kt">Formula</span><span class="w"> </span><span class="kt">Formula</span><span class="w"></span>
<span class="w">             </span><span class="o">|</span><span class="w"> </span><span class="kt">Imp</span><span class="w"> </span><span class="kt">Formula</span><span class="w"> </span><span class="kt">Formula</span><span class="w"></span>
<span class="w">             </span><span class="o">|</span><span class="w"> </span><span class="kt">Iff</span><span class="w"> </span><span class="kt">Formula</span><span class="w"> </span><span class="kt">Formula</span><span class="w"></span>
<span class="w">             </span><span class="o">|</span><span class="w"> </span><span class="kt">Forall</span><span class="w"> </span><span class="kt">String</span><span class="w"> </span><span class="kt">Formula</span><span class="w"></span>
<span class="w">             </span><span class="o">|</span><span class="w"> </span><span class="kt">Exists</span><span class="w"> </span><span class="kt">String</span><span class="w"> </span><span class="kt">Formula</span><span class="w"></span>
<span class="w">               </span><span class="kr">deriving</span><span class="w"> </span><span class="p">(</span><span class="kt">Show</span><span class="p">,</span><span class="w"> </span><span class="kt">Eq</span><span class="p">)</span><span class="w"></span>


<span class="kr">data</span><span class="w"> </span><span class="kt">Justification</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">MP</span><span class="w"> </span><span class="kt">Step</span><span class="w"> </span><span class="kt">Step</span><span class="w"></span>
<span class="w">                   </span><span class="o">|</span><span class="w"> </span><span class="kt">Prop_1</span><span class="w"> </span><span class="kt">Formula</span><span class="w"> </span><span class="kt">Formula</span><span class="w"></span>
<span class="w">                   </span><span class="o">|</span><span class="w"> </span><span class="kt">Prop_2</span><span class="w"> </span><span class="kt">Formula</span><span class="w"> </span><span class="kt">Formula</span><span class="w"> </span><span class="kt">Formula</span><span class="w"></span>
<span class="w">                   </span><span class="o">|</span><span class="w"> </span><span class="kt">Prop_3</span><span class="w"> </span><span class="kt">Formula</span><span class="w"></span>
<span class="w">                     </span><span class="kr">deriving</span><span class="w"> </span><span class="p">(</span><span class="kt">Show</span><span class="p">,</span><span class="w"> </span><span class="kt">Eq</span><span class="p">)</span><span class="w"></span>

<span class="kr">type</span><span class="w"> </span><span class="kt">Assertion</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Formula</span><span class="w"></span>
<span class="kr">type</span><span class="w"> </span><span class="kt">Step</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="kt">Assertion</span><span class="p">,</span><span class="w"> </span><span class="kt">Justification</span><span class="p">)</span><span class="w"></span>


<span class="nf">checkStep</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Step</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Bool</span><span class="w"></span>

<span class="c1">-- Propositional calculus</span><span class="w"></span>

<span class="c1">-- |- p &amp; |- (p -&gt; q) =&gt; |- q</span><span class="w"></span>
<span class="nf">checkStep</span><span class="w"> </span><span class="p">(</span><span class="n">assertion</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">MP</span><span class="w"> </span><span class="n">step_1</span><span class="o">@</span><span class="p">(</span><span class="n">minor</span><span class="p">,</span><span class="w"> </span><span class="kr">_</span><span class="p">)</span><span class="w"> </span><span class="n">step_2</span><span class="o">@</span><span class="p">(</span><span class="n">major</span><span class="p">,</span><span class="w"> </span><span class="kr">_</span><span class="p">)))</span><span class="w"> </span><span class="ow">=</span><span class="w"></span>
<span class="w">  </span><span class="kr">case</span><span class="w"> </span><span class="n">major</span><span class="w"> </span><span class="kr">of</span><span class="w"></span>
<span class="w">    </span><span class="p">(</span><span class="kt">Imp</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">q</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">minor</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"></span>
<span class="w">                 </span><span class="n">q</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">assertion</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"></span>
<span class="w">                 </span><span class="n">checkStep</span><span class="w"> </span><span class="n">step_1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"></span>
<span class="w">                 </span><span class="n">checkStep</span><span class="w"> </span><span class="n">step_2</span><span class="w"></span>
<span class="w">    </span><span class="kr">_</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="ne">error</span><span class="w"> </span><span class="s">"mp"</span><span class="w"></span>

<span class="c1">-- |- (p -&gt; (q -&gt; p))</span><span class="w"></span>
<span class="nf">checkStep</span><span class="w"> </span><span class="p">(</span><span class="n">assertion</span><span class="p">,</span><span class="w"> </span><span class="kt">Prop_1</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">q</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"></span>
<span class="w">  </span><span class="n">assertion</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="w"> </span><span class="p">`</span><span class="kt">Imp</span><span class="p">`</span><span class="w"> </span><span class="p">(</span><span class="n">q</span><span class="w"> </span><span class="p">`</span><span class="kt">Imp</span><span class="p">`</span><span class="w"> </span><span class="n">p</span><span class="p">))</span><span class="w"></span>

<span class="c1">-- |- ((p -&gt; (q -&gt; r)) -&gt; ((p -&gt; q) -&gt; (p -&gt; r)))</span><span class="w"></span>
<span class="nf">checkStep</span><span class="w"> </span><span class="p">(</span><span class="n">assertion</span><span class="p">,</span><span class="w"> </span><span class="kt">Prop_2</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="n">r</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"></span>
<span class="w">  </span><span class="n">assertion</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">((</span><span class="n">p</span><span class="w"> </span><span class="p">`</span><span class="kt">Imp</span><span class="p">`</span><span class="w"> </span><span class="p">(</span><span class="n">q</span><span class="w"> </span><span class="p">`</span><span class="kt">Imp</span><span class="p">`</span><span class="w"> </span><span class="n">r</span><span class="p">))</span><span class="w"> </span><span class="p">`</span><span class="kt">Imp</span><span class="p">`</span><span class="w"> </span><span class="p">((</span><span class="n">p</span><span class="w"> </span><span class="p">`</span><span class="kt">Imp</span><span class="p">`</span><span class="w"> </span><span class="n">q</span><span class="p">)</span><span class="w"> </span><span class="p">`</span><span class="kt">Imp</span><span class="p">`</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="w"> </span><span class="p">`</span><span class="kt">Imp</span><span class="p">`</span><span class="w"> </span><span class="n">r</span><span class="p">)))</span><span class="w"></span>

<span class="c1">-- |- (((p -&gt; false) -&gt; false) -&gt; p)</span><span class="w"></span>
<span class="nf">checkStep</span><span class="w"> </span><span class="p">(</span><span class="n">assertion</span><span class="p">,</span><span class="w"> </span><span class="kt">Prop_3</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"></span>
<span class="w">  </span><span class="n">assertion</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(((</span><span class="n">p</span><span class="w"> </span><span class="p">`</span><span class="kt">Imp</span><span class="p">`</span><span class="w"> </span><span class="kt">Bottom</span><span class="p">)</span><span class="w"> </span><span class="p">`</span><span class="kt">Imp</span><span class="p">`</span><span class="w"> </span><span class="kt">Bottom</span><span class="p">)</span><span class="w"> </span><span class="p">`</span><span class="kt">Imp</span><span class="p">`</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"></span>


<span class="c1">-- Example</span><span class="w"></span>

<span class="c1">-- |- p -&gt; p</span><span class="w"></span>

<span class="nf">ex_1</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="ow">=</span><span class="w"></span>
<span class="w">  </span><span class="kr">let</span><span class="w"> </span><span class="n">s1</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">((</span><span class="n">p</span><span class="w"> </span><span class="p">`</span><span class="kt">Imp</span><span class="p">`</span><span class="w"> </span><span class="p">((</span><span class="n">p</span><span class="w"> </span><span class="p">`</span><span class="kt">Imp</span><span class="p">`</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="p">`</span><span class="kt">Imp</span><span class="p">`</span><span class="w"> </span><span class="n">p</span><span class="p">))</span><span class="w"> </span><span class="p">`</span><span class="kt">Imp</span><span class="p">`</span><span class="w"> </span><span class="p">((</span><span class="n">p</span><span class="w"> </span><span class="p">`</span><span class="kt">Imp</span><span class="p">`</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="w"> </span><span class="p">`</span><span class="kt">Imp</span><span class="p">`</span><span class="w"> </span><span class="n">p</span><span class="p">))</span><span class="w"> </span><span class="p">`</span><span class="kt">Imp</span><span class="p">`</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="w"> </span><span class="p">`</span><span class="kt">Imp</span><span class="p">`</span><span class="w"> </span><span class="n">p</span><span class="p">)),</span><span class="w"> </span><span class="kt">Prop_2</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="w"> </span><span class="p">`</span><span class="kt">Imp</span><span class="p">`</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="kr">in</span><span class="w"></span>
<span class="w">  </span><span class="kr">let</span><span class="w"> </span><span class="n">s2</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="w"> </span><span class="p">`</span><span class="kt">Imp</span><span class="p">`</span><span class="w"> </span><span class="p">((</span><span class="n">p</span><span class="w"> </span><span class="p">`</span><span class="kt">Imp</span><span class="p">`</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="p">`</span><span class="kt">Imp</span><span class="p">`</span><span class="w"> </span><span class="n">p</span><span class="p">),</span><span class="w"> </span><span class="kt">Prop_1</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="w"> </span><span class="p">`</span><span class="kt">Imp</span><span class="p">`</span><span class="w"> </span><span class="n">p</span><span class="p">))</span><span class="w"> </span><span class="kr">in</span><span class="w"></span>
<span class="w">  </span><span class="kr">let</span><span class="w"> </span><span class="n">s3</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">((</span><span class="n">p</span><span class="w"> </span><span class="p">`</span><span class="kt">Imp</span><span class="p">`</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="w"> </span><span class="p">`</span><span class="kt">Imp</span><span class="p">`</span><span class="w"> </span><span class="n">p</span><span class="p">))</span><span class="w"> </span><span class="p">`</span><span class="kt">Imp</span><span class="p">`</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="w"> </span><span class="p">`</span><span class="kt">Imp</span><span class="p">`</span><span class="w"> </span><span class="n">p</span><span class="p">),</span><span class="w"> </span><span class="kt">MP</span><span class="w"> </span><span class="n">s2</span><span class="w"> </span><span class="n">s1</span><span class="p">)</span><span class="w"> </span><span class="kr">in</span><span class="w"></span>
<span class="w">  </span><span class="kr">let</span><span class="w"> </span><span class="n">s4</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="w"> </span><span class="p">`</span><span class="kt">Imp</span><span class="p">`</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="w"> </span><span class="p">`</span><span class="kt">Imp</span><span class="p">`</span><span class="w"> </span><span class="n">p</span><span class="p">),</span><span class="w"> </span><span class="kt">Prop_1</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="kr">in</span><span class="w"></span>
<span class="w">  </span><span class="kr">let</span><span class="w"> </span><span class="n">s5</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="w"> </span><span class="p">`</span><span class="kt">Imp</span><span class="p">`</span><span class="w"> </span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="kt">MP</span><span class="w"> </span><span class="n">s4</span><span class="w"> </span><span class="n">s3</span><span class="p">)</span><span class="w"> </span><span class="kr">in</span><span class="w"></span>
<span class="w">  </span><span class="n">checkStep</span><span class="w"> </span><span class="n">s5</span><span class="w"></span>
</code></pre></div>



<a name="269216988"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269216988" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Trebor Huang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269216988">(Jan 25 2022 at 07:11)</a>:</h4>
<p>That's right.</p>



<a name="269218660"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269218660" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269218660">(Jan 25 2022 at 07:35)</a>:</h4>
<p>Then I could also thread a separately verified  immutable definition context through <code>checkStep</code> and add <code>UnfoldFunc</code> and <code>UnfoldPred</code> cases to the <code>checkStep</code> function?</p>



<a name="269218735"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269218735" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269218735">(Jan 25 2022 at 07:36)</a>:</h4>
<p>That is, immutable with regards to <code>checkStep</code>.</p>



<a name="269218758"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269218758" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269218758">(Jan 25 2022 at 07:37)</a>:</h4>
<p>As in, no case in <code>checkStep</code> changes the definition context passed to it.</p>



<a name="269253402"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269253402" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Zhanrong Qiao <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269253402">(Jan 25 2022 at 13:05)</a>:</h4>
<p><span class="user-mention silent" data-user-id="139442">Patrick Thomas</span> <a href="#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/269218660">said</a>:</p>
<blockquote>
<p>Then I could also thread a separately verified  immutable definition context through <code>checkStep</code> and add <code>UnfoldFunc</code> and <code>UnfoldPred</code> cases to the <code>checkStep</code> function?</p>
</blockquote>
<p>Yes, you probably need to consider "assert <code>x</code> under definition context <code>d</code>" as a whole in <code>checkStep</code>... Then you probably need a "weakening" rule (adding definitions to context does not change the validity of the assertion, as long as the names used by the assertion don't get redefined etc)...</p>



<a name="269254085"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269254085" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Zhanrong Qiao <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269254085">(Jan 25 2022 at 13:10)</a>:</h4>
<p>Or you could disallow naming clashes when forming definition contexts, in this way you don't need to check for redefinitions in the weakening rule (I think I got weakening wrong in my implementations, I did not check for naming clash; will fix them later)</p>



<a name="269254381"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269254381" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Zhanrong Qiao <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269254381">(Jan 25 2022 at 13:12)</a>:</h4>
<p>But if you have a global context that 1. only allows adding more definitions but not removing definitions 2. disallows naming clash, then you no longer need to pass contexts into <code>checkStep</code> and weakening will be automatic</p>



<a name="269263894"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269263894" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Zhanrong Qiao <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269263894">(Jan 25 2022 at 14:27)</a>:</h4>
<p>Should I allow definitions to abstract over functions/predicates (like the <code>subset</code> function I imagined here)? This seems to be not even a part of <a href="https://en.wikipedia.org/wiki/Second-order_logic#Syntax_and_fragments">second-order logic</a>...</p>



<a name="269263904"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269263904" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Zhanrong Qiao <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269263904">(Jan 25 2022 at 14:27)</a>:</h4>
<p><a href="/user_uploads/3121/WWiDNuO03SaDOzCg8eMvfxct/Untitled.png">Untitled.png</a></p>
<div class="message_inline_image"><a href="/user_uploads/3121/WWiDNuO03SaDOzCg8eMvfxct/Untitled.png" title="Untitled.png"><img src="/user_uploads/3121/WWiDNuO03SaDOzCg8eMvfxct/Untitled.png"></a></div>



<a name="269265466"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269265466" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Zhanrong Qiao <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269265466">(Jan 25 2022 at 14:38)</a>:</h4>
<p>I tried and it feels like the verifier code will become much messier with this (probably I have to start from some type theory...)</p>



<a name="269337672"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269337672" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Zhanrong Qiao <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269337672">(Jan 25 2022 at 22:55)</a>:</h4>
<p>Oh but I did not imagine any instances where we need more than one abstraction over (definable) functions/predicates in a formula. Probably I could still keep it simple...</p>



<a name="269352774"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269352774" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269352774">(Jan 26 2022 at 01:50)</a>:</h4>
<p>(deleted)</p>



<a name="269358445"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269358445" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269358445">(Jan 26 2022 at 03:37)</a>:</h4>
<p>(deleted)</p>



<a name="269358939"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269358939" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269358939">(Jan 26 2022 at 03:45)</a>:</h4>
<p>Does this work for adding definitions?<br>
<a href="/user_uploads/3121/rjefRFiy-C-m3J-5MeSP8L_i/Test.hs">Test.hs</a></p>



<a name="269359719"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269359719" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269359719">(Jan 26 2022 at 03:58)</a>:</h4>
<p>I don't need to check that each function and predicate used in the proof is in the definition context do I? They just can't be unfolded if they are not?</p>



<a name="269361190"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269361190" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269361190">(Jan 26 2022 at 04:20)</a>:</h4>
<p><span class="user-mention silent" data-user-id="450398">Zhanrong Qiao</span> <a href="#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/269254381">said</a>:</p>
<blockquote>
<p>But if you have a global context that 1. only allows adding more definitions but not removing definitions 2. disallows naming clash, then you no longer need to pass contexts into <code>checkStep</code> and weakening will be automatic</p>
</blockquote>
<p>It seems that it would be easiest to not add definitions in the lines of the proof, and just require that they be given at the start. Then there is a single check that they are valid, and the context is only sent through the <code>checkProofInContext</code> function so that they can be unfolded as needed. Example code above.</p>



<a name="269361934"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269361934" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269361934">(Jan 26 2022 at 04:26)</a>:</h4>
<p>(deleted)</p>



<a name="269362115"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269362115" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269362115">(Jan 26 2022 at 04:28)</a>:</h4>
<p>(deleted)</p>



<a name="269362553"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269362553" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269362553">(Jan 26 2022 at 04:35)</a>:</h4>
<p>Should I allow a proof step for alpha conversion? Or change to locally nameless? I suppose I should do one or the other or proofs will become unwieldy?</p>



<a name="269363241"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269363241" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269363241">(Jan 26 2022 at 04:49)</a>:</h4>
<p><span class="user-mention silent" data-user-id="139442">Patrick Thomas</span> <a href="#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/269359719">said</a>:</p>
<blockquote>
<p>For this non LCF version, I don't need to check that each function and predicate used in the proof is in the definition context do I? They just can't be unfolded if they are not?</p>
</blockquote>
<p>This is not okay in definitions, at least. Because you can do <code>def foo := bar</code> (where <code>bar</code> is an undeclared nullary constant symbol) and then <code>def bar := not foo</code> (a regular definition) and suddenly you can unfold both <code>foo</code> and <code>bar</code> and get a contradiction</p>



<a name="269363514"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269363514" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269363514">(Jan 26 2022 at 04:53)</a>:</h4>
<p>It seems generally dubious to me to allow undefined references anywhere in a proof, but I think that under certain settings you can argue that if you use an undefined term constructor somewhere then it is effectively an opaque constant, and assuming it doesn't show up in the theorem statement you can generalize it and replace it with something more innocuous like the constant true function. (It does imply that your sorts are all nonempty, but in FOL this is usually the case anyway.)</p>



<a name="269364148"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269364148" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269364148">(Jan 26 2022 at 05:02)</a>:</h4>
<p><span class="user-mention silent" data-user-id="450398">Zhanrong Qiao</span> <a href="#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/269263894">said</a>:</p>
<blockquote>
<p>Should I allow definitions to abstract over functions/predicates (like the <code>subset</code> function I imagined here)? This seems to be not even a part of <a href="https://en.wikipedia.org/wiki/Second-order_logic#Syntax_and_fragments">second-order logic</a>...</p>
</blockquote>
<p>You might take some inspiration from metamath here. Metamath allows for the definition of functions that take second order variables, but no higher. If <code>Set</code> is the base sort (the collection of ZFC sets, for example), then first order variables (set variables) have type <code>Set</code> and second order variables (class and wff variables) have type <code>Set -&gt; ... -&gt; Class</code> or <code>Set -&gt; ... -&gt; Prop</code> (where we think of <code>Class</code> as <code>Class := Set -&gt; Prop</code>). It is then possible to make definitions that accept any number of class and wff variables and produce a class or wff, for example the class abstraction operator <code>(Set -&gt; Prop) -&gt; Class</code>. However, there are no variables in this "third order" level, only concrete term constructors. <code>subset : Class -&gt; Class -&gt; Prop</code> would be in this category.</p>



<a name="269364766"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269364766" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269364766">(Jan 26 2022 at 05:13)</a>:</h4>
<p>(deleted)</p>



<a name="269523830"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269523830" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269523830">(Jan 27 2022 at 04:13)</a>:</h4>
<p>Does this fix the issue with the undefined references? <a href="/user_uploads/3121/Zu1_2In88zKJWxtE4p-pEjE4/Test.hs">Test.hs</a></p>



<a name="269530905"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269530905" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269530905">(Jan 27 2022 at 06:28)</a>:</h4>
<p>It does, but now you have the issue that you have to recheck subformulas many times. The usual way to fix this is to add some explicit DAG-like structure to your proof terms, so that if a subproof or subformula appears in two places it only has to be validated once. This can be done by adding a <code>let</code>-like construct: a way to extend the local context with a record "<code>Ref 0</code> means <code>P /\ Q</code>", and then you can use <code>Ref 0</code> to refer to this saved expression, and you know it is valid because it was checked when it was first entered into the context. The same thing applies to proofs, this is basically <code>have</code> statements. It is useful for both terms/formulas and proofs: for proofs, because proofs can be long and you don't want to duplicate them (and if there are duplicated subproofs in a duplicated proof it can blow up exponentially), and for terms/formulas because they have very high duplication within a proof, because all the core rules require some kind of subterm similarity (for example, <code>P</code> will necessarily be constructed at least twice, in both sides of a <code>MP</code> application proving <code>P, (P -&gt; Q) |- Q</code>).</p>



<a name="269582118"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269582118" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269582118">(Jan 27 2022 at 14:44)</a>:</h4>
<p>Thank you. Does this mean for instance that instead of passing <code>Term</code>s, <code>Formula</code>s and <code>Proof</code>s to cases of <code>checkProofInContext</code>, you would pass <code>Either Term Ref</code>, <code>Either Formula Ref</code> and <code>Either Proof Ref</code> and also a local context mapping <code>Ref</code> to <code>Term</code>s, <code>Formula</code>s and <code>Proof</code>s? And you would change <code>Proof</code> to be one of <code>Assertion Justification</code>, <code>Let Ref (Either Term Formula)</code> or <code>Have Ref Proof</code>?</p>



<a name="269597839"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269597839" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269597839">(Jan 27 2022 at 16:26)</a>:</h4>
<p>Actually, no, I'm not sure I have that right. At least not the part about changing the definition of <code>Proof</code>.</p>



<a name="269600128"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269600128" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269600128">(Jan 27 2022 at 16:42)</a>:</h4>
<p>Maybe I should create a <code>Step</code> type that is either a <code>(Assertion, Justification)</code>, a <code>Let</code> or a <code>Have</code>? And replace the <code>checkProofInContext</code> function with a <code>CheckSteps</code> function that takes the definition context, reference context and a list of <code>Step</code>s?</p>



<a name="269600993"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269600993" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269600993">(Jan 27 2022 at 16:48)</a>:</h4>
<p>I'm not sure. Suggestions welcomed :)</p>



<a name="269602434"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269602434" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269602434">(Jan 27 2022 at 16:57)</a>:</h4>
<p>You want <code>Let</code> and <code>Have</code> to be part of the <code>Justification</code> grammar itself, and similarly you want <code>Ref</code> to appear inside a <code>Formula</code>. This complicates formula equality testing though; one way would be to ensure as part of wellformedness checking that formulas in the context never contain <code>Ref</code> and formulas in the <code>Justification</code> have all the <code>Ref</code>s substituted out before going in the context or being equality tested</p>



<a name="269602638"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269602638" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269602638">(Jan 27 2022 at 16:59)</a>:</h4>
<p>basically the <code>Formula</code> expressions inside <code>Justification</code> are more like mini-programs for constructing a formula with guaranteed internal sharing</p>



<a name="269603445"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269603445" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269603445">(Jan 27 2022 at 17:03)</a>:</h4>
<p>When you say context, are you referring to the definition context?</p>



<a name="269603796"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269603796" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269603796">(Jan 27 2022 at 17:05)</a>:</h4>
<p>Also, what do you mean by guaranteed internal sharing?</p>



<a name="269614635"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269614635" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Zhanrong Qiao <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269614635">(Jan 27 2022 at 18:14)</a>:</h4>
<p>Without de Brujin indexing, you recurse to check formulas without modifying it, so if you have a "certificate" that some formula is well-formed, then you also have "certificates" that all its subformulas are well-formed (though if you move into binders, there will be more free variables), so you could reuse the "certificates" (i.e. skip checking formulas that are subformulas of already-checked ones) i guess</p>



<a name="269616084"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269616084" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Zhanrong Qiao <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269616084">(Jan 27 2022 at 18:24)</a>:</h4>
<p>To implement this we could store checked formulas in the context for reference</p>



<a name="269616322"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269616322" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Zhanrong Qiao <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269616322">(Jan 27 2022 at 18:26)</a>:</h4>
<p>But if formulas in the context refer to each other, that could make equality testing slow, so Mario suggests to unfold their <code>Ref</code>s before putting formulas into the context?</p>



<a name="269617289"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269617289" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Zhanrong Qiao <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269617289">(Jan 27 2022 at 18:33)</a>:</h4>
<p>(I'm not going to push for this level of optimization in checking for now... Will we encounter really long formulas in practice?)</p>



<a name="269619321"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269619321" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269619321">(Jan 27 2022 at 18:48)</a>:</h4>
<p>I'm not sure if this is what he meant or not.</p>



<a name="269648876"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269648876" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269648876">(Jan 27 2022 at 22:20)</a>:</h4>
<p>I'm not sure that he is saying that the issue is related to not using de Bruijn indexes.</p>



<a name="269651141"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269651141" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269651141">(Jan 27 2022 at 22:39)</a>:</h4>
<p>No, de bruijn indices don't really affect this one way or another</p>



<a name="269651231"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269651231" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269651231">(Jan 27 2022 at 22:40)</a>:</h4>
<p>When I say context I mean the local context associating <code>Ref -&gt; CheckedFormula</code></p>



<a name="269651572"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269651572" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269651572">(Jan 27 2022 at 22:43)</a>:</h4>
<p>What differentiates local and global contexts? The definition context is passed trough each instance of the proof checking function, so I guess that makes it global? What would be an example of a local context?</p>



<a name="269651592"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269651592" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269651592">(Jan 27 2022 at 22:43)</a>:</h4>
<p>by internal sharing, I mean that something like <code>(x + x) + (x + x)</code> will be represented as a DAG with 3 nodes <code>x4 ⇉ x2 ⇉ x</code></p>



<a name="269651778"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269651778" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269651778">(Jan 27 2022 at 22:44)</a>:</h4>
<p>The map from refs to formulas can have whatever scope you like, but it generally makes most sense for it to be local to a given proof</p>



<a name="269651812"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269651812" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269651812">(Jan 27 2022 at 22:45)</a>:</h4>
<p>if you make it too global then the ref numbers and the context gets big</p>



<a name="269651850"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269651850" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269651850">(Jan 27 2022 at 22:45)</a>:</h4>
<p>since it basically becomes a log of all expressions ever constructed</p>



<a name="269651981"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269651981" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269651981">(Jan 27 2022 at 22:46)</a>:</h4>
<p>Wait, so every formula gets added to the map from references to formulas, not just those specified by <code>let</code>?</p>



<a name="269652045"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269652045" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269652045">(Jan 27 2022 at 22:47)</a>:</h4>
<p>no, just the <code>let</code> ones, but you can have them stick around / not be scoped if you like</p>



<a name="269652126"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269652126" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269652126">(Jan 27 2022 at 22:47)</a>:</h4>
<p>for example you could require that every proof starts with a list of all <code>let</code> formulas and then the actual justification</p>



<a name="269652248"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269652248" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269652248">(Jan 27 2022 at 22:48)</a>:</h4>
<p>that way you don't have to worry about scope checking, things just monotonically add to the context and then you throw the whole thing away at the end of the proof</p>



<a name="269652476"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269652476" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269652476">(Jan 27 2022 at 22:50)</a>:</h4>
<p>What would be the drawback to doing that?</p>



<a name="269652547"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269652547" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269652547">(Jan 27 2022 at 22:51)</a>:</h4>
<p>I'm not sure what would delineate the start and end of a local context?</p>



<a name="269652657"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269652657" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269652657">(Jan 27 2022 at 22:52)</a>:</h4>
<p>How would that differ from what I added for definitions?</p>



<a name="269652664"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269652664" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269652664">(Jan 27 2022 at 22:52)</a>:</h4>
<p>no major drawback, I suppose the numbers could get large if it's a big monolithic proof but it probably won't be your biggest issue anyway</p>



<a name="269652773"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269652773" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269652773">(Jan 27 2022 at 22:53)</a>:</h4>
<p>Does that mean you see a much bigger issue here?</p>



<a name="269652894"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269652894" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269652894">(Jan 27 2022 at 22:54)</a>:</h4>
<p>It's kind of like definitions, but transparent to the other rules. If <code>r0 := p /\ p</code> and <code>r1 := p</code>  then you want <code>r0</code> and <code>r1 /\ p</code> to be considered syntactically equal for the purposes of rules like <code>MP</code></p>



<a name="269652998"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269652998" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269652998">(Jan 27 2022 at 22:55)</a>:</h4>
<p>Note that equality testing is still slow with this scheme, because in haskell you can't observe the pointer sharing so even if you have <code>x4 ⇉ x2 ⇉ x</code> and <code>y4 ⇉ y2 ⇉ x</code> checking that <code>x4 = y4</code> requires checking <code>x2 = y2</code> twice</p>



<a name="269653133"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269653133" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269653133">(Jan 27 2022 at 22:56)</a>:</h4>
<p>This is only a major issue if you have large terms, however. As Zhanrong said, long formulas are a niche issue</p>



<a name="269653179"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269653179" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269653179">(Jan 27 2022 at 22:56)</a>:</h4>
<p>It's more important to support this for proofs, since duplication there is much more common</p>



<a name="269653224"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269653224" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269653224">(Jan 27 2022 at 22:57)</a>:</h4>
<p>In DTT you can get very large terms or terms with high duplication, however</p>



<a name="269653373"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269653373" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269653373">(Jan 27 2022 at 22:58)</a>:</h4>
<p>DTT?</p>



<a name="269653401"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269653401" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269653401">(Jan 27 2022 at 22:58)</a>:</h4>
<p>dependent type theory, i.e. lean or coq style</p>



<a name="269653430"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269653430" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269653430">(Jan 27 2022 at 22:59)</a>:</h4>
<p>as opposed to FOL or HOL</p>



<a name="269654071"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269654071" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269654071">(Jan 27 2022 at 23:04)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/269653179">said</a>:</p>
<blockquote>
<p>It's more important to support this for proofs, since duplication there is much more common</p>
</blockquote>
<p>You mean <code>have</code> statements?</p>



<a name="269654502"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269654502" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269654502">(Jan 27 2022 at 23:07)</a>:</h4>
<p>Sorry, I'm not certain what a local context would look like. What would start and end it?</p>



<a name="269654683"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269654683" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269654683">(Jan 27 2022 at 23:08)</a>:</h4>
<p>Can you do the same thing with <code>have</code> statements and put them all at the beginning, like using earlier proofs?</p>



<a name="269654770"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269654770" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269654770">(Jan 27 2022 at 23:09)</a>:</h4>
<p>It doesn't seem like what I currently have doesn't have any support for using prior proofs?</p>



<a name="269659010"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269659010" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269659010">(Jan 27 2022 at 23:46)</a>:</h4>
<p>A local context for holding terms, formulas, and proofs might look like this:</p>
<div class="codehilite" data-code-language="Haskell"><pre><span></span><code><span class="kr">data</span><span class="w"> </span><span class="kt">ProofContext</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">ProofContext</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"> </span><span class="n">terms</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Seq</span><span class="w"> </span><span class="kt">Term</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">fmlas</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Seq</span><span class="w"> </span><span class="kt">Formula</span><span class="p">,</span><span class="w"></span>
<span class="w">   </span><span class="n">proofs</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Seq</span><span class="w"> </span><span class="kt">Assertion</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="kr">data</span><span class="w"> </span><span class="kt">Term</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
<span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="kt">Ref</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>

<span class="kr">data</span><span class="w"> </span><span class="kt">Formula</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
<span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="kt">Ref</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>

<span class="kr">data</span><span class="w"> </span><span class="kt">Justification</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
<span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="kt">Ref</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>
<span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="kt">LetTerm</span><span class="w"> </span><span class="kt">Term</span><span class="w"> </span><span class="kt">Justification</span><span class="w"></span>
<span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="kt">LetFormula</span><span class="w"> </span><span class="kt">Formula</span><span class="w"> </span><span class="kt">Justification</span><span class="w"></span>
<span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="kt">LetProof</span><span class="w"> </span><span class="kt">Proof</span><span class="w"> </span><span class="kt">Justification</span><span class="w"></span>

<span class="nf">checkProof</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Context</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">ProofContext</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Proof</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Bool</span><span class="w"></span>
</code></pre></div>



<a name="269660099"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269660099" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269660099">(Jan 27 2022 at 23:56)</a>:</h4>
<p>Thank you. What makes <code>ProofContext</code> local?</p>



<a name="269660376"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269660376" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269660376">(Jan 27 2022 at 23:59)</a>:</h4>
<p>Does local mean initialized to be empty at the start of each <code>checkProof</code>?</p>



<a name="269666835"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269666835" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269666835">(Jan 28 2022 at 01:05)</a>:</h4>
<p>Is there a formal definition of what a proof is in Hilbert FOL? For instance something that reads like "a proof is a sequence of steps each of which can refer to a previous step and must be of the form ....."</p>



<a name="269679452"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269679452" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269679452">(Jan 28 2022 at 02:47)</a>:</h4>
<p><span class="user-mention silent" data-user-id="139442">Patrick Thomas</span> <a href="#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/269660376">said</a>:</p>
<blockquote>
<p>Does local mean initialized to be empty at the start of each <code>checkProof</code>?</p>
</blockquote>
<p>Yes</p>



<a name="269679509"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269679509" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269679509">(Jan 28 2022 at 02:48)</a>:</h4>
<p>compared to <code>Context</code> which contains all the definitions, and is generally monotonic across a whole proof development</p>



<a name="269681923"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269681923" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269681923">(Jan 28 2022 at 03:29)</a>:</h4>
<p><code>checkProof</code> is not the entirety of a whole proof development?</p>



<a name="269682031"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269682031" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269682031">(Jan 28 2022 at 03:31)</a>:</h4>
<p>I don't know why I didn't think of this before, but there is probably a formal description of this proof system (Hilbert FOL with equality and definitions) that I could be referencing and translating from?</p>



<a name="269682323"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269682323" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269682323">(Jan 28 2022 at 03:36)</a>:</h4>
<p>For example, something that reads like "A proof is a sequence of steps such that ..."</p>



<a name="269685105"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269685105" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269685105">(Jan 28 2022 at 04:26)</a>:</h4>
<p>If anyone has a pointer to one, that would be great. Thank you.</p>



<a name="269697689"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269697689" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Trebor Huang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269697689">(Jan 28 2022 at 07:46)</a>:</h4>
<p>Logic books usually don't do that because that's too "software-engineerish". So you should probably look in proof assistant descriptions. I haven't really read about Mizar or HOL Light before, but I suppose you can find relevant design there.</p>
<p>Probably nobody has ever done this exact thing, so there won't be complete references, and you have to gather information from different sources.</p>



<a name="269726785"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269726785" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269726785">(Jan 28 2022 at 12:18)</a>:</h4>
<p>One example that gets pretty close to covering the whole gamut of practical theory development is the <a href="http://www.gilith.com/opentheory/article.html">OpenTheory spec</a></p>



<a name="269754716"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269754716" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269754716">(Jan 28 2022 at 15:37)</a>:</h4>
<p>Thank you. I'm kind of surprised that no one has done this before, and I wonder if they had good reason and I am missing something. I was kind of expecting to find something in searches related to proof theory, but the closest I have come is the extended Frege system.</p>



<a name="269760278"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269760278" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269760278">(Jan 28 2022 at 16:15)</a>:</h4>
<p>"It does, but now you have the issue that you have to recheck subformulas many times. The usual way to fix this is to add some explicit DAG-like structure to your proof terms, so that if a subproof or subformula appears in two places it only has to be validated once."<br>
For example, when you say the usual way, what does that mean? What references or examples do you draw from?</p>



<a name="269779744"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269779744" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Zhanrong Qiao <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269779744">(Jan 28 2022 at 18:22)</a>:</h4>
<p>Like, for example we have <code>let</code> binders in all major proof assistants...?</p>



<a name="269780094"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269780094" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269780094">(Jan 28 2022 at 18:25)</a>:</h4>
<p>I guess I meant more along the lines of how they are implemented.</p>



<a name="269783223"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269783223" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Zhanrong Qiao <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269783223">(Jan 28 2022 at 18:45)</a>:</h4>
<p>You mean, how are the representation and checking of <code>let</code> implemented?</p>



<a name="269783289"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269783289" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269783289">(Jan 28 2022 at 18:46)</a>:</h4>
<p>Yes, I think so.</p>



<a name="269784563"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269784563" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Zhanrong Qiao <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269784563">(Jan 28 2022 at 18:55)</a>:</h4>
<p>If I understood correctly, I guess in your example just extend <code>Formula</code> with a constructor <code>Ref Int</code>, and <code>Justification</code> with a constructor <code>Let [Formula] Justification</code> (the list can be seen as a mapping from <code>Int</code> to <code>Formula</code>, and probably using <code>Map Int Formula</code> is faster in Haskell? And the <code>Justification</code> argument is the scope of the Let) with the convention that there are no nested <code>Let</code>s.</p>



<a name="269784921"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269784921" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Zhanrong Qiao <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269784921">(Jan 28 2022 at 18:57)</a>:</h4>
<p>I guess that more commonly, a local context is kept when checking proofs, and upon encountering a <code>Let String Formula Proof</code>, check the <code>Formula</code>, temporarily push the entry <code>(String, Formula)</code> onto the top of the local context and check the <code>Proof</code> in the extended context (in this way there can be nested <code>Let</code>s)</p>



<a name="269785515"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269785515" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Zhanrong Qiao <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269785515">(Jan 28 2022 at 19:01)</a>:</h4>
<p>And when encountering <code>Ref Int</code> (or <code>Ref String</code> or <code>Ref</code> + whatever index type) just read the corresponding entry from the local context</p>



<a name="269786219"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269786219" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269786219">(Jan 28 2022 at 19:05)</a>:</h4>
<p>So a global context is common to all proofs? I guess I'm having trouble understanding what would constitute separate proofs, because in order to use one proof in another you have to check the "external" proof when you encounter a reference to it in another proof?</p>



<a name="269786384"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269786384" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269786384">(Jan 28 2022 at 19:06)</a>:</h4>
<p>That is, I don't see a way in the current system to have separate <code>Theorem</code> statements like in Lean.</p>



<a name="269786503"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269786503" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269786503">(Jan 28 2022 at 19:07)</a>:</h4>
<p>All of which fall under a global context.</p>



<a name="269787120"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269787120" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Zhanrong Qiao <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269787120">(Jan 28 2022 at 19:10)</a>:</h4>
<p>Lean seems to have a two-level hierarchy (just my feeling, I'm not sure if I'm correct, I have less experience in theorem proving than you...), in the "outer level" you use <code>axiom</code>, <code>def</code>, <code>theorem</code> etc. to introduce things, and the "inner level" is only relevant when checking individual terms, where you use <code>let</code>, <code>λ</code> etc. to introduce things (and these things will be removed once you go out of their scope)?</p>



<a name="269787450"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269787450" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269787450">(Jan 28 2022 at 19:13)</a>:</h4>
<p>That is how it appears to me as well. I don't have that much experience either. I'm wondering if that is what Mario means by a global and local context in my implementation.</p>



<a name="269788829"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269788829" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Zhanrong Qiao <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269788829">(Jan 28 2022 at 19:24)</a>:</h4>
<p>I don't think you made such a distinction in your implementation (I also did not, and I'm not even sure whether we need two levels of contexts...)</p>



<a name="269788965"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269788965" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269788965">(Jan 28 2022 at 19:25)</a>:</h4>
<p>No, I don't think I did. I'm wondering if I should have.</p>



<a name="269789775"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269789775" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Zhanrong Qiao <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269789775">(Jan 28 2022 at 19:31)</a>:</h4>
<p>(Probably this is for the sake of checking speed? After removing definitions from the context, you will need to check if the conclusion of a proof is still a well-formed formula, and if there are only two layers (here I mean a global one and one for the scope of a <code>Let</code>, with no nested <code>Let</code>s) this check will not be too often)</p>



<a name="269789915"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269789915" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Zhanrong Qiao <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269789915">(Jan 28 2022 at 19:32)</a>:</h4>
<p>But we still have nested <code>let</code>s and <code>λ</code>s in Lean anyway (Lean's "inner level" context is more like a stack with multiple layers. Sorry if my wording is confusing...)</p>



<a name="269791711"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269791711" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269791711">(Jan 28 2022 at 19:46)</a>:</h4>
<p>I'm also wondering if a Hilbert system was the right approach.</p>



<a name="269793420"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269793420" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Zhanrong Qiao <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269793420">(Jan 28 2022 at 19:58)</a>:</h4>
<p>I (personally) think to make proofs appear natural, it's better to provide rules that allow making and discharging hypotheses directly (and anyway you can transform such proofs into Hilbert-style using the deduction theorem afterwards)... <a href="http://us.metamath.org/mpeuni/mmnatded.html">Metamath also supports this!</a></p>



<a name="269797192"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269797192" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269797192">(Jan 28 2022 at 20:23)</a>:</h4>
<p>Hmm. I wonder if <code>let</code> and <code>have</code> are something usually reserved for natural deduction.</p>



<a name="269797343"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269797343" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269797343">(Jan 28 2022 at 20:24)</a>:</h4>
<p>Same with local and global contexts.</p>



<a name="269797389"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269797389" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269797389">(Jan 28 2022 at 20:24)</a>:</h4>
<p>Or at least originate from it.</p>



<a name="269797968"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269797968" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Zhanrong Qiao <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269797968">(Jan 28 2022 at 20:29)</a>:</h4>
<p>In some sense yes? Natural deduction is indeed related to <code>λ</code> (through the Curry-Howard correspondence) which also binds some variable...</p>



<a name="269798094"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269798094" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Zhanrong Qiao <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269798094">(Jan 28 2022 at 20:30)</a>:</h4>
<p><code>let</code> and <code>have</code> are related to the "cut rule" in sequent calculus in this way</p>



<a name="269798358"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269798358" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269798358">(Jan 28 2022 at 20:33)</a>:</h4>
<p>Interesting. I am familiar with the Curry-Howard correspondence, but not sequent calculus.</p>



<a name="269798770"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269798770" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Zhanrong Qiao <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269798770">(Jan 28 2022 at 20:36)</a>:</h4>
<p>Sequent calculus feels like "what we are actually thinking when writing down natural deduction proofs", and it works both forwards (from premises) and backwards (from goals); natural deduction is like working forwards only</p>



<a name="269798955"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269798955" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269798955">(Jan 28 2022 at 20:37)</a>:</h4>
<p>Hmm. What do <code>have</code> and <code>let</code> correspond to in natural deduction?</p>



<a name="269799106"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269799106" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Zhanrong Qiao <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269799106">(Jan 28 2022 at 20:38)</a>:</h4>
<p>The cut rule corresponds to "proving some lemma and then use it to prove the goal" in ND</p>



<a name="269799272"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269799272" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269799272">(Jan 28 2022 at 20:40)</a>:</h4>
<p>I see. Are there also local and global definitions?</p>



<a name="269799274"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269799274" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Zhanrong Qiao <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269799274">(Jan 28 2022 at 20:40)</a>:</h4>
<p>(deleted)</p>



<a name="269799331"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269799331" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Zhanrong Qiao <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269799331">(Jan 28 2022 at 20:40)</a>:</h4>
<p>I don't think so, they are often considered separately as an extension to FOL? (But in dependent type theory with C-H they are similar to <code>let</code>...)</p>



<a name="269799415"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269799415" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269799415">(Jan 28 2022 at 20:41)</a>:</h4>
<p>I see. Thank you!</p>



<a name="269821328"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269821328" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269821328">(Jan 29 2022 at 00:05)</a>:</h4>
<p>Is there a good reference for formalized natural deduction extended with definitions?</p>



<a name="269826105"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269826105" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269826105">(Jan 29 2022 at 01:02)</a>:</h4>
<p>What is the form of natural deduction that Lean corresponds to in the Curry-Howard correspondence? Is there a formalization for it?</p>



<a name="269831255"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269831255" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269831255">(Jan 29 2022 at 02:28)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/268179806">said</a>:</p>
<blockquote>
<p>Your rule for <code>ForallIntro</code> is problematic because you don't have a weakening rule: you won't be able to prove e.g. <code>x = x |- forall x. True</code>. One way to fix it is instead of checking <code>not (any (freeIn x) gamma)</code> you filter out everything from <code>gamma</code> which has a free <code>x</code> in the subproof.</p>
</blockquote>
<p>Do you mean like:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">Forall</span> <span class="n">introduction</span><span class="o">:</span>
<span class="n">Let</span> <span class="n">gamma</span> <span class="bp">-</span> <span class="o">{</span><span class="n">x</span><span class="o">}</span> <span class="n">be</span> <span class="n">the</span> <span class="n">set</span> <span class="n">of</span> <span class="n">all</span> <span class="n">the</span> <span class="n">formulas</span> <span class="k">in</span> <span class="n">gamma</span> <span class="n">for</span> <span class="n">which</span> <span class="n">x</span> <span class="n">does</span> <span class="n">not</span> <span class="n">occur</span> <span class="n">free.</span> <span class="n">Then</span>
<span class="o">(</span><span class="n">gamma</span> <span class="bp">-</span> <span class="o">{</span><span class="n">x</span><span class="o">}</span><span class="bp">|-</span> <span class="n">p</span><span class="o">)</span> <span class="bp">=&gt;</span>
<span class="o">(</span><span class="n">gamma</span> <span class="bp">|-</span> <span class="k">forall</span> <span class="n">x.</span> <span class="n">p</span><span class="o">)</span>
</code></pre></div>



<a name="269831858"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269831858" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269831858">(Jan 29 2022 at 02:40)</a>:</h4>
<p>Does the same problem occur in my implementation of exists elimination?</p>



<a name="269843136"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269843136" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269843136">(Jan 29 2022 at 06:15)</a>:</h4>
<p>Is it natural deduction that Lean corresponds to in the C-H correspondence? If so, what are the exact rules of inference for it? What do <code>let</code> and <code>have</code> correspond to in it?</p>



<a name="269849090"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269849090" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269849090">(Jan 29 2022 at 08:25)</a>:</h4>
<p>Are <code>have</code> statements needed because my checker processes a proof as a tree, and in a tree you have to repeat the entirety of subproofs if you use them more than once? For example, would <code>have</code> statements no longer be needed if instead my checker processed the proof as a sequence of labelled steps, and the inference rules just used the labels to refer to previously checked steps?</p>



<a name="269852470"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269852470" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269852470">(Jan 29 2022 at 09:37)</a>:</h4>
<p>This could probably be made cleaner and faster, but for a thrown together example, does this eliminate the need for <code>have</code> statements?</p>
<div class="codehilite" data-code-language="Haskell"><pre><span></span><code><span class="kr">import</span><span class="w"> </span><span class="nn">Data.Map</span><span class="w"></span>
<span class="kr">import</span><span class="w"> </span><span class="nn">Data.Set</span><span class="w"></span>

<span class="cm">{-</span>
<span class="cm">Func "c" [] : A constant named "c"</span>
<span class="cm">Func "f" [v] : A function named "f" of one variable v</span>
<span class="cm">-}</span><span class="w"></span>
<span class="kr">data</span><span class="w"> </span><span class="kt">Term</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Var</span><span class="w"> </span><span class="kt">String</span><span class="w"></span>
<span class="w">          </span><span class="o">|</span><span class="w"> </span><span class="kt">Func</span><span class="w"> </span><span class="kt">String</span><span class="w"> </span><span class="p">[</span><span class="kt">Term</span><span class="p">]</span><span class="w"></span>
<span class="w">            </span><span class="kr">deriving</span><span class="w"> </span><span class="p">(</span><span class="kt">Show</span><span class="p">,</span><span class="w"> </span><span class="kt">Eq</span><span class="p">)</span><span class="w"></span>

<span class="cm">{-</span>
<span class="cm">Pred "P" [] : A propositional variable named "P"</span>
<span class="cm">Pred "Eq" [s, t] : s = t</span>
<span class="cm">-}</span><span class="w"></span>
<span class="kr">data</span><span class="w"> </span><span class="kt">Formula</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Bottom</span><span class="w"> </span><span class="c1">-- False</span><span class="w"></span>
<span class="w">             </span><span class="o">|</span><span class="w"> </span><span class="kt">Top</span><span class="w"> </span><span class="c1">-- True</span><span class="w"></span>
<span class="w">             </span><span class="o">|</span><span class="w"> </span><span class="kt">Pred</span><span class="w"> </span><span class="kt">String</span><span class="w"> </span><span class="p">[</span><span class="kt">Term</span><span class="p">]</span><span class="w"></span>
<span class="w">             </span><span class="o">|</span><span class="w"> </span><span class="kt">Not</span><span class="w"> </span><span class="kt">Formula</span><span class="w"></span>
<span class="w">             </span><span class="o">|</span><span class="w"> </span><span class="kt">And</span><span class="w"> </span><span class="kt">Formula</span><span class="w"> </span><span class="kt">Formula</span><span class="w"></span>
<span class="w">             </span><span class="o">|</span><span class="w"> </span><span class="kt">Or</span><span class="w"> </span><span class="kt">Formula</span><span class="w"> </span><span class="kt">Formula</span><span class="w"></span>
<span class="w">             </span><span class="o">|</span><span class="w"> </span><span class="kt">Imp</span><span class="w"> </span><span class="kt">Formula</span><span class="w"> </span><span class="kt">Formula</span><span class="w"></span>
<span class="w">             </span><span class="o">|</span><span class="w"> </span><span class="kt">Iff</span><span class="w"> </span><span class="kt">Formula</span><span class="w"> </span><span class="kt">Formula</span><span class="w"></span>
<span class="w">             </span><span class="o">|</span><span class="w"> </span><span class="kt">Forall</span><span class="w"> </span><span class="kt">String</span><span class="w"> </span><span class="kt">Formula</span><span class="w"></span>
<span class="w">             </span><span class="o">|</span><span class="w"> </span><span class="kt">Exists</span><span class="w"> </span><span class="kt">String</span><span class="w"> </span><span class="kt">Formula</span><span class="w"></span>
<span class="w">               </span><span class="kr">deriving</span><span class="w"> </span><span class="p">(</span><span class="kt">Show</span><span class="p">,</span><span class="w"> </span><span class="kt">Eq</span><span class="p">)</span><span class="w"></span>

<span class="kr">type</span><span class="w"> </span><span class="kt">Assertion</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Formula</span><span class="w"></span>

<span class="kr">data</span><span class="w"> </span><span class="kt">Justification</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">MP</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>
<span class="w">                   </span><span class="o">|</span><span class="w"> </span><span class="kt">Prop_1</span><span class="w"> </span><span class="kt">Formula</span><span class="w"> </span><span class="kt">Formula</span><span class="w"></span>
<span class="w">                   </span><span class="o">|</span><span class="w"> </span><span class="kt">Prop_2</span><span class="w"> </span><span class="kt">Formula</span><span class="w"> </span><span class="kt">Formula</span><span class="w"> </span><span class="kt">Formula</span><span class="w"></span>
<span class="w">                   </span><span class="o">|</span><span class="w"> </span><span class="kt">Prop_3</span><span class="w"> </span><span class="kt">Formula</span><span class="w"></span>
<span class="w">                     </span><span class="kr">deriving</span><span class="w"> </span><span class="p">(</span><span class="kt">Show</span><span class="p">,</span><span class="w"> </span><span class="kt">Eq</span><span class="p">)</span><span class="w"></span>

<span class="kr">type</span><span class="w"> </span><span class="kt">Step</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="kt">Assertion</span><span class="p">,</span><span class="w"> </span><span class="kt">Justification</span><span class="p">)</span><span class="w"></span>

<span class="nf">checkStep</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="kt">Step</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Step</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Bool</span><span class="w"></span>

<span class="c1">-- Propositional calculus</span><span class="w"></span>

<span class="c1">-- |- p &amp; |- (p -&gt; q) =&gt; |- q</span><span class="w"></span>
<span class="nf">checkStep</span><span class="w"> </span><span class="n">checked</span><span class="w"> </span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="w"> </span><span class="kt">MP</span><span class="w"> </span><span class="n">index_1</span><span class="w"> </span><span class="n">index_2</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"></span>
<span class="w">  </span><span class="kr">let</span><span class="w"> </span><span class="n">pq</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">fst</span><span class="w"> </span><span class="p">(</span><span class="n">checked</span><span class="w"> </span><span class="o">!!</span><span class="w"> </span><span class="n">index_1</span><span class="p">)</span><span class="w"> </span><span class="kr">in</span><span class="w"></span>
<span class="w">  </span><span class="kr">let</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">fst</span><span class="w"> </span><span class="p">(</span><span class="n">checked</span><span class="w"> </span><span class="o">!!</span><span class="w"> </span><span class="n">index_2</span><span class="p">)</span><span class="w"> </span><span class="kr">in</span><span class="w"></span>
<span class="w">  </span><span class="kr">case</span><span class="w"> </span><span class="n">pq</span><span class="w"> </span><span class="kr">of</span><span class="w"></span>
<span class="w">    </span><span class="p">(</span><span class="kt">Imp</span><span class="w"> </span><span class="n">p'</span><span class="w"> </span><span class="n">q'</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">p'</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">q'</span><span class="w"></span>
<span class="w">    </span><span class="kr">_</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="ne">error</span><span class="w"> </span><span class="s">"mp"</span><span class="w"></span>

<span class="c1">-- |- (p -&gt; (q -&gt; p))</span><span class="w"></span>
<span class="nf">checkStep</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="p">(</span><span class="n">assertion</span><span class="p">,</span><span class="w"> </span><span class="kt">Prop_1</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">q</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"></span>
<span class="w">  </span><span class="n">assertion</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="w"> </span><span class="p">`</span><span class="kt">Imp</span><span class="p">`</span><span class="w"> </span><span class="p">(</span><span class="n">q</span><span class="w"> </span><span class="p">`</span><span class="kt">Imp</span><span class="p">`</span><span class="w"> </span><span class="n">p</span><span class="p">))</span><span class="w"></span>

<span class="c1">-- |- ((p -&gt; (q -&gt; r)) -&gt; ((p -&gt; q) -&gt; (p -&gt; r)))</span><span class="w"></span>
<span class="nf">checkStep</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="p">(</span><span class="n">assertion</span><span class="p">,</span><span class="w"> </span><span class="kt">Prop_2</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="n">r</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"></span>
<span class="w">  </span><span class="n">assertion</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">((</span><span class="n">p</span><span class="w"> </span><span class="p">`</span><span class="kt">Imp</span><span class="p">`</span><span class="w"> </span><span class="p">(</span><span class="n">q</span><span class="w"> </span><span class="p">`</span><span class="kt">Imp</span><span class="p">`</span><span class="w"> </span><span class="n">r</span><span class="p">))</span><span class="w"> </span><span class="p">`</span><span class="kt">Imp</span><span class="p">`</span><span class="w"> </span><span class="p">((</span><span class="n">p</span><span class="w"> </span><span class="p">`</span><span class="kt">Imp</span><span class="p">`</span><span class="w"> </span><span class="n">q</span><span class="p">)</span><span class="w"> </span><span class="p">`</span><span class="kt">Imp</span><span class="p">`</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="w"> </span><span class="p">`</span><span class="kt">Imp</span><span class="p">`</span><span class="w"> </span><span class="n">r</span><span class="p">)))</span><span class="w"></span>

<span class="c1">-- |- (((p -&gt; false) -&gt; false) -&gt; p)</span><span class="w"></span>
<span class="nf">checkStep</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="p">(</span><span class="n">assertion</span><span class="p">,</span><span class="w"> </span><span class="kt">Prop_3</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"></span>
<span class="w">  </span><span class="n">assertion</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(((</span><span class="n">p</span><span class="w"> </span><span class="p">`</span><span class="kt">Imp</span><span class="p">`</span><span class="w"> </span><span class="kt">Bottom</span><span class="p">)</span><span class="w"> </span><span class="p">`</span><span class="kt">Imp</span><span class="p">`</span><span class="w"> </span><span class="kt">Bottom</span><span class="p">)</span><span class="w"> </span><span class="p">`</span><span class="kt">Imp</span><span class="p">`</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"></span>


<span class="nf">checkAll</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="kt">Step</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Bool</span><span class="w"></span>
<span class="nf">checkAll</span><span class="w"> </span><span class="n">steps</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">go</span><span class="w"> </span><span class="n">steps</span><span class="w"> </span><span class="kt">[]</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="n">go</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="kt">Step</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="kt">Step</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Bool</span><span class="w"></span>
<span class="w">  </span><span class="n">go</span><span class="w"> </span><span class="kt">[]</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">True</span><span class="w"></span>
<span class="w">  </span><span class="n">go</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span><span class="w"> </span><span class="n">previous</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="n">checkStep</span><span class="w"> </span><span class="n">previous</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">go</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="p">(</span><span class="n">previous</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="p">]))</span><span class="w"></span>


<span class="c1">-- Example</span><span class="w"></span>

<span class="c1">-- |- p -&gt; p</span><span class="w"></span>

<span class="nf">ex_1</span><span class="w"> </span><span class="ow">=</span><span class="w"></span>
<span class="w">  </span><span class="kr">let</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Pred</span><span class="w"> </span><span class="s">"P"</span><span class="w"> </span><span class="kt">[]</span><span class="w"> </span><span class="kr">in</span><span class="w"></span>
<span class="w">  </span><span class="kr">let</span><span class="w"> </span><span class="n">s0</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">((</span><span class="n">p</span><span class="w"> </span><span class="p">`</span><span class="kt">Imp</span><span class="p">`</span><span class="w"> </span><span class="p">((</span><span class="n">p</span><span class="w"> </span><span class="p">`</span><span class="kt">Imp</span><span class="p">`</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="p">`</span><span class="kt">Imp</span><span class="p">`</span><span class="w"> </span><span class="n">p</span><span class="p">))</span><span class="w"> </span><span class="p">`</span><span class="kt">Imp</span><span class="p">`</span><span class="w"> </span><span class="p">((</span><span class="n">p</span><span class="w"> </span><span class="p">`</span><span class="kt">Imp</span><span class="p">`</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="w"> </span><span class="p">`</span><span class="kt">Imp</span><span class="p">`</span><span class="w"> </span><span class="n">p</span><span class="p">))</span><span class="w"> </span><span class="p">`</span><span class="kt">Imp</span><span class="p">`</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="w"> </span><span class="p">`</span><span class="kt">Imp</span><span class="p">`</span><span class="w"> </span><span class="n">p</span><span class="p">)),</span><span class="w"> </span><span class="kt">Prop_2</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="w"> </span><span class="p">`</span><span class="kt">Imp</span><span class="p">`</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="kr">in</span><span class="w"></span>
<span class="w">  </span><span class="kr">let</span><span class="w"> </span><span class="n">s1</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="w"> </span><span class="p">`</span><span class="kt">Imp</span><span class="p">`</span><span class="w"> </span><span class="p">((</span><span class="n">p</span><span class="w"> </span><span class="p">`</span><span class="kt">Imp</span><span class="p">`</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="p">`</span><span class="kt">Imp</span><span class="p">`</span><span class="w"> </span><span class="n">p</span><span class="p">),</span><span class="w"> </span><span class="kt">Prop_1</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="w"> </span><span class="p">`</span><span class="kt">Imp</span><span class="p">`</span><span class="w"> </span><span class="n">p</span><span class="p">))</span><span class="w"> </span><span class="kr">in</span><span class="w"></span>
<span class="w">  </span><span class="kr">let</span><span class="w"> </span><span class="n">s2</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">((</span><span class="n">p</span><span class="w"> </span><span class="p">`</span><span class="kt">Imp</span><span class="p">`</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="w"> </span><span class="p">`</span><span class="kt">Imp</span><span class="p">`</span><span class="w"> </span><span class="n">p</span><span class="p">))</span><span class="w"> </span><span class="p">`</span><span class="kt">Imp</span><span class="p">`</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="w"> </span><span class="p">`</span><span class="kt">Imp</span><span class="p">`</span><span class="w"> </span><span class="n">p</span><span class="p">),</span><span class="w"> </span><span class="kt">MP</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="kr">in</span><span class="w"></span>
<span class="w">  </span><span class="kr">let</span><span class="w"> </span><span class="n">s3</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="w"> </span><span class="p">`</span><span class="kt">Imp</span><span class="p">`</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="w"> </span><span class="p">`</span><span class="kt">Imp</span><span class="p">`</span><span class="w"> </span><span class="n">p</span><span class="p">),</span><span class="w"> </span><span class="kt">Prop_1</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="kr">in</span><span class="w"></span>
<span class="w">  </span><span class="kr">let</span><span class="w"> </span><span class="n">s4</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="w"> </span><span class="p">`</span><span class="kt">Imp</span><span class="p">`</span><span class="w"> </span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="kt">MP</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="kr">in</span><span class="w"></span>
<span class="w">  </span><span class="n">checkAll</span><span class="w"> </span><span class="p">[</span><span class="n">s0</span><span class="p">,</span><span class="w"> </span><span class="n">s1</span><span class="p">,</span><span class="w"> </span><span class="n">s2</span><span class="p">,</span><span class="w"> </span><span class="n">s3</span><span class="p">,</span><span class="w"> </span><span class="n">s4</span><span class="p">]</span><span class="w"></span>
</code></pre></div>



<a name="269858977"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269858977" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Trebor Huang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269858977">(Jan 29 2022 at 11:47)</a>:</h4>
<p>Looks good.</p>
<p>But here's one thing where type theory is superior to usual FOL: In type theory, <code>let</code> and <code>have</code> are essentially the same thing except for syntactic differences. In FOL they have to be different: <code>let</code> for terms and <code>have</code> for proofs.</p>



<a name="269875167"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269875167" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269875167">(Jan 29 2022 at 16:53)</a>:</h4>
<p>Great! Thank you!<br>
I think MetaMath has the user prove that each term and formula is valid? I'm not sure how their use in the proof is then checked.</p>



<a name="269878785"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269878785" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269878785">(Jan 29 2022 at 18:00)</a>:</h4>
<p><span class="user-mention silent" data-user-id="139442">Patrick Thomas</span> <a href="#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/269849090">said</a>:</p>
<blockquote>
<p>Are <code>have</code> statements needed because my checker processes a proof as a tree, and in a tree you have to repeat the entirety of subproofs if you use them more than once? For example, would <code>have</code> statements no longer be needed if instead my checker processed the proof as a sequence of labelled steps, and the inference rules just used the labels to refer to previously checked steps?</p>
</blockquote>
<p>Yes, that's correct. The same thing applies to terms, and here you gain the additional advantage that if every term is only constructed once then equality checking becomes O(1)</p>



<a name="269878934"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269878934" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269878934">(Jan 29 2022 at 18:02)</a>:</h4>
<p><span class="user-mention silent" data-user-id="139442">Patrick Thomas</span> <a href="#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/269760278">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/269530905">said</a>:</p>
<blockquote>
<p>It does, but now you have the issue that you have to recheck subformulas many times. The usual way to fix this is to add some explicit DAG-like structure to your proof terms, so that if a subproof or subformula appears in two places it only has to be validated once.</p>
</blockquote>
<p>When you say the usual way, what do you mean? What references or examples do you draw from?</p>
</blockquote>
<p>Besides my experience with poking around in different proof assistants, almost everything I've talked about in this thread has been incorporated as part of <a href="https://github.com/digama0/mm0">MM0</a>, including the term deduplication trick I just mentioned. When you put it all together it has a really dramatic effect on performance</p>



<a name="269879052"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269879052" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269879052">(Jan 29 2022 at 18:04)</a>:</h4>
<p><span class="user-mention silent" data-user-id="139442">Patrick Thomas</span> <a href="#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/269786219">said</a>:</p>
<blockquote>
<p>So a global context is common to all proofs? I guess I'm having trouble understanding what would constitute separate proofs, because in order to use one proof in another you have to check the "external" proof when you encounter a reference to it in another proof?</p>
</blockquote>
<p>The global context should include also a list of checked proofs, which can then be referenced as part of new proofs. Both metamath and lean work like that.</p>



<a name="269879679"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269879679" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269879679">(Jan 29 2022 at 18:17)</a>:</h4>
<p>I know a few proof assistants that lack this "two level hierarchy", but they seem to be in the minority. In many of the HOLs, including HOL light, there is no explicit two-level thing; instead every theorem stands on its own and you "name" a theorem by assigning it to an OCaml variable. I think this was later found to be a bad idea, because it means you can't just enumerate over the theorems that exist like lean's <code>environment.fold</code>, nor can you get their user-provided names, which is problematic for, say, a proof exporter.</p>
<p>Lean does not have any context management keywords at the "global" level, unlike Zhanrong's language. I think these are avoided because they require you to keep the list of statements in a stack, which makes lookups more expensive, and if popping an assumption changes the type of statements then it can be expensive. I think Isabelle and Coq both have a module system, which amounts to hypotheses at the global level that can be discharged later, but I believe the scope checking entails walking all the theorems in the scope and I have heard rumors of long running <code>Qed.</code> statements, which is a baffling experience for users since it is weird that closing a scope should be expensive.  Lean 3 has <code>parameter</code> which tries to simulate this behavior, but it isn't really type changing the theorems, it only makes them appear to have a different type inside the scope.</p>



<a name="269880084"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269880084" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269880084">(Jan 29 2022 at 18:25)</a>:</h4>
<p><span class="user-mention silent" data-user-id="139442">Patrick Thomas</span> <a href="#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/269875167">said</a>:</p>
<blockquote>
<p>Great! Thank you!<br>
I think MetaMath has the user prove that each term and formula is valid? I'm not sure how their use in the proof is then checked.</p>
</blockquote>
<p>Every theorem comes with assumptions about each variable appearing in the theorem. So for example modus ponens which looks like <code>|- P  &amp; |- (P -&gt; Q)  =&gt;  |- Q</code> actually has four assumptions: <code>wff P</code>, <code>wff Q</code>, <code>|- P</code>and <code>|- (P -&gt; Q)</code>. So when you apply this theorem you make substitutions in for <code>P</code> and <code>Q</code>, say <code>T.</code> and <code>x = x</code>, and then you would have subproofs for <code>wff T.</code>, <code>wff x = x</code>, <code>|- T.</code> and <code>|- (T -&gt; x = x)</code>. The <code>wff T.</code> proof is showing that <code>T.</code> is a well formed formula.</p>



<a name="269882914"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269882914" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269882914">(Jan 29 2022 at 19:18)</a>:</h4>
<p>Thank you!<br>
Do you mean that you have additional steps, where each is an assertion that a term or formula is well formed with a justification potentially referring to previous steps for why that assertion holds, and when for example you need to pass a proof of p and q being well formed to mp, then you just pass the step label that asserts that p is well formed and the step label that asserts that q is well formed? So mp just takes four step labels? Do you interleave these steps with the steps for the axioms and inference rules, and add the justifications for being well formed to the list of justifications for the axioms and inference rules, or do you keep them separate and check all of the assertions of being well formed first?</p>



<a name="269883215"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269883215" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269883215">(Jan 29 2022 at 19:24)</a>:</h4>
<p>Why incidentally is it that mp requires proofs of p and q being well formed, and not p and p -&gt; q?</p>



<a name="269884064"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269884064" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269884064">(Jan 29 2022 at 19:41)</a>:</h4>
<p>The well formedness steps are interleaved with the rest in the overall proof, but for each individual theorem all the well-formedness assumptions (called "floating hypotheses" or <code>$f</code> in metamath) precede the regular assumptions ("essential hypotheses" or <code>$e</code> in metamath) to that theorem.</p>



<a name="269884230"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269884230" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269884230">(Jan 29 2022 at 19:45)</a>:</h4>
<p><span class="user-mention silent" data-user-id="139442">Patrick Thomas</span> <a href="#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/269883215">said</a>:</p>
<blockquote>
<p>Why incidentally is it that mp requires proofs of p and q being well formed, and not p and p -&gt; q?</p>
</blockquote>
<p>The <code>$f</code> hypotheses to a theorem are calculated automatically, by collecting all the variables that appear in the <code>$e</code> hypotheses and the theorem statement. This is somewhat analogous to what would happen in lean if you had <code>variables p q r s t : Prop</code> at the top of the file and then state <code>theorem mp (min : p) (maj : p -&gt; q) : q := ...</code>, you will get four actual pis in the theorem statement, <code>(p q : Prop) (min : p) (maj : p -&gt; q)</code>. You don't need an assumption that <code>p -&gt; q</code> is well formed because the theorem itself has the context to see that if <code>p</code> and <code>q</code> are well formed then so is  <code>p -&gt; q</code>, so even after substituting <code>p</code> and <code>q</code> we know it is well formed</p>



<a name="269884332"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269884332" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269884332">(Jan 29 2022 at 19:47)</a>:</h4>
<p>Note that in metamath proof assertions and well formedness assertions are on the same footing - <code>wff p</code> and <code>|- p</code> are just two different statements that can be proved</p>



<a name="269884650"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269884650" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269884650">(Jan 29 2022 at 19:53)</a>:</h4>
<p>I think I see. So<code>mp</code> in my implementation would still take four step labels, one for the assertion of <code>wff p</code>, one for <code>wff q</code>, one for<code> |- p</code> and one for <code>|- p -&gt; q</code>? And the code for <code>mp</code> looks at the assertions at those step labels and checks that everything matches up?</p>



<a name="269885078"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269885078" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269885078">(Jan 29 2022 at 19:58)</a>:</h4>
<p>What makes a formula (or term?) well formed? That each occurring predicate and function is in the definitions table, and that each subformula (and subterm?) is well formed?</p>



<a name="269885482"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269885482" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269885482">(Jan 29 2022 at 20:04)</a>:</h4>
<p>Do you have justifications like <code>AndWff Int Int</code>, where the first <code>Int</code> is the label of a step that asserts that the left subformula of the <code>/\</code> is well formed and the second is the label of a step that asserts that the right subformula is well formed?</p>



<a name="269885966"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269885966" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269885966">(Jan 29 2022 at 20:13)</a>:</h4>
<p>Yes. Each term constructor is introduced by an axiom that looks like <code>wff (p -&gt; q)</code>, which like other theorems inherits the assumptions <code>wff p</code> and <code>wff q</code></p>



<a name="269886096"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269886096" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269886096">(Jan 29 2022 at 20:15)</a>:</h4>
<p><span class="user-mention silent" data-user-id="139442">Patrick Thomas</span> <a href="#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/269885078">said</a>:</p>
<blockquote>
<p>What makes a formula (or term?) well formed? That each occurring predicate and function is in the definitions table, and that each subformula (and subterm?) is well formed?</p>
</blockquote>
<p>In metamath, saying that a formula is well formed is the same as asserting the provability of <code>wff fmla</code>, in a context where you have wff hypotheses for every variable and have access to the syntax axioms like <code>wff p &amp; wff q =&gt; wff (p -&gt; q)</code></p>



<a name="269886179"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269886179" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269886179">(Jan 29 2022 at 20:17)</a>:</h4>
<p>the distinction between formulas and terms is done here by having multiple constants that can appear in the first position: <code>wff p</code> vs <code>class A</code></p>



<a name="269886200"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269886200" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269886200">(Jan 29 2022 at 20:17)</a>:</h4>
<p>each metamath database defines its set of valid sorts, it's not a closed list known to the verifier</p>



<a name="269886205"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269886205" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269886205">(Jan 29 2022 at 20:17)</a>:</h4>
<p>same thing for the syntax axioms</p>



<a name="269886352"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269886352" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269886352">(Jan 29 2022 at 20:20)</a>:</h4>
<p>As a result, the <code>Justification</code> grammar in metamath looks closer to this:</p>
<div class="codehilite" data-code-language="Haskell"><pre><span></span><code><span class="kr">data</span><span class="w"> </span><span class="kt">Justification</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">ApplyThm</span><span class="w"> </span><span class="kt">String</span><span class="w"> </span><span class="p">[</span><span class="kt">Justification</span><span class="p">]</span><span class="w"></span>
</code></pre></div>



<a name="269886434"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269886434" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269886434">(Jan 29 2022 at 20:21)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/269886179">said</a>:</p>
<blockquote>
<p>the distinction between formulas and terms is done here by having multiple constants that can appear in the first position: <code>wff p</code> vs <code>class A</code></p>
</blockquote>
<p>When you say term and formula here are you referring to what corresponds to <code>Term</code> and <code>Formula</code> in my implementation?</p>



<a name="269886453"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269886453" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269886453">(Jan 29 2022 at 20:22)</a>:</h4>
<p>yes</p>



<a name="269886497"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269886497" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269886497">(Jan 29 2022 at 20:22)</a>:</h4>
<p>those aren't metamath concepts per se</p>



<a name="269886538"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269886538" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269886538">(Jan 29 2022 at 20:23)</a>:</h4>
<p>but if you are doing FOL-ish things you will probably have something similar to terms and formulas, and in <a href="http://set.mm">set.mm</a> that's <code>wff</code> and <code>class</code></p>



<a name="269886561"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269886561" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269886561">(Jan 29 2022 at 20:23)</a>:</h4>
<p>Oh, class as in class variable?</p>



<a name="269886573"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269886573" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269886573">(Jan 29 2022 at 20:23)</a>:</h4>
<p><code>class</code> is actually more like second order terms, but it is used for both</p>



<a name="269886581"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269886581" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269886581">(Jan 29 2022 at 20:23)</a>:</h4>
<p>yes, it means ZFC class expression</p>



<a name="269886636"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269886636" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269886636">(Jan 29 2022 at 20:24)</a>:</h4>
<p>there is also <code>setvar</code> but this is only for set variables, as the name implies, not expressions</p>



<a name="269886855"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269886855" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269886855">(Jan 29 2022 at 20:28)</a>:</h4>
<p>Hmm. Thank you. I will try and see if I can extend what I have with what I think I understand.</p>



<a name="269893994"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269893994" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269893994">(Jan 29 2022 at 22:53)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/269884230">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="139442">Patrick Thomas</span> <a href="#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/269883215">said</a>:</p>
<blockquote>
<p>Why incidentally is it that mp requires proofs of p and q being well formed, and not p and p -&gt; q?</p>
</blockquote>
<p>The <code>$f</code> hypotheses to a theorem are calculated automatically, by collecting all the variables that appear in the <code>$e</code> hypotheses and the theorem statement. This is somewhat analogous to what would happen in lean if you had <code>variables p q r s t : Prop</code> at the top of the file and then state <code>theorem mp (min : p) (maj : p -&gt; q) : q := ...</code>, you will get four actual pis in the theorem statement, <code>(p q : Prop) (min : p) (maj : p -&gt; q)</code>. You don't need an assumption that <code>p -&gt; q</code> is well formed because the theorem itself has the context to see that if <code>p</code> and <code>q</code> are well formed then so is  <code>p -&gt; q</code>, so even after substituting <code>p</code> and <code>q</code> we know it is well formed</p>
</blockquote>
<p>For the formulas passed to the axiom schemes, are you just checking that each formula passed is well formed? For example, passing <code>p -&gt; q</code> and <code>q -&gt; r</code> to the parameters <code>p</code> and <code>q</code> of <code>prop_1</code>, do they provide proofs that <code>p -&gt; q</code> and <code>q -&gt; r</code> are well formed, or that <code>p</code>, <code>q</code> and <code>r</code> are well formed? In the latter case, you would need to accept a variable number of proofs for wff and try to match them up?</p>



<a name="269894068"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269894068" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269894068">(Jan 29 2022 at 22:54)</a>:</h4>
<p>the latter. There is one wff proof per variable appearing in the formula</p>



<a name="269894085"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269894085" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269894085">(Jan 29 2022 at 22:54)</a>:</h4>
<p>and they come in the same order as the variable declaration</p>



<a name="269894162"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269894162" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269894162">(Jan 29 2022 at 22:56)</a>:</h4>
<p>So if the passed parameters were <code>a -&gt; (c -&gt; d)</code> and <code>c -&gt; b</code> they would pass wff proofs in the order for <code>a, c, d, b</code>?</p>



<a name="269894172"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269894172" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269894172">(Jan 29 2022 at 22:56)</a>:</h4>
<p>no, they would be in the order <code>a,b,c,d</code></p>



<a name="269894182"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269894182" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269894182">(Jan 29 2022 at 22:56)</a>:</h4>
<p>because that's the order they were defined at the top of the file</p>



<a name="269894196"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269894196" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269894196">(Jan 29 2022 at 22:57)</a>:</h4>
<p>pretty sure. It's mostly handled behind the scenes by the authoring tool, the user doesn't generally have to see it</p>



<a name="269894265"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269894265" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269894265">(Jan 29 2022 at 22:58)</a>:</h4>
<p>Hmm, that seems like it complicates my implementation, or I'm not sure how to handle it well.</p>



<a name="269894339"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269894339" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269894339">(Jan 29 2022 at 23:00)</a>:</h4>
<p>Do I lose anything by requiring wff proofs for what is passed exactly instead?</p>



<a name="269894503"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269894503" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269894503">(Jan 29 2022 at 23:03)</a>:</h4>
<p>Suppose you want to prove <code>a -&gt; b</code> and <code>b -&gt; c</code> implies <code>a -&gt; c</code>. You need to know more than that <code>a -&gt; b</code> and <code>b -&gt; c</code> are well formed, you need <code>a</code> and <code>b</code> to be well formed to apply lemmas that recombine these variables in different ways</p>



<a name="269894593"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269894593" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269894593">(Jan 29 2022 at 23:04)</a>:</h4>
<p>The automatic variable construction in metamath is a front end thing. Behind the scenes it probably makes more sense to assume the list of variables is provided in some order and you just check that all the hypotheses use variables in that list</p>



<a name="269894700"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269894700" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269894700">(Jan 29 2022 at 23:07)</a>:</h4>
<p>When you say a variable in a hypothesis, are talking about subformulas or actually variables of the form <code>Var x</code>? What level do you break each formula down to that the user has to provide wff proofs for?</p>



<a name="269894807"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269894807" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269894807">(Jan 29 2022 at 23:09)</a>:</h4>
<p>Are we taking definitions into account here also, in that predicates and functions have to be defined in order to be considered well formed?</p>



<a name="269894817"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269894817" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269894817">(Jan 29 2022 at 23:10)</a>:</h4>
<p>I mean variables</p>



<a name="269894867"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269894867" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269894867">(Jan 29 2022 at 23:10)</a>:</h4>
<p>you don't have to unfold definitions, it is syntactically obvious what the variables in an expression are</p>



<a name="269894891"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269894891" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269894891">(Jan 29 2022 at 23:11)</a>:</h4>
<p>isn't a variable well formed by definition? Why do we need to check that it is well formed?</p>



<a name="269894895"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269894895" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269894895">(Jan 29 2022 at 23:11)</a>:</h4>
<p>For an expression to be well formed you have to be able to prove it is well formed. That proof uses syntax axioms, and you get one of those for every definition</p>



<a name="269894962"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269894962" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269894962">(Jan 29 2022 at 23:12)</a>:</h4>
<p>In this setting variables are not well formed by definition, well formedness means that the variable is among the list of variables permitted to appear in the statement</p>



<a name="269894977"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269894977" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269894977">(Jan 29 2022 at 23:13)</a>:</h4>
<p>in the metamath approach this is true by construction, but if you are given a list of variables separately then you have to check it</p>



<a name="269894994"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269894994" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269894994">(Jan 29 2022 at 23:13)</a>:</h4>
<p>Oh, but metamath is at a lower level then what I am doing right. In my implementation you can only construct wff, provided that the predicates and functions are defined?</p>



<a name="269894995"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269894995" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269894995">(Jan 29 2022 at 23:13)</a>:</h4>
<p>or if the variables are numbered then you are checking that the numbers are less than the length of the list</p>



<a name="269895048"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269895048" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269895048">(Jan 29 2022 at 23:14)</a>:</h4>
<p>Because they are constrained by the constructors of <code>Term</code> and <code>Formula</code>?</p>



<a name="269895059"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269895059" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269895059">(Jan 29 2022 at 23:14)</a>:</h4>
<p>Well, your prover still isn't dealing with applying one theorem in another context (with substitution for the variables)</p>



<a name="269895084"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269895084" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269895084">(Jan 29 2022 at 23:15)</a>:</h4>
<p>the situation to avoid is that the substitution does not cover one of the variables appearing in the statement of the theorem</p>



<a name="269895098"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269895098" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269895098">(Jan 29 2022 at 23:16)</a>:</h4>
<p>You mean accidental bindings?</p>



<a name="269895168"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269895168" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269895168">(Jan 29 2022 at 23:17)</a>:</h4>
<p>The only context I have is the global context of definitions and proofs previously checked right?</p>



<a name="269895172"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269895172" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269895172">(Jan 29 2022 at 23:17)</a>:</h4>
<p>like if you have <code>syl: (a -&gt; b) =&gt; (b -&gt; c) =&gt; (a -&gt; c)</code> and you say "apply <code>syl</code> with <code>a := 2 + 2</code>" and don't say anything about <code>b</code></p>



<a name="269895264"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269895264" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269895264">(Jan 29 2022 at 23:19)</a>:</h4>
<p>the metamath approach is to first gather up the variables in <code>syl</code> in order to get <code>a,b,c</code>, and then when you apply it you have to give 3 things <code>x,y,z</code> and then given two more things <code>x -&gt; y</code> and <code>y -&gt; z</code> you get <code>x -&gt; z</code>. If the gathering of variables wasn't done correctly and, say, omitted <code>c</code>, then the downstream use would not substitute for it and you would get a scope error where <code>c</code> appears in the present theorem without any hypothesis about it</p>



<a name="269895317"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269895317" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269895317">(Jan 29 2022 at 23:20)</a>:</h4>
<p>or you would just get a crash when you look up <code>c</code> in some map</p>



<a name="269895379"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269895379" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269895379">(Jan 29 2022 at 23:22)</a>:</h4>
<p><span class="user-mention silent" data-user-id="139442">Patrick Thomas</span> <a href="#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/269895168">said</a>:</p>
<blockquote>
<p>The only context I have is the global context of definitions and proofs previously checked right?</p>
</blockquote>
<p>I mean another local context, i.e. you are proving an unrelated theorem from the one to be applied</p>



<a name="269895550"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269895550" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269895550">(Jan 29 2022 at 23:25)</a>:</h4>
<p>So we are talking about when I have more than one proof, and proofs take hypothesis?</p>



<a name="269895616"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269895616" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269895616">(Jan 29 2022 at 23:26)</a>:</h4>
<p>I guess I'm confused, because I don't declare a list of variables at the beginning?</p>



<a name="269895643"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269895643" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269895643">(Jan 29 2022 at 23:27)</a>:</h4>
<p>I mean, in this Hilbert system there are no hypothesis right?</p>



<a name="269895713"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269895713" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269895713">(Jan 29 2022 at 23:28)</a>:</h4>
<p>So this would be an issue only if I allowed for them, say moved to natural deduction?</p>



<a name="269895890"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269895890" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269895890">(Jan 29 2022 at 23:33)</a>:</h4>
<p>Sure, you can have them all exist a priori (as long as you only have one type, which is already not quite true since you have formulas and terms), but then you have to decide what to do about substitution in a theorem</p>



<a name="269895945"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269895945" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269895945">(Jan 29 2022 at 23:34)</a>:</h4>
<p>like, I want to be able to prove <code>syl</code> once (using the axioms) and use it later without having to replay the axioms</p>



<a name="269896149"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269896149" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269896149">(Jan 29 2022 at 23:39)</a>:</h4>
<p>I'm sorry, I'm not sure I am following. If I want to prove something, I need to declare what variables are allowed to appear in the proof?</p>



<a name="269896203"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269896203" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269896203">(Jan 29 2022 at 23:40)</a>:</h4>
<p>in metamath, yes</p>



<a name="269896206"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269896206" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269896206">(Jan 29 2022 at 23:40)</a>:</h4>
<p>in lean, yes as well</p>



<a name="269896211"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269896211" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269896211">(Jan 29 2022 at 23:40)</a>:</h4>
<p>Sorry, why is that again?</p>



<a name="269896223"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269896223" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269896223">(Jan 29 2022 at 23:41)</a>:</h4>
<p>you can't just use random variables that haven't been declared, because variables come with type information and a random letter has unknown type</p>



<a name="269896276"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269896276" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269896276">(Jan 29 2022 at 23:42)</a>:</h4>
<p>In HOL you can kind of get away with this by having a constructor of the form <code>Var String Type</code></p>



<a name="269896300"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269896300" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269896300">(Jan 29 2022 at 23:43)</a>:</h4>
<p>but it's still dicey because you can have variables <code>a: A</code> and <code>a: B</code> and they should be treated as different (even after substituting <code>B := A</code>!)</p>



<a name="269896308"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269896308" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269896308">(Jan 29 2022 at 23:43)</a>:</h4>
<p>I didn't think FOL had types? I thought there was just one big domain of discourse?</p>



<a name="269896355"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269896355" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269896355">(Jan 29 2022 at 23:44)</a>:</h4>
<p>What about wff vs term?</p>



<a name="269896449"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269896449" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269896449">(Jan 29 2022 at 23:46)</a>:</h4>
<p>Oh. So like the p and q in the prop_1 scheme are variables of type formula and the t in the eq_refl scheme is a variable of type term?</p>



<a name="269896454"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269896454" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269896454">(Jan 29 2022 at 23:46)</a>:</h4>
<p>right</p>



<a name="269896464"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269896464" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269896464">(Jan 29 2022 at 23:47)</a>:</h4>
<p>If you don't do this, you won't be able to substitute in <code>syl</code>, which is a pretty big hit for a hilbert system</p>



<a name="269896474"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269896474" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269896474">(Jan 29 2022 at 23:47)</a>:</h4>
<p>that is, without the ability to prove propositional theorems you can't build up a toolbox of useful theorems like <code>and.left</code></p>



<a name="269896536"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269896536" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269896536">(Jan 29 2022 at 23:48)</a>:</h4>
<p>In natural deduction it is not quite as bad because the axioms are a little closer to practice, but there are still plenty of useful propositional lemmas that aren't god given like <code>and_assoc</code></p>



<a name="269896542"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269896542" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269896542">(Jan 29 2022 at 23:49)</a>:</h4>
<p>Would you call these something like proof schemes?</p>



<a name="269896545"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269896545" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269896545">(Jan 29 2022 at 23:49)</a>:</h4>
<p>yes</p>



<a name="269896553"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269896553" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269896553">(Jan 29 2022 at 23:49)</a>:</h4>
<p>in metamath everything is a scheme, it's a logic of schemes being deduced from other schemes</p>



<a name="269896597"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269896597" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269896597">(Jan 29 2022 at 23:50)</a>:</h4>
<p>which is why variable distinctness is a primitive notion</p>



<a name="269896608"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269896608" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269896608">(Jan 29 2022 at 23:50)</a>:</h4>
<p>That is, you are proving proof schemes, and when the user goes to use it they need to know what kind of variables to substitute in for which parameters?</p>



<a name="269896628"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269896628" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269896628">(Jan 29 2022 at 23:51)</a>:</h4>
<p>Like in the proof of p -&gt; p I would declare p to be a formula variable.</p>



<a name="269896630"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269896630" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269896630">(Jan 29 2022 at 23:51)</a>:</h4>
<p>exactly</p>



<a name="269896730"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269896730" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269896730">(Jan 29 2022 at 23:53)</a>:</h4>
<p>So when the user passes an expression in for p, you have to break it done into all of the variables and then make sure that they recombine to form a formula?</p>



<a name="269896805"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269896805" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269896805">(Jan 29 2022 at 23:55)</a>:</h4>
<p>Because p has been declared to be a formula variable in the proof?</p>



<a name="269896806"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269896806" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269896806">(Jan 29 2022 at 23:55)</a>:</h4>
<p>well, they have to pass a formula for p</p>



<a name="269896816"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269896816" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269896816">(Jan 29 2022 at 23:55)</a>:</h4>
<p>so previously they had to have constructed that formula, with all the attendant checks</p>



<a name="269896891"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269896891" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269896891">(Jan 29 2022 at 23:57)</a>:</h4>
<p>that is, you have a formula <code>foo</code> which has already been validated and you put it in as <code>p := foo</code> in <code>id : p -&gt; p</code>, which is done by traversing the expression <code>p -&gt; p</code> and replacing occurrences of <code>p</code> with <code>foo</code></p>



<a name="269896907"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269896907" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269896907">(Jan 29 2022 at 23:57)</a>:</h4>
<p>and that replacement doesn't have to validate anything, because <code>p -&gt; p</code> is a valid formula and <code>foo</code> is a valid formula so <code>foo -&gt; foo</code> is also valid</p>



<a name="269896997"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269896997" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269896997">(Jan 29 2022 at 23:59)</a>:</h4>
<p>So you would have a justification like, declared as term variable and a justification like declared as formula variable?</p>



<a name="269897163"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269897163" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269897163">(Jan 30 2022 at 00:01)</a>:</h4>
<p>But you also have a third type of variable, the one occurring as <code>Var String</code> in term, which I guess is an object variable?</p>



<a name="269897225"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269897225" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269897225">(Jan 30 2022 at 00:02)</a>:</h4>
<p>And the term and formula ones are meta variables? or schema variables?</p>



<a name="269897259"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269897259" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269897259">(Jan 30 2022 at 00:03)</a>:</h4>
<p>I think you can unify term variables and term metavariables in that scheme</p>



<a name="269898023"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269898023" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269898023">(Jan 30 2022 at 00:22)</a>:</h4>
<p>I'm sorry, I'm still not quite clear what I am checking if a formula is passed to an axiom scheme. I know it is a formula because they had to check it before hand right? In the check for that step of the proof, do I still need to gather all the variables that occur in the passed formulas and check that they are declared? Declared where? Wasn't that already done when it was checked that it was a formula?</p>



<a name="269898153"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269898153" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269898153">(Jan 30 2022 at 00:24)</a>:</h4>
<p>For reference, I am taking about what I need to check for example in the <code>checkStep _ (assertion, Prop_1 p q)</code> case of this code:<br>
<a href="/user_uploads/3121/XGL0C-xqJv8LziFuEjWxxxl8/Hilbert_Linear.hs">Hilbert_Linear.hs</a></p>



<a name="269898261"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269898261" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269898261">(Jan 30 2022 at 00:27)</a>:</h4>
<p>We are saying that the user has already checked that what is passed in for <code>p</code> and <code>q</code> are formulas right? But we also need to break these apart to determine that all of the variables occurring in the formulas that were passed are declared somewhere? Isn't that done when they verified they were formulas?</p>



<a name="269898595"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269898595" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269898595">(Jan 30 2022 at 00:34)</a>:</h4>
<p>Or is this not for the axiom schemes in my implementation, but for the proof schemes?</p>



<a name="269898625"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269898625" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269898625">(Jan 30 2022 at 00:35)</a>:</h4>
<p>Because in the axiom schemes for my implementation what needs to be passed in is already explicit.</p>



<a name="269899922"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269899922" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269899922">(Jan 30 2022 at 01:01)</a>:</h4>
<p>So should I rename my data definition for <code>Term</code> to <code>TermScheme</code> and add a constructor that takes the name of a term scheme variable, and change the definition of <code>Formula</code> to <code>FormulaScheme</code> and add a constructor that takes the name of a formula scheme variable? So each axiom scheme takes formula schemes and term schemes and returns proof schemes?</p>



<a name="269900020"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269900020" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269900020">(Jan 30 2022 at 01:03)</a>:</h4>
<p>Or would I even have data definitions for any kind of term, term scheme, formula or formula scheme?</p>



<a name="269900774"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269900774" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269900774">(Jan 30 2022 at 01:18)</a>:</h4>
<p>Like, how far off was I here:<br>
<a href="/user_uploads/3121/n43o4mVTbpysIksQ-W-PVeF9/Hilbert_Linear_2.hs">Hilbert_Linear_2.hs</a></p>



<a name="269900796"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269900796" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269900796">(Jan 30 2022 at 01:19)</a>:</h4>
<p><span class="user-mention silent" data-user-id="139442">Patrick Thomas</span> <a href="#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/269898153">said</a>:</p>
<blockquote>
<p>For reference, I am taking about what I need to check for example in the <code>checkStep _ (assertion, Prop_1 p q)</code> case of this code:<br>
<a href="/user_uploads/3121/XGL0C-xqJv8LziFuEjWxxxl8/Hilbert_Linear.hs">Hilbert_Linear.hs</a></p>
</blockquote>
<p>In addition to what you already have, you need to check that <code>p</code> and <code>q</code> are valid formulas, or else you should have <code>Int</code>s passed in and refer to some already checked formulas in the local context</p>



<a name="269900816"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269900816" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269900816">(Jan 30 2022 at 01:20)</a>:</h4>
<p>Like in the code I just added?</p>



<a name="269900966"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269900966" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269900966">(Jan 30 2022 at 01:22)</a>:</h4>
<p>I would modify that code to remove the <code>Formula</code> from <code>FormulaStep</code>, and instead have the type of checked steps be different from the input</p>



<a name="269901144"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269901144" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269901144">(Jan 30 2022 at 01:26)</a>:</h4>
<p>Sorry, why is that? And why only for FormulaStep?</p>



<a name="269901165"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269901165" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269901165">(Jan 30 2022 at 01:27)</a>:</h4>
<p>Or do you mean have only one kind of step?</p>



<a name="269901251"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269901251" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269901251">(Jan 30 2022 at 01:28)</a>:</h4>
<p>Instead of ProofStep, FormulaStep and TermStep just have Step?</p>



<a name="269901262"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269901262" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269901262">(Jan 30 2022 at 01:28)</a>:</h4>
<p>yes, that</p>



<a name="269901268"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269901268" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269901268">(Jan 30 2022 at 01:29)</a>:</h4>
<p>1 sec, example coming up</p>



<a name="269901727"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269901727" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269901727">(Jan 30 2022 at 01:38)</a>:</h4>
<div class="codehilite" data-code-language="Haskell"><pre><span></span><code><span class="kr">data</span><span class="w"> </span><span class="kt">Term</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Var</span><span class="w"> </span><span class="kt">String</span><span class="w"></span>
<span class="w">  </span><span class="kr">deriving</span><span class="w"> </span><span class="p">(</span><span class="kt">Show</span><span class="p">,</span><span class="w"> </span><span class="kt">Eq</span><span class="p">)</span><span class="w"></span>
<span class="kr">data</span><span class="w"> </span><span class="kt">Formula</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Imp</span><span class="w"> </span><span class="kt">Formula</span><span class="w"> </span><span class="kt">Formula</span><span class="w"></span>
<span class="w">  </span><span class="kr">deriving</span><span class="w"> </span><span class="p">(</span><span class="kt">Show</span><span class="p">,</span><span class="w"> </span><span class="kt">Eq</span><span class="p">)</span><span class="w"></span>
<span class="kr">data</span><span class="w"> </span><span class="kt">Proof</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Proof</span><span class="w"> </span><span class="kt">Formula</span><span class="w"></span>

<span class="kr">data</span><span class="w"> </span><span class="kt">Step</span><span class="w"></span>
<span class="w">  </span><span class="ow">=</span><span class="w"> </span><span class="kt">IsVar</span><span class="w"> </span><span class="kt">String</span><span class="w"></span>
<span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="kt">IsImp</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>
<span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="kt">MP</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>
<span class="w">  </span><span class="kr">deriving</span><span class="w"> </span><span class="p">(</span><span class="kt">Show</span><span class="p">,</span><span class="w"> </span><span class="kt">Eq</span><span class="p">)</span><span class="w"></span>

<span class="kr">type</span><span class="w"> </span><span class="kt">LocalContext</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">([</span><span class="kt">Term</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="kt">Formula</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="kt">Proof</span><span class="p">])</span><span class="w"></span>

<span class="nf">pushTerm</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">LocalContext</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Term</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">LocalContext</span><span class="w"></span>
<span class="nf">pushTerm</span><span class="w"> </span><span class="p">(</span><span class="n">ts</span><span class="p">,</span><span class="w"> </span><span class="n">fs</span><span class="p">,</span><span class="w"> </span><span class="n">ps</span><span class="p">)</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="n">ts</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="p">[</span><span class="n">t</span><span class="p">],</span><span class="w"> </span><span class="n">fs</span><span class="p">,</span><span class="w"> </span><span class="n">ps</span><span class="p">)</span><span class="w"></span>
<span class="nf">getTerm</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">LocalContext</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Term</span><span class="w"></span>
<span class="nf">getTerm</span><span class="w"> </span><span class="p">(</span><span class="n">ts</span><span class="p">,</span><span class="w"> </span><span class="kr">_</span><span class="p">,</span><span class="w"> </span><span class="kr">_</span><span class="p">)</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">ts</span><span class="w"> </span><span class="o">!!</span><span class="w"> </span><span class="n">i</span><span class="w"></span>

<span class="nf">pushFormula</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">LocalContext</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Formula</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">LocalContext</span><span class="w"></span>
<span class="nf">pushFormula</span><span class="w"> </span><span class="p">(</span><span class="n">ts</span><span class="p">,</span><span class="w"> </span><span class="n">fs</span><span class="p">,</span><span class="w"> </span><span class="n">ps</span><span class="p">)</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="n">ts</span><span class="p">,</span><span class="w"> </span><span class="n">fs</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="p">[</span><span class="n">f</span><span class="p">],</span><span class="w"> </span><span class="n">ps</span><span class="p">)</span><span class="w"></span>
<span class="nf">getFormula</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">LocalContext</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Formula</span><span class="w"></span>
<span class="nf">getFormula</span><span class="w"> </span><span class="p">(</span><span class="kr">_</span><span class="p">,</span><span class="w"> </span><span class="n">fs</span><span class="p">,</span><span class="w"> </span><span class="kr">_</span><span class="p">)</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">fs</span><span class="w"> </span><span class="o">!!</span><span class="w"> </span><span class="n">i</span><span class="w"></span>

<span class="nf">pushProof</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">LocalContext</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Proof</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">LocalContext</span><span class="w"></span>
<span class="nf">pushProof</span><span class="w"> </span><span class="p">(</span><span class="n">ts</span><span class="p">,</span><span class="w"> </span><span class="n">fs</span><span class="p">,</span><span class="w"> </span><span class="n">ps</span><span class="p">)</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="n">ts</span><span class="p">,</span><span class="w"> </span><span class="n">fs</span><span class="p">,</span><span class="w"> </span><span class="n">ps</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="p">[</span><span class="n">p</span><span class="p">])</span><span class="w"></span>
<span class="nf">getProof</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">LocalContext</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Proof</span><span class="w"></span>
<span class="nf">getProof</span><span class="w"> </span><span class="p">(</span><span class="kr">_</span><span class="p">,</span><span class="w"> </span><span class="n">fs</span><span class="p">,</span><span class="w"> </span><span class="kr">_</span><span class="p">)</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">fs</span><span class="w"> </span><span class="o">!!</span><span class="w"> </span><span class="n">i</span><span class="w"></span>

<span class="nf">checkStep</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">LocalContext</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Step</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">LocalContext</span><span class="w"></span>
<span class="nf">checkStep</span><span class="w"> </span><span class="n">ctx</span><span class="w"> </span><span class="p">(</span><span class="kt">IsVar</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">pushTerm</span><span class="w"> </span><span class="n">ctx</span><span class="w"> </span><span class="p">(</span><span class="kt">Var</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"></span>
<span class="nf">checkStep</span><span class="w"> </span><span class="n">ctx</span><span class="w"> </span><span class="p">(</span><span class="kt">IsImp</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">g</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">pushFormula</span><span class="w"> </span><span class="n">ctx</span><span class="w"> </span><span class="p">(</span><span class="kt">Imp</span><span class="w"> </span><span class="p">(</span><span class="n">getFormula</span><span class="w"> </span><span class="n">ctx</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">getFormula</span><span class="w"> </span><span class="n">ctx</span><span class="w"> </span><span class="n">g</span><span class="p">))</span><span class="w"></span>
<span class="nf">checkStep</span><span class="w"> </span><span class="n">ctx</span><span class="w"> </span><span class="p">(</span><span class="kt">MP</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="n">h1</span><span class="w"> </span><span class="n">h2</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"></span>
<span class="w">  </span><span class="kr">let</span><span class="w"> </span><span class="kt">Proof</span><span class="w"> </span><span class="n">p'</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">getProof</span><span class="w"> </span><span class="n">ctx</span><span class="w"> </span><span class="n">h1</span><span class="w"> </span><span class="kr">in</span><span class="w"></span>
<span class="w">  </span><span class="kr">let</span><span class="w"> </span><span class="kt">Proof</span><span class="w"> </span><span class="p">(</span><span class="kt">Imp</span><span class="w"> </span><span class="n">p''</span><span class="w"> </span><span class="n">q'</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">getProof</span><span class="w"> </span><span class="n">ctx</span><span class="w"> </span><span class="n">h2</span><span class="w"> </span><span class="kr">in</span><span class="w"></span>
<span class="w">  </span><span class="kr">if</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">p'</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">p''</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">q'</span><span class="w"> </span><span class="kr">then</span><span class="w"></span>
<span class="w">    </span><span class="n">pushProof</span><span class="w"> </span><span class="n">ctx</span><span class="w"> </span><span class="p">(</span><span class="kt">Proof</span><span class="w"> </span><span class="n">q</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="kr">else</span><span class="w"> </span><span class="ne">error</span><span class="w"> </span><span class="s">"MP"</span><span class="w"></span>

<span class="nf">checkSteps</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="kt">Step</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Proof</span><span class="w"></span>
<span class="nf">checkSteps</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">go</span><span class="w"> </span><span class="p">(</span><span class="kt">[]</span><span class="p">,</span><span class="w"> </span><span class="kt">[]</span><span class="p">,</span><span class="w"> </span><span class="kt">[]</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="n">go</span><span class="w"> </span><span class="p">(</span><span class="kr">_</span><span class="p">,</span><span class="w"> </span><span class="kr">_</span><span class="p">,</span><span class="w"> </span><span class="n">ps</span><span class="p">)</span><span class="w"> </span><span class="kt">[]</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">last</span><span class="w"> </span><span class="n">ps</span><span class="w"></span>
<span class="w">  </span><span class="n">go</span><span class="w"> </span><span class="n">ctx</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="kt">:</span><span class="n">ss</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">go</span><span class="w"> </span><span class="n">ss</span><span class="w"> </span><span class="p">(</span><span class="n">checkStep</span><span class="w"> </span><span class="n">ctx</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w"></span>
</code></pre></div>



<a name="269902373"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269902373" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269902373">(Jan 30 2022 at 01:51)</a>:</h4>
<p>Very cool! Thank you!<br>
Would I also need steps for adding term scheme variables, and formula scheme variables?</p>



<a name="269902374"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269902374" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269902374">(Jan 30 2022 at 01:51)</a>:</h4>
<p>And an example use (imagine that <code>Prop_1</code> and <code>Prop_2</code> are defined similarly):</p>
<div class="codehilite" data-code-language="Haskell"><pre><span></span><code><span class="nf">ex_1</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">checkSteps</span><span class="w"> </span><span class="p">[</span><span class="w"></span>
<span class="w">  </span><span class="kt">IsPred</span><span class="w"> </span><span class="s">"P"</span><span class="w"> </span><span class="kt">[]</span><span class="p">,</span><span class="w"> </span><span class="c1">-- f0 = p</span><span class="w"></span>
<span class="w">  </span><span class="kt">IsImp</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="c1">-- f1 = p -&gt; p</span><span class="w"></span>
<span class="w">  </span><span class="kt">IsImp</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="c1">-- f2 = (p -&gt; p) -&gt; p</span><span class="w"></span>
<span class="w">  </span><span class="kt">IsImp</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="c1">-- f3 = p -&gt; ((p -&gt; p) -&gt; p)</span><span class="w"></span>
<span class="w">  </span><span class="kt">IsImp</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="c1">-- f4 = p -&gt; (p -&gt; p)</span><span class="w"></span>
<span class="w">  </span><span class="kt">IsImp</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="c1">-- f5 = (p -&gt; (p -&gt; p)) -&gt; (p -&gt; p)</span><span class="w"></span>
<span class="w">  </span><span class="kt">IsImp</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="c1">-- f6 = (p -&gt; ((p -&gt; p) -&gt; p)) -&gt; ((p -&gt; (p -&gt; p)) -&gt; (p -&gt; p))</span><span class="w"></span>
<span class="w">  </span><span class="kt">Prop_2</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="c1">-- p0 = |- (p -&gt; ((p -&gt; p) -&gt; p)) -&gt; ((p -&gt; (p -&gt; p)) -&gt; (p -&gt; p))</span><span class="w"></span>
<span class="w">  </span><span class="kt">Prop_1</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="c1">-- p1 = |- p -&gt; ((p -&gt; p) -&gt; p)</span><span class="w"></span>
<span class="w">  </span><span class="kt">MP</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="c1">-- p2 = |- (p -&gt; (p -&gt; p)) -&gt; (p -&gt; p)</span><span class="w"></span>
<span class="w">  </span><span class="kt">Prop_1</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="c1">-- p3 = |- p -&gt; (p -&gt; p)</span><span class="w"></span>
<span class="w">  </span><span class="kt">MP</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="c1">-- p4 = |- p -&gt; p</span><span class="w"></span>
<span class="p">]</span><span class="w"></span>
</code></pre></div>
<p>Probably you want to assert that this is a proof of <code>p -&gt; p</code> at the end</p>



<a name="269902448"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269902448" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269902448">(Jan 30 2022 at 01:52)</a>:</h4>
<p>You already have term and formula variables via the <code>Pred</code> and <code>Var</code> constructors</p>



<a name="269902454"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269902454" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269902454">(Jan 30 2022 at 01:52)</a>:</h4>
<p>you just need a mechanism to substitute into them</p>



<a name="269902540"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269902540" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269902540">(Jan 30 2022 at 01:54)</a>:</h4>
<p>I see. That mechanism being two more <code>Step</code> constructors?</p>



<a name="269903509"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269903509" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269903509">(Jan 30 2022 at 02:14)</a>:</h4>
<p>Something like this:</p>
<div class="codehilite" data-code-language="Haskell"><pre><span></span><code><span class="kr">data</span><span class="w"> </span><span class="kt">Term</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Var</span><span class="w"> </span><span class="kt">String</span><span class="w"></span>
<span class="w">  </span><span class="kr">deriving</span><span class="w"> </span><span class="p">(</span><span class="kt">Show</span><span class="p">,</span><span class="w"> </span><span class="kt">Eq</span><span class="p">)</span><span class="w"></span>
<span class="kr">data</span><span class="w"> </span><span class="kt">Formula</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Imp</span><span class="w"> </span><span class="kt">Formula</span><span class="w"> </span><span class="kt">Formula</span><span class="w"></span>
<span class="w">  </span><span class="kr">deriving</span><span class="w"> </span><span class="p">(</span><span class="kt">Show</span><span class="p">,</span><span class="w"> </span><span class="kt">Eq</span><span class="p">)</span><span class="w"></span>
<span class="kr">data</span><span class="w"> </span><span class="kt">Proof</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Proof</span><span class="w"> </span><span class="kt">Formula</span><span class="w"></span>

<span class="kr">data</span><span class="w"> </span><span class="kt">Step</span><span class="w"></span>
<span class="w">  </span><span class="ow">=</span><span class="w"> </span><span class="kt">IsVar</span><span class="w"> </span><span class="kt">String</span><span class="w"></span>
<span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="kt">IsImp</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>
<span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="kt">ApplyThm</span><span class="w"> </span><span class="kt">String</span><span class="w"> </span><span class="p">(</span><span class="kt">M</span><span class="o">.</span><span class="kt">Map</span><span class="w"> </span><span class="kt">String</span><span class="w"> </span><span class="kt">Int</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="kt">M</span><span class="o">.</span><span class="kt">Map</span><span class="w"> </span><span class="kt">String</span><span class="w"> </span><span class="p">([</span><span class="kt">String</span><span class="p">],</span><span class="w"> </span><span class="kt">Int</span><span class="p">))</span><span class="w"> </span><span class="p">[</span><span class="kt">Int</span><span class="p">]</span><span class="w"></span>
<span class="w">  </span><span class="kr">deriving</span><span class="w"> </span><span class="p">(</span><span class="kt">Show</span><span class="p">,</span><span class="w"> </span><span class="kt">Eq</span><span class="p">)</span><span class="w"></span>

<span class="kr">type</span><span class="w"> </span><span class="kt">LocalContext</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">([</span><span class="kt">Term</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="kt">Formula</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="kt">Proof</span><span class="p">])</span><span class="w"></span>
<span class="kr">type</span><span class="w"> </span><span class="kt">GlobalContext</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">M</span><span class="o">.</span><span class="kt">Map</span><span class="w"> </span><span class="kt">String</span><span class="w"> </span><span class="p">([</span><span class="kt">Proof</span><span class="p">],</span><span class="w"> </span><span class="kt">Proof</span><span class="p">)</span><span class="w"></span>

<span class="nf">substTerm</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">M</span><span class="o">.</span><span class="kt">Map</span><span class="w"> </span><span class="kt">String</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Term</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Term</span><span class="w"></span>
<span class="nf">substTerm</span><span class="w"> </span><span class="n">ts</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">go</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="n">go</span><span class="w"> </span><span class="p">(</span><span class="kt">Var</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">ts</span><span class="w"> </span><span class="kt">M</span><span class="o">.!</span><span class="w"> </span><span class="n">v</span><span class="w"></span>

<span class="nf">substFormula</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">LocalContext</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">M</span><span class="o">.</span><span class="kt">Map</span><span class="w"> </span><span class="kt">String</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">M</span><span class="o">.</span><span class="kt">Map</span><span class="w"> </span><span class="kt">String</span><span class="w"> </span><span class="p">([</span><span class="kt">String</span><span class="p">],</span><span class="w"> </span><span class="kt">Int</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Formula</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Formula</span><span class="w"></span>
<span class="nf">substFormula</span><span class="w"> </span><span class="n">ctx</span><span class="w"> </span><span class="n">ts</span><span class="w"> </span><span class="n">fs</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">go</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="n">go</span><span class="w"> </span><span class="p">(</span><span class="kt">Imp</span><span class="w"> </span><span class="n">f1</span><span class="w"> </span><span class="n">f2</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Imp</span><span class="w"> </span><span class="p">(</span><span class="n">go</span><span class="w"> </span><span class="n">f1</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">go</span><span class="w"> </span><span class="n">f2</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="n">go</span><span class="w"> </span><span class="p">(</span><span class="kt">Pred</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"></span>
<span class="w">    </span><span class="kr">let</span><span class="w"> </span><span class="p">(</span><span class="n">vs</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">fs</span><span class="w"> </span><span class="kt">M</span><span class="o">.!</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="kr">in</span><span class="w"></span>
<span class="w">    </span><span class="kr">let</span><span class="w"> </span><span class="n">args'</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">go</span><span class="w"> </span><span class="o">&lt;$&gt;</span><span class="w"> </span><span class="n">args</span><span class="w"> </span><span class="kr">in</span><span class="w"></span>
<span class="w">    </span><span class="kr">if</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="n">args'</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="n">vs</span><span class="w"> </span><span class="kr">then</span><span class="w"></span>
<span class="w">      </span><span class="n">substFormula</span><span class="w"> </span><span class="n">ctx</span><span class="w"> </span><span class="p">(</span><span class="kt">M</span><span class="o">.</span><span class="n">fromList</span><span class="w"> </span><span class="p">(</span><span class="n">zip</span><span class="w"> </span><span class="n">vs</span><span class="w"> </span><span class="n">args'</span><span class="p">))</span><span class="w"> </span><span class="kt">[]</span><span class="w"> </span><span class="p">(</span><span class="n">getFormula</span><span class="w"> </span><span class="n">ctx</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kr">else</span><span class="w"> </span><span class="ne">error</span><span class="w"> </span><span class="s">"subst"</span><span class="w"></span>

<span class="nf">substProof</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">LocalContext</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">M</span><span class="o">.</span><span class="kt">Map</span><span class="w"> </span><span class="kt">String</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">M</span><span class="o">.</span><span class="kt">Map</span><span class="w"> </span><span class="kt">String</span><span class="w"> </span><span class="p">([</span><span class="kt">String</span><span class="p">],</span><span class="w"> </span><span class="kt">Int</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Proof</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Proof</span><span class="w"></span>
<span class="nf">substProof</span><span class="w"> </span><span class="n">ctx</span><span class="w"> </span><span class="n">ts</span><span class="w"> </span><span class="n">fs</span><span class="w"> </span><span class="p">(</span><span class="kt">Proof</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Proof</span><span class="w"> </span><span class="p">(</span><span class="n">substFormula</span><span class="w"> </span><span class="n">ctx</span><span class="w"> </span><span class="n">ts</span><span class="w"> </span><span class="n">fs</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="w"></span>

<span class="nf">checkStep</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">GlobalContext</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">LocalContext</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Step</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">LocalContext</span><span class="w"></span>
<span class="nf">checkStep</span><span class="w"> </span><span class="n">gctx</span><span class="w"> </span><span class="n">ctx</span><span class="w"> </span><span class="p">(</span><span class="kt">ApplyThm</span><span class="w"> </span><span class="n">th</span><span class="w"> </span><span class="n">ts</span><span class="w"> </span><span class="n">fs</span><span class="w"> </span><span class="n">ps</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"></span>
<span class="w">  </span><span class="kr">let</span><span class="w"> </span><span class="p">(</span><span class="n">hs</span><span class="p">,</span><span class="w"> </span><span class="n">concl</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">gctx</span><span class="w"> </span><span class="kt">M</span><span class="o">.!</span><span class="w"> </span><span class="n">th</span><span class="w"> </span><span class="kr">in</span><span class="w"></span>
<span class="w">  </span><span class="kr">let</span><span class="w"> </span><span class="n">hs'</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">substProof</span><span class="w"> </span><span class="n">lctx</span><span class="w"> </span><span class="n">ts</span><span class="w"> </span><span class="n">fs</span><span class="w"> </span><span class="o">&lt;$&gt;</span><span class="w"> </span><span class="n">hs</span><span class="w"> </span><span class="kr">in</span><span class="w"></span>
<span class="w">  </span><span class="kr">let</span><span class="w"> </span><span class="n">concl'</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">substProof</span><span class="w"> </span><span class="n">lctx</span><span class="w"> </span><span class="n">ts</span><span class="w"> </span><span class="n">fs</span><span class="w"> </span><span class="n">concl</span><span class="w"> </span><span class="kr">in</span><span class="w"></span>
<span class="w">  </span><span class="kr">if</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="n">hs'</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="n">ps</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"></span>
<span class="w">    </span><span class="n">all</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="p">(</span><span class="n">h</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kr">let</span><span class="w"> </span><span class="kt">Proof</span><span class="w"> </span><span class="n">h'</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">ctx</span><span class="w"> </span><span class="o">!!</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">h'</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">zip</span><span class="w"> </span><span class="n">hs'</span><span class="w"> </span><span class="n">ps</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="kr">then</span><span class="w"> </span><span class="n">pushProof</span><span class="w"> </span><span class="n">ctx</span><span class="w"> </span><span class="n">concl'</span><span class="w"></span>
<span class="w">  </span><span class="kr">else</span><span class="w"> </span><span class="ne">error</span><span class="w"> </span><span class="s">"ApplyThm"</span><span class="w"></span>
</code></pre></div>



<a name="269903636"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269903636" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269903636">(Jan 30 2022 at 02:17)</a>:</h4>
<p>Notice that you can eliminate <code>Prop_1</code> and <code>MP</code> constructors from <code>Step</code> with this, by pre-seeding the <code>GlobalContext</code> with</p>
<div class="codehilite" data-code-language="Haskell"><pre><span></span><code><span class="nf">initialContext</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">M</span><span class="o">.</span><span class="n">fromList</span><span class="w"> </span><span class="p">[</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="s">"MP"</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">Proof</span><span class="w"> </span><span class="p">[</span><span class="kt">Pred</span><span class="w"> </span><span class="s">"P"</span><span class="w"> </span><span class="kt">[]</span><span class="p">,</span><span class="w"> </span><span class="kt">Imp</span><span class="w"> </span><span class="p">(</span><span class="kt">Pred</span><span class="w"> </span><span class="s">"P"</span><span class="w"> </span><span class="kt">[]</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="kt">Pred</span><span class="w"> </span><span class="s">"Q"</span><span class="w"> </span><span class="kt">[]</span><span class="p">)],</span><span class="w"> </span><span class="kt">Pred</span><span class="w"> </span><span class="s">"Q"</span><span class="w"> </span><span class="kt">[]</span><span class="p">)),</span><span class="w"></span>
<span class="w"> </span><span class="o">...</span><span class="w"></span>
<span class="p">]</span><span class="w"></span>
</code></pre></div>



<a name="269904201"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269904201" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269904201">(Jan 30 2022 at 02:29)</a>:</h4>
<p>Sorry, what do the constructor arguments to <code>ApplyThm</code> represent? The name of a theorem, and ?</p>



<a name="269904622"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269904622" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269904622">(Jan 30 2022 at 02:39)</a>:</h4>
<p>The name of the theorem, the substitutions for term variables, the substitutions for predicate variables, and the list of hypotheses</p>



<a name="269904785"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269904785" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269904785">(Jan 30 2022 at 02:42)</a>:</h4>
<p>Since you aren't tracking what variables appear in a theorem or ordering them when they go into the global context, these have to be given as maps from string. For predicate variables, the substitution is basically a lambda, since we might want to substitute for a predicate variable which has nonzero arity, and we need a secondary <code>substFormula</code> call to substitute into the lambda</p>



<a name="269905202"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269905202" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269905202">(Jan 30 2022 at 02:50)</a>:</h4>
<p>In the substitutions for predicate variables <code>M.Map String ([String], Int)</code> the first string is the name of a predicate being substituted into, and sorry, what are the list of strings and int? The names of the variables in the predicate to substitute in for? The arity?</p>



<a name="269905666"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269905666" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269905666">(Jan 30 2022 at 03:00)</a>:</h4>
<p>I'm guessing we need to check for accidental variable binding in all of these substitutions if this gets extended to predicate calculus?</p>



<a name="269905806"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269905806" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269905806">(Jan 30 2022 at 03:03)</a>:</h4>
<p>I'm wondering if there is a missing call to <code>substTerm</code> or if it is implicit somewhere?</p>



<a name="269906025"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269906025" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269906025">(Jan 30 2022 at 03:08)</a>:</h4>
<p><span class="user-mention silent" data-user-id="139442">Patrick Thomas</span> <a href="#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/269905202">said</a>:</p>
<blockquote>
<p>In the substitutions for predicate variables <code>M.Map String ([String], Int)</code> the first string is the name of a predicate being substituted into, and sorry, what are the list of strings and int? The names of the variables in the predicate to substitute in for? The arity?</p>
</blockquote>
<p>The list of strings are the lambda binders, and the int is a previously constructed formula from the local context. For example we might set <code>P := \x y z -&gt; x + y = z</code></p>



<a name="269906051"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269906051" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269906051">(Jan 30 2022 at 03:09)</a>:</h4>
<p>and then we would turn an occurrence like <code>P(1, 2, 3)</code> into <code>1 + 2 = 3</code></p>



<a name="269906127"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269906127" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269906127">(Jan 30 2022 at 03:10)</a>:</h4>
<p><code>substTerm</code> doesn't appear in the constructors I've shown, but it would appear in the <code>Pred</code> case, for example</p>



<a name="269906143"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269906143" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269906143">(Jan 30 2022 at 03:11)</a>:</h4>
<p>er... I guess I did that one</p>



<a name="269906166"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269906166" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269906166">(Jan 30 2022 at 03:12)</a>:</h4>
<p>yeah this probably doesn't typecheck, we should be using <code>let args' = substTerm ts &lt;$&gt; args</code> instead of <code>let args' = go &lt;$&gt; args</code></p>



<a name="269906542"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269906542" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269906542">(Jan 30 2022 at 03:20)</a>:</h4>
<p>I'll have to think more about what substituting for a predicate name means. I can see when the arity is zero, that it is just replacing it by a formula, like in the axiom schemes, but I'm not sure what it means when the arity is greater than zero.<br>
I have a prior engagement to attend to, but thank you so much. This is really cool!</p>



<a name="269910626"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269910626" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269910626">(Jan 30 2022 at 04:59)</a>:</h4>
<p>So if you have a predicate such as such as <code>Pred "P" []</code> in the proof scheme that you are substituting into,  then you can replace it with any formula with no free variables right? What can you do when you have something like  <code>Pred "P" [Func "f" [Var "x"], Var "y"]</code>? Replace it with any formula that has the same number of free variables?</p>



<a name="269910870"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269910870" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269910870">(Jan 30 2022 at 05:02)</a>:</h4>
<p>Or no, maybe just replace each free variable with any term?</p>



<a name="269912987"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269912987" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269912987">(Jan 30 2022 at 05:51)</a>:</h4>
<p>No, you can replace it with formulas with free variables, the variables just have to not get captured so there is some "free for t in x" side condition</p>



<a name="269913010"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269913010" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269913010">(Jan 30 2022 at 05:52)</a>:</h4>
<p>I haven't thought about the details but if you draw examples of the bad case it shouldn't be too hard to figure out</p>



<a name="269913077"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269913077" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269913077">(Jan 30 2022 at 05:53)</a>:</h4>
<p>You could replace <code>x = y</code> with <code>x &lt; y</code>?</p>



<a name="269913143"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269913143" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269913143">(Jan 30 2022 at 05:54)</a>:</h4>
<p>Oh, or where you talking about the first sentence.</p>



<a name="269913271"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269913271" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269913271">(Jan 30 2022 at 05:58)</a>:</h4>
<p>For example, replacing <code>forall x, P(x, y)</code> with <code>P(z, w) := x &lt; z</code> is bad because <code>x</code> will get captured</p>



<a name="269913301"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269913301" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269913301">(Jan 30 2022 at 05:59)</a>:</h4>
<p>So you can replace any predicate of arity 0 with any formula, given the side conditions on name capture? What can you do for arity &gt; 0?</p>



<a name="269913306"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269913306" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269913306">(Jan 30 2022 at 05:59)</a>:</h4>
<p>that example is a predicate of arity 2</p>



<a name="269913452"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269913452" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269913452">(Jan 30 2022 at 06:01)</a>:</h4>
<p>Metamath has the ability to manually rename binders because they are subject to substitution. If you are treating them as binders, then you probably want to just alpha-rename the binder automatically instead of restricting the substitution</p>



<a name="269913510"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269913510" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269913510">(Jan 30 2022 at 06:02)</a>:</h4>
<p>so that example would result in <code>forall x', x &lt; x'</code></p>



<a name="269913734"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269913734" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269913734">(Jan 30 2022 at 06:09)</a>:</h4>
<p>I'm sorry, I got a little lost. I guess I am just trying to understand what can be substituted in for a predicate of arity 0 (a propositional variable) and what can be substituted in for a predicate of arity &gt; 0.</p>



<a name="269913796"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269913796" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269913796">(Jan 30 2022 at 06:10)</a>:</h4>
<p>For the arity 0 special case, you can substitute any formula expression whose free variables are not bound in the context where the variable appears. So in <code>P -&gt; forall x. P</code>, you can substitute any expression for <code>P</code> not containing a free <code>x</code></p>



<a name="269913822"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269913822" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269913822">(Jan 30 2022 at 06:11)</a>:</h4>
<p>or in the alpha-renaming version, you can substitute any expression for <code>P</code>, but if <code>P</code> contains a free <code>x</code> then the <code>x</code> binder will be renamed to <code>x'</code> or something else not free in <code>P</code></p>



<a name="269913956"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269913956" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269913956">(Jan 30 2022 at 06:14)</a>:</h4>
<p>In the second sentence are you still talking about the special case of arity = 0? Because then P wouldn't have a free x right?</p>



<a name="269913967"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269913967" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269913967">(Jan 30 2022 at 06:15)</a>:</h4>
<p>I am</p>



<a name="269913977"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269913977" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269913977">(Jan 30 2022 at 06:15)</a>:</h4>
<p>In the second version we lift the restriction on <code>P</code>, so you can put anything in for it</p>



<a name="269913986"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269913986" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269913986">(Jan 30 2022 at 06:15)</a>:</h4>
<p>instead of restricting the substitution, we sometimes rename the binder to avoid clashes</p>



<a name="269914007"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269914007" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269914007">(Jan 30 2022 at 06:16)</a>:</h4>
<p>in the first version we just reject if we would otherwise have to rename a binder</p>



<a name="269914013"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269914013" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269914013">(Jan 30 2022 at 06:16)</a>:</h4>
<p>I don't understand how P can have arity = 0 and have a free x. Wouldn't it have at least an arity of 1?</p>



<a name="269914020"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269914020" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269914020">(Jan 30 2022 at 06:16)</a>:</h4>
<p>for example <code>P := 0 &lt; x</code></p>



<a name="269914036"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269914036" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269914036">(Jan 30 2022 at 06:17)</a>:</h4>
<p>The arity of <code>P</code> is determined by its use in the original theorem, here <code>P -&gt; forall x. P</code></p>



<a name="269914044"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269914044" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269914044">(Jan 30 2022 at 06:17)</a>:</h4>
<p>we're allowed to use an expression with free variables</p>



<a name="269914049"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269914049" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269914049">(Jan 30 2022 at 06:17)</a>:</h4>
<p>we might want to derive <code>0 &lt; x -&gt; forall x'. 0 &lt; x</code> here</p>



<a name="269914107"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269914107" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269914107">(Jan 30 2022 at 06:18)</a>:</h4>
<p>We would use a nonzero arity when the theorem in question uses the predicate at multiple values, for example <code>forall x. P(x) -&gt; P(t)</code></p>



<a name="269914182"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269914182" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269914182">(Jan 30 2022 at 06:20)</a>:</h4>
<p>In this case, <code>P(y) := 0 &lt; x</code> would require renaming the binder (and results in <code>forall x'. 0 &lt; x -&gt; 0 &lt; x</code>), but <code>P(x) := 0 &lt; x</code> is okay and does not rename the binder, resulting in <code>forall x. 0 &lt; x -&gt; 0 &lt; t</code>. This is how you get deliberately captured variables</p>



<a name="269914392"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269914392" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269914392">(Jan 30 2022 at 06:25)</a>:</h4>
<p>Wait, so what does P(x) mean? Is it the same as Pred "P" [Var "x"]?</p>



<a name="269914523"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269914523" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269914523">(Jan 30 2022 at 06:28)</a>:</h4>
<p>It seems not? The "x" in P(x) is some kind of binder?</p>



<a name="269914554"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269914554" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269914554">(Jan 30 2022 at 06:29)</a>:</h4>
<p>In formulas, <code>P(t)</code> refers to <code>Pred "P" [t]</code> (where <code>t</code> is any term). When I write <code>P(x) := e</code>, I mean that the substitution map contains <code>"P" -&gt; (["x"], e)</code></p>



<a name="269914637"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269914637" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269914637">(Jan 30 2022 at 06:31)</a>:</h4>
<p>well, technically <code>"P" -&gt; (["x"], i)</code> where <code>getFormula ctx i = e</code></p>



<a name="269914784"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269914784" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269914784">(Jan 30 2022 at 06:35)</a>:</h4>
<p><code>"P" -&gt; (["x"], e)</code> means we are replacing the variable <code>x</code> by <code>e</code> in <code>P</code>?</p>



<a name="269914815"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269914815" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269914815">(Jan 30 2022 at 06:36)</a>:</h4>
<p>Sorry, maybe it is easier to talk about outside of the code, which I am still trying to understand.</p>



<a name="269914862"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269914862" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269914862">(Jan 30 2022 at 06:36)</a>:</h4>
<p>It means we are replacing <code>P(x)</code> by <code>e</code>, and more generally <code>P(t)</code> by <code>e[t/x]</code></p>



<a name="269914958"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269914958" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269914958">(Jan 30 2022 at 06:39)</a>:</h4>
<p>perhaps you should study the code and come back with more pointed questions. (I don't guarantee the code is correct - I wrote it without actually compiling it so there are probably several errors)</p>



<a name="269915027"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269915027" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269915027">(Jan 30 2022 at 06:40)</a>:</h4>
<p>Ok, sorry. I'll see if I can put together what I think it would look like for just the propositional calculus, and then see what needs to change to extend it to the predicate calculus, if that makes sense?</p>



<a name="269915085"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269915085" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269915085">(Jan 30 2022 at 06:42)</a>:</h4>
<p>Thank you.</p>



<a name="269915114"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269915114" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269915114">(Jan 30 2022 at 06:43)</a>:</h4>
<p>Probably not tonight though. Have a good evening, or day depending on your time zone.</p>



<a name="269979126"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269979126" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269979126">(Jan 31 2022 at 04:36)</a>:</h4>
<p>Does this look correct for the propositional calculus case? Do the comments reflect a correct understanding? Thank you.<br>
<a href="/user_uploads/3121/aojQ7h71kfhMZm_ZuH5y40IT/Hilbert_Prop.hs">Hilbert_Prop.hs</a></p>



<a name="269979230"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269979230" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269979230">(Jan 31 2022 at 04:38)</a>:</h4>
<p>Sorry, the comment for <code>GlobalContext</code> should be changed to</p>
<div class="codehilite" data-code-language="Haskell"><pre><span></span><code><span class="cm">{-</span>
<span class="cm">Monotonic.</span>
<span class="cm">A mapping of names to previously checked derivations.</span>
<span class="cm">name -&gt; (ps, p) :</span>
<span class="cm">name : The name of a previously checked derivation.</span>
<span class="cm">ps : The list of proof schemes in the previously checked derivation.</span>
<span class="cm">p : The last proof scheme in the previously checked derivation.</span>
<span class="cm">-}</span><span class="w"></span>
</code></pre></div>
<p><a href="/user_uploads/3121/CHlN-psLnsx8fqV4LkSH0knY/Hilbert_Prop.hs">Hilbert_Prop.hs</a></p>



<a name="269980076"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269980076" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269980076">(Jan 31 2022 at 04:54)</a>:</h4>
<p>It looks good. The guard <code>(Data.Map.keysSet m) == (allVar p)</code> is overly strict, it suffices to use <code>(allVar p) `subset` (Data.Map.keysSet m)</code>. Also it's possible to combine the guard and the substitution into one operation that replaces each free occurrence of a variable in <code>p</code> with the corresponding element of <code>m</code> (which will fail if it's not in the map)</p>



<a name="269980183"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269980183" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269980183">(Jan 31 2022 at 04:57)</a>:</h4>
<p>So you don't have to replace every free variable in the formula scheme? I was wondering about that.</p>



<a name="269980245"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269980245" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269980245">(Jan 31 2022 at 04:58)</a>:</h4>
<p>Or I guess I read that backwards. You do have to?</p>



<a name="269980276"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269980276" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269980276">(Jan 31 2022 at 04:59)</a>:</h4>
<p>Did you mean <code>(Data.Map.keysSet m) `subset` (allVar p)</code>?</p>



<a name="269980722"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269980722" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269980722">(Jan 31 2022 at 05:08)</a>:</h4>
<p>Nevermind, I think I see. You can have a mapping that has keys that do not appear in the formula but not vice versa. You do have to replace every free variable in the formula. I think?</p>



<a name="269981181"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269981181" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269981181">(Jan 31 2022 at 05:16)</a>:</h4>
<p>Thank you!</p>



<a name="269983035"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/269983035" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#269983035">(Jan 31 2022 at 05:51)</a>:</h4>
<p>Like this?<br>
<a href="/user_uploads/3121/rBwFaaLyk1CGpI2JdagkQ-ty/Hilbert_Prop.hs">Hilbert_Prop.hs</a></p>



<a name="270140166"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270140166" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270140166">(Feb 01 2022 at 02:09)</a>:</h4>
<p>Out of curiosity, what is the advantage to storing the intermediate proof schemes in the global context at the end of a derivation instead of just the last proof scheme in the derivation?</p>



<a name="270140676"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270140676" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270140676">(Feb 01 2022 at 02:16)</a>:</h4>
<p>I don't think I ever suggested that?</p>



<a name="270140747"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270140747" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270140747">(Feb 01 2022 at 02:18)</a>:</h4>
<p>There are some advantages of being able to build multiple proof schemes out of one "derivation pool" / local context, but they are quite niche</p>



<a name="270140965"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270140965" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270140965">(Feb 01 2022 at 02:20)</a>:</h4>
<p>I think it was in your example code maybe? <a href="#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/269903509">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/269903509</a></p>



<a name="270141102"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270141102" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270141102">(Feb 01 2022 at 02:22)</a>:</h4>
<p>that example doesn't have the <code>checkSteps</code> function. The one <a href="#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/269901727">earlier</a> does and it uses <code>last ps</code></p>



<a name="270141214"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270141214" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270141214">(Feb 01 2022 at 02:24)</a>:</h4>
<p>I see. I must have mixed together the code. Thank you.</p>



<a name="270142115"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270142115" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270142115">(Feb 01 2022 at 02:36)</a>:</h4>
<p>If I move the last code example that I posted from propositional logic to predicate logic, do I understand correctly that applying a theorem will  then require replacing each free term variable with a syntactically correct term scheme, taking into account potential free variable capture, in addition to the replacement of propositional variables (predicate variables of arity 0) that is already done in the current propositional case?</p>



<a name="270169793"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270169793" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270169793">(Feb 01 2022 at 08:41)</a>:</h4>
<p>yes</p>



<a name="270325848"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270325848" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270325848">(Feb 02 2022 at 02:53)</a>:</h4>
<p>Thank you.</p>



<a name="270326024"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270326024" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270326024">(Feb 02 2022 at 02:55)</a>:</h4>
<p>Is it correct that metamath and mm0 use named variables? If so, how is free variable capture handled? Is there a step that allows the user to explicitly alpha convert a formula scheme?</p>



<a name="270326546"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270326546" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270326546">(Feb 02 2022 at 03:02)</a>:</h4>
<p>Yes, they use named variables. You can use theorems to prove alpha conversion, there is no built in support for it</p>



<a name="270326720"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270326720" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270326720">(Feb 02 2022 at 03:05)</a>:</h4>
<p>I did not realize that was possible. What do you need to prove it, just FOL?</p>



<a name="270327482"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270327482" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270327482">(Feb 02 2022 at 03:16)</a>:</h4>
<p>It uses lemmas like <a href="http://us.metamath.org/mpeuni/cbvalv.html">http://us.metamath.org/mpeuni/cbvalv.html</a></p>



<a name="270327531"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270327531" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270327531">(Feb 02 2022 at 03:16)</a>:</h4>
<p>which follow from the FOL axiomatization</p>



<a name="270327966"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270327966" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270327966">(Feb 02 2022 at 03:23)</a>:</h4>
<p>Interesting. Is that due specifically to the axiomatization used by metamath that avoids substitution, or is that true generally?</p>



<a name="270328054"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270328054" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270328054">(Feb 02 2022 at 03:24)</a>:</h4>
<p>I guess I just expected that would have to be proved at the meta level.</p>



<a name="270328150"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270328150" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270328150">(Feb 02 2022 at 03:26)</a>:</h4>
<p>I don't think it's something special about the axiomatization: I mean it's a true theorem of FOL so as long as the axiomatization is something complete for FOL then that theorem should be provable</p>



<a name="270328180"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270328180" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270328180">(Feb 02 2022 at 03:26)</a>:</h4>
<p>The interesting observation is that it suffices to use theorems like that in lieu of built in alpha renaming</p>



<a name="270328201"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270328201" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270328201">(Feb 02 2022 at 03:27)</a>:</h4>
<p>That is cool.</p>



<a name="270328218"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270328218" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270328218">(Feb 02 2022 at 03:27)</a>:</h4>
<p>Same thing for the "not-free" predicate, which in metamath is a regular predicate defined as <code>NF(x, ph) := (∃ x, ph) → (∀ x, ph)</code></p>



<a name="270328289"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270328289" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270328289">(Feb 02 2022 at 03:28)</a>:</h4>
<p>you can use <code>NF(x, ph)</code> as a substitute for actual not-free constraints in lemmas that require it</p>



<a name="270328325"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270328325" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270328325">(Feb 02 2022 at 03:29)</a>:</h4>
<p>This is not the usual not-free predicate defined in the metalogic, because for example <code>NF(x, x = x)</code> holds, but it is "just as good" from the point of view of provable theorems</p>



<a name="270328503"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270328503" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270328503">(Feb 02 2022 at 03:32)</a>:</h4>
<p>and there are lemmas that prove <code>NF(x, ∀ x, ph)</code> and <code>NF(y, ph) -&gt; NF(y, ∀ x, ph)</code> and so on, so whenever a variable is not-free in an expression for an interesting reason (not just because it is not present in the expression), you can prove an <code>NF</code> lemma and then use a pred calc theorem that has an <code>NF</code> assumption</p>



<a name="270328668"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270328668" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270328668">(Feb 02 2022 at 03:35)</a>:</h4>
<p>Cool.</p>



<a name="270328938"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270328938" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270328938">(Feb 02 2022 at 03:39)</a>:</h4>
<p>So there are predicate calculus theorems that have the meta logic NF as a condition? How does that work without being able to do this? Wouldn't they have to jump to the level of meta theorems?</p>



<a name="270329063"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270329063" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270329063">(Feb 02 2022 at 03:41)</a>:</h4>
<p>Or are they in fact considered as meta theorems, and this allows you to move them down.</p>



<a name="270329233"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270329233" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270329233">(Feb 02 2022 at 03:43)</a>:</h4>
<p>No, there are predicate calculus theorems that have the object logic NF as a condition</p>



<a name="270329278"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270329278" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270329278">(Feb 02 2022 at 03:44)</a>:</h4>
<p>that is, the <code>NF(x, ph)</code> function I just mentioned</p>



<a name="270329306"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270329306" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270329306">(Feb 02 2022 at 03:44)</a>:</h4>
<p>for example <code>NF(x, ph) -&gt; ph -&gt; ∀ x, ph</code> is pretty easy to prove</p>



<a name="270329379"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270329379" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270329379">(Feb 02 2022 at 03:45)</a>:</h4>
<p>or <code>NF(x, ph), ph -&gt; ps |- ph -&gt; ∀ x, ps</code></p>



<a name="270329610"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270329610" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270329610">(Feb 02 2022 at 03:48)</a>:</h4>
<p>But there are also predicate calculus theorems that have the meta logic NF as a condition?</p>



<a name="270329952"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270329952" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270329952">(Feb 02 2022 at 03:54)</a>:</h4>
<p>no, at least not in metamath. Theorems that would normally have an NF condition in FOL come in two flavors in metamath: either they have a disjointness requirement (not-present rather than not-free), or they have a <code>NF</code> condition. Not-present is stricter than not-free but is handled by metamath natively so it is easy to use, while <code>NF</code> is weaker than not-free and requires a subproof</p>



<a name="270329998"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270329998" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270329998">(Feb 02 2022 at 03:55)</a>:</h4>
<p>I guess I meant in textbooks.</p>



<a name="270330081"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270330081" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270330081">(Feb 02 2022 at 03:56)</a>:</h4>
<p>I thought maybe that is what you meant by "you can use NF(x, ph) as a substitute for actual not-free constraints in lemmas that require it".</p>



<a name="270330094"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270330094" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270330094">(Feb 02 2022 at 03:56)</a>:</h4>
<p>That there are lemmas in textbooks that use the meta logic (actual) version of it.</p>



<a name="270330193"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270330193" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270330193">(Feb 02 2022 at 03:58)</a>:</h4>
<p>Right. You take the textbook lemma, using the metalevel not-free constraint, and replace all instances of it with <code>NF(x, ph)</code></p>



<a name="270330203"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270330203" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270330203">(Feb 02 2022 at 03:58)</a>:</h4>
<p>and that gives you a theorem that can be stated and proved in metamath</p>



<a name="270330379"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270330379" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270330379">(Feb 02 2022 at 03:59)</a>:</h4>
<p>Do the textbooks identify these as meta lemmas when they state them?</p>



<a name="270330492"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270330492" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270330492">(Feb 02 2022 at 04:00)</a>:</h4>
<p>In the textbooks these are all theorem schemes, since they usually have wff metavariables in them</p>



<a name="270330714"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270330714" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270330714">(Feb 02 2022 at 04:02)</a>:</h4>
<p>What is proved in metamath are theorem schemes too aren't they?</p>



<a name="270330860"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270330860" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270330860">(Feb 02 2022 at 04:04)</a>:</h4>
<p>Yes, but the scheme language is more restricted, to just substitution and distinctness</p>



<a name="270330897"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270330897" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270330897">(Feb 02 2022 at 04:05)</a>:</h4>
<p>anything beyond that has to be implemented inside the target language itself</p>



<a name="270331015"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270331015" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270331015">(Feb 02 2022 at 04:07)</a>:</h4>
<p>So meta, but not as meta? :)</p>



<a name="270331131"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270331131" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270331131">(Feb 02 2022 at 04:08)</a>:</h4>
<p>the scheme language in FOL is not rigidly defined, in principle you can do whatever you like by recursion on formulas, but generally includes at least not-free, proper substitution, alpha equality, and possibly the 3-ary not-free operation "y is free for x in t"</p>



<a name="270331250"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270331250" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270331250">(Feb 02 2022 at 04:10)</a>:</h4>
<p>For a more interesting example of an operation defined by recursion on formulas consider the <a href="https://en.wikipedia.org/wiki/Double-negation_translation#First-order_logic">double negation translation</a></p>



<a name="270331751"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270331751" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270331751">(Feb 02 2022 at 04:19)</a>:</h4>
<p>And everything that holds true at the object level using the usual axiom schemes holds true using metamath's restricted axiom schemes and vice versa?</p>



<a name="270331844"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270331844" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270331844">(Feb 02 2022 at 04:21)</a>:</h4>
<p>yes</p>



<a name="270331934"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270331934" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270331934">(Feb 02 2022 at 04:22)</a>:</h4>
<p>That's pretty cool. I would be interested in the proof, although I'm not sure I would be able to understand it.</p>



<a name="270332082"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270332082" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270332082">(Feb 02 2022 at 04:24)</a>:</h4>
<p>That's different than saying that the axiom schemes from one can be derived from the other and vice versa right?</p>



<a name="270332209"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270332209" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270332209">(Feb 02 2022 at 04:26)</a>:</h4>
<p>Because they are different at the meta level, so that wouldn't make sense.</p>



<a name="270332355"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270332355" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270332355">(Feb 02 2022 at 04:28)</a>:</h4>
<p>The axiom schemes of metamath should be true interpreted as FOL schemes, this is just soundness restated. The reverse doesn't work because unrestricted FOL schemes can't necessarily be expressed in metamath</p>



<a name="270332469"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270332469" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270332469">(Feb 02 2022 at 04:30)</a>:</h4>
<p>I see. Is that reverse direction at the same meta level and same idea as the deduction theorem showing that Hilbert and ND are equivalent?</p>



<a name="270332499"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270332499" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270332499">(Feb 02 2022 at 04:31)</a>:</h4>
<p>Some FOL schemes are mapped to metamath metatheorems, which is to say that each instance of the scheme corresponds to a metamath theorem</p>



<a name="270332564"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270332564" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270332564">(Feb 02 2022 at 04:32)</a>:</h4>
<p>the deduction theorem is one of these</p>



<a name="270333043"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270333043" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270333043">(Feb 02 2022 at 04:39)</a>:</h4>
<p>This gets confusing.</p>



<a name="270333567"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270333567" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270333567">(Feb 02 2022 at 04:47)</a>:</h4>
<p>So FOL schemes and metamath meta theorems are at the same level? How do you keep this all straight :)</p>



<a name="270333686"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270333686" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270333686">(Feb 02 2022 at 04:49)</a>:</h4>
<p>Is everything eventually embedded into a single higher level metalogic?</p>



<a name="270333864"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270333864" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270333864">(Feb 02 2022 at 04:51)</a>:</h4>
<p>That is, there is a single metalogic that can describe both FOL schemes and metamath metatheorems?</p>



<a name="270334796"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270334796" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Trebor Huang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270334796">(Feb 02 2022 at 05:02)</a>:</h4>
<p>I think you shouldn't 'align' the levels of metamath and textbook FOL, that just gets confusing.</p>



<a name="270334964"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270334964" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270334964">(Feb 02 2022 at 05:05)</a>:</h4>
<p>They don't align? Don't they have to at some level in order to show that they are equivalent at the object level?</p>



<a name="270335027"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270335027" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270335027">(Feb 02 2022 at 05:06)</a>:</h4>
<p>Or at least doesn't there have to be a single meta logic that can describe them both?</p>



<a name="270335236"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270335236" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270335236">(Feb 02 2022 at 05:09)</a>:</h4>
<p>Metamath, like any formal system, has built in limits on what it can do natively. By contrast, mathematicians always dislike such restrictions and will "go meta" whenever they feel the need to. So the best you can hope for is to carve out a well defined subset of what mathematicians/logicians are doing and call it a formal system</p>



<a name="270335539"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270335539" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270335539">(Feb 02 2022 at 05:12)</a>:</h4>
<p>You can think of metamath like a traditional logic textbook written by someone who wanted to demonstrate that you can do FOL without defining not-free</p>



<a name="270335856"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270335856" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270335856">(Feb 02 2022 at 05:17)</a>:</h4>
<p>I guess that makes sense. They would still want to show that they are doing the same FOL though right?</p>



<a name="270335874"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270335874" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270335874">(Feb 02 2022 at 05:17)</a>:</h4>
<p>Hence the proofs that they are equivalent at the object level.</p>



<a name="270335960"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270335960" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270335960">(Feb 02 2022 at 05:18)</a>:</h4>
<p>well, most logic textbooks aren't too concerned with showing that they are equivalent to some other logic textbook. More important is that all the obviously true things can be derived</p>



<a name="270336118"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270336118" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270336118">(Feb 02 2022 at 05:21)</a>:</h4>
<p>I suppose that is true. I guess it would be easier if the axioms were more intuitive or obvious, which could also probably be said for the Hilbert axioms.</p>



<a name="270336257"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270336257" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270336257">(Feb 02 2022 at 05:23)</a>:</h4>
<p>I guess if you can show that they are complete and the definition of complete makes sense.</p>



<a name="270336986"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270336986" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270336986">(Feb 02 2022 at 05:34)</a>:</h4>
<p>Kind of an aside, but there is something that has always bothered me regarding meta logic. If I use a meta logic to prove that a logic is consistent (can not prove false and hence anything), how do I know that the meta logic I used is consistent? What if it is not, and I only proved that the logic is consistent because I can prove anything with the meta logic? Then don't I need a meta meta logic to prove that the meta logic is consistent and so on?</p>



<a name="270337006"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270337006" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270337006">(Feb 02 2022 at 05:34)</a>:</h4>
<p>sure that's true</p>



<a name="270337015"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270337015" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270337015">(Feb 02 2022 at 05:35)</a>:</h4>
<p>you can't really avoid that</p>



<a name="270337114"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270337114" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270337114">(Feb 02 2022 at 05:36)</a>:</h4>
<p>Any system of axioms comes with baseline assumptions. Without axioms you can't prove anything</p>



<a name="270337143"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270337143" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270337143">(Feb 02 2022 at 05:37)</a>:</h4>
<p>the best you can do is make sure the axioms are "obviously correct"</p>



<a name="270337223"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270337223" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270337223">(Feb 02 2022 at 05:38)</a>:</h4>
<p>or you can try not to engage with the question and use an off-the-shelf axiom system</p>



<a name="270337250"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270337250" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270337250">(Feb 02 2022 at 05:38)</a>:</h4>
<p>I see. Do the meta logics become increasingly simpler and more "obviously correct" the "higher" you go?</p>



<a name="270337283"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270337283" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270337283">(Feb 02 2022 at 05:39)</a>:</h4>
<p>they need not, it's up to you</p>



<a name="270337289"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270337289" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270337289">(Feb 02 2022 at 05:39)</a>:</h4>
<p>From what I have seen of the first level it appears to be about the same as the logic it is describing.</p>



<a name="270337299"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270337299" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270337299">(Feb 02 2022 at 05:40)</a>:</h4>
<p>but it is usually possible to have a PA-ish metalogic supporting an arbitrarily complicated object logic</p>



<a name="270337368"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270337368" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270337368">(Feb 02 2022 at 05:40)</a>:</h4>
<p>What does "PA-ish" mean?</p>



<a name="270337386"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270337386" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270337386">(Feb 02 2022 at 05:40)</a>:</h4>
<p>either peano arithmetic or a variation/subsystem of it</p>



<a name="270337414"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270337414" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270337414">(Feb 02 2022 at 05:41)</a>:</h4>
<p>like EFA (exponential function arithmetic) or PRA (primitive recursive arithmetic)</p>



<a name="270337469"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270337469" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270337469">(Feb 02 2022 at 05:42)</a>:</h4>
<p>if you try to make the system too weak it won't be able to support Godel's theorems</p>



<a name="270337684"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270337684" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270337684">(Feb 02 2022 at 05:45)</a>:</h4>
<p>The incompleteness theorems?</p>



<a name="270337701"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270337701" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270337701">(Feb 02 2022 at 05:45)</a>:</h4>
<p>yes</p>



<a name="270337789"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270337789" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270337789">(Feb 02 2022 at 05:47)</a>:</h4>
<p>You can run the argument with <a href="https://en.wikipedia.org/wiki/Robinson_arithmetic">Robinson's Q</a>, but since that system doesn't have induction, you need to do meta-induction to reason about it which means you have to step up another level</p>



<a name="270338057"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270338057" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270338057">(Feb 02 2022 at 05:51)</a>:</h4>
<p>The argument that it is "obviously correct"?</p>



<a name="270338135"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270338135" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270338135">(Feb 02 2022 at 05:52)</a>:</h4>
<p>it's pretty hard to argue that PA is not obviously correct</p>



<a name="270338180"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270338180" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270338180">(Feb 02 2022 at 05:53)</a>:</h4>
<p>you have to have a strange idea of what numbers are to be able to contemplate the inconsistency of PA</p>



<a name="270338278"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270338278" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270338278">(Feb 02 2022 at 05:54)</a>:</h4>
<p>I'm not sure what you meant about run the argument with Robinson's Q. Which argument?</p>



<a name="270338331"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270338331" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270338331">(Feb 02 2022 at 05:55)</a>:</h4>
<p>And why do you want to be able to support Godel's theorems?</p>



<a name="270338881"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270338881" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270338881">(Feb 02 2022 at 06:00)</a>:</h4>
<p>the argument for Godel's incompleteness theorem, which involves constructing a provability assertion inside the weak metalogic</p>



<a name="270338994"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270338994" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270338994">(Feb 02 2022 at 06:01)</a>:</h4>
<p>The systems that can prove Godel's theorems are "essentially undecidable", which is a good thing. Below that, you mostly have theories that are decidable, meaning that they can't model any interesting mathematics</p>



<a name="270339069"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270339069" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270339069">(Feb 02 2022 at 06:02)</a>:</h4>
<p>That is, a decidable theory can't be a metalogic for an undecidable theory because any question in the object logic can be reformulated as a question in the metalogic</p>



<a name="270339093"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270339093" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270339093">(Feb 02 2022 at 06:03)</a>:</h4>
<p>and since ultimately we want to do mathematics in interesting and undecidable domains, this forms a bare minimum requirement on the metalogic</p>



<a name="270339284"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270339284" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270339284">(Feb 02 2022 at 06:06)</a>:</h4>
<p>Although I should give an honorable mention to <a href="https://en.wikipedia.org/wiki/Self-verifying_theories">self-verifying theories</a>, which live somewhere below Q (usually by not validating the totality of multiplication) and satisfying <code>T |- Con(T)</code></p>



<a name="270339562"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270339562" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270339562">(Feb 02 2022 at 06:10)</a>:</h4>
<p>That makes sense.</p>



<a name="270339567"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270339567" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270339567">(Feb 02 2022 at 06:10)</a>:</h4>
<p>Although proving their own consistency sounds like a circular argument?</p>



<a name="270339612"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270339612" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270339612">(Feb 02 2022 at 06:11)</a>:</h4>
<p>It's not circular, since consistency of <code>T</code> is not a precondition of the proof</p>



<a name="270339666"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270339666" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270339666">(Feb 02 2022 at 06:12)</a>:</h4>
<p>in fact if <code>T</code> was inconsistent then <code>T |- Con(T)</code> would hold trivially</p>



<a name="270339683"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270339683" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270339683">(Feb 02 2022 at 06:12)</a>:</h4>
<p>Of course the interesting thing about self-verifying theories is that they are <em>in fact</em> consistent in addition to being able to prove they are consistent inside themselves</p>



<a name="270339775"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270339775" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270339775">(Feb 02 2022 at 06:14)</a>:</h4>
<p>What does "in fact consistent" mean?</p>



<a name="270339807"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270339807" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270339807">(Feb 02 2022 at 06:15)</a>:</h4>
<p>in the case of Willard's axiom systems this is usually ensured by having the theory be a subsystem of PA</p>



<a name="270339877"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270339877" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270339877">(Feb 02 2022 at 06:16)</a>:</h4>
<p>Why does that mean "in fact"?</p>



<a name="270339900"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270339900" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270339900">(Feb 02 2022 at 06:16)</a>:</h4>
<p>What I mean is, it's consistent from an "external viewpoint", not merely in <code>T</code>'s opinion</p>



<a name="270339919"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270339919" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270339919">(Feb 02 2022 at 06:17)</a>:</h4>
<p>since, as mentioned, if <code>T</code> was inconsistent it would prove its own consistency</p>



<a name="270339926"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270339926" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270339926">(Feb 02 2022 at 06:17)</a>:</h4>
<p>this is the "uninteresting case" of self-verification</p>



<a name="270340143"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270340143" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270340143">(Feb 02 2022 at 06:20)</a>:</h4>
<p>Of course you can question the consistency of any theory, including PA, but you have to throw out the vast majority of mathematics in the world to take that position. I can prove <code>Con(PA)</code> in lean with <code>no axioms</code></p>



<a name="270340398"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270340398" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270340398">(Feb 02 2022 at 06:24)</a>:</h4>
<p>You mean just from type theory?</p>



<a name="270340626"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270340626" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270340626">(Feb 02 2022 at 06:28)</a>:</h4>
<p>So are you basically using a sort of induction with the proof within T that T is consistent? That is, let each level of the meta logic just be T?</p>



<a name="270340662"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270340662" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270340662">(Feb 02 2022 at 06:29)</a>:</h4>
<p>And since we know we can always prove the consistency of T from T...</p>



<a name="270340665"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270340665" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Trebor Huang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270340665">(Feb 02 2022 at 06:29)</a>:</h4>
<p>Lean proves Con(PA), but PA never proves Con(PA)</p>



<a name="270340674"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270340674" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Trebor Huang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270340674">(Feb 02 2022 at 06:29)</a>:</h4>
<p>That's Goedel's incompleteness theorem.</p>



<a name="270340740"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270340740" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Trebor Huang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270340740">(Feb 02 2022 at 06:30)</a>:</h4>
<p>Of course, unless PA is inconsistent, in which case PA proves anything by ex falso.</p>



<a name="270341077"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270341077" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270341077">(Feb 02 2022 at 06:36)</a>:</h4>
<p>It seems kind of oddly concrete that the level is arithmetic that the incompleteness theorem takes affect.</p>



<a name="270341100"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270341100" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270341100">(Feb 02 2022 at 06:37)</a>:</h4>
<p>That's the level where undecidability starts to pop up, for example in diophantine equations</p>



<a name="270341171"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270341171" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270341171">(Feb 02 2022 at 06:38)</a>:</h4>
<p>I guess I would have expected it to be more abstract, like some subset of the set theory axioms.</p>



<a name="270341177"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270341177" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270341177">(Feb 02 2022 at 06:38)</a>:</h4>
<p>I don't think it has to be arithmetical, but historically that's where it's easiest to state these types of theories</p>



<a name="270341189"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270341189" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270341189">(Feb 02 2022 at 06:38)</a>:</h4>
<p>I see.</p>



<a name="270341192"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270341192" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270341192">(Feb 02 2022 at 06:38)</a>:</h4>
<p>The set theory axioms generally blow past this level pretty quickly</p>



<a name="270341211"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270341211" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270341211">(Feb 02 2022 at 06:39)</a>:</h4>
<p>once you have something that acts like a successor function like <code>{x}</code> you can usually already do all this stuff</p>



<a name="270341241"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270341241" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Trebor Huang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270341241">(Feb 02 2022 at 06:39)</a>:</h4>
<p>One thing though: I don't immediately see how Lean proves Con(PA) without excluded middle, is there any reference?</p>



<a name="270341293"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270341293" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270341293">(Feb 02 2022 at 06:40)</a>:</h4>
<p>I was actually writing that up right now</p>



<a name="270341321"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270341321" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270341321">(Feb 02 2022 at 06:40)</a>:</h4>
<p>it's not too hard to see that it should be possible: <code>nat</code> has decidable equality</p>



<a name="270341347"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270341347" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270341347">(Feb 02 2022 at 06:41)</a>:</h4>
<p>plus <code>Con(PA)</code> is a negative statement so intuitionism doesn't get in the way much</p>



<a name="270341351"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270341351" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Trebor Huang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270341351">(Feb 02 2022 at 06:41)</a>:</h4>
<p>Yeah I guess so, but it would be cool to see the complete proof done ;)</p>



<a name="270341561"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270341561" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270341561">(Feb 02 2022 at 06:44)</a>:</h4>
<p>Along the same lines, is there a written, maybe formal, proof that the axioms of metamath are equivalent at the object level to say the axioms of ND?</p>



<a name="270341661"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270341661" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270341661">(Feb 02 2022 at 06:46)</a>:</h4>
<p>Not sure if I would understand it, but might be interesting to try to.</p>



<a name="270341663"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270341663" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Trebor Huang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270341663">(Feb 02 2022 at 06:46)</a>:</h4>
<p>I think there's Meredith's work, which is mildly relevant(?)</p>



<a name="270341678"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270341678" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270341678">(Feb 02 2022 at 06:46)</a>:</h4>
<p>Something like <a href="http://us.metamath.org/mpeuni/natded.html">http://us.metamath.org/mpeuni/natded.html</a>?</p>



<a name="270342457"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270342457" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270342457">(Feb 02 2022 at 07:00)</a>:</h4>
<p>So I guess that shows that everything proven in ND can be proven from metamath. And the other way is shown because every axiom of metamath is a theorem of the Hilbert system, and the Hilbert system has been shown through the deduction theorem to be equivalent at the object level to ND?</p>



<a name="270343077"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270343077" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270343077">(Feb 02 2022 at 07:09)</a>:</h4>
<p>I found a way to cheat enough to make an easy proof of <code>Con(PA)</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">proof</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="kd">prefix</span> <span class="bp">`⊢`</span><span class="o">:</span><span class="mi">30</span> <span class="o">:=</span> <span class="n">proof</span>
<span class="bp">|</span> <span class="n">refl</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">⊢</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span>
<span class="bp">|</span> <span class="n">symm</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">⊢</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="bp">→</span> <span class="bp">⊢</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">x</span>
<span class="bp">|</span> <span class="n">trans</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">⊢</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="bp">→</span> <span class="bp">⊢</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">z</span> <span class="bp">→</span> <span class="bp">⊢</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">z</span>
<span class="bp">|</span> <span class="n">succ_inj</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">⊢</span> <span class="o">(</span><span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="bp">↔</span> <span class="n">nat.succ</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">nat.succ</span> <span class="n">y</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">succ_ne_zero</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">⊢</span> <span class="n">nat.succ</span> <span class="n">x</span> <span class="bp">≠</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="n">induction</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="bp">⊢</span> <span class="o">(</span><span class="n">P</span> <span class="mi">0</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">P</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">P</span> <span class="n">x.succ</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">P</span> <span class="n">x</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">add_zero</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">⊢</span> <span class="n">a</span> <span class="bp">+</span> <span class="mi">0</span> <span class="bp">=</span> <span class="n">a</span>
<span class="bp">|</span> <span class="n">add_succ</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">⊢</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b.succ</span> <span class="bp">=</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span><span class="bp">.</span><span class="n">succ</span>
<span class="bp">|</span> <span class="n">mul_zero</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">⊢</span> <span class="n">a</span> <span class="bp">*</span> <span class="mi">0</span> <span class="bp">=</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="n">mul_succ</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">⊢</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b.succ</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">a</span>
<span class="kd">prefix</span> <span class="bp">`⊢`</span><span class="o">:</span><span class="mi">30</span> <span class="o">:=</span> <span class="n">proof</span>

<span class="kd">theorem</span> <span class="n">proof.sound</span> <span class="o">{</span><span class="n">p</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">⊢</span> <span class="n">p</span><span class="o">)</span> <span class="o">:</span> <span class="n">p</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">induction</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">case</span> <span class="n">refl</span> <span class="o">:</span> <span class="n">x</span> <span class="o">{</span> <span class="n">exact</span> <span class="n">rfl</span> <span class="o">},</span>
  <span class="n">case</span> <span class="n">symm</span> <span class="o">:</span> <span class="n">x</span> <span class="n">y</span> <span class="n">h</span> <span class="n">ih</span> <span class="o">{</span> <span class="n">exact</span> <span class="n">ih.symm</span> <span class="o">},</span>
  <span class="n">case</span> <span class="n">trans</span> <span class="o">:</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="n">h₁</span> <span class="n">h₂</span> <span class="n">ih₁</span> <span class="n">ih₂</span> <span class="o">{</span> <span class="n">exact</span> <span class="n">ih₁.trans</span> <span class="n">ih₂</span> <span class="o">},</span>
  <span class="n">case</span> <span class="n">succ_inj</span> <span class="o">:</span> <span class="n">x</span> <span class="n">y</span> <span class="o">{</span> <span class="n">exact</span> <span class="o">⟨</span><span class="n">congr_arg</span> <span class="n">_</span><span class="o">,</span> <span class="n">nat.succ.inj</span><span class="o">⟩</span> <span class="o">},</span>
  <span class="n">case</span> <span class="n">succ_ne_zero</span> <span class="o">:</span> <span class="n">x</span> <span class="n">y</span> <span class="o">{</span> <span class="n">exact</span> <span class="n">nat.succ_ne_zero</span> <span class="n">_</span> <span class="o">},</span>
  <span class="n">case</span> <span class="n">induction</span> <span class="o">:</span> <span class="n">P</span> <span class="n">P0</span> <span class="n">Ps</span> <span class="n">n</span> <span class="o">{</span> <span class="n">exact</span> <span class="n">nat.rec_on</span> <span class="n">n</span> <span class="n">P0</span> <span class="n">Ps</span> <span class="o">},</span>
  <span class="n">case</span> <span class="n">add_zero</span> <span class="o">{</span> <span class="n">exact</span> <span class="n">rfl</span> <span class="o">},</span>
  <span class="n">case</span> <span class="n">add_succ</span> <span class="o">{</span> <span class="n">exact</span> <span class="n">rfl</span> <span class="o">},</span>
  <span class="n">case</span> <span class="n">mul_zero</span> <span class="o">{</span> <span class="n">exact</span> <span class="n">rfl</span> <span class="o">},</span>
  <span class="n">case</span> <span class="n">mul_succ</span> <span class="o">{</span> <span class="n">exact</span> <span class="n">rfl</span> <span class="o">},</span>
<span class="kd">end</span>

<span class="kd">theorem</span> <span class="n">con_pa</span> <span class="o">:</span> <span class="bp">¬</span> <span class="bp">⊢</span> <span class="mi">0</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">absurd</span> <span class="n">h.sound</span> <span class="n">dec_trivial</span>
<span class="k">#print</span> <span class="kd">axioms</span> <span class="n">con_pa</span> <span class="c1">-- no axioms</span>
</code></pre></div>



<a name="270343438"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270343438" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Trebor Huang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270343438">(Feb 02 2022 at 07:16)</a>:</h4>
<p>That looks very much like how the Church's simple theory of types deals with propositions: There's no Curry-Howard correspondence, and  there is a separate relation <code>|-</code> for proposition derivability, with separate axioms.</p>



<a name="270343514"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270343514" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Trebor Huang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270343514">(Feb 02 2022 at 07:17)</a>:</h4>
<p>But that's currently incomplete as I see it. You don't even have modus ponens, right?</p>



<a name="270343639"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270343639" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270343639">(Feb 02 2022 at 07:19)</a>:</h4>
<p>it's a bit annoying that the wikipedia article barely acknowledges this</p>



<a name="270344467"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270344467" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270344467">(Feb 02 2022 at 07:32)</a>:</h4>
<p>Thank you for the help! I'm going to sleep now :)</p>



<a name="270348518"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270348518" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270348518">(Feb 02 2022 at 08:23)</a>:</h4>
<p>Okay, here's a slightly less cheating version, which embeds classical logic via the <code>wff</code> type, even though we aren't assuming any classical axioms on <code>Prop</code></p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">wff</span>
<span class="bp">|</span> <span class="n">eq</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">wff</span>
<span class="bp">|</span> <span class="n">not</span> <span class="o">:</span> <span class="n">wff</span> <span class="bp">→</span> <span class="n">wff</span>
<span class="bp">|</span> <span class="n">imp</span> <span class="o">:</span> <span class="n">wff</span> <span class="bp">→</span> <span class="n">wff</span> <span class="bp">→</span> <span class="n">wff</span>
<span class="bp">|</span> <span class="n">all</span> <span class="o">:</span> <span class="o">(</span><span class="n">ℕ</span> <span class="bp">→</span> <span class="n">wff</span><span class="o">)</span> <span class="bp">→</span> <span class="n">wff</span>
<span class="kd">infix</span> <span class="bp">`</span> <span class="bp">≃</span> <span class="bp">`</span><span class="o">:</span><span class="mi">60</span> <span class="o">:=</span> <span class="n">wff.eq</span>
<span class="kd">infixr</span> <span class="bp">`</span> <span class="bp">⇒</span> <span class="bp">`</span><span class="o">:</span><span class="mi">50</span> <span class="o">:=</span> <span class="n">wff.imp</span>
<span class="kd">prefix</span> <span class="bp">`~`</span><span class="o">:</span><span class="mi">59</span> <span class="o">:=</span> <span class="n">wff.not</span>
<span class="kd">def</span> <span class="n">wff.and</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">wff</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">~</span><span class="o">(</span><span class="n">x</span> <span class="bp">⇒</span> <span class="bp">~</span><span class="n">y</span><span class="o">)</span>
<span class="kd">infix</span> <span class="bp">`</span> <span class="bp">&amp;&amp;</span> <span class="bp">`</span><span class="o">:</span><span class="mi">55</span> <span class="o">:=</span> <span class="n">wff.and</span>
<span class="kd">def</span> <span class="n">wff.or</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">wff</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">~</span><span class="n">x</span> <span class="bp">⇒</span> <span class="n">y</span>
<span class="kd">infix</span> <span class="bp">`</span> <span class="bp">||</span> <span class="bp">`</span><span class="o">:</span><span class="mi">54</span> <span class="o">:=</span> <span class="n">wff.or</span>
<span class="kd">def</span> <span class="n">wff.iff</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">wff</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">x</span> <span class="bp">⇒</span> <span class="n">y</span><span class="o">)</span> <span class="bp">&amp;&amp;</span> <span class="o">(</span><span class="n">y</span> <span class="bp">⇒</span> <span class="n">x</span><span class="o">)</span>
<span class="kd">infix</span> <span class="bp">`</span> <span class="bp">⇔</span> <span class="bp">`</span><span class="o">:</span><span class="mi">53</span> <span class="o">:=</span> <span class="n">wff.iff</span>
<span class="kd">notation</span> <span class="bp">`𝔸`</span> <span class="n">binders</span> <span class="bp">`</span><span class="o">,</span> <span class="bp">`</span> <span class="n">b</span><span class="o">:</span><span class="n">scoped</span> <span class="o">:=</span> <span class="n">wff.all</span> <span class="n">b</span>

<span class="kd">inductive</span> <span class="n">proof</span> <span class="o">:</span> <span class="n">wff</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="kd">prefix</span> <span class="bp">`⊢</span> <span class="bp">`</span><span class="o">:</span><span class="mi">30</span> <span class="o">:=</span> <span class="n">proof</span>
<span class="bp">|</span> <span class="n">ax_1</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">wff</span><span class="o">)</span> <span class="o">:</span> <span class="bp">⊢</span> <span class="n">p</span> <span class="bp">⇒</span> <span class="n">q</span> <span class="bp">⇒</span> <span class="n">p</span>
<span class="bp">|</span> <span class="n">ax_2</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="n">r</span> <span class="o">:</span> <span class="n">wff</span><span class="o">)</span> <span class="o">:</span> <span class="bp">⊢</span> <span class="o">(</span><span class="n">p</span> <span class="bp">⇒</span> <span class="n">q</span> <span class="bp">⇒</span> <span class="n">r</span><span class="o">)</span> <span class="bp">⇒</span> <span class="o">(</span><span class="n">p</span> <span class="bp">⇒</span> <span class="n">q</span><span class="o">)</span> <span class="bp">⇒</span> <span class="o">(</span><span class="n">p</span> <span class="bp">⇒</span> <span class="n">r</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">ax_3</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">wff</span><span class="o">)</span> <span class="o">:</span> <span class="bp">⊢</span> <span class="o">(</span><span class="bp">~</span><span class="n">p</span> <span class="bp">⇒</span> <span class="bp">~</span><span class="n">q</span><span class="o">)</span> <span class="bp">⇒</span> <span class="n">q</span> <span class="bp">⇒</span> <span class="n">p</span>
<span class="bp">|</span> <span class="n">mp</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">wff</span><span class="o">)</span> <span class="o">:</span> <span class="bp">⊢</span> <span class="n">p</span> <span class="bp">⇒</span> <span class="n">q</span> <span class="bp">→</span> <span class="bp">⊢</span> <span class="n">p</span> <span class="bp">→</span> <span class="bp">⊢</span> <span class="n">q</span>
<span class="bp">|</span> <span class="n">gen</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">wff</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="bp">⊢</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">⊢</span> <span class="bp">𝔸</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span>
<span class="bp">|</span> <span class="n">ax_4</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">wff</span><span class="o">)</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">⊢</span> <span class="o">(</span><span class="bp">𝔸</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">⇒</span> <span class="n">p</span> <span class="n">t</span>
<span class="bp">|</span> <span class="n">ax_5</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">wff</span><span class="o">)</span> <span class="o">:</span> <span class="bp">⊢</span> <span class="o">(</span><span class="bp">𝔸</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span> <span class="bp">⇒</span> <span class="n">q</span> <span class="n">x</span><span class="o">)</span> <span class="bp">⇒</span> <span class="o">(</span><span class="bp">𝔸</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">⇒</span> <span class="o">(</span><span class="bp">𝔸</span> <span class="n">x</span><span class="o">,</span> <span class="n">q</span> <span class="n">x</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">ax_6</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">wff</span><span class="o">)</span> <span class="o">:</span> <span class="bp">⊢</span> <span class="n">p</span> <span class="bp">⇒</span> <span class="o">(</span><span class="bp">𝔸</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">refl</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">⊢</span> <span class="n">x</span> <span class="bp">≃</span> <span class="n">x</span>
<span class="bp">|</span> <span class="n">symm</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">⊢</span> <span class="n">x</span> <span class="bp">≃</span> <span class="n">y</span> <span class="bp">→</span> <span class="bp">⊢</span> <span class="n">y</span> <span class="bp">≃</span> <span class="n">x</span>
<span class="bp">|</span> <span class="n">trans</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">⊢</span> <span class="n">x</span> <span class="bp">≃</span> <span class="n">y</span> <span class="bp">→</span> <span class="bp">⊢</span> <span class="n">y</span> <span class="bp">≃</span> <span class="n">z</span> <span class="bp">→</span> <span class="bp">⊢</span> <span class="n">x</span> <span class="bp">≃</span> <span class="n">z</span>
<span class="bp">|</span> <span class="n">subst</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">wff</span><span class="o">)</span> <span class="o">:</span> <span class="bp">⊢</span> <span class="n">x</span> <span class="bp">≃</span> <span class="n">y</span> <span class="bp">⇒</span> <span class="n">p</span> <span class="n">x</span> <span class="bp">⇒</span> <span class="n">p</span> <span class="n">y</span>
<span class="bp">|</span> <span class="n">succ_inj</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">⊢</span> <span class="n">x</span> <span class="bp">≃</span> <span class="n">y</span> <span class="bp">⇔</span> <span class="n">x.succ</span> <span class="bp">≃</span> <span class="n">y.succ</span>
<span class="bp">|</span> <span class="n">succ_ne_zero</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">⊢</span> <span class="bp">~</span><span class="o">(</span><span class="n">x.succ</span> <span class="bp">≃</span> <span class="mi">0</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">induction</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">wff</span><span class="o">)</span> <span class="o">:</span> <span class="bp">⊢</span> <span class="o">(</span><span class="n">P</span> <span class="mi">0</span> <span class="bp">⇒</span> <span class="o">(</span><span class="bp">𝔸</span> <span class="n">x</span><span class="o">,</span> <span class="n">P</span> <span class="n">x</span> <span class="bp">⇒</span> <span class="n">P</span> <span class="n">x.succ</span><span class="o">)</span> <span class="bp">⇒</span> <span class="bp">𝔸</span> <span class="n">x</span><span class="o">,</span> <span class="n">P</span> <span class="n">x</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">add_zero</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">⊢</span> <span class="n">a</span> <span class="bp">+</span> <span class="mi">0</span> <span class="bp">≃</span> <span class="n">a</span>
<span class="bp">|</span> <span class="n">add_succ</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">⊢</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b.succ</span> <span class="bp">≃</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span><span class="bp">.</span><span class="n">succ</span>
<span class="bp">|</span> <span class="n">mul_zero</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">⊢</span> <span class="n">a</span> <span class="bp">*</span> <span class="mi">0</span> <span class="bp">≃</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="n">mul_succ</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">⊢</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b.succ</span> <span class="bp">≃</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">a</span>
<span class="kd">prefix</span> <span class="bp">`⊢</span> <span class="bp">`</span><span class="o">:</span><span class="mi">30</span> <span class="o">:=</span> <span class="n">proof</span>

<span class="kd">def</span> <span class="n">wff.val</span> <span class="o">:</span> <span class="n">wff</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">x</span> <span class="bp">≃</span> <span class="n">y</span><span class="o">)</span> <span class="o">:=</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span>
<span class="bp">|</span> <span class="o">(</span><span class="bp">~</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">¬</span> <span class="n">x.val</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">x</span> <span class="bp">⇒</span> <span class="n">y</span><span class="o">)</span> <span class="o">:=</span> <span class="n">x.val</span> <span class="bp">→</span> <span class="n">y.val</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">wff.all</span> <span class="n">p</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="o">(</span><span class="n">p</span> <span class="n">x</span><span class="o">)</span><span class="bp">.</span><span class="n">val</span>

<span class="kd">theorem</span> <span class="n">wff.dne</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">wff</span><span class="o">,</span> <span class="bp">¬¬</span><span class="n">x.val</span> <span class="bp">→</span> <span class="n">x.val</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">x</span> <span class="bp">≃</span> <span class="n">y</span><span class="o">)</span> <span class="n">h</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">decidable.of_not_not</span> <span class="o">(</span><span class="n">x</span> <span class="bp">=</span> <span class="n">y</span><span class="o">)</span> <span class="n">_</span> <span class="n">h</span>
<span class="bp">|</span> <span class="o">(</span><span class="bp">~</span> <span class="n">x</span><span class="o">)</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">not_of_not_not_not</span> <span class="n">h</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">x</span> <span class="bp">⇒</span> <span class="n">y</span><span class="o">)</span> <span class="n">h</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">hx</span><span class="o">,</span> <span class="n">y.dne</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">hy</span><span class="o">,</span> <span class="n">h</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">hi</span><span class="o">,</span> <span class="n">hy</span> <span class="o">(</span><span class="n">hi</span> <span class="n">hx</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">wff.all</span> <span class="n">p</span><span class="o">)</span> <span class="n">h</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="o">(</span><span class="n">p</span> <span class="n">x</span><span class="o">)</span><span class="bp">.</span><span class="n">dne</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">hx</span><span class="o">,</span> <span class="n">h</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">ha</span><span class="o">,</span> <span class="n">hx</span> <span class="bp">$</span> <span class="n">ha</span> <span class="n">x</span>

<span class="kd">theorem</span> <span class="n">proof.sound</span> <span class="o">{</span><span class="n">p</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">⊢</span> <span class="n">p</span><span class="o">)</span> <span class="o">:</span> <span class="n">p.val</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">induction</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">case</span> <span class="n">ax_1</span> <span class="o">:</span> <span class="n">p</span> <span class="n">q</span> <span class="o">{</span> <span class="n">exact</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">a</span> <span class="o">},</span>
  <span class="n">case</span> <span class="n">ax_2</span> <span class="o">:</span> <span class="n">p</span> <span class="n">q</span> <span class="n">r</span> <span class="o">{</span> <span class="n">exact</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="o">,</span> <span class="n">a</span> <span class="n">c</span> <span class="o">(</span><span class="n">b</span> <span class="n">c</span><span class="o">)</span> <span class="o">},</span>
  <span class="n">case</span> <span class="n">ax_3</span> <span class="o">:</span> <span class="n">p</span> <span class="n">q</span> <span class="o">{</span> <span class="n">exact</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">p.dne</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">a</span> <span class="n">h</span> <span class="n">b</span> <span class="o">},</span>
  <span class="n">case</span> <span class="n">mp</span> <span class="o">:</span> <span class="n">p</span> <span class="n">q</span> <span class="n">h₁</span> <span class="n">h₂</span> <span class="n">ih₁</span> <span class="n">ih₂</span> <span class="o">{</span> <span class="n">exact</span> <span class="n">ih₁</span> <span class="n">ih₂</span> <span class="o">},</span>
  <span class="n">case</span> <span class="n">gen</span> <span class="o">:</span> <span class="n">p</span> <span class="n">h</span> <span class="n">ih</span> <span class="o">{</span> <span class="n">exact</span> <span class="n">ih</span> <span class="o">},</span>
  <span class="n">case</span> <span class="n">ax_4</span> <span class="o">:</span> <span class="n">p</span> <span class="n">x</span> <span class="o">{</span> <span class="n">exact</span> <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">h</span> <span class="n">x</span> <span class="o">},</span>
  <span class="n">case</span> <span class="n">ax_5</span> <span class="o">:</span> <span class="n">p</span> <span class="n">q</span> <span class="o">{</span> <span class="n">exact</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">x</span><span class="o">,</span> <span class="n">a</span> <span class="n">x</span> <span class="o">(</span><span class="n">b</span> <span class="n">x</span><span class="o">)</span> <span class="o">},</span>
  <span class="n">case</span> <span class="n">ax_6</span> <span class="o">:</span> <span class="n">p</span> <span class="o">{</span> <span class="n">exact</span> <span class="bp">λ</span> <span class="n">h</span> <span class="n">x</span><span class="o">,</span> <span class="n">h</span> <span class="o">},</span>
  <span class="n">case</span> <span class="n">refl</span> <span class="o">:</span> <span class="n">x</span> <span class="o">{</span> <span class="n">exact</span> <span class="n">rfl</span> <span class="o">},</span>
  <span class="n">case</span> <span class="n">symm</span> <span class="o">:</span> <span class="n">x</span> <span class="n">y</span> <span class="n">h</span> <span class="n">ih</span> <span class="o">{</span> <span class="n">exact</span> <span class="n">ih.symm</span> <span class="o">},</span>
  <span class="n">case</span> <span class="n">trans</span> <span class="o">:</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="n">h₁</span> <span class="n">h₂</span> <span class="n">ih₁</span> <span class="n">ih₂</span> <span class="o">{</span> <span class="n">exact</span> <span class="n">ih₁.trans</span> <span class="n">ih₂</span> <span class="o">},</span>
  <span class="n">case</span> <span class="n">subst</span> <span class="o">:</span> <span class="n">x</span> <span class="n">y</span> <span class="n">p</span> <span class="o">{</span> <span class="n">exact</span> <span class="bp">λ</span> <span class="o">(</span><span class="n">e</span><span class="o">:</span><span class="n">x</span><span class="bp">=</span><span class="n">y</span><span class="o">)</span> <span class="n">h</span><span class="o">,</span> <span class="n">e</span> <span class="bp">▸</span> <span class="n">h</span> <span class="o">},</span>
  <span class="n">case</span> <span class="n">succ_inj</span> <span class="o">:</span> <span class="n">x</span> <span class="n">y</span> <span class="o">{</span> <span class="n">exact</span> <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">h</span> <span class="o">(</span><span class="n">congr_arg</span> <span class="n">_</span><span class="o">)</span> <span class="n">nat.succ.inj</span> <span class="o">},</span>
  <span class="n">case</span> <span class="n">succ_ne_zero</span> <span class="o">:</span> <span class="n">x</span> <span class="n">y</span> <span class="o">{</span> <span class="n">exact</span> <span class="n">nat.succ_ne_zero</span> <span class="n">_</span> <span class="o">},</span>
  <span class="n">case</span> <span class="n">induction</span> <span class="o">:</span> <span class="n">P</span> <span class="o">{</span> <span class="n">exact</span> <span class="bp">λ</span> <span class="n">P0</span> <span class="n">Ps</span> <span class="n">n</span><span class="o">,</span> <span class="n">nat.rec_on</span> <span class="n">n</span> <span class="n">P0</span> <span class="n">Ps</span> <span class="o">},</span>
  <span class="n">case</span> <span class="n">add_zero</span> <span class="o">{</span> <span class="n">exact</span> <span class="n">rfl</span> <span class="o">},</span>
  <span class="n">case</span> <span class="n">add_succ</span> <span class="o">{</span> <span class="n">exact</span> <span class="n">rfl</span> <span class="o">},</span>
  <span class="n">case</span> <span class="n">mul_zero</span> <span class="o">{</span> <span class="n">exact</span> <span class="n">rfl</span> <span class="o">},</span>
  <span class="n">case</span> <span class="n">mul_succ</span> <span class="o">{</span> <span class="n">exact</span> <span class="n">rfl</span> <span class="o">},</span>
<span class="kd">end</span>

<span class="kd">theorem</span> <span class="n">con_pa</span> <span class="o">:</span> <span class="bp">¬</span> <span class="bp">⊢</span> <span class="mi">0</span> <span class="bp">≃</span> <span class="mi">1</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">absurd</span> <span class="n">h.sound</span> <span class="o">(</span><span class="n">dec_trivial</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≠</span> <span class="mi">1</span><span class="o">)</span>
<span class="k">#print</span> <span class="kd">axioms</span> <span class="n">con_pa</span> <span class="c1">-- no axioms</span>
</code></pre></div>



<a name="270504934"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270504934" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270504934">(Feb 03 2022 at 06:05)</a>:</h4>
<p><span class="user-mention silent" data-user-id="139442">Patrick Thomas</span> <a href="#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/270142115">said</a>:</p>
<blockquote>
<p>If I move the last code example that I posted from propositional logic to predicate logic, do I understand correctly that applying a theorem will  then require replacing each free term variable with a syntactically correct term scheme, taking into account potential free variable capture, in addition to the replacement of propositional variables (predicate variables of arity 0) that is already done in the current propositional case?</p>
</blockquote>
<p>If you substitute a formula in for a propositional variable, do you at the same time have to substitute in for each of the propositional variables and each of the free term variables in that formula? And so on recursively?</p>



<a name="270505113"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270505113" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270505113">(Feb 03 2022 at 06:09)</a>:</h4>
<p>No. The variables in the formula will be variables in the current context</p>



<a name="270505197"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270505197" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270505197">(Feb 03 2022 at 06:10)</a>:</h4>
<p>Ok. Thank you.</p>



<a name="270505463"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270505463" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270505463">(Feb 03 2022 at 06:14)</a>:</h4>
<p>there is some "second order subtitution" going on in the code for substituting into a second order variable, for example if we want to substitute <code>P(x, y) := a &lt; b + x</code> into a theorem scheme like <code>all z, ex w, P(z + 1, w)</code> we have to substitute <code>z + 1, w</code> for <code>x, y</code> to get <code>a &lt; b + (z + 1)</code> and then replace <code>P(z + 1, w)</code> with this <code>a &lt; b + (z + 1)</code> formula in the original expression <code>all z, ex w, P(z + 1, w)</code> to get <code>all z, ex w, a &lt; b + (z + 1)</code>, but that's as far as it goes. (You would need third order substitution if the variables <code>z</code> and <code>w</code> could themselves be higher order objects appearing as <code>z(u)</code> in the expression.)</p>



<a name="270505508"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270505508" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270505508">(Feb 03 2022 at 06:15)</a>:</h4>
<p>If you only have 0-ary formula and term variables then you only need one level of substitution</p>



<a name="270505869"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270505869" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270505869">(Feb 03 2022 at 06:21)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/270505508">said</a>:</p>
<blockquote>
<p>If you only have 0-ary formula and term variables then you only need one level of substitution</p>
</blockquote>
<p>I'm not sure if I do or not. I mean I have predicate variables which can have arbitrary arity. But are you maybe referring to higher order logics, that is beyond first order logic, where for example you can generalize over propositions?</p>



<a name="270505927"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270505927" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270505927">(Feb 03 2022 at 06:22)</a>:</h4>
<p>The question is whether you can substitute for those predicate variables of nonzero arity</p>



<a name="270505943"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270505943" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270505943">(Feb 03 2022 at 06:22)</a>:</h4>
<p>I assume you can, in which case you have the second order substitution process I mentioned</p>



<a name="270506019"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270506019" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270506019">(Feb 03 2022 at 06:23)</a>:</h4>
<p>This is second order logic "lite"</p>



<a name="270506073"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270506073" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270506073">(Feb 03 2022 at 06:23)</a>:</h4>
<p>since you don't have arbitrary quantification over those predicate variables</p>



<a name="270506169"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270506169" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270506169">(Feb 03 2022 at 06:25)</a>:</h4>
<p>I don't think I can. I mean you can substitute for the terms in them, but I don't have it that you can replace them entirely, which are different things right?</p>



<a name="270506208"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270506208" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270506208">(Feb 03 2022 at 06:25)</a>:</h4>
<p>I'm trying to stick to just FOL for now.</p>



<a name="270506274"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270506274" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270506274">(Feb 03 2022 at 06:26)</a>:</h4>
<p>Right I mean if you have a lemma like <code>(all x, P(x) -&gt; Q(x)) -&gt; (all x, P(x)) -&gt; (all x, Q(x))</code> and you say "I want to use this lemma with <code>P(x) := 2 &lt; x</code> and <code>Q(x) := 0 &lt; x</code>"</p>



<a name="270506309"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270506309" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270506309">(Feb 03 2022 at 06:27)</a>:</h4>
<p>Without such a mechanism it's not very useful to prove FOL schemes</p>



<a name="270506369"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270506369" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270506369">(Feb 03 2022 at 06:28)</a>:</h4>
<p>Basically the predicate variables aren't variables at all, they are constants</p>



<a name="270506520"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270506520" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270506520">(Feb 03 2022 at 06:31)</a>:</h4>
<p>Maybe it will be easier if I post what I have of the code so far.</p>



<a name="270506589"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270506589" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270506589">(Feb 03 2022 at 06:32)</a>:</h4>
<p>Let me clean it up a bit.</p>



<a name="270506606"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270506606" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270506606">(Feb 03 2022 at 06:33)</a>:</h4>
<p>What I'm saying is that if you can't substitute for predicate variables then they aren't variables</p>



<a name="270506615"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270506615" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270506615">(Feb 03 2022 at 06:33)</a>:</h4>
<p>that's what it means to be a variable</p>



<a name="270506681"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270506681" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270506681">(Feb 03 2022 at 06:34)</a>:</h4>
<p>Predicate constants are useful too, for example <code>\in</code> and <code>&lt;</code> are predicate constants</p>



<a name="270506694"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270506694" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270506694">(Feb 03 2022 at 06:34)</a>:</h4>
<p>you wouldn't expect to be able to substitute them with expressions</p>



<a name="270507252"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270507252" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270507252">(Feb 03 2022 at 06:45)</a>:</h4>
<p>There are probably errors, but I think this gives the general idea:</p>
<div class="codehilite" data-code-language="Haskell"><pre><span></span><code><span class="cm">{-</span>
<span class="cm">allVar t = The set of the names of all of the variables that occur in</span>
<span class="cm">the term t.</span>
<span class="cm">-}</span><span class="w"></span>
<span class="nf">allVar</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Term</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Data</span><span class="o">.</span><span class="kt">Set</span><span class="o">.</span><span class="kt">Set</span><span class="w"> </span><span class="kt">String</span><span class="w"></span>
<span class="nf">allVar</span><span class="w"> </span><span class="p">(</span><span class="kt">Var</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Data</span><span class="o">.</span><span class="kt">Set</span><span class="o">.</span><span class="n">singleton</span><span class="w"> </span><span class="n">v</span><span class="w"></span>
<span class="nf">allVar</span><span class="w"> </span><span class="p">(</span><span class="kt">Func</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="n">ts</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Data</span><span class="o">.</span><span class="kt">Set</span><span class="o">.</span><span class="n">unions</span><span class="w"> </span><span class="p">(</span><span class="kt">Prelude</span><span class="o">.</span><span class="n">map</span><span class="w"> </span><span class="n">allVar</span><span class="w"> </span><span class="n">ts</span><span class="p">)</span><span class="w"></span>

<span class="cm">{-</span>
<span class="cm">allFreeVar p = The set of the names of all of the variables that occur</span>
<span class="cm">free in the formula p.</span>
<span class="cm">-}</span><span class="w"></span>
<span class="nf">allFreeVar</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Formula</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Data</span><span class="o">.</span><span class="kt">Set</span><span class="o">.</span><span class="kt">Set</span><span class="w"> </span><span class="kt">String</span><span class="w"></span>
<span class="nf">allFreeVar</span><span class="w"> </span><span class="p">(</span><span class="kt">Pred</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="n">ts</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Data</span><span class="o">.</span><span class="kt">Set</span><span class="o">.</span><span class="n">unions</span><span class="w"> </span><span class="p">(</span><span class="kt">Prelude</span><span class="o">.</span><span class="n">map</span><span class="w"> </span><span class="n">allVar</span><span class="w"> </span><span class="n">ts</span><span class="p">)</span><span class="w"></span>
<span class="nf">allFreeVar</span><span class="w"> </span><span class="kt">Bottom</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Data</span><span class="o">.</span><span class="kt">Set</span><span class="o">.</span><span class="n">empty</span><span class="w"></span>
<span class="nf">allFreeVar</span><span class="w"> </span><span class="p">(</span><span class="kt">Imp</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">q</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Data</span><span class="o">.</span><span class="kt">Set</span><span class="o">.</span><span class="n">union</span><span class="w"> </span><span class="p">(</span><span class="n">allFreeVar</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">allFreeVar</span><span class="w"> </span><span class="n">q</span><span class="p">)</span><span class="w"></span>
<span class="nf">allFreeVar</span><span class="w"> </span><span class="p">(</span><span class="kt">Forall</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Data</span><span class="o">.</span><span class="kt">Set</span><span class="o">.</span><span class="n">delete</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="p">(</span><span class="n">allFreeVar</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"></span>


<span class="cm">{-</span>

<span class="cm">-}</span><span class="w"></span>
<span class="nf">subEachInForm</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Formula</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"></span>
<span class="w">                 </span><span class="kt">Data</span><span class="o">.</span><span class="kt">Map</span><span class="o">.</span><span class="kt">Map</span><span class="w"> </span><span class="kt">String</span><span class="w"> </span><span class="kt">Term</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"></span>
<span class="w">                 </span><span class="kt">Data</span><span class="o">.</span><span class="kt">Map</span><span class="o">.</span><span class="kt">Map</span><span class="w"> </span><span class="kt">String</span><span class="w"> </span><span class="kt">Formula</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"></span>
<span class="w">                 </span><span class="kt">Formula</span><span class="w"></span>

<span class="nf">subEachInForm</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">t_map</span><span class="w"> </span><span class="n">f_map</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">go</span><span class="w"> </span><span class="kt">Data</span><span class="o">.</span><span class="kt">Set</span><span class="o">.</span><span class="n">empty</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">t_map</span><span class="w"> </span><span class="n">f_map</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="n">go</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Data</span><span class="o">.</span><span class="kt">Set</span><span class="o">.</span><span class="kt">Set</span><span class="w"> </span><span class="kt">String</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"></span>
<span class="w">        </span><span class="kt">Formula</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"></span>
<span class="w">        </span><span class="kt">Data</span><span class="o">.</span><span class="kt">Map</span><span class="o">.</span><span class="kt">Map</span><span class="w"> </span><span class="kt">String</span><span class="w"> </span><span class="kt">Term</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"></span>
<span class="w">        </span><span class="kt">Data</span><span class="o">.</span><span class="kt">Map</span><span class="o">.</span><span class="kt">Map</span><span class="w"> </span><span class="kt">String</span><span class="w"> </span><span class="kt">Formula</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"></span>
<span class="w">        </span><span class="kt">Formula</span><span class="w"></span>

<span class="w">  </span><span class="n">go</span><span class="w"> </span><span class="n">binders</span><span class="w"> </span><span class="p">(</span><span class="kt">Pred</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="kt">[]</span><span class="p">)</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="n">f_map</span><span class="w"> </span><span class="ow">=</span><span class="w"></span>
<span class="w">    </span><span class="kr">let</span><span class="w"> </span><span class="n">f'</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">f_map</span><span class="w"> </span><span class="o">!</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="kr">in</span><span class="w"></span>
<span class="w">    </span><span class="kr">if</span><span class="w"> </span><span class="kt">Data</span><span class="o">.</span><span class="kt">Set</span><span class="o">.</span><span class="n">disjoint</span><span class="w"> </span><span class="p">(</span><span class="n">allFreeVar</span><span class="w"> </span><span class="n">f'</span><span class="p">)</span><span class="w"> </span><span class="n">binders</span><span class="w"></span>
<span class="w">    </span><span class="kr">then</span><span class="w"> </span><span class="n">f'</span><span class="w"></span>
<span class="w">    </span><span class="kr">else</span><span class="w"> </span><span class="ne">error</span><span class="w"> </span><span class="s">"free variable capture"</span><span class="w"></span>

<span class="w">  </span><span class="n">go</span><span class="w"> </span><span class="n">binders</span><span class="w"> </span><span class="p">(</span><span class="kt">Pred</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="n">ts</span><span class="p">)</span><span class="w"> </span><span class="n">t_map</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="ow">=</span><span class="w"></span>
<span class="w">        </span><span class="kt">Pred</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="p">(</span><span class="kt">Data</span><span class="o">.</span><span class="kt">List</span><span class="o">.</span><span class="n">map</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">t</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">subEachInTerm</span><span class="w"> </span><span class="n">binders</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="n">t_map</span><span class="p">)</span><span class="w"> </span><span class="n">ts</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">          </span><span class="n">subEachInTerm</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Data</span><span class="o">.</span><span class="kt">Set</span><span class="o">.</span><span class="kt">Set</span><span class="w"> </span><span class="kt">String</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"></span>
<span class="w">                           </span><span class="kt">Term</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"></span>
<span class="w">                           </span><span class="kt">Data</span><span class="o">.</span><span class="kt">Map</span><span class="o">.</span><span class="kt">Map</span><span class="w"> </span><span class="kt">String</span><span class="w"> </span><span class="kt">Term</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"></span>
<span class="w">                           </span><span class="kt">Term</span><span class="w"></span>

<span class="w">          </span><span class="n">subEachInTerm</span><span class="w"> </span><span class="p">(</span><span class="n">binders</span><span class="w"> </span><span class="kt">Var</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="n">t_map</span><span class="w"> </span><span class="ow">=</span><span class="w"></span>
<span class="w">            </span><span class="kr">if</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="p">`</span><span class="kt">Data</span><span class="o">.</span><span class="kt">Set</span><span class="o">.</span><span class="n">member</span><span class="p">`</span><span class="w"> </span><span class="n">binders</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="kt">Var</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="kr">else</span><span class="w"></span>
<span class="w">            </span><span class="kr">let</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">t_map</span><span class="w"> </span><span class="o">!</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="kr">in</span><span class="w"></span>
<span class="w">            </span><span class="kr">if</span><span class="w"> </span><span class="kt">Data</span><span class="o">.</span><span class="kt">Set</span><span class="o">.</span><span class="n">disjoint</span><span class="w"> </span><span class="p">(</span><span class="n">allVar</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="n">binders</span><span class="w"></span>
<span class="w">            </span><span class="kr">then</span><span class="w"> </span><span class="n">t</span><span class="w"></span>
<span class="w">            </span><span class="kr">else</span><span class="w"> </span><span class="ne">error</span><span class="w"> </span><span class="s">"free variable capture"</span><span class="w"></span>

<span class="w">          </span><span class="n">subEachInTerm</span><span class="w"> </span><span class="n">binders</span><span class="w"> </span><span class="p">(</span><span class="kt">Func</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="n">ts</span><span class="p">)</span><span class="w"> </span><span class="n">t_map</span><span class="w"> </span><span class="ow">=</span><span class="w"></span>
<span class="w">            </span><span class="kt">Func</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="p">(</span><span class="kt">Data</span><span class="o">.</span><span class="kt">List</span><span class="o">.</span><span class="n">map</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">t</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">subEachInTerm</span><span class="w"> </span><span class="n">binders</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="n">t_map</span><span class="p">)</span><span class="w"> </span><span class="n">ts</span><span class="p">)</span><span class="w"></span>

<span class="w">  </span><span class="n">go</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="kt">Bottom</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Bottom</span><span class="w"></span>

<span class="w">  </span><span class="n">go</span><span class="w"> </span><span class="n">binders</span><span class="w"> </span><span class="p">(</span><span class="kt">Imp</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">q</span><span class="p">)</span><span class="w"> </span><span class="n">t_map</span><span class="w"> </span><span class="n">f_map</span><span class="w"> </span><span class="ow">=</span><span class="w"></span>
<span class="w">    </span><span class="kt">Imp</span><span class="w"> </span><span class="p">(</span><span class="n">subEachInForm</span><span class="w"> </span><span class="n">binders</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">t_map</span><span class="w"> </span><span class="n">f_map</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">subEachInForm</span><span class="w"> </span><span class="n">binders</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="n">t_map</span><span class="w"> </span><span class="n">f_map</span><span class="p">)</span><span class="w"></span>

<span class="w">  </span><span class="n">go</span><span class="w"> </span><span class="n">binders</span><span class="w"> </span><span class="p">(</span><span class="kt">Forall</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"></span>
<span class="w">    </span><span class="kt">Forall</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="p">(</span><span class="n">subEachInForm</span><span class="w"> </span><span class="p">(</span><span class="kt">Data</span><span class="o">.</span><span class="kt">Set</span><span class="o">.</span><span class="n">insert</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="n">binders</span><span class="p">)</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">t_map</span><span class="w"> </span><span class="n">f_map</span><span class="p">)</span><span class="w"></span>
</code></pre></div>



<a name="270507353"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270507353" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270507353">(Feb 03 2022 at 06:47)</a>:</h4>
<p>shouldn't the last case</p>
<div class="codehilite" data-code-language="Haskell"><pre><span></span><code><span class="w">  </span><span class="n">go</span><span class="w"> </span><span class="n">binders</span><span class="w"> </span><span class="p">(</span><span class="kt">Forall</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"></span>
<span class="w">    </span><span class="kt">Forall</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="p">(</span><span class="n">subEachInForm</span><span class="w"> </span><span class="p">(</span><span class="kt">Data</span><span class="o">.</span><span class="kt">Set</span><span class="o">.</span><span class="n">insert</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="n">binders</span><span class="p">)</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">t_map</span><span class="w"> </span><span class="n">f_map</span><span class="p">)</span><span class="w"></span>
</code></pre></div>
<p>be calling <code>go</code> recursively?</p>



<a name="270507358"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270507358" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270507358">(Feb 03 2022 at 06:47)</a>:</h4>
<p>Yep.</p>



<a name="270507407"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270507407" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270507407">(Feb 03 2022 at 06:48)</a>:</h4>
<p>also protip you don't need to pass things that are fixed in the recursion to <code>go</code></p>



<a name="270507415"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270507415" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270507415">(Feb 03 2022 at 06:48)</a>:</h4>
<p>like <code>f_map</code> and <code>t_map</code></p>



<a name="270507440"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270507440" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270507440">(Feb 03 2022 at 06:49)</a>:</h4>
<p>Yeah, I started out thinking I might need to recursively descend for the propositional case and would need them.</p>



<a name="270507483"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270507483" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270507483">(Feb 03 2022 at 06:50)</a>:</h4>
<p>Or something like that.</p>



<a name="270507506"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270507506" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270507506">(Feb 03 2022 at 06:50)</a>:</h4>
<p>This code is roughly what I expected. You aren't substituting for predicate variables, which means that you can't prove schemes over predicates and use them later</p>



<a name="270507546"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270507546" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270507546">(Feb 03 2022 at 06:51)</a>:</h4>
<p>What will be the drawbacks of not being able to do that?</p>



<a name="270507613"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270507613" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270507613">(Feb 03 2022 at 06:52)</a>:</h4>
<p>Are there things I can't prove, or will it just be lot harder to prove them?</p>



<a name="270507619"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270507619" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270507619">(Feb 03 2022 at 06:52)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/270506274">said</a>:</p>
<blockquote>
<p>Right I mean if you have a lemma like <code>(all x, P(x) -&gt; Q(x)) -&gt; (all x, P(x)) -&gt; (all x, Q(x))</code> and you say "I want to use this lemma with <code>P(x) := 2 &lt; x</code> and <code>Q(x) := 0 &lt; x</code>"</p>
</blockquote>



<a name="270507673"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270507673" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270507673">(Feb 03 2022 at 06:53)</a>:</h4>
<p>In order to do this you would need to replay the proof in the specific case <code>(all x, 2 &lt; x -&gt; 0 &lt; x) -&gt; (all x, 2 &lt; x) -&gt; (all x, 0 &lt; x)</code></p>



<a name="270507678"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270507678" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270507678">(Feb 03 2022 at 06:53)</a>:</h4>
<p>Yeah, that sounds like an issue.</p>



<a name="270507757"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270507757" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270507757">(Feb 03 2022 at 06:54)</a>:</h4>
<p>But I have to implement another level for every arity I want to support?</p>



<a name="270507783"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270507783" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270507783">(Feb 03 2022 at 06:55)</a>:</h4>
<p>I refer you back to <code>substFormula</code> from <a href="#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/269903509">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/269903509</a></p>



<a name="270507797"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270507797" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270507797">(Feb 03 2022 at 06:55)</a>:</h4>
<p>That handles arbitrary arity</p>



<a name="270507804"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270507804" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270507804">(Feb 03 2022 at 06:55)</a>:</h4>
<p>it doesn't handle third order variables but you don't have those anyway</p>



<a name="270507857"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270507857" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270507857">(Feb 03 2022 at 06:56)</a>:</h4>
<p>Wait, what is the difference between arity and order?</p>



<a name="270507905"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270507905" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270507905">(Feb 03 2022 at 06:57)</a>:</h4>
<ul>
<li><code>x : nat</code> : first order</li>
<li><code>P : nat -&gt; Prop</code>: second order, arity 1</li>
<li><code>P : nat -&gt; nat -&gt; Prop</code>: second order, arity 2</li>
<li><code>P : (nat -&gt; Prop) -&gt; Prop</code>: third order, arity 1</li>
</ul>



<a name="270507954"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270507954" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270507954">(Feb 03 2022 at 06:58)</a>:</h4>
<p>An nth order variable takes (any number of) arguments of order n-1</p>



<a name="270508135"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270508135" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270508135">(Feb 03 2022 at 07:01)</a>:</h4>
<p>Which order would a propositional variable be? <code>P : Prop</code>?</p>



<a name="270508211"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270508211" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270508211">(Feb 03 2022 at 07:02)</a>:</h4>
<p>I would usually refer to them as second order variables for consistency with the predicates, but you could also consider them as first order</p>



<a name="270508337"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270508337" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270508337">(Feb 03 2022 at 07:04)</a>:</h4>
<p>you can always code a proposition as a <code>nat</code>, using <code>if p then 1 else 0</code>, so it's possible to smuggle propositions when only first order / <code>nat</code> variables are allowed</p>



<a name="270508358"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270508358" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270508358">(Feb 03 2022 at 07:05)</a>:</h4>
<p>but of course you can't code a <code>nat -&gt; Prop</code> as a <code>nat</code>, that's cantor's theorem</p>



<a name="270508585"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270508585" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270508585">(Feb 03 2022 at 07:08)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/270507783">said</a>:</p>
<blockquote>
<p>I refer you back to <code>substFormula</code> from <a href="#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/269903509">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/269903509</a></p>
</blockquote>
<p>I'm sorry, I was having trouble following your code from earlier, so I thought it might make more sense to me to incrementally build my code up from prop logic and see what I needed to change.</p>



<a name="270508747"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270508747" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270508747">(Feb 03 2022 at 07:11)</a>:</h4>
<p>So, what are the rules to additionally substitute for a predicate variable of arity &gt; 0? What can I substitute for what under what conditions?</p>



<a name="270508917"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270508917" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270508917">(Feb 03 2022 at 07:14)</a>:</h4>
<p>From the code it seems maybe you can substitute one predicate for another if there aritys match?</p>



<a name="270508964"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270508964" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270508964">(Feb 03 2022 at 07:15)</a>:</h4>
<p>that's certainly a necessary condition</p>



<a name="270509039"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270509039" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270509039">(Feb 03 2022 at 07:16)</a>:</h4>
<p>Think of it from the HOL perspective. We have a term like <code>P(x, y)</code> and we want to substitute a lambda like <code>P := \lam u v -&gt; foo</code> into it</p>



<a name="270509046"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270509046" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270509046">(Feb 03 2022 at 07:16)</a>:</h4>
<p>obviously the number of lambda binders has to match the number of arguments to <code>P</code></p>



<a name="270509065"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270509065" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270509065">(Feb 03 2022 at 07:17)</a>:</h4>
<p>I'm guessing there are also conditions to prevent free variable capture?</p>



<a name="270509534"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270509534" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270509534">(Feb 03 2022 at 07:26)</a>:</h4>
<p>Here's a fairly generic situation:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">substitute</span>
<span class="n">P</span><span class="o">(</span><span class="n">u</span><span class="o">,</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">∀</span> <span class="n">b</span><span class="o">,</span> <span class="n">u</span> <span class="bp">&lt;</span> <span class="n">a</span> <span class="bp">∧</span> <span class="n">v</span> <span class="bp">&lt;</span> <span class="n">b</span>
<span class="n">into</span>
<span class="bp">∀</span> <span class="n">x</span> <span class="n">z</span><span class="o">,</span> <span class="n">P</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span>
<span class="n">to</span> <span class="n">get</span>
<span class="bp">∀</span> <span class="n">x</span> <span class="n">z</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">b</span><span class="o">,</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="n">a</span> <span class="bp">∧</span> <span class="n">y</span> <span class="bp">&lt;</span> <span class="n">b</span>
</code></pre></div>
<ul>
<li>We start with an expression for <code>P</code> that has <code>a</code> a free variable (referring to something external) and <code>b</code> a bound variable, and the parameters <code>u</code> and <code>v</code>.</li>
<li>In the final result, <code>a</code> should still be a free variable: therefore it must not clash with the binders it was placed under, namely <code>x</code> and <code>z</code></li>
<li>Additionally, <code>x</code> and <code>y</code> were not previously under the <code>b</code> binder but have been moved under it in the result, thus they also must not clash</li>
</ul>



<a name="270509800"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270509800" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270509800">(Feb 03 2022 at 07:30)</a>:</h4>
<p>Basically any time we have an expression in an outer context with some free variables in it and we want to insert it somewhere under a binder, none of the free variables can clash with the binder</p>



<a name="270509973"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270509973" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270509973">(Feb 03 2022 at 07:33)</a>:</h4>
<p>This happens twice in the example, we took the expression <code>λ u v, ∀ b, u &lt; a ∧ v &lt; b</code> with free variable <code>a</code> and moved it under the binders <code>∀ x z, </code> so <code>a</code> must not clash with <code>x, z</code>, and then we took the expressions <code>x, y</code> with free variables <code>x, y</code> and moved them under the binder <code>∀ b,</code> so <code>b</code> must not clash with <code>x, y</code></p>



<a name="270510058"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270510058" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270510058">(Feb 03 2022 at 07:34)</a>:</h4>
<p>I'm not sure if I have ever seen that kind of substitution before.</p>



<a name="270510100"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270510100" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270510100">(Feb 03 2022 at 07:35)</a>:</h4>
<p>In higher order logic we would only do the first part, substituting <code>P := λ u v, ∀ b, u &lt; a ∧ v &lt; b</code> and resulting in</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">∀</span> <span class="n">x</span> <span class="n">z</span><span class="o">,</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">u</span> <span class="n">v</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">b</span><span class="o">,</span> <span class="n">u</span> <span class="bp">&lt;</span> <span class="n">a</span> <span class="bp">∧</span> <span class="n">v</span> <span class="bp">&lt;</span> <span class="n">b</span><span class="o">)(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span>
</code></pre></div>



<a name="270510122"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270510122" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270510122">(Feb 03 2022 at 07:35)</a>:</h4>
<p>we might beta reduce it later, resulting in more constraints / alpha renaming</p>



<a name="270510195"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270510195" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270510195">(Feb 03 2022 at 07:36)</a>:</h4>
<p>here we're trying to stick to first order so we always eliminate lambdas before they appear</p>



<a name="270510197"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270510197" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270510197">(Feb 03 2022 at 07:36)</a>:</h4>
<p>Free variables and parameters are not the same? What are parameters in my implementation, if I have any?</p>



<a name="270510209"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270510209" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270510209">(Feb 03 2022 at 07:36)</a>:</h4>
<p>hopefully my terminology is clear from the example</p>



<a name="270510227"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270510227" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270510227">(Feb 03 2022 at 07:37)</a>:</h4>
<p><code>a</code> is a free variable, <code>u</code> is a parameter</p>



<a name="270510246"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270510246" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270510246">(Feb 03 2022 at 07:37)</a>:</h4>
<p>which is to say, it is a "bound variable" bound by the lambda</p>



<a name="270510255"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270510255" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270510255">(Feb 03 2022 at 07:37)</a>:</h4>
<p>even though we don't have any explicit lambda here</p>



<a name="270510342"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270510342" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270510342">(Feb 03 2022 at 07:39)</a>:</h4>
<p>in my code earlier, the parameters are the <code>[String]</code> in the <code>M.Map String ([String], Int)</code> of the formula substitution map</p>



<a name="270510382"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270510382" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270510382">(Feb 03 2022 at 07:39)</a>:</h4>
<p>Is there a dependent type here? There are both lambdas and a forall?</p>



<a name="270510454"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270510454" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270510454">(Feb 03 2022 at 07:40)</a>:</h4>
<p>Lambda isn't formally a part of the syntax, but we are substituting for a predicate so there is morally a lambda involved</p>



<a name="270510503"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270510503" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270510503">(Feb 03 2022 at 07:41)</a>:</h4>
<p>I've been writing these predicate substitutions as <code>P(u, v) := ∀ b, u &lt; a ∧ v &lt; b</code> or <code>P := λ u v, ∀ b, u &lt; a ∧ v &lt; b</code></p>



<a name="270510551"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270510551" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270510551">(Feb 03 2022 at 07:42)</a>:</h4>
<p>lambda only appears at the top level here, the syntax is a list of variable names followed by a formula</p>



<a name="270510583"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270510583" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270510583">(Feb 03 2022 at 07:42)</a>:</h4>
<p>like <code>([u, v], ∀ b, u &lt; a ∧ v &lt; b)</code></p>



<a name="270510709"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270510709" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270510709">(Feb 03 2022 at 07:44)</a>:</h4>
<p>I mean, is there a parameter in the definition I have of <code>Formula</code>? Is it the variable name after the <code>Forall</code>?</p>



<a name="270510752"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270510752" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270510752">(Feb 03 2022 at 07:45)</a>:</h4>
<p>no, I'm using the term parameter just for the lambda-bound arguments</p>



<a name="270510761"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270510761" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270510761">(Feb 03 2022 at 07:45)</a>:</h4>
<p>the variables in a forall are just bound variables</p>



<a name="270510786"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270510786" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270510786">(Feb 03 2022 at 07:45)</a>:</h4>
<p>so <code>b</code> is a bound variable in the running example</p>



<a name="270510895"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270510895" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270510895">(Feb 03 2022 at 07:47)</a>:</h4>
<p>I guess I'm not sure what lambda bound means here. Do I have to extend the <code>Formula</code> def?</p>



<a name="270510900"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270510900" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270510900">(Feb 03 2022 at 07:47)</a>:</h4>
<p>no</p>



<a name="270510985"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270510985" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270510985">(Feb 03 2022 at 07:48)</a>:</h4>
<p>A predicate substitution consists of a variable to replace, <code>P</code>, a list of variables <code>[u, v]</code>, and a formula <code>∀ b, u &lt; a ∧ v &lt; b</code></p>



<a name="270510997"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270510997" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270510997">(Feb 03 2022 at 07:49)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/270510503">said</a>:</p>
<blockquote>
<p>I've been writing these predicate substitutions as <code>P(u, v) := ∀ b, u &lt; a ∧ v &lt; b</code> or <code>P := λ u v, ∀ b, u &lt; a ∧ v &lt; b</code></p>
</blockquote>



<a name="270511090"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270511090" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270511090">(Feb 03 2022 at 07:50)</a>:</h4>
<p>So you just decide which variables are going to be parameters when you decide to do a substitution?</p>



<a name="270511096"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270511096" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270511096">(Feb 03 2022 at 07:50)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/270510342">said</a>:</p>
<blockquote>
<p>in my code earlier, the parameters are the <code>[String]</code> in the <code>M.Map String ([String], Int)</code> of the formula substitution map</p>
</blockquote>



<a name="270511144"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270511144" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270511144">(Feb 03 2022 at 07:51)</a>:</h4>
<p>you get to make a new formula substitution map any time you apply a lemma</p>



<a name="270511197"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270511197" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270511197">(Feb 03 2022 at 07:52)</a>:</h4>
<p>so the parameters can be different if you want</p>



<a name="270511207"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270511207" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270511207">(Feb 03 2022 at 07:52)</a>:</h4>
<p>the formula will usually be different too</p>



<a name="270511269"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270511269" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270511269">(Feb 03 2022 at 07:53)</a>:</h4>
<p>But it has to be a well formed formula right?</p>



<a name="270511301"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270511301" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270511301">(Feb 03 2022 at 07:53)</a>:</h4>
<p>Can we go step by step for what gets replaced by what?</p>



<a name="270511409"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270511409" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270511409">(Feb 03 2022 at 07:55)</a>:</h4>
<p>Suppose I have the predicate <code>Pred "P" [Var (x), (Func "f" [Var "y"])]</code> I guess.</p>



<a name="270511491"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270511491" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270511491">(Feb 03 2022 at 07:56)</a>:</h4>
<p>Although maybe that is not a proof scheme, so it doesn't work.</p>



<a name="270511643"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270511643" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270511643">(Feb 03 2022 at 07:58)</a>:</h4>
<p>Can you substitute into predicates over arbitrary terms or just predicates of individual variables. Like I think I have only seen substitutions into things like P(x,y)?</p>



<a name="270511769"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270511769" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270511769">(Feb 03 2022 at 08:00)</a>:</h4>
<p>I'm sorry, maybe I need a more detailed paper or textbook or something.</p>



<a name="270511831"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270511831" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270511831">(Feb 03 2022 at 08:00)</a>:</h4>
<p>This kind of substitution is new to me, I think.</p>



<a name="270512694"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270512694" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270512694">(Feb 03 2022 at 08:11)</a>:</h4>
<p>Is there some kind of arbitrary predicate that we can only replace? We can't replace specific predicates like "x &lt; y" with something like "x = y" right?</p>



<a name="270513396"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270513396" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270513396">(Feb 03 2022 at 08:20)</a>:</h4>
<p>I changed <code>x</code> to <code>f(x)</code> in the example to emphasize that <code>P</code> is being applied to terms not variables</p>



<a name="270513424"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270513424" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270513424">(Feb 03 2022 at 08:21)</a>:</h4>
<p><code>u</code> is a variable, but <code>P(f(x), y)</code> can have arbitrary terms there</p>



<a name="270513584"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270513584" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270513584">(Feb 03 2022 at 08:22)</a>:</h4>
<p><span class="user-mention silent" data-user-id="139442">Patrick Thomas</span> <a href="#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/270512694">said</a>:</p>
<blockquote>
<p>Is there some kind of arbitrary predicate that we can only replace? We can't replace specific predicates like "x &lt; y" with something like "x = y" right?</p>
</blockquote>
<p>Ah, yes you might need to distinguish these since you haven't been doing so thus far. There are predicate constants and predicate variables and you can only substitute for variables</p>



<a name="270513605"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270513605" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270513605">(Feb 03 2022 at 08:22)</a>:</h4>
<p><code>&lt;</code> is a predicate constant</p>



<a name="270513657"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270513657" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270513657">(Feb 03 2022 at 08:23)</a>:</h4>
<p>definitions produce new predicate constants, and axiomatic constants like <code>=</code> are also constants</p>



<a name="270513792"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270513792" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270513792">(Feb 03 2022 at 08:24)</a>:</h4>
<p>The code that you wrote <a href="#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/270507252">before</a> for the <code>Pred name ts</code> case is appropriate for predicate constants</p>



<a name="270514019"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270514019" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270514019">(Feb 03 2022 at 08:27)</a>:</h4>
<p>Hmm. Ok. How would my data types change? What is an appropriate constructor for a predicate variable?</p>



<a name="270514095"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270514095" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270514095">(Feb 03 2022 at 08:28)</a>:</h4>
<p>same as constants</p>



<a name="270514132"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270514132" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270514132">(Feb 03 2022 at 08:28)</a>:</h4>
<p>the only difference is that variables are substituted and constants aren't</p>



<a name="270514200"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270514200" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270514200">(Feb 03 2022 at 08:29)</a>:</h4>
<p>So they can take arbitrary terms, not just <code>Var</code>?</p>



<a name="270514211"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270514211" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270514211">(Feb 03 2022 at 08:29)</a>:</h4>
<p>yes</p>



<a name="270514230"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270514230" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270514230">(Feb 03 2022 at 08:29)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/270513424">said</a>:</p>
<blockquote>
<p><code>u</code> is a variable, but <code>P(f(x), y)</code> can have arbitrary terms there</p>
</blockquote>



<a name="270514493"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270514493" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270514493">(Feb 03 2022 at 08:32)</a>:</h4>
<p>How do you distinguish them in the code? I mean, I have no real data type for axiomatic constants right?</p>



<a name="270514712"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270514712" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270514712">(Feb 03 2022 at 08:35)</a>:</h4>
<p>Can we go more slowly through an example substitution using the notation from the code?</p>



<a name="270515076"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270515076" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270515076">(Feb 03 2022 at 08:38)</a>:</h4>
<p>Actually, I should probably go to sleep. Thank you for your patience.</p>



<a name="270515087"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270515087" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270515087">(Feb 03 2022 at 08:38)</a>:</h4>
<p>I don't really want to drag this out on a public channel</p>



<a name="270515134"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270515134" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270515134">(Feb 03 2022 at 08:39)</a>:</h4>
<p>Ok.</p>



<a name="270515157"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270515157" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270515157">(Feb 03 2022 at 08:39)</a>:</h4>
<p>Sorry.</p>



<a name="270515204"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270515204" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270515204">(Feb 03 2022 at 08:40)</a>:</h4>
<p>Thank you for your time.</p>



<a name="270515287"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270515287" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270515287">(Feb 03 2022 at 08:40)</a>:</h4>
<p>perhaps you should PM me or we can have a video discussion or something, I just don't want the hundreds of other people who read #general to deal with it if it isn't of general interest</p>



<a name="270515355"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270515355" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270515355">(Feb 03 2022 at 08:41)</a>:</h4>
<p>I'm not against discussing this stuff for far longer than appropriate but I should probably moderate at some point</p>



<a name="270515451"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270515451" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270515451">(Feb 03 2022 at 08:42)</a>:</h4>
<p>:) Ok. I'll see what I can find for texts, papers first.</p>



<a name="270516930"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270516930" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Trebor Huang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270516930">(Feb 03 2022 at 08:56)</a>:</h4>
<p>Apart from efficiency concerns, there's actually no need to distinguish <code>&lt;</code> as constants. They <strong>can</strong> be replaced, as long as you are also replacing them consistently in the axioms.</p>



<a name="270517018"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270517018" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Trebor Huang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270517018">(Feb 03 2022 at 08:57)</a>:</h4>
<p>So declaring <code>&lt;</code> as a constant serves only to say "hey, this thing is present in the axioms, so you can't just replace it without touching the axioms".</p>



<a name="270517487"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270517487" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270517487">(Feb 03 2022 at 09:01)</a>:</h4>
<p>You definitely can't replace definitions, you might have used the definition in the proof</p>



<a name="270517615"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270517615" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270517615">(Feb 03 2022 at 09:02)</a>:</h4>
<p>You can't replace axiomatic constants either since they might be used in axioms (e.g. replace <code>=</code> with <code>&lt;</code> in <code>x = x</code>)</p>



<a name="270517702"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/270517702" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#270517702">(Feb 03 2022 at 09:03)</a>:</h4>
<p>That is, I think this only works if you don't have a concept of "global context" which is not subject to substitution</p>



<a name="285194183"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/285194183" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#285194183">(Jun 07 2022 at 01:43)</a>:</h4>
<p>Given this definition:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">interpretation</span> <span class="o">(</span><span class="n">domain</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">nonempty</span> <span class="o">:</span> <span class="n">nonempty</span> <span class="n">domain</span><span class="o">)</span>
<span class="o">(</span><span class="n">func</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">string</span> <span class="bp">→</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">domain</span><span class="o">)</span> <span class="bp">→</span> <span class="n">domain</span><span class="o">)</span>
<span class="o">(</span><span class="n">pred</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">string</span> <span class="bp">→</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">domain</span><span class="o">)</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
</code></pre></div>
<p>If I have an instance <code>m</code> of <code>interpretation</code> and a function <code>s : string -&gt; string</code>, is there a way to create a new instance <code>m'</code> of <code>interpretation</code> such that <code>m'.nonempty = m.nonempty</code>, <code>m'.func = m.func</code> and if <code>m.pred = 0 p terms</code> then <code>m'.pred = 0 (s p) terms</code> and is <code>m.pred</code> for <code>n != 0</code>?</p>
<p>I am trying to prove this: <a href="https://github.com/pthomas505/lean3/blob/ba0e7d74687a84729d8f0bf1db9c186c89c63937/src/metalogic/pred.lean#L1648">https://github.com/pthomas505/lean3/blob/ba0e7d74687a84729d8f0bf1db9c186c89c63937/src/metalogic/pred.lean#L1648</a></p>



<a name="285476036"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/285476036" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#285476036">(Jun 09 2022 at 01:53)</a>:</h4>
<p>Should this theorem hold?</p>



<a name="285482117"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/285482117" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#285482117">(Jun 09 2022 at 03:41)</a>:</h4>
<p>that theorem is only true in the forward direction. For example, <code>P -&gt; Q</code> is not a tautology but a substitution instance of it is <code>P -&gt; P</code> which is a tautology</p>



<a name="285482296"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/285482296" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#285482296">(Jun 09 2022 at 03:44)</a>:</h4>
<p>I see. So just <code>is_valid P -&gt; is_valid (sub_prop s P)</code> holds?</p>



<a name="285482335"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/285482335" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#285482335">(Jun 09 2022 at 03:45)</a>:</h4>
<p>Ok.</p>



<a name="285482532"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/285482532" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#285482532">(Jun 09 2022 at 03:49)</a>:</h4>
<p>Thank you.</p>



<a name="285482742"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/285482742" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#285482742">(Jun 09 2022 at 03:53)</a>:</h4>
<p>Should <code>s</code> be of type <code>string -&gt; string</code> or <code>string -&gt; formula</code>? I'm guessing the latter, based on the propositional calculus case.</p>



<a name="285486736"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/285486736" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#285486736">(Jun 09 2022 at 05:06)</a>:</h4>
<p>Hmm, I need to check for variable capture then.</p>



<a name="285631761"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/285631761" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#285631761">(Jun 10 2022 at 05:07)</a>:</h4>
<p>I was wondering if anyone could help me figure out how to show that <code>term</code> and <code>formula</code> are instances of <code>decidable_eq</code>? If I add <code>@[derive decidable_eq]</code> in front of the definition of <code>term</code> I get:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">invalid</span> <span class="n">user</span> <span class="n">defined</span> <span class="n">recursor</span><span class="o">,</span> <span class="n">motive</span> <span class="n">result</span> <span class="n">sort</span> <span class="n">must</span> <span class="n">be</span> <span class="kt">Prop</span> <span class="n">or</span> <span class="kt">Type</span><span class="bp">.</span><span class="o">{</span><span class="n">l</span><span class="o">}</span> <span class="n">where</span> <span class="n">l</span> <span class="n">is</span> <span class="n">a</span> <span class="kd">universe</span> <span class="kd">parameter</span>
</code></pre></div>
<p>If I add it in front of the definition of <code>formula</code> I get:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">mk_dec_eq_instance</span> <span class="n">failed</span><span class="o">,</span> <span class="n">failed</span> <span class="n">to</span> <span class="n">generate</span> <span class="kd">instance</span> <span class="n">for</span>
  <span class="bp">Π</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">term</span><span class="o">),</span> <span class="n">decidable</span> <span class="o">(</span><span class="n">a</span> <span class="bp">=</span> <span class="n">b</span><span class="o">)</span>
</code></pre></div>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.finset</span>

<span class="kd">inductive</span> <span class="n">term</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">var</span> <span class="o">:</span> <span class="n">string</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">func</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">string</span> <span class="bp">→</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">term</span><span class="o">)</span> <span class="bp">→</span> <span class="n">term</span>

<span class="kn">open</span> <span class="n">term</span>

<span class="kd">inductive</span> <span class="n">formula</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">bottom</span> <span class="o">:</span> <span class="n">formula</span>
<span class="bp">|</span> <span class="n">top</span> <span class="o">:</span> <span class="n">formula</span>
<span class="bp">|</span> <span class="n">atom</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">string</span> <span class="bp">→</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">term</span><span class="o">)</span> <span class="bp">→</span> <span class="n">formula</span>
<span class="bp">|</span> <span class="n">not</span> <span class="o">:</span> <span class="n">formula</span> <span class="bp">→</span> <span class="n">formula</span>
<span class="bp">|</span> <span class="n">and</span> <span class="o">:</span> <span class="n">formula</span> <span class="bp">→</span> <span class="n">formula</span> <span class="bp">→</span> <span class="n">formula</span>
<span class="bp">|</span> <span class="n">or</span> <span class="o">:</span> <span class="n">formula</span> <span class="bp">→</span> <span class="n">formula</span> <span class="bp">→</span> <span class="n">formula</span>
<span class="bp">|</span> <span class="n">imp</span> <span class="o">:</span> <span class="n">formula</span> <span class="bp">→</span> <span class="n">formula</span> <span class="bp">→</span> <span class="n">formula</span>
<span class="bp">|</span> <span class="n">iff</span> <span class="o">:</span> <span class="n">formula</span> <span class="bp">→</span> <span class="n">formula</span> <span class="bp">→</span> <span class="n">formula</span>
<span class="bp">|</span> <span class="n">forall_</span> <span class="o">:</span> <span class="n">string</span> <span class="bp">→</span> <span class="n">formula</span> <span class="bp">→</span> <span class="n">formula</span>
<span class="bp">|</span> <span class="n">exists_</span> <span class="o">:</span> <span class="n">string</span> <span class="bp">→</span> <span class="n">formula</span> <span class="bp">→</span> <span class="n">formula</span>
</code></pre></div>



<a name="286255578"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/286255578" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#286255578">(Jun 15 2022 at 18:40)</a>:</h4>
<p>I don't know if the default derive handler can really be expected to do this. It relies on the fact that <code>fin</code> is a fintype naturally.<br>
Here is a proof anyways, would be great if it can be improved but it is the best I could do</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.finset</span>

<span class="kd">inductive</span> <span class="n">term</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">var</span> <span class="o">:</span> <span class="n">string</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">func</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">string</span> <span class="bp">→</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">term</span><span class="o">)</span> <span class="bp">→</span> <span class="n">term</span>


<span class="kd">variables</span> <span class="o">{</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">}</span>
<span class="kd">def</span> <span class="n">pi_decide</span> <span class="o">[</span><span class="n">decidable</span> <span class="n">p</span><span class="o">]</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">decidable</span> <span class="n">q</span><span class="o">)</span> <span class="o">:</span> <span class="n">decidable</span> <span class="o">(</span><span class="n">p</span> <span class="bp">∧</span> <span class="n">q</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">if</span> <span class="n">hp</span> <span class="o">:</span> <span class="n">p</span> <span class="k">then</span>
  <span class="kd">by</span> <span class="n">haveI</span> <span class="o">:=</span> <span class="n">h</span> <span class="n">hp</span><span class="bp">;</span> <span class="n">exact</span>
  <span class="k">if</span> <span class="n">hq</span> <span class="o">:</span> <span class="n">q</span> <span class="k">then</span> <span class="n">is_true</span> <span class="o">⟨</span><span class="n">hp</span><span class="o">,</span> <span class="n">hq</span><span class="o">⟩</span>
  <span class="k">else</span> <span class="n">is_false</span> <span class="o">(</span><span class="k">assume</span> <span class="n">h</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">∧</span> <span class="n">q</span><span class="o">,</span> <span class="n">hq</span> <span class="o">(</span><span class="n">and.right</span> <span class="n">h</span><span class="o">))</span>
<span class="k">else</span> <span class="n">is_false</span> <span class="o">(</span><span class="k">assume</span> <span class="n">h</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">∧</span> <span class="n">q</span><span class="o">,</span> <span class="n">hp</span> <span class="o">(</span><span class="n">and.left</span> <span class="n">h</span><span class="o">))</span>

<span class="kn">open</span> <span class="n">term</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">decidable_eq</span> <span class="n">term</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">var</span> <span class="n">s₁</span><span class="o">)</span> <span class="o">(</span><span class="n">var</span> <span class="n">s₂</span><span class="o">)</span> <span class="o">:=</span> <span class="n">decidable_of_decidable_of_iff</span> <span class="o">(</span><span class="kd">by</span> <span class="n">apply_instance</span> <span class="o">:</span> <span class="n">decidable</span> <span class="o">(</span><span class="n">s₁</span> <span class="bp">=</span> <span class="n">s₂</span><span class="o">))</span> <span class="o">(</span><span class="kd">by</span> <span class="n">simp</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">var</span> <span class="n">s</span><span class="o">)</span> <span class="o">(</span><span class="n">func</span> <span class="n">n</span> <span class="n">s'</span> <span class="n">t</span><span class="o">)</span> <span class="o">:=</span> <span class="n">is_false</span> <span class="o">(</span><span class="kd">by</span> <span class="n">simp</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">func</span> <span class="n">n</span> <span class="n">s'</span> <span class="n">t</span><span class="o">)</span> <span class="o">(</span><span class="n">var</span> <span class="n">s</span><span class="o">)</span> <span class="o">:=</span> <span class="n">is_false</span> <span class="o">(</span><span class="kd">by</span> <span class="n">simp</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">func</span> <span class="n">n₁</span> <span class="n">s₁</span> <span class="n">t₁</span><span class="o">)</span> <span class="o">(</span><span class="n">func</span> <span class="n">n₂</span> <span class="n">s₂</span> <span class="n">t₂</span><span class="o">)</span> <span class="o">:=</span> <span class="n">decidable_of_decidable_of_iff</span>
  <span class="o">(</span><span class="kd">begin</span>
    <span class="n">apply'</span> <span class="n">pi_decide</span><span class="o">,</span>
    <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">apply'</span> <span class="n">and.decidable</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">fin.heq_fun_iff</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">apply'</span> <span class="n">fintype.decidable_forall_fintype</span><span class="o">,</span>
    <span class="n">intro</span> <span class="n">a</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">term.decidable_eq</span><span class="o">,</span>
  <span class="kd">end</span> <span class="o">:</span> <span class="n">decidable</span> <span class="bp">$</span> <span class="n">n₁</span> <span class="bp">=</span> <span class="n">n₂</span> <span class="bp">∧</span> <span class="n">s₁</span> <span class="bp">=</span> <span class="n">s₂</span> <span class="bp">∧</span> <span class="n">t₁</span> <span class="bp">==</span> <span class="n">t₂</span><span class="o">)</span> <span class="o">(</span><span class="kd">by</span> <span class="n">simp</span><span class="o">)</span>


<span class="k">#eval</span> <span class="n">to_bool</span> <span class="bp">$</span> <span class="n">term.func</span> <span class="mi">2</span> <span class="s2">"f"</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">term.var</span> <span class="s2">"x"</span><span class="o">)</span> <span class="bp">=</span>
      <span class="n">term.func</span> <span class="o">(</span><span class="mi">1</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="s2">"f"</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">term.var</span> <span class="s2">"y"</span><span class="o">)</span>

<span class="kn">open</span> <span class="n">term</span>

<span class="kd">@[derive decidable_eq]</span>
<span class="kd">inductive</span> <span class="n">formula</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">bottom</span> <span class="o">:</span> <span class="n">formula</span>
<span class="bp">|</span> <span class="n">top</span> <span class="o">:</span> <span class="n">formula</span>
<span class="bp">|</span> <span class="n">atom</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">string</span> <span class="bp">→</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">term</span><span class="o">)</span> <span class="bp">→</span> <span class="n">formula</span>
<span class="bp">|</span> <span class="n">not</span> <span class="o">:</span> <span class="n">formula</span> <span class="bp">→</span> <span class="n">formula</span>
<span class="bp">|</span> <span class="n">and</span> <span class="o">:</span> <span class="n">formula</span> <span class="bp">→</span> <span class="n">formula</span> <span class="bp">→</span> <span class="n">formula</span>
<span class="bp">|</span> <span class="n">or</span> <span class="o">:</span> <span class="n">formula</span> <span class="bp">→</span> <span class="n">formula</span> <span class="bp">→</span> <span class="n">formula</span>
<span class="bp">|</span> <span class="n">imp</span> <span class="o">:</span> <span class="n">formula</span> <span class="bp">→</span> <span class="n">formula</span> <span class="bp">→</span> <span class="n">formula</span>
<span class="bp">|</span> <span class="n">iff</span> <span class="o">:</span> <span class="n">formula</span> <span class="bp">→</span> <span class="n">formula</span> <span class="bp">→</span> <span class="n">formula</span>
<span class="bp">|</span> <span class="n">forall_</span> <span class="o">:</span> <span class="n">string</span> <span class="bp">→</span> <span class="n">formula</span> <span class="bp">→</span> <span class="n">formula</span>
<span class="bp">|</span> <span class="n">exists_</span> <span class="o">:</span> <span class="n">string</span> <span class="bp">→</span> <span class="n">formula</span> <span class="bp">→</span> <span class="n">formula</span>
</code></pre></div>
<p><span class="user-mention" data-user-id="139442">@Patrick Thomas</span></p>



<a name="286298120"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/286298120" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#286298120">(Jun 16 2022 at 02:05)</a>:</h4>
<p>Thank you!</p>



<a name="286630323"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/286630323" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#286630323">(Jun 18 2022 at 05:21)</a>:</h4>
<p><a href="https://proofassistants.stackexchange.com/questions/1537/creating-a-proof-assistant-for-first-order-logic-in-haskell">https://proofassistants.stackexchange.com/questions/1537/creating-a-proof-assistant-for-first-order-logic-in-haskell</a></p>



<a name="286659768"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/286659768" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#286659768">(Jun 18 2022 at 16:43)</a>:</h4>
<p>Is there an implementation in Lean or Haskell of the algorithm that Lean uses for the locally nameless representation?</p>



<a name="286659925"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/286659925" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#286659925">(Jun 18 2022 at 16:46)</a>:</h4>
<p>I would like to try to see how that translates to a representation for FOL.</p>



<a name="286841987"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/286841987" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#286841987">(Jun 20 2022 at 21:54)</a>:</h4>
<p>Is there a way to simplify these, for example if there exist definitions in mathlib that avoid the need to convert the fin function to a list?<br>
<a href="https://github.com/pthomas505/lean3/blob/06c3f0981ed301f4c4e5c447cb648e33a17e2fcd/src/metalogic/pred.lean#L2593-L2702">https://github.com/pthomas505/lean3/blob/06c3f0981ed301f4c4e5c447cb648e33a17e2fcd/src/metalogic/pred.lean#L2593-L2702</a></p>



<a name="286842359"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/286842359" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#286842359">(Jun 20 2022 at 22:00)</a>:</h4>
<p>I don't look forward to trying to prove things about them as they are :)</p>



<a name="289059673"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/289059673" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#289059673">(Jul 09 2022 at 19:57)</a>:</h4>
<p>I'm trying to formalize the substitution of predicates as described <a href="https://math.stackexchange.com/questions/1374736/is-there-a-rule-for-uniform-substitution-of-predicate-symbols-in-fol/1374989#1374989">here</a> and then prove that this substitution preserves the validity of formulas. I'm wondering if anyone has any advice on how to go about doing this. Is there a proof somewhere, either formal or informal?</p>



<a name="289059687"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/289059687" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#289059687">(Jul 09 2022 at 19:57)</a>:</h4>
<p>I have been having a hard time finding references to it, and I'm not sure why.</p>



<a name="289059748"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP%20for%20FOL%20%2B%20ZFC/near/289059748" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC.html#289059748">(Jul 09 2022 at 19:59)</a>:</h4>
<p>My code base is <a href="https://github.com/pthomas505/lean3/blob/d892151aa112dd27bdf2cbaf11efec89d8ddb9f0/src/metalogic/pred.lean">here</a>.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
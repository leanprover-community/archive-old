---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/restrict_scalars.20vs.20enrich_scalars.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/restrict_scalars.20vs.20enrich_scalars.html">restrict_scalars vs enrich_scalars</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="241172703"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/restrict_scalars%20vs%20enrich_scalars/near/241172703" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/restrict_scalars.20vs.20enrich_scalars.html#241172703">(Jun 02 2021 at 16:18)</a>:</h4>
<p>I just opened <a href="https://github.com/leanprover-community/mathlib/issues/7807">#7807</a> in which I propose adding a trivial (but useful!) equiv. While I was there I decided to update a doc string and as a result of writing it I now wonder if we could save some confusion by renaming what we currently call <code>restrict_scalars</code> to <code>enrich_scalars</code>.</p>



<a name="241172829"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/restrict_scalars%20vs%20enrich_scalars/near/241172829" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/restrict_scalars.20vs.20enrich_scalars.html#241172829">(Jun 02 2021 at 16:19)</a>:</h4>
<p>Here's the relevant doc string:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/-- A type synonym representing the functor from the category of modules over `A`, regarded as a</span>
<span class="sd">(semi)ring, to the category of modules over `A`, regarded as an `R`-algebra.</span>

<span class="sd">Warning: use this type synonym judiciously! Often what one wants instead of `restrict_scalars` is</span>
<span class="sd">actually the following setup:</span>
<span class="sd">`[comm_semiring R] [semiring A] [algebra R A] [module R M] [module A M] [is_scalar_tower R A M]` (*)</span>
<span class="sd">which is just the way of saying "let `M` be a module over the `R`-algebra `A`".</span>

<span class="sd">Mathematically, when `A` is an `R`-algebra, there are two different functors:</span>
<span class="sd"> 1. The functor from the category of modules over the (semi)ring `A` to the category of modules over</span>
<span class="sd">    the `R`-algebra `A`. This is what is defined here, and is called `restrict_scalars` (though</span>
<span class="sd">    perhaps a better name would be `enrich_scalars`).</span>
<span class="sd"> 2. The functor from the category of modules over the `R`-algebra `A` to the category of modules</span>
<span class="sd">    over the (semi)ring `R`. This is the true restriction of scalars but when one uses the setup (*)</span>
<span class="sd">    above, it is invisible functor available for free through typeclass inference.</span>

<span class="sd">A standard example of when one might want to invoke 1 would be if one has a vector space over a</span>
<span class="sd">field of characteristic zero and wishes to make use of the `ℚ`-algebra structure. -/</span>
<span class="kd">@[nolint unused_arguments]</span>
<span class="kd">def</span> <span class="n">restrict_scalars</span> <span class="o">(</span><span class="n">R</span> <span class="n">A</span> <span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span> <span class="o">:=</span> <span class="n">M</span>
</code></pre></div>



<a name="241175209"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/restrict_scalars%20vs%20enrich_scalars/near/241175209" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/restrict_scalars.20vs.20enrich_scalars.html#241175209">(Jun 02 2021 at 16:37)</a>:</h4>
<p>Just to make things more confusing, I think <a href="https://leanprover-community.github.io/mathlib_docs/find/algebra.comap">docs#algebra.comap</a> is exactly the same as <a href="https://leanprover-community.github.io/mathlib_docs/find/restrict_scalars">docs#restrict_scalars</a></p>



<a name="241175294"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/restrict_scalars%20vs%20enrich_scalars/near/241175294" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/restrict_scalars.20vs.20enrich_scalars.html#241175294">(Jun 02 2021 at 16:38)</a>:</h4>
<p>Or at least, they could be unified into the same type alias, because the structures they confer are defeq</p>



<a name="241175530"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/restrict_scalars%20vs%20enrich_scalars/near/241175530" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/restrict_scalars.20vs.20enrich_scalars.html#241175530">(Jun 02 2021 at 16:40)</a>:</h4>
<p>Yes, it's essentially the same.</p>



<a name="241175690"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/restrict_scalars%20vs%20enrich_scalars/near/241175690" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/restrict_scalars.20vs.20enrich_scalars.html#241175690">(Jun 02 2021 at 16:41)</a>:</h4>
<p>The pojnt of <code>restrict_scalars</code>, as I understand it, is not really to get a module over the <code>R</code>-algebra <code>A</code>, but mainly a module over <code>R</code>. And this operation is commonly called restriction of scalars, right?</p>



<a name="241175981"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/restrict_scalars%20vs%20enrich_scalars/near/241175981" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/restrict_scalars.20vs.20enrich_scalars.html#241175981">(Jun 02 2021 at 16:43)</a>:</h4>
<p>Well I think it depends. What <code>restrict_scalars</code> actually provides is a module over the <code>R</code>-algebra <code>A</code>. Because of how we set things up, once you have a module over an <code>R</code>-algebra <code>A</code>, you can invisibly restrict scalars to get an <code>R</code>-module. However I don't know what the person who invokes it wants until they use it.</p>



<a name="241176402"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/restrict_scalars%20vs%20enrich_scalars/near/241176402" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/restrict_scalars.20vs.20enrich_scalars.html#241176402">(Jun 02 2021 at 16:46)</a>:</h4>
<p>E.g., we could have some theorem somehwere which demands the following: <code>(K L V : Type*) [field K] [field L] [algebra K L] [add_comm_group V] [module K V] [module L V] [is_scalar_tower K L V]</code>.</p>



<a name="241176508"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/restrict_scalars%20vs%20enrich_scalars/near/241176508" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/restrict_scalars.20vs.20enrich_scalars.html#241176508">(Jun 02 2021 at 16:47)</a>:</h4>
<p>If we only have <code>[field L] [char_zero L] [add_comm_group V] [module L V]</code> then we can use such a theorem on <code>restrict_scalars ℚ L V</code>.</p>



<a name="241176534"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/restrict_scalars%20vs%20enrich_scalars/near/241176534" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/restrict_scalars.20vs.20enrich_scalars.html#241176534">(Jun 02 2021 at 16:47)</a>:</h4>
<p>So I claim that <code>restrict_scalars</code> is really _enriching_ the scalars.</p>



<a name="241176905"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/restrict_scalars%20vs%20enrich_scalars/near/241176905" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/restrict_scalars.20vs.20enrich_scalars.html#241176905">(Jun 02 2021 at 16:50)</a>:</h4>
<p>It's enriching them with extra typeclasses but restricting them to a type of (usually) smaller cardinality, right?</p>



<a name="241176994"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/restrict_scalars%20vs%20enrich_scalars/near/241176994" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/restrict_scalars.20vs.20enrich_scalars.html#241176994">(Jun 02 2021 at 16:51)</a>:</h4>
<p>I'm a little confused by the discussion above - isn't the whole point of <code>restrict_scalars R A M</code> to provide a <code>module R M</code> instance when only <code>module A M</code> is available?</p>



<a name="241177025"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/restrict_scalars%20vs%20enrich_scalars/near/241177025" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/restrict_scalars.20vs.20enrich_scalars.html#241177025">(Jun 02 2021 at 16:51)</a>:</h4>
<p>I agree that it is enriching the scalars, in the sense that instead of having one scalar field now we have two. But in most cases the new field <code>L</code> is a subfield of the original one <code>K</code>, so the new action consists in forgetting how a bunch of elements act (the ones in <code>K \ L</code>). In this sense, you are forgetting information, and I think that's why is called scalar restriction. In any case, it's standard math terminology, so I don't think it would make sense to change our naming here.</p>



<a name="241177215"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/restrict_scalars%20vs%20enrich_scalars/near/241177215" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/restrict_scalars.20vs.20enrich_scalars.html#241177215">(Jun 02 2021 at 16:53)</a>:</h4>
<p>I absolutely do not want to diverge from standard math terminology. In fact I want to get back to it since I think we are applying it incorrectly in this case and it causes confusion.</p>



<a name="241177430"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/restrict_scalars%20vs%20enrich_scalars/near/241177430" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/restrict_scalars.20vs.20enrich_scalars.html#241177430">(Jun 02 2021 at 16:55)</a>:</h4>
<blockquote>
<p>In this sense, you are forgetting information, </p>
</blockquote>
<p>well, for <code>[algebra L K] [module K M]</code>, the instance <code>module K (restrict_scalars L K M)</code> still exists, so the action of elements in <code>K \ L</code> hasn't been forgotten</p>



<a name="241177455"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/restrict_scalars%20vs%20enrich_scalars/near/241177455" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/restrict_scalars.20vs.20enrich_scalars.html#241177455">(Jun 02 2021 at 16:55)</a>:</h4>
<p>Right!</p>



<a name="241177648"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/restrict_scalars%20vs%20enrich_scalars/near/241177648" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/restrict_scalars.20vs.20enrich_scalars.html#241177648">(Jun 02 2021 at 16:57)</a>:</h4>
<p>Without any mathematical training to ground my interpretation, I read "restrict_scalars R A M" as <em>"provide <code>M</code> with a new action by the restricted "set" <code>R</code> of elements from <code>A</code>"</em></p>



<a name="241177661"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/restrict_scalars%20vs%20enrich_scalars/near/241177661" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/restrict_scalars.20vs.20enrich_scalars.html#241177661">(Jun 02 2021 at 16:57)</a>:</h4>
<p>I claim that mathematically, the data required to perform restriction of scalars is a module over an algebra. What we currently call <code>restrict_scalars</code> allows us to get this data if somehow (e.g., vector space over field of char 0) we are not explicitly in this situation and want to get there.</p>



<a name="241177694"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/restrict_scalars%20vs%20enrich_scalars/near/241177694" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/restrict_scalars.20vs.20enrich_scalars.html#241177694">(Jun 02 2021 at 16:57)</a>:</h4>
<p>Once we are there, we _may_ then use this data to restrict scalars or we may not.</p>



<a name="241177835"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/restrict_scalars%20vs%20enrich_scalars/near/241177835" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/restrict_scalars.20vs.20enrich_scalars.html#241177835">(Jun 02 2021 at 16:58)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/113488-general/topic/restrict_scalars.20vs.20enrich_scalars/near/241177648">said</a>:</p>
<blockquote>
<p>Without any mathematical training to ground my interpretation, I read "restrict_scalars R A M" as <em>"provide <code>M</code> with a new action by the restricted "set" <code>R</code> of elements from <code>A</code>"</em></p>
</blockquote>
<p>I agree with this. If everyone (except me) reads it this way then we're fine as we are.</p>



<a name="241177838"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/restrict_scalars%20vs%20enrich_scalars/near/241177838" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/restrict_scalars.20vs.20enrich_scalars.html#241177838">(Jun 02 2021 at 16:58)</a>:</h4>
<p>I'd note that probably <code>restrict_scalars</code> shouldn't  ever appear in a lemma or definition statement, only in a proof / implementation</p>



<a name="241177894"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/restrict_scalars%20vs%20enrich_scalars/near/241177894" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/restrict_scalars.20vs.20enrich_scalars.html#241177894">(Jun 02 2021 at 16:59)</a>:</h4>
<p>Technically I think it could but I agree that is the right rule of thumb.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/golfing.20.20challenge!.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/golfing.20.20challenge!.html">golfing  challenge!</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="245623552"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/golfing%20%20challenge%21/near/245623552" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hanting Zhang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/golfing.20.20challenge!.html#245623552">(Jul 11 2021 at 19:50)</a>:</h4>
<p>I'm currently fighting <code>supr/bsupr</code> and <code>finsupp.sum/finset.sum</code> and struggling. Is there any way to shorten these lemmas?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.finsupp.basic</span>
<span class="kn">import</span> <span class="n">data.finset.basic</span>
<span class="kn">import</span> <span class="n">linear_algebra.basic</span>

<span class="kn">open</span> <span class="n">finset</span>
<span class="n">open_locale</span> <span class="n">big_operators</span> <span class="n">classical</span>
<span class="kd">universes</span> <span class="n">u</span> <span class="n">v</span> <span class="n">w</span>

<span class="kd">theorem</span> <span class="n">bsupr_eq_supr</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">complete_lattice</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">α</span><span class="o">}</span>
  <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">:</span> <span class="o">(</span><span class="bp">⨆</span> <span class="n">i</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">p</span> <span class="n">i</span><span class="o">),</span> <span class="n">s</span> <span class="n">i</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">⨆</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">subtype</span> <span class="n">p</span><span class="o">),</span> <span class="n">s</span> <span class="n">i</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="gr">sorry</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">finsupp.sum_add_add</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span>
  <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→₀</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∑</span> <span class="n">a</span> <span class="k">in</span> <span class="o">(</span><span class="n">f</span> <span class="bp">+</span> <span class="n">g</span><span class="o">)</span><span class="bp">.</span><span class="n">support</span><span class="o">,</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">g</span> <span class="n">a</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">∑</span> <span class="n">a</span> <span class="k">in</span> <span class="n">f.support</span><span class="o">,</span> <span class="n">f</span> <span class="n">a</span> <span class="bp">+</span> <span class="bp">∑</span> <span class="n">a</span> <span class="k">in</span> <span class="n">g.support</span><span class="o">,</span> <span class="n">g</span> <span class="n">a</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">change</span> <span class="o">(</span><span class="n">f</span> <span class="bp">+</span> <span class="n">g</span><span class="o">)</span><span class="bp">.</span><span class="n">sum</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span> <span class="n">a</span><span class="o">,</span> <span class="n">a</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f.sum</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span> <span class="n">a</span><span class="o">,</span> <span class="n">a</span><span class="o">)</span> <span class="bp">+</span> <span class="n">g.sum</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span> <span class="n">a</span><span class="o">,</span> <span class="n">a</span><span class="o">),</span>
  <span class="n">rw</span> <span class="n">finsupp.sum_add_index</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">exact</span> <span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="n">rfl</span><span class="o">,</span> <span class="n">exact</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b₁</span> <span class="n">b₂</span><span class="o">,</span> <span class="n">rfl</span><span class="o">,</span>
<span class="kd">end</span>

<span class="c1">-- pretty atrocious but hey it works</span>
<span class="kd">lemma</span> <span class="n">mem_supr'</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span>
  <span class="o">{</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">w</span><span class="o">}</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">submodule</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">M</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">x</span> <span class="bp">∈</span> <span class="n">supr</span> <span class="n">p</span> <span class="bp">↔</span> <span class="bp">∃</span> <span class="n">v</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→₀</span> <span class="n">M</span><span class="o">,</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">v</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">p</span> <span class="n">i</span><span class="o">)</span> <span class="bp">∧</span> <span class="bp">∑</span> <span class="n">i</span> <span class="k">in</span> <span class="n">v.support</span><span class="o">,</span> <span class="n">v</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">x</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">classical</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">submodule.supr_eq_span</span><span class="o">,</span>
  <span class="n">refine</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
  <span class="n">refine</span> <span class="n">submodule.span_induction</span> <span class="n">h</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">y</span> <span class="n">hy</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">set.mem_Union</span> <span class="n">at</span> <span class="n">hy</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">hy</span> <span class="k">with</span> <span class="n">i</span> <span class="n">hy</span><span class="o">,</span>
    <span class="n">use</span> <span class="n">finsupp.single</span> <span class="n">i</span> <span class="n">y</span><span class="o">,</span>
    <span class="n">split</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">intro</span> <span class="n">j</span><span class="o">,</span> <span class="n">by_cases</span> <span class="n">h</span> <span class="o">:</span> <span class="n">j</span> <span class="bp">=</span> <span class="n">i</span><span class="o">,</span>
      <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">h</span><span class="o">,</span> <span class="n">finsupp.single_eq_same</span><span class="o">],</span> <span class="n">exact</span> <span class="n">hy</span><span class="o">,</span>
      <span class="n">rw</span> <span class="bp">←</span> <span class="n">ne.def</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
      <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">finsupp.single_eq_of_ne</span> <span class="n">h.symm</span><span class="o">,</span> <span class="n">submodule.zero_mem</span><span class="o">],</span> <span class="o">},</span>
    <span class="n">by_cases</span> <span class="n">hy</span> <span class="o">:</span> <span class="n">y</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">rw</span> <span class="n">hy</span><span class="o">,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">finsupp.coe_zero</span><span class="o">,</span> <span class="n">pi.zero_apply</span><span class="o">,</span> <span class="n">finsupp.single_zero</span><span class="o">,</span> <span class="n">finset.sum_const_zero</span><span class="o">],</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">finsupp.support_single_ne_zero</span> <span class="n">hy</span><span class="o">,</span> <span class="n">finset.sum_singleton</span><span class="o">],</span>
    <span class="n">exact</span> <span class="n">finsupp.single_eq_same</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">use</span> <span class="mi">0</span><span class="o">,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">finsupp.coe_zero</span><span class="o">,</span> <span class="n">pi.zero_apply</span><span class="o">,</span> <span class="n">implies_true_iff</span><span class="o">,</span> <span class="n">eq_self_iff_true</span><span class="o">,</span> <span class="n">and_self</span><span class="o">,</span>
      <span class="n">finset.sum_const_zero</span><span class="o">,</span> <span class="n">submodule.zero_mem</span><span class="o">],</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">x</span> <span class="n">y</span> <span class="n">hx</span> <span class="n">hy</span><span class="o">,</span>
    <span class="n">rcases</span> <span class="n">hx</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">v</span><span class="o">,</span> <span class="n">hv</span><span class="o">,</span> <span class="n">hvs</span><span class="o">⟩,</span>
    <span class="n">rcases</span> <span class="n">hy</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">w</span><span class="o">,</span> <span class="n">hw</span><span class="o">,</span> <span class="n">hws</span><span class="o">⟩,</span>
    <span class="n">use</span> <span class="n">v</span> <span class="bp">+</span> <span class="n">w</span><span class="o">,</span>
    <span class="n">refine</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">submodule.add_mem</span> <span class="n">_</span> <span class="o">(</span><span class="n">hv</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">hw</span> <span class="n">i</span><span class="o">),</span> <span class="n">_</span><span class="o">⟩,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">hvs</span><span class="o">,</span> <span class="bp">←</span> <span class="n">hws</span><span class="o">],</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">finsupp.add_apply</span><span class="o">],</span>
    <span class="n">convert</span> <span class="n">finsupp.sum_add_add</span> <span class="n">v</span> <span class="n">w</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">r</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span>
    <span class="n">rcases</span> <span class="n">hx</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">v</span><span class="o">,</span> <span class="n">hv</span><span class="o">,</span> <span class="n">hvs</span><span class="o">⟩,</span>
    <span class="n">use</span> <span class="n">r</span> <span class="bp">•</span> <span class="n">v</span><span class="o">,</span>
    <span class="n">refine</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">submodule.smul_mem</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="n">hv</span> <span class="n">i</span><span class="o">),</span> <span class="n">_</span><span class="o">⟩,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">hvs</span><span class="o">,</span> <span class="n">finset.smul_sum</span><span class="o">],</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">finsupp.smul_apply</span><span class="o">],</span>
    <span class="n">refine</span> <span class="n">finset.sum_subset</span> <span class="n">finsupp.support_smul</span>
      <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span> <span class="n">ha</span> <span class="n">han</span><span class="o">,</span> <span class="n">finsupp.not_mem_support_iff.mp</span> <span class="n">han</span><span class="o">)</span> <span class="o">},</span>
  <span class="n">rcases</span> <span class="n">h</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">v</span><span class="o">,</span> <span class="n">hv</span><span class="o">,</span> <span class="n">hvs</span><span class="o">⟩,</span>
  <span class="k">have</span> <span class="o">:=</span> <span class="n">submodule.sum_mem</span> <span class="o">(</span><span class="n">supr</span> <span class="n">p</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span> <span class="n">_</span><span class="o">,</span> <span class="o">(</span><span class="n">le_supr</span> <span class="n">p</span> <span class="n">i</span> <span class="o">:</span> <span class="n">p</span> <span class="n">i</span> <span class="bp">≤</span> <span class="n">supr</span> <span class="n">p</span><span class="o">)</span> <span class="o">(</span><span class="n">hv</span> <span class="n">i</span><span class="o">)),</span>
  <span class="n">rw</span> <span class="bp">←</span> <span class="n">submodule.supr_eq_span</span><span class="o">,</span>
  <span class="n">rwa</span> <span class="n">hvs</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span>
<span class="kd">end</span>

<span class="c1">-- **definitely** atrocious but hey it works</span>
<span class="kd">lemma</span> <span class="n">mem_bsupr</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span>
  <span class="o">{</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">w</span><span class="o">}</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">submodule</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">x</span> <span class="bp">∈</span> <span class="o">(</span><span class="bp">⨆</span> <span class="n">i</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">p</span> <span class="n">i</span><span class="o">),</span> <span class="n">f</span> <span class="n">i</span><span class="o">)</span> <span class="bp">↔</span>
  <span class="bp">∃</span> <span class="n">v</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→₀</span> <span class="n">M</span><span class="o">,</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">v</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">f</span> <span class="n">i</span><span class="o">)</span> <span class="bp">∧</span> <span class="bp">∑</span> <span class="n">i</span> <span class="k">in</span> <span class="n">v.support</span><span class="o">,</span> <span class="n">v</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">x</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="bp">¬</span> <span class="n">p</span> <span class="n">i</span> <span class="bp">→</span> <span class="n">v</span> <span class="n">i</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">classical</span><span class="o">,</span>
  <span class="n">change</span> <span class="n">set</span> <span class="n">ι</span> <span class="n">at</span> <span class="n">p</span><span class="o">,</span>
  <span class="n">refine</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="n">bsupr_eq_supr</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">rcases</span> <span class="o">(</span><span class="n">mem_supr'</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">mp</span> <span class="n">h</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">v'</span><span class="o">,</span> <span class="n">hv'</span><span class="o">,</span> <span class="n">hsum</span><span class="o">⟩,</span>
    <span class="n">change</span> <span class="n">p</span> <span class="bp">→₀</span> <span class="n">M</span> <span class="n">at</span> <span class="n">v'</span><span class="o">,</span>
    <span class="c1">-- define `v = v'` where `p i` is true and zero otherwise</span>
    <span class="k">let</span> <span class="n">v</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→₀</span> <span class="n">M</span> <span class="o">:=</span>
      <span class="o">⟨</span><span class="n">v'.support.map</span> <span class="o">(</span><span class="n">function.embedding.subtype</span> <span class="n">p</span><span class="o">),</span>
       <span class="bp">λ</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ι</span><span class="o">),</span> <span class="n">dite</span> <span class="o">(</span><span class="n">p</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">hi</span><span class="o">,</span> <span class="n">v'</span> <span class="o">⟨</span><span class="n">i</span><span class="o">,</span> <span class="n">hi</span><span class="o">⟩)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="mi">0</span><span class="o">),</span> <span class="n">_</span><span class="o">⟩,</span>
    <span class="n">refine</span> <span class="o">⟨</span><span class="n">v</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
    <span class="o">{</span> <span class="n">intros</span> <span class="n">i</span><span class="o">,</span>
      <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">finsupp.coe_mk</span><span class="o">],</span>
      <span class="n">split_ifs</span> <span class="k">with</span> <span class="n">hi</span><span class="o">,</span>
      <span class="o">{</span> <span class="n">exact</span> <span class="n">hv'</span> <span class="o">⟨</span><span class="n">i</span><span class="o">,</span> <span class="n">hi</span><span class="o">⟩</span> <span class="o">},</span>
      <span class="n">exact</span> <span class="n">submodule.zero_mem</span> <span class="n">_</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">finsupp.coe_mk</span><span class="o">,</span> <span class="n">dite_eq_ite</span><span class="o">,</span> <span class="n">function.embedding.coe_subtype</span><span class="o">,</span> <span class="n">finset.sum_map</span><span class="o">,</span>
        <span class="n">subtype.coe_eta</span><span class="o">],</span>
      <span class="n">convert</span> <span class="n">hsum</span><span class="o">,</span>
      <span class="n">ext</span> <span class="n">i</span><span class="o">,</span> <span class="n">split_ifs</span> <span class="k">with</span> <span class="n">hi</span><span class="o">,</span> <span class="n">refl</span><span class="o">,</span>
      <span class="n">exfalso</span><span class="o">,</span> <span class="n">apply</span> <span class="n">hi</span><span class="o">,</span> <span class="n">exact</span> <span class="n">i.2</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">intros</span> <span class="n">i</span> <span class="n">hi</span><span class="o">,</span>
      <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">finsupp.coe_mk</span><span class="o">,</span> <span class="n">dif_neg</span> <span class="n">hi</span><span class="o">],</span> <span class="o">},</span>
    <span class="n">intros</span> <span class="n">i</span><span class="o">,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">exists_prop</span><span class="o">,</span> <span class="n">function.embedding.coe_subtype</span><span class="o">,</span> <span class="n">set_coe.exists</span><span class="o">,</span> <span class="n">finset.mem_map</span><span class="o">,</span>
      <span class="n">exists_and_distrib_right</span><span class="o">,</span> <span class="n">exists_eq_right</span><span class="o">,</span> <span class="n">finsupp.mem_support_iff</span><span class="o">,</span> <span class="n">ne.def</span><span class="o">,</span> <span class="n">subtype.coe_mk</span><span class="o">],</span>
    <span class="n">split_ifs</span> <span class="k">with</span> <span class="n">hi</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">refine</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">hh</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">hh</span><span class="o">,</span> <span class="o">⟨</span><span class="n">hi</span><span class="o">,</span> <span class="n">hh</span><span class="o">⟩⟩,</span>
      <span class="n">cases</span> <span class="n">hh</span> <span class="k">with</span> <span class="n">_</span> <span class="n">key</span><span class="o">,</span> <span class="n">exact</span> <span class="n">key</span> <span class="o">},</span>
    <span class="n">refine</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">hh</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">hh</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
    <span class="o">{</span> <span class="n">cases</span> <span class="n">hh</span> <span class="k">with</span> <span class="n">key</span> <span class="n">_</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">hi</span> <span class="n">key</span> <span class="o">},</span>
    <span class="n">exfalso</span><span class="o">,</span> <span class="n">exact</span> <span class="n">hh</span> <span class="n">rfl</span> <span class="o">},</span>
  <span class="n">rcases</span> <span class="n">h</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">v</span><span class="o">,</span> <span class="n">hv</span><span class="o">,</span> <span class="n">hsum</span><span class="o">,</span> <span class="n">hzero</span><span class="o">⟩,</span>
  <span class="k">have</span> <span class="n">hle</span><span class="o">:</span> <span class="o">(</span><span class="bp">⨆</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">v.support</span><span class="o">,</span> <span class="n">f</span> <span class="n">i</span><span class="o">)</span> <span class="bp">≤</span> <span class="bp">⨆</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ι</span><span class="o">)</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">p</span> <span class="n">i</span><span class="o">),</span> <span class="n">f</span> <span class="n">i</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">refine</span> <span class="n">bsupr_le_bsupr'</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span> <span class="n">hi</span><span class="o">,</span> <span class="n">_</span><span class="o">),</span>
    <span class="n">revert</span> <span class="n">hi</span><span class="o">,</span> <span class="n">contrapose</span><span class="bp">!</span><span class="o">,</span>
    <span class="n">refine</span> <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">finsupp.not_mem_support_iff.mpr</span> <span class="o">(</span><span class="n">hzero</span> <span class="n">i</span> <span class="n">h</span><span class="o">),</span> <span class="o">},</span>
  <span class="k">have</span> <span class="n">key</span><span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="bp">⨆</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">v.support</span><span class="o">,</span> <span class="n">f</span> <span class="n">i</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="bp">←</span> <span class="n">hsum</span><span class="o">,</span> <span class="n">exact</span> <span class="n">submodule.sum_mem_bsupr</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span> <span class="n">hi</span><span class="o">,</span> <span class="n">hv</span> <span class="n">i</span><span class="o">),</span> <span class="o">},</span>
  <span class="n">exact</span> <span class="n">hle</span> <span class="n">key</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="245623683"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/golfing%20%20challenge%21/near/245623683" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hanting Zhang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/golfing.20.20challenge!.html#245623683">(Jul 11 2021 at 19:54)</a>:</h4>
<p>In particular, I feel like <code>bsupr_eq_supr</code> and <code>finsupp.sum_add_add</code> both are supposed to be one line proofs, but I'm not abusing definitional equality hard enough.</p>
<p><code>mem_supr'</code> and <code>mem_bsupr</code> have some actual content, but the current proofs seem far too awkward. I'm not sure how to make them better.</p>
<p>Thanks in advance for any help!</p>



<a name="245623839"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/golfing%20%20challenge%21/near/245623839" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/golfing.20.20challenge!.html#245623839">(Jul 11 2021 at 19:59)</a>:</h4>
<p><del>I think the first one is <a href="https://leanprover-community.github.io/mathlib_docs/find/finsupp.sum_add_index">docs#finsupp.sum_add_index</a></del> nevermind, you already prove it with that. It golfs to a single invocation of that lemma though.</p>



<a name="245623979"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/golfing%20%20challenge%21/near/245623979" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/golfing.20.20challenge!.html#245623979">(Jul 11 2021 at 20:02)</a>:</h4>
<p>bsupr_eq_supr is <a href="https://leanprover-community.github.io/mathlib_docs/find/supr_subtype">docs#supr_subtype</a> (or the primed version)</p>



<a name="245624306"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/golfing%20%20challenge%21/near/245624306" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/golfing.20.20challenge!.html#245624306">(Jul 11 2021 at 20:12)</a>:</h4>
<p>Can you use <a href="https://leanprover-community.github.io/mathlib_docs/find/submodule.exists_finset_of_mem_supr">docs#submodule.exists_finset_of_mem_supr</a>?  (For the main result.)</p>



<a name="245628700"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/golfing%20%20challenge%21/near/245628700" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/golfing.20.20challenge!.html#245628700">(Jul 11 2021 at 21:44)</a>:</h4>
<p>I just PR'd <a href="https://github.com/leanprover-community/mathlib/issues/8268">#8268</a> which adds an <code>iff</code> version of that lemma, <code>mem_supr_iff_exists_finset</code>, on the off-chance it helps</p>



<a name="245631044"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/golfing%20%20challenge%21/near/245631044" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/golfing.20.20challenge!.html#245631044">(Jul 11 2021 at 22:43)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> apparently asked the same question three months ago!<br>
<a href="#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/submonoid.2Emem_supr">https://leanprover.zulipchat.com/#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/submonoid.2Emem_supr</a></p>



<a name="245631276"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/golfing%20%20challenge%21/near/245631276" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/golfing.20.20challenge!.html#245631276">(Jul 11 2021 at 22:48)</a>:</h4>
<p>I also wonder whether there's a nice variant of <a href="https://leanprover-community.github.io/mathlib_docs/find/submodule.coe_sup">docs#submodule.coe_sup</a> which could be stated for <code>supr</code>. I don't have a good understanding of the cases when the index set isn't finite though.</p>



<a name="245653225"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/golfing%20%20challenge%21/near/245653225" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/golfing.20.20challenge!.html#245653225">(Jul 12 2021 at 07:26)</a>:</h4>
<p>Here's a golf of <code>mem_supr'</code> that follows the same strategy as your proof:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">add_submonoid.finsupp_sum_mem</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">add_submonoid</span> <span class="n">M</span><span class="o">)</span>
  <span class="o">{</span><span class="n">ι₁</span> <span class="n">ι₂</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">has_zero</span> <span class="n">ι₂</span><span class="o">]</span>
  <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ι₁</span> <span class="bp">→₀</span> <span class="n">ι₂</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">ι₁</span> <span class="bp">→</span> <span class="n">ι₂</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">c</span><span class="o">,</span> <span class="n">f</span> <span class="n">c</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="bp">→</span> <span class="n">g</span> <span class="n">c</span> <span class="o">(</span><span class="n">f</span> <span class="n">c</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">S</span><span class="o">)</span> <span class="o">:</span> <span class="n">f.sum</span> <span class="n">g</span> <span class="bp">∈</span> <span class="n">S</span> <span class="o">:=</span>
<span class="n">S.sum_mem</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">i</span> <span class="n">hi</span><span class="o">,</span> <span class="n">h</span> <span class="n">_</span> <span class="o">(</span><span class="n">finsupp.mem_support_iff.mp</span> <span class="n">hi</span><span class="o">)</span>

<span class="kd">lemma</span> <span class="n">submodule.finsupp_sum_mem</span> <span class="o">{</span><span class="n">R</span> <span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span>
  <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">submodule</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span> <span class="o">{</span><span class="n">ι₁</span> <span class="n">ι₂</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">has_zero</span> <span class="n">ι₂</span><span class="o">]</span>
  <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ι₁</span> <span class="bp">→₀</span> <span class="n">ι₂</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">ι₁</span> <span class="bp">→</span> <span class="n">ι₂</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">c</span><span class="o">,</span> <span class="n">f</span> <span class="n">c</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="bp">→</span> <span class="n">g</span> <span class="n">c</span> <span class="o">(</span><span class="n">f</span> <span class="n">c</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">S</span><span class="o">)</span> <span class="o">:</span> <span class="n">f.sum</span> <span class="n">g</span> <span class="bp">∈</span> <span class="n">S</span> <span class="o">:=</span>
<span class="n">S.to_add_submonoid.finsupp_sum_mem</span> <span class="n">f</span> <span class="n">g</span> <span class="n">h</span>

<span class="c1">-- pretty atrocious but hey it works</span>
<span class="kd">lemma</span> <span class="n">mem_supr'</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span>
  <span class="o">{</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">w</span><span class="o">}</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">submodule</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">M</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">x</span> <span class="bp">∈</span> <span class="n">supr</span> <span class="n">p</span> <span class="bp">↔</span> <span class="bp">∃</span> <span class="n">v</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→₀</span> <span class="n">M</span><span class="o">,</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">v</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">p</span> <span class="n">i</span><span class="o">)</span> <span class="bp">∧</span> <span class="n">v.sum</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span> <span class="n">vi</span><span class="o">,</span> <span class="n">vi</span><span class="o">)</span> <span class="bp">=</span> <span class="n">x</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">refine</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="n">submodule.supr_eq_span</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">refine</span> <span class="n">submodule.span_induction</span> <span class="n">h</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">intros</span> <span class="n">y</span> <span class="n">hy</span><span class="o">,</span>
      <span class="n">obtain</span> <span class="o">⟨</span><span class="n">i</span><span class="o">,</span> <span class="n">hy</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">set.mem_Union.mp</span> <span class="n">hy</span><span class="o">,</span>
      <span class="n">refine</span> <span class="o">⟨</span><span class="n">finsupp.single</span> <span class="n">i</span> <span class="n">y</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">j</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">finsupp.sum_single_index</span> <span class="n">rfl</span><span class="o">⟩,</span>
      <span class="n">cases</span> <span class="n">eq_or_ne</span> <span class="n">j</span> <span class="n">i</span> <span class="k">with</span> <span class="n">h</span> <span class="n">h</span><span class="o">,</span>
      <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">h</span><span class="o">,</span> <span class="n">finsupp.single_eq_same</span><span class="o">],</span> <span class="n">exact</span> <span class="n">hy</span><span class="o">,</span> <span class="o">},</span>
      <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">finsupp.single_eq_of_ne</span> <span class="n">h.symm</span><span class="o">,</span> <span class="n">submodule.zero_mem</span><span class="o">],</span> <span class="o">},</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="o">⟨</span><span class="mi">0</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">submodule.zero_mem</span> <span class="n">_</span><span class="o">,</span> <span class="n">finsupp.sum_zero_index</span><span class="o">⟩,</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">rintros</span> <span class="n">x</span> <span class="n">y</span> <span class="o">⟨</span><span class="n">v</span><span class="o">,</span> <span class="n">hv</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">w</span><span class="o">,</span> <span class="n">hw</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span>
      <span class="n">refine</span> <span class="o">⟨</span><span class="n">v</span> <span class="bp">+</span> <span class="n">w</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">submodule.add_mem</span> <span class="n">_</span> <span class="o">(</span><span class="n">hv</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">hw</span> <span class="n">i</span><span class="o">),</span>
                    <span class="n">finsupp.sum_add_index</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">rfl</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="n">rfl</span><span class="o">)⟩</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">rintros</span> <span class="n">r</span> <span class="n">x</span> <span class="o">⟨</span><span class="n">v</span><span class="o">,</span> <span class="n">hv</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span>
      <span class="n">refine</span> <span class="o">⟨</span><span class="n">r</span> <span class="bp">•</span> <span class="n">v</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">submodule.smul_mem</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="n">hv</span> <span class="n">i</span><span class="o">),</span> <span class="n">_</span><span class="o">⟩,</span>
      <span class="n">rw</span> <span class="o">[</span><span class="n">finsupp.sum_smul_index'</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">),</span> <span class="n">finsupp.smul_sum</span><span class="o">],</span>
      <span class="n">refl</span> <span class="o">},</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rcases</span> <span class="n">h</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">v</span><span class="o">,</span> <span class="n">hv</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span>
    <span class="n">exact</span> <span class="n">submodule.finsupp_sum_mem</span> <span class="n">_</span> <span class="n">v</span> <span class="n">_</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span> <span class="n">_</span><span class="o">,</span> <span class="o">(</span><span class="n">le_supr</span> <span class="n">p</span> <span class="n">i</span> <span class="o">:</span> <span class="n">p</span> <span class="n">i</span> <span class="bp">≤</span> <span class="n">supr</span> <span class="n">p</span><span class="o">)</span> <span class="o">(</span><span class="n">hv</span> <span class="n">i</span><span class="o">)),}</span>
<span class="kd">end</span>
</code></pre></div>



<a name="245654179"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/golfing%20%20challenge%21/near/245654179" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/golfing.20.20challenge!.html#245654179">(Jul 12 2021 at 07:36)</a>:</h4>
<p><code>mem_bsupr</code> is much easier, and most of the proof is just pushing binders around:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">mem_bsupr</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span>
  <span class="o">{</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">w</span><span class="o">}</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">submodule</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">x</span> <span class="bp">∈</span> <span class="o">(</span><span class="bp">⨆</span> <span class="n">i</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">p</span> <span class="n">i</span><span class="o">),</span> <span class="n">f</span> <span class="n">i</span><span class="o">)</span> <span class="bp">↔</span>
  <span class="bp">∃</span> <span class="n">v</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→₀</span> <span class="n">M</span><span class="o">,</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">v</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">f</span> <span class="n">i</span><span class="o">)</span> <span class="bp">∧</span> <span class="n">v.sum</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span> <span class="n">vi</span><span class="o">,</span> <span class="n">vi</span><span class="o">)</span> <span class="bp">=</span> <span class="n">x</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="bp">¬</span> <span class="n">p</span> <span class="n">i</span> <span class="bp">→</span> <span class="n">v</span> <span class="n">i</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="n">mem_supr'</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">exists_congr</span><span class="o">,</span>
  <span class="n">intro</span> <span class="n">a</span><span class="o">,</span>
  <span class="n">conv_rhs</span> <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span><span class="n">and_assoc</span><span class="o">,</span> <span class="n">and_comm</span><span class="o">,</span> <span class="bp">←</span><span class="n">and_assoc</span><span class="o">]},</span>
  <span class="n">apply</span> <span class="n">and_congr_left'</span><span class="o">,</span>
  <span class="n">rw</span> <span class="bp">←</span><span class="n">forall_and_distrib</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">forall_congr</span><span class="o">,</span>
  <span class="n">intro</span> <span class="n">i</span><span class="o">,</span>
  <span class="n">by_cases</span> <span class="n">hp</span> <span class="o">:</span> <span class="n">p</span> <span class="n">i</span><span class="o">,</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">hp</span><span class="o">],</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">hp</span><span class="o">]</span> <span class="o">{</span><span class="n">contextual</span> <span class="o">:=</span> <span class="n">tt</span><span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>



<a name="245654516"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/golfing%20%20challenge%21/near/245654516" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/golfing.20.20challenge!.html#245654516">(Jul 12 2021 at 07:40)</a>:</h4>
<p>If you tweak the statement it gets shorter:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">mem_bsupr</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span>
  <span class="o">{</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">w</span><span class="o">}</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">submodule</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">x</span> <span class="bp">∈</span> <span class="o">(</span><span class="bp">⨆</span> <span class="n">i</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">p</span> <span class="n">i</span><span class="o">),</span> <span class="n">f</span> <span class="n">i</span><span class="o">)</span> <span class="bp">↔</span>
  <span class="bp">∃</span> <span class="n">v</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→₀</span> <span class="n">M</span><span class="o">,</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="o">(</span><span class="bp">¬</span> <span class="n">p</span> <span class="n">i</span> <span class="bp">→</span> <span class="n">v</span> <span class="n">i</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span> <span class="bp">∧</span> <span class="n">v</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">f</span> <span class="n">i</span><span class="o">)</span> <span class="bp">∧</span> <span class="n">v.sum</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span> <span class="n">vi</span><span class="o">,</span> <span class="n">vi</span><span class="o">)</span> <span class="bp">=</span> <span class="n">x</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="n">mem_supr'</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">exists_congr</span><span class="o">,</span>
  <span class="n">intro</span> <span class="n">v</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">and_congr_left'</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">forall_congr</span><span class="o">,</span>
  <span class="n">intro</span> <span class="n">i</span><span class="o">,</span>
  <span class="n">by_cases</span> <span class="n">hp</span> <span class="o">:</span> <span class="n">p</span> <span class="n">i</span><span class="o">,</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">hp</span><span class="o">],</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">hp</span><span class="o">]</span> <span class="o">{</span><span class="n">contextual</span> <span class="o">:=</span> <span class="n">tt</span><span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>



<a name="245668567"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/golfing%20%20challenge%21/near/245668567" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/golfing.20.20challenge!.html#245668567">(Jul 12 2021 at 10:25)</a>:</h4>
<p>I think this lemma is the one we really want:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/-- Note that `dfinsupp.lsum ℕ f` is precisely `direct_sum.to_module f` -/</span>
<span class="kd">lemma</span> <span class="n">supr_eq_dfinsupp_lsum_range</span>
  <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span>
  <span class="o">{</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">w</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">ι</span><span class="o">]</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">submodule</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">supr</span> <span class="n">p</span> <span class="bp">=</span> <span class="o">(</span><span class="n">dfinsupp.lsum</span> <span class="n">ℕ</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="o">(</span><span class="n">p</span> <span class="n">i</span><span class="o">)</span><span class="bp">.</span><span class="n">subtype</span><span class="o">))</span><span class="bp">.</span><span class="n">range</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">apply</span> <span class="n">le_antisymm</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">apply</span> <span class="n">supr_le</span> <span class="n">_</span><span class="o">,</span>
    <span class="n">intros</span> <span class="n">i</span> <span class="n">y</span> <span class="n">hy</span><span class="o">,</span>
    <span class="n">exact</span> <span class="o">⟨</span><span class="n">dfinsupp.single</span> <span class="n">i</span> <span class="o">⟨</span><span class="n">y</span><span class="o">,</span> <span class="n">hy</span><span class="o">⟩,</span> <span class="n">dfinsupp.sum_add_hom_single</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span><span class="o">⟩,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rintros</span> <span class="n">x</span> <span class="o">⟨</span><span class="n">v</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span>
    <span class="n">exact</span> <span class="n">dfinsupp_sum_add_hom_mem</span> <span class="n">_</span> <span class="n">v</span> <span class="n">_</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span> <span class="n">_</span><span class="o">,</span> <span class="o">(</span><span class="n">le_supr</span> <span class="n">p</span> <span class="n">i</span> <span class="o">:</span> <span class="n">p</span> <span class="n">i</span> <span class="bp">≤</span> <span class="n">_</span><span class="o">)</span> <span class="o">(</span><span class="n">v</span> <span class="n">i</span><span class="o">)</span><span class="bp">.</span><span class="n">prop</span><span class="o">)</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>



<a name="245774080"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/golfing%20%20challenge%21/near/245774080" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hanting Zhang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/golfing.20.20challenge!.html#245774080">(Jul 13 2021 at 02:54)</a>:</h4>
<p>Thanks <span class="user-mention" data-user-id="310045">@Eric Wieser</span>! You're too fast for me though with <a href="https://github.com/leanprover-community/mathlib/issues/8274">#8274</a>; I'll be moving stuff around in <a href="https://github.com/leanprover-community/mathlib/issues/8246">#8246</a> to readjust my approach</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
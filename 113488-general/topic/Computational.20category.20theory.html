---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/Computational.20category.20theory.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20category.20theory.html">Computational category theory</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="224830030"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20category%20theory/near/224830030" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nasos Evangelou-Oost <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20category.20theory.html#224830030">(Feb 02 2021 at 05:15)</a>:</h4>
<p><span class="user-mention" data-user-id="270523">@Huỳnh Trần Khanh</span> i see. actually what i'm more interested is in computational category theory and general purpose programming. i recently was surprised to learn that lean4 is actually quite capable of this.  i'm currently working on a project in F# but the lack of dependent types is limiting. i also considered idris2 as a general-purpose dependently typed language but it is in prerelease and its development seems slow (idris 1 seems too slow to be able to do anything useful).</p>



<a name="224830188"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20category%20theory/near/224830188" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nasos Evangelou-Oost <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20category.20theory.html#224830188">(Feb 02 2021 at 05:18)</a>:</h4>
<p>on the official Lean about page (<a href="https://leanprover.github.io/about/">https://leanprover.github.io/about/</a>) it says "Lean is a functional programming language that makes it easy to write correct and maintainable code. You can also use Lean as an interactive theorem prover." it sounds like Lean is being marketed here as a programming language first and a theorem prover second. Is this a change of direction in lean4? or is lean3 also capable of general purpose programming?</p>



<a name="224830262"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20category%20theory/near/224830262" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Huỳnh Trần Khanh <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20category.20theory.html#224830262">(Feb 02 2021 at 05:19)</a>:</h4>
<p>I wouldn't say that this is a change of direction in Lean 4. Lean has been exploiting the Curry–Howard correspondence since its inception and I think this is just a natural evolution of the idea perhaps.</p>



<a name="224830307"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20category%20theory/near/224830307" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Huỳnh Trần Khanh <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20category.20theory.html#224830307">(Feb 02 2021 at 05:20)</a>:</h4>
<p>And no, Lean 3 is not capable of general purpose programming. But you can still write programs in Lean 3.</p>



<a name="224830346"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20category%20theory/near/224830346" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Huỳnh Trần Khanh <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20category.20theory.html#224830346">(Feb 02 2021 at 05:21)</a>:</h4>
<p><span class="user-mention silent" data-user-id="386149">Nasos Evangelou-Oost</span> <a href="#narrow/stream/270676-lean4/topic/mathlib/near/224830030">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="270523">Huỳnh Trần Khanh</span> i see. actually what i'm more interested is in computational category theory and general purpose programming. i recently was surprised to learn that lean4 is actually quite capable of this.  i'm currently working on a project in F# but the lack of dependent types is limiting. i also considered idris2 as a general-purpose dependently typed language but it is in prerelease and its development seems slow (idris 1 seems too slow to be able to do anything useful).</p>
</blockquote>
<p>Have you tried Dafny? Does it fit your use case?</p>



<a name="224830350"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20category%20theory/near/224830350" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20category.20theory.html#224830350">(Feb 02 2021 at 05:21)</a>:</h4>
<p>Lean 3 can be used as a general purpose programming language, it's just not very good</p>



<a name="224830395"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20category%20theory/near/224830395" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20category.20theory.html#224830395">(Feb 02 2021 at 05:22)</a>:</h4>
<p>I thought F# had dependent types?</p>



<a name="224830433"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20category%20theory/near/224830433" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20category.20theory.html#224830433">(Feb 02 2021 at 05:23)</a>:</h4>
<p><a href="https://www.fstar-lang.org/#introduction">https://www.fstar-lang.org/#introduction</a></p>
<blockquote>
<p><code>F*</code>'s type system includes dependent types, monadic effects, refinement types, and a weakest precondition calculus. Together, these features allow expressing precise and compact specifications for programs. The F* type-checker aims to prove that programs meet their specifications using a combination of SMT solving and interactive proofs.</p>
</blockquote>



<a name="224830475"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20category%20theory/near/224830475" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nasos Evangelou-Oost <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20category.20theory.html#224830475">(Feb 02 2021 at 05:24)</a>:</h4>
<p>funny you ask... i am about to TA for a class that uses Dafny. but I have never actually used it before, so I'm not sure. to give you an idea of what i'm interested in, here is the project i am working on in F#: <a href="https://github.com/nasosev/topos-tool">https://github.com/nasosev/topos-tool</a> . my goal is to use it as a calulator for small presheaf toposes</p>



<a name="224830481"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20category%20theory/near/224830481" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nasos Evangelou-Oost <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20category.20theory.html#224830481">(Feb 02 2021 at 05:24)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span>  that is F* not F#</p>



<a name="224830491"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20category%20theory/near/224830491" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20category.20theory.html#224830491">(Feb 02 2021 at 05:24)</a>:</h4>
<p>oh right, F# is just C# with different syntax</p>



<a name="224830571"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20category%20theory/near/224830571" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nasos Evangelou-Oost <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20category.20theory.html#224830571">(Feb 02 2021 at 05:26)</a>:</h4>
<p>eh,  i guess. i use it because it is an ML with good cross-platform support and it works in jupyter notebooks, so works well as a 'calculator'</p>



<a name="224830676"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20category%20theory/near/224830676" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Notification Bot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20category.20theory.html#224830676">(Feb 02 2021 at 05:28)</a>:</h4>
<p>This topic was moved here from <a class="stream-topic" data-stream-id="270676" href="/#narrow/stream/270676-lean4/topic/mathlib">#lean4 &gt; mathlib</a> by <span class="user-mention silent" data-user-id="110049">Mario Carneiro</span></p>



<a name="224830704"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20category%20theory/near/224830704" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20category.20theory.html#224830704">(Feb 02 2021 at 05:29)</a>:</h4>
<p>Oops, this got the whole past of the thread too</p>



<a name="224830769"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20category%20theory/near/224830769" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Huỳnh Trần Khanh <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20category.20theory.html#224830769">(Feb 02 2021 at 05:30)</a>:</h4>
<p>Oh dear. How can we fix this?</p>



<a name="224830867"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20category%20theory/near/224830867" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20category.20theory.html#224830867">(Feb 02 2021 at 05:32)</a>:</h4>
<p>Eh, close enough</p>



<a name="224830960"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20category%20theory/near/224830960" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20category.20theory.html#224830960">(Feb 02 2021 at 05:34)</a>:</h4>
<p><span class="user-mention" data-user-id="386149">@Nasos Evangelou-Oost</span> From a cursory look at the project, it seems like you are looking at finite categories represented by finite sets of objects and morphisms?</p>



<a name="224831074"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20category%20theory/near/224831074" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20category.20theory.html#224831074">(Feb 02 2021 at 05:37)</a>:</h4>
<p>How large are the categories and presheaves you are building? It might be possible to do this in lean 3 if the numbers are small enough</p>



<a name="224831253"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20category%20theory/near/224831253" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nasos Evangelou-Oost <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20category.20theory.html#224831253">(Feb 02 2021 at 05:41)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span>  yes, everything is finite and the base categories are very small, and i am looking at 'presheaves' on them that take objects to homogeneous sets <code>Set&lt;'A&gt;</code> and morphisms to set functions, represented as maps <code>Map&lt;'A,'A&gt;</code> (so that they can be collected into sets themselves and compared for equality). as a simple example (see <a href="https://github.com/nasosev/topos-tool/blob/master/nb/graphs.ipynb">https://github.com/nasosev/topos-tool/blob/master/nb/graphs.ipynb</a>) is the category G with two objects and two morphisms between them, and presheaves on G are directed graphs</p>



<a name="224831317"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20category%20theory/near/224831317" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20category.20theory.html#224831317">(Feb 02 2021 at 05:42)</a>:</h4>
<p>yeah that sounds doable</p>



<a name="224831326"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20category%20theory/near/224831326" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nasos Evangelou-Oost <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20category.20theory.html#224831326">(Feb 02 2021 at 05:42)</a>:</h4>
<p>i think essentially i am limited to very small things as the constructions involved tend to be exponential in  complexity</p>



<a name="224831379"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20category%20theory/near/224831379" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20category.20theory.html#224831379">(Feb 02 2021 at 05:44)</a>:</h4>
<p>it's a bit different from the definitions in <code>category_theory</code>, where the objects are a whole type rather than a finite subset of that type</p>



<a name="224831431"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20category%20theory/near/224831431" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20category.20theory.html#224831431">(Feb 02 2021 at 05:45)</a>:</h4>
<p>you can build a type out of a finite set though, so you can still relate your definitions to those in the category theory library</p>



<a name="224836583"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20category%20theory/near/224836583" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20category.20theory.html#224836583">(Feb 02 2021 at 07:29)</a>:</h4>
<p><span class="user-mention" data-user-id="386149">@Nasos Evangelou-Oost</span> Here's a prototype of the first example in your notebook, using the <code>Category.make</code> function:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.list.alist</span>

<span class="kn">namespace</span> <span class="n">alist</span>

<span class="kd">def</span> <span class="n">modify_or_insert</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">β</span> <span class="n">a</span><span class="o">)</span>
  <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">β</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">β</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">alist</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">alist</span> <span class="n">β</span> <span class="o">:=</span>
<span class="n">l.insert</span> <span class="n">a</span> <span class="bp">$</span> <span class="n">f</span> <span class="bp">$</span> <span class="o">(</span><span class="n">l.lookup</span> <span class="n">a</span><span class="o">)</span><span class="bp">.</span><span class="n">get_or_else</span> <span class="n">z</span>

<span class="kd">end</span> <span class="n">alist</span>

<span class="kn">namespace</span> <span class="n">list</span>

<span class="kd">def</span> <span class="n">to_alist'</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">β</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span> <span class="n">alist</span> <span class="n">β</span> <span class="o">:=</span>
<span class="k">let</span> <span class="n">s</span> <span class="o">:=</span> <span class="n">l.erase_dup</span> <span class="k">in</span>
<span class="o">⟨</span><span class="n">s.map</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="o">(⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span><span class="o">⟩</span> <span class="o">:</span> <span class="n">sigma</span> <span class="n">β</span><span class="o">),</span>
  <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">list.nodupkeys</span><span class="o">,</span> <span class="n">list.keys</span><span class="o">]</span><span class="bp">;</span> <span class="n">convert</span> <span class="n">l.nodup_erase_dup</span><span class="bp">;</span> <span class="n">rw</span> <span class="o">[</span><span class="n">map_id'</span><span class="o">]</span><span class="bp">;</span> <span class="n">simp</span><span class="o">⟩</span>

<span class="kd">instance</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">has_to_string</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="n">has_to_string</span> <span class="o">(</span><span class="n">β</span> <span class="n">a</span><span class="o">)]</span> <span class="o">:</span>
  <span class="n">has_to_string</span> <span class="o">(</span><span class="n">alist</span> <span class="n">β</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">to_string</span> <span class="bp">∘</span> <span class="n">alist.entries</span><span class="o">⟩</span>

<span class="kd">end</span> <span class="n">list</span>

<span class="kn">namespace</span> <span class="n">fincat</span>

<span class="kd">@[derive decidable_eq]</span>
<span class="kd">structure</span> <span class="n">arrow</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">dom</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">cod</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">name</span> <span class="o">:</span> <span class="n">string</span><span class="o">)</span>

<span class="kd">instance</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="n">has_to_string</span> <span class="o">(</span><span class="n">arrow</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">arrow.name</span><span class="o">⟩</span>

<span class="kd">def</span> <span class="n">arrow.id</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">has_to_string</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">arrow</span> <span class="n">α</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">a</span><span class="o">,</span> <span class="s2">"1_"</span> <span class="bp">++</span> <span class="n">to_string</span> <span class="n">a</span><span class="o">⟩</span>

<span class="kd">structure</span> <span class="n">fincat</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">name</span> <span class="o">:</span> <span class="n">string</span><span class="o">)</span>
<span class="o">(</span><span class="n">ob</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span>
<span class="o">(</span><span class="n">nonid_arrows</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">arrow</span> <span class="n">α</span><span class="o">))</span>
<span class="o">(</span><span class="n">arrows</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">arrow</span> <span class="n">α</span><span class="o">))</span>
<span class="o">(</span><span class="n">id</span> <span class="o">:</span> <span class="n">alist</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span><span class="o">:</span><span class="n">α</span><span class="o">,</span> <span class="n">arrow</span> <span class="n">α</span><span class="o">))</span>
<span class="o">(</span><span class="n">hom</span> <span class="o">:</span> <span class="n">alist</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span><span class="o">:</span><span class="n">α</span><span class="o">,</span> <span class="n">alist</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span><span class="o">:</span><span class="n">α</span><span class="o">,</span> <span class="n">list</span> <span class="o">(</span><span class="n">arrow</span> <span class="n">α</span><span class="o">))))</span>
<span class="o">(</span><span class="n">compose</span> <span class="o">:</span> <span class="n">alist</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span><span class="o">:</span><span class="n">arrow</span> <span class="n">α</span><span class="o">,</span> <span class="n">alist</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span><span class="o">:</span><span class="n">arrow</span> <span class="n">α</span><span class="o">,</span> <span class="n">arrow</span> <span class="n">α</span><span class="o">)))</span>

<span class="kd">def</span> <span class="n">fincat.make</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">has_to_string</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span>
  <span class="o">(</span><span class="n">name</span> <span class="o">:</span> <span class="n">string</span><span class="o">)</span> <span class="o">(</span><span class="n">ob</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span>
  <span class="o">(</span><span class="n">nonid_arrows</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">arrow</span> <span class="n">α</span><span class="o">))</span>
  <span class="o">(</span><span class="n">nontriv_compose</span> <span class="o">:</span> <span class="n">alist</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span><span class="o">:</span><span class="n">arrow</span> <span class="n">α</span><span class="o">,</span> <span class="n">alist</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span><span class="o">:</span><span class="n">arrow</span> <span class="n">α</span><span class="o">,</span> <span class="n">arrow</span> <span class="n">α</span><span class="o">)))</span> <span class="o">:</span>
  <span class="n">option</span> <span class="o">(</span><span class="n">fincat</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">let</span> <span class="n">compose</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">arrow</span> <span class="n">α</span> <span class="bp">×</span> <span class="n">arrow</span> <span class="n">α</span> <span class="bp">×</span> <span class="n">arrow</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
  <span class="o">(</span><span class="n">ob.map</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">A</span><span class="o">,</span> <span class="k">let</span> <span class="n">I</span> <span class="o">:=</span> <span class="n">arrow.id</span> <span class="n">A</span> <span class="k">in</span> <span class="o">(</span><span class="n">I</span><span class="o">,</span> <span class="n">I</span><span class="o">,</span> <span class="n">I</span><span class="o">))</span> <span class="bp">++</span>
  <span class="o">(</span><span class="n">nonid_arrows.map</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">arrow.id</span> <span class="n">a.dom</span><span class="o">,</span> <span class="n">a</span><span class="o">))</span> <span class="bp">++</span>
  <span class="o">(</span><span class="n">nonid_arrows.map</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="o">(</span><span class="n">arrow.id</span> <span class="n">a.cod</span><span class="o">,</span> <span class="n">a</span><span class="o">,</span> <span class="n">a</span><span class="o">))</span> <span class="bp">++</span>
  <span class="o">(</span><span class="k">do</span>
    <span class="n">a</span> <span class="bp">←</span> <span class="n">nonid_arrows</span><span class="o">,</span>
    <span class="n">b</span> <span class="bp">←</span> <span class="n">nonid_arrows</span><span class="o">,</span>
    <span class="n">guard</span> <span class="o">(</span><span class="n">b.cod</span> <span class="bp">=</span> <span class="n">a.dom</span> <span class="bp">∧</span> <span class="n">a.cod</span> <span class="bp">=</span> <span class="n">b.dom</span> <span class="bp">∧</span>
      <span class="o">((</span><span class="n">nontriv_compose.lookup</span> <span class="n">a</span><span class="o">)</span><span class="bp">.</span><span class="n">bind</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">v</span><span class="o">,</span> <span class="n">v.lookup</span> <span class="n">b</span><span class="o">))</span><span class="bp">.</span><span class="n">is_none</span><span class="o">),</span>
    <span class="n">pure</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">arrow.id</span> <span class="n">b.dom</span><span class="o">))</span> <span class="k">in</span>
<span class="k">let</span> <span class="n">hom</span> <span class="o">:</span> <span class="n">alist</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span><span class="o">:</span><span class="n">α</span><span class="o">,</span> <span class="n">alist</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span><span class="o">:</span><span class="n">α</span><span class="o">,</span> <span class="n">list</span> <span class="o">(</span><span class="n">arrow</span> <span class="n">α</span><span class="o">)))</span> <span class="o">:=</span>
  <span class="n">ob.to_alist'</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">A</span><span class="o">,</span> <span class="n">ob.to_alist'</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">B</span><span class="o">,</span>
    <span class="o">(</span><span class="k">do</span>
      <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">)</span> <span class="bp">←</span> <span class="n">compose</span><span class="o">,</span>
      <span class="n">guard</span> <span class="o">(</span><span class="n">b</span> <span class="bp">=</span> <span class="n">arrow.id</span> <span class="n">A</span><span class="o">),</span>
      <span class="n">pure</span> <span class="n">c</span><span class="o">)</span> <span class="bp">∩</span>
    <span class="o">(</span><span class="k">do</span>
      <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">)</span> <span class="bp">←</span> <span class="n">compose</span><span class="o">,</span>
      <span class="n">guard</span> <span class="o">(</span><span class="n">a</span> <span class="bp">=</span> <span class="n">arrow.id</span> <span class="n">B</span><span class="o">),</span>
      <span class="n">pure</span> <span class="n">c</span><span class="o">)</span> <span class="k">in</span>
<span class="k">let</span> <span class="n">compose</span> <span class="o">:</span> <span class="n">alist</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span><span class="o">:</span><span class="n">arrow</span> <span class="n">α</span><span class="o">,</span> <span class="n">alist</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span><span class="o">:</span><span class="n">arrow</span> <span class="n">α</span><span class="o">,</span> <span class="n">arrow</span> <span class="n">α</span><span class="o">))</span> <span class="o">:=</span>
  <span class="n">compose.foldl</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">l</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">⟩,</span> <span class="n">l.modify_or_insert</span> <span class="n">a</span> <span class="bp">∅</span> <span class="bp">$</span> <span class="n">alist.insert</span> <span class="n">b</span> <span class="n">c</span><span class="o">)</span> <span class="bp">∅</span> <span class="k">in</span>
<span class="k">let</span> <span class="n">arrows</span> <span class="o">:=</span> <span class="k">do</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">l</span><span class="o">⟩</span> <span class="bp">←</span> <span class="n">hom.1</span><span class="o">,</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">l</span><span class="o">⟩</span> <span class="bp">←</span> <span class="n">l.1</span><span class="o">,</span> <span class="n">l</span> <span class="k">in</span>
<span class="n">guard</span> <span class="o">(</span>
  <span class="bp">∀</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">arrows</span><span class="o">,</span>
  <span class="bp">∀</span> <span class="n">b</span> <span class="bp">∈</span> <span class="n">arrows</span><span class="o">,</span>
  <span class="n">arrow.cod</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">arrow.dom</span> <span class="n">a</span> <span class="bp">→</span>
  <span class="o">((</span><span class="n">compose.lookup</span> <span class="n">a</span><span class="o">)</span><span class="bp">.</span><span class="n">bind</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">v</span><span class="o">,</span> <span class="n">v.lookup</span> <span class="n">b</span><span class="o">))</span><span class="bp">.</span><span class="n">is_some</span>
<span class="o">)</span> <span class="bp">&gt;&gt;</span>
<span class="n">some</span> <span class="o">{</span>
  <span class="n">name</span> <span class="o">:=</span> <span class="n">name</span><span class="o">,</span>
  <span class="n">ob</span> <span class="o">:=</span> <span class="n">ob</span><span class="o">,</span>
  <span class="n">id</span> <span class="o">:=</span>  <span class="n">ob.to_alist'</span> <span class="n">arrow.id</span><span class="o">,</span>
  <span class="n">arrows</span> <span class="o">:=</span> <span class="n">arrows</span><span class="o">,</span>
  <span class="n">nonid_arrows</span> <span class="o">:=</span> <span class="n">nonid_arrows</span><span class="o">,</span>
  <span class="n">hom</span> <span class="o">:=</span> <span class="n">hom</span><span class="o">,</span>
  <span class="n">compose</span> <span class="o">:=</span> <span class="n">compose</span> <span class="o">}</span>

<span class="kd">end</span> <span class="n">fincat</span>

<span class="kn">open</span> <span class="n">fincat</span>

<span class="kd">@[derive decidable_eq]</span>
<span class="kd">inductive</span> <span class="n">Graph</span> <span class="bp">|</span> <span class="n">V</span> <span class="bp">|</span> <span class="n">E</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_to_string</span> <span class="n">Graph</span> <span class="o">:=</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">Graph.rec</span> <span class="s2">"V"</span> <span class="s2">"E"</span> <span class="n">x</span><span class="o">⟩</span>

<span class="kn">open</span> <span class="n">Graph</span>
<span class="k">#eval</span> <span class="k">show</span> <span class="n">tactic</span> <span class="n">unit</span><span class="o">,</span> <span class="k">from</span> <span class="k">do</span>
  <span class="k">let</span> <span class="n">objects</span> <span class="o">:=</span> <span class="o">[</span><span class="n">V</span><span class="o">,</span> <span class="n">E</span><span class="o">],</span>
  <span class="k">let</span> <span class="n">arrows</span> <span class="o">:=</span> <span class="o">[</span><span class="n">arrow.mk</span> <span class="n">V</span> <span class="n">E</span> <span class="s2">"s"</span><span class="o">,</span> <span class="n">arrow.mk</span> <span class="n">V</span> <span class="n">E</span> <span class="s2">"t"</span><span class="o">],</span>
  <span class="n">cat</span> <span class="bp">←</span> <span class="n">fincat.make</span> <span class="s2">"Graphs"</span> <span class="n">objects</span> <span class="n">arrows</span> <span class="bp">∅</span><span class="o">,</span>
  <span class="n">tactic.trace</span> <span class="bp">$</span> <span class="s2">"name: "</span> <span class="bp">++</span> <span class="n">cat.name</span><span class="o">,</span>
  <span class="n">tactic.trace</span> <span class="bp">$</span> <span class="s2">"objects: "</span> <span class="bp">++</span> <span class="n">to_string</span> <span class="n">cat.ob</span><span class="o">,</span>
  <span class="n">tactic.trace</span> <span class="bp">$</span> <span class="s2">"nonid_arrows: "</span> <span class="bp">++</span> <span class="n">to_string</span> <span class="n">cat.nonid_arrows</span><span class="o">,</span>
  <span class="n">tactic.trace</span> <span class="bp">$</span> <span class="s2">"hom: "</span> <span class="bp">++</span> <span class="n">to_string</span> <span class="n">cat.hom</span><span class="o">,</span>
  <span class="n">tactic.trace</span> <span class="bp">$</span> <span class="s2">"compose: "</span> <span class="bp">++</span> <span class="n">to_string</span> <span class="n">cat.compose</span><span class="o">,</span>
  <span class="n">pure</span> <span class="o">()</span>

<span class="c1">-- name: Graphs</span>
<span class="c1">-- objects: [V, E]</span>
<span class="c1">-- nonid_arrows: [s, t]</span>
<span class="c1">-- hom: [⟨V, [⟨V, [1_V]⟩, ⟨E, [s, t]⟩]⟩, ⟨E, [⟨V, []⟩, ⟨E, [1_E]⟩]⟩]</span>
<span class="c1">-- compose: [⟨1_E, [⟨t, t⟩, ⟨s, s⟩, ⟨1_E, 1_E⟩]⟩, ⟨t, [⟨1_V, t⟩]⟩, ⟨s, [⟨1_V, s⟩]⟩, ⟨1_V, [⟨1_V, 1_V⟩]⟩]</span>
</code></pre></div>
<p>This sort of thing will get a lot easier in lean 4 though.</p>



<a name="224837547"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20category%20theory/near/224837547" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nasos Evangelou-Oost <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20category.20theory.html#224837547">(Feb 02 2021 at 07:43)</a>:</h4>
<p>thank you very much <span class="user-mention" data-user-id="110049">@Mario Carneiro</span> ! this will give me a great head start. </p>
<p>are you using mathlib here by the way? and what in particular should be easier in lean 4?</p>



<a name="224837732"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20category%20theory/near/224837732" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20category.20theory.html#224837732">(Feb 02 2021 at 07:46)</a>:</h4>
<p>Yes, it's using <code>data.list.alist</code> from mathlib. This is more or less straight programming, which has better support (and much more efficient too, meaning you can go to bigger examples) in lean 4, as well as nicer syntax for this use case. The code above has been written such that you could in principle prove the equivalence to <code>category_theory</code> categories, but that's a fairly nontrivial theorem because of all the programming stuff</p>



<a name="224837851"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20category%20theory/near/224837851" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20category.20theory.html#224837851">(Feb 02 2021 at 07:48)</a>:</h4>
<p>I originally started writing this with <code>finset</code> and <code>finmap</code>, but those types are explicitly order-erased, which means there are proof obligations in the operations to prove that the order you collect things doesn't matter. It can be done but it would take some more hours to figure out</p>



<a name="224837880"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20category%20theory/near/224837880" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nasos Evangelou-Oost <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20category.20theory.html#224837880">(Feb 02 2021 at 07:49)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> I see. If i don't need to show equivalence mathlib definitions or do any proofs ofr the time being, maybe I could just start right away with lean 4, using its <code>List</code> type?</p>



<a name="224837896"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20category%20theory/near/224837896" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nasos Evangelou-Oost <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20category.20theory.html#224837896">(Feb 02 2021 at 07:49)</a>:</h4>
<p>ah yes, i was worried about that when looking up <code>finset</code> earlier in the mathlib docs</p>



<a name="224837968"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20category%20theory/near/224837968" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20category.20theory.html#224837968">(Feb 02 2021 at 07:50)</a>:</h4>
<p>Yes, I think that would work. There might also be more efficient set/map data structures in lean 4; I'm using lists here for simplicity but that performs pretty poorly</p>



<a name="224837997"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20category%20theory/near/224837997" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nasos Evangelou-Oost <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20category.20theory.html#224837997">(Feb 02 2021 at 07:51)</a>:</h4>
<p>i see--thanks!</p>



<a name="224838025"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20category%20theory/near/224838025" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20category.20theory.html#224838025">(Feb 02 2021 at 07:51)</a>:</h4>
<p><code>alist B</code> is really just <code>list (sigma B)</code> with a proof that the list has nodup keys; if you maintain that property yourself without doing proofs then you can just use <code>list (sigma B)</code> (or <code>list (A x B)</code> in your case since the dependent types aren't necessary)</p>



<a name="224838076"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20category%20theory/near/224838076" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nasos Evangelou-Oost <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20category.20theory.html#224838076">(Feb 02 2021 at 07:52)</a>:</h4>
<p>oh, and once the library is built, how would you suggest is the best way to use/interact with i?t-- i imagine Lean does not yet support a notebook interface like Jupyter. But does it have a REPL?</p>



<a name="224838102"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20category%20theory/near/224838102" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20category.20theory.html#224838102">(Feb 02 2021 at 07:53)</a>:</h4>
<p><span class="user-mention" data-user-id="123965">@Bryan Gin-ge Chen</span> has a set up for running lean 3 in an Observable notebook somewhere</p>



<a name="224838148"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20category%20theory/near/224838148" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20category.20theory.html#224838148">(Feb 02 2021 at 07:53)</a>:</h4>
<p>No REPL but it does have a web version, for example <a href="https://leanprover-community.github.io/lean-web-editor/">https://leanprover-community.github.io/lean-web-editor/</a></p>



<a name="224838209"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20category%20theory/near/224838209" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nasos Evangelou-Oost <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20category.20theory.html#224838209">(Feb 02 2021 at 07:54)</a>:</h4>
<p>oh, nice! it looks like one can load external files in there, so that should be enough</p>



<a name="224838264"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20category%20theory/near/224838264" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20category.20theory.html#224838264">(Feb 02 2021 at 07:55)</a>:</h4>
<p><span class="user-mention silent" data-user-id="386149">Nasos Evangelou-Oost</span> <a href="#narrow/stream/113488-general/topic/Computational.20category.20theory/near/224838076">said</a>:</p>
<blockquote>
<p>But does it have a REPL?</p>
</blockquote>
<p>In a certain sense the source files themselves are a REPL using commands like <code>#eval</code></p>



<a name="224894181"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20category%20theory/near/224894181" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20category.20theory.html#224894181">(Feb 02 2021 at 16:17)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113488-general/topic/Computational.20category.20theory/near/224838102">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="123965">Bryan Gin-ge Chen</span> has a set up for running lean 3 in an Observable notebook somewhere</p>
</blockquote>
<p>Here's a link to a collection containing my Lean notebooks: <a href="https://observablehq.com/collection/@bryangingechen/lean">https://observablehq.com/collection/@bryangingechen/lean</a></p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/relation.2Echurch_rosser.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/relation.2Echurch_rosser.html">relation.church_rosser</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="249686428"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/relation.church_rosser/near/249686428" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/relation.2Echurch_rosser.html#249686428">(Aug 17 2021 at 07:24)</a>:</h4>
<p>How is that lemma known in real life?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">church_rosser</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="o">,</span> <span class="n">r</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">r</span> <span class="n">a</span> <span class="n">c</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">d</span><span class="o">,</span> <span class="n">refl_gen</span> <span class="n">r</span> <span class="n">b</span> <span class="n">d</span> <span class="bp">∧</span> <span class="n">refl_trans_gen</span> <span class="n">r</span> <span class="n">c</span> <span class="n">d</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hab</span> <span class="o">:</span> <span class="n">refl_trans_gen</span> <span class="n">r</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">hac</span> <span class="o">:</span> <span class="n">refl_trans_gen</span> <span class="n">r</span> <span class="n">a</span> <span class="n">c</span><span class="o">)</span> <span class="o">:</span> <span class="n">join</span> <span class="o">(</span><span class="n">refl_trans_gen</span> <span class="n">r</span><span class="o">)</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:=</span>
</code></pre></div>
<p>I looked around and, up to my humble knowledge, it's not the Church-Rosser theorem, because it doesn't talk about β-reduction. Is it a generalization of the fact that weak Church-Rosser implies strong Church-Rosser? Also, can it not be generalized to the following?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">stronger_church_rosser</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="o">,</span> <span class="n">r</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">r</span> <span class="n">a</span> <span class="n">c</span> <span class="bp">→</span> <span class="n">join</span> <span class="o">(</span><span class="n">refl_trans_gen</span> <span class="n">r</span><span class="o">)</span> <span class="n">b</span> <span class="n">c</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hab</span> <span class="o">:</span> <span class="n">refl_trans_gen</span> <span class="n">r</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">hac</span> <span class="o">:</span> <span class="n">refl_trans_gen</span> <span class="n">r</span> <span class="n">a</span> <span class="n">c</span><span class="o">)</span> <span class="o">:</span> <span class="n">join</span> <span class="o">(</span><span class="n">refl_trans_gen</span> <span class="n">r</span><span class="o">)</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:=</span>
</code></pre></div>



<a name="249686700"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/relation.church_rosser/near/249686700" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/relation.2Echurch_rosser.html#249686700">(Aug 17 2021 at 07:29)</a>:</h4>
<p>It has something to do with the Church-Rosser property for <a href="https://en.wikipedia.org/wiki/Abstract_rewriting_system">abstract rewrite systems</a>, though the particular form of it is puzzling.  Your stronger version is that "locally confluent implies confluent" I think.</p>



<a name="249688232"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/relation.church_rosser/near/249688232" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/relation.2Echurch_rosser.html#249688232">(Aug 17 2021 at 07:50)</a>:</h4>
<p>Yeah that's what I thought. Should I generalize it and then call that "locally confluent implies confluent"?</p>



<a name="249688261"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/relation.church_rosser/near/249688261" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/relation.2Echurch_rosser.html#249688261">(Aug 17 2021 at 07:51)</a>:</h4>
<p>Well, I won't change the lemma name, but I will add a docstring.</p>



<a name="249688344"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/relation.church_rosser/near/249688344" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/relation.2Echurch_rosser.html#249688344">(Aug 17 2021 at 07:52)</a>:</h4>
<p>Is the stronger form true? I think <a href="https://en.wikipedia.org/wiki/Confluence_(abstract_rewriting)">https://en.wikipedia.org/wiki/Confluence_(abstract_rewriting)</a> has a counterexample</p>



<a name="249688403"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/relation.church_rosser/near/249688403" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/relation.2Echurch_rosser.html#249688403">(Aug 17 2021 at 07:53)</a>:</h4>
<p>Ahah! Interesting. And there's no way to get to Newman's lemma? How do we formalise this "no infinite reduction path" condition?</p>



<a name="249688514"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/relation.church_rosser/near/249688514" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/relation.2Echurch_rosser.html#249688514">(Aug 17 2021 at 07:55)</a>:</h4>
<p>that sounds like some inductive condition, for example an element is strongly normalizing if all elements it reduces to are strongly normalizing</p>



<a name="249688666"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/relation.church_rosser/near/249688666" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/relation.2Echurch_rosser.html#249688666">(Aug 17 2021 at 07:57)</a>:</h4>
<p>where strongly normalizing means that it's not related to anything on the right (normalizing) and that every it's transitivitely related to on the left is only transitively related to things it's transitively related to on the right (strongly)?</p>



<a name="249688783"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/relation.church_rosser/near/249688783" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/relation.2Echurch_rosser.html#249688783">(Aug 17 2021 at 07:58)</a>:</h4>
<p>My idea to define this condition is to have a "quantified" reflexive transitive closure which takes in a natural as one more argument.</p>



<a name="249689120"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/relation.church_rosser/near/249689120" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/relation.2Echurch_rosser.html#249689120">(Aug 17 2021 at 08:02)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">quantified_refl_trans_gen</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">refl</span> <span class="o">:</span> <span class="n">refl_trans_gen</span> <span class="n">a</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="n">tail</span> <span class="o">{</span><span class="n">n</span> <span class="n">b</span> <span class="n">c</span><span class="o">}</span> <span class="o">:</span> <span class="n">refl_trans_gen</span> <span class="n">b</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">r</span> <span class="n">b</span> <span class="n">c</span> <span class="bp">→</span> <span class="n">refl_trans_gen</span> <span class="n">c</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">no_infinite_reduction_path</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">refl_trans_gen</span> <span class="n">r</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">N</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">quantified_refl_trans_gen</span> <span class="n">r</span> <span class="n">a</span> <span class="n">b</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">n</span> <span class="bp">≤</span> <span class="n">N</span>
</code></pre></div>



<a name="249689149"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/relation.church_rosser/near/249689149" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/relation.2Echurch_rosser.html#249689149">(Aug 17 2021 at 08:03)</a>:</h4>
<p>This natural is concretely measuring the length of the path so far.</p>



<a name="249743699"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/relation.church_rosser/near/249743699" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/relation.2Echurch_rosser.html#249743699">(Aug 17 2021 at 16:29)</a>:</h4>
<p><span class="user-mention" data-user-id="387244">@Yaël Dillies</span> Your relation is satisfied by the b = a + 1 relation on nat, so it's not right. I mean exactly what I said above:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">strongly_normalizing</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">mk</span> <span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">b</span><span class="o">,</span> <span class="n">r</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">strongly_normalizing</span> <span class="n">b</span><span class="o">)</span> <span class="bp">→</span> <span class="n">strongly_normalizing</span> <span class="n">a</span>
</code></pre></div>
<p>The term "strongly normalizing" is usually used to mean there are no infinite reduction paths starting at this element. It's basically the same as <code>acc (flip r)</code> as you can see, and the definition you have (with no element, just talking about the relation as a whole) is equivalent to <code>well_founded (flip r)</code>.</p>



<a name="249743895"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/relation.church_rosser/near/249743895" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/relation.2Echurch_rosser.html#249743895">(Aug 17 2021 at 16:30)</a>:</h4>
<p>Oh yeah, what's <code>acc</code> actually?</p>



<a name="249743965"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/relation.church_rosser/near/249743965" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/relation.2Echurch_rosser.html#249743965">(Aug 17 2021 at 16:31)</a>:</h4>
<p>it stands for "accessible", and it's literally the definition I wrote with r flipped</p>



<a name="249743975"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/relation.church_rosser/near/249743975" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/relation.2Echurch_rosser.html#249743975">(Aug 17 2021 at 16:31)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/acc">docs#acc</a></p>



<a name="249744050"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/relation.church_rosser/near/249744050" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/relation.2Echurch_rosser.html#249744050">(Aug 17 2021 at 16:32)</a>:</h4>
<p>it's the basic building block for defining well foundedness</p>



<a name="249744205"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/relation.church_rosser/near/249744205" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/relation.2Echurch_rosser.html#249744205">(Aug 17 2021 at 16:32)</a>:</h4>
<p>in maths we would read <code>acc (&lt;) a</code> as "there is no infinite sequence <code>a &gt; a1 &gt; a2 &gt; ...</code>"</p>



<a name="249744519"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/relation.church_rosser/near/249744519" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/relation.2Echurch_rosser.html#249744519">(Aug 17 2021 at 16:35)</a>:</h4>
<p>see <a href="https://leanprover-community.github.io/mathlib_docs/find/rel_embedding.well_founded_iff_no_descending_seq">docs#rel_embedding.well_founded_iff_no_descending_seq</a> for the proof of equivalence of these two statements</p>



<a name="250095702"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/relation.church_rosser/near/250095702" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/relation.2Echurch_rosser.html#250095702">(Aug 20 2021 at 09:19)</a>:</h4>
<p>Ahah! So <code>relation.church_rosser</code> is the proof that semi-confluent implies the Church Rosser property.</p>



<a name="250096530"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/relation.church_rosser/near/250096530" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/relation.2Echurch_rosser.html#250096530">(Aug 20 2021 at 09:28)</a>:</h4>
<p>Wait, no. It's not semi-confluence... The <code>refl_gen</code> <code>refl_trans_gen</code> is on the wrong side of the implication.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
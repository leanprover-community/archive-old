---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/notation.20challenge.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/notation.20challenge.html">notation challenge</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="243885818"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation%20challenge/near/243885818" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/notation.20challenge.html#243885818">(Jun 25 2021 at 07:57)</a>:</h4>
<p>Dear All,</p>
<p>I have a tricky <code>notation</code>question.  I am working on the "positive/non-negative" elements of a Type <code>X</code> (of course, <code>X</code> has zero and lt/le).  Everything works smoothly and my question is about the notation.  Ideally, I would like</p>
<ul>
<li>the type of non-negative elements of <code>X</code> to be <code>X≥0</code> (in analogy with <code>nnreal</code>);</li>
<li>the type of positive elements of <code>X</code> to be <code>X&gt;0</code> (naturally).</li>
</ul>
<p>The closest I could get is to have <code>|X≥0</code> and <code>|X&gt;0</code> to work (see below).</p>
<p>Is it possible to drop the <code>|</code> entirely?</p>
<p>Thanks!</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.real.nnreal</span>

<span class="sd">/--  The elements of a type that are in relation with a fixed element.  The main examples are</span>
<span class="sd">the positive/non-negative elements of a Type with an order. -/</span>
<span class="kd">def</span> <span class="n">rel_with</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">o</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">a</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">//</span> <span class="n">r</span> <span class="n">o</span> <span class="n">a</span> <span class="o">}</span>

<span class="c1">-- Ideally, I would like to drop the vertical bar `|` from the notation.</span>
<span class="kd">notation</span> <span class="bp">`|`</span><span class="o">:</span><span class="mi">1024</span> <span class="n">α</span><span class="o">:</span><span class="mi">1</span> <span class="bp">`≥</span><span class="mi">0</span><span class="bp">`</span><span class="o">:</span><span class="mi">1</span> <span class="o">:=</span> <span class="n">rel_with</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="bp">≤</span><span class="o">)</span>
<span class="kd">notation</span> <span class="bp">`|`</span><span class="o">:</span><span class="mi">1024</span> <span class="n">α</span><span class="o">:</span><span class="mi">1</span> <span class="bp">`&gt;</span><span class="mi">0</span><span class="bp">`</span><span class="o">:</span><span class="mi">1</span> <span class="o">:=</span> <span class="n">rel_with</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="bp">&lt;</span><span class="o">)</span>

<span class="c">/-</span><span class="cm"> Check: works with `pnat`. -/</span>
<span class="kd">lemma</span> <span class="n">pnat_eq_new</span> <span class="o">:</span> <span class="n">pnat</span> <span class="bp">=</span> <span class="bp">|</span><span class="n">ℕ</span><span class="bp">&gt;</span><span class="mi">0</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="kd">lemma</span> <span class="n">natp_eq_new</span> <span class="o">:</span> <span class="n">ℕ</span><span class="bp">+</span> <span class="bp">=</span> <span class="bp">|</span><span class="n">ℕ</span><span class="bp">&gt;</span><span class="mi">0</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="c">/-</span><span class="cm"> Check: works with random Types with `0` and `&lt;`. -/</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">has_zero</span> <span class="n">X</span><span class="o">]</span> <span class="o">[</span><span class="n">has_lt</span> <span class="n">X</span><span class="o">]</span>
<span class="k">#check</span> <span class="o">(</span><span class="bp">|</span><span class="n">X</span><span class="bp">&gt;</span><span class="mi">0</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>  <span class="c1">--works</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">has_zero</span> <span class="n">Y</span><span class="o">]</span> <span class="o">[</span><span class="n">linear_order</span> <span class="n">Y</span><span class="o">]</span>
<span class="k">#check</span> <span class="o">(</span><span class="bp">|</span><span class="n">Y</span><span class="bp">&gt;</span><span class="mi">0</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>  <span class="c1">--works</span>
<span class="k">#check</span> <span class="o">(</span><span class="bp">|</span><span class="n">Y</span><span class="bp">≥</span><span class="mi">0</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>  <span class="c1">--works</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">ordered_add_comm_monoid</span> <span class="n">R</span><span class="o">]</span>
<span class="k">#check</span> <span class="o">(</span><span class="bp">|</span><span class="n">R</span><span class="bp">&gt;</span><span class="mi">0</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>  <span class="c1">--works</span>
<span class="k">#check</span> <span class="o">(</span><span class="bp">|</span><span class="n">R</span><span class="bp">≥</span><span class="mi">0</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>  <span class="c1">--works</span>

<span class="c">/-</span><span class="cm"> Check: works with `ℝ≥0`. -/</span>
<span class="c">/-</span><span class="cm">  A new name, since otherwise `ℝ≥0` could ambiguously refer to the actual nnreals or the</span>
<span class="cm">ones defined using `rel_with`. -/</span>
<span class="kd">def</span> <span class="n">myr</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="n">ℝ</span>
<span class="kd">instance</span> <span class="n">myr.has_zero</span> <span class="o">:</span> <span class="n">has_zero</span> <span class="n">myr</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">zero</span> <span class="o">:=</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">}</span>
<span class="kd">instance</span> <span class="n">myr.has_le</span> <span class="o">:</span> <span class="n">has_le</span> <span class="n">myr</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">le</span> <span class="o">:=</span> <span class="o">((</span><span class="bp">≤</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">}</span>

<span class="n">open_locale</span> <span class="n">nnreal</span>
<span class="c">/-</span><span class="cm"> Check: works with `ℝ≥0`. -/</span>
<span class="kd">lemma</span> <span class="n">nnreal_eq_myn</span> <span class="o">:</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span> <span class="bp">=</span> <span class="bp">|</span><span class="n">myr</span><span class="bp">≥</span><span class="mi">0</span> <span class="o">:=</span> <span class="n">rfl</span>
</code></pre></div>



<a name="243896429"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation%20challenge/near/243896429" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/notation.20challenge.html#243896429">(Jun 25 2021 at 10:06)</a>:</h4>
<p>My guess would be that it's not possible, since it's not really possible to distinguish <code>X≥0</code> from <code>ge</code> on <code>Type*</code>.</p>
<p>There is another problem with this notation (even with <code>|</code>), and that is that <code>≥0</code> and <code>&gt;0</code> become tokens, which means that if we write <code>≥0</code> and <code>&gt;0</code> anywhere in a file that imports this, it will not be interpreted as two tokens:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">rel_with</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">o</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">a</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">//</span> <span class="n">r</span> <span class="n">o</span> <span class="n">a</span> <span class="o">}</span>
<span class="kd">notation</span> <span class="bp">`|`</span><span class="o">:</span><span class="mi">1024</span> <span class="n">α</span><span class="o">:</span><span class="mi">1</span> <span class="bp">`≥</span><span class="mi">0</span><span class="bp">`</span><span class="o">:</span><span class="mi">1</span> <span class="o">:=</span> <span class="n">rel_with</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="bp">≤</span><span class="o">)</span>

<span class="kd">example</span> <span class="o">:</span> <span class="mi">1</span><span class="bp">≥</span><span class="mi">0</span> <span class="o">:=</span> <span class="gr">sorry</span> <span class="c1">-- syntax error</span>
<span class="kd">example</span> <span class="o">:</span> <span class="bp">∀</span><span class="n">x</span><span class="bp">≥</span><span class="mi">0</span><span class="o">,</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span> <span class="o">:=</span> <span class="gr">sorry</span> <span class="c1">-- syntax error</span>
</code></pre></div>



<a name="243896938"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation%20challenge/near/243896938" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/notation.20challenge.html#243896938">(Jun 25 2021 at 10:12)</a>:</h4>
<p>Floris,</p>
<p>thank you for your comments!  I might have learned what a token is!</p>
<p>If this makes sense, I think that what I had in mind then was a "dependent" notation where <code>_&gt;0</code> is the token and <code>_</code> is filled in by the symbol for the Type in question.  Once I say it like this, I realize that this is probably too much to ask for...</p>



<a name="243896988"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation%20challenge/near/243896988" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/notation.20challenge.html#243896988">(Jun 25 2021 at 10:13)</a>:</h4>
<p>On the other hand, this is a good way to enforce that the order relations are separated by spaces...</p>



<a name="243897006"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation%20challenge/near/243897006" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/notation.20challenge.html#243897006">(Jun 25 2021 at 10:13)</a>:</h4>
<p>Actually I guess that's pretty fine because we supposedly always use <code>≤</code> and <code>&lt;</code>. If the Unicode index modifier proposition goes through, then you will be able to write subscripts <code>≥</code> and <code>&gt;</code>.</p>



<a name="243897082"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation%20challenge/near/243897082" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/notation.20challenge.html#243897082">(Jun 25 2021 at 10:14)</a>:</h4>
<p>ah, subscript <code>≥0</code> would look even better!</p>



<a name="243897088"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation%20challenge/near/243897088" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/notation.20challenge.html#243897088">(Jun 25 2021 at 10:14)</a>:</h4>
<p>Another idea is to use <code>≥₀</code> and <code>&gt;₀</code>.</p>



<a name="243897125"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation%20challenge/near/243897125" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/notation.20challenge.html#243897125">(Jun 25 2021 at 10:15)</a>:</h4>
<p>Looks a bit weird, but I think it's fine!</p>



<a name="243897153"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation%20challenge/near/243897153" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/notation.20challenge.html#243897153">(Jun 25 2021 at 10:15)</a>:</h4>
<p>Is that already a notation somewhere?</p>



<a name="243897162"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation%20challenge/near/243897162" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/notation.20challenge.html#243897162">(Jun 25 2021 at 10:15)</a>:</h4>
<p>Yaël, I like your suggestion a lot (until <code>&gt;</code> and <code>≥</code> can be subscripts as well)!  Now the remaining issue is the prefix <code>|</code> that I would like to avoid.</p>



<a name="243897445"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation%20challenge/near/243897445" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/notation.20challenge.html#243897445">(Jun 25 2021 at 10:19)</a>:</h4>
<p>Here is the updated notation:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">rel_with</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">o</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">a</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">//</span> <span class="n">r</span> <span class="n">o</span> <span class="n">a</span> <span class="o">}</span>

<span class="kd">notation</span> <span class="bp">`|`</span><span class="o">:</span><span class="mi">1024</span> <span class="n">α</span><span class="o">:</span><span class="mi">1</span> <span class="bp">`≥₀`</span><span class="o">:</span><span class="mi">1</span> <span class="o">:=</span> <span class="n">rel_with</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="bp">≤</span><span class="o">)</span>
<span class="kd">notation</span> <span class="bp">`|`</span><span class="o">:</span><span class="mi">1024</span> <span class="n">α</span><span class="o">:</span><span class="mi">1</span> <span class="bp">`&gt;₀`</span><span class="o">:</span><span class="mi">1</span> <span class="o">:=</span> <span class="n">rel_with</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="bp">&lt;</span><span class="o">)</span>

<span class="c">/-</span><span class="cm"> Check: works with `pnat`. -/</span>
<span class="kd">lemma</span> <span class="n">pnat_eq_new</span> <span class="o">:</span> <span class="n">pnat</span> <span class="bp">=</span> <span class="bp">|</span><span class="n">ℕ</span><span class="bp">&gt;₀</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="kd">lemma</span> <span class="n">natp_eq_new</span> <span class="o">:</span> <span class="n">ℕ</span><span class="bp">+</span> <span class="bp">=</span> <span class="bp">|</span><span class="n">ℕ</span><span class="bp">&gt;₀</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="c">/-</span><span class="cm"> Check: works with a random Types with `0` and `&lt;`. -/</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">has_zero</span> <span class="n">X</span><span class="o">]</span> <span class="o">[</span><span class="n">has_lt</span> <span class="n">X</span><span class="o">]</span>
<span class="k">#check</span> <span class="o">(</span><span class="bp">|</span><span class="n">X</span><span class="bp">&gt;₀</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>  <span class="c1">--works</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">has_zero</span> <span class="n">Y</span><span class="o">]</span> <span class="o">[</span><span class="n">linear_order</span> <span class="n">Y</span><span class="o">]</span>
<span class="k">#check</span> <span class="o">(</span><span class="bp">|</span><span class="n">Y</span><span class="bp">&gt;₀</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>  <span class="c1">--works</span>
<span class="k">#check</span> <span class="o">(</span><span class="bp">|</span><span class="n">Y</span><span class="bp">≥₀</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>  <span class="c1">--works</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">ordered_add_comm_monoid</span> <span class="n">R</span><span class="o">]</span>
<span class="k">#check</span> <span class="o">(</span><span class="bp">|</span><span class="n">R</span><span class="bp">&gt;₀</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>  <span class="c1">--works</span>
<span class="k">#check</span> <span class="o">(</span><span class="bp">|</span><span class="n">R</span><span class="bp">≥₀</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>  <span class="c1">--works</span>
</code></pre></div>
<p>How do people feel about this?</p>



<a name="243897556"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation%20challenge/near/243897556" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/notation.20challenge.html#243897556">(Jun 25 2021 at 10:20)</a>:</h4>
<p>Does it not pick up the correct thing by itself when you remove the <code>|</code>?</p>



<a name="243898150"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation%20challenge/near/243898150" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/notation.20challenge.html#243898150">(Jun 25 2021 at 10:27)</a>:</h4>
<p>This seems to mess up the already defined notation for pnat and nnreal:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">rel_with</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">o</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">a</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">//</span> <span class="n">r</span> <span class="n">o</span> <span class="n">a</span> <span class="o">}</span>

<span class="kd">notation</span> <span class="n">α</span><span class="bp">`≥₀`</span> <span class="o">:=</span> <span class="n">rel_with</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="bp">≤</span><span class="o">)</span>
<span class="kd">notation</span> <span class="n">α</span><span class="bp">`&gt;₀`</span> <span class="o">:=</span> <span class="n">rel_with</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="bp">&lt;</span><span class="o">)</span>

<span class="k">#check</span> <span class="n">ℕ</span><span class="bp">&gt;₀</span>  <span class="c1">--works</span>
<span class="k">#check</span> <span class="n">ℕ</span><span class="bp">≥₀</span>  <span class="c1">--works</span>

<span class="c1">-- however this does not</span>
<span class="kd">lemma</span> <span class="n">pnat_eq_new</span> <span class="o">:</span> <span class="n">pnat</span> <span class="bp">=</span> <span class="n">ℕ</span><span class="bp">&gt;₀</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="c1">-- not a rfl-lemma, even though marked as rfl</span>
<span class="c1">-- and</span>
<span class="c1">-- invalid pre-numeral, universe level must be &gt; 0</span>
</code></pre></div>
<p>(I get the same error when I try the nnreal "<code>rfl</code>".)</p>



<a name="243898826"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation%20challenge/near/243898826" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/notation.20challenge.html#243898826">(Jun 25 2021 at 10:35)</a>:</h4>
<p>Okay I just don't know how notations work <span aria-label="sad" class="emoji emoji-2639" role="img" title="sad">:sad:</span></p>



<a name="243898939"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation%20challenge/near/243898939" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/notation.20challenge.html#243898939">(Jun 25 2021 at 10:36)</a>:</h4>
<p>Me neither, but thank you very much for your suggestions!</p>



<a name="243899188"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation%20challenge/near/243899188" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/notation.20challenge.html#243899188">(Jun 25 2021 at 10:39)</a>:</h4>
<p>Looking for trouble: this does not work for the same reason as the one above</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">notation</span> <span class="n">α</span><span class="bp">`🐙`</span> <span class="o">:=</span> <span class="n">rel_with</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="bp">&lt;</span><span class="o">)</span>

<span class="k">#check</span> <span class="n">ℕ</span><span class="bp">🐙</span>  <span class="c1">--works</span>

<span class="c1">-- however this does not</span>
<span class="kd">lemma</span> <span class="n">pnat_eq_new</span> <span class="o">:</span> <span class="n">pnat</span> <span class="bp">=</span> <span class="n">ℕ</span><span class="bp">🐙</span> <span class="o">:=</span> <span class="n">rfl</span>
</code></pre></div>
<p>so the <code>&gt;</code> symbol was not actually relevant.</p>



<a name="243899667"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation%20challenge/near/243899667" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> kana <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/notation.20challenge.html#243899667">(Jun 25 2021 at 10:45)</a>:</h4>
<p>It doesn't work because of priority, <br>
check this</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">notation</span> <span class="n">α</span><span class="bp">`🐙`</span> <span class="o">:=</span> <span class="n">α</span> <span class="bp">∧</span> <span class="n">α</span>
<span class="kd">set_option</span> <span class="n">pp.notation</span>
<span class="k">#check</span> <span class="n">ℕ</span> <span class="bp">=</span> <span class="n">ℕ</span><span class="bp">🐙</span>
<span class="c1">-- ℕ = ℕ ∧ ℕ = ℕ : Prop</span>
</code></pre></div>
<p>Just add more priority</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">notation</span> <span class="n">α</span><span class="bp">`🐙`</span><span class="o">:</span><span class="mi">1024</span> <span class="o">:=</span> <span class="n">α</span> <span class="bp">∧</span> <span class="n">α</span>
</code></pre></div>



<a name="243900533"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation%20challenge/near/243900533" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/notation.20challenge.html#243900533">(Jun 25 2021 at 10:56)</a>:</h4>
<p>kana, thank you so much!  This does indeed work!!  </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">notation</span> <span class="n">α</span><span class="bp">`&gt;₀`</span><span class="o">:</span><span class="mi">1024</span> <span class="o">:=</span> <span class="n">rel_with</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="bp">&lt;</span><span class="o">)</span>

<span class="k">#check</span> <span class="n">ℕ</span> <span class="bp">=</span> <span class="n">ℕ</span><span class="bp">&gt;₀</span>  <span class="c1">--works</span>

<span class="kd">lemma</span> <span class="n">pnat_eq_new</span> <span class="o">:</span> <span class="o">{</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">//</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="o">}</span> <span class="bp">=</span> <span class="n">ℕ</span><span class="bp">&gt;₀</span> <span class="o">:=</span> <span class="n">rfl</span>  <span class="c1">--also works!</span>
</code></pre></div>



<a name="243900663"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation%20challenge/near/243900663" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/notation.20challenge.html#243900663">(Jun 25 2021 at 10:58)</a>:</h4>
<p>I suggest using <code>1025</code> or higher as number, so that <code>option ℕ&gt;₀</code> is <code>option (ℕ&gt;₀)</code> and not <code>(option ℕ)&gt;₀</code></p>



<a name="243900668"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation%20challenge/near/243900668" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/notation.20challenge.html#243900668">(Jun 25 2021 at 10:58)</a>:</h4>
<p>So, as long as subscripts for <code>≥</code> and <code>&gt;</code> are available, I think that my current favourites are <code>≥₀</code> and <code>&gt;₀</code>.  Any further thoughts?</p>



<a name="243900692"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation%20challenge/near/243900692" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/notation.20challenge.html#243900692">(Jun 25 2021 at 10:58)</a>:</h4>
<p>The <code>0</code> really looks like it's modifying the inequality though, but maybe that's the best we can do for now...</p>



<a name="243900722"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation%20challenge/near/243900722" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/notation.20challenge.html#243900722">(Jun 25 2021 at 10:59)</a>:</h4>
<p>On paper, I would write <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="double-struck">N</mi><mrow><mo>≥</mo><mn>0</mn></mrow></msub></mrow><annotation encoding="application/x-tex">\mathbb{N}_{\ge 0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.934069em;vertical-align:-0.24517899999999998em;"></span><span class="mord"><span class="mord mathbb">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mrel mtight">≥</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24517899999999998em;"><span></span></span></span></span></span></span></span></span></span>, for sure...</p>



<a name="243900729"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation%20challenge/near/243900729" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/notation.20challenge.html#243900729">(Jun 25 2021 at 10:59)</a>:</h4>
<p>yeah, that would be nice</p>



<a name="243902004"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation%20challenge/near/243902004" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/notation.20challenge.html#243902004">(Jun 25 2021 at 11:16)</a>:</h4>
<p>Another way you can play this game:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">notation</span> <span class="n">α</span> <span class="bp">`ː`</span><span class="o">:</span><span class="mi">1025</span> <span class="n">f</span> <span class="o">:=</span> <span class="n">subtype</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>

<span class="k">#check</span> <span class="n">ℕ</span> <span class="bp">=</span> <span class="n">ℕ</span><span class="bp">ː</span><span class="o">(</span><span class="bp">&gt;</span><span class="mi">0</span><span class="o">)</span>  <span class="c1">--works</span>

<span class="kd">lemma</span> <span class="n">pnat_eq_new</span> <span class="o">:</span> <span class="o">{</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">//</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="o">}</span> <span class="bp">=</span> <span class="n">ℕ</span><span class="bp">ː</span><span class="o">(</span><span class="bp">&gt;</span><span class="mi">0</span><span class="o">)</span> <span class="o">:=</span> <span class="n">rfl</span>  <span class="c1">--also works!</span>
</code></pre></div>



<a name="243902429"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation%20challenge/near/243902429" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/notation.20challenge.html#243902429">(Jun 25 2021 at 11:21)</a>:</h4>
<p>Or even</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="c1">-- I doubt this is a good idea</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_coe_to_fun</span> <span class="kt">Type</span><span class="bp">*</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">α</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">),</span> <span class="n">subtype</span> <span class="n">p</span><span class="o">⟩</span>
<span class="kd">lemma</span> <span class="n">pnat_eq_new'</span> <span class="o">:</span> <span class="o">{</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">//</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="o">}</span> <span class="bp">=</span> <span class="n">ℕ</span><span class="o">(</span><span class="bp">&gt;</span><span class="mi">0</span><span class="o">)</span> <span class="o">:=</span> <span class="n">rfl</span>
</code></pre></div>



<a name="243905510"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation%20challenge/near/243905510" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/notation.20challenge.html#243905510">(Jun 25 2021 at 11:55)</a>:</h4>
<p>Eric, those are good suggestions as well!  I think that I still prefer the other options, mostly since it involves fewer characters when writing the type.</p>



<a name="243905872"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation%20challenge/near/243905872" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/notation.20challenge.html#243905872">(Jun 25 2021 at 11:59)</a>:</h4>
<p>Do you ultimately want to yet the notation <code>ℕ+</code> out of existence?</p>



<a name="243905997"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation%20challenge/near/243905997" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/notation.20challenge.html#243905997">(Jun 25 2021 at 12:00)</a>:</h4>
<p>The advantage of the subtype approach is the notation works for <code>(&lt;0)</code>, <code>(&gt;1)</code>, and even <code>even</code>!</p>



<a name="243907453"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation%20challenge/near/243907453" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/notation.20challenge.html#243907453">(Jun 25 2021 at 12:17)</a>:</h4>
<p>I do not have in mind of replacing old notation, I simply wanted to have a convenient way of talking about positive/non-negative elements for the <code>order</code> refactor.  I want to be able to say easily that multiplying by the non-negative elements is monotone, by the positive one is strictly monotone and so on.  Of course, I can say it without the notation, but accompanying this by a clear symbol seems useful!</p>



<a name="243907559"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation%20challenge/near/243907559" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/notation.20challenge.html#243907559">(Jun 25 2021 at 12:18)</a>:</h4>
<p>Eric, I actually like your suggestion, though I think that maybe both should be available: I see myself using more often the <code>&gt;0</code> case than the general one and it would be nice if that one had a short, informative notation, in my opinion.</p>



<a name="243908500"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation%20challenge/near/243908500" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/notation.20challenge.html#243908500">(Jun 25 2021 at 12:28)</a>:</h4>
<p>For instance, this works (which is great!):</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">open_locale</span> <span class="n">nnreal</span>

<span class="kd">lemma</span> <span class="n">nnreal_eq_new</span> <span class="o">:</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span> <span class="bp">=</span> <span class="n">ℝ</span><span class="bp">ː</span><span class="o">(</span><span class="bp">≥</span><span class="mi">0</span><span class="o">)</span> <span class="o">:=</span> <span class="n">rfl</span>  <span class="c1">--also works!</span>
</code></pre></div>
<p>Maybe, it makes sense to replace the notation for <code>nnreal</code> so that it picks this one up?</p>
<p>Floris'  objection was that you could not then use <code>1&gt;0</code>, though, really this is bad form for two reasons:</p>
<ul>
<li>it uses <code>&gt;</code>;</li>
<li>it does not leave spaces around <code>&gt;</code>.</li>
</ul>
<p>What do you think?</p>



<a name="243908712"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation%20challenge/near/243908712" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/notation.20challenge.html#243908712">(Jun 25 2021 at 12:30)</a>:</h4>
<p>Concretely, how about making these definitions:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">notation</span> <span class="n">α</span> <span class="bp">`ː`</span><span class="o">:</span><span class="mi">1025</span> <span class="n">f</span> <span class="o">:=</span> <span class="n">subtype</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="kd">notation</span> <span class="n">α</span> <span class="bp">`≥</span><span class="mi">0</span><span class="bp">`</span><span class="o">:</span><span class="mi">1025</span> <span class="o">:=</span> <span class="n">subtype</span> <span class="o">((</span><span class="bp">≥</span><span class="mi">0</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="kd">notation</span> <span class="n">α</span> <span class="bp">`&gt;</span><span class="mi">0</span><span class="bp">`</span><span class="o">:</span><span class="mi">1025</span> <span class="o">:=</span> <span class="n">subtype</span> <span class="o">((</span><span class="bp">&gt;</span><span class="mi">0</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
</code></pre></div>
<p>and then there is no need to define <code>nnreal</code> as a special entity: it already means the right thing.</p>



<a name="243908865"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation%20challenge/near/243908865" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/notation.20challenge.html#243908865">(Jun 25 2021 at 12:31)</a>:</h4>
<p>I really think we should be able to keep writing <code>∀ ε &gt; 0</code>. I don't mind being forced to use spaces around <code>&gt;</code> but I'm afraid this will create inconsistencies and confusing error messages.</p>



<a name="243909146"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation%20challenge/near/243909146" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/notation.20challenge.html#243909146">(Jun 25 2021 at 12:34)</a>:</h4>
<p>Actually, Patrick, at the moment the spaces seem to be ignored, so also using them causes problems.  Back to looking for a solution!</p>



<a name="243909651"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation%20challenge/near/243909651" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/notation.20challenge.html#243909651">(Jun 25 2021 at 12:39)</a>:</h4>
<p>Hmm, maybe I take it back.  This works:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.real.basic</span>

<span class="kd">notation</span> <span class="n">α</span> <span class="bp">`ː`</span><span class="o">:</span><span class="mi">1025</span> <span class="n">f</span> <span class="o">:=</span> <span class="n">subtype</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="kd">notation</span> <span class="n">α</span> <span class="bp">`≥</span><span class="mi">0</span><span class="bp">`</span><span class="o">:</span><span class="mi">1025</span> <span class="o">:=</span> <span class="n">subtype</span> <span class="o">((</span><span class="bp">≥</span><span class="mi">0</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="kd">notation</span> <span class="n">α</span> <span class="bp">`&gt;</span><span class="mi">0</span><span class="bp">`</span><span class="o">:</span><span class="mi">1025</span> <span class="o">:=</span> <span class="n">subtype</span> <span class="o">((</span><span class="bp">&gt;</span><span class="mi">0</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_zero</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span> <span class="o">:=</span> <span class="o">⟨⟨</span><span class="mi">0</span><span class="o">,</span> <span class="n">rfl.le</span><span class="o">⟩⟩</span>

<span class="kd">lemma</span> <span class="n">eps</span> <span class="o">{</span><span class="n">ε</span> <span class="o">:</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">ε</span> <span class="bp">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">ε</span> <span class="o">:=</span> <span class="n">h</span>
</code></pre></div>
<p>Note that these are all the imports and there is no <code>open_locale nnreal</code>.</p>



<a name="243909880"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation%20challenge/near/243909880" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/notation.20challenge.html#243909880">(Jun 25 2021 at 12:41)</a>:</h4>
<p>The error here</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">{</span><span class="n">ε</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">:</span> <span class="n">ε</span><span class="bp">&gt;</span><span class="mi">0</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>
<p>is </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">type</span> <span class="n">expected</span> <span class="n">at</span>
  <span class="n">ε</span>
<span class="n">term</span> <span class="n">has</span> <span class="n">type</span>
  <span class="n">ℝ</span>
</code></pre></div>



<a name="243909999"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation%20challenge/near/243909999" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/notation.20challenge.html#243909999">(Jun 25 2021 at 12:42)</a>:</h4>
<p>notation tokens ignore spaces iirc, like if you write <code>notation  α` ≥0 `:1025 := &lt;blah&gt;</code> it just basically tells the pretty-printer to use the spaces around it when displaying it, but lets you type it in without them</p>



<a name="243910070"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation%20challenge/near/243910070" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/notation.20challenge.html#243910070">(Jun 25 2021 at 12:43)</a>:</h4>
<p>Indeed, these two give errors:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">{</span><span class="n">ε</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">:</span> <span class="n">ε</span><span class="bp">&gt;</span><span class="mi">0</span> <span class="o">:=</span> <span class="gr">sorry</span> <span class="c1">-- error</span>
<span class="kd">example</span> <span class="o">{</span><span class="n">ε</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">:</span> <span class="n">ε</span> <span class="bp">&gt;</span><span class="mi">0</span> <span class="o">:=</span> <span class="gr">sorry</span> <span class="c1">-- error</span>
</code></pre></div>
<p>while</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">{</span><span class="n">ε</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">:</span> <span class="n">ε</span> <span class="bp">&gt;</span> <span class="mi">0</span> <span class="o">:=</span> <span class="gr">sorry</span> <span class="c1">-- ok</span>
<span class="kd">example</span> <span class="o">{</span><span class="n">ε</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">:</span> <span class="n">ε</span><span class="bp">&gt;</span> <span class="mi">0</span> <span class="o">:=</span> <span class="gr">sorry</span> <span class="c1">-- ok</span>
</code></pre></div>
<p>do not</p>



<a name="243910389"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation%20challenge/near/243910389" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/notation.20challenge.html#243910389">(Jun 25 2021 at 12:46)</a>:</h4>
<p>The conclusion is that if you maintain <code>&gt;</code> and <code>0</code> separate by a space, you split the token and you do not pick up the <code>subtype</code> notation.</p>
<p>I personally find this acceptable, though I maybe not everyone does...</p>



<a name="243911404"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation%20challenge/near/243911404" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/notation.20challenge.html#243911404">(Jun 25 2021 at 12:55)</a>:</h4>
<p>Unless I am mistaken, there seem to be 45 uses of <code>&gt;0</code> in the current master (many of which in doc-strings) and, the only uses of <code>≥0</code> are in <code>ℝ≥0</code> (possibly continuing to <code>ℝ≥0∞</code>).</p>



<a name="243912190"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation%20challenge/near/243912190" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/notation.20challenge.html#243912190">(Jun 25 2021 at 13:02)</a>:</h4>
<p>Here is a proposal (and note that I do not feel strongly in favour, although it does seem nice notation and somewhat useful).</p>
<p>Define</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">notation</span> <span class="n">α</span> <span class="bp">`ː`</span><span class="o">:</span><span class="mi">1025</span> <span class="n">f</span> <span class="o">:=</span> <span class="n">subtype</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="kd">notation</span> <span class="n">α</span> <span class="bp">`≥</span><span class="mi">0</span><span class="bp">`</span><span class="o">:</span><span class="mi">1025</span> <span class="o">:=</span> <span class="n">subtype</span> <span class="o">((</span><span class="bp">≥</span><span class="mi">0</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="kd">notation</span> <span class="n">α</span> <span class="bp">`&gt;</span><span class="mi">0</span><span class="bp">`</span><span class="o">:</span><span class="mi">1025</span> <span class="o">:=</span> <span class="n">subtype</span> <span class="o">((</span><span class="bp">&gt;</span><span class="mi">0</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
</code></pre></div>
<p>and get rid of the special notation for <code>nnreal</code>, since now it is a special case of this one.</p>
<p>Also, this will enforce using <code>&gt; 0</code> and <code>≥ 0</code>, rather than <code>&gt;0</code> and <code>≥0</code> (emphasis on the space), when you really mean the inequality, as the alternative would give an obscure error.</p>
<p>Feel free to thumbs up if you like, thumbs down if you do not!</p>



<a name="243994679"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation%20challenge/near/243994679" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/notation.20challenge.html#243994679">(Jun 26 2021 at 04:47)</a>:</h4>
<p>I attempted this change and the main issue that I found was that it got tricky to use the <code>nnreal</code> namespace, since Lean would often want it to be <code>subtype</code> instead.  This (and especially Mario's thumb down), makes me skeptical of this approach.</p>
<p>I still might give a try to Eric's</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">notation</span> <span class="n">α</span> <span class="bp">`ː`</span><span class="o">:</span><span class="mi">1025</span> <span class="n">f</span> <span class="o">:=</span> <span class="n">subtype</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
</code></pre></div>
<p>for types of non-negative/positive elements.</p>
<p>Mario, what do you think about this?</p>



<a name="244026229"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation%20challenge/near/244026229" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/notation.20challenge.html#244026229">(Jun 26 2021 at 17:51)</a>:</h4>
<p>This idea to have new notation for <code>subtype</code> is fascinating, especially since it can pair well with slices of relations and other predicates.  For what it's worth, it seems that <code>&amp;</code> is free to use, and it's somewhat mnemonic:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">notation</span> <span class="n">α</span> <span class="bp">`&amp;`</span><span class="o">:</span><span class="mi">1025</span> <span class="n">f</span> <span class="o">:=</span> <span class="n">subtype</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">posnat</span> <span class="o">:=</span> <span class="n">ℕ</span><span class="bp">&amp;</span><span class="o">(</span><span class="bp">≥</span><span class="mi">1</span><span class="o">)</span>
<span class="c1">-- "natural and greater than or equal to 1"</span>
<span class="kd">def</span> <span class="n">evennat</span> <span class="o">:=</span> <span class="n">ℕ</span><span class="bp">&amp;</span><span class="n">even</span>
<span class="c1">-- "natural and even"</span>
</code></pre></div>



<a name="244026496"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation%20challenge/near/244026496" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/notation.20challenge.html#244026496">(Jun 26 2021 at 17:56)</a>:</h4>
<p>Or, dual to <span class="user-mention" data-user-id="310045">@Eric Wieser</span>'s suspect idea, I'll throw in my own:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">:</span> <span class="n">has_coe_to_sort</span> <span class="o">(</span><span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">f</span><span class="o">,</span> <span class="n">subtype</span> <span class="n">f</span><span class="o">⟩</span>

<span class="kd">def</span> <span class="n">posreal</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">≥</span><span class="o">(</span><span class="mi">1</span><span class="o">:</span><span class="n">ℝ</span><span class="o">))</span>
</code></pre></div>
<p>(please don't do this <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span>)</p>



<a name="244027586"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation%20challenge/near/244027586" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/notation.20challenge.html#244027586">(Jun 26 2021 at 18:19)</a>:</h4>
<p>I think that using <code>≥0</code> alone to mean subtype is way too implicit. Everyone knows that it means "greater than or equal to zero" so this overloading is going to cause confusion. <code>:</code> is problematic because it is used to mean typing in binders and in type ascription. <code>&amp;</code> is sufficiently strange that I would only want it to be a local notation so that the reader is constantly reminded what it means</p>



<a name="244027643"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation%20challenge/near/244027643" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/notation.20challenge.html#244027643">(Jun 26 2021 at 18:19)</a>:</h4>
<p>I think the best notation is <code>{x // x≥0}</code></p>



<a name="244027706"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation%20challenge/near/244027706" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/notation.20challenge.html#244027706">(Jun 26 2021 at 18:20)</a>:</h4>
<p>for particular subtypes that have names like <code>ennreal</code> it makes sense to have a dedicated notation, but <code>subtype</code> already has a notation</p>



<a name="244028036"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation%20challenge/near/244028036" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/notation.20challenge.html#244028036">(Jun 26 2021 at 18:29)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113488-general/topic/notation.20challenge/near/244027586">said</a>:</p>
<blockquote>
<p><code>:</code> is problematic because it is used to mean typing in binders and in type ascription</p>
</blockquote>
<p>I'd thought so, too, but you have to zoom in to <code>ː</code> or get your text editor to tell you it's MODIFIER LETTER TRIANGULAR COLON</p>



<a name="244028789"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation%20challenge/near/244028789" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/notation.20challenge.html#244028789">(Jun 26 2021 at 18:48)</a>:</h4>
<p>I am happy to use the <code>&amp;</code> in a special locale.  Eventually, my hope would be to use this under the hood, for proving the basic stuff about inequalities, but that it would be seen as an explicit positivity assumption in "externally applied" lemmas.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/Addressing.20mismatch.20issues.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Addressing.20mismatch.20issues.html">Addressing mismatch issues</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="227039620"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Addressing%20mismatch%20issues/near/227039620" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Peter Nelson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Addressing.20mismatch.20issues.html#227039620">(Feb 19 2021 at 22:27)</a>:</h4>
<p>I am working with a bunch of calculations with expressions that depend on fintype, and mismatch issues are happening. From what I understand, avoiding the mismatches arising is not feasible, but I'm looking for a non-painful way to handle them.</p>
<p>Each individual mismatch can generally be handled with <code>convert rfl</code>,  and indeed sometimes this will kill the problems if there is more than one. But it can be hard to handle these issues when they occur in a complicated context and the pretty-printer makes differences invisible. For instance, suppose that <code>a</code> and <code>a'</code> are complicated expressions in <code>int</code>, indistinguishable without diving into implicit parameters, and hiding different <code>fintype</code> instances. Let <code>b</code> and <code>b'</code> be another such pair.  Now <code>a = a'</code> and <code>b = b'</code> can be proved with <code>convert rfl</code> (or maybe <code>congr'</code>), but how would I prove, say, that <code>-b + x + a + b' + y + z - a'  = x + y + z</code>, where <code>x</code>, <code>y</code> and <code>z</code> are themselves long and complicated enough that copy-pasting them into a proof would double its length? </p>
<p>This is clearly possible, but quite awkard  in the middle of a proof. Of course, a proof somehow isomorphic to <code>rw [(by convert rfl : a = a'), (by convert rfl : b = b')], linarith</code> is what I would like. But I can't do this without hundreds of characters and underscores, because <code>a</code> and <code>a'</code> are syntactically identical! </p>
<p>Unfortunately it is hard to come up with an mwe because the nature of my gripe is 'in a complicated context', but I hope I've communicated my question. </p>
<p>(Of course, what I would really like is a way to seamlessly replace <code>fintype</code> with a similar typeclass that is purely propositional, in a way that doesn't involve remaking half the API from scratch, but I don't know how to do that, either).</p>



<a name="227052403"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Addressing%20mismatch%20issues/near/227052403" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Addressing.20mismatch.20issues.html#227052403">(Feb 20 2021 at 00:50)</a>:</h4>
<p>If you can't rewrite with a lemma due to a mismatching fintypes instance, that usually means that the lemma is written badly, and only applies to a specific instance</p>



<a name="227052891"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Addressing%20mismatch%20issues/near/227052891" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Addressing.20mismatch.20issues.html#227052891">(Feb 20 2021 at 00:57)</a>:</h4>
<p>I teach my mathematician students to use <code>set.finite</code> and [finite X] where none of these problems occur. I have no interest in constructive finiteness</p>



<a name="227053440"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Addressing%20mismatch%20issues/near/227053440" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Addressing.20mismatch.20issues.html#227053440">(Feb 20 2021 at 01:04)</a>:</h4>
<p>oh apparently mathlib doesn't have <code>finite X</code> -- hard luck.</p>



<a name="227073233"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Addressing%20mismatch%20issues/near/227073233" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Addressing.20mismatch.20issues.html#227073233">(Feb 20 2021 at 07:14)</a>:</h4>
<p><span class="user-mention" data-user-id="329425">@Peter Nelson</span> These issues sound quite similar to the issues that we have been facing in homological algebra. Where you have a complex of (say) vector spaces, indexed by <code>int</code> or <code>nat</code>. And now you fact the issues that <code>V i</code> is not the same vector space as <code>V (i - 1 + 1)</code>. Which is of course ridiculous. We are still experimenting to find the best solution.</p>



<a name="227073256"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Addressing%20mismatch%20issues/near/227073256" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Addressing.20mismatch.20issues.html#227073256">(Feb 20 2021 at 07:15)</a>:</h4>
<p>But more on topic, I think that you provide another strong datapoint for the need of a propositional analogue of <code>fintype</code>.</p>



<a name="227097066"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Addressing%20mismatch%20issues/near/227097066" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Addressing.20mismatch.20issues.html#227097066">(Feb 20 2021 at 15:12)</a>:</h4>
<p><span class="user-mention" data-user-id="329425">@Peter Nelson</span> let's first get one thing clear -- are we talking about finite types, or finite subsets of types? We already have <code>set.finite</code> in mathlib, which is an "I am finite" predicate on a set which does not suffer from all the constructivist problems you're seeing.</p>



<a name="227097531"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Addressing%20mismatch%20issues/near/227097531" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Peter Nelson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Addressing.20mismatch.20issues.html#227097531">(Feb 20 2021 at 15:21)</a>:</h4>
<p>We're talking about finite types. I'm not using finset directly at all, except where I'm being forced to. Here is some code - one of the problems occurs in the last lemma. </p>
<p>(Related to the fact that I'm not using finset, what I'm trying to do here is to make the shorthand <code>∑ (a : X), f a</code> easier to work with, since most of the <code>finset.sum</code> API is instead written in terms of <code>∑ a in X, f a</code>.)</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="c1">----------------------------------------------------------------</span>
<span class="n">open_locale</span> <span class="n">classical</span> <span class="n">big_operators</span>
<span class="kn">open</span> <span class="n">set</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">:</span> <span class="kt">Type</span><span class="o">}[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">][</span><span class="n">add_comm_monoid</span> <span class="n">β</span><span class="o">](</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span>

<span class="kd">lemma</span> <span class="n">set.to_finset_insert'</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)(</span><span class="n">e</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">X</span> <span class="bp">∪</span> <span class="o">{</span><span class="n">e</span><span class="o">})</span><span class="bp">.</span><span class="n">to_finset</span> <span class="bp">=</span> <span class="n">X.to_finset</span> <span class="bp">∪</span> <span class="o">{</span><span class="n">e</span><span class="o">}</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span><span class="n">ext</span><span class="o">,</span> <span class="n">simp</span><span class="o">[</span><span class="n">or_comm</span><span class="o">]}</span>

<span class="kd">lemma</span> <span class="n">fin_sum_eq</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">):</span>
  <span class="bp">∑</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">X</span><span class="o">),</span> <span class="n">f</span> <span class="n">a</span> <span class="bp">=</span> <span class="bp">∑</span> <span class="n">a</span> <span class="k">in</span> <span class="n">X.to_finset</span><span class="o">,</span> <span class="n">f</span> <span class="n">a</span> <span class="o">:=</span>
<span class="k">let</span> <span class="n">φ</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">↪</span> <span class="n">α</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">coe</span><span class="o">,</span> <span class="n">subtype.coe_injective</span><span class="o">⟩</span> <span class="k">in</span> <span class="o">(</span><span class="n">finset.sum_map</span> <span class="o">(</span><span class="n">finset.univ</span><span class="o">)</span> <span class="n">φ</span> <span class="n">f</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span>

<span class="kd">lemma</span> <span class="n">fin_sum_insert</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}{</span><span class="n">e</span> <span class="o">:</span> <span class="n">α</span><span class="o">}:</span>
  <span class="n">e</span> <span class="bp">∉</span> <span class="n">X</span> <span class="bp">→</span> <span class="bp">∑</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">∪</span> <span class="o">{</span><span class="n">e</span><span class="o">}),</span> <span class="n">f</span> <span class="n">a</span> <span class="bp">=</span> <span class="o">(</span><span class="bp">∑</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">X</span><span class="o">),</span> <span class="n">f</span> <span class="n">a</span><span class="o">)</span> <span class="bp">+</span> <span class="n">f</span> <span class="n">e</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rintro</span> <span class="n">he</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hdj</span> <span class="o">:</span><span class="n">disjoint</span> <span class="n">X.to_finset</span> <span class="o">{</span><span class="n">e</span><span class="o">},</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">finset.disjoint_iff_inter_eq_empty</span><span class="o">],</span> <span class="n">ext</span><span class="o">,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">finset.not_mem_empty</span><span class="o">,</span> <span class="n">not_and</span><span class="o">,</span> <span class="n">finset.mem_singleton</span><span class="o">,</span> <span class="n">iff_false</span><span class="o">,</span> <span class="n">finset.mem_inter</span><span class="o">,</span> <span class="n">mem_to_finset</span><span class="o">],</span>
    <span class="n">exact</span> <span class="bp">λ</span> <span class="n">haX</span> <span class="n">hae</span><span class="o">,</span> <span class="n">false.elim</span> <span class="o">(</span><span class="n">he</span> <span class="o">(</span><span class="kd">by</span> <span class="o">{</span><span class="n">rwa</span> <span class="bp">←</span><span class="n">hae</span><span class="o">})),},</span>

  <span class="c1">-- this next claim causes instance mismatch problems if fin_sum_eq is invoked directly,</span>
  <span class="c1">-- due to two competing instances of fintype for X ∪ {e}</span>
  <span class="k">have</span> <span class="n">hXe</span> <span class="o">:</span> <span class="bp">∑</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="o">(</span><span class="n">X</span> <span class="bp">∪</span><span class="o">{</span><span class="n">e</span><span class="o">})</span> <span class="o">),</span> <span class="n">f</span> <span class="n">a</span> <span class="bp">=</span> <span class="bp">∑</span> <span class="n">a</span> <span class="k">in</span> <span class="o">(</span><span class="n">X</span> <span class="bp">∪</span> <span class="o">{</span><span class="n">e</span><span class="o">})</span><span class="bp">.</span><span class="n">to_finset</span><span class="o">,</span> <span class="n">f</span> <span class="n">a</span><span class="o">,</span>
    <span class="n">convert</span> <span class="n">fin_sum_eq</span> <span class="n">f</span> <span class="o">(</span><span class="n">X</span> <span class="bp">∪</span> <span class="o">{</span><span class="n">e</span><span class="o">}</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">),</span>

  <span class="n">rw</span> <span class="o">[</span><span class="n">hXe</span><span class="o">,</span> <span class="n">fin_sum_eq</span> <span class="n">f</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">),</span> <span class="n">set.to_finset_insert'</span> <span class="n">X</span> <span class="n">e</span><span class="o">,</span> <span class="n">finset.sum_union</span> <span class="n">hdj</span><span class="o">],</span>
  <span class="n">simp</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="227097915"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Addressing%20mismatch%20issues/near/227097915" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Addressing.20mismatch.20issues.html#227097915">(Feb 20 2021 at 15:28)</a>:</h4>
<p>Why don't you just use finsets here? it shouldn't be hard to have analogues of all the sets you could want with <code>open_locale classical</code></p>



<a name="227098209"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Addressing%20mismatch%20issues/near/227098209" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Peter Nelson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Addressing.20mismatch.20issues.html#227098209">(Feb 20 2021 at 15:33)</a>:</h4>
<p>The <code>set</code> API is just more complete.</p>



<a name="227098374"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Addressing%20mismatch%20issues/near/227098374" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Addressing.20mismatch.20issues.html#227098374">(Feb 20 2021 at 15:36)</a>:</h4>
<p>Only when it comes to equality of sets. The finset API is a lot more complete when it comes to summation; you can do the summation stuff on finsets and pull back to sets for the set algebra</p>



<a name="227098783"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Addressing%20mismatch%20issues/near/227098783" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Addressing.20mismatch.20issues.html#227098783">(Feb 20 2021 at 15:44)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">fin_sum_insert</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}{</span><span class="n">e</span> <span class="o">:</span> <span class="n">α</span><span class="o">}:</span>
  <span class="n">e</span> <span class="bp">∉</span> <span class="n">X</span> <span class="bp">→</span> <span class="bp">∑</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">∪</span> <span class="o">{</span><span class="n">e</span><span class="o">}),</span> <span class="n">f</span> <span class="n">a</span> <span class="bp">=</span> <span class="o">(</span><span class="bp">∑</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">X</span><span class="o">),</span> <span class="n">f</span> <span class="n">a</span><span class="o">)</span> <span class="bp">+</span> <span class="n">f</span> <span class="n">e</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rintro</span> <span class="n">he</span><span class="o">,</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">X</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span> <span class="o">:=</span> <span class="o">(</span><span class="n">finite.of_fintype</span> <span class="n">X</span><span class="o">)</span><span class="bp">.</span><span class="n">exists_finset_coe</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">fin_sum_eq</span><span class="o">,</span> <span class="n">add_comm</span><span class="o">,</span> <span class="bp">←</span> <span class="n">finset.sum_insert</span><span class="o">],</span>
  <span class="n">convert</span> <span class="o">(</span><span class="n">fin_sum_eq</span> <span class="n">f</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">trans</span> <span class="n">_</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">congr'</span><span class="o">,</span> <span class="n">ext</span><span class="o">,</span> <span class="n">simp</span> <span class="o">},</span>
  <span class="n">simpa</span> <span class="n">using</span> <span class="n">he</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="227098892"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Addressing%20mismatch%20issues/near/227098892" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Addressing.20mismatch.20issues.html#227098892">(Feb 20 2021 at 15:46)</a>:</h4>
<p><code>set.to_finset</code> doesn't seem to have many lemmas about it, although it does have <code>mem_to_finset</code> which is why the <code>ext, simp</code> works</p>



<a name="227098907"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Addressing%20mismatch%20issues/near/227098907" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Peter Nelson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Addressing.20mismatch.20issues.html#227098907">(Feb 20 2021 at 15:46)</a>:</h4>
<p>so the trick is <code>exists_finset_coe</code>?</p>



<a name="227098943"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Addressing%20mismatch%20issues/near/227098943" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Addressing.20mismatch.20issues.html#227098943">(Feb 20 2021 at 15:47)</a>:</h4>
<p>That's how you make everything use finsets</p>



<a name="227099011"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Addressing%20mismatch%20issues/near/227099011" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Peter Nelson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Addressing.20mismatch.20issues.html#227099011">(Feb 20 2021 at 15:48)</a>:</h4>
<p>Good to know - thanks!</p>



<a name="227100994"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Addressing%20mismatch%20issues/near/227100994" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Peter Nelson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Addressing.20mismatch.20issues.html#227100994">(Feb 20 2021 at 16:09)</a>:</h4>
<p>Unfortunately it seems like the problem cascades. Here's an attempted consequence of the above where a mismatch issue carries forward, with either of our proofs of <code>fin_sum_insert</code>. The context is a little contrived - is is the problematic part of a proof by induction. The proof that works involves reducing to a case where a single <code>convert</code> resolves the goal, but rewriting earlier fails. </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">subadditive</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">:=</span>
  <span class="bp">∀</span> <span class="n">X</span> <span class="n">Y</span><span class="o">,</span> <span class="n">g</span> <span class="o">(</span><span class="n">X</span> <span class="bp">∪</span> <span class="n">Y</span><span class="o">)</span> <span class="bp">≤</span> <span class="n">g</span> <span class="n">X</span> <span class="bp">+</span> <span class="n">g</span> <span class="n">Y</span>

<span class="kd">lemma</span> <span class="n">foo</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">set</span> <span class="n">α</span><span class="o">)){</span><span class="n">g</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">ℤ</span><span class="o">}{</span><span class="n">X₀</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}(</span><span class="n">hX₀</span> <span class="o">:</span> <span class="n">X₀</span> <span class="bp">∉</span> <span class="n">S</span><span class="o">)</span>
<span class="o">(</span><span class="n">hg</span> <span class="o">:</span> <span class="n">subadditive</span> <span class="n">g</span><span class="o">)</span> <span class="o">(</span><span class="n">hS</span> <span class="o">:</span> <span class="n">g</span> <span class="o">(</span><span class="bp">⋃₀</span> <span class="n">S</span><span class="o">)</span> <span class="bp">≤</span> <span class="bp">∑</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="bp">↥</span><span class="n">S</span><span class="o">),</span> <span class="n">g</span> <span class="n">X</span><span class="o">):</span>
  <span class="n">g</span> <span class="o">(</span><span class="bp">⋃₀</span><span class="o">(</span><span class="n">S</span> <span class="bp">∪</span> <span class="o">{</span><span class="n">X₀</span><span class="o">}))</span> <span class="bp">≤</span> <span class="bp">∑</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="bp">↥</span><span class="o">(</span><span class="n">S</span> <span class="bp">∪</span> <span class="o">{</span><span class="n">X₀</span><span class="o">})),</span> <span class="n">g</span> <span class="n">X</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="c1">-- rw fin_sum_insert g hX₀,</span>
  <span class="c1">-- Doesn't work</span>

  <span class="n">simp_rw</span> <span class="o">[</span><span class="n">sUnion_union</span><span class="o">,</span> <span class="n">sUnion_singleton</span><span class="o">]</span> <span class="n">at</span> <span class="n">hS</span> <span class="bp">⊢</span><span class="o">,</span>

  <span class="n">refine</span> <span class="n">le_trans</span> <span class="o">(</span><span class="n">hg</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">refine</span> <span class="n">le_trans</span> <span class="o">(</span><span class="n">int.add_le_add_right</span> <span class="n">hS</span> <span class="o">(</span><span class="n">g</span> <span class="n">X₀</span><span class="o">))</span> <span class="o">(</span><span class="n">le_of_eq</span> <span class="n">_</span><span class="o">),</span>
  <span class="n">convert</span> <span class="o">(</span><span class="n">fin_sum_insert</span> <span class="n">g</span> <span class="n">hX₀</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="o">,</span>
  <span class="c1">-- works</span>
<span class="kd">end</span>
</code></pre></div>



<a name="227101170"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Addressing%20mismatch%20issues/near/227101170" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Addressing.20mismatch.20issues.html#227101170">(Feb 20 2021 at 16:11)</a>:</h4>
<p>So you can't use <code>S : finset (set \a)</code>?</p>



<a name="227101285"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Addressing%20mismatch%20issues/near/227101285" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Peter Nelson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Addressing.20mismatch.20issues.html#227101285">(Feb 20 2021 at 16:13)</a>:</h4>
<p>I probably could, but I would be worried that this will just move the problem further upwards. In the case I want to invoke, <code>S</code> has type <code>set (set \a)</code> because it's a collection of equivalence classes, so I would have to use some type of equivalence between <code>set</code> and <code>finset</code> to get to <code>finset (set \a)</code>.</p>



<a name="227101844"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Addressing%20mismatch%20issues/near/227101844" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Addressing.20mismatch.20issues.html#227101844">(Feb 20 2021 at 16:22)</a>:</h4>
<p>Yes, that's <code>exists_finset_coe</code> as you saw</p>



<a name="227101853"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Addressing%20mismatch%20issues/near/227101853" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Addressing.20mismatch.20issues.html#227101853">(Feb 20 2021 at 16:23)</a>:</h4>
<p>or <code>set.to_finset</code></p>



<a name="227101991"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Addressing%20mismatch%20issues/near/227101991" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Addressing.20mismatch.20issues.html#227101991">(Feb 20 2021 at 16:25)</a>:</h4>
<p>So I guess you can do</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">obtain</span> <span class="bp">\&lt;</span><span class="n">S</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">\&gt;</span> <span class="o">:=</span> <span class="n">exists_finset_coe</span> <span class="n">S</span>
</code></pre></div>
<p>or something like that, as first line of the proof</p>



<a name="227102011"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Addressing%20mismatch%20issues/near/227102011" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Addressing.20mismatch.20issues.html#227102011">(Feb 20 2021 at 16:25)</a>:</h4>
<p>Right, as Mario suggested upstairs:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">X</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span> <span class="o">:=</span> <span class="o">(</span><span class="n">finite.of_fintype</span> <span class="n">X</span><span class="o">)</span><span class="bp">.</span><span class="n">exists_finset_coe</span><span class="o">,</span>
</code></pre></div>



<a name="227102059"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Addressing%20mismatch%20issues/near/227102059" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Addressing.20mismatch.20issues.html#227102059">(Feb 20 2021 at 16:26)</a>:</h4>
<p>After that, the proof should be "smooth"</p>



<a name="227102075"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Addressing%20mismatch%20issues/near/227102075" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Addressing.20mismatch.20issues.html#227102075">(Feb 20 2021 at 16:26)</a>:</h4>
<p>it wasn't completely smooth, there seem to be some missing simp lemmas</p>



<a name="227102737"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Addressing%20mismatch%20issues/near/227102737" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Peter Nelson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Addressing.20mismatch.20issues.html#227102737">(Feb 20 2021 at 16:38)</a>:</h4>
<p>Yeah, that last proof is something where I want things from both APIs at the same time.</p>



<a name="227103036"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Addressing%20mismatch%20issues/near/227103036" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Peter Nelson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Addressing.20mismatch.20issues.html#227103036">(Feb 20 2021 at 16:44)</a>:</h4>
<p>of course, what I actually want is that <code>fintype</code> be propositional.</p>



<a name="227109003"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Addressing%20mismatch%20issues/near/227109003" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Addressing.20mismatch.20issues.html#227109003">(Feb 20 2021 at 18:31)</a>:</h4>
<p>If you use <code>convert ... using 1</code>, does it show what doesn't match?</p>



<a name="227114245"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Addressing%20mismatch%20issues/near/227114245" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Peter Nelson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Addressing.20mismatch.20issues.html#227114245">(Feb 20 2021 at 20:02)</a>:</h4>
<p>The first instance of <code>fintype ↥(S ∪ {X₀})</code> is this : </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="o">(</span><span class="bp">@</span><span class="n">subtype.fintype</span> <span class="o">(</span><span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">),</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">S</span><span class="o">)</span>
     <span class="o">(</span><span class="bp">@</span><span class="n">set.decidable_mem</span> <span class="o">(</span><span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="n">S</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">),</span> <span class="n">classical.prop_decidable</span> <span class="o">(</span><span class="n">S</span> <span class="n">a</span><span class="o">)))</span>
     <span class="o">(</span><span class="bp">@</span><span class="n">set.fintype</span> <span class="n">α</span> <span class="n">_inst_1</span><span class="o">))</span>
  <span class="o">(</span><span class="bp">@</span><span class="n">set.fintype_pure</span> <span class="o">(</span><span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="n">X₀</span><span class="o">)</span>
</code></pre></div>
<p>and the second is this : </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">@</span><span class="n">set.fintype_union</span> <span class="o">(</span><span class="n">set</span> <span class="n">α</span><span class="o">)</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">),</span>
     <span class="bp">@</span><span class="n">fintype.decidable_pi_fintype</span> <span class="n">α</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">),</span> <span class="n">classical.prop_decidable</span> <span class="o">(</span><span class="n">a</span> <span class="bp">=</span> <span class="n">b</span><span class="o">))</span>
       <span class="n">_inst_1</span>
       <span class="n">a</span>
       <span class="n">b</span><span class="o">)</span>
  <span class="n">S</span>
  <span class="o">{</span><span class="n">X₀</span><span class="o">}</span>
  <span class="o">(</span><span class="bp">@</span><span class="n">subtype.fintype</span> <span class="o">(</span><span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">),</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">S</span><span class="o">)</span>
     <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">),</span> <span class="bp">@</span><span class="n">set.decidable_mem</span> <span class="o">(</span><span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="n">S</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">),</span> <span class="n">classical.prop_decidable</span> <span class="o">(</span><span class="n">S</span> <span class="n">a</span><span class="o">))</span> <span class="n">a</span><span class="o">)</span>
     <span class="o">(</span><span class="bp">@</span><span class="n">set.fintype</span> <span class="n">α</span> <span class="n">_inst_1</span><span class="o">))</span>
  <span class="o">(</span><span class="bp">@</span><span class="n">set.fintype_pure</span> <span class="o">(</span><span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="n">X₀</span><span class="o">)</span>
</code></pre></div>



<a name="227114591"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Addressing%20mismatch%20issues/near/227114591" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Peter Nelson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Addressing.20mismatch.20issues.html#227114591">(Feb 20 2021 at 20:07)</a>:</h4>
<p>Ah, so it's actually <code>decidable_eq</code> that is the culprit! The difference between the above is :</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">fintype.decidable_pi_fintype</span> <span class="n">α</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">),</span> <span class="n">classical.prop_decidable</span> <span class="o">(</span><span class="n">a</span> <span class="bp">=</span> <span class="n">b</span><span class="o">))</span>
<span class="n">_inst_1</span>
<span class="n">a</span>
<span class="n">b</span>
</code></pre></div>
<p>vs </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">classical.prop_decidable</span> <span class="o">(</span><span class="n">a</span> <span class="bp">=</span> <span class="n">b</span><span class="o">)</span>
</code></pre></div>
<p>I don't know if that makes any of these problems easier to address....</p>



<a name="227118320"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Addressing%20mismatch%20issues/near/227118320" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Addressing.20mismatch.20issues.html#227118320">(Feb 20 2021 at 21:14)</a>:</h4>
<p>What should propositional finiteness be called? <code>[is_finite alpha]</code>?</p>



<a name="227122813"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Addressing%20mismatch%20issues/near/227122813" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Addressing.20mismatch.20issues.html#227122813">(Feb 20 2021 at 22:20)</a>:</h4>
<p>My assumption is that <a href="https://leanprover-community.github.io/mathlib_docs/find/fin_sum_insert">docs#fin_sum_insert</a> is stated poorly</p>



<a name="227122854"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Addressing%20mismatch%20issues/near/227122854" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Addressing.20mismatch.20issues.html#227122854">(Feb 20 2021 at 22:20)</a>:</h4>
<p>But that link doesn't work - where is that lemma?</p>



<a name="227122949"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Addressing%20mismatch%20issues/near/227122949" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Addressing.20mismatch.20issues.html#227122949">(Feb 20 2021 at 22:22)</a>:</h4>
<p>It was proved earlier in this thread: <a href="#narrow/stream/113488-general/topic/Addressing.20mismatch.20issues/near/227098783">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Addressing.20mismatch.20issues/near/227098783</a></p>



<a name="227123571"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Addressing%20mismatch%20issues/near/227123571" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Addressing.20mismatch.20issues.html#227123571">(Feb 20 2021 at 22:32)</a>:</h4>
<p>Is there a full mwe?</p>



<a name="227123738"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Addressing%20mismatch%20issues/near/227123738" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Addressing.20mismatch.20issues.html#227123738">(Feb 20 2021 at 22:35)</a>:</h4>
<p>I think the lemma needs <code>[fintype X]</code> and <code>[fintype (X \union {e})]</code> to avoid this problem</p>



<a name="227125108"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Addressing%20mismatch%20issues/near/227125108" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Peter Nelson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Addressing.20mismatch.20issues.html#227125108">(Feb 20 2021 at 22:55)</a>:</h4>
<p>This mwe is a union of things earlier, but here is all of it in one place: </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="c1">----------------------------------------------------------------</span>
<span class="n">open_locale</span> <span class="n">classical</span> <span class="n">big_operators</span>
<span class="kn">open</span> <span class="n">set</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">:</span> <span class="kt">Type</span><span class="o">}[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">][</span><span class="n">add_comm_monoid</span> <span class="n">β</span><span class="o">](</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span>

<span class="kd">lemma</span> <span class="n">set.to_finset_insert'</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)(</span><span class="n">e</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">X</span> <span class="bp">∪</span> <span class="o">{</span><span class="n">e</span><span class="o">})</span><span class="bp">.</span><span class="n">to_finset</span> <span class="bp">=</span> <span class="n">X.to_finset</span> <span class="bp">∪</span> <span class="o">{</span><span class="n">e</span><span class="o">}</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span><span class="n">ext</span><span class="o">,</span> <span class="n">simp</span><span class="o">[</span><span class="n">or_comm</span><span class="o">]}</span>

<span class="kd">lemma</span> <span class="n">fin_sum_eq</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">):</span>
  <span class="bp">∑</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">X</span><span class="o">),</span> <span class="n">f</span> <span class="n">a</span> <span class="bp">=</span> <span class="bp">∑</span> <span class="n">a</span> <span class="k">in</span> <span class="n">X.to_finset</span><span class="o">,</span> <span class="n">f</span> <span class="n">a</span> <span class="o">:=</span>
<span class="k">let</span> <span class="n">φ</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">↪</span> <span class="n">α</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">coe</span><span class="o">,</span> <span class="n">subtype.coe_injective</span><span class="o">⟩</span> <span class="k">in</span> <span class="o">(</span><span class="n">finset.sum_map</span> <span class="o">(</span><span class="n">finset.univ</span><span class="o">)</span> <span class="n">φ</span> <span class="n">f</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span>

<span class="kd">lemma</span> <span class="n">fin_sum_insert</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}{</span><span class="n">e</span> <span class="o">:</span> <span class="n">α</span><span class="o">}:</span>
  <span class="n">e</span> <span class="bp">∉</span> <span class="n">X</span> <span class="bp">→</span> <span class="bp">∑</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">∪</span> <span class="o">{</span><span class="n">e</span><span class="o">}),</span> <span class="n">f</span> <span class="n">a</span> <span class="bp">=</span> <span class="o">(</span><span class="bp">∑</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">X</span><span class="o">),</span> <span class="n">f</span> <span class="n">a</span><span class="o">)</span> <span class="bp">+</span> <span class="n">f</span> <span class="n">e</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rintro</span> <span class="n">he</span><span class="o">,</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">X</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span> <span class="o">:=</span> <span class="o">(</span><span class="n">finite.of_fintype</span> <span class="n">X</span><span class="o">)</span><span class="bp">.</span><span class="n">exists_finset_coe</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">fin_sum_eq</span><span class="o">,</span> <span class="n">add_comm</span><span class="o">,</span> <span class="bp">←</span> <span class="n">finset.sum_insert</span><span class="o">],</span>
  <span class="n">convert</span> <span class="o">(</span><span class="n">fin_sum_eq</span> <span class="n">f</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">trans</span> <span class="n">_</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">congr'</span><span class="o">,</span> <span class="n">ext</span><span class="o">,</span> <span class="n">simp</span> <span class="o">},</span>
  <span class="n">simpa</span> <span class="n">using</span> <span class="n">he</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">def</span> <span class="n">subadditive</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">:=</span>
  <span class="bp">∀</span> <span class="n">X</span> <span class="n">Y</span><span class="o">,</span> <span class="n">g</span> <span class="o">(</span><span class="n">X</span> <span class="bp">∪</span> <span class="n">Y</span><span class="o">)</span> <span class="bp">≤</span> <span class="n">g</span> <span class="n">X</span> <span class="bp">+</span> <span class="n">g</span> <span class="n">Y</span>


<span class="kd">lemma</span> <span class="n">foo</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">set</span> <span class="n">α</span><span class="o">)){</span><span class="n">g</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">ℤ</span><span class="o">}{</span><span class="n">X₀</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}(</span><span class="n">hX₀</span> <span class="o">:</span> <span class="n">X₀</span> <span class="bp">∉</span> <span class="n">S</span><span class="o">)</span>
<span class="o">(</span><span class="n">hg</span> <span class="o">:</span> <span class="n">subadditive</span> <span class="n">g</span><span class="o">)</span> <span class="o">(</span><span class="n">hS</span> <span class="o">:</span> <span class="n">g</span> <span class="o">(</span><span class="bp">⋃₀</span> <span class="n">S</span><span class="o">)</span> <span class="bp">≤</span> <span class="bp">∑</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="bp">↥</span><span class="n">S</span><span class="o">),</span> <span class="n">g</span> <span class="n">X</span><span class="o">):</span>
  <span class="n">g</span> <span class="o">(</span><span class="bp">⋃₀</span><span class="o">(</span><span class="n">S</span> <span class="bp">∪</span> <span class="o">{</span><span class="n">X₀</span><span class="o">}))</span> <span class="bp">≤</span> <span class="bp">∑</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="bp">↥</span><span class="o">(</span><span class="n">S</span> <span class="bp">∪</span> <span class="o">{</span><span class="n">X₀</span><span class="o">})),</span> <span class="n">g</span> <span class="n">X</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">simp_rw</span> <span class="o">[</span><span class="n">sUnion_union</span><span class="o">,</span> <span class="n">sUnion_singleton</span><span class="o">]</span> <span class="n">at</span> <span class="n">hS</span> <span class="bp">⊢</span><span class="o">,</span>

  <span class="c1">--would like to rw here with fin_sum_insert but can't.</span>

  <span class="n">refine</span> <span class="n">le_trans</span> <span class="o">(</span><span class="n">hg</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">refine</span> <span class="n">le_trans</span> <span class="o">(</span><span class="n">int.add_le_add_right</span> <span class="n">hS</span> <span class="o">(</span><span class="n">g</span> <span class="n">X₀</span><span class="o">))</span> <span class="o">(</span><span class="n">le_of_eq</span> <span class="n">_</span><span class="o">),</span>
  <span class="n">convert</span> <span class="o">(</span><span class="n">fin_sum_insert</span> <span class="n">g</span> <span class="n">hX₀</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="227125300"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Addressing%20mismatch%20issues/near/227125300" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Addressing.20mismatch.20issues.html#227125300">(Feb 20 2021 at 22:58)</a>:</h4>
<p>Thanks, I'll try my idea out myself tomorrow</p>



<a name="227131817"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Addressing%20mismatch%20issues/near/227131817" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Addressing.20mismatch.20issues.html#227131817">(Feb 21 2021 at 01:10)</a>:</h4>
<p>Is this just not going to work because subadditive is defined in a classical context?</p>



<a name="227171527"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Addressing%20mismatch%20issues/near/227171527" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Addressing.20mismatch.20issues.html#227171527">(Feb 21 2021 at 14:36)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/113488-general/topic/Addressing.20mismatch.20issues/near/227123738">said</a>:</p>
<blockquote>
<p>I think the lemma needs <code>[fintype X]</code> and <code>[fintype (X \union {e})]</code> to avoid this problem</p>
</blockquote>
<p>Yes, this fixes it, in conjuction with removing <code>fintype α</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="c1">----------------------------------------------------------------</span>
<span class="n">open_locale</span> <span class="n">classical</span> <span class="n">big_operators</span>
<span class="kn">open</span> <span class="n">set</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">β</span><span class="o">](</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span>

<span class="kd">lemma</span> <span class="n">set.to_finset_insert'</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">[</span><span class="n">fintype</span> <span class="bp">↥</span><span class="n">X</span><span class="o">]</span> <span class="o">[</span><span class="n">fintype</span> <span class="bp">↥</span><span class="o">(</span><span class="n">X</span> <span class="bp">∪</span> <span class="o">{</span><span class="n">e</span><span class="o">})]:</span>
  <span class="o">(</span><span class="n">X</span> <span class="bp">∪</span> <span class="o">{</span><span class="n">e</span><span class="o">})</span><span class="bp">.</span><span class="n">to_finset</span> <span class="bp">=</span> <span class="n">X.to_finset</span> <span class="bp">∪</span> <span class="o">{</span><span class="n">e</span><span class="o">}</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span><span class="n">ext</span><span class="o">,</span> <span class="n">simp</span><span class="o">[</span><span class="n">or_comm</span><span class="o">]}</span>

<span class="kd">lemma</span> <span class="n">fin_sum_eq</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">[</span><span class="n">fintype</span> <span class="bp">↥</span><span class="n">X</span><span class="o">]</span> <span class="o">:</span>
  <span class="bp">∑</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">X</span><span class="o">),</span> <span class="n">f</span> <span class="n">a</span> <span class="bp">=</span> <span class="bp">∑</span> <span class="n">a</span> <span class="k">in</span> <span class="n">X.to_finset</span><span class="o">,</span> <span class="n">f</span> <span class="n">a</span> <span class="o">:=</span>
<span class="k">let</span> <span class="n">φ</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">↪</span> <span class="n">α</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">coe</span><span class="o">,</span> <span class="n">subtype.coe_injective</span><span class="o">⟩</span> <span class="k">in</span> <span class="o">(</span><span class="n">finset.sum_map</span> <span class="o">(</span><span class="n">finset.univ</span><span class="o">)</span> <span class="n">φ</span> <span class="n">f</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span>

<span class="kd">lemma</span> <span class="n">fin_sum_insert</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}{</span><span class="n">e</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="bp">↥</span><span class="n">X</span><span class="o">]</span> <span class="o">[</span><span class="n">fintype</span> <span class="bp">↥</span><span class="o">(</span><span class="n">X</span> <span class="bp">∪</span> <span class="o">{</span><span class="n">e</span><span class="o">})]:</span>
  <span class="n">e</span> <span class="bp">∉</span> <span class="n">X</span> <span class="bp">→</span> <span class="bp">∑</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">∪</span> <span class="o">{</span><span class="n">e</span><span class="o">}),</span> <span class="n">f</span> <span class="n">a</span> <span class="bp">=</span> <span class="o">(</span><span class="bp">∑</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">X</span><span class="o">),</span> <span class="n">f</span> <span class="n">a</span><span class="o">)</span> <span class="bp">+</span> <span class="n">f</span> <span class="n">e</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rintro</span> <span class="n">he</span><span class="o">,</span>
  <span class="n">unfreezingI</span> <span class="o">{</span> <span class="n">obtain</span> <span class="o">⟨</span><span class="n">X'</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">finite.exists_finset_coe</span> <span class="o">⟨‹</span><span class="n">fintype</span> <span class="bp">↥</span><span class="n">X</span><span class="o">›⟩</span> <span class="o">},</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">fin_sum_eq</span><span class="o">,</span> <span class="n">fin_sum_eq</span><span class="o">,</span> <span class="n">add_comm</span><span class="o">,</span> <span class="bp">←</span><span class="n">finset.sum_insert</span><span class="o">],</span>
  <span class="o">{</span> <span class="n">congr'</span><span class="o">,</span> <span class="n">ext</span><span class="o">,</span> <span class="n">simp</span> <span class="o">},</span>
  <span class="n">simpa</span> <span class="n">using</span> <span class="n">he</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">def</span> <span class="n">subadditive</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">:=</span>
  <span class="bp">∀</span> <span class="n">X</span> <span class="n">Y</span><span class="o">,</span> <span class="n">g</span> <span class="o">(</span><span class="n">X</span> <span class="bp">∪</span> <span class="n">Y</span><span class="o">)</span> <span class="bp">≤</span> <span class="n">g</span> <span class="n">X</span> <span class="bp">+</span> <span class="n">g</span> <span class="n">Y</span>


<span class="kd">lemma</span> <span class="n">foo</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">set</span> <span class="n">α</span><span class="o">))</span> <span class="o">[</span><span class="n">fintype</span> <span class="bp">↥</span><span class="n">S</span><span class="o">]</span> <span class="o">{</span><span class="n">g</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">ℤ</span><span class="o">}</span> <span class="o">{</span><span class="n">X₀</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="bp">↥</span><span class="o">(</span><span class="n">S</span> <span class="bp">∪</span> <span class="o">{</span><span class="n">X₀</span><span class="o">})]</span> <span class="o">(</span><span class="n">hX₀</span> <span class="o">:</span> <span class="n">X₀</span> <span class="bp">∉</span> <span class="n">S</span><span class="o">)</span>
<span class="o">(</span><span class="n">hg</span> <span class="o">:</span> <span class="n">subadditive</span> <span class="n">g</span><span class="o">)</span> <span class="o">(</span><span class="n">hS</span> <span class="o">:</span> <span class="n">g</span> <span class="o">(</span><span class="bp">⋃₀</span> <span class="n">S</span><span class="o">)</span> <span class="bp">≤</span> <span class="bp">∑</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="bp">↥</span><span class="n">S</span><span class="o">),</span> <span class="n">g</span> <span class="n">X</span><span class="o">):</span>
  <span class="n">g</span> <span class="o">(</span><span class="bp">⋃₀</span><span class="o">(</span><span class="n">S</span> <span class="bp">∪</span> <span class="o">{</span><span class="n">X₀</span><span class="o">}))</span> <span class="bp">≤</span> <span class="bp">∑</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="bp">↥</span><span class="o">(</span><span class="n">S</span> <span class="bp">∪</span> <span class="o">{</span><span class="n">X₀</span><span class="o">})),</span> <span class="n">g</span> <span class="n">X</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">simp_rw</span> <span class="o">[</span><span class="n">sUnion_union</span><span class="o">,</span> <span class="n">sUnion_singleton</span><span class="o">]</span> <span class="n">at</span> <span class="n">hS</span> <span class="bp">⊢</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">fin_sum_insert</span> <span class="n">_</span> <span class="n">hX₀</span><span class="o">,</span>  <span class="c1">-- rw works</span>
  <span class="gr">sorry</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="227171548"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Addressing%20mismatch%20issues/near/227171548" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Addressing.20mismatch.20issues.html#227171548">(Feb 21 2021 at 14:37)</a>:</h4>
<p>You should never assume a more general <code>fintype</code> instance than the one the lemma actually requires and let the specific one be derived, because then the lemma won't match again terms which obtain the specific one via a different means</p>



<a name="227188243"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Addressing%20mismatch%20issues/near/227188243" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Peter Nelson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Addressing.20mismatch.20issues.html#227188243">(Feb 21 2021 at 19:23)</a>:</h4>
<p>Thank you! What if I want to invoke <code>fin_sum_insert</code> in the middle of a larger proof where there is already a <code>fintype α</code> instance hanging around?</p>



<a name="227189118"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Addressing%20mismatch%20issues/near/227189118" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Addressing.20mismatch.20issues.html#227189118">(Feb 21 2021 at 19:38)</a>:</h4>
<p>It should work fine</p>



<a name="227189176"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Addressing%20mismatch%20issues/near/227189176" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Addressing.20mismatch.20issues.html#227189176">(Feb 21 2021 at 19:40)</a>:</h4>
<p>When you rewrite, the instances on the left-hand side of the eq / iff will already be present in the goal, while typeclass instances will try to deduce the ones on the right-hand-side</p>



<a name="227189910"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Addressing%20mismatch%20issues/near/227189910" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Peter Nelson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Addressing.20mismatch.20issues.html#227189910">(Feb 21 2021 at 19:52)</a>:</h4>
<p>Ok. I've run into a curiosity that results from this solution when I'm applying it in an inductive proof. The below is the smallest example where I can reproduce the issue. </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="c1">----------------------------------------------------------------</span>
<span class="n">open_locale</span> <span class="n">classical</span> <span class="n">big_operators</span>
<span class="kn">open</span> <span class="n">set</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}[</span><span class="n">add_comm_monoid</span> <span class="n">β</span><span class="o">]</span>

<span class="kd">lemma</span> <span class="n">fin_sum_empty</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∑</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∅</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)),</span> <span class="n">f</span> <span class="n">a</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="n">finset.sum_empty</span>

<span class="kd">lemma</span> <span class="n">fin_sum_eq</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)(</span><span class="n">X</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)[</span><span class="n">fintype</span> <span class="n">X</span><span class="o">]:</span>
  <span class="bp">∑</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">X</span><span class="o">),</span> <span class="n">f</span> <span class="n">a</span> <span class="bp">=</span> <span class="bp">∑</span> <span class="n">a</span> <span class="k">in</span> <span class="n">X.to_finset</span><span class="o">,</span> <span class="n">f</span> <span class="n">a</span> <span class="o">:=</span>
<span class="k">let</span> <span class="n">φ</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">↪</span> <span class="n">α</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">coe</span><span class="o">,</span> <span class="n">subtype.coe_injective</span><span class="o">⟩</span> <span class="k">in</span> <span class="o">(</span><span class="n">finset.sum_map</span> <span class="o">(</span><span class="n">finset.univ</span><span class="o">)</span> <span class="n">φ</span> <span class="n">f</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span>

<span class="kd">lemma</span> <span class="n">fin_sum_insert</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">){</span><span class="n">X</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}{</span><span class="n">e</span> <span class="o">:</span> <span class="n">α</span><span class="o">}(</span><span class="n">he</span> <span class="o">:</span> <span class="n">e</span> <span class="bp">∉</span> <span class="n">X</span><span class="o">)[</span><span class="n">fintype</span> <span class="bp">↥</span><span class="n">X</span><span class="o">][</span><span class="n">fintype</span> <span class="bp">↥</span><span class="o">(</span><span class="n">X</span> <span class="bp">∪</span> <span class="o">{</span><span class="n">e</span><span class="o">})]:</span>
   <span class="bp">∑</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">∪</span> <span class="o">{</span><span class="n">e</span><span class="o">}),</span> <span class="n">f</span> <span class="n">a</span> <span class="bp">=</span> <span class="o">(</span><span class="bp">∑</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">X</span><span class="o">),</span> <span class="n">f</span> <span class="n">a</span><span class="o">)</span> <span class="bp">+</span> <span class="n">f</span> <span class="n">e</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">unfreezingI</span> <span class="o">{</span><span class="n">obtain</span> <span class="o">⟨</span><span class="n">X'</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">finite.exists_finset_coe</span> <span class="o">⟨‹</span><span class="n">fintype</span> <span class="bp">↥</span><span class="n">X</span><span class="o">›⟩</span> <span class="o">},</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">fin_sum_eq</span><span class="o">,</span> <span class="n">fin_sum_eq</span><span class="o">,</span> <span class="n">add_comm</span><span class="o">,</span> <span class="bp">←</span><span class="n">finset.sum_insert</span><span class="o">],</span>
  <span class="o">{</span> <span class="n">congr'</span><span class="o">,</span> <span class="n">ext</span><span class="o">,</span> <span class="n">simp</span> <span class="o">},</span>
  <span class="n">simpa</span> <span class="n">using</span> <span class="n">he</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">induction_foo</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">](</span><span class="n">P</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">):</span>
  <span class="o">(</span><span class="n">P</span> <span class="bp">∅</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)(</span><span class="n">e</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">e</span> <span class="bp">∉</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">P</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">P</span> <span class="o">(</span><span class="n">X</span> <span class="bp">∪</span> <span class="o">{</span><span class="n">e</span><span class="o">}))</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">X</span><span class="o">,</span> <span class="n">P</span> <span class="n">X</span><span class="o">)</span> <span class="o">:=</span>
<span class="gr">sorry</span>

<span class="kd">lemma</span> <span class="n">fin_sum_one_eq_card</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">](</span><span class="n">X</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">):</span>
  <span class="bp">∑</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">X</span><span class="o">),</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">ℤ</span><span class="o">)</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">X.to_finset.card</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">revert</span> <span class="n">X</span><span class="o">,</span> <span class="n">apply</span> <span class="n">induction_foo</span><span class="o">,</span>
  <span class="o">{</span><span class="n">rw</span> <span class="o">[</span><span class="n">to_finset_card</span><span class="o">,</span> <span class="n">empty_card'</span><span class="o">],</span> <span class="n">convert</span> <span class="n">fin_sum_empty</span> <span class="n">_</span><span class="o">,</span> <span class="o">},</span>

  <span class="n">intros</span> <span class="n">X</span> <span class="n">e</span> <span class="n">he</span> <span class="n">hX</span><span class="o">,</span>
  <span class="c1">-- rw fin_sum_insert _ he,</span>
  <span class="c1">-- doesn't work</span>

  <span class="n">rw</span> <span class="n">fin_sum_insert</span><span class="o">,</span> <span class="n">swap</span><span class="o">,</span> <span class="n">assumption</span><span class="o">,</span>
  <span class="c1">--works</span>

  <span class="gr">sorry</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>In the proof of <code>fin_sum_one_eq_card</code>, I am able to rw with <code>fin_sum_insert</code> if I don't pass it the term <code>he</code>, but if I pass it <code>he</code>, the rewrite fails, even though <code>he</code> is exactly the term it needs, and resolving the goal later using <code>he</code> works fine . The <code>swap, assumption</code> handles this cleanly enough in practice, but I'd still like to understand what is happening, and can't figure it out.</p>



<a name="227190523"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Addressing%20mismatch%20issues/near/227190523" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Addressing.20mismatch.20issues.html#227190523">(Feb 21 2021 at 20:03)</a>:</h4>
<p>I don't know the answer to your question, but <code>convert</code> works so it's some type class inference issue again. Independent of that, why have you got such a horrible <code>∑ (a : ↥X), 1 ↑a</code> term? Why not just some over <code>a \in X</code>? Oh! Because it's not a finset :-( I think your fabulous questions are just indicating that we need some API. We solved this with <code>finsum_in</code> when we were doing finite groups: see <a href="https://github.com/ImperialCollegeLondon/group-theory-game/blob/152ec4a92ad67b6174a3d240c63fa56a6df6017e/src/finsum/basic.lean#L54">here</a>.</p>



<a name="227190656"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Addressing%20mismatch%20issues/near/227190656" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Addressing.20mismatch.20issues.html#227190656">(Feb 21 2021 at 20:05)</a>:</h4>
<p>I totally agree with you, all this constructive stuff is hard to work with but as you can see there are now sufficiently many experts around going "no it's fine, just think about it this way and there's a trick" that we've all just got used to it and learnt the tricks. Why not just write your own API and sorry it all out? <code>finsum_in</code> will solve all your problems. The proofs are just hacks to reduce everything to finset.sum and are very ugly but you don't care about those, you just reap the benefits.</p>



<a name="227191231"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Addressing%20mismatch%20issues/near/227191231" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Addressing.20mismatch.20issues.html#227191231">(Feb 21 2021 at 20:15)</a>:</h4>
<p><span class="user-mention" data-user-id="329425">@Peter Nelson</span> I hesitated to introduce these new definitions because some people pointed out to me that the tools we have are enough for the job as long as you continually jump over the traps you're running into, and hence because such a nonconstructive approach is not strictly necessary (it all _can_ be done with what we have) I was just in danger of adding to the noise a la <a href="https://xkcd.com/927/">xkcd#927</a>. However your situation I think just makes it clear that we need them. If this sort of stuff is deterring beginners then it's clear that there's an argument for it. I've suggested these before but here we go again:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">is_finite</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span>
<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">finsum</span> <span class="o">{</span><span class="n">ι</span> <span class="n">M</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span> <span class="n">M</span> <span class="c1">-- zero if support infinite</span>
<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">finsum_in</span> <span class="o">{</span><span class="n">ι</span> <span class="n">M</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ι</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span> <span class="n">M</span> <span class="c1">-- zero if support intersect s is infinite</span>
<span class="kd">def</span> <span class="n">fincard</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="c1">-- zero if X is infinite</span>
</code></pre></div>
<p>Why don't you switch to these, sorry all the lemmas you need and feed them back, and we can just make the API? I've done it once before and it was quite fun, I just didn't get round to PR'ing it because some people weren't convinced this stuff was needed. In some sense they might be right -- jump through some hoops, use <code>convert</code> and woo-hoo, it's all computable! I am losing my patience with this approach.</p>



<a name="227191355"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Addressing%20mismatch%20issues/near/227191355" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Addressing.20mismatch.20issues.html#227191355">(Feb 21 2021 at 20:17)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="n">intros</span> <span class="n">X</span> <span class="n">e</span> <span class="n">he</span> <span class="n">hX</span><span class="o">,</span>
  <span class="n">convert</span> <span class="n">fin_sum_insert</span> <span class="n">_</span> <span class="n">he</span><span class="o">,</span> <span class="c1">-- this works</span>
  <span class="k">have</span> <span class="o">:</span> <span class="bp">↑</span><span class="o">((</span><span class="n">X</span> <span class="bp">∪</span> <span class="o">{</span><span class="n">e</span><span class="o">})</span><span class="bp">.</span><span class="n">to_finset.card</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">∑</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="bp">↥</span><span class="n">X</span><span class="o">),</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">ℤ</span><span class="o">)</span> <span class="bp">↑</span><span class="n">a</span> <span class="bp">+</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">ℤ</span><span class="o">)</span> <span class="n">e</span><span class="o">,</span> <span class="c1">-- the goal!</span>
    <span class="gr">sorry</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">this</span><span class="o">,</span> <span class="c1">-- stupid typeclass fail</span>
</code></pre></div>



<a name="227191429"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Addressing%20mismatch%20issues/near/227191429" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Addressing.20mismatch.20issues.html#227191429">(Feb 21 2021 at 20:18)</a>:</h4>
<p>With my approach there will be no up-arrows</p>



<a name="227194037"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Addressing%20mismatch%20issues/near/227194037" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason KY. <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Addressing.20mismatch.20issues.html#227194037">(Feb 21 2021 at 21:06)</a>:</h4>
<p>I wonder if it is worthwhile just pr <a href="https://github.com/leanprover-community/mathlib/blob/fincard/src/data/fincard.lean#L91">finsum</a>. All of the APIs are already done. I don't think too many standards is an issue if we can easily convert between the standards and I feel that this has come up often enough to warrant a separate definition.</p>



<a name="227196168"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Addressing%20mismatch%20issues/near/227196168" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Peter Nelson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Addressing.20mismatch.20issues.html#227196168">(Feb 21 2021 at 21:47)</a>:</h4>
<p>I like this idea. I do see the perspective of the more constructively inclined, and am even (on some level) enjoying how much these subtle issues  teach me about the language. I'm grateful for all the help, patience and expertise I've been getting here. </p>
<p>However, I am planning to give a talk in the near future to fellows combinatorialists about how great/fun formalization is, and these types of problems are among the downsides on my mind. 'Traps' is the right word - none of the problems are insurmountable, but they are barriers to entry. Being someone very interested in theorems about finite structures, I suspect that this stuff happens more frequently for me than many others, and it would be good to have a solution that can be explained in terms an average mathematician can immediately understand. </p>
<p>Regarding an API, I would love to have such a thing available in mathlib. Likely not much would be needed - I suspect the existing one is all I would need to work with.</p>



<a name="227199082"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Addressing%20mismatch%20issues/near/227199082" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Addressing.20mismatch.20issues.html#227199082">(Feb 21 2021 at 22:22)</a>:</h4>
<p>A linter to catch the type of <code>decidable</code> / <code>fintype</code> instance problems I resolved above would likely help with avoiding some of these traps</p>



<a name="227200100"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Addressing%20mismatch%20issues/near/227200100" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Addressing.20mismatch.20issues.html#227200100">(Feb 21 2021 at 22:42)</a>:</h4>
<p>Yes but I think the time has come now to do this -- and I'm about to sit down and do it -- because there are some people who simply never ever want to #eval anything and simply do not need the trouble which things like <code>fintype </code> and <code>finset.sum</code> can cause, especially if they open_locale classical on line 1 and then occasionally use types which have got decidable equality. It's just one extra hassle which doesn't need to be dealt with. Avigad told me that Isabelle has finsum and it works fine.</p>



<a name="227200247"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Addressing%20mismatch%20issues/near/227200247" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Addressing.20mismatch.20issues.html#227200247">(Feb 21 2021 at 22:45)</a>:</h4>
<p><span class="user-mention" data-user-id="243312">@Jason KY.</span> I'll put you as co-author, I'll do it on the discord.</p>



<a name="227208904"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Addressing%20mismatch%20issues/near/227208904" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Addressing.20mismatch.20issues.html#227208904">(Feb 22 2021 at 01:19)</a>:</h4>
<p>It's not just <code>#eval</code>, when it comes to facts about small matrices or something <code>dec_trivial</code> can sometimes be the most powerful tool at our disposal</p>



<a name="227208953"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Addressing%20mismatch%20issues/near/227208953" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Addressing.20mismatch.20issues.html#227208953">(Feb 22 2021 at 01:20)</a>:</h4>
<p>That's not a great situation, since that approach has a host of limitations, but it is what it is</p>



<a name="227209160"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Addressing%20mismatch%20issues/near/227209160" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Addressing.20mismatch.20issues.html#227209160">(Feb 22 2021 at 01:24)</a>:</h4>
<p>That said I'm in agreement on the introduction of <code>fincard</code> and <code>finsum</code> FWIW. There are just a lot of lemmas that are needed to make this nice - I found at least two or three in my proof above, regarding the interaction between <code>set.to_finset</code> and all of the finset API; with a finsum API we also need lemmas relating it to finset sum, and also copies of everything in the finset sum API.</p>



<a name="227211278"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Addressing%20mismatch%20issues/near/227211278" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Addressing.20mismatch.20issues.html#227211278">(Feb 22 2021 at 02:08)</a>:</h4>
<p>First attempt to make a <code>finsum</code> API is <a href="https://github.com/leanprover-community/mathlib/issues/6355">#6355</a>. Many thanks to <span class="user-mention" data-user-id="243312">@Jason KY.</span> who did most of the work.</p>



<a name="227211348"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Addressing%20mismatch%20issues/near/227211348" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Addressing.20mismatch.20issues.html#227211348">(Feb 22 2021 at 02:10)</a>:</h4>
<p><span class="user-mention" data-user-id="329425">@Peter Nelson</span> we don't make propositional finite types because we can just use <code>nonempty (fintype α)</code>. We don't do cardinality yet, that is some work we have prepared but haven't got into PR shape yet. This might take some time to get through the system.</p>



<a name="227212808"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Addressing%20mismatch%20issues/near/227212808" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Peter Nelson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Addressing.20mismatch.20issues.html#227212808">(Feb 22 2021 at 02:36)</a>:</h4>
<p>That sounds great - I look forward to tinkering tomorrow. </p>
<p>Might there be a case for also adding <code>finmax</code> to the API? It is a special case of <code>finsum</code> (and could be defined as such), but API lemmas in which maxima are taken over subsets etc could be useful. Something I'm currently doing uses <code>fintype.exists_max</code> + choice  to define a maximum, and I haven't run into any mismatch issues so far, but who knows what will happen in the future.</p>



<a name="227213393"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Addressing%20mismatch%20issues/near/227213393" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Peter Nelson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Addressing.20mismatch.20issues.html#227213393">(Feb 22 2021 at 02:47)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}[</span><span class="n">linear_order</span> <span class="n">β</span><span class="o">]</span>

<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">finmax</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">β</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="c1">-- some default value if no max exists, otherwise the max</span>

<span class="kd">lemma</span> <span class="n">finmax_is_max</span> <span class="o">[</span><span class="n">nonempty</span> <span class="n">α</span><span class="o">][</span><span class="n">nonempty</span> <span class="o">(</span><span class="n">fintype</span> <span class="n">α</span><span class="o">)](</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">):</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">finmax</span> <span class="n">f</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">lemma</span> <span class="n">exists_argmax</span>  <span class="o">[</span><span class="n">nonempty</span> <span class="n">α</span><span class="o">][</span><span class="n">nonempty</span> <span class="o">(</span><span class="n">fintype</span> <span class="n">α</span><span class="o">)](</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">):</span> <span class="bp">∃</span> <span class="n">x</span><span class="o">,</span>  <span class="n">f</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">finmax</span> <span class="n">f</span>  <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>
<p>etc etc</p>



<a name="227213587"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Addressing%20mismatch%20issues/near/227213587" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Addressing.20mismatch.20issues.html#227213587">(Feb 22 2021 at 02:51)</a>:</h4>
<p>That seems very near to what <code>supr</code> already does</p>



<a name="227213673"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Addressing%20mismatch%20issues/near/227213673" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Addressing.20mismatch.20issues.html#227213673">(Feb 22 2021 at 02:52)</a>:</h4>
<p>we just need a version of <code>supr</code> that works on any preorder</p>



<a name="227213770"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Addressing%20mismatch%20issues/near/227213770" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Peter Nelson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Addressing.20mismatch.20issues.html#227213770">(Feb 22 2021 at 02:54)</a>:</h4>
<p>The existence of an argmax following from (propositional) finiteness is what I'm after.  I can't see anything about finiteness in the <code>supr</code> API, but maybe I'm missing something?</p>



<a name="227213778"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Addressing%20mismatch%20issues/near/227213778" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Addressing.20mismatch.20issues.html#227213778">(Feb 22 2021 at 02:54)</a>:</h4>
<p>finite lattices are complete</p>



<a name="227213863"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Addressing%20mismatch%20issues/near/227213863" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Peter Nelson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Addressing.20mismatch.20issues.html#227213863">(Feb 22 2021 at 02:56)</a>:</h4>
<p>Is there a <code>fintype</code> hiding there somewhere?</p>



<a name="227213907"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Addressing%20mismatch%20issues/near/227213907" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Addressing.20mismatch.20issues.html#227213907">(Feb 22 2021 at 02:57)</a>:</h4>
<p>My point is that for the <code>finmax</code> function, you don't need any inputs except for <code>preorder B</code> and <code>nonempty A</code>, and it can be well defined whenever anything like it makes sense; you can then prove that it makes sense when A is finite to make use of it in your scenario</p>



<a name="227213955"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Addressing%20mismatch%20issues/near/227213955" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Addressing.20mismatch.20issues.html#227213955">(Feb 22 2021 at 02:58)</a>:</h4>
<p>there's no need to bake finiteness into the definition though</p>



<a name="227214054"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Addressing%20mismatch%20issues/near/227214054" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Addressing.20mismatch.20issues.html#227214054">(Feb 22 2021 at 03:00)</a>:</h4>
<p>actually <code>nonempty B</code> is probably better than <code>nonempty A</code> here, that way it can default to the zero of the codomain instead of a random value</p>



<a name="227214091"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Addressing%20mismatch%20issues/near/227214091" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Addressing.20mismatch.20issues.html#227214091">(Feb 22 2021 at 03:01)</a>:</h4>
<p><code>inhabited B</code> is probably better</p>



<a name="227214319"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Addressing%20mismatch%20issues/near/227214319" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Peter Nelson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Addressing.20mismatch.20issues.html#227214319">(Feb 22 2021 at 03:05)</a>:</h4>
<p>Ah, it looks like <code>set.finite.exists_maximal_wrt</code> already does what I want , without any <code>fintype</code>. Here it is: </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">set.finite.exists_maximal_wrt</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">[</span><span class="n">partial_order</span> <span class="n">β</span><span class="o">]</span>
<span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">s.finite</span><span class="o">)</span> <span class="o">:</span>
<span class="n">s.nonempty</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∃</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">),</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a'</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">a'</span> <span class="bp">∈</span> <span class="n">s</span> <span class="bp">→</span> <span class="n">f</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">f</span> <span class="n">a'</span> <span class="bp">→</span> <span class="n">f</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">a'</span><span class="o">)</span>
</code></pre></div>
<p>Or not quite, but it's easy to get a <code>linear_order</code> version.</p>



<a name="228975133"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Addressing%20mismatch%20issues/near/228975133" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Peter Nelson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Addressing.20mismatch.20issues.html#228975133">(Mar 05 2021 at 15:49)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> <span class="user-mention" data-user-id="243312">@Jason KY.</span>  I've started incorporating <code>finsum</code> into my project, as well as rolling my own <code>fincard</code> by finsumming ones (I'm assuming the intended implementation of <code>fincard</code> is more principled, but mine will do for now). It's great avoiding the mismatches, and what's more, not to have to regularly descend into finset coercion hell in the first place! </p>
<p>I have a question about intended usage. For most of my interaction with <code>finsum</code>, everything will be happening with <code>variables {\a : Type} [nonempty (fintype \a)]</code> at the top of files. But this will mean that for each of the <code>finsum</code> and <code>finsum_in</code> lemmas that require explicit finiteness assumptions (which already each come in a few different flavours) , there will be yet another version that takes a nonempty fintype instance. For example, here are statements of a lemma I proved and its version that takes an instance. </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">finsum_le_finsum</span> <span class="o">[</span><span class="n">ordered_add_comm_monoid</span> <span class="n">M</span><span class="o">](</span><span class="n">hfg</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">g</span> <span class="n">x</span><span class="o">)</span>
<span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="o">(</span><span class="n">function.support</span> <span class="n">f</span><span class="o">)</span><span class="bp">.</span><span class="n">finite</span><span class="o">)(</span><span class="n">hg</span> <span class="o">:</span> <span class="o">(</span><span class="n">function.support</span> <span class="n">g</span><span class="o">)</span><span class="bp">.</span><span class="n">finite</span><span class="o">):</span>
  <span class="bp">∑ᶠ</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">f</span> <span class="n">i</span> <span class="bp">≤</span> <span class="bp">∑ᶠ</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">g</span> <span class="n">i</span> <span class="o">:=</span>
<span class="gr">sorry</span>

<span class="kd">lemma</span> <span class="n">finsum_le_finsum'</span> <span class="o">[</span><span class="n">ordered_add_comm_monoid</span> <span class="n">M</span><span class="o">][</span><span class="n">nonempty</span> <span class="o">(</span><span class="n">fintype</span> <span class="n">α</span><span class="o">)]</span>
<span class="o">(</span><span class="n">hfg</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">g</span> <span class="n">x</span><span class="o">):</span>
  <span class="bp">∑ᶠ</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">f</span> <span class="n">i</span> <span class="bp">≤</span> <span class="bp">∑ᶠ</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">g</span> <span class="n">i</span> <span class="o">:=</span>
<span class="gr">sorry</span>
</code></pre></div>
<p>Is doing this for every such lemma a reasonable solution? I can't even think of a good naming convention.</p>



<a name="228988888"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Addressing%20mismatch%20issues/near/228988888" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason KY. <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Addressing.20mismatch.20issues.html#228988888">(Mar 05 2021 at 17:09)</a>:</h4>
<p>I think the idea is you prove the different versions if you are writing APIs (e.g. your example) while if you are simply using <code>finsum</code> you can just stick to one version (or the most general version, i.e. the support is finite.). <span class="user-mention" data-user-id="110049">@Mario Carneiro</span> suggest a naming scheme <a href="https://github.com/leanprover-community/mathlib/pull/6355#discussion_r579925163">here</a></p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
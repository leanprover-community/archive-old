---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/native.2Efloat.20equality.20is.20inconsistent.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/native.2Efloat.20equality.20is.20inconsistent.html">native.float equality is inconsistent</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="220979523"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/native.float%20equality%20is%20inconsistent/near/220979523" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/native.2Efloat.20equality.20is.20inconsistent.html#220979523">(Dec 26 2020 at 21:19)</a>:</h4>
<p>I just noticed that float equality is exposed as an implementation of <code>decidable_eq</code>. This is not correct:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">test_eq</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="n">to_bool</span> <span class="o">(</span><span class="n">x</span> <span class="bp">=</span> <span class="n">x</span><span class="o">)</span>

<span class="kd">theorem</span> <span class="n">test_eq_tt</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">test_eq</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">tt</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">to_bool_iff</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span> <span class="n">rfl</span>

<span class="k">#eval</span> <span class="n">test_eq</span> <span class="n">native.float.qNaN</span> <span class="c1">-- ff</span>
</code></pre></div>



<a name="220979700"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/native.float%20equality%20is%20inconsistent/near/220979700" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/native.2Efloat.20equality.20is.20inconsistent.html#220979700">(Dec 26 2020 at 21:24)</a>:</h4>
<p>We could just implement <code>has_equiv</code> or some other notation instead of <code>=</code> (which means something specific in lean and does not permit funny things like IEEE float equality)</p>



<a name="220979784"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/native.float%20equality%20is%20inconsistent/near/220979784" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/native.2Efloat.20equality.20is.20inconsistent.html#220979784">(Dec 26 2020 at 21:26)</a>:</h4>
<p>Since there is no to_bits function on native.float, it would also be possible to implement a decidable_eq instance that makes any two NaNs equal, i.e. <code>x = y &lt;-&gt; x.eq y \/ (is_nan x /\ is_nan y)</code></p>



<a name="220979794"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/native.float%20equality%20is%20inconsistent/near/220979794" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Huisinga <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/native.2Efloat.20equality.20is.20inconsistent.html#220979794">(Dec 26 2020 at 21:27)</a>:</h4>
<p><a href="https://github.com/leanprover/lean4/commit/705530b62bc23b47c0ba9baa8e199ab376b8fd7b">https://github.com/leanprover/lean4/commit/705530b62bc23b47c0ba9baa8e199ab376b8fd7b</a> <span aria-label="grinning" class="emoji emoji-1f600" role="img" title="grinning">:grinning:</span></p>



<a name="220979905"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/native.float%20equality%20is%20inconsistent/near/220979905" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jacques Carette <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/native.2Efloat.20equality.20is.20inconsistent.html#220979905">(Dec 26 2020 at 21:30)</a>:</h4>
<p>Note that you also run into trouble with +-infinity -- if they both invert to unsigned 0, things get weird again. But +-0 are supposed to be equal (in IEEE's highly non-mathematical notion of equal).</p>



<a name="220979914"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/native.float%20equality%20is%20inconsistent/near/220979914" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/native.2Efloat.20equality.20is.20inconsistent.html#220979914">(Dec 26 2020 at 21:30)</a>:</h4>
<p>ah, that's true, my proposed alternative would have to check for signed zero</p>



<a name="220979920"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/native.float%20equality%20is%20inconsistent/near/220979920" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/native.2Efloat.20equality.20is.20inconsistent.html#220979920">(Dec 26 2020 at 21:31)</a>:</h4>
<p>probably the easiest implementation of a conforming = is just <code>x.to_bits = y.to_bits</code></p>



<a name="220979921"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/native.float%20equality%20is%20inconsistent/near/220979921" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Huisinga <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/native.2Efloat.20equality.20is.20inconsistent.html#220979921">(Dec 26 2020 at 21:31)</a>:</h4>
<p>yup, +0 = -0 but 1/+0 = +inf != -inf = 1/-0</p>



<a name="220980005"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/native.float%20equality%20is%20inconsistent/near/220980005" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/native.2Efloat.20equality.20is.20inconsistent.html#220980005">(Dec 26 2020 at 21:34)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">test_congr</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="n">to_bool</span> <span class="o">(</span><span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">y</span><span class="o">)</span>

<span class="kd">theorem</span> <span class="n">test_congr_tt</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span><span class="o">)</span> <span class="o">:</span> <span class="n">test_congr</span> <span class="n">x</span> <span class="n">y</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">tt</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">to_bool_iff</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="kd">by</span> <span class="n">rw</span> <span class="n">x</span><span class="o">)</span>

<span class="k">#eval</span> <span class="n">test_congr</span> <span class="o">(</span><span class="mi">0</span><span class="o">:</span><span class="n">native.float</span><span class="o">)</span> <span class="o">(</span><span class="bp">-</span><span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="mi">1</span> <span class="bp">/</span> <span class="n">x</span><span class="o">)</span> <span class="c1">-- ff</span>
</code></pre></div>



<a name="220980039"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/native.float%20equality%20is%20inconsistent/near/220980039" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/native.2Efloat.20equality.20is.20inconsistent.html#220980039">(Dec 26 2020 at 21:34)</a>:</h4>
<p>I'm guessing not even a <code>quot</code> can represent the irreflexivity of nan equality?</p>



<a name="220980052"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/native.float%20equality%20is%20inconsistent/near/220980052" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/native.2Efloat.20equality.20is.20inconsistent.html#220980052">(Dec 26 2020 at 21:34)</a>:</h4>
<p>no, that would help with the congr example just given but not irreflexivity</p>



<a name="220980132"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/native.float%20equality%20is%20inconsistent/near/220980132" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/native.2Efloat.20equality.20is.20inconsistent.html#220980132">(Dec 26 2020 at 21:37)</a>:</h4>
<p>But I think any quotient that identifies 0 and -0 and is closed under congr would have to identify +inf and -inf; is it possible to prove this also identifies all finite numbers?</p>



<a name="220980142"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/native.float%20equality%20is%20inconsistent/near/220980142" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/native.2Efloat.20equality.20is.20inconsistent.html#220980142">(Dec 26 2020 at 21:37)</a>:</h4>
<p>oh lol there is <code>-nan</code> too</p>



<a name="220980242"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/native.float%20equality%20is%20inconsistent/near/220980242" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Huisinga <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/native.2Efloat.20equality.20is.20inconsistent.html#220980242">(Dec 26 2020 at 21:40)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113488-general/topic/native.2Efloat.20equality.20is.20inconsistent/near/220980132">said</a>:</p>
<blockquote>
<p>is it possible to prove this also identifies all finite numbers?</p>
</blockquote>
<p>-inf &lt;= x &lt;= +inf?</p>



<a name="220980243"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/native.float%20equality%20is%20inconsistent/near/220980243" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/native.2Efloat.20equality.20is.20inconsistent.html#220980243">(Dec 26 2020 at 21:40)</a>:</h4>
<p>uh oh: <code>tanh inf = 1</code>, <code>tanh -inf = -1</code></p>



<a name="220980251"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/native.float%20equality%20is%20inconsistent/near/220980251" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/native.2Efloat.20equality.20is.20inconsistent.html#220980251">(Dec 26 2020 at 21:41)</a>:</h4>
<p>Are you assuming le_antisymm there <span class="user-mention" data-user-id="221921">@Marc Huisinga</span> ?</p>



<a name="220980253"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/native.float%20equality%20is%20inconsistent/near/220980253" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/native.2Efloat.20equality.20is.20inconsistent.html#220980253">(Dec 26 2020 at 21:41)</a>:</h4>
<p>I'm just assuming that the equality is closed under congruence</p>



<a name="220980305"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/native.float%20equality%20is%20inconsistent/near/220980305" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Huisinga <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/native.2Efloat.20equality.20is.20inconsistent.html#220980305">(Dec 26 2020 at 21:42)</a>:</h4>
<p>i haven't actually looked up how stuff is specified in lean 3, just guessing</p>



<a name="220980314"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/native.float%20equality%20is%20inconsistent/near/220980314" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/native.2Efloat.20equality.20is.20inconsistent.html#220980314">(Dec 26 2020 at 21:43)</a>:</h4>
<p>There is no specification, they are mostly uninterpreted functions</p>



<a name="220980321"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/native.float%20equality%20is%20inconsistent/near/220980321" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/native.2Efloat.20equality.20is.20inconsistent.html#220980321">(Dec 26 2020 at 21:43)</a>:</h4>
<p>which is mostly fine, except that this still assumes they are "functions", i.e. respect equality</p>



<a name="220980367"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/native.float%20equality%20is%20inconsistent/near/220980367" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/native.2Efloat.20equality.20is.20inconsistent.html#220980367">(Dec 26 2020 at 21:44)</a>:</h4>
<p>and so implementing decidable_eq is a strong statement since two things that are equal can't be distinguished by later function application</p>



<a name="220980384"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/native.float%20equality%20is%20inconsistent/near/220980384" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/native.2Efloat.20equality.20is.20inconsistent.html#220980384">(Dec 26 2020 at 21:45)</a>:</h4>
<p>I'm not even sure it's totally safe to assume they are functions in this sense in lean 4 since the compilation works by generating C code and gcc can do funny things like increasing the precision on intermediate computations</p>



<a name="220980391"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/native.float%20equality%20is%20inconsistent/near/220980391" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/native.2Efloat.20equality.20is.20inconsistent.html#220980391">(Dec 26 2020 at 21:46)</a>:</h4>
<p>so determinism goes out the window</p>



<a name="220987221"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/native.float%20equality%20is%20inconsistent/near/220987221" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/native.2Efloat.20equality.20is.20inconsistent.html#220987221">(Dec 27 2020 at 01:22)</a>:</h4>
<p><span class="user-mention" data-user-id="221921">@Marc Huisinga</span> There is no <code>float</code> type in Lean 3. It seems someone added them to the Lean 3 community branch.</p>



<a name="220987762"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/native.float%20equality%20is%20inconsistent/near/220987762" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/native.2Efloat.20equality.20is.20inconsistent.html#220987762">(Dec 27 2020 at 01:39)</a>:</h4>
<p><code>float</code> was added to community Lean 3 by <span class="user-mention" data-user-id="121918">@Edward Ayers</span> in <a href="https://github.com/leanprover-community/lean/issues/2">lean#2</a>.</p>



<a name="221009826"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/native.float%20equality%20is%20inconsistent/near/221009826" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/native.2Efloat.20equality.20is.20inconsistent.html#221009826">(Dec 27 2020 at 14:02)</a>:</h4>
<p>When you say "inconsistent", do you mean you can prove <code>false</code> or just that it is weird behavior in the meta world?  I tried to turn your example into a proof of <code>tt = ff</code>, but even though <code>#eval test_eq native.float.qNaN</code> comes out as<code>ff</code>, I can't find a way to prove <code>test_eq native.float.qNaN = ff</code>.  Does  the fact that <code>float</code> is <code>meta</code> protect the consistency of Lean (3 community version)?</p>



<a name="221010479"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/native.float%20equality%20is%20inconsistent/near/221010479" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/native.2Efloat.20equality.20is.20inconsistent.html#221010479">(Dec 27 2020 at 14:25)</a>:</h4>
<p>This won't even check:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="n">decidable_eq</span> <span class="n">native.float</span> <span class="o">:=</span> <span class="n">native.float.dec_eq</span>
</code></pre></div>
<p>So even though <code>native.float.dec_eq</code> looks like an inconsistent axiom, is not usable in proofs it seems.  (Maybe this is all obvious, but I got confused with the "inconsistent" terminology.)</p>



<a name="221059874"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/native.float%20equality%20is%20inconsistent/near/221059874" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/native.2Efloat.20equality.20is.20inconsistent.html#221059874">(Dec 28 2020 at 13:17)</a>:</h4>
<p>Again this is probably obvious to everyone else, but I convinced myself by "inconsistent" here we just mean that if we prove something about <code>=</code> we should try to make make our <code>meta</code> definitions behave as if they are functions which respect Lean's equality rule, which <code>float</code> currently does not.</p>



<a name="221059900"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/native.float%20equality%20is%20inconsistent/near/221059900" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/native.2Efloat.20equality.20is.20inconsistent.html#221059900">(Dec 28 2020 at 13:17)</a>:</h4>
<p>Other than that there is nothing logically inconsistent since <code>meta</code> definitions don't have to obey Lean theorems about functions and equality.  Here is an example I coded up reproducing the problems with <code>float</code> but just using a meta type I coded in Lean:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">meta</span> <span class="kd">def</span> <span class="n">paradox</span> <span class="o">:</span> <span class="n">unit</span> <span class="bp">-&gt;</span> <span class="n">false</span>
<span class="bp">|</span> <span class="n">u</span> <span class="o">:=</span> <span class="n">paradox</span> <span class="n">u</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">cheat</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="n">p</span> <span class="o">:=</span> <span class="n">false.elim</span> <span class="o">(</span><span class="n">paradox</span> <span class="o">())</span>

<span class="kd">meta</span> <span class="kd">inductive</span> <span class="n">bad_int</span>
<span class="bp">|</span> <span class="n">nan</span> <span class="o">:</span> <span class="n">bad_int</span>
<span class="bp">|</span> <span class="n">pos</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">bad_int</span>  <span class="c1">-- has +0</span>
<span class="bp">|</span> <span class="n">neg</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">bad_int</span>  <span class="c1">-- has -0</span>

<span class="kn">namespace</span> <span class="n">bad_int</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">bad_eq</span> <span class="o">:</span> <span class="n">bad_int</span> <span class="bp">→</span> <span class="n">bad_int</span> <span class="bp">→</span> <span class="n">bool</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">pos</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">neg</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:=</span> <span class="n">tt</span>
<span class="bp">|</span> <span class="n">nan</span> <span class="n">nan</span> <span class="o">:=</span> <span class="n">ff</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">pos</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">pos</span> <span class="n">j</span><span class="o">)</span> <span class="o">:=</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">j</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">neg</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">neg</span> <span class="n">j</span><span class="o">)</span> <span class="o">:=</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">j</span>
<span class="bp">|</span> <span class="n">_</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">ff</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">bad_sign</span> <span class="o">:</span> <span class="n">bad_int</span> <span class="bp">→</span> <span class="n">bad_int</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">pos</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="n">pos</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">neg</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="n">neg</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="n">nan</span> <span class="o">:=</span> <span class="n">nan</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">dec_eq_rel</span> <span class="o">(</span><span class="n">i</span> <span class="n">j</span> <span class="o">:</span> <span class="n">bad_int</span><span class="o">)</span> <span class="o">:</span> <span class="n">decidable</span> <span class="o">(</span><span class="n">i</span> <span class="bp">=</span> <span class="n">j</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">if</span> <span class="n">bad_eq</span> <span class="n">i</span> <span class="n">j</span> <span class="k">then</span>
  <span class="n">decidable.is_true</span> <span class="o">(</span><span class="n">cheat</span> <span class="o">(</span><span class="n">i</span> <span class="bp">=</span> <span class="n">j</span><span class="o">))</span>
<span class="k">else</span>
 <span class="n">decidable.is_false</span> <span class="o">(</span><span class="n">cheat</span> <span class="o">(</span><span class="n">i</span> <span class="bp">≠</span> <span class="n">j</span><span class="o">))</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">dec_eq</span> <span class="o">:</span> <span class="n">decidable_eq</span> <span class="n">bad_int</span> <span class="o">:=</span> <span class="n">dec_eq_rel</span>
<span class="kn">attribute</span> <span class="o">[</span><span class="kd">instance</span><span class="o">]</span> <span class="n">dec_eq</span>

<span class="kd">def</span> <span class="n">test_eq</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="n">to_bool</span> <span class="o">(</span><span class="n">x</span> <span class="bp">=</span> <span class="n">x</span><span class="o">)</span>

<span class="kd">theorem</span> <span class="n">test_eq_tt</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">test_eq</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">tt</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">to_bool_iff</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span> <span class="n">rfl</span>

<span class="k">#eval</span> <span class="n">test_eq</span> <span class="n">nan</span> <span class="c1">-- ff</span>


<span class="kd">def</span> <span class="n">test_congr</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="n">to_bool</span> <span class="o">(</span><span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">y</span><span class="o">)</span>

<span class="kd">theorem</span> <span class="n">test_congr_tt</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span><span class="o">)</span> <span class="o">:</span> <span class="n">test_congr</span> <span class="n">x</span> <span class="n">y</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">tt</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">to_bool_iff</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="kd">by</span> <span class="n">rw</span> <span class="n">x</span><span class="o">)</span>

<span class="k">#eval</span> <span class="n">test_congr</span> <span class="o">(</span><span class="n">pos</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">neg</span> <span class="mi">0</span><span class="o">)</span> <span class="n">bad_sign</span> <span class="c1">-- ff</span>

<span class="kd">end</span> <span class="n">bad_int</span>
</code></pre></div>



<a name="221074936"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/native.float%20equality%20is%20inconsistent/near/221074936" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/native.2Efloat.20equality.20is.20inconsistent.html#221074936">(Dec 28 2020 at 17:08)</a>:</h4>
<p>Yes, you can argue in this way. However, keep in mind that bad meta definitions also compromise the correctness of lean's compiler, which matters even for meta code because this is what gives them meaning. That is, to the extent that <code>meta</code> code is like code you would find in C or Haskell, this kind of thing can cause miscompilation because lean makes some assumptions about pure code being pure</p>



<a name="221075223"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/native.float%20equality%20is%20inconsistent/near/221075223" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/native.2Efloat.20equality.20is.20inconsistent.html#221075223">(Dec 28 2020 at 17:12)</a>:</h4>
<p>We're doing a similar thing right now to cover up another inconsistency in <code>level</code> I found a long time ago:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">open</span> <span class="n">level</span>
<span class="kd">meta</span> <span class="kd">example</span> <span class="o">:</span> <span class="n">max</span> <span class="n">zero</span> <span class="n">zero</span> <span class="bp">≠</span> <span class="n">zero</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">level.no_confusion</span> <span class="n">h</span>
<span class="k">#eval</span> <span class="n">to_bool</span> <span class="o">(</span><span class="n">max</span> <span class="n">zero</span> <span class="n">zero</span> <span class="bp">=</span> <span class="n">zero</span><span class="o">)</span> <span class="c1">-- tt</span>
</code></pre></div>



<a name="221075685"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/native.float%20equality%20is%20inconsistent/near/221075685" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/native.2Efloat.20equality.20is.20inconsistent.html#221075685">(Dec 28 2020 at 17:18)</a>:</h4>
<p>If it's not a proof of false, it's not an inconsistency, surely</p>



<a name="221075809"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/native.float%20equality%20is%20inconsistent/near/221075809" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/native.2Efloat.20equality.20is.20inconsistent.html#221075809">(Dec 28 2020 at 17:20)</a>:</h4>
<p>It's still a problem if it means your unsafe code is even less safe than you expected.</p>



<a name="221080265"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/native.float%20equality%20is%20inconsistent/near/221080265" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/native.2Efloat.20equality.20is.20inconsistent.html#221080265">(Dec 28 2020 at 18:19)</a>:</h4>
<p>I will note that a proof of false was in fact used in Jason's example</p>



<a name="221080417"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/native.float%20equality%20is%20inconsistent/near/221080417" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/native.2Efloat.20equality.20is.20inconsistent.html#221080417">(Dec 28 2020 at 18:21)</a>:</h4>
<p><code>meta</code> code allows you to bypass restrictions, it's not "safe". But that doesn't mean we shouldn't make every effort to not be wrong</p>



<a name="221080572"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/native.float%20equality%20is%20inconsistent/near/221080572" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/native.2Efloat.20equality.20is.20inconsistent.html#221080572">(Dec 28 2020 at 18:23)</a>:</h4>
<p>i think the right thing to do for floating point equality is to check <code>x.to_bits = y.to_bits</code> and if you need the abomination that is ieee equality to call it <code>ieee_eq</code> or something</p>



<a name="221080625"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/native.float%20equality%20is%20inconsistent/near/221080625" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/native.2Efloat.20equality.20is.20inconsistent.html#221080625">(Dec 28 2020 at 18:24)</a>:</h4>
<p>in general you rarely want to be checking ieee equality for floating point numbers anyway, only if you're doing something like verifying that a serialization-&gt;deserialization worked where you'd want bitwise equality</p>



<a name="221080648"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/native.float%20equality%20is%20inconsistent/near/221080648" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/native.2Efloat.20equality.20is.20inconsistent.html#221080648">(Dec 28 2020 at 18:25)</a>:</h4>
<p>This will be even more important in Lean 4 where we'll have more power to create custom commands. For instance it should be pretty easy to create a <code>major_theorem</code> command which acts like <code>theorem</code> excepts it replaces whatever statement you type with <code>0 = 0</code> before asking for a proof. Of course the Lean kernel will see a statement and proof of <code>0 = 0</code> but a human reading the Lean file will see any statement you want.</p>



<a name="221081182"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/native.float%20equality%20is%20inconsistent/near/221081182" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/native.2Efloat.20equality.20is.20inconsistent.html#221081182">(Dec 28 2020 at 18:33)</a>:</h4>
<p><span class="user-mention silent" data-user-id="238605">Kevin Lacker</span> <a href="#narrow/stream/113488-general/topic/native.2Efloat.20equality.20is.20inconsistent/near/221080572">said</a>:</p>
<blockquote>
<p>i think the right thing to do for floating point equality is to check <code>x.to_bits = y.to_bits</code> and if you need the abomination that is ieee equality to call it <code>ieee_eq</code> or something</p>
</blockquote>
<p>I agree with this. Using <code>=</code> or <code>==</code> is a bad habit inherited from other programming languages that don't have such a strong stance on formal correctness. Rust uses <code>PartialEq</code> instead of <code>Eq</code> essentially only because floats exist, but I would much rather compromise on notational convenience of float ops because it's important to recognize the float weirdness happening in each operation.</p>



<a name="221081335"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/native.float%20equality%20is%20inconsistent/near/221081335" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/native.2Efloat.20equality.20is.20inconsistent.html#221081335">(Dec 28 2020 at 18:34)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110031">Patrick Massot</span> <a href="#narrow/stream/113488-general/topic/native.2Efloat.20equality.20is.20inconsistent/near/221080648">said</a>:</p>
<blockquote>
<p>This will be even more important in Lean 4 where we'll have more power to create custom commands. For instance it should be pretty easy to create a <code>major_theorem</code> command which acts like <code>theorem</code> excepts it replaces whatever statement you type with <code>0 = 0</code> before asking for a proof. Of course the Lean kernel will see a statement and proof of <code>0 = 0</code> but a human reading the Lean file will see any statement you want.</p>
</blockquote>
<p>I think it's possible to override <code>theorem</code> to do that, actually</p>



<a name="221081362"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/native.float%20equality%20is%20inconsistent/near/221081362" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/native.2Efloat.20equality.20is.20inconsistent.html#221081362">(Dec 28 2020 at 18:35)</a>:</h4>
<p>wait, and you are telling us now...</p>



<a name="221081365"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/native.float%20equality%20is%20inconsistent/near/221081365" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/native.2Efloat.20equality.20is.20inconsistent.html#221081365">(Dec 28 2020 at 18:35)</a>:</h4>
<p>It may be possible in Lean 3 already, but I wanted to point out it will probably be <em>easy</em> in Lean 4.</p>



<a name="221081389"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/native.float%20equality%20is%20inconsistent/near/221081389" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/native.2Efloat.20equality.20is.20inconsistent.html#221081389">(Dec 28 2020 at 18:35)</a>:</h4>
<p>all these months we've been sweating to prove our theorems... and we were just one override and a <code>rfl</code> away from proving them</p>



<a name="221081456"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/native.float%20equality%20is%20inconsistent/near/221081456" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/native.2Efloat.20equality.20is.20inconsistent.html#221081456">(Dec 28 2020 at 18:36)</a>:</h4>
<p>Yes, this is a major concern of mine regarding the tremendous syntax flexibility of lean 4. You basically can't trust anything you see</p>



<a name="221081463"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/native.float%20equality%20is%20inconsistent/near/221081463" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/native.2Efloat.20equality.20is.20inconsistent.html#221081463">(Dec 28 2020 at 18:36)</a>:</h4>
<div class="message_inline_image"><a href="https://jrlburke.files.wordpress.com/2015/10/could-should.jpg"><img src="https://jrlburke.files.wordpress.com/2015/10/could-should.jpg"></a></div>



<a name="221081573"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/native.float%20equality%20is%20inconsistent/near/221081573" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/native.2Efloat.20equality.20is.20inconsistent.html#221081573">(Dec 28 2020 at 18:38)</a>:</h4>
<p>"trusted syntax is an editor feature" -- anonymous</p>



<a name="221085430"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/native.float%20equality%20is%20inconsistent/near/221085430" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/native.2Efloat.20equality.20is.20inconsistent.html#221085430">(Dec 28 2020 at 19:30)</a>:</h4>
<p>I think it is important to clarify a few points and avoid misinformation being spread.</p>
<p>1- Most users assume "inconsistent" means "being able to prove false". This is <strong>not</strong> the case here.</p>
<p>2- The bug is in the native implementation (in C++) of float equality. The bug is in the Lean 3 community branch only.</p>
<p>3- The bug only affects people using the Lean 3 community branch as a programming language. <br>
One may claim it also affects users writing tactics. As far as I know, nobody uses float for writing tactics.<br>
However, even if someone wrote a tactic using them, it would be just another buggy tactic. Incorrect proofs produced by buggy tactics are caught by the kernel.</p>
<p>4- A less alarmist way to describe the bug is: "The native implementation of float equality is incorrect. It doesn't correctly implement the type it claims to implement. This bug affects people using the Lean 3 community branch, float, and Lean as a programming language". </p>
<p>5- No "proof of false" has ever been reported to a Lean developer. If a "proof of false" is one day found, we would tag it as a high priority and would fix it.</p>
<p>6- In Lean, users can inspect, and export objects constructed using the system. This allows users to scrutinize any result proved using Lean. In Lean 4, users have access to not only the Kernel terms but all built-in data structures representing parsers, elaborators, instances, classes, etc. </p>
<p>7- One doesn't need "tremendous syntax flexibility" to tricky naive users to believe they proved something they didn't. Example:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">notation</span> <span class="bp">`</span><span class="n">false</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">true</span>

<span class="kd">theorem</span> <span class="n">unsound</span> <span class="o">:</span> <span class="n">false</span> <span class="o">:=</span>
  <span class="n">trivial</span>
</code></pre></div>
<p>One can easily obfuscate the example above and make the exploit less obvious. However, the previous point remains, we provide tools for users to scrutinize and export their results.</p>
<p>8- Users can write their own independent type checkers and visualizers for Lean developments. A few independent type checkers have already been implemented. I know that 2 of them are efficient enough for checking real/big Lean developments.</p>
<p>To be honest, some of the comments on this thread read like FUD <a href="https://en.wikipedia.org/wiki/Fear,_uncertainty,_and_doubt">https://en.wikipedia.org/wiki/Fear,_uncertainty,_and_doubt</a></p>



<a name="221085836"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/native.float%20equality%20is%20inconsistent/near/221085836" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/native.2Efloat.20equality.20is.20inconsistent.html#221085836">(Dec 28 2020 at 19:36)</a>:</h4>
<p>I'm not laying any blame at lean 4 here. My original post was about lean 3 community edition. Some of the follow on comments apply to lean 4, but this particular issue has already been fixed</p>



<a name="221085997"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/native.float%20equality%20is%20inconsistent/near/221085997" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/native.2Efloat.20equality.20is.20inconsistent.html#221085997">(Dec 28 2020 at 19:39)</a>:</h4>
<p>Re: 7, I agree that it's easy to write things that don't mean what they say in lean 3 (and even easier in lean 4). This doesn't make me any less concerned. Ideally we would have something like the export format with trusted syntax, but where you can actually read it. This does not currently exist.</p>



<a name="221086188"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/native.float%20equality%20is%20inconsistent/near/221086188" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/native.2Efloat.20equality.20is.20inconsistent.html#221086188">(Dec 28 2020 at 19:43)</a>:</h4>
<p>Re: 1, I don't have a good term for this. Is "miscompilation" better? "Inconsistent with reality"? The code doesn't do what it says. Regarding "can't prove false", of course in meta code you very much can, but that's obviously not what people are talking about. <code>native.float</code> is a meta feature, it lacks whatever sense of correctness you can meaningfully apply to meta things.</p>



<a name="221086701"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/native.float%20equality%20is%20inconsistent/near/221086701" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/native.2Efloat.20equality.20is.20inconsistent.html#221086701">(Dec 28 2020 at 19:51)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113488-general/topic/native.2Efloat.20equality.20is.20inconsistent/near/221081456">said</a>:</p>
<blockquote>
<p>Yes, this is a major concern of mine regarding the tremendous syntax flexibility of lean 4. You basically can't trust anything you see</p>
</blockquote>
<p>I admit this is hyperbolic. Of course in practice this isn't likely to be a major issue. But from a formal perspective, I really don't know if I can tighten this claim up very much; you more or less have to read the entirety of the lean code and parser infrastructure before you can make any sure claims about the lack of tricky parser mechanisms in use. Maybe we need a "Lean Zero" for verified syntax? :)</p>



<a name="221087056"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/native.float%20equality%20is%20inconsistent/near/221087056" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/native.2Efloat.20equality.20is.20inconsistent.html#221087056">(Dec 28 2020 at 19:57)</a>:</h4>
<p>Leo, I don't know how much of your message is directed towards my two messages in this thread, but I'd like to clarify that I'm not worried at all, and I'm super excited to get access to Lean 4 flexibility in the future. My message was a comment on Mario's "meta code allows you to bypass restrictions, it's not "safe". But that doesn't mean we shouldn't make every effort to not be wrong". As you point out yourself, there are ways to write deceiving Lean code, but this wasn't meant as a critique, only reinforcing the claim that we should make every effort to write good meta code.</p>



<a name="221087544"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/native.float%20equality%20is%20inconsistent/near/221087544" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/native.2Efloat.20equality.20is.20inconsistent.html#221087544">(Dec 28 2020 at 20:04)</a>:</h4>
<p><span class="user-mention silent" data-user-id="115715">Jason Rute</span> <a href="#narrow/stream/113488-general/topic/native.2Efloat.20equality.20is.20inconsistent/near/221009826">said</a>:</p>
<blockquote>
<p>When you say "inconsistent", do you mean you can prove <code>false</code> or just that it is weird behavior in the meta world?  I tried to turn your example into a proof of <code>tt = ff</code>, but even though <code>#eval test_eq native.float.qNaN</code> comes out as<code>ff</code>, I can't find a way to prove <code>test_eq native.float.qNaN = ff</code>.  Does  the fact that <code>float</code> is <code>meta</code> protect the consistency of Lean (3 community version)?</p>
</blockquote>
<p>Leo already said this, but just to be clear: This is just weird behavior in <code>meta</code> world. The kernel doesn't see any declarations marked <code>meta</code>, so logical soundness of the lean kernel is not compromised.</p>



<a name="221087872"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/native.float%20equality%20is%20inconsistent/near/221087872" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/native.2Efloat.20equality.20is.20inconsistent.html#221087872">(Dec 28 2020 at 20:09)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span>  This is not the first message I see from you that has a very "alarmist tone". <br>
The main point is the bug does not affect the soundness of results proved using Lean. <br>
The key issue here for me is: Should we trust results proved using Lean?</p>
<blockquote>
<p>Regarding "can't prove false", of course in meta code you very much can, but that's obviously not what people are talking about. </p>
</blockquote>
<p>I disagree. It was not obvious to Jason Rute. He wrote</p>
<blockquote>
<p>When you say "inconsistent", do you mean you can prove false or just that it is weird behavior in the meta world?</p>
</blockquote>
<p>He is clearly concerned about the soundness of the system.</p>
<blockquote>
<p>Re: 1, I don't have a good term for this. Is "miscompilation" better? </p>
</blockquote>
<p>You could have simply said: "this bug does not affect the soundness of results proved using Lean"<br>
You could have just answered "no, you cannot prove false" to Jason. He was clearly asking whether the bug affects the soundness of the system or not.</p>
<blockquote>
<p>Ideally we would have something like the export format with trusted syntax, but where you can actually read it. This does not currently exist.</p>
</blockquote>
<p>We don't need an export format in Lean 4 anymore. Users can traverse all data structures and export whatever they want using the format they want.<br>
As far as I know, Gabriel's external type checker can pretty-print the results it checked.</p>
<blockquote>
<p>Maybe we need a "Lean Zero" for verified syntax? <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span></p>
</blockquote>
<p>If you are concerned so much about this problem, you should do it.<br>
I am not. There are many more important problems that need to be addressed. <br>
I acknowledge that Lean has many problems, but soundness is not one of them. As I said, no "proof of false" has ever been reported to me.<br>
I am clearly referring to "non-meta" here.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/congr.20with.20associativity.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20with.20associativity.html">congr with associativity</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="303302666"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/congr%20with%20associativity/near/303302666" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20with.20associativity.html#303302666">(Oct 10 2022 at 17:47)</a>:</h4>
<p>I'd like to have a tactic like <code>congr</code> but with associativity. Let's say <code>∘</code> is an associative operation (not commutative).</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">⊢</span>  <span class="n">a</span> <span class="bp">∘</span> <span class="o">(</span><span class="n">b</span> <span class="bp">∘</span> <span class="o">(</span><span class="n">c</span> <span class="bp">∘</span> <span class="n">d</span><span class="o">))</span> <span class="bp">=</span> <span class="o">(</span><span class="n">a</span> <span class="bp">∘</span> <span class="n">x</span><span class="o">)</span> <span class="bp">∘</span> <span class="o">(</span><span class="n">y</span> <span class="bp">∘</span> <span class="n">d</span><span class="o">)</span>
</code></pre></div>
<p>I'd like to call the tactic, then <code>b ∘ c = x ∘ y</code> would be the new goal.</p>



<a name="303303590"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/congr%20with%20associativity/near/303303590" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20with.20associativity.html#303303590">(Oct 10 2022 at 17:54)</a>:</h4>
<p>Maybe <span class="user-mention" data-user-id="321459">@Damiano Testa</span>'s tactic <code>move_add</code> <a href="https://github.com/leanprover-community/mathlib/pull/13483">#13483</a> would be relevant for this kind of task?</p>



<a name="303303937"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/congr%20with%20associativity/near/303303937" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20with.20associativity.html#303303937">(Oct 10 2022 at 17:57)</a>:</h4>
<p>[I specified the question.]</p>



<a name="303304881"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/congr%20with%20associativity/near/303304881" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20with.20associativity.html#303304881">(Oct 10 2022 at 18:05)</a>:</h4>
<p>I wish <a href="https://leanprover-community.github.io/mathlib_docs/tactics.html#slice">tactic#slice</a> could be extended to associative operations instead of only working in category theory ... in fact it's a TODO in comments <a href="https://tqft.net/mathlib/tactic/slice">file#tactic/slice</a></p>



<a name="303306336"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/congr%20with%20associativity/near/303306336" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20with.20associativity.html#303306336">(Oct 10 2022 at 18:15)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/tactics.html#assoc_rw">tactic#assoc_rw</a> isn't what you want but is useful</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.group.basic</span>
<span class="bp">.</span>
<span class="kd">lemma</span> <span class="n">m</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">a</span> <span class="bp">*</span> <span class="o">(</span><span class="n">b</span> <span class="bp">*</span> <span class="o">(</span><span class="n">c</span> <span class="bp">*</span> <span class="n">d</span><span class="o">))</span> <span class="bp">=</span> <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="n">x</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">y</span> <span class="bp">*</span> <span class="n">d</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">assoc_rw</span> <span class="o">(</span><span class="k">show</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">,</span> <span class="k">from</span> <span class="n">_</span><span class="o">),</span>
  <span class="n">assoc_rw</span> <span class="o">(</span><span class="k">show</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">y</span> <span class="bp">*</span> <span class="n">d</span> <span class="bp">=</span> <span class="n">_</span><span class="o">,</span> <span class="k">from</span> <span class="n">rfl</span><span class="o">),</span>
  <span class="gr">sorry</span>
<span class="kd">end</span>
</code></pre></div>
<p>also <a href="https://leanprover-community.github.io/mathlib_docs/tactics.html#ac_refl">tactic#ac_refl</a>, <a href="https://leanprover-community.github.io/mathlib_docs/tactics.html#ac_change">tactic#ac_change</a></p>



<a name="303374802"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/congr%20with%20associativity/near/303374802" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20with.20associativity.html#303374802">(Oct 11 2022 at 07:43)</a>:</h4>
<p>Since my project contains 155 explicit invocations of <code>list.append_assoc</code> I think I should automate it. The above-mentioned tactic does not exist. What will you recommend me to start with if I want to write it myself? I don't have experience with metaprogramming.</p>



<a name="303384396"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/congr%20with%20associativity/near/303384396" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20with.20associativity.html#303384396">(Oct 11 2022 at 08:50)</a>:</h4>
<p>Which tactic doesn't exist?</p>



<a name="303389174"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/congr%20with%20associativity/near/303389174" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20with.20associativity.html#303389174">(Oct 11 2022 at 09:23)</a>:</h4>
<p><span class="user-mention silent" data-user-id="417654">Martin Dvořák</span> <a href="#narrow/stream/113488-general/topic/congr.20with.20associativity/near/303302666">said</a>:</p>
<blockquote>
<p>I'd like to have a tactic like <code>congr</code> but with associativity. Let's say <code>∘</code> is an associative operation (not commutative).</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">⊢</span>  <span class="n">a</span> <span class="bp">∘</span> <span class="o">(</span><span class="n">b</span> <span class="bp">∘</span> <span class="o">(</span><span class="n">c</span> <span class="bp">∘</span> <span class="n">d</span><span class="o">))</span> <span class="bp">=</span> <span class="o">(</span><span class="n">a</span> <span class="bp">∘</span> <span class="n">x</span><span class="o">)</span> <span class="bp">∘</span> <span class="o">(</span><span class="n">y</span> <span class="bp">∘</span> <span class="n">d</span><span class="o">)</span>
</code></pre></div>
<p>I'd like to call the tactic, then <code>b ∘ c = x ∘ y</code> would be the new goal.</p>
</blockquote>
<p>this</p>



<a name="303389451"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/congr%20with%20associativity/near/303389451" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20with.20associativity.html#303389451">(Oct 11 2022 at 09:25)</a>:</h4>
<p>[my workaround idea didn't work either]</p>



<a name="303392754"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/congr%20with%20associativity/near/303392754" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20with.20associativity.html#303392754">(Oct 11 2022 at 09:48)</a>:</h4>
<p>A primitive implementation might just be:</p>
<ul>
<li>use the simplifier to left associate</li>
<li>run <code>congr</code></li>
<li>use the simplifier to right associate</li>
<li>run <code>congr</code><br>
You should think pretty carefully about the specification of your tactic first before implementing it. (Mostly because for simple tactics the implementation follows directly from the spec.)</li>
</ul>



<a name="303396631"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/congr%20with%20associativity/near/303396631" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20with.20associativity.html#303396631">(Oct 11 2022 at 10:16)</a>:</h4>
<p>Not exactly <code>congr</code> — it would attempt to match even the non-matching parts (before trying the other direction that might actually help to simplify the goal).</p>
<p>Nevertheless, you are right that I should first carefully specify what I want from my tactic.</p>



<a name="303491289"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/congr%20with%20associativity/near/303491289" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20with.20associativity.html#303491289">(Oct 11 2022 at 18:01)</a>:</h4>
<p>What should it do on <code>(a * b) * c = (a * c) * (b * d)</code>?</p>



<a name="303491537"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/congr%20with%20associativity/near/303491537" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20with.20associativity.html#303491537">(Oct 11 2022 at 18:02)</a>:</h4>
<p>This feels pretty underspecified to me</p>



<a name="303538534"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/congr%20with%20associativity/near/303538534" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20with.20associativity.html#303538534">(Oct 11 2022 at 23:52)</a>:</h4>
<p>Surely <code>b * c = c * b * d</code>? It's only assuming associativity, no commutatively, right?</p>



<a name="303551902"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/congr%20with%20associativity/near/303551902" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20with.20associativity.html#303551902">(Oct 12 2022 at 02:57)</a>:</h4>
<p>Why wouldn't it produce two goals, <code>b = c * b</code> and <code>c = d</code>?</p>



<a name="303552106"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/congr%20with%20associativity/near/303552106" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20with.20associativity.html#303552106">(Oct 12 2022 at 03:00)</a>:</h4>
<p>Oh, I see. I was imagining only "splitting" on <code>*</code> if at least one side matches. I doubt "find minimal runs of non-matching elements" has a unique answer.</p>



<a name="303565547"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/congr%20with%20associativity/near/303565547" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20with.20associativity.html#303565547">(Oct 12 2022 at 06:20)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110087">Scott Morrison</span> <a href="#narrow/stream/113488-general/topic/congr.20with.20associativity/near/303392754">said</a>:</p>
<blockquote>
<p>A primitive implementation might just be:</p>
<ul>
<li>use the simplifier to left associate</li>
<li>run <code>congr</code></li>
<li>use the simplifier to right associate</li>
<li>run <code>congr</code><br>
You should think pretty carefully about the specification of your tactic first before implementing it. (Mostly because for simple tactics the implementation follows directly from the spec.)</li>
</ul>
</blockquote>
<p>Let's say I only want to do the longest matching prefix and the longest matching suffix. Would there a similarly easy solution?</p>



<a name="303628420"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/congr%20with%20associativity/near/303628420" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20with.20associativity.html#303628420">(Oct 12 2022 at 13:32)</a>:</h4>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span>, that sounds like a clearer spec, but I don't think your suggested implementation implements it.</p>



<a name="303724231"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/congr%20with%20associativity/near/303724231" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20with.20associativity.html#303724231">(Oct 12 2022 at 21:25)</a>:</h4>
<p>No, I agree. You'd replace <code>congr</code> with repeated application of lemmas like<br>
<code>b = c -&gt; a * b = a * c</code>.</p>



<a name="303777525"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/congr%20with%20associativity/near/303777525" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20with.20associativity.html#303777525">(Oct 13 2022 at 08:08)</a>:</h4>
<p>What about <code>a * b * x * b * a = a * b * a</code>? Do you match the prefix or the suffix? I feel like most of this ambiguity is avoided by just having the user use <code>ac_change</code> in the first place to put things in whatever state they actually desire before using <code>congr</code>...</p>



<a name="303793278"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/congr%20with%20associativity/near/303793278" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20with.20associativity.html#303793278">(Oct 13 2022 at 09:57)</a>:</h4>
<p>How is <code>ac_change</code> that doesn't use commutativity?</p>



<a name="303809330"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/congr%20with%20associativity/near/303809330" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20with.20associativity.html#303809330">(Oct 13 2022 at 11:42)</a>:</h4>
<p>I think ac_change only uses commutativity if it's available</p>



<a name="303809348"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/congr%20with%20associativity/near/303809348" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20with.20associativity.html#303809348">(Oct 13 2022 at 11:42)</a>:</h4>
<p>But I could be wrong</p>



<a name="303815962"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/congr%20with%20associativity/near/303815962" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20with.20associativity.html#303815962">(Oct 13 2022 at 12:22)</a>:</h4>
<p>Here, the operation <code>++</code> is only associative. It doesn't do what it is supposed to do.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">list</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">++</span> <span class="o">(</span><span class="n">b</span> <span class="bp">++</span> <span class="o">(</span><span class="n">c</span> <span class="bp">++</span> <span class="n">d</span><span class="o">))</span> <span class="bp">=</span> <span class="o">(</span><span class="n">a</span> <span class="bp">++</span> <span class="n">x</span><span class="o">)</span> <span class="bp">++</span> <span class="o">(</span><span class="n">y</span> <span class="bp">++</span> <span class="n">d</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">ac_change</span> <span class="n">a</span> <span class="bp">++</span> <span class="o">(</span><span class="n">b</span> <span class="bp">++</span> <span class="n">c</span><span class="o">)</span> <span class="bp">++</span> <span class="n">d</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">++</span> <span class="o">(</span><span class="n">x</span> <span class="bp">++</span> <span class="n">y</span><span class="o">)</span> <span class="bp">++</span> <span class="n">d</span><span class="bp">;</span>
  <span class="gr">sorry</span>
<span class="kd">end</span>
</code></pre></div>



<a name="303829194"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/congr%20with%20associativity/near/303829194" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20with.20associativity.html#303829194">(Oct 13 2022 at 13:09)</a>:</h4>
<p>This works:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">+</span> <span class="o">(</span><span class="n">b</span> <span class="bp">+</span> <span class="o">(</span><span class="n">c</span> <span class="bp">+</span> <span class="n">d</span><span class="o">))</span> <span class="bp">=</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span> <span class="bp">+</span> <span class="o">(</span><span class="n">c</span> <span class="bp">+</span> <span class="n">d</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">ac_refl</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>This doesn't work:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span> <span class="o">:</span> <span class="n">list</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">++</span> <span class="o">(</span><span class="n">b</span> <span class="bp">++</span> <span class="o">(</span><span class="n">c</span> <span class="bp">++</span> <span class="n">d</span><span class="o">))</span> <span class="bp">=</span> <span class="o">(</span><span class="n">a</span> <span class="bp">++</span> <span class="n">b</span><span class="o">)</span> <span class="bp">++</span> <span class="o">(</span><span class="n">c</span> <span class="bp">++</span> <span class="n">d</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">ac_refl</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="303829563"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/congr%20with%20associativity/near/303829563" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20with.20associativity.html#303829563">(Oct 13 2022 at 13:12)</a>:</h4>
<p>Is there a tactic like <code>ac_refl</code> but for operations that are associative and not commutative?</p>



<a name="303848724"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/congr%20with%20associativity/near/303848724" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20with.20associativity.html#303848724">(Oct 13 2022 at 14:22)</a>:</h4>
<p>I'm not sure if one exists already but here is one:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="bp">.</span>
<span class="kn">open</span> <span class="n">tactic</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">tactic.interactive.assoc_refl</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="k">do</span> <span class="o">(</span><span class="n">lhs</span><span class="o">,</span> <span class="n">rhs</span><span class="o">)</span> <span class="bp">←</span> <span class="n">target</span> <span class="bp">&gt;&gt;=</span> <span class="n">match_eq</span><span class="o">,</span>
   <span class="n">assoc_refl</span> <span class="n">lhs.app_fn.app_fn</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span> <span class="o">:</span> <span class="n">list</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">++</span> <span class="o">(</span><span class="n">b</span> <span class="bp">++</span> <span class="n">c</span><span class="o">)</span> <span class="bp">++</span> <span class="n">d</span> <span class="bp">=</span> <span class="o">(</span><span class="n">a</span> <span class="bp">++</span> <span class="n">b</span><span class="o">)</span> <span class="bp">++</span> <span class="o">(</span><span class="n">c</span> <span class="bp">++</span> <span class="n">d</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">assoc_refl</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="303849836"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/congr%20with%20associativity/near/303849836" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20with.20associativity.html#303849836">(Oct 13 2022 at 14:26)</a>:</h4>
<p>Why not simply using <code>simp only [list.append_assoc]</code>?</p>



<a name="303850712"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/congr%20with%20associativity/near/303850712" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20with.20associativity.html#303850712">(Oct 13 2022 at 14:30)</a>:</h4>
<p>It may look like cheating but the example of <a href="https://leanprover-community.github.io/mathlib_docs/tactics.html#group">tactic#group</a> shows this idea can already go quite a long way.</p>



<a name="303850923"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/congr%20with%20associativity/near/303850923" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20with.20associativity.html#303850923">(Oct 13 2022 at 14:31)</a>:</h4>
<p>I think thats also a reasonable solution in this case, but to answer the question: some ways in which a specialized tactic can be better are if you want flexibility of the operation without needing to know the name of the appropriate lemma, and that the proofs produced are way shorter and more reasonable looking. But for most applications using simp is probably way more convenient.</p>



<a name="303933322"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/congr%20with%20associativity/near/303933322" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20with.20associativity.html#303933322">(Oct 13 2022 at 22:19)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110031">Patrick Massot</span> <a href="#narrow/stream/113488-general/topic/congr.20with.20associativity/near/303849836">said</a>:</p>
<blockquote>
<p>Why not simply using <code>simp only [list.append_assoc]</code>?</p>
</blockquote>
<p>I conclude that, in a similar manner how <code>ac_change</code> does <code>convert_to r n; try ac_refl</code>, I should implement <code>la_change</code> as <code>convert_to r n; try simp only [list.append_assoc]</code> ok?<br>
It will not fully automate what I wanted to do (as with <code>la_change</code> I have to create the new form of the goal in my head and write it down), but it will get me to a form which <code>congr</code> can then simplify really usefully.<br>
Any other suggestion?</p>



<a name="304401036"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/congr%20with%20associativity/near/304401036" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20with.20associativity.html#304401036">(Oct 17 2022 at 07:57)</a>:</h4>
<p>What does <code>(n : parse (tk "using" *&gt; small_nat)?)</code> mean?<br>
<a href="https://github.com/leanprover-community/mathlib/blob/0c171f291c5e590f368974dc3a293c7b50de44a4/src/tactic/congr.lean#L228">https://github.com/leanprover-community/mathlib/blob/0c171f291c5e590f368974dc3a293c7b50de44a4/src/tactic/congr.lean#L228</a></p>



<a name="304401907"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/congr%20with%20associativity/near/304401907" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20with.20associativity.html#304401907">(Oct 17 2022 at 08:03)</a>:</h4>
<p>That a tactic takes an optional argument <code>using n</code> and <code>n</code> will be parsed as a natural number.</p>



<a name="304407332"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/congr%20with%20associativity/near/304407332" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20with.20associativity.html#304407332">(Oct 17 2022 at 08:38)</a>:</h4>
<p>I am confused. Example</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">list</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">++</span> <span class="o">(</span><span class="n">b</span> <span class="bp">++</span> <span class="o">(</span><span class="n">c</span> <span class="bp">++</span> <span class="n">d</span><span class="o">))</span> <span class="bp">=</span> <span class="o">(</span><span class="n">a</span> <span class="bp">++</span> <span class="n">x</span><span class="o">)</span> <span class="bp">++</span> <span class="o">(</span><span class="n">y</span> <span class="bp">++</span> <span class="n">d</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">convert_to</span> <span class="n">a</span> <span class="bp">++</span> <span class="o">(</span><span class="n">b</span> <span class="bp">++</span> <span class="n">c</span><span class="o">)</span> <span class="bp">++</span> <span class="n">d</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">++</span> <span class="o">(</span><span class="n">x</span> <span class="bp">++</span> <span class="n">y</span><span class="o">)</span> <span class="bp">++</span> <span class="n">d</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">list.append_assoc</span><span class="o">]</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">list.append_assoc</span><span class="o">]</span> <span class="o">},</span>
  <span class="c1">-- I am talking about the goal remaining here.</span>
  <span class="gr">sorry</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>leads to the goal <code>a ++ (b ++ c) ++ d = a ++ (x ++ y) ++ d</code> as I intended. However</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">list</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">++</span> <span class="o">(</span><span class="n">b</span> <span class="bp">++</span> <span class="o">(</span><span class="n">c</span> <span class="bp">++</span> <span class="n">d</span><span class="o">))</span> <span class="bp">=</span> <span class="o">(</span><span class="n">a</span> <span class="bp">++</span> <span class="n">x</span><span class="o">)</span> <span class="bp">++</span> <span class="o">(</span><span class="n">y</span> <span class="bp">++</span> <span class="n">d</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">convert_to</span> <span class="n">a</span> <span class="bp">++</span> <span class="o">(</span><span class="n">b</span> <span class="bp">++</span> <span class="n">c</span><span class="o">)</span> <span class="bp">++</span> <span class="n">d</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">++</span> <span class="o">(</span><span class="n">x</span> <span class="bp">++</span> <span class="n">y</span><span class="o">)</span> <span class="bp">++</span> <span class="n">d</span><span class="bp">;</span>
  <span class="n">try</span> <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">list.append_assoc</span><span class="o">]</span> <span class="o">},</span>
  <span class="c1">-- I am talking about the goal remaining here.</span>
  <span class="gr">sorry</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>leaves me with <code>a ++ (b ++ (c ++ d)) = a ++ (x ++ (y ++ d))</code> which I didn't ask for. Why?</p>



<a name="306049176"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/congr%20with%20associativity/near/306049176" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20with.20associativity.html#306049176">(Oct 25 2022 at 15:07)</a>:</h4>
<p><span class="user-mention" data-user-id="417654">@Martin Dvořák</span> are you still stumped by this?</p>
<p>Note that <code>try {...}</code> means "try this block and do it, unless you get an error".  It does not mean "try this block and do it only if you close the goal".  The latter could probably be implemented as</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="n">try</span> <span class="o">{</span> <span class="o">{</span> <span class="n">tactics</span> <span class="o">}</span> <span class="o">}</span>
</code></pre></div>
<p>note the second layer of curly braces: this acts as <code>focus</code>.  The block will be executed only if it closes the goal.  You could also use</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="n">try</span> <span class="o">{</span> <span class="n">tactics</span><span class="o">,</span> <span class="n">done</span> <span class="o">}</span>
</code></pre></div>
<p>to achieve the same effect.</p>



<a name="306193758"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/congr%20with%20associativity/near/306193758" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20with.20associativity.html#306193758">(Oct 26 2022 at 08:58)</a>:</h4>
<p><span class="user-mention silent" data-user-id="321459">Damiano Testa</span> <a href="#narrow/stream/113488-general/topic/congr.20with.20associativity/near/306049176">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="417654">Martin Dvořák</span> are you still stumped by this?</p>
</blockquote>
<p>I gave up on implementing a tactic. I continue to prove stuff "manually". Nevertheless, your reply is useful!</p>



<a name="306200220"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/congr%20with%20associativity/near/306200220" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20with.20associativity.html#306200220">(Oct 26 2022 at 09:37)</a>:</h4>
<p>If you change your mind and want some help with the tactic, let me know: I'd be happy to help and I think that I did something similar already.</p>
<p>As has been commented before, the main obstacle that I view is figuring out which <em>exact</em> cases you want the tactic to solve:</p>
<ul>
<li>you may want to use the initial parentheses as a guide to match LHS with RHS,</li>
<li>you may want to first remove all parentheses and then do the matching,</li>
<li>you may want to have a heuristic that tries the longest actual match from the beginning, before splitting out side-goals,</li>
<li>...</li>
</ul>
<p>All these are easy to implement, it is just a matter of deciding which would be the most useful.</p>



<a name="306211261"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/congr%20with%20associativity/near/306211261" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20with.20associativity.html#306211261">(Oct 26 2022 at 10:44)</a>:</h4>
<p>I think I want to ignore the parentheses, match the longest prefix, then match the longest suffix of the remaining equality, and produce a single goal for what remained.</p>
<p>In the example <code>a * b * x * b * a = a * b * a</code> by Eric Wieser, I want the tactic to output a goal that <code>x * b</code> is the neutral element.</p>



<a name="306225535"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/congr%20with%20associativity/near/306225535" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20with.20associativity.html#306225535">(Oct 26 2022 at 12:14)</a>:</h4>
<p>This tactic isn't congr at all if you want it to manufacture a <code>1</code> term</p>



<a name="306227130"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/congr%20with%20associativity/near/306227130" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20with.20associativity.html#306227130">(Oct 26 2022 at 12:23)</a>:</h4>
<p>For me, it makes sense as a special case of the tactic I described. Would you specify it otherwise?</p>



<a name="306275957"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/congr%20with%20associativity/near/306275957" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20with.20associativity.html#306275957">(Oct 26 2022 at 16:08)</a>:</h4>
<p>Ok, it was fairly close to code that I already had.  Below is something that works with a couple of examples.  Let me know if it also works on your use cases!  Some of the functions are a little hacky, so they may misbehave.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.group.defs</span>

<span class="kn">namespace</span> <span class="n">list</span>
<span class="sd">/--  Let `l r` be two lists.  `in_match l r` is the longest, left-most consecutive</span>
<span class="sd">sublist of `l r`.  For example:</span>
<span class="sd">```lean</span>
<span class="sd">#eval in_match [1, 2, 3, 4] [1, 2, 4]  -- [1, 2]</span>
<span class="sd">```</span>
<span class="sd">-/</span>
<span class="kd">def</span> <span class="n">in_match</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">α</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="n">_</span> <span class="o">:=</span> <span class="o">[]</span>
<span class="bp">|</span> <span class="n">_</span> <span class="o">[]</span> <span class="o">:=</span> <span class="o">[]</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">a</span><span class="o">::</span><span class="n">as</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span><span class="o">::</span><span class="n">bs</span><span class="o">)</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span> <span class="k">then</span> <span class="o">(</span><span class="n">a</span> <span class="o">::</span> <span class="n">in_match</span> <span class="n">as</span> <span class="n">bs</span><span class="o">)</span> <span class="k">else</span> <span class="o">[]</span>

<span class="sd">/--  Let `l r` be two lists.  `split3 l r` is the ordered triple</span>
<span class="sd">`(initial, (mid_l, mid_r), final)`, where</span>
<span class="sd">`l = initial ++ mid_l ++ final, r = initial ++ mid_r ++ final`, with</span>
<span class="sd">* `initial` chosen greedily (via `in_match`);</span>
<span class="sd">* `final` chosen next and again greedily (via `in_match`, but starting from the end of the lists);</span>
<span class="sd">* `mid_l, mid_r` chosen to be what is left-over.</span>
<span class="sd">For example:</span>
<span class="sd">```lean</span>
<span class="sd">#eval split3 [0, 1, 2, 8, 6, 3, 7] [0, 1, 2, 4, 5, 6, 3, 7]</span>
<span class="sd">-- ([0, 1, 2], (([8], [4, 5]), [6, 3, 7]))</span>

<span class="sd">#eval split3 [0, 1, 2, 6, 3, 7] [0, 1, 2, 4, 5, 6, 3, 7]</span>
<span class="sd">-- ([0, 1, 2], (([], [4, 5]), [6, 3, 7]))</span>
<span class="sd">```</span>
<span class="sd">-/</span>
<span class="kd">def</span> <span class="n">split3</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">l</span> <span class="n">r</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span> <span class="bp">×</span> <span class="o">(</span><span class="n">list</span> <span class="n">α</span> <span class="bp">×</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="bp">×</span> <span class="n">list</span> <span class="n">α</span> <span class="o">:=</span>
<span class="k">let</span> <span class="n">ini</span>         <span class="o">:=</span> <span class="n">in_match</span> <span class="n">l</span> <span class="n">r</span> <span class="k">in</span>
<span class="k">let</span> <span class="n">lx_tail</span>     <span class="o">:=</span> <span class="n">l.drop</span> <span class="n">ini.length</span> <span class="k">in</span>
<span class="k">let</span> <span class="n">rx_tail</span>     <span class="o">:=</span> <span class="n">r.drop</span> <span class="n">ini.length</span> <span class="k">in</span>
<span class="k">let</span> <span class="n">lx_tail_rev</span> <span class="o">:=</span> <span class="n">lx_tail.reverse</span> <span class="k">in</span>
<span class="k">let</span> <span class="n">rx_tail_rev</span> <span class="o">:=</span> <span class="n">rx_tail.reverse</span> <span class="k">in</span>
<span class="k">let</span> <span class="n">fin</span>         <span class="o">:=</span> <span class="o">(</span><span class="n">in_match</span> <span class="n">lx_tail_rev</span> <span class="n">rx_tail_rev</span><span class="o">)</span><span class="bp">.</span><span class="n">reverse</span> <span class="k">in</span>
  <span class="o">(</span><span class="n">ini</span><span class="o">,</span>
    <span class="o">((</span><span class="n">lx_tail_rev.drop</span> <span class="n">fin.length</span><span class="o">)</span><span class="bp">.</span><span class="n">reverse</span><span class="o">,</span>
     <span class="o">(</span><span class="n">rx_tail_rev.drop</span> <span class="n">fin.length</span><span class="o">)</span><span class="bp">.</span><span class="n">reverse</span><span class="o">),</span>
    <span class="n">fin</span><span class="o">)</span>

<span class="sd">/--  `sum_up_with_default e op l` folds the operation `op` over the list `l`, using the given</span>
<span class="sd">element `e` as output in the case of an empty list. -/</span>
<span class="kd">meta</span> <span class="kd">def</span> <span class="n">sum_up_with_default</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">op</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span>
<span class="bp">|</span> <span class="o">[]</span>      <span class="o">:=</span> <span class="n">e</span>
<span class="bp">|</span> <span class="o">[</span><span class="n">a</span><span class="o">]</span>     <span class="o">:=</span> <span class="n">a</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">a</span><span class="o">::</span><span class="n">as</span><span class="o">)</span> <span class="o">:=</span> <span class="n">as.foldl</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">op</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="n">a</span>

<span class="kd">end</span> <span class="n">list</span>

<span class="kn">namespace</span> <span class="n">tactic</span>

<span class="kn">namespace</span> <span class="n">fla</span>

<span class="sd">/--  Similar to `sum_up_with_default e op l` except it does not take the default element `e`,</span>
<span class="sd">but fails in the case of an empty list. -/</span>
<span class="kd">meta</span> <span class="kd">def</span> <span class="n">sum_up</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">op</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">tactic</span> <span class="n">α</span>
<span class="bp">|</span> <span class="o">[]</span>      <span class="o">:=</span> <span class="n">fail</span> <span class="s2">"no initial match -- could use a unit here"</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">a</span><span class="o">::</span><span class="n">as</span><span class="o">)</span> <span class="o">:=</span> <span class="n">pure</span> <span class="bp">$</span> <span class="o">(</span><span class="n">a</span><span class="o">::</span><span class="n">as</span><span class="o">)</span><span class="bp">.</span><span class="n">sum_up_with_default</span> <span class="n">a</span> <span class="n">op</span>

<span class="sd">/--  `assoc_unit oper typ` is a hacky way of extracting a unit for the (binary) operation `oper`</span>
<span class="sd">on the type `typ`. -/</span>
<span class="kd">meta</span> <span class="kd">def</span> <span class="n">assoc_unit</span> <span class="o">(</span><span class="n">oper</span> <span class="n">typ</span> <span class="o">:</span> <span class="n">expr</span><span class="o">)</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">expr</span> <span class="o">:=</span> <span class="k">do</span>
<span class="n">some</span> <span class="n">las</span> <span class="bp">←</span> <span class="n">pure</span> <span class="bp">$</span> <span class="n">oper.get_app_args.last'</span><span class="o">,</span>
<span class="n">et</span> <span class="bp">←</span> <span class="n">infer_type</span> <span class="n">las</span><span class="o">,</span>
<span class="k">match</span> <span class="n">oper.get_app_fn.const_name</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="bp">`</span><span class="n">has_append.append</span> <span class="o">:=</span> <span class="n">to_expr</span> <span class="bp">``</span><span class="o">([]</span> <span class="o">:</span> <span class="bp">%%</span><span class="n">typ</span><span class="o">)</span> <span class="n">tt</span> <span class="n">ff</span>
  <span class="bp">|</span> <span class="bp">`</span><span class="n">has_mul.mul</span>       <span class="o">:=</span> <span class="n">to_expr</span> <span class="bp">``</span><span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="bp">%%</span><span class="n">typ</span><span class="o">)</span> <span class="n">tt</span> <span class="n">ff</span>
  <span class="bp">|</span> <span class="bp">`</span><span class="n">has_add.add</span>       <span class="o">:=</span> <span class="n">to_expr</span> <span class="bp">``</span><span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="bp">%%</span><span class="n">typ</span><span class="o">)</span> <span class="n">tt</span> <span class="n">ff</span>
  <span class="bp">|</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">fail</span><span class="s2">"the tactic does not support this operation"</span>
  <span class="kd">end</span>

<span class="sd">/--  `assoc_tac oper` is a hacky way of extracting a tactic for associating and eliminating</span>
<span class="sd">empty lists, multiplications by `1` or additions by `0` under the (binary) operation `oper`. -/</span>
<span class="kd">meta</span> <span class="kd">def</span> <span class="n">assoc_tac</span> <span class="o">(</span><span class="n">oper</span> <span class="o">:</span> <span class="n">expr</span><span class="o">)</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="k">match</span> <span class="n">oper.get_app_fn.const_name</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="bp">`</span><span class="n">has_append.append</span> <span class="o">:=</span> <span class="bp">`</span><span class="o">[</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">list.append_assoc</span><span class="o">,</span> <span class="n">list.nil_append</span><span class="o">],</span> <span class="n">done</span> <span class="o">]</span>
  <span class="bp">|</span> <span class="bp">`</span><span class="n">has_mul.mul</span>       <span class="o">:=</span> <span class="bp">`</span><span class="o">[</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">mul_assoc</span><span class="o">,</span> <span class="n">mul_one</span><span class="o">],</span> <span class="n">done</span> <span class="o">]</span>
  <span class="bp">|</span> <span class="bp">`</span><span class="n">has_add.add</span>       <span class="o">:=</span> <span class="bp">`</span><span class="o">[</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">add_assoc</span><span class="o">,</span> <span class="n">add_zero</span><span class="o">],</span> <span class="n">done</span> <span class="o">]</span>
  <span class="bp">|</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">fail</span><span class="s2">"the tactic does not support this operation"</span>
  <span class="kd">end</span>

<span class="kd">end</span> <span class="n">fla</span>

<span class="kn">namespace</span> <span class="n">interactive</span>
<span class="kn">open</span> <span class="n">fla</span>

<span class="sd">/--  `fla` tries to extract side-goals for the "central part" of an equality between two</span>
<span class="sd">iterated applications of a binary associative operation. -/</span>
<span class="kd">meta</span> <span class="kd">def</span> <span class="n">fla</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span> <span class="k">do</span>
<span class="bp">`</span><span class="o">(</span><span class="bp">%%</span><span class="n">lhs</span> <span class="bp">=</span> <span class="bp">%%</span><span class="n">rhs</span><span class="o">)</span> <span class="bp">←</span> <span class="n">target</span> <span class="bp">&gt;&gt;=</span> <span class="n">instantiate_mvars</span> <span class="bp">&lt;|&gt;</span> <span class="n">fail</span><span class="s2">"goal is not an equality"</span><span class="o">,</span>
<span class="n">et</span> <span class="bp">←</span> <span class="n">infer_type</span> <span class="n">lhs</span><span class="o">,</span>
<span class="n">oper</span> <span class="bp">←</span> <span class="k">match</span> <span class="n">lhs</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="o">(</span><span class="n">expr.app</span> <span class="o">(</span><span class="n">expr.app</span> <span class="n">f</span> <span class="n">_</span><span class="o">)</span> <span class="n">_</span><span class="o">)</span> <span class="o">:=</span> <span class="n">pure</span> <span class="n">f</span>
  <span class="bp">|</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">fail</span> <span class="s2">"no operation found"</span>
  <span class="kd">end</span><span class="o">,</span>
<span class="n">opl</span> <span class="bp">←</span> <span class="n">list_binary_operands</span> <span class="n">oper</span> <span class="n">lhs</span><span class="o">,</span>
<span class="n">opr</span> <span class="bp">←</span> <span class="n">list_binary_operands</span> <span class="n">oper</span> <span class="n">rhs</span><span class="o">,</span>
<span class="k">let</span> <span class="o">(</span><span class="n">ini</span><span class="o">,</span> <span class="o">(</span><span class="n">ldiff</span><span class="o">,</span> <span class="n">rdiff</span><span class="o">),</span> <span class="n">fin</span><span class="o">)</span> <span class="o">:=</span> <span class="n">opl.split3</span> <span class="n">opr</span><span class="o">,</span>
<span class="n">sini</span>   <span class="bp">←</span> <span class="n">sum_up</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">oper.mk_app</span> <span class="o">[</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">])</span> <span class="n">ini</span><span class="o">,</span>
<span class="n">smidl</span>  <span class="bp">←</span> <span class="n">sum_up</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">oper.mk_app</span> <span class="o">[</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">])</span> <span class="n">ldiff</span><span class="o">,</span>
<span class="n">smidr</span>  <span class="bp">←</span> <span class="n">sum_up</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">oper.mk_app</span> <span class="o">[</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">])</span> <span class="n">rdiff</span><span class="o">,</span>
<span class="n">sfin</span>   <span class="bp">←</span> <span class="n">sum_up</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">oper.mk_app</span> <span class="o">[</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">])</span> <span class="n">fin</span><span class="o">,</span>
<span class="n">nleft</span>  <span class="bp">←</span> <span class="n">sum_up</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">oper.mk_app</span> <span class="o">[</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">])</span> <span class="o">[</span><span class="n">sini</span><span class="o">,</span> <span class="n">smidl</span><span class="o">,</span> <span class="n">sfin</span><span class="o">],</span>
<span class="n">nright</span> <span class="bp">←</span> <span class="n">sum_up</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">oper.mk_app</span> <span class="o">[</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">])</span> <span class="o">[</span><span class="n">sini</span><span class="o">,</span> <span class="n">smidr</span><span class="o">,</span> <span class="n">sfin</span><span class="o">],</span>
<span class="n">l_eq</span> <span class="bp">←</span> <span class="n">mk_app</span> <span class="bp">`</span><span class="n">eq</span> <span class="o">[</span><span class="n">lhs</span><span class="o">,</span> <span class="n">nleft</span><span class="o">],</span>
<span class="n">r_eq</span> <span class="bp">←</span> <span class="n">mk_app</span> <span class="bp">`</span><span class="n">eq</span> <span class="o">[</span><span class="n">nright</span><span class="o">,</span> <span class="n">rhs</span><span class="o">],</span>
<span class="o">(</span><span class="n">_</span><span class="o">,</span> <span class="n">pr_left</span><span class="o">)</span>  <span class="bp">←</span> <span class="n">solve_aux</span> <span class="n">l_eq</span> <span class="o">(</span><span class="n">assoc_tac</span> <span class="n">oper</span><span class="o">),</span>
<span class="o">(</span><span class="n">_</span><span class="o">,</span> <span class="n">pr_right</span><span class="o">)</span> <span class="bp">←</span> <span class="n">solve_aux</span> <span class="n">r_eq</span> <span class="o">(</span><span class="n">assoc_tac</span> <span class="n">oper</span><span class="o">),</span>
<span class="n">refine</span> <span class="bp">``</span><span class="o">(</span><span class="n">eq.trans</span> <span class="bp">%%</span><span class="n">pr_left</span> <span class="o">(</span><span class="n">eq.trans</span> <span class="n">_</span> <span class="bp">%%</span><span class="n">pr_right</span><span class="o">)),</span>
<span class="n">congr</span>

<span class="sd">/--  `fla_with_unit` is similar to `fla` except that it also tries to extract a unit for the</span>
<span class="sd">operation and uses it to handle cases where the expressions to match leave some empty sublist. -/</span>
<span class="kd">meta</span> <span class="kd">def</span> <span class="n">fla_with_unit</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span> <span class="k">do</span>
<span class="bp">`</span><span class="o">(</span><span class="bp">%%</span><span class="n">lhs</span> <span class="bp">=</span> <span class="bp">%%</span><span class="n">rhs</span><span class="o">)</span> <span class="bp">←</span> <span class="n">target</span> <span class="bp">&gt;&gt;=</span> <span class="n">instantiate_mvars</span><span class="o">,</span>
<span class="n">et</span> <span class="bp">←</span> <span class="n">infer_type</span> <span class="n">lhs</span><span class="o">,</span>
<span class="n">oper</span> <span class="bp">←</span> <span class="k">match</span> <span class="n">lhs</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="o">(</span><span class="n">expr.app</span> <span class="o">(</span><span class="n">expr.app</span> <span class="n">f</span> <span class="n">_</span><span class="o">)</span> <span class="n">_</span><span class="o">)</span> <span class="o">:=</span> <span class="n">pure</span> <span class="n">f</span>
  <span class="bp">|</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">fail</span> <span class="s2">"no operation found"</span>
  <span class="kd">end</span><span class="o">,</span>
<span class="n">un</span> <span class="bp">←</span> <span class="n">assoc_unit</span> <span class="n">oper</span> <span class="n">et</span><span class="o">,</span>
<span class="n">opl</span> <span class="bp">←</span> <span class="n">list_binary_operands</span> <span class="n">oper</span> <span class="n">lhs</span><span class="o">,</span>
<span class="n">opr</span> <span class="bp">←</span> <span class="n">list_binary_operands</span> <span class="n">oper</span> <span class="n">rhs</span><span class="o">,</span>
<span class="k">let</span> <span class="o">(</span><span class="n">ini</span><span class="o">,</span> <span class="o">(</span><span class="n">ldiff</span><span class="o">,</span> <span class="n">rdiff</span><span class="o">),</span> <span class="n">fin</span><span class="o">)</span> <span class="o">:=</span>  <span class="n">opl.split3</span> <span class="n">opr</span><span class="o">,</span>
<span class="k">let</span> <span class="n">sini</span>   <span class="o">:=</span>  <span class="n">ini.sum_up_with_default</span> <span class="n">un</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">oper.mk_app</span> <span class="o">[</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">]),</span>
<span class="k">let</span> <span class="n">smidl</span>  <span class="o">:=</span>  <span class="n">ldiff.sum_up_with_default</span> <span class="n">un</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">oper.mk_app</span> <span class="o">[</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">]),</span>
<span class="k">let</span> <span class="n">smidr</span>  <span class="o">:=</span>  <span class="n">rdiff.sum_up_with_default</span> <span class="n">un</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">oper.mk_app</span> <span class="o">[</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">]),</span>
<span class="k">let</span> <span class="n">sfin</span>   <span class="o">:=</span>  <span class="n">fin.sum_up_with_default</span> <span class="n">un</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">oper.mk_app</span> <span class="o">[</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">]),</span>
<span class="k">let</span> <span class="n">nleft</span>  <span class="o">:=</span>  <span class="o">[</span><span class="n">sini</span><span class="o">,</span> <span class="n">smidl</span><span class="o">,</span> <span class="n">sfin</span><span class="o">]</span><span class="bp">.</span><span class="n">sum_up_with_default</span> <span class="n">un</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">oper.mk_app</span> <span class="o">[</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">]),</span>
<span class="k">let</span> <span class="n">nright</span> <span class="o">:=</span>  <span class="o">[</span><span class="n">sini</span><span class="o">,</span> <span class="n">smidr</span><span class="o">,</span> <span class="n">sfin</span><span class="o">]</span><span class="bp">.</span><span class="n">sum_up_with_default</span> <span class="n">un</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">oper.mk_app</span> <span class="o">[</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">]),</span>
<span class="n">l_eq</span> <span class="bp">←</span> <span class="n">mk_app</span> <span class="bp">`</span><span class="n">eq</span> <span class="o">[</span><span class="n">lhs</span><span class="o">,</span> <span class="n">nleft</span><span class="o">],</span>
<span class="n">r_eq</span> <span class="bp">←</span> <span class="n">mk_app</span> <span class="bp">`</span><span class="n">eq</span> <span class="o">[</span><span class="n">nright</span><span class="o">,</span> <span class="n">rhs</span><span class="o">],</span>
<span class="o">(</span><span class="n">_</span><span class="o">,</span> <span class="n">pr_left</span><span class="o">)</span>  <span class="bp">←</span> <span class="n">solve_aux</span> <span class="n">l_eq</span> <span class="o">(</span><span class="n">assoc_tac</span> <span class="n">oper</span><span class="o">),</span>
<span class="o">(</span><span class="n">_</span><span class="o">,</span> <span class="n">pr_right</span><span class="o">)</span> <span class="bp">←</span> <span class="n">solve_aux</span> <span class="n">r_eq</span> <span class="o">(</span><span class="n">assoc_tac</span> <span class="n">oper</span><span class="o">),</span>
<span class="n">refine</span> <span class="bp">``</span><span class="o">(</span><span class="n">eq.trans</span> <span class="bp">%%</span><span class="n">pr_left</span> <span class="o">(</span><span class="n">eq.trans</span> <span class="n">_</span> <span class="bp">%%</span><span class="n">pr_right</span><span class="o">)),</span>
<span class="n">congr</span>

<span class="kd">end</span> <span class="n">interactive</span>

<span class="kd">end</span> <span class="n">tactic</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span> <span class="n">e</span> <span class="n">f</span> <span class="o">:</span> <span class="n">list</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="n">e</span> <span class="bp">++</span> <span class="n">f</span> <span class="bp">++</span> <span class="n">e</span> <span class="bp">=</span> <span class="n">f</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">a</span> <span class="bp">++</span> <span class="o">(</span><span class="n">b</span> <span class="bp">++</span> <span class="n">c</span><span class="o">)</span> <span class="bp">++</span> <span class="n">e</span> <span class="bp">++</span> <span class="n">f</span> <span class="bp">++</span> <span class="n">e</span> <span class="bp">++</span> <span class="n">d</span> <span class="bp">=</span> <span class="o">(</span><span class="n">a</span> <span class="bp">++</span> <span class="n">b</span><span class="o">)</span> <span class="bp">++</span> <span class="o">(</span><span class="n">c</span> <span class="bp">++</span> <span class="n">f</span> <span class="bp">++</span> <span class="n">d</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">fla</span><span class="o">,</span>
  <span class="n">assumption</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">semigroup</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span> <span class="n">e</span> <span class="n">f</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="n">e</span> <span class="bp">*</span> <span class="n">f</span> <span class="bp">*</span> <span class="n">e</span> <span class="bp">=</span> <span class="n">f</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">a</span> <span class="bp">*</span> <span class="o">(</span><span class="n">b</span> <span class="bp">*</span> <span class="n">c</span><span class="o">)</span> <span class="bp">*</span> <span class="n">e</span> <span class="bp">*</span> <span class="n">f</span> <span class="bp">*</span> <span class="n">e</span> <span class="bp">*</span> <span class="n">d</span> <span class="bp">=</span> <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="n">b</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">c</span> <span class="bp">*</span> <span class="n">f</span> <span class="bp">*</span> <span class="n">d</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">fla</span><span class="o">,</span>
  <span class="n">assumption</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">add_semigroup</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span> <span class="n">e</span> <span class="n">f</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="n">e</span> <span class="bp">+</span> <span class="n">f</span> <span class="bp">+</span> <span class="n">e</span> <span class="bp">=</span> <span class="n">f</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">a</span> <span class="bp">+</span> <span class="o">(</span><span class="n">b</span> <span class="bp">+</span> <span class="n">c</span><span class="o">)</span> <span class="bp">+</span> <span class="n">e</span> <span class="bp">+</span> <span class="n">f</span> <span class="bp">+</span> <span class="n">e</span> <span class="bp">+</span> <span class="n">d</span> <span class="bp">=</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span> <span class="bp">+</span> <span class="o">(</span><span class="n">c</span> <span class="bp">+</span> <span class="n">f</span> <span class="bp">+</span> <span class="n">d</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">fla</span><span class="o">,</span>
  <span class="n">assumption</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span> <span class="n">e</span> <span class="n">f</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="n">e</span> <span class="bp">=</span> <span class="o">[])</span> <span class="o">:</span>
  <span class="n">a</span> <span class="bp">++</span> <span class="o">(</span><span class="n">b</span> <span class="bp">++</span> <span class="n">c</span><span class="o">)</span> <span class="bp">++</span> <span class="n">e</span> <span class="bp">++</span> <span class="n">f</span> <span class="bp">++</span> <span class="n">d</span> <span class="bp">=</span> <span class="o">(</span><span class="n">a</span> <span class="bp">++</span> <span class="n">b</span><span class="o">)</span> <span class="bp">++</span> <span class="o">(</span><span class="n">c</span> <span class="bp">++</span> <span class="n">f</span> <span class="bp">++</span> <span class="n">d</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">fla_with_unit</span><span class="o">,</span>
  <span class="n">assumption</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span> <span class="n">e</span> <span class="n">f</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="n">e</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">a</span> <span class="bp">*</span> <span class="o">(</span><span class="n">b</span> <span class="bp">*</span> <span class="n">c</span><span class="o">)</span> <span class="bp">*</span> <span class="n">e</span> <span class="bp">*</span> <span class="n">f</span> <span class="bp">*</span> <span class="n">d</span> <span class="bp">=</span> <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="n">b</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">c</span> <span class="bp">*</span> <span class="n">f</span> <span class="bp">*</span> <span class="n">d</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">fla_with_unit</span><span class="o">,</span>
  <span class="n">assumption</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">add_monoid</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span> <span class="n">e</span> <span class="n">f</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="n">e</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">a</span> <span class="bp">+</span> <span class="o">(</span><span class="n">b</span> <span class="bp">+</span> <span class="n">c</span><span class="o">)</span> <span class="bp">+</span> <span class="n">e</span> <span class="bp">+</span> <span class="n">f</span> <span class="bp">+</span> <span class="n">d</span> <span class="bp">=</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span> <span class="bp">+</span> <span class="o">(</span><span class="n">c</span> <span class="bp">+</span> <span class="n">f</span> <span class="bp">+</span> <span class="n">d</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">fla_with_unit</span><span class="o">,</span>
  <span class="n">assumption</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="306276547"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/congr%20with%20associativity/near/306276547" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20with.20associativity.html#306276547">(Oct 26 2022 at 16:11)</a>:</h4>
<p>I produced two tactics:</p>
<ul>
<li><code>fla</code> applies associativity with your specifications, but fails if one of the 3 parts in which the expressions get split is empty;</li>
<li><code>fla_with_unit</code> works like <code>fla</code>, except that it tries to make a guess as to what the unit of the operation should be and hopes for the best!</li>
</ul>



<a name="306379217"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/congr%20with%20associativity/near/306379217" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20with.20associativity.html#306379217">(Oct 27 2022 at 05:55)</a>:</h4>
<p>Wow! Thanks a lot!!! Imma test it today.</p>



<a name="306379701"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/congr%20with%20associativity/near/306379701" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20with.20associativity.html#306379701">(Oct 27 2022 at 06:00)</a>:</h4>
<p>Great!  If the tactic fails on some goals, please post the failure here and I will try to debug!</p>



<a name="306407998"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/congr%20with%20associativity/near/306407998" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20with.20associativity.html#306407998">(Oct 27 2022 at 09:25)</a>:</h4>
<p>It works great in many situations! However, it fails here.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">{</span><span class="n">B</span> <span class="n">C</span> <span class="o">:</span> <span class="n">R</span><span class="o">}</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">++</span> <span class="o">[</span><span class="n">B</span><span class="o">]</span> <span class="bp">++</span> <span class="o">[</span><span class="n">C</span><span class="o">]</span> <span class="bp">++</span> <span class="n">d</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">++</span> <span class="o">[</span><span class="n">B</span><span class="o">,</span> <span class="n">C</span><span class="o">]</span> <span class="bp">++</span> <span class="n">d</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">fla</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="306414241"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/congr%20with%20associativity/near/306414241" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20with.20associativity.html#306414241">(Oct 27 2022 at 10:06)</a>:</h4>
<p>What happens with this case is that the penultimate <code>congr'</code> already solves the goal.  If you replace the last line of <code>fla</code> with</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">try</span> <span class="bp">$</span> <span class="n">tactic.congr'</span> <span class="o">(</span><span class="n">some</span> <span class="mi">1</span><span class="o">)</span>
</code></pre></div>
<p>(i.e. simply adding <code>try $ </code> at the beginning) fixes this issue.</p>



<a name="306414670"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/congr%20with%20associativity/near/306414670" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20with.20associativity.html#306414670">(Oct 27 2022 at 10:09)</a>:</h4>
<p>Amazing!!! Thank you!!!</p>



<a name="306414986"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/congr%20with%20associativity/near/306414986" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20with.20associativity.html#306414986">(Oct 27 2022 at 10:11)</a>:</h4>
<p>It was confusing because when I wrote</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">{</span><span class="n">B</span> <span class="n">C</span> <span class="o">:</span> <span class="n">R</span><span class="o">}</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">++</span> <span class="o">[</span><span class="n">B</span><span class="o">]</span> <span class="bp">++</span> <span class="o">[</span><span class="n">C</span><span class="o">]</span> <span class="bp">++</span> <span class="n">d</span> <span class="bp">++</span> <span class="n">e</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">++</span> <span class="o">[</span><span class="n">B</span><span class="o">,</span> <span class="n">C</span><span class="o">]</span> <span class="bp">++</span> <span class="n">d</span> <span class="bp">++</span> <span class="n">f</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">fla</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>it didn't match <code>[B] ++ [C] </code> with <code>[B, C]</code>. Hence I didn't expect <code>fla</code> to close the goal too early in the previous example.</p>



<a name="306415335"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/congr%20with%20associativity/near/306415335" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20with.20associativity.html#306415335">(Oct 27 2022 at 10:13)</a>:</h4>
<p>Oh, that is probably because the 3-way split of the expressions is different: in the latter example, the expression have no common "tail", so everything is "beginning" or "middle".  The earlier example that you posted has a common "tail".  I think that this allows <code>congr</code> (that uses more defeqs and subsingleton) to be smarter and therefore close the goal too early!</p>



<a name="306415510"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/congr%20with%20associativity/near/306415510" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20with.20associativity.html#306415510">(Oct 27 2022 at 10:14)</a>:</h4>
<p>Is it possible to add <code>fla</code> to the list of tactics that <code>hint</code> tries inside my project?</p>



<a name="306415527"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/congr%20with%20associativity/near/306415527" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20with.20associativity.html#306415527">(Oct 27 2022 at 10:14)</a>:</h4>
<p>Note that I think that currently <code>[B] ++ [C]</code> and <code>[B, C]</code> are not considered a match by the first part of the tactic, but likely they are unified by congr.</p>



<a name="306415623"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/congr%20with%20associativity/near/306415623" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20with.20associativity.html#306415623">(Oct 27 2022 at 10:14)</a>:</h4>
<p><span class="user-mention silent" data-user-id="417654">Martin Dvořák</span> <a href="#narrow/stream/113488-general/topic/congr.20with.20associativity/near/306415510">said</a>:</p>
<blockquote>
<p>Is it possible to add <code>fla</code> to the list of tactics that <code>hint</code> tries inside my project?</p>
</blockquote>
<p>I think yes, though I need to look up what command is the right one to get it on <code>hint</code>s radar.</p>



<a name="306415934"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/congr%20with%20associativity/near/306415934" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20with.20associativity.html#306415934">(Oct 27 2022 at 10:16)</a>:</h4>
<p>Maybe it is a simple as adding <code>@[hint_tactic]</code> before <code>meta def fla</code>?</p>



<a name="306416099"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/congr%20with%20associativity/near/306416099" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20with.20associativity.html#306416099">(Oct 27 2022 at 10:17)</a>:</h4>
<p>this works, but suggests the full name <code>tactic.interactive.fla</code>.  I'll see if you can get <code>fla</code> only.</p>



<a name="306416151"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/congr%20with%20associativity/near/306416151" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20with.20associativity.html#306416151">(Oct 27 2022 at 10:17)</a>:</h4>
<p>Don't worry about that.</p>



<a name="306416292"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/congr%20with%20associativity/near/306416292" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20with.20associativity.html#306416292">(Oct 27 2022 at 10:18)</a>:</h4>
<p>Yes, instead of the attribute at the beginning, simply put <code>add_hint_tactic "fla"</code> after the definition.</p>



<a name="306416961"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/congr%20with%20associativity/near/306416961" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20with.20associativity.html#306416961">(Oct 27 2022 at 10:22)</a>:</h4>
<p>(I updated the tactic above with the <code>try</code> and the <code>hint</code>.)</p>



<a name="306417240"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/congr%20with%20associativity/near/306417240" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20with.20associativity.html#306417240">(Oct 27 2022 at 10:24)</a>:</h4>
<p>Debugging and feature requests are fun: feel free to come up with more complicated examples and post them here!</p>



<a name="306418696"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/congr%20with%20associativity/near/306418696" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20with.20associativity.html#306418696">(Oct 27 2022 at 10:34)</a>:</h4>
<p>BTW why is <code>fla</code> the name? Is it short for something?</p>



<a name="306419318"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/congr%20with%20associativity/near/306419318" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20with.20associativity.html#306419318">(Oct 27 2022 at 10:38)</a>:</h4>
<p>Oh, I think it was "Force Left Associative"</p>



<a name="306419342"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/congr%20with%20associativity/near/306419342" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20with.20associativity.html#306419342">(Oct 27 2022 at 10:38)</a>:</h4>
<p>Feel free to suggest a different name!</p>



<a name="306419403"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/congr%20with%20associativity/near/306419403" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20with.20associativity.html#306419403">(Oct 27 2022 at 10:38)</a>:</h4>
<p>I will add it to my project. How do you want credits to be written?</p>



<a name="306419565"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/congr%20with%20associativity/near/306419565" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20with.20associativity.html#306419565">(Oct 27 2022 at 10:40)</a>:</h4>
<p>I do not particularly mind: if it is its own separate file, you could add a "copyright" header like the one for mathlib.</p>
<p>In any case, most of the code here is stolen from similar code somewhere else already!</p>



<a name="306419709"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/congr%20with%20associativity/near/306419709" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20with.20associativity.html#306419709">(Oct 27 2022 at 10:41)</a>:</h4>
<p>Do you have any idea who else should get copyright, apart from you?</p>



<a name="306420481"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/congr%20with%20associativity/near/306420481" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20with.20associativity.html#306420481">(Oct 27 2022 at 10:46)</a>:</h4>
<p>Not really, since I got a lot of this code from what I had been doing with <code>move_add</code> and that in turn was through the help of Arthur Paulino, Eric Wieser, Rob Lewis and whoever wrote the tactics that I browsed.</p>
<p>I have a feeling that in this community (and certainly for myself) there is not such a big emphasis on <em>personal</em> copyright, as much as "contributing to the whole".</p>



<a name="306420691"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/congr%20with%20associativity/near/306420691" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20with.20associativity.html#306420691">(Oct 27 2022 at 10:48)</a>:</h4>
<p>I'm not adding it to mathlib but to my own project. Therefore, I don't know how much "contributing to the whole" is a valid concept here. So I want to give you a proper copyright.</p>



<a name="306420909"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/congr%20with%20associativity/near/306420909" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20with.20associativity.html#306420909">(Oct 27 2022 at 10:49)</a>:</h4>
<p>Ok, so let's ping <span class="user-mention" data-user-id="451983">@Arthur Paulino</span> , <span class="user-mention" data-user-id="310045">@Eric Wieser</span> and <span class="user-mention" data-user-id="110596">@Rob Lewis</span> and see if any of them wants to have some specific recognition for the code above.  I am certainly mostly indebted to the three of them for whatever knowledge of tactic-writing that I have.</p>



<a name="306421658"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/congr%20with%20associativity/near/306421658" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20with.20associativity.html#306421658">(Oct 27 2022 at 10:54)</a>:</h4>
<p>I don't mind copyrights. No need to mention me <span aria-label="+1" class="emoji emoji-1f44d" role="img" title="+1">:+1:</span></p>



<a name="306436237"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/congr%20with%20associativity/near/306436237" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20with.20associativity.html#306436237">(Oct 27 2022 at 12:23)</a>:</h4>
<p><span class="user-mention silent" data-user-id="321459">Damiano Testa</span> <a href="#narrow/stream/113488-general/topic/congr.20with.20associativity/near/306419342">said</a>:</p>
<blockquote>
<p>Feel free to suggest a different name!</p>
</blockquote>
<p>Would you mind if I simply call it <code>associativity</code>?</p>



<a name="306444342"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/congr%20with%20associativity/near/306444342" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20with.20associativity.html#306444342">(Oct 27 2022 at 13:05)</a>:</h4>
<p>No, I do not mind what the name ends up being.  <code>associativity</code> might be a little long, but since you might be the only user of this tactic, it is entirely up to you!  <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span></p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
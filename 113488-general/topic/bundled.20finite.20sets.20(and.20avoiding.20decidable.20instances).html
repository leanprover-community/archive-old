---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/bundled.20finite.20sets.20(and.20avoiding.20decidable.20instances).html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/bundled.20finite.20sets.20(and.20avoiding.20decidable.20instances).html">bundled finite sets (and avoiding decidable instances)</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="282193391"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bundled%20finite%20sets%20%28and%20avoiding%20decidable%20instances%29/near/282193391" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/bundled.20finite.20sets.20(and.20avoiding.20decidable.20instances).html#282193391">(May 13 2022 at 01:41)</a>:</h4>
<p>Something that has been talked about many times before is having a variant on <code>finset</code> that's "for mathematics" (i.e., ignores issues of computability/decidability). There's a design with seemingly good definitional properties that's been rattling around my mind for a while that I spent some time today developing out to see how it might work.</p>
<p>Here's an overview of the design:</p>
<ul>
<li>We keep <code>finset</code> as a data type for use in computation (and perhaps it is renamed to reflect its intended use and properties).</li>
<li>We replace <code>set.finite</code> with a predicate that says that there exists a finset with the same elements:</li>
</ul>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">set.is_finite</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">exists_finset</span> <span class="o">:</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">),</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">t</span><span class="o">)</span>
</code></pre></div>
<ul>
<li>We define a bundled <code>finite_set</code> type implementing <a href="https://leanprover-community.github.io/mathlib_docs/find/set_like">docs#set_like</a>, and because all the <code>finset</code> business is in a <code>Prop</code> we can hide away computational issues using <code>classical</code> while making the carrier set have nice definitional properties.</li>
</ul>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/-- Bundled finite sets -/</span>
<span class="kd">structure</span> <span class="n">finite_set</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">carrier</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span>
<span class="o">(</span><span class="n">finite</span> <span class="o">:</span> <span class="n">carrier.is_finite</span><span class="o">)</span>
</code></pre></div>
<ul>
<li>We replace <code>fintype</code> with a <code>Prop</code>-valued predicate, allowing us to avoid diamond problems:</li>
</ul>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">finite_type</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">univ_finite</span> <span class="o">:</span> <span class="o">(</span><span class="n">set.univ</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span><span class="bp">.</span><span class="n">is_finite</span><span class="o">)</span>
</code></pre></div>
<ul>
<li>To work with unbundled finite sets, we use <code>[finite_type s]</code> just like how we are already using <code>[fintype s]</code>, but now <code>s.to_finite_set</code> has the nice property that it <em>definitionally</em> coerces to <code>s</code>.</li>
</ul>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">set.to_finite_set</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">[</span><span class="n">finite_type</span> <span class="n">s</span><span class="o">]</span> <span class="o">:</span> <span class="n">finite_set</span> <span class="n">α</span> <span class="o">:=</span>
<span class="n">finite_set.mk</span> <span class="n">s</span>
<span class="o">(</span><span class="kd">by</span> <span class="o">{</span> <span class="n">use</span> <span class="o">(</span><span class="n">finite_set.univ</span> <span class="o">:</span> <span class="n">finite_set</span> <span class="n">s</span><span class="o">)</span><span class="bp">.</span><span class="n">finite.to_finset.map</span> <span class="o">(</span><span class="n">function.embedding.subtype</span> <span class="n">_</span><span class="o">),</span>
      <span class="n">ext</span><span class="o">,</span> <span class="n">simp</span> <span class="o">})</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">set.coe_to_finite_set</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">[</span><span class="n">finite_type</span> <span class="n">s</span><span class="o">]</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">s.to_finite_set</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="bp">=</span> <span class="n">s</span> <span class="o">:=</span> <span class="n">rfl</span>
</code></pre></div>
<ul>
<li>We can still talk about computation by introducing instances for computing specific sets as <code>finset</code>s. We can compute specific <code>finite_set</code>s too by giving <code>has_finset</code> instances for them (since they coerce to <code>set</code>).</li>
</ul>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/-- Class for computing a `finset` for a `set`. -/</span>
<span class="kd">class</span> <span class="n">has_finset</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">to_finset</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)</span>
<span class="o">(</span><span class="n">eq_to_finset</span> <span class="o">[]</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">to_finset</span><span class="o">)</span>
</code></pre></div>



<a name="282193399"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bundled%20finite%20sets%20%28and%20avoiding%20decidable%20instances%29/near/282193399" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/bundled.20finite.20sets.20(and.20avoiding.20decidable.20instances).html#282193399">(May 13 2022 at 01:41)</a>:</h4>
<p><em>(code <a href="#narrow/stream/113488-general/topic/bundled.20finite.20sets.20.28no.20decidable.20instances.29/near/282195508">below</a>)</em></p>



<a name="282193689"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bundled%20finite%20sets%20%28and%20avoiding%20decidable%20instances%29/near/282193689" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/bundled.20finite.20sets.20(and.20avoiding.20decidable.20instances).html#282193689">(May 13 2022 at 01:47)</a>:</h4>
<p>For defining operations on <code>finite_set</code>, the pattern is to</p>
<ol>
<li>Define a <code>set.is_finite</code> constructor for the given set, for instance</li>
</ol>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">protected</span> <span class="kd">lemma</span> <span class="n">is_finite.inter</span> <span class="o">{</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="n">s.is_finite</span><span class="o">)</span> <span class="o">(</span><span class="n">ht</span> <span class="o">:</span> <span class="n">t.is_finite</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">s</span> <span class="bp">∩</span> <span class="n">t</span><span class="o">)</span><span class="bp">.</span><span class="n">is_finite</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">classical</span><span class="o">,</span> <span class="n">exact</span> <span class="o">⟨⟨</span><span class="n">hs.to_finset</span> <span class="bp">∩</span> <span class="n">ht.to_finset</span><span class="o">,</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">ext</span><span class="o">,</span> <span class="n">simp</span> <span class="o">}⟩⟩</span> <span class="o">}</span>
</code></pre></div>
<p>This involves giving a corresponding <code>finset</code> construction.</p>
<ol start="2">
<li>Define the <code>finite_set</code> operation, for instance</li>
</ol>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">:</span> <span class="n">has_inter</span> <span class="o">(</span><span class="n">finite_set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">s</span> <span class="n">t</span><span class="o">,</span> <span class="o">⟨</span><span class="n">s</span> <span class="bp">∩</span> <span class="n">t</span><span class="o">,</span> <span class="n">set.is_finite.inter</span> <span class="n">s.finite</span> <span class="n">t.finite</span><span class="o">⟩⟩</span>
</code></pre></div>
<p>This is simply a matter of bundling the <code>is_finite</code> operation.</p>
<ol start="3">
<li>Provide extensionality lemmas, for instance</li>
</ol>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">mem_inter</span> <span class="o">{</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">finite_set</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span> <span class="bp">∩</span> <span class="n">t</span> <span class="bp">↔</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span> <span class="bp">∧</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">t</span> <span class="o">:=</span> <span class="n">iff.rfl</span>
</code></pre></div>



<a name="282193847"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bundled%20finite%20sets%20%28and%20avoiding%20decidable%20instances%29/near/282193847" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/bundled.20finite.20sets.20(and.20avoiding.20decidable.20instances).html#282193847">(May 13 2022 at 01:51)</a>:</h4>
<p>For lifting operations on sets to computations on <code>finset</code>s, then one can also define some instances for set operations.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">{</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">has_finset</span> <span class="n">s</span><span class="o">]</span> <span class="o">[</span><span class="n">has_finset</span> <span class="n">t</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">has_finset</span> <span class="o">(</span><span class="n">s</span> <span class="bp">∩</span> <span class="n">t</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">s.get_finset</span> <span class="bp">∩</span> <span class="n">t.get_finset</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">⟩</span>
</code></pre></div>
<p>The <code>has_finset</code> class is the <code>set</code>/<code>finset</code> analogue to <code>decidable_eq</code>, which is for <code>Prop</code>/<code>Bool</code>.  I don't really know how well this class works in practice, but using instances seems like a reasonably good place to record this sort of thing.</p>



<a name="282194418"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bundled%20finite%20sets%20%28and%20avoiding%20decidable%20instances%29/near/282194418" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/bundled.20finite.20sets.20(and.20avoiding.20decidable.20instances).html#282194418">(May 13 2022 at 02:00)</a>:</h4>
<p>I guess these <code>has_finset</code> instances can actually be useful for defining <code>is_finite</code> constructors.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">protected</span> <span class="kd">lemma</span> <span class="n">is_finite.inter</span> <span class="o">{</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="n">s.is_finite</span><span class="o">)</span> <span class="o">(</span><span class="n">ht</span> <span class="o">:</span> <span class="n">t.is_finite</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">s</span> <span class="bp">∩</span> <span class="n">t</span><span class="o">)</span><span class="bp">.</span><span class="n">is_finite</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">classical</span><span class="o">,</span> <span class="n">haveI</span> <span class="o">:=</span> <span class="n">hs.has_finset</span><span class="o">,</span> <span class="n">haveI</span> <span class="o">:=</span> <span class="n">ht.has_finset</span><span class="o">,</span> <span class="n">apply</span> <span class="n">is_finite_of_has_finset</span> <span class="o">}</span>
<span class="c1">-- ^ code that's not specific to the situation.</span>
</code></pre></div>



<a name="282195508"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bundled%20finite%20sets%20%28and%20avoiding%20decidable%20instances%29/near/282195508" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/bundled.20finite.20sets.20(and.20avoiding.20decidable.20instances).html#282195508">(May 13 2022 at 02:21)</a>:</h4>
<div class="spoiler-block"><div class="spoiler-header">
<p>newest code</p>
</div><div class="spoiler-content" aria-hidden="true">
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.set</span>
<span class="kn">import</span> <span class="n">data.finset</span>
<span class="kn">import</span> <span class="n">data.fintype.basic</span>

<span class="c">/-</span><span class="cm">! ## finiteness predicate for sets -/</span>

<span class="c1">-- to replace `set.finite`</span>
<span class="kd">structure</span> <span class="n">set.is_finite</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">exists_finset</span> <span class="o">:</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">),</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">t</span><span class="o">)</span>

<span class="kn">namespace</span> <span class="n">set</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>

<span class="sd">/-- Noncomputably get the data of a `finset` that represents this set. -/</span>
<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">is_finite.to_finset</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="n">s.is_finite</span><span class="o">)</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span> <span class="o">:=</span>
<span class="n">hs.exists_finset.some</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">is_finite.mem_to_finset</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="n">s.is_finite</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">x</span> <span class="bp">∈</span> <span class="n">hs.to_finset</span> <span class="bp">↔</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">have</span> <span class="o">:=</span> <span class="n">hs.exists_finset.some_spec.symm</span><span class="o">,</span>
  <span class="n">apply_fun</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">t</span><span class="o">,</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">t</span><span class="o">)</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span>
  <span class="n">simpa</span> <span class="n">only</span> <span class="o">[</span><span class="n">eq_iff_iff</span><span class="o">]</span> <span class="n">using</span> <span class="n">this</span><span class="o">,</span>
<span class="kd">end</span>

<span class="sd">/-- Class for computing a `finset` for a `set`. -/</span>
<span class="kd">class</span> <span class="n">has_finset</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">to_finset</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)</span>
<span class="o">(</span><span class="n">eq_to_finset</span> <span class="o">[]</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">to_finset</span><span class="o">)</span>

<span class="sd">/-- Computably get a `finset` that represents this `finite_set`.</span>
<span class="sd">(Writing `get_finset` since mathlib already has `to_finset`.) -/</span>
<span class="kd">@[reducible]</span> <span class="kd">def</span> <span class="n">get_finset</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">[</span><span class="n">has_finset</span> <span class="n">s</span><span class="o">]</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span> <span class="o">:=</span>
<span class="n">has_finset.to_finset</span> <span class="n">s</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">mem_get_finset</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">[</span><span class="n">has_finset</span> <span class="n">s</span><span class="o">]</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">x</span> <span class="bp">∈</span> <span class="n">s.get_finset</span> <span class="bp">↔</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">have</span> <span class="o">:=</span> <span class="o">(</span><span class="n">has_finset.eq_to_finset</span> <span class="n">s</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="o">,</span>
  <span class="n">apply_fun</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">t</span><span class="o">,</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">t</span><span class="o">)</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span>
  <span class="n">simpa</span> <span class="n">only</span> <span class="o">[</span><span class="n">eq_iff_iff</span><span class="o">]</span> <span class="n">using</span> <span class="n">this</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">@[simp]</span> <span class="kd">def</span> <span class="n">coe_get_finset</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">[</span><span class="n">has_finset</span> <span class="n">s</span><span class="o">]</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">s.get_finset</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="bp">=</span> <span class="n">s</span> <span class="o">:=</span> <span class="o">(</span><span class="n">has_finset.eq_to_finset</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span>

<span class="kd">@[inline]</span> <span class="kd">instance</span> <span class="n">has_to_finset.of_finset</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">has_finset</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="n">s</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span>

<span class="kd">instance</span> <span class="o">{</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">has_finset</span> <span class="n">s</span><span class="o">]</span> <span class="o">[</span><span class="n">has_finset</span> <span class="n">t</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">has_finset</span> <span class="o">(</span><span class="n">s</span> <span class="bp">∪</span> <span class="n">t</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">s.get_finset</span> <span class="bp">∪</span> <span class="n">t.get_finset</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">⟩</span>

<span class="kd">instance</span> <span class="o">{</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">has_finset</span> <span class="n">s</span><span class="o">]</span> <span class="o">[</span><span class="n">has_finset</span> <span class="n">t</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">has_finset</span> <span class="o">(</span><span class="n">s</span> <span class="bp">∩</span> <span class="n">t</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">s.get_finset</span> <span class="bp">∩</span> <span class="n">t.get_finset</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">⟩</span>

<span class="kd">instance</span> <span class="o">{</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">has_finset</span> <span class="n">s</span><span class="o">]</span> <span class="o">[</span><span class="n">has_finset</span> <span class="n">t</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">has_finset</span> <span class="o">(</span><span class="n">s</span> <span class="bp">\</span> <span class="n">t</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">s.get_finset</span> <span class="bp">\</span> <span class="n">t.get_finset</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">⟩</span>

<span class="kd">instance</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">has_finset</span> <span class="n">s</span><span class="o">]</span> <span class="o">{</span><span class="n">t</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">β</span><span class="o">}</span> <span class="o">[</span><span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">has_finset</span> <span class="o">(</span><span class="n">t</span> <span class="n">x</span><span class="o">)]</span>
  <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">β</span><span class="o">]</span> <span class="o">:</span> <span class="n">has_finset</span> <span class="o">(</span><span class="bp">⋃</span><span class="o">(</span><span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">),</span> <span class="n">t</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="n">s.get_finset.bUnion</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="o">(</span><span class="n">t</span> <span class="n">x</span><span class="o">)</span><span class="bp">.</span><span class="n">get_finset</span><span class="o">),</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">⟩</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_finset</span> <span class="o">(</span><span class="bp">∅</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="bp">∅</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">⟩</span>

<span class="kd">instance</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="n">has_finset</span> <span class="o">({</span><span class="n">x</span><span class="o">}</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨{</span><span class="n">x</span><span class="o">},</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">⟩</span>

<span class="kd">instance</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">[</span><span class="n">has_finset</span> <span class="n">s</span><span class="o">]</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">has_finset</span> <span class="o">(</span><span class="n">insert</span> <span class="n">x</span> <span class="n">s</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="n">insert</span> <span class="n">x</span> <span class="n">s.get_finset</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">⟩</span>

<span class="kd">instance</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">[</span><span class="n">has_finset</span> <span class="n">s</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">β</span><span class="o">]</span> <span class="o">:</span> <span class="n">has_finset</span> <span class="o">(</span><span class="n">f</span> <span class="bp">''</span> <span class="n">s</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="n">s.get_finset.image</span> <span class="n">f</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">⟩</span>

<span class="kd">def</span> <span class="n">is_finite_of_has_finset</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">[</span><span class="n">has_finset</span> <span class="n">s</span><span class="o">]</span> <span class="o">:</span> <span class="n">s.is_finite</span> <span class="o">:=</span>
<span class="o">⟨⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">has_finset.eq_to_finset</span> <span class="n">_</span><span class="o">⟩⟩</span>

<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">is_finite.has_finset</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="n">s.is_finite</span><span class="o">)</span> <span class="o">:</span> <span class="n">has_finset</span> <span class="n">s</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="n">hs.to_finset</span><span class="o">,</span> <span class="n">hs.exists_finset.some_spec</span><span class="o">⟩</span>

<span class="kn">protected</span> <span class="kd">lemma</span> <span class="n">is_finite.union</span> <span class="o">{</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="n">s.is_finite</span><span class="o">)</span> <span class="o">(</span><span class="n">ht</span> <span class="o">:</span> <span class="n">t.is_finite</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">s</span> <span class="bp">∪</span> <span class="n">t</span><span class="o">)</span><span class="bp">.</span><span class="n">is_finite</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">classical</span><span class="o">,</span> <span class="n">haveI</span> <span class="o">:=</span> <span class="n">hs.has_finset</span><span class="o">,</span> <span class="n">haveI</span> <span class="o">:=</span> <span class="n">ht.has_finset</span><span class="o">,</span> <span class="n">apply</span> <span class="n">is_finite_of_has_finset</span> <span class="o">}</span>

<span class="kn">protected</span> <span class="kd">lemma</span> <span class="n">is_finite.inter</span> <span class="o">{</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="n">s.is_finite</span><span class="o">)</span> <span class="o">(</span><span class="n">ht</span> <span class="o">:</span> <span class="n">t.is_finite</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">s</span> <span class="bp">∩</span> <span class="n">t</span><span class="o">)</span><span class="bp">.</span><span class="n">is_finite</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">classical</span><span class="o">,</span> <span class="n">haveI</span> <span class="o">:=</span> <span class="n">hs.has_finset</span><span class="o">,</span> <span class="n">haveI</span> <span class="o">:=</span> <span class="n">ht.has_finset</span><span class="o">,</span> <span class="n">apply</span> <span class="n">is_finite_of_has_finset</span> <span class="o">}</span>

<span class="kn">protected</span> <span class="kd">lemma</span> <span class="n">is_finite.sdiff</span> <span class="o">{</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="n">s.is_finite</span><span class="o">)</span> <span class="o">(</span><span class="n">ht</span> <span class="o">:</span> <span class="n">t.is_finite</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">s</span> <span class="bp">\</span> <span class="n">t</span><span class="o">)</span><span class="bp">.</span><span class="n">is_finite</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">classical</span><span class="o">,</span> <span class="n">haveI</span> <span class="o">:=</span> <span class="n">hs.has_finset</span><span class="o">,</span> <span class="n">haveI</span> <span class="o">:=</span> <span class="n">ht.has_finset</span><span class="o">,</span> <span class="n">apply</span> <span class="n">is_finite_of_has_finset</span> <span class="o">}</span>

<span class="kn">protected</span> <span class="kd">lemma</span> <span class="n">is_finite.bUnion</span>
  <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="n">s.is_finite</span><span class="o">)</span> <span class="o">{</span><span class="n">t</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">β</span><span class="o">}</span> <span class="o">(</span><span class="n">ht</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="o">(</span><span class="n">t</span> <span class="n">x</span><span class="o">)</span><span class="bp">.</span><span class="n">is_finite</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">⋃</span><span class="o">(</span><span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">),</span> <span class="n">t</span> <span class="n">x</span><span class="o">)</span><span class="bp">.</span><span class="n">is_finite</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">classical</span><span class="o">,</span>
  <span class="n">haveI</span> <span class="o">:=</span> <span class="n">hs.has_finset</span><span class="o">,</span>
  <span class="n">haveI</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="o">(</span><span class="n">ht</span> <span class="n">x</span><span class="o">)</span><span class="bp">.</span><span class="n">has_finset</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">is_finite_of_has_finset</span>
<span class="kd">end</span>

<span class="kn">protected</span> <span class="kd">lemma</span> <span class="n">is_finite.image</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="n">s.is_finite</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">f</span> <span class="bp">''</span> <span class="n">s</span><span class="o">)</span><span class="bp">.</span><span class="n">is_finite</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">classical</span><span class="o">,</span> <span class="n">haveI</span> <span class="o">:=</span> <span class="n">hs.has_finset</span><span class="o">,</span> <span class="n">apply</span> <span class="n">is_finite_of_has_finset</span> <span class="o">}</span>

<span class="kn">protected</span> <span class="kd">lemma</span> <span class="n">is_finite.emptyc</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∅</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span><span class="bp">.</span><span class="n">is_finite</span> <span class="o">:=</span>
<span class="n">is_finite_of_has_finset</span> <span class="n">_</span>

<span class="kn">protected</span> <span class="kd">lemma</span> <span class="n">is_finite.singleton</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="o">({</span><span class="n">x</span><span class="o">}</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span><span class="bp">.</span><span class="n">is_finite</span> <span class="o">:=</span>
<span class="n">is_finite_of_has_finset</span> <span class="n">_</span>

<span class="kn">protected</span> <span class="kd">lemma</span> <span class="n">is_finite.insert</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="n">s.is_finite</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">insert</span> <span class="n">x</span> <span class="n">s</span><span class="o">)</span><span class="bp">.</span><span class="n">is_finite</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">classical</span><span class="o">,</span> <span class="n">haveI</span> <span class="o">:=</span> <span class="n">hs.has_finset</span><span class="o">,</span> <span class="n">apply</span> <span class="n">is_finite_of_has_finset</span> <span class="o">}</span>

<span class="kd">end</span> <span class="n">set</span>


<span class="c">/-</span><span class="cm">! ## Bundled finite sets -/</span>

<span class="sd">/-- Bundled finite sets -/</span>
<span class="kd">structure</span> <span class="n">finite_set</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">carrier</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span>
<span class="o">(</span><span class="n">finite</span> <span class="o">:</span> <span class="n">carrier.is_finite</span><span class="o">)</span>

<span class="sd">/-- Create a `finite_set` from a proof of finiteness.  -/</span>
<span class="kd">def</span> <span class="n">set.is_finite.to_finite_set</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="n">s.is_finite</span><span class="o">)</span> <span class="o">:</span> <span class="n">finite_set</span> <span class="n">α</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">s</span><span class="o">,</span> <span class="n">hs</span><span class="o">⟩</span>

<span class="kn">namespace</span> <span class="n">finite_set</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">set_like</span> <span class="o">(</span><span class="n">finite_set</span> <span class="n">α</span><span class="o">)</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="n">finite_set.carrier</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">p</span> <span class="n">q</span> <span class="n">h</span><span class="o">,</span> <span class="kd">by</span> <span class="n">cases</span> <span class="n">p</span><span class="bp">;</span> <span class="n">cases</span> <span class="n">q</span><span class="bp">;</span> <span class="n">congr'</span><span class="o">⟩</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">mem_carrier</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">finite_set</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s.carrier</span> <span class="bp">↔</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span> <span class="o">:=</span> <span class="n">iff.rfl</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">mem_mk</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">h</span><span class="o">}</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">finite_set.mk</span> <span class="n">s</span> <span class="n">h</span> <span class="bp">↔</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span> <span class="o">:=</span> <span class="n">iff.rfl</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">mem_to_finite_set</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">hs</span> <span class="o">:</span> <span class="n">s.is_finite</span><span class="o">}</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">hs.to_finite_set</span> <span class="bp">↔</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span> <span class="o">:=</span> <span class="n">iff.rfl</span>

<span class="kd">@[ext]</span> <span class="kd">theorem</span> <span class="n">ext</span> <span class="o">{</span><span class="n">s</span> <span class="n">s'</span> <span class="o">:</span> <span class="n">finite_set</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span> <span class="bp">↔</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s'</span><span class="o">)</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">s'</span> <span class="o">:=</span> <span class="n">set_like.ext</span> <span class="n">h</span>

<span class="sd">/-- Copy of a `my_subobject` with a new `carrier` equal to the old one. Useful to fix definitional</span>
<span class="sd">equalities. See Note [range copy pattern]. -/</span>
<span class="kn">protected</span> <span class="kd">def</span> <span class="n">copy</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finite_set</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">s'</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="n">s'</span> <span class="bp">=</span> <span class="bp">↑</span><span class="n">s</span><span class="o">)</span> <span class="o">:</span> <span class="n">finite_set</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">carrier</span> <span class="o">:=</span> <span class="n">s'</span><span class="o">,</span>
  <span class="n">finite</span> <span class="o">:=</span> <span class="n">hs.symm</span> <span class="bp">▸</span> <span class="n">s.finite</span> <span class="o">}</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">coe_copy</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finite_set</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">s'</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="n">s'</span> <span class="bp">=</span> <span class="bp">↑</span><span class="n">s</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">s.copy</span> <span class="n">s'</span> <span class="n">hs</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="bp">=</span> <span class="n">s'</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">lemma</span> <span class="n">copy_eq</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finite_set</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">s'</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="n">s'</span> <span class="bp">=</span> <span class="bp">↑</span><span class="n">s</span><span class="o">)</span> <span class="o">:</span> <span class="n">s.copy</span> <span class="n">s'</span> <span class="n">hs</span> <span class="bp">=</span> <span class="n">s</span> <span class="o">:=</span>
<span class="n">set_like.coe_injective</span> <span class="n">hs</span>

<span class="kd">instance</span> <span class="n">has_coe.of_finset</span> <span class="o">:</span> <span class="n">has_coe</span> <span class="o">(</span><span class="n">finset</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">finite_set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">s</span><span class="o">,</span> <span class="n">finite_set.mk</span> <span class="bp">↑</span><span class="n">s</span> <span class="o">⟨⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩⟩⟩</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">finset.mem_coe</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finite_set</span> <span class="n">α</span><span class="o">)</span> <span class="bp">↔</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span> <span class="o">:=</span> <span class="n">iff.rfl</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">coe_to_finset_eq</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finite_set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">s.finite.to_finset</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="bp">=</span> <span class="n">s</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">ext</span><span class="o">,</span> <span class="n">simp</span> <span class="o">}</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">coe_to_finset</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finite_set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">s.finite.to_finset</span> <span class="o">:</span> <span class="n">finite_set</span> <span class="n">α</span><span class="o">)</span> <span class="bp">=</span> <span class="n">s</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">ext</span><span class="o">,</span> <span class="n">simp</span> <span class="o">}</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_union</span> <span class="o">(</span><span class="n">finite_set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">s</span> <span class="n">t</span><span class="o">,</span> <span class="o">⟨</span><span class="n">s</span> <span class="bp">∪</span> <span class="n">t</span><span class="o">,</span> <span class="n">set.is_finite.union</span> <span class="n">s.finite</span> <span class="n">t.finite</span><span class="o">⟩⟩</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_inter</span> <span class="o">(</span><span class="n">finite_set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">s</span> <span class="n">t</span><span class="o">,</span> <span class="o">⟨</span><span class="n">s</span> <span class="bp">∩</span> <span class="n">t</span><span class="o">,</span> <span class="n">set.is_finite.inter</span> <span class="n">s.finite</span> <span class="n">t.finite</span><span class="o">⟩⟩</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_sdiff</span> <span class="o">(</span><span class="n">finite_set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">s</span> <span class="n">t</span><span class="o">,</span> <span class="o">⟨</span><span class="n">s</span> <span class="bp">\</span> <span class="n">t</span><span class="o">,</span> <span class="n">set.is_finite.sdiff</span> <span class="n">s.finite</span> <span class="n">t.finite</span><span class="o">⟩⟩</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_emptyc</span> <span class="o">(</span><span class="n">finite_set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨⟨</span><span class="bp">∅</span><span class="o">,</span> <span class="n">set.is_finite.emptyc</span><span class="o">⟩⟩</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_singleton</span> <span class="n">α</span> <span class="o">(</span><span class="n">finite_set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="o">⟨{</span><span class="n">x</span><span class="o">},</span> <span class="n">set.is_finite.singleton</span> <span class="n">x</span><span class="o">⟩⟩</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_insert</span> <span class="n">α</span> <span class="o">(</span><span class="n">finite_set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">x</span> <span class="n">s</span><span class="o">,</span> <span class="o">⟨</span><span class="n">insert</span> <span class="n">x</span> <span class="n">s</span><span class="o">,</span> <span class="n">set.is_finite.insert</span> <span class="n">x</span> <span class="n">s.finite</span><span class="o">⟩⟩</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">mem_union</span> <span class="o">{</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">finite_set</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span> <span class="bp">∪</span> <span class="n">t</span> <span class="bp">↔</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span> <span class="bp">∨</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">t</span> <span class="o">:=</span> <span class="n">iff.rfl</span>
<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">mem_inter</span> <span class="o">{</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">finite_set</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span> <span class="bp">∩</span> <span class="n">t</span> <span class="bp">↔</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span> <span class="bp">∧</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">t</span> <span class="o">:=</span> <span class="n">iff.rfl</span>
<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">mem_sdiff</span> <span class="o">{</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">finite_set</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span> <span class="bp">\</span> <span class="n">t</span> <span class="bp">↔</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span> <span class="bp">∧</span> <span class="bp">¬</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">t</span> <span class="o">:=</span> <span class="n">iff.rfl</span>
<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">mem_emptyc</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="o">(</span><span class="bp">∅</span> <span class="o">:</span> <span class="n">finite_set</span> <span class="n">α</span><span class="o">)</span> <span class="bp">↔</span> <span class="n">false</span> <span class="o">:=</span> <span class="n">iff.rfl</span>
<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">mem_insert</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">finite_set</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">insert</span> <span class="n">y</span> <span class="n">s</span> <span class="bp">↔</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="bp">∨</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span> <span class="o">:=</span> <span class="n">iff.rfl</span>

<span class="kd">def</span> <span class="n">bUnion</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finite_set</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">finite_set</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">finite_set</span> <span class="n">β</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="bp">⋃</span> <span class="o">(</span><span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">),</span> <span class="n">t</span> <span class="n">x</span><span class="o">,</span> <span class="n">set.is_finite.bUnion</span> <span class="n">s.finite</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="o">(</span><span class="n">t</span> <span class="n">x</span><span class="o">)</span><span class="bp">.</span><span class="n">finite</span><span class="o">)⟩</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">mem_bUnion</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">finite_set</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">t</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">finite_set</span> <span class="n">β</span><span class="o">}</span> <span class="o">{</span><span class="n">y</span> <span class="o">:</span> <span class="n">β</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">y</span> <span class="bp">∈</span> <span class="n">s.bUnion</span> <span class="n">t</span> <span class="bp">↔</span> <span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span> <span class="bp">∧</span> <span class="n">y</span> <span class="bp">∈</span> <span class="n">t</span> <span class="n">x</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">bUnion</span><span class="o">]</span>

<span class="kd">def</span> <span class="n">image</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finite_set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">finite_set</span> <span class="n">β</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="n">f</span> <span class="bp">''</span> <span class="n">s</span><span class="o">,</span> <span class="n">set.is_finite.image</span> <span class="n">f</span> <span class="n">s.finite</span><span class="o">⟩</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">mem_image</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">finite_set</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">y</span> <span class="o">:</span> <span class="n">β</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">y</span> <span class="bp">∈</span> <span class="n">f</span> <span class="bp">''</span> <span class="n">s</span> <span class="bp">↔</span> <span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span> <span class="bp">∧</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">iff.rfl</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">monad</span> <span class="n">finite_set</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">map</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span> <span class="n">f</span><span class="o">,</span> <span class="n">image</span> <span class="n">f</span><span class="o">,</span>
  <span class="n">pure</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span> <span class="n">x</span><span class="o">,</span> <span class="o">{</span><span class="n">x</span><span class="o">},</span>
  <span class="n">seq</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span> <span class="n">t</span> <span class="n">s</span><span class="o">,</span> <span class="n">t.bUnion</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">f</span><span class="o">,</span> <span class="n">s.image</span> <span class="n">f</span><span class="o">),</span>
  <span class="n">bind</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span> <span class="n">s</span> <span class="n">f</span><span class="o">,</span> <span class="n">s.bUnion</span> <span class="n">f</span> <span class="o">}</span>

<span class="kd">end</span> <span class="n">finite_set</span>


<span class="c">/-</span><span class="cm">! ## Finite types -/</span>

<span class="kd">class</span> <span class="n">finite_type</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">univ_finite</span> <span class="o">:</span> <span class="o">(</span><span class="n">set.univ</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span><span class="bp">.</span><span class="n">is_finite</span><span class="o">)</span>

<span class="kn">namespace</span> <span class="n">finite_set</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>

<span class="sd">/-- `set.univ` as a `finite_set`. -/</span>
<span class="kd">def</span> <span class="n">univ</span> <span class="o">[</span><span class="n">finite_type</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">finite_set</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">finite_type.univ_finite.to_finite_set</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">coe_univ</span> <span class="o">[</span><span class="n">finite_type</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="o">((</span><span class="n">univ</span> <span class="o">:</span> <span class="n">finite_set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="bp">=</span> <span class="n">set.univ</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">mem_univ</span> <span class="o">[</span><span class="n">finite_type</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="o">(</span><span class="n">univ</span> <span class="o">:</span> <span class="n">finite_set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="n">trivial</span>

<span class="sd">/-- Every type that is computably finite is also a `finite_type`.</span>
<span class="sd">(Should `fintype` even exist if there is `finite_type`?) -/</span>
<span class="kd">instance</span> <span class="n">of_fintype</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">finite_type</span> <span class="n">α</span> <span class="o">:=</span> <span class="o">⟨⟨⟨</span><span class="n">finset.univ</span><span class="o">,</span> <span class="kd">by</span> <span class="n">rw</span> <span class="n">finset.coe_univ</span><span class="o">⟩⟩⟩</span>

<span class="kd">end</span> <span class="n">finite_set</span>


<span class="c">/-</span><span class="cm">! ## Mechanism for bundling a `set` as a `finite_set' -/</span>

<span class="sd">/-- Get the bundled `finite_set` for a set that has a `finite_type` instance. -/</span>
<span class="kd">def</span> <span class="n">set.to_finite_set</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">[</span><span class="n">finite_type</span> <span class="n">s</span><span class="o">]</span> <span class="o">:</span> <span class="n">finite_set</span> <span class="n">α</span> <span class="o">:=</span>
<span class="n">finite_set.mk</span> <span class="n">s</span>
<span class="o">(</span><span class="kd">by</span> <span class="o">{</span> <span class="n">use</span> <span class="o">(</span><span class="n">finite_set.univ</span> <span class="o">:</span> <span class="n">finite_set</span> <span class="n">s</span><span class="o">)</span><span class="bp">.</span><span class="n">finite.to_finset.map</span> <span class="o">(</span><span class="n">function.embedding.subtype</span> <span class="n">_</span><span class="o">),</span>
      <span class="n">ext</span><span class="o">,</span> <span class="n">simp</span> <span class="o">})</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">set.coe_to_finite_set</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">[</span><span class="n">finite_type</span> <span class="n">s</span><span class="o">]</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">s.to_finite_set</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="bp">=</span> <span class="n">s</span> <span class="o">:=</span> <span class="n">rfl</span>
</code></pre></div>
</div></div>



<a name="282216456"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bundled%20finite%20sets%20%28and%20avoiding%20decidable%20instances%29/near/282216456" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/bundled.20finite.20sets.20(and.20avoiding.20decidable.20instances).html#282216456">(May 13 2022 at 08:21)</a>:</h4>
<p>Why not go the other way around and hold a <code>set</code> in <code>finset</code>?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">finset</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">val</span> <span class="o">:</span> <span class="n">multiset</span> <span class="n">α</span><span class="o">)</span>
<span class="o">(</span><span class="n">nodup</span> <span class="o">:</span> <span class="n">nodup</span> <span class="n">val</span><span class="o">)</span>
<span class="o">(</span><span class="n">to_set</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span>
<span class="o">(</span><span class="n">coe_eq</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">val</span> <span class="bp">↔</span> <span class="n">to_set</span><span class="o">)</span>
</code></pre></div>
<p>Then you can define the coercion from <code>finset α</code> to <code>set α</code> as <code>finset.to_set</code>. No need for a new structure, and not much changes.</p>



<a name="282235058"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bundled%20finite%20sets%20%28and%20avoiding%20decidable%20instances%29/near/282235058" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/bundled.20finite.20sets.20(and.20avoiding.20decidable.20instances).html#282235058">(May 13 2022 at 11:45)</a>:</h4>
<p>That still needs decidable instances to be useful as data. The design goals are (1) to keep a computational finite set definition around, (2) to have a computationally irrelevant finite set definition (no more decidable instances in proofs about mathematical finite sets!), (3) to have this definition have good definitional properties with respect to <code>set</code>, (4) to have <code>fintype</code> be a Prop so that instances may enjoy proof irrelevance, and (5) to have a way to associate computational sets to computationally irrelevant ones (so we at least have a place to put fintype algorithms).</p>
<p>That suggested change to <code>finset</code> partly handles 3 and does not simultaneously handle 1 and 2. The issue with 3 is that even if the sets are definitionally equal, the multisets might not be.</p>



<a name="282235216"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bundled%20finite%20sets%20%28and%20avoiding%20decidable%20instances%29/near/282235216" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/bundled.20finite.20sets.20(and.20avoiding.20decidable.20instances).html#282235216">(May 13 2022 at 11:46)</a>:</h4>
<p>Of course, this is a trade-off. But experience suggests that we care much more about the <code>finset α → set α</code> coercion than the <code>finset α → multiset α</code> one.</p>



<a name="282235428"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bundled%20finite%20sets%20%28and%20avoiding%20decidable%20instances%29/near/282235428" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/bundled.20finite.20sets.20(and.20avoiding.20decidable.20instances).html#282235428">(May 13 2022 at 11:49)</a>:</h4>
<p>I'm afraid this will just end up being "Yet another way to talk about finite things" while the symptom of the problem hasn't been solved. Namely, decidability shouldn't stop defeq. A few uneducated solutions I have to this are:</p>
<ul>
<li>Do not handle decidability with instances. An option is your <code>compuitable</code> typeclass. Another one would to have a fully separate decidability handler, which automatically marks declaration with the right decidability instances.</li>
<li>Make subsingleton elimination defeq, at least for <code>decidable</code> and <code>fintype</code></li>
</ul>



<a name="282244196"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bundled%20finite%20sets%20%28and%20avoiding%20decidable%20instances%29/near/282244196" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/bundled.20finite.20sets.20(and.20avoiding.20decidable.20instances).html#282244196">(May 13 2022 at 13:13)</a>:</h4>
<blockquote>
<p>Make subsingleton elimination defeq, at least for decidable and fintype</p>
</blockquote>
<p>I've always suggested this, or at least a type-class inference system that can handle defeq. I feel like the deeper we get into maths, the more we can't rejig to make things defeq. I often struggle accepting that <code>x^1</code> is not definitionally equal to <code>x</code> (or hell, even <code>1*x</code> or <code>x*1</code>),  and these issues are just going to keep intensifying, c.f. representation theory</p>



<a name="282244516"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bundled%20finite%20sets%20%28and%20avoiding%20decidable%20instances%29/near/282244516" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/bundled.20finite.20sets.20(and.20avoiding.20decidable.20instances).html#282244516">(May 13 2022 at 13:16)</a>:</h4>
<p>I'm curious if the change in <a href="https://github.com/leanprover-community/mathlib/pull/14122">#14122</a> will make decidable arguments in proofs less annoying</p>



<a name="282244866"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bundled%20finite%20sets%20%28and%20avoiding%20decidable%20instances%29/near/282244866" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/bundled.20finite.20sets.20(and.20avoiding.20decidable.20instances).html#282244866">(May 13 2022 at 13:19)</a>:</h4>
<p>I guess this will mostly solve <code>decidable</code>, but no good solution to <code>fintype</code> still :(</p>



<a name="282244895"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bundled%20finite%20sets%20%28and%20avoiding%20decidable%20instances%29/near/282244895" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/bundled.20finite.20sets.20(and.20avoiding.20decidable.20instances).html#282244895">(May 13 2022 at 13:19)</a>:</h4>
<p>And the only real reason it solves is it because no-one ever writes decidable instances ;b</p>



<a name="282247720"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bundled%20finite%20sets%20%28and%20avoiding%20decidable%20instances%29/near/282247720" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/bundled.20finite.20sets.20(and.20avoiding.20decidable.20instances).html#282247720">(May 13 2022 at 13:39)</a>:</h4>
<blockquote>
<p>Make subsingleton elimination defeq, at least for decidable and fintype</p>
</blockquote>
<p>I think it's strictly better to just make <code>decidable</code> and <code>fintype</code> propositions, mainly because it's a thing we can actually do</p>



<a name="282247837"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bundled%20finite%20sets%20%28and%20avoiding%20decidable%20instances%29/near/282247837" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/bundled.20finite.20sets.20(and.20avoiding.20decidable.20instances).html#282247837">(May 13 2022 at 13:40)</a>:</h4>
<p>Making <code>decidable p : Prop</code> would be pointless (and would make <code>if</code> noncomputable!), so I assume you meant something else</p>



<a name="282247894"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bundled%20finite%20sets%20%28and%20avoiding%20decidable%20instances%29/near/282247894" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/bundled.20finite.20sets.20(and.20avoiding.20decidable.20instances).html#282247894">(May 13 2022 at 13:40)</a>:</h4>
<p>Well, effectively it means getting rid of (i.e., not using) <code>decidable</code></p>



<a name="282247921"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bundled%20finite%20sets%20%28and%20avoiding%20decidable%20instances%29/near/282247921" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/bundled.20finite.20sets.20(and.20avoiding.20decidable.20instances).html#282247921">(May 13 2022 at 13:41)</a>:</h4>
<p>(Also, it's not constructively pointless!)</p>



<a name="282247937"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bundled%20finite%20sets%20%28and%20avoiding%20decidable%20instances%29/near/282247937" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/bundled.20finite.20sets.20(and.20avoiding.20decidable.20instances).html#282247937">(May 13 2022 at 13:41)</a>:</h4>
<p><code>decidable</code> is still needed for meta code though</p>



<a name="282247962"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bundled%20finite%20sets%20%28and%20avoiding%20decidable%20instances%29/near/282247962" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/bundled.20finite.20sets.20(and.20avoiding.20decidable.20instances).html#282247962">(May 13 2022 at 13:41)</a>:</h4>
<p>(Also, it's not constructively pointless!)</p>



<a name="282247963"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bundled%20finite%20sets%20%28and%20avoiding%20decidable%20instances%29/near/282247963" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/bundled.20finite.20sets.20(and.20avoiding.20decidable.20instances).html#282247963">(May 13 2022 at 13:41)</a>:</h4>
<p>Well, effectively it means getting rid of (i.e., not using) <code>decidable</code></p>



<a name="282247985"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bundled%20finite%20sets%20%28and%20avoiding%20decidable%20instances%29/near/282247985" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/bundled.20finite.20sets.20(and.20avoiding.20decidable.20instances).html#282247985">(May 13 2022 at 13:41)</a>:</h4>
<p>Right, <code>if</code> should be noncomputable</p>



<a name="282248003"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bundled%20finite%20sets%20%28and%20avoiding%20decidable%20instances%29/near/282248003" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/bundled.20finite.20sets.20(and.20avoiding.20decidable.20instances).html#282248003">(May 13 2022 at 13:41)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/113488-general/topic/bundled.20finite.20sets.20.28and.20avoiding.20decidable.20instances.29/near/282247985">said</a>:</p>
<blockquote>
<p>Right, <code>if</code> should be noncomputable</p>
</blockquote>
<p>Then we need a different <code>if</code> for meta code</p>



<a name="282248026"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bundled%20finite%20sets%20%28and%20avoiding%20decidable%20instances%29/near/282248026" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/bundled.20finite.20sets.20(and.20avoiding.20decidable.20instances).html#282248026">(May 13 2022 at 13:42)</a>:</h4>
<p>If you're going down the extensional type theory road then you are going to have way bigger problems than that</p>



<a name="282250917"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bundled%20finite%20sets%20%28and%20avoiding%20decidable%20instances%29/near/282250917" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/bundled.20finite.20sets.20(and.20avoiding.20decidable.20instances).html#282250917">(May 13 2022 at 14:01)</a>:</h4>
<p>The general case is that if you want a definitionally irrelevant subsingleton then we already have it, it's called <code>Prop</code>. I agree including the case of <code>decidable</code> is a bit silly.</p>



<a name="282251706"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bundled%20finite%20sets%20%28and%20avoiding%20decidable%20instances%29/near/282251706" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/bundled.20finite.20sets.20(and.20avoiding.20decidable.20instances).html#282251706">(May 13 2022 at 14:06)</a>:</h4>
<p>Does the type theory become more complex if we allow <code>trunc</code> to be definitionally irrelevant too?</p>



<a name="282251738"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bundled%20finite%20sets%20%28and%20avoiding%20decidable%20instances%29/near/282251738" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/bundled.20finite.20sets.20(and.20avoiding.20decidable.20instances).html#282251738">(May 13 2022 at 14:07)</a>:</h4>
<p>Because we could wrap everything where this problem arises in <code>trunc</code> if necessary</p>



<a name="282252071"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bundled%20finite%20sets%20%28and%20avoiding%20decidable%20instances%29/near/282252071" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/bundled.20finite.20sets.20(and.20avoiding.20decidable.20instances).html#282252071">(May 13 2022 at 14:09)</a>:</h4>
<p>I'm pretty sure all of these amount to equality reflection, i.e., if you have <code>h : a = b</code> then <code>a</code> and <code>b</code> are defeq</p>



<a name="282252172"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bundled%20finite%20sets%20%28and%20avoiding%20decidable%20instances%29/near/282252172" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/bundled.20finite.20sets.20(and.20avoiding.20decidable.20instances).html#282252172">(May 13 2022 at 14:10)</a>:</h4>
<p>except the ones involving <code>decidable</code>, which I'm not sure about</p>



<a name="282252217"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bundled%20finite%20sets%20%28and%20avoiding%20decidable%20instances%29/near/282252217" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/bundled.20finite.20sets.20(and.20avoiding.20decidable.20instances).html#282252217">(May 13 2022 at 14:11)</a>:</h4>
<p>what was the issue with equality reflection again?</p>



<a name="282252442"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bundled%20finite%20sets%20%28and%20avoiding%20decidable%20instances%29/near/282252442" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/bundled.20finite.20sets.20(and.20avoiding.20decidable.20instances).html#282252442">(May 13 2022 at 14:13)</a>:</h4>
<p>It's way outside the scope of Lean. I've seen a theorem prover based on extensional type theory but I don't remember what it was called, or how serious it was</p>



<a name="282253032"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bundled%20finite%20sets%20%28and%20avoiding%20decidable%20instances%29/near/282253032" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/bundled.20finite.20sets.20(and.20avoiding.20decidable.20instances).html#282253032">(May 13 2022 at 14:17)</a>:</h4>
<p>NuPRL has extensional types I believe.</p>



<a name="282253278"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bundled%20finite%20sets%20%28and%20avoiding%20decidable%20instances%29/near/282253278" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/bundled.20finite.20sets.20(and.20avoiding.20decidable.20instances).html#282253278">(May 13 2022 at 14:19)</a>:</h4>
<p>The main issue is that to check a defeq the kernel might have to synthesize some arbitrary proof of equality--obviously there's no algorithm that can do so in all cases, so how do you make something usable and reliable and trustable.</p>



<a name="282253440"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bundled%20finite%20sets%20%28and%20avoiding%20decidable%20instances%29/near/282253440" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/bundled.20finite.20sets.20(and.20avoiding.20decidable.20instances).html#282253440">(May 13 2022 at 14:20)</a>:</h4>
<p>In Lean's current type theory the definitional equality is more or less decidable by an algorithm and that algorithm works in practice most of the time.</p>



<a name="282253497"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bundled%20finite%20sets%20%28and%20avoiding%20decidable%20instances%29/near/282253497" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/bundled.20finite.20sets.20(and.20avoiding.20decidable.20instances).html#282253497">(May 13 2022 at 14:20)</a>:</h4>
<p>why can't we just use the current kernel typechecker. if a <code>rfl</code> that should work fails that shouldn't be able to affect consistency</p>



<a name="282253559"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bundled%20finite%20sets%20%28and%20avoiding%20decidable%20instances%29/near/282253559" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/bundled.20finite.20sets.20(and.20avoiding.20decidable.20instances).html#282253559">(May 13 2022 at 14:21)</a>:</h4>
<p>and then we can just add the extra <code>rfl</code>s that need kernel support</p>



<a name="282253714"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bundled%20finite%20sets%20%28and%20avoiding%20decidable%20instances%29/near/282253714" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/bundled.20finite.20sets.20(and.20avoiding.20decidable.20instances).html#282253714">(May 13 2022 at 14:22)</a>:</h4>
<p>Those extra <code>rfl</code>s are where the problem is</p>



<a name="282253733"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bundled%20finite%20sets%20%28and%20avoiding%20decidable%20instances%29/near/282253733" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/bundled.20finite.20sets.20(and.20avoiding.20decidable.20instances).html#282253733">(May 13 2022 at 14:22)</a>:</h4>
<p>Those extra <code>rfl</code>s are where the problem is</p>



<a name="282254083"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bundled%20finite%20sets%20%28and%20avoiding%20decidable%20instances%29/near/282254083" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/bundled.20finite.20sets.20(and.20avoiding.20decidable.20instances).html#282254083">(May 13 2022 at 14:25)</a>:</h4>
<p>how so? say for example we have Lean + "if there's a proof that a type <code>t</code> is a subsingleton in the instance cache somehow, then <code>a = b : @eq t</code> is <code>rfl</code>"</p>



<a name="282254583"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bundled%20finite%20sets%20%28and%20avoiding%20decidable%20instances%29/near/282254583" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/bundled.20finite.20sets.20(and.20avoiding.20decidable.20instances).html#282254583">(May 13 2022 at 14:28)</a>:</h4>
<p>Well the kernel doesn't have an instance cache</p>



<a name="282255052"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bundled%20finite%20sets%20%28and%20avoiding%20decidable%20instances%29/near/282255052" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/bundled.20finite.20sets.20(and.20avoiding.20decidable.20instances).html#282255052">(May 13 2022 at 14:31)</a>:</h4>
<p>Proof irrelevance for <code>Prop</code> is already a bit funny and I think it's why definitions using well-founded recursion don't compute in the kernel (right?)</p>



<a name="282255053"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bundled%20finite%20sets%20%28and%20avoiding%20decidable%20instances%29/near/282255053" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/bundled.20finite.20sets.20(and.20avoiding.20decidable.20instances).html#282255053">(May 13 2022 at 14:31)</a>:</h4>
<p>Hmm, I guess not, but the higher-level automation could add the instances that are used using <code>have</code> statements to the proofs. I guess this is really slow and complicated, though</p>



<a name="282255209"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bundled%20finite%20sets%20%28and%20avoiding%20decidable%20instances%29/near/282255209" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/bundled.20finite.20sets.20(and.20avoiding.20decidable.20instances).html#282255209">(May 13 2022 at 14:32)</a>:</h4>
<p>For specific types, however, specific support could be added and that solves 99% of the issues (fintype, decidable, Q-algebras maybe)</p>



<a name="282255527"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bundled%20finite%20sets%20%28and%20avoiding%20decidable%20instances%29/near/282255527" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/bundled.20finite.20sets.20(and.20avoiding.20decidable.20instances).html#282255527">(May 13 2022 at 14:35)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/113488-general/topic/bundled.20finite.20sets.20.28and.20avoiding.20decidable.20instances.29/near/282248003">said</a>:</p>
<blockquote>
<p>Then we need a different <code>if</code> for meta code</p>
</blockquote>
<p>I suggest <code>mif</code></p>



<a name="282255977"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bundled%20finite%20sets%20%28and%20avoiding%20decidable%20instances%29/near/282255977" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/bundled.20finite.20sets.20(and.20avoiding.20decidable.20instances).html#282255977">(May 13 2022 at 14:38)</a>:</h4>
<p>OK so let's suppose you write down a rule "if <code>a : fintype X</code> and <code>b : fintype X</code> then <code>a</code> and <code>b</code> are defeq"</p>



<a name="282256020"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bundled%20finite%20sets%20%28and%20avoiding%20decidable%20instances%29/near/282256020" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/bundled.20finite.20sets.20(and.20avoiding.20decidable.20instances).html#282256020">(May 13 2022 at 14:38)</a>:</h4>
<p>How do you know when to apply the rule?</p>



<a name="282256102"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bundled%20finite%20sets%20%28and%20avoiding%20decidable%20instances%29/near/282256102" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/bundled.20finite.20sets.20(and.20avoiding.20decidable.20instances).html#282256102">(May 13 2022 at 14:39)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span> That makes sense, but we should probably think ahead to Lean 4 -- we probably don't want to override its programming language features.  We could have <code>if'</code> on the math side, or <code>cif</code> for "classical if".</p>



<a name="282256106"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bundled%20finite%20sets%20%28and%20avoiding%20decidable%20instances%29/near/282256106" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/bundled.20finite.20sets.20(and.20avoiding.20decidable.20instances).html#282256106">(May 13 2022 at 14:39)</a>:</h4>
<p>Maybe I'm trying to type check <code>rfl : 0 = sum (x : X), x</code></p>



<a name="282256331"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bundled%20finite%20sets%20%28and%20avoiding%20decidable%20instances%29/near/282256331" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/bundled.20finite.20sets.20(and.20avoiding.20decidable.20instances).html#282256331">(May 13 2022 at 14:41)</a>:</h4>
<p>That <code>sum</code> involves a <code>fintype X</code> argument which might be stuck for some reason (e.g., uses an axiom). But wait! what if I can somehow cook up a second <code>b : fintype X</code> which isn't stuck, and then keep reducing</p>



<a name="282256452"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bundled%20finite%20sets%20%28and%20avoiding%20decidable%20instances%29/near/282256452" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/bundled.20finite.20sets.20(and.20avoiding.20decidable.20instances).html#282256452">(May 13 2022 at 14:41)</a>:</h4>
<p>Now I am back to the same problem, namely, I should be able to synthesize terms out of thin air</p>



<a name="282256824"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bundled%20finite%20sets%20%28and%20avoiding%20decidable%20instances%29/near/282256824" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/bundled.20finite.20sets.20(and.20avoiding.20decidable.20instances).html#282256824">(May 13 2022 at 14:44)</a>:</h4>
<p>Maybe you say: well too bad, I don't know how to do that. Then you are in the nontransitivite defeq situation. The <code>sum</code> with the bad <code>fintype</code> instance is convertible to the one with the good <code>fintype</code> instance (by <code>fintype</code> irrelevance), which can be reduced to <code>0</code>. But we aren't capable of reducing the original <code>sum</code> to <code>0</code>.</p>



<a name="282257229"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bundled%20finite%20sets%20%28and%20avoiding%20decidable%20instances%29/near/282257229" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/bundled.20finite.20sets.20(and.20avoiding.20decidable.20instances).html#282257229">(May 13 2022 at 14:46)</a>:</h4>
<p>If that is going to happen anyways, then maybe <code>sum</code> should just be noncomputable in the first place, and we can use tactics/propositional reasoning when we want to "compute" it. At least this is something that we could Just Do today, and doesn't require modifying the kernel with possibly other consequences.</p>



<a name="282257513"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bundled%20finite%20sets%20%28and%20avoiding%20decidable%20instances%29/near/282257513" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/bundled.20finite.20sets.20(and.20avoiding.20decidable.20instances).html#282257513">(May 13 2022 at 14:48)</a>:</h4>
<p>Thanks, that's a really good explanation. I feel like a non-transitive defeq isn't that evil, though - hell, I thought we had it already for some language features. Plus, it also fits my idea of "true by definition" in informal mathematics.</p>



<a name="282257673"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bundled%20finite%20sets%20%28and%20avoiding%20decidable%20instances%29/near/282257673" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/bundled.20finite.20sets.20(and.20avoiding.20decidable.20instances).html#282257673">(May 13 2022 at 14:49)</a>:</h4>
<p>But I guess this second approach is the current tsum/etc approach, and that leaves us with a lot of arguments we have to carry around. Maybe we can improve that by making an instanced version of <code>nonempty (x)</code>for relevant x, and then we get TC search and not a bunch of annoying arguments everywhere</p>



<a name="282257852"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bundled%20finite%20sets%20%28and%20avoiding%20decidable%20instances%29/near/282257852" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/bundled.20finite.20sets.20(and.20avoiding.20decidable.20instances).html#282257852">(May 13 2022 at 14:50)</a>:</h4>
<p><span class="user-mention silent" data-user-id="387244">Yaël Dillies</span> <a href="#narrow/stream/113488-general/topic/bundled.20finite.20sets.20.28and.20avoiding.20decidable.20instances.29/near/282235216">said</a>:</p>
<blockquote>
<p>Of course, this is a trade-off. But experience suggests that we care much more about the <code>finset α → set α</code> coercion than the <code>finset α → multiset α</code> one.</p>
</blockquote>
<p>I suspect I'm not being understood here. The issues is not about coercions per se. The proposed <code>finite_set</code> type has the property that the finite sets are definitionally equal if and only if the underlying sets are definitionally equal. When you have the <code>multiset</code> in the mix as actual data, you essentially have diamond problems, which I at least would like to avoid.</p>
<p>Regarding a trade-off, the five design goals I mentioned are all met by the <code>finite_set</code> proposal. It does not meet the unmentioned number 6 (not be a whole lot of work) but I think this is unavoidable.</p>
<p>So long as we keep using data structures for finite sets as if they were <code>set</code>s that are finite, I think we're going to keep having a struggle.  Regarding your concern about "yet another way to talk about finite things", it seems similar to how we have both lists and functions <code>fin n -&gt; A</code>, but we don't try to force one to be the other.</p>



<a name="282257859"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bundled%20finite%20sets%20%28and%20avoiding%20decidable%20instances%29/near/282257859" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/bundled.20finite.20sets.20(and.20avoiding.20decidable.20instances).html#282257859">(May 13 2022 at 14:50)</a>:</h4>
<p>Or maybe you really specifically need the definitional equality (because these expressions are appearing in the index of some type family) and then yes, I agree it would be much nicer if you could convince the kernel to do these conversions; I just don't know what the framework for making it work reliably should look like, and I'm not sure whether anyone does</p>



<a name="282257971"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bundled%20finite%20sets%20%28and%20avoiding%20decidable%20instances%29/near/282257971" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/bundled.20finite.20sets.20(and.20avoiding.20decidable.20instances).html#282257971">(May 13 2022 at 14:51)</a>:</h4>
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span> Do you have any thoughts about the <code>finite_set</code> proposal? It seems like you're in favor at least in principle. I'm wondering partly because I know you spent time a while back working on this sort of thing.</p>



<a name="282258168"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bundled%20finite%20sets%20%28and%20avoiding%20decidable%20instances%29/near/282258168" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/bundled.20finite.20sets.20(and.20avoiding.20decidable.20instances).html#282258168">(May 13 2022 at 14:52)</a>:</h4>
<p>To reduce work, I think leaving <code>fintype</code> as-is makes sense for now (rather than replacing it) and introducing <code>finite_type</code> for the <code>Prop</code> version, then having <code>finite_type</code> instances from <code>fintype</code> instances.</p>



<a name="282258544"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bundled%20finite%20sets%20%28and%20avoiding%20decidable%20instances%29/near/282258544" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/bundled.20finite.20sets.20(and.20avoiding.20decidable.20instances).html#282258544">(May 13 2022 at 14:55)</a>:</h4>
<p><span class="user-mention silent" data-user-id="387244">Yaël Dillies</span> <a href="#narrow/stream/113488-general/topic/bundled.20finite.20sets.20.28and.20avoiding.20decidable.20instances.29/near/282216456">said</a>:</p>
<blockquote>
<p>Why not go the other way around and hold a <code>set</code> in <code>finset</code>?<br>
&lt;snip&gt;</p>
</blockquote>
<p>Just to note, the effect of this change is to have nicer definitional control of what finset membership means, but it's orthogonal to decidability discussions.</p>



<a name="282259758"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bundled%20finite%20sets%20%28and%20avoiding%20decidable%20instances%29/near/282259758" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/bundled.20finite.20sets.20(and.20avoiding.20decidable.20instances).html#282259758">(May 13 2022 at 15:02)</a>:</h4>
<p><span class="user-mention" data-user-id="310045">@Eric Wieser</span> What's "this"? I assume you're clarifying Yael's suggestion?</p>



<a name="282259833"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bundled%20finite%20sets%20%28and%20avoiding%20decidable%20instances%29/near/282259833" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/bundled.20finite.20sets.20(and.20avoiding.20decidable.20instances).html#282259833">(May 13 2022 at 15:03)</a>:</h4>
<p>"this" refers to Yael's suggestion in the message I quoted</p>



<a name="282360549"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bundled%20finite%20sets%20%28and%20avoiding%20decidable%20instances%29/near/282360549" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/bundled.20finite.20sets.20(and.20avoiding.20decidable.20instances).html#282360549">(May 14 2022 at 16:22)</a>:</h4>
<p>After going through all of what we have already in <code>data/set/finite</code> and reorganizing it (<a href="https://github.com/leanprover-community/mathlib/pull/14136">#14136</a>), I guess we already have pretty much everything set up for bundled finite sets. Here's an overview for a proposed design:</p>
<ul>
<li><code>finset</code> remains as-is. It's the computational model (i.e. a data structure) for finite sets.</li>
<li><code>fintype</code> remains as-is. Paired with <a href="https://leanprover-community.github.io/mathlib_docs/find/set.to_finite">docs#set.to_finite</a>, this is the database of ways to turn sets that are finite into computable finite sets. (It's the finite set analogue of <code>decidable</code>.)</li>
<li><code>set.finite</code> remains as-is. This is the predicate that represents the mere fact that a set is finite without offering any computational guarantees.</li>
<li>In <code>data/set/finite</code> there is a long list of <code>fintype</code> instances that give ways of computing different set constructions already.</li>
<li>Parallel to that, <code>data/set/finite</code> also has a long list of <code>set.finite</code> constructions. These are mostly formulaic, just applying <code>fintype</code> instances.</li>
<li>Then we can define <code>finite_set</code>, which is a <code>set</code> that is <code>set.finite</code>. This will have all the properties I mentioned in my first posts. Operations on <code>finite_set</code> can be lifted in a mostly  formulaic way from corresponding <code>set.finite</code> constructions, and properties should be mostly liftable from <code>set</code> properties due to the fact a <code>finite_set</code> "is" a <code>set</code>. (Note: in the VM, a <code>finite_set</code> will be essentially computationally irrelevant, similar to <code>set</code>. At most they'll be passed around as zero-argument constructors.)</li>
<li>We can also define <code>finite_type</code>. There are a couple ways this could be defined, but probably the easiest is <code>nonempty (fintype A)</code>. This is a type whose <code>set.univ</code> can be given as a <code>finite_set</code>.</li>
</ul>



<a name="282362991"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bundled%20finite%20sets%20%28and%20avoiding%20decidable%20instances%29/near/282362991" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/bundled.20finite.20sets.20(and.20avoiding.20decidable.20instances).html#282362991">(May 14 2022 at 17:15)</a>:</h4>
<p>+1 for <code>finite_type</code>, I thought <span class="user-mention" data-user-id="214703">@Yury G. Kudryashov</span> mentioned at some point that he was thinking of adding this.</p>



<a name="282363046"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bundled%20finite%20sets%20%28and%20avoiding%20decidable%20instances%29/near/282363046" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/bundled.20finite.20sets.20(and.20avoiding.20decidable.20instances).html#282363046">(May 14 2022 at 17:17)</a>:</h4>
<p>I've started working on a typeclass for countable types (and sorts), see <a href="https://github.com/leanprover-community/mathlib/tree/YK-countable">branch#YK-countable</a>.</p>



<a name="282363053"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bundled%20finite%20sets%20%28and%20avoiding%20decidable%20instances%29/near/282363053" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/bundled.20finite.20sets.20(and.20avoiding.20decidable.20instances).html#282363053">(May 14 2022 at 17:17)</a>:</h4>
<p>It would be nice if someone adopts this branch.</p>



<a name="282363059"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bundled%20finite%20sets%20%28and%20avoiding%20decidable%20instances%29/near/282363059" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/bundled.20finite.20sets.20(and.20avoiding.20decidable.20instances).html#282363059">(May 14 2022 at 17:17)</a>:</h4>
<p>About <code>finite_type</code>: please make it work for <code>Sort*</code>.</p>



<a name="282363115"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bundled%20finite%20sets%20%28and%20avoiding%20decidable%20instances%29/near/282363115" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/bundled.20finite.20sets.20(and.20avoiding.20decidable.20instances).html#282363115">(May 14 2022 at 17:18)</a>:</h4>
<p>E.g., you can define <code>finite_type (α : Sort*) := (ex_equiv_fin : ∃ n : nat, nonempty (α ≃ fin n))</code></p>



<a name="282363142"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bundled%20finite%20sets%20%28and%20avoiding%20decidable%20instances%29/near/282363142" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/bundled.20finite.20sets.20(and.20avoiding.20decidable.20instances).html#282363142">(May 14 2022 at 17:19)</a>:</h4>
<p>With this typeclass, we can have lemmas about finite unions/intersections without dealing separately with unions over proofs of propositions.</p>



<a name="284939283"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bundled%20finite%20sets%20%28and%20avoiding%20decidable%20instances%29/near/284939283" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/bundled.20finite.20sets.20(and.20avoiding.20decidable.20instances).html#284939283">(Jun 03 2022 at 22:20)</a>:</h4>
<p>I was wondering all the ways we have to represent finite (multi)sets in mathlib. Here's what I could think of (and if there are others anyone can think of, I'll add them to the list).</p>
<p>Finite sets:</p>
<ul>
<li><a href="https://leanprover-community.github.io/mathlib_docs/find/finset">docs#finset</a> (a <code>multiset</code> without duplicates)</li>
<li><a href="https://leanprover-community.github.io/mathlib_docs/find/set">docs#set</a> satisfying <a href="https://leanprover-community.github.io/mathlib_docs/find/set.finite">docs#set.finite</a></li>
<li><a href="https://leanprover-community.github.io/mathlib_docs/find/set">docs#set</a> whose coercion has a <a href="https://leanprover-community.github.io/mathlib_docs/find/fintype">docs#fintype</a> instance</li>
<li><a href="https://leanprover-community.github.io/mathlib_docs/find/finsupp">docs#finsupp</a> with <code>fin 2</code> codomain</li>
</ul>
<p>Finite multisets:</p>
<ul>
<li><a href="https://leanprover-community.github.io/mathlib_docs/find/multiset">docs#multiset</a> (a <code>list</code> modulo permutation)</li>
<li><a href="https://leanprover-community.github.io/mathlib_docs/find/finsupp">docs#finsupp</a> with <code>ℕ</code> codomain</li>
</ul>



<a name="284939483"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bundled%20finite%20sets%20%28and%20avoiding%20decidable%20instances%29/near/284939483" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/bundled.20finite.20sets.20(and.20avoiding.20decidable.20instances).html#284939483">(Jun 03 2022 at 22:22)</a>:</h4>
<p>This is a kind of funny and perhaps roundabout way to work with finite sets:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.finsupp.basic</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_zero</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">false</span><span class="o">⟩</span>

<span class="kd">def</span> <span class="n">finset'</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span> <span class="n">finsupp</span> <span class="n">α</span> <span class="kt">Prop</span>

<span class="kd">def</span> <span class="n">finset'.to_set</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">:</span> <span class="n">finset'</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">finsupp.to_fun</span>
</code></pre></div>
<p>If you expand out the definitions it's essentially something Yael suggested earlier, which is a finite set definition that contains both a <code>finset</code> and a <code>set</code> so you can get definitional control over both.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/real-valued.20logic.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/real-valued.20logic.html">real-valued logic</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="220372639"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/real-valued%20logic/near/220372639" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alexandre Rademaker <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/real-valued.20logic.html#220372639">(Dec 18 2020 at 13:39)</a>:</h4>
<p>Can you elaborate on that?</p>



<a name="220373118"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/real-valued%20logic/near/220373118" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/real-valued.20logic.html#220373118">(Dec 18 2020 at 13:44)</a>:</h4>
<p>What kind of an answer do you expect to get if you attempt to "evaluate" (whatever that means) an arbitrary real number computed as a sup?</p>



<a name="220373542"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/real-valued%20logic/near/220373542" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/real-valued.20logic.html#220373542">(Dec 18 2020 at 13:49)</a>:</h4>
<p>Indeed, I think the  fact that they are uniquely suitable for doing logic is intrinsically linked to the fact that they are not computable, because this would otherwise imply that arbitrary formulas can simply be evaluated to a truth value, which is obviously false for nondecidable propositions</p>



<a name="220375813"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/real-valued%20logic/near/220375813" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alexandre Rademaker <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/real-valued.20logic.html#220375813">(Dec 18 2020 at 14:11)</a>:</h4>
<p>Hum... hi Kevin, thank you for your attention, programming languages use some approximation right? Evaluation couldn’t be bound to some approximation?</p>



<a name="220376609"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/real-valued%20logic/near/220376609" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alexandre Rademaker <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/real-valued.20logic.html#220376609">(Dec 18 2020 at 14:19)</a>:</h4>
<p>Hi Mario, once more, maybe a silly question... but what do you mean for nondecidable proposition? 1) A proposition for which we can’t  find the truth assignment (interpretation) that make it true/false or; 2) a proposition for which given a truth assignment (interpretation) we can’t evaluate it’s truth value? </p>
<p>In general (2) is “easy” and (1) can be undecidable, right?  But we may be talking about different things...</p>



<a name="220379789"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/real-valued%20logic/near/220379789" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/real-valued.20logic.html#220379789">(Dec 18 2020 at 14:46)</a>:</h4>
<p>Reals with approximations (some sort of interval / ball arithmetic) that allow one to compute the first few digits of a real number would be cool type to have in mathlib, but mathlibs <code>real</code> is not defined this way. It is defined the mathematical way as quotients of Cauchy sequences of rationals, so even computing the first few terms of this cauchy sequence doesn't actually tell you anything about the real number, as the sequence is only guaranteed to be eventually close to whatever real it converges too.</p>



<a name="220382365"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/real-valued%20logic/near/220382365" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/real-valued.20logic.html#220382365">(Dec 18 2020 at 15:06)</a>:</h4>
<p>Is it possible to spit out the first few digits of a real number inside something like an <code>IO</code> monad?</p>



<a name="220382539"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/real-valued%20logic/near/220382539" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/real-valued.20logic.html#220382539">(Dec 18 2020 at 15:08)</a>:</h4>
<p>It needs to be able to decide whether <code>x = 0.99999998</code> or <code>x = 1.000000001</code> to do that, right?</p>



<a name="220382575"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/real-valued%20logic/near/220382575" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/real-valued.20logic.html#220382575">(Dec 18 2020 at 15:08)</a>:</h4>
<p>So maybe you want to allow it an error margin?</p>



<a name="220382678"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/real-valued%20logic/near/220382678" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/real-valued.20logic.html#220382678">(Dec 18 2020 at 15:09)</a>:</h4>
<p>Apart from that, you need to make sure to bound the rate of convergence of the sequence. It could be the sequence is 0 for the first 9999999999 terms and then jumps to 1.</p>



<a name="220382840"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/real-valued%20logic/near/220382840" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/real-valued.20logic.html#220382840">(Dec 18 2020 at 15:10)</a>:</h4>
<p>Can you represent a real number as a sequence of nested intervals (whose length tends to zero)?</p>



<a name="220382875"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/real-valued%20logic/near/220382875" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/real-valued.20logic.html#220382875">(Dec 18 2020 at 15:10)</a>:</h4>
<p>Brouwer does so IIRC, where the n'th interval has length at most 10^-n.</p>



<a name="220382882"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/real-valued%20logic/near/220382882" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/real-valued.20logic.html#220382882">(Dec 18 2020 at 15:10)</a>:</h4>
<p>Yeah I think that's what Alex is suggesting.</p>



<a name="220392518"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/real-valued%20logic/near/220392518" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/real-valued.20logic.html#220392518">(Dec 18 2020 at 16:19)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/issues/1038">#1038</a> has a few ideas too.</p>



<a name="220416624"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/real-valued%20logic/near/220416624" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/real-valued.20logic.html#220416624">(Dec 18 2020 at 19:18)</a>:</h4>
<p>what you typically do in non-Lean programming when you are fidgeting about precision is instead of using a real number stored as a variable, you use functions like f(epsilon) where f returns an approximation that is correct within epsilon. which is kind of what that PR proposes. it's not really clear to me what problem this is trying to solve, but I think that will be more tractable for exact computation than handling reals as a sequence of things.</p>



<a name="220419370"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/real-valued%20logic/near/220419370" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/real-valued.20logic.html#220419370">(Dec 18 2020 at 19:42)</a>:</h4>
<p>One design question that comes up when doing real computations is whether to work "forward" or "backward" to get the approximation order. With computable reals, you are usually working backward, meaning that each step in the computation is given a target approximation order and gets to pick the approximation order to request of its inputs. By contrast, in interval arithmetic, you generally say that the inputs are given at some approximation order, and then you work forward to find out how much accuracy you can get for each of the intermediate steps; at the end you get some approximation level and if that's not good enough then you redo the whole computation at higher accuracy.</p>



<a name="220419819"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/real-valued%20logic/near/220419819" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/real-valued.20logic.html#220419819">(Dec 18 2020 at 19:46)</a>:</h4>
<p>I think the latter method is more appropriate for actual verified computations, since you can encode the good enough initial approximation order pretty easily as a witness in the script. Most of our numerical computations (such as the calculations of e and pi) are like that</p>



<a name="220420065"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/real-valued%20logic/near/220420065" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/real-valued.20logic.html#220420065">(Dec 18 2020 at 19:48)</a>:</h4>
<p>the nice thing about the former (computable reals) method is that it is more well encapsulated; you actually get something that you can call a "real number", namely a function which given a target approximation will provide a rational which is at least that close to the true value</p>



<a name="220420175"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/real-valued%20logic/near/220420175" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/real-valued.20logic.html#220420175">(Dec 18 2020 at 19:49)</a>:</h4>
<p>you can even mostly use it to replace the <code>real</code> type itself, if you take an appropriate quotient. The quotient kind of destroys your ability to get actual answers to questions though</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/fin.20simp.20normal.20form.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20simp.20normal.20form.html">fin simp normal form</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="206718311"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20simp%20normal%20form/near/206718311" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20simp.20normal.20form.html#206718311">(Aug 12 2020 at 16:36)</a>:</h4>
<p>Is there a preferred form between <code>fin.val</code> and the coercion to <code>nat</code>? I have a <code>simp</code> that gets stuck on <code>i.val = ↑i</code>.</p>



<a name="206718364"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20simp%20normal%20form/near/206718364" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20simp.20normal.20form.html#206718364">(Aug 12 2020 at 16:37)</a>:</h4>
<p><code>i.val</code> is coming from the extensionality lemma <code>fin.eq_of_veq : ∀ {n : ℕ} {i j : fin n}, i.val = j.val → i = j</code></p>



<a name="206718402"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20simp%20normal%20form/near/206718402" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20simp.20normal.20form.html#206718402">(Aug 12 2020 at 16:37)</a>:</h4>
<p>(By the way, it's really cool that <code>show_term {ext}</code> works.)</p>



<a name="206718611"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20simp%20normal%20form/near/206718611" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20simp.20normal.20form.html#206718611">(Aug 12 2020 at 16:39)</a>:</h4>
<p>I've been slowly chipping away at various <code>fin</code> lemmas that should reduce these happenings. In your case (without seeing the whole thing), you might do  <code>obtain ⟨i, hi⟩ := i</code> and that could help.</p>



<a name="206718817"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20simp%20normal%20form/near/206718817" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20simp.20normal.20form.html#206718817">(Aug 12 2020 at 16:41)</a>:</h4>
<p>In this case I can just write <code>simp, refl</code> but I think I shouldn't have to.</p>



<a name="206727348"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20simp%20normal%20form/near/206727348" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Dan Stanescu <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20simp.20normal.20form.html#206727348">(Aug 12 2020 at 17:49)</a>:</h4>
<p>For how useful it is, I think <code>fin</code> needs a little more API. Sometimes even simple results may be a little tricky for a beginner, like this one:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">example</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">≤</span> <span class="n">n</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="k">have</span> <span class="n">h1</span> <span class="o">:=</span> <span class="n">fin</span><span class="bp">.</span><span class="n">le_last</span> <span class="n">i</span><span class="o">,</span>  <span class="c1">-- this doesn&#39;t immediately help</span>
  <span class="n">sorry</span>
<span class="kn">end</span>
</code></pre></div>



<a name="206727556"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20simp%20normal%20form/near/206727556" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20simp.20normal.20form.html#206727556">(Aug 12 2020 at 17:51)</a>:</h4>
<p>I kind of think the coercion from <code>nat</code> to <code>fin</code> just shouldn't exist</p>



<a name="206727914"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20simp%20normal%20form/near/206727914" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20simp.20normal.20form.html#206727914">(Aug 12 2020 at 17:54)</a>:</h4>
<p>I mean the fact that there is a (much more sensible) coercion in the other direction ought to be a red flag</p>



<a name="206728854"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20simp%20normal%20form/near/206728854" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20simp.20normal.20form.html#206728854">(Aug 12 2020 at 18:01)</a>:</h4>
<p>Numeric literals don't use that coercion, right?</p>



<a name="206729722"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20simp%20normal%20form/near/206729722" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20simp.20normal.20form.html#206729722">(Aug 12 2020 at 18:07)</a>:</h4>
<p>To return to the original topic, is it an intentional decision to not have a simp lemma between <code>.val</code> and the coercion in either direction?</p>



<a name="206729811"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20simp%20normal%20form/near/206729811" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20simp.20normal.20form.html#206729811">(Aug 12 2020 at 18:08)</a>:</h4>
<p>I would think it would be better to pick one--my mild preference would be for the coercion</p>



<a name="206731028"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20simp%20normal%20form/near/206731028" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20simp.20normal.20form.html#206731028">(Aug 12 2020 at 18:18)</a>:</h4>
<p>The coercion from nat to fin should not be used, it's not very well behaved</p>



<a name="206731087"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20simp%20normal%20form/near/206731087" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20simp.20normal.20form.html#206731087">(Aug 12 2020 at 18:18)</a>:</h4>
<p>The main times you actually want it are when you really mean <code>zmod</code> instead of <code>fin</code></p>



<a name="206731154"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20simp%20normal%20form/near/206731154" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20simp.20normal.20form.html#206731154">(Aug 12 2020 at 18:19)</a>:</h4>
<p>But we can't really make it not exist because it meets the criteria for <code>nat.cast</code></p>



<a name="206731228"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20simp%20normal%20form/near/206731228" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20simp.20normal.20form.html#206731228">(Aug 12 2020 at 18:19)</a>:</h4>
<p>I guess we could remove <code>+</code> on fin, but how disruptive would that be?</p>



<a name="206731313"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20simp%20normal%20form/near/206731313" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20simp.20normal.20form.html#206731313">(Aug 12 2020 at 18:20)</a>:</h4>
<p>we would lose numeric literals, which I think are used, if not in mathlib then in other projects</p>



<a name="206732196"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20simp%20normal%20form/near/206732196" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20simp.20normal.20form.html#206732196">(Aug 12 2020 at 18:27)</a>:</h4>
<p>I think that <code>fin n</code> has cemented itself as our de facto canonical type with <code>n</code> terms, and this is an argument for its API just being things which are useful for manipulating maps <code>fin n -&gt; X</code> like e.g. some sensible map from <code>fin a \coprod fin b</code> to <code>fin (a + b)</code>, and all the maps used in simplicial homology from <code>fin n</code> to <code>fin (n+1)</code> etc. I think it's a great idea to remove <code>+</code> on <code>fin</code>. I think it was only there as a stop gap because people wanted Z/n and we didn't have <code>zmod</code> yet.</p>



<a name="206737907"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20simp%20normal%20form/near/206737907" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Dan Stanescu <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20simp.20normal.20form.html#206737907">(Aug 12 2020 at 19:14)</a>:</h4>
<p>I need some help to clarify this. Here is a not-so-short example where I felt that I couldn't get away without some coercion. Is anyone willing to take a look and tell me how I could avoid getting into trouble (hence possibly also avoid using the two lemmas at the top)? The two relevant lines have comments ending in <code>-- here?</code></p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">analysis</span><span class="bp">.</span><span class="n">calculus</span><span class="bp">.</span><span class="n">local_extr</span>
<span class="kn">import</span> <span class="n">analysis</span><span class="bp">.</span><span class="n">calculus</span><span class="bp">.</span><span class="n">times_cont_diff</span>
<span class="kn">import</span> <span class="n">analysis</span><span class="bp">.</span><span class="n">calculus</span><span class="bp">.</span><span class="n">iterated_deriv</span>
<span class="kn">import</span> <span class="n">tactic</span> <span class="n">data</span><span class="bp">.</span><span class="n">fin</span>
<span class="kn">open</span> <span class="n">set</span>

<span class="kn">lemma</span> <span class="n">fin_lt_succ</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="o">:</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">2</span><span class="o">))</span> <span class="bp">&lt;</span> <span class="o">(</span><span class="n">i</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">cases</span> <span class="n">i</span> <span class="k">with</span> <span class="n">i</span> <span class="n">hi</span><span class="o">,</span>
  <span class="n">change</span> <span class="o">(</span><span class="bp">_</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">2</span><span class="o">))</span><span class="bp">.</span><span class="n">val</span> <span class="bp">&lt;</span> <span class="o">(</span><span class="bp">_</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">2</span><span class="o">))</span><span class="bp">.</span><span class="n">val</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">fin</span><span class="bp">.</span><span class="n">coe_mk</span><span class="o">,</span> <span class="n">coe_coe</span><span class="o">],</span>
  <span class="n">norm_cast</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">fin</span><span class="bp">.</span><span class="n">coe_val_of_lt</span><span class="o">,</span> <span class="n">fin</span><span class="bp">.</span><span class="n">coe_val_of_lt</span><span class="o">]</span><span class="bp">;</span> <span class="n">omega</span><span class="o">,</span>
<span class="kn">end</span>

<span class="kn">lemma</span> <span class="n">fin_le_last_val</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">))</span> <span class="o">:</span>  <span class="n">i</span> <span class="bp">≤</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
    <span class="k">have</span> <span class="n">j0</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">linarith</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">j0</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">fin</span><span class="bp">.</span><span class="n">coe_val_of_lt</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">j0</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">h3</span> <span class="o">:</span> <span class="n">i</span><span class="bp">.</span><span class="n">val</span> <span class="bp">≤</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">linarith</span> <span class="o">[</span><span class="n">i</span><span class="bp">.</span><span class="n">is_lt</span><span class="o">],</span>
    <span class="n">apply</span> <span class="n">fin</span><span class="bp">.</span><span class="n">le_iff_val_le_val</span><span class="bp">.</span><span class="n">mpr</span><span class="o">,</span>
    <span class="n">rw</span> <span class="err">←</span> <span class="n">j0</span> <span class="n">at</span> <span class="n">h3</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">h3</span><span class="o">,</span>
<span class="kn">end</span>


<span class="kn">lemma</span> <span class="n">exist_points_deriv</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">2</span><span class="o">)</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">hx</span> <span class="o">:</span> <span class="n">strict_mono</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span>
    <span class="bp">∀</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">),</span> <span class="n">continuous_on</span> <span class="n">f</span> <span class="o">(</span> <span class="n">Icc</span> <span class="o">(</span><span class="n">x</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">))</span> <span class="o">)</span> <span class="bp">→</span>
    <span class="o">(</span><span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">x</span> <span class="n">i</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span>  <span class="bp">→</span>
    <span class="bp">∃</span> <span class="o">(</span><span class="n">xp</span> <span class="o">:</span> <span class="n">fin</span><span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">),</span> <span class="n">strict_mono</span> <span class="n">xp</span> <span class="bp">∧</span>
        <span class="bp">∀</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)),</span> <span class="n">xp</span> <span class="n">i</span> <span class="err">∈</span> <span class="o">(</span> <span class="n">Ioo</span> <span class="o">(</span><span class="n">x</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">))</span> <span class="o">)</span> <span class="bp">∧</span> <span class="n">deriv</span> <span class="n">f</span> <span class="o">(</span><span class="n">xp</span> <span class="n">i</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="k">begin</span>
    <span class="n">intros</span> <span class="n">f</span> <span class="n">hf</span> <span class="n">hxi</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">h1</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)),</span> <span class="bp">∃</span> <span class="n">y</span> <span class="err">∈</span> <span class="o">(</span><span class="n">Ioo</span> <span class="o">(</span><span class="n">x</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">(</span><span class="n">i</span><span class="bp">+</span><span class="mi">1</span><span class="o">))),</span> <span class="n">deriv</span> <span class="n">f</span> <span class="n">y</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">,</span>
        <span class="n">intro</span> <span class="n">i</span><span class="o">,</span>
        <span class="n">apply</span> <span class="n">exists_deriv_eq_zero</span><span class="o">,</span>
        <span class="c1">-- show x i &lt; x (i+1)</span>
        <span class="n">exact</span> <span class="n">hx</span> <span class="o">(</span><span class="n">fin_lt_succ</span> <span class="n">n</span> <span class="n">i</span><span class="o">),</span>   <span class="c1">---- what to do here?</span>
        <span class="c1">-- show f continuous on Icc (x i) (x (i+1))</span>
        <span class="k">have</span> <span class="n">h02</span> <span class="o">:</span> <span class="n">Icc</span> <span class="o">(</span><span class="n">x</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">(</span><span class="n">i</span><span class="bp">+</span><span class="mi">1</span><span class="o">))</span> <span class="err">⊆</span> <span class="n">Icc</span> <span class="o">(</span><span class="n">x</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)),</span>
            <span class="n">intros</span> <span class="n">z</span> <span class="n">hz</span><span class="o">,</span>
            <span class="n">cases</span> <span class="n">hz</span> <span class="k">with</span> <span class="n">hz1</span> <span class="n">hz2</span><span class="o">,</span>
            <span class="n">split</span><span class="o">,</span>
            <span class="k">have</span> <span class="n">g3</span> <span class="o">:=</span> <span class="o">(</span><span class="n">strict_mono</span><span class="bp">.</span><span class="n">le_iff_le</span> <span class="n">hx</span><span class="o">)</span><span class="bp">.</span><span class="n">mpr</span> <span class="o">(</span><span class="n">fin</span><span class="bp">.</span><span class="n">zero_le</span> <span class="n">i</span><span class="o">),</span>
            <span class="n">linarith</span><span class="o">,</span>
            <span class="k">have</span> <span class="n">g3</span> <span class="o">:=</span> <span class="o">(</span><span class="n">strict_mono</span><span class="bp">.</span><span class="n">le_iff_le</span> <span class="n">hx</span><span class="o">)</span><span class="bp">.</span><span class="n">mpr</span> <span class="o">(</span><span class="n">fin_le_last_val</span> <span class="n">n</span> <span class="o">(</span><span class="n">i</span><span class="bp">+</span><span class="mi">1</span><span class="o">)),</span> <span class="c1">---- and here?</span>
            <span class="n">linarith</span><span class="o">,</span>
        <span class="n">exact</span> <span class="n">continuous_on</span><span class="bp">.</span><span class="n">mono</span> <span class="n">hf</span> <span class="n">h02</span><span class="o">,</span>
        <span class="c1">-- show f (x i) = f (x (i+1))</span>
        <span class="n">rw</span> <span class="o">[</span><span class="n">hxi</span> <span class="n">i</span><span class="o">,</span> <span class="n">hxi</span> <span class="o">(</span><span class="n">i</span><span class="bp">+</span><span class="mi">1</span><span class="o">)],</span>
        <span class="c1">-- this is just normal Rolle, exists_deriv_eq_zero</span>
    <span class="n">choose</span> <span class="n">xp</span> <span class="n">hxp</span> <span class="kn">using</span> <span class="n">h1</span><span class="o">,</span>
    <span class="n">use</span> <span class="n">xp</span><span class="o">,</span> <span class="n">split</span><span class="o">,</span>
    <span class="n">intros</span> <span class="n">i</span> <span class="n">j</span> <span class="n">hij</span><span class="o">,</span>
    <span class="n">cases</span> <span class="o">(</span><span class="n">hxp</span> <span class="n">i</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span> <span class="k">with</span> <span class="n">hi1</span> <span class="n">hi2</span><span class="o">,</span> <span class="n">cases</span> <span class="o">(</span><span class="n">hxp</span> <span class="n">j</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span> <span class="k">with</span> <span class="n">hj1</span> <span class="n">hj2</span><span class="o">,</span>
    <span class="n">rcases</span> <span class="n">lt_trichotomy</span> <span class="o">((</span><span class="n">i</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">2</span><span class="o">)</span> <span class="o">)</span> <span class="o">(</span><span class="n">j</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">2</span><span class="o">))</span> <span class="k">with</span> <span class="n">h1</span><span class="bp">|</span><span class="n">h2</span><span class="bp">|</span><span class="n">h3</span><span class="o">,</span>
    <span class="c1">-- case (i+1) &lt; j</span>
    <span class="k">have</span> <span class="n">hii1</span> <span class="o">:=</span> <span class="n">hx</span> <span class="n">h1</span><span class="o">,</span> <span class="n">linarith</span><span class="o">,</span>
    <span class="c1">-- case (i+1) = j</span>
    <span class="n">rw</span> <span class="n">h2</span> <span class="n">at</span> <span class="n">hi2</span><span class="o">,</span> <span class="n">linarith</span><span class="o">,</span>
    <span class="c1">-- case j &lt; (i+1) is not possible because i &lt; j</span>
    <span class="n">exfalso</span><span class="o">,</span>
        <span class="k">have</span> <span class="n">h3n</span> <span class="o">:</span> <span class="o">(</span><span class="n">j</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="o">((</span><span class="n">i</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="o">{</span>
            <span class="n">norm_num</span> <span class="n">at</span> <span class="n">h3</span><span class="o">,</span>
            <span class="n">change</span> <span class="o">(</span><span class="n">j</span><span class="bp">.</span><span class="n">val</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">2</span><span class="o">))</span><span class="bp">.</span><span class="n">val</span> <span class="bp">&lt;</span> <span class="o">(</span><span class="n">i</span><span class="bp">.</span><span class="n">val</span><span class="bp">.</span><span class="n">succ</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">2</span><span class="o">))</span><span class="bp">.</span><span class="n">val</span> <span class="n">at</span> <span class="n">h3</span><span class="o">,</span>
            <span class="n">rwa</span> <span class="o">[</span><span class="n">fin</span><span class="bp">.</span><span class="n">coe_val_of_lt</span> <span class="o">(</span><span class="k">show</span> <span class="n">j</span><span class="bp">.</span><span class="mi">1</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">,</span> <span class="k">by</span> <span class="n">linarith</span> <span class="o">[</span><span class="n">j</span><span class="bp">.</span><span class="mi">2</span><span class="o">]),</span>
                <span class="n">fin</span><span class="bp">.</span><span class="n">coe_val_of_lt</span> <span class="o">(</span><span class="k">show</span> <span class="n">i</span><span class="bp">.</span><span class="mi">1</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">,</span> <span class="k">by</span> <span class="n">linarith</span> <span class="o">[</span><span class="n">i</span><span class="bp">.</span><span class="mi">2</span><span class="o">])]</span> <span class="n">at</span> <span class="n">h3</span><span class="o">,</span>
            <span class="o">},</span>
        <span class="k">have</span> <span class="n">gf1</span> <span class="o">:=</span> <span class="n">nat</span><span class="bp">.</span><span class="n">lt_succ_iff</span><span class="bp">.</span><span class="n">mp</span> <span class="n">h3n</span><span class="o">,</span>
        <span class="c1">--strange as it looks, linarith still needs this</span>
        <span class="k">have</span> <span class="n">hijn</span> <span class="o">:</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="o">(</span><span class="n">j</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="n">exact</span> <span class="n">hij</span><span class="o">,</span>
        <span class="n">linarith</span><span class="o">,</span>
    <span class="n">intro</span> <span class="n">i</span><span class="o">,</span> <span class="n">split</span><span class="o">,</span>
    <span class="n">swap</span><span class="o">,</span> <span class="n">exact</span> <span class="o">(</span><span class="n">hxp</span> <span class="n">i</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span><span class="o">,</span>
    <span class="n">split</span><span class="o">,</span>
    <span class="n">cases</span> <span class="o">((</span><span class="n">hxp</span> <span class="n">i</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span><span class="o">)</span> <span class="k">with</span> <span class="n">g01</span> <span class="n">g02</span><span class="o">,</span>
    <span class="k">have</span> <span class="o">:=</span> <span class="o">(</span><span class="n">strict_mono</span><span class="bp">.</span><span class="n">le_iff_le</span> <span class="n">hx</span><span class="o">)</span><span class="bp">.</span><span class="n">mpr</span> <span class="o">(</span><span class="bp">@</span><span class="n">fin</span><span class="bp">.</span><span class="n">zero_le</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">i</span><span class="o">),</span>
    <span class="n">linarith</span><span class="o">,</span>
    <span class="n">cases</span> <span class="o">((</span><span class="n">hxp</span> <span class="n">i</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span><span class="o">)</span> <span class="k">with</span> <span class="n">g01</span> <span class="n">g02</span><span class="o">,</span>
    <span class="k">have</span> <span class="o">:=</span> <span class="o">(</span><span class="n">strict_mono</span><span class="bp">.</span><span class="n">le_iff_le</span> <span class="n">hx</span><span class="o">)</span><span class="bp">.</span><span class="n">mpr</span> <span class="o">(</span><span class="n">fin_le_last_val</span> <span class="n">n</span> <span class="o">(</span><span class="n">i</span><span class="bp">+</span><span class="mi">1</span><span class="o">)),</span>
    <span class="n">linarith</span><span class="o">,</span> <span class="n">done</span>
<span class="kn">end</span>
</code></pre></div>



<a name="206739363"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20simp%20normal%20form/near/206739363" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20simp.20normal.20form.html#206739363">(Aug 12 2020 at 19:28)</a>:</h4>
<p>The first one is a coercion between <code>fin</code>s -- that should be fine. In fact I think we could (and perhaps already did) name the <code>&lt;</code>-preserving maps from fin n to fin (n+1).</p>



<a name="206739438"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20simp%20normal%20form/near/206739438" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20simp.20normal.20form.html#206739438">(Aug 12 2020 at 19:29)</a>:</h4>
<p>I have some fin lemmas written that should help with this. But what's wrong with the first two lemmas? I might just say i.succ instead of i + 1</p>



<a name="206739497"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20simp%20normal%20form/near/206739497" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20simp.20normal.20form.html#206739497">(Aug 12 2020 at 19:29)</a>:</h4>
<p>There's also a lemma about lt_last</p>



<a name="206739547"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20simp%20normal%20form/near/206739547" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20simp.20normal.20form.html#206739547">(Aug 12 2020 at 19:30)</a>:</h4>
<p><code>last</code> is an OK coercion (I mean, I don't mind coercing <code>n</code> to <code>fin (n+1)</code>) but ideally we should have notation for this. Is <code>fin n</code> a complete lattice for n&gt;0?</p>



<a name="206739589"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20simp%20normal%20form/near/206739589" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Dan Stanescu <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20simp.20normal.20form.html#206739589">(Aug 12 2020 at 19:30)</a>:</h4>
<p><span class="user-mention silent" data-user-id="308899">Yakov Pechersky</span> <a href="#narrow/stream/113488-general/topic/fin.20simp.20normal.20form/near/206739497">said</a>:</p>
<blockquote>
<p>There's also a lemma about le_last</p>
</blockquote>
<p>Right, but that doesn't immediately help, see above in this thread.</p>



<a name="206739641"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20simp%20normal%20form/near/206739641" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20simp.20normal.20form.html#206739641">(Aug 12 2020 at 19:30)</a>:</h4>
<p>Ah, I wrote it out but got distracted by my day job. I'll upload it when I can, sorry</p>



<a name="206739645"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20simp%20normal%20form/near/206739645" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20simp.20normal.20form.html#206739645">(Aug 12 2020 at 19:30)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span>  Yes, as I mentioned in the other thread any (nonempty) finite lattice is complete</p>



<a name="206739679"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20simp%20normal%20form/near/206739679" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Dan Stanescu <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20simp.20normal.20form.html#206739679">(Aug 12 2020 at 19:31)</a>:</h4>
<p><span class="user-mention silent" data-user-id="308899">Yakov Pechersky</span> <a href="#narrow/stream/113488-general/topic/fin.20simp.20normal.20form/near/206739641">said</a>:</p>
<blockquote>
<p>Ah, I wrote it out but got distracted by my day job. I'll upload it when I can, sorry</p>
</blockquote>
<p>I do have a proof, but it's just not immediate. Not in the form I need it.</p>



<a name="206739715"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20simp%20normal%20form/near/206739715" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20simp.20normal.20form.html#206739715">(Aug 12 2020 at 19:31)</a>:</h4>
<p>I mean -- is it a lattice? If so, shouldn't we be using <code>\top</code> for the top element of <code>fin (n+1)</code>?</p>



<a name="206739781"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20simp%20normal%20form/near/206739781" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20simp.20normal.20form.html#206739781">(Aug 12 2020 at 19:32)</a>:</h4>
<p>any linear order is a lattice, the operations are <code>min</code> and <code>max</code></p>



<a name="206739810"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20simp%20normal%20form/near/206739810" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20simp.20normal.20form.html#206739810">(Aug 12 2020 at 19:32)</a>:</h4>
<p>sure, that works for me</p>



<a name="206739849"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20simp%20normal%20form/near/206739849" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20simp.20normal.20form.html#206739849">(Aug 12 2020 at 19:32)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="n">failed</span> <span class="n">to</span> <span class="n">synthesize</span> <span class="n">type</span> <span class="n">class</span> <span class="kn">instance</span> <span class="n">for</span>
<span class="err">⊢</span> <span class="n">has_top</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">4</span><span class="o">)</span>
</code></pre></div>



<a name="206739902"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20simp%20normal%20form/near/206739902" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20simp.20normal.20form.html#206739902">(Aug 12 2020 at 19:33)</a>:</h4>
<p>When I said it is a complete lattice, I mean mathematically</p>



<a name="206739916"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20simp%20normal%20form/near/206739916" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20simp.20normal.20form.html#206739916">(Aug 12 2020 at 19:33)</a>:</h4>
<p>the instance isn't registered</p>



<a name="206740034"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20simp%20normal%20form/near/206740034" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20simp.20normal.20form.html#206740034">(Aug 12 2020 at 19:34)</a>:</h4>
<p>It is a bit sad that we use <code>\top</code> instead of a variant on <code>n</code> though (which is definitely what the books will use)</p>



<a name="206740058"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20simp%20normal%20form/near/206740058" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20simp.20normal.20form.html#206740058">(Aug 12 2020 at 19:34)</a>:</h4>
<p>In my model of <code>fin n</code>, <code>fin_lt_succ</code> should be the statement that <code>delta^{n,0} x &lt; delta^{n,n} x</code></p>



<a name="206740130"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20simp%20normal%20form/near/206740130" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20simp.20normal.20form.html#206740130">(Aug 12 2020 at 19:35)</a>:</h4>
<p>where <code>delta^{n+1,i}</code> is the map from fin n to fin (n+1) which misses i</p>



<a name="206740279"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20simp%20normal%20form/near/206740279" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20simp.20normal.20form.html#206740279">(Aug 12 2020 at 19:36)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113488-general/topic/fin.20simp.20normal.20form/near/206740034">said</a>:</p>
<blockquote>
<p>It is a bit sad that we use <code>\top</code> instead of a variant on <code>n</code> though (which is definitely what the books will use)</p>
</blockquote>
<p>this is fixed if we write <code>T : nat</code> and <code>fin (T + 1)</code></p>



<a name="206740283"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20simp%20normal%20form/near/206740283" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20simp.20normal.20form.html#206740283">(Aug 12 2020 at 19:36)</a>:</h4>
<p>What I want to argue is that all the mess which people are getting into using + (and note that it's just things like +1, it's not + in general) could perhaps be fixed if people were to just treat these things as finite total orders and use the standard convention for maps between them and their API.</p>



<a name="206740398"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20simp%20normal%20form/near/206740398" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20simp.20normal.20form.html#206740398">(Aug 12 2020 at 19:37)</a>:</h4>
<p>then the first lemma would be in the API and the second would just be le_top.</p>



<a name="206740413"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20simp%20normal%20form/near/206740413" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20simp.20normal.20form.html#206740413">(Aug 12 2020 at 19:37)</a>:</h4>
<p>The trouble is if the coercion exists then people will use it, either because they don't know better or unintentionally even if they do</p>



<a name="206740508"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20simp%20normal%20form/near/206740508" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20simp.20normal.20form.html#206740508">(Aug 12 2020 at 19:38)</a>:</h4>
<p>If we remove <code>add</code> from <code>fin</code> then the coercion goes too, right?</p>



<a name="206740521"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20simp%20normal%20form/near/206740521" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20simp.20normal.20form.html#206740521">(Aug 12 2020 at 19:38)</a>:</h4>
<p>If you're "in the <code>fin</code> zone" and acutely aware of this issue it's not hard to avoid it</p>



<a name="206740547"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20simp%20normal%20form/near/206740547" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20simp.20normal.20form.html#206740547">(Aug 12 2020 at 19:38)</a>:</h4>
<p>Yes but that will apparently break numeric literals too</p>



<a name="206740564"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20simp%20normal%20form/near/206740564" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20simp.20normal.20form.html#206740564">(Aug 12 2020 at 19:38)</a>:</h4>
<p>at least all the ones starting from 2</p>



<a name="206740618"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20simp%20normal%20form/near/206740618" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20simp.20normal.20form.html#206740618">(Aug 12 2020 at 19:39)</a>:</h4>
<p>Well maybe we should be encouraging people to think about <code>fin n</code> more like this</p>



<a name="206740620"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20simp%20normal%20form/near/206740620" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20simp.20normal.20form.html#206740620">(Aug 12 2020 at 19:39)</a>:</h4>
<p>I never count that high anyway</p>



<a name="206740649"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20simp%20normal%20form/near/206740649" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Dan Stanescu <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20simp.20normal.20form.html#206740649">(Aug 12 2020 at 19:39)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/113488-general/topic/fin.20simp.20normal.20form/near/206740521">said</a>:</p>
<blockquote>
<p>If you're "in the <code>fin</code> zone" and acutely aware of this issue it's not hard to avoid it</p>
</blockquote>
<p>You mean <code>cast_succ</code> and the like?</p>



<a name="206740659"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20simp%20normal%20form/near/206740659" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20simp.20normal.20form.html#206740659">(Aug 12 2020 at 19:39)</a>:</h4>
<p>Yes, I rarely get to 2</p>



<a name="206740831"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20simp%20normal%20form/near/206740831" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20simp.20normal.20form.html#206740831">(Aug 12 2020 at 19:40)</a>:</h4>
<p>You have to be alert to the possibility of Lean interpreting what you write as a coercion, and then use all the methods documented at the top of <code>data.fin</code> to avoid it happening.</p>



<a name="206741014"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20simp%20normal%20form/near/206741014" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20simp.20normal.20form.html#206741014">(Aug 12 2020 at 19:42)</a>:</h4>
<p>I mean the other option is to add much better support for reasoning about the coercions somehow.</p>



<a name="206741050"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20simp%20normal%20form/near/206741050" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20simp.20normal.20form.html#206741050">(Aug 12 2020 at 19:42)</a>:</h4>
<p>actually I just looked at some of my papers and I get to 2 quite a lot, but I rarely get to 3</p>



<a name="206741089"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20simp%20normal%20form/near/206741089" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20simp.20normal.20form.html#206741089">(Aug 12 2020 at 19:43)</a>:</h4>
<p><a href="https://arxiv.org/abs/0810.2106">https://arxiv.org/abs/0810.2106</a></p>



<a name="206741103"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20simp%20normal%20form/near/206741103" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20simp.20normal.20form.html#206741103">(Aug 12 2020 at 19:43)</a>:</h4>
<p>Q: What does a number theorist call a number greater than 2?</p>



<a name="206741141"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20simp%20normal%20form/near/206741141" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20simp.20normal.20form.html#206741141">(Aug 12 2020 at 19:43)</a>:</h4>
<p>I give an example which shows the theory is nonempty, which uses sqrt(29) and 3, but other than that it's all 0,1,2.</p>



<a name="206741155"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20simp%20normal%20form/near/206741155" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20simp.20normal.20form.html#206741155">(Aug 12 2020 at 19:43)</a>:</h4>
<p>"many"</p>



<a name="206741160"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20simp%20normal%20form/near/206741160" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Dan Stanescu <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20simp.20normal.20form.html#206741160">(Aug 12 2020 at 19:43)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113488-general/topic/fin.20simp.20normal.20form/near/206741050">said</a>:</p>
<blockquote>
<p>actually I just looked at some of my papers and I get to 2 quite a lot, but I rarely get to 3</p>
</blockquote>
<p>I did get to 2 but that was it, not 3.</p>



<a name="206741161"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20simp%20normal%20form/near/206741161" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20simp.20normal.20form.html#206741161">(Aug 12 2020 at 19:43)</a>:</h4>
<p>A: Odd</p>



<a name="206745152"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20simp%20normal%20form/near/206745152" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph Myers <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20simp.20normal.20form.html#206745152">(Aug 12 2020 at 20:14)</a>:</h4>
<p>I think of the coercion from <code>nat</code> to <code>fin</code> as like all the cases where a partial function is given some default value to make it a total function: I can convert a <code>nat</code> value to <code>fin (n + 1)</code> whenever convenient and supply the proof that the <code>nat</code> value was within range for the conversion some time later when I need to use that fact. On the other hand, the proof I did using that approach (for an olympiad problem about a 2019 × 2019 grid, which I represented as <code>fin 2019 × fin 2019</code>) ended up as over 3000 lines of Lean for a problem that's pretty easy mathematically, so this doesn't provide much evidence that that approach is useful. (With hindsight I suspect it would have been easier to work with <code>ℕ × ℕ</code> or <code>ℤ × ℤ</code> and avoid <code>fin 2019</code> completely.)</p>



<a name="206745588"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20simp%20normal%20form/near/206745588" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20simp.20normal.20form.html#206745588">(Aug 12 2020 at 20:17)</a>:</h4>
<p>When I need to do that sort of thing, I will use a local notation like <code>#n</code> that calls <code>fin.mk</code> with <code>norm_num</code> or something producing the proof</p>



<a name="206745652"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20simp%20normal%20form/near/206745652" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20simp.20normal.20form.html#206745652">(Aug 12 2020 at 20:17)</a>:</h4>
<p>Right, this is similar to <code>nat</code> subtraction</p>



<a name="206745949"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20simp%20normal%20form/near/206745949" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20simp.20normal.20form.html#206745949">(Aug 12 2020 at 20:19)</a>:</h4>
<p>My view is that you're generally in a better position to explain why the <code>fin</code> value is sensible (i.e. has the expected property, in this case that its <code>val</code> equals the thing you put in) when you build it than when you want to reason about it later on. But this is to an extent contingent on how good our automation is at proving obvious facts.</p>



<a name="206746075"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20simp%20normal%20form/near/206746075" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20simp.20normal.20form.html#206746075">(Aug 12 2020 at 20:20)</a>:</h4>
<p>The nice thing about the local notation is that you can tailor the proof method to the use case</p>



<a name="206746351"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20simp%20normal%20form/near/206746351" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph Myers <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20simp.20normal.20form.html#206746351">(Aug 12 2020 at 20:22)</a>:</h4>
<p>The values being converted weren't constants. The proofs typically ended up being <code>linarith</code>, but after some preparation (e.g. various parts of the argument involved cases based on parity) - or there was a definition involving conversion to <code>fin</code>, that was only used in proofs where the conversion was legitimate. Type class inference became happier once I switched from literal <code>fin 2019</code> to more general <code>fin (n + 1)</code>, I think before that it kept having to do kernel reduction to show 2019 is <code>succ 2018</code> in order to deduce <code>has_zero (fin 2019)</code> and similar.</p>



<a name="206746526"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20simp%20normal%20form/near/206746526" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20simp.20normal.20form.html#206746526">(Aug 12 2020 at 20:23)</a>:</h4>
<p>Didn't we once discover there's a special case for treating <code>nat</code> <code>+</code> specifically in instance search?</p>



<a name="206746897"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20simp%20normal%20form/near/206746897" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph Myers <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20simp.20normal.20form.html#206746897">(Aug 12 2020 at 20:26)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">example</span> <span class="o">:</span> <span class="n">has_zero</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">1024</span><span class="o">)</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">apply_instance</span> <span class="c1">-- succeeds</span>
<span class="kn">example</span> <span class="o">:</span> <span class="n">has_zero</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">1025</span><span class="o">)</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">apply_instance</span> <span class="c1">-- fails</span>
</code></pre></div>



<a name="206747002"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20simp%20normal%20form/near/206747002" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20simp.20normal.20form.html#206747002">(Aug 12 2020 at 20:27)</a>:</h4>
<p><code>local notation `2019` := 2018 + 1</code> <span aria-label="upside down" class="emoji emoji-1f643" role="img" title="upside down">:upside_down:</span></p>



<a name="206754142"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20simp%20normal%20form/near/206754142" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20simp.20normal.20form.html#206754142">(Aug 12 2020 at 21:24)</a>:</h4>
<p>It's a bit0 and bit1 issue?</p>



<a name="206763616"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20simp%20normal%20form/near/206763616" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20simp.20normal.20form.html#206763616">(Aug 12 2020 at 23:06)</a>:</h4>
<p>Some work: </p>
<div class="codehilite"><pre><span></span><code><span class="kn">lemma</span> <span class="n">fin</span><span class="bp">.</span><span class="n">coe_succ_eq_succ</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="o">((</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">=</span> <span class="n">i</span><span class="bp">.</span><span class="n">succ</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">fin</span><span class="bp">.</span><span class="n">eq_iff_veq</span><span class="o">,</span> <span class="n">fin</span><span class="bp">.</span><span class="n">succ_val</span><span class="o">,</span> <span class="n">coe_coe</span><span class="o">],</span>
  <span class="n">norm_cast</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">fin</span><span class="bp">.</span><span class="n">coe_coe_of_lt</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">add_lt_add_right</span> <span class="n">i</span><span class="bp">.</span><span class="n">is_lt</span> <span class="mi">1</span>
<span class="kn">end</span>

<span class="kn">lemma</span> <span class="n">fin</span><span class="bp">.</span><span class="n">coe_eq_cast_succ</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="bp">=</span> <span class="n">i</span><span class="bp">.</span><span class="n">cast_succ</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">fin</span><span class="bp">.</span><span class="n">cast_succ</span><span class="o">,</span> <span class="n">fin</span><span class="bp">.</span><span class="n">cast_add</span><span class="o">,</span> <span class="n">fin</span><span class="bp">.</span><span class="n">cast_le</span><span class="o">,</span> <span class="n">fin</span><span class="bp">.</span><span class="n">cast_lt</span><span class="o">],</span>
  <span class="k">obtain</span> <span class="bp">⟨</span><span class="n">i</span><span class="o">,</span> <span class="n">hi</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">i</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">fin</span><span class="bp">.</span><span class="n">eq_iff_veq</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">:</span> <span class="n">i</span><span class="bp">.</span><span class="n">succ</span> <span class="bp">=</span> <span class="n">i</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">rfl</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">this</span><span class="o">],</span>
  <span class="n">apply</span> <span class="n">fin</span><span class="bp">.</span><span class="n">coe_val_of_lt</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">nat</span><span class="bp">.</span><span class="n">lt</span><span class="bp">.</span><span class="n">step</span> <span class="n">hi</span><span class="o">,</span>
<span class="kn">end</span>

<span class="kn">lemma</span> <span class="n">fin</span><span class="bp">.</span><span class="n">val_coe_eq_self</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span><span class="bp">.</span><span class="n">val</span> <span class="bp">=</span> <span class="n">i</span><span class="bp">.</span><span class="n">val</span> <span class="o">:=</span>
<span class="k">by</span> <span class="o">{</span> <span class="n">rw</span> <span class="n">fin</span><span class="bp">.</span><span class="n">coe_eq_cast_succ</span><span class="o">,</span> <span class="n">refl</span> <span class="o">}</span>
</code></pre></div>



<a name="206763655"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20simp%20normal%20form/near/206763655" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20simp.20normal.20form.html#206763655">(Aug 12 2020 at 23:06)</a>:</h4>
<p>Could those be in the direction of simp normal form?</p>



<a name="206765129"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20simp%20normal%20form/near/206765129" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20simp.20normal.20form.html#206765129">(Aug 12 2020 at 23:25)</a>:</h4>
<p>If you inspect my original messages closely you will find they have nothing to do with this coercion <span aria-label="upside down" class="emoji emoji-1f643" role="img" title="upside down">:upside_down:</span></p>



<a name="206768793"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20simp%20normal%20form/near/206768793" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20simp.20normal.20form.html#206768793">(Aug 13 2020 at 00:12)</a>:</h4>
<p>Ah, but could be useful for the rolle theorem one</p>



<a name="206768836"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20simp%20normal%20form/near/206768836" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20simp.20normal.20form.html#206768836">(Aug 13 2020 at 00:13)</a>:</h4>
<p>There are other ones cooking regarding addition of one</p>



<a name="206769061"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20simp%20normal%20form/near/206769061" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Dan Stanescu <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20simp.20normal.20form.html#206769061">(Aug 13 2020 at 00:17)</a>:</h4>
<p><span class="user-mention silent" data-user-id="308899">Yakov Pechersky</span> <a href="#narrow/stream/113488-general/topic/fin.20simp.20normal.20form/near/206768793">said</a>:</p>
<blockquote>
<p>Ah, but could be useful for the rolle theorem one</p>
</blockquote>
<p>Thanks Yakov. I do have all I need there. What I meant was that some of these results might be nice in the <code>fin</code> API in <code>mathlib</code>.</p>



<a name="206769279"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20simp%20normal%20form/near/206769279" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20simp.20normal.20form.html#206769279">(Aug 13 2020 at 00:21)</a>:</h4>
<p>Sure thing. A general question then is whether the lemmas above should be simp lemmas.</p>



<a name="206786092"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20simp%20normal%20form/near/206786092" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20simp.20normal.20form.html#206786092">(Aug 13 2020 at 07:04)</a>:</h4>
<p>I think that addition of 1 on <code>fin</code> should be avoided to the extent that anything simplifying it to the sensible functions which have been set up us a great idea. On the other hand I think that users should think very hard before using addition in any way. There are functions for adding one and adding things bigger than one should be undefined unless you're adding a and moving from fin n to fin (n+a).</p>



<a name="206806963"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20simp%20normal%20form/near/206806963" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Dan Stanescu <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20simp.20normal.20form.html#206806963">(Aug 13 2020 at 12:10)</a>:</h4>
<p>I agree, but let me add that heavy use cases (like Yakov's and, admittedly to a lesser extent, mine) suggest that the functions that are available in <code>data.fin</code> are not  enough of an API yet. So I strongly advocate that this API be augmented.<br>
This discussion might be veering away from Reid's initial post...</p>



<a name="206919123"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20simp%20normal%20form/near/206919123" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20simp.20normal.20form.html#206919123">(Aug 14 2020 at 11:18)</a>:</h4>
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span> I would prefer to have the coercion as simp normal form.</p>



<a name="207742338"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20simp%20normal%20form/near/207742338" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20simp.20normal.20form.html#207742338">(Aug 22 2020 at 21:09)</a>:</h4>
<p>I'm dealing with <code>fin 3 → α</code> and <code>fin 4 → α</code>. While the most natural way to write arguments is <code>(f : fin 3 → α) 1</code>, <code>fin_cases</code> generates cases <code>⟨0, _⟩</code> etc, and <code>simp</code> doesn't convert in either direction.</p>



<a name="207750237"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20simp%20normal%20form/near/207750237" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20simp.20normal.20form.html#207750237">(Aug 23 2020 at 01:30)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/issues/3769">#3769</a> will simp to 0 and 1 iirc</p>



<a name="207750868"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20simp%20normal%20form/near/207750868" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20simp.20normal.20form.html#207750868">(Aug 23 2020 at 01:53)</a>:</h4>
<p>Which lemma in <a href="https://github.com/leanprover-community/mathlib/issues/3769">#3769</a>?</p>



<a name="207750923"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20simp%20normal%20form/near/207750923" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20simp.20normal.20form.html#207750923">(Aug 23 2020 at 01:54)</a>:</h4>
<p>I see that it'll work with <code>0</code> and <code>1</code> but I'm interested in <code>2</code> and <code>3</code> as well. Something like <code>mk_bit0</code>/<code>mk_bit1</code>?</p>



<a name="207752017"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20simp%20normal%20form/near/207752017" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20simp.20normal.20form.html#207752017">(Aug 23 2020 at 02:31)</a>:</h4>
<p>It's mk_zero_eq_zero I think</p>



<a name="207752058"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20simp%20normal%20form/near/207752058" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20simp.20normal.20form.html#207752058">(Aug 23 2020 at 02:32)</a>:</h4>
<p>I've played around with bit0 and bit1 lemmas but it gets complicated with the modular math</p>



<a name="207752068"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20simp%20normal%20form/near/207752068" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20simp.20normal.20form.html#207752068">(Aug 23 2020 at 02:32)</a>:</h4>
<p>And guessing which fin n you're working in.</p>



<a name="207753986"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20simp%20normal%20form/near/207753986" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20simp.20normal.20form.html#207753986">(Aug 23 2020 at 03:32)</a>:</h4>
<p>Works for me:</p>
<div class="codehilite"><pre><span></span><code><span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">mk_zero</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="bp">⟨</span><span class="mi">0</span><span class="o">,</span> <span class="n">n</span><span class="bp">.</span><span class="n">zero_lt_succ</span><span class="bp">⟩</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">mk_one</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">hn</span> <span class="o">:</span> <span class="mi">1</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="bp">⟨</span><span class="mi">1</span><span class="o">,</span> <span class="n">hn</span><span class="bp">⟩</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="n">eq_of_veq</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">mod_eq_of_lt</span> <span class="n">hn</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">mk_bit0</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">bit0</span> <span class="n">m</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">⟨_</span><span class="o">,</span> <span class="n">h</span><span class="bp">⟩</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="n">bit0</span> <span class="bp">⟨</span><span class="n">m</span><span class="o">,</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">le_add_right</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">)</span><span class="bp">.</span><span class="n">trans_lt</span> <span class="n">h</span><span class="bp">⟩</span> <span class="o">:=</span>
<span class="n">eq_of_veq</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">mod_eq_of_lt</span> <span class="n">h</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">mk_bit1</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">bit1</span> <span class="n">m</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">⟨</span><span class="n">bit1</span> <span class="n">m</span><span class="o">,</span> <span class="n">h</span><span class="bp">⟩</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="bp">=</span> <span class="n">bit1</span> <span class="bp">⟨</span><span class="n">m</span><span class="o">,</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">le_add_right</span> <span class="n">m</span> <span class="n">m</span><span class="o">)</span><span class="bp">.</span><span class="n">trans_lt</span>
    <span class="o">((</span><span class="n">m</span> <span class="bp">+</span> <span class="n">m</span><span class="o">)</span><span class="bp">.</span><span class="n">lt_succ_self</span><span class="bp">.</span><span class="n">trans</span> <span class="n">h</span><span class="o">)</span><span class="bp">⟩</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">ext</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">bit1</span><span class="o">,</span> <span class="n">bit0</span><span class="o">]</span> <span class="n">at</span> <span class="n">h</span> <span class="err">⊢</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">val_add</span><span class="o">,</span> <span class="n">one_val</span><span class="o">,</span> <span class="err">←</span> <span class="n">nat</span><span class="bp">.</span><span class="n">add_mod</span><span class="o">,</span> <span class="n">nat</span><span class="bp">.</span><span class="n">mod_eq_of_lt</span> <span class="n">h</span><span class="o">]</span>
<span class="kn">end</span>
</code></pre></div>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
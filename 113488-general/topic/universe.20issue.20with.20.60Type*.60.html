---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/universe.20issue.20with.20.60Type*.60.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universe.20issue.20with.20.60Type*.60.html">universe issue with `Type*`</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="228074514"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universe%20issue%20with%20%60Type%2A%60/near/228074514" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universe.20issue.20with.20.60Type*.60.html#228074514">(Feb 27 2021 at 18:26)</a>:</h4>
<p>There was a time when I was scared of <code>Type*</code>, preferring to roll my own universes. However there were changes, particularly the advent of <code>{A B C : Type*}</code>, and I switched back. But here's something which I think is odd:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">linear_algebra.basis</span>

<span class="kn">open</span> <span class="n">submodule</span>

<span class="n">open_locale</span> <span class="n">big_operators</span> <span class="n">classical</span>

<span class="kn">open</span> <span class="n">finsupp</span>

<span class="kd">universe</span> <span class="n">u</span>

<span class="kd">set_option</span> <span class="n">pp.universes</span> <span class="n">true</span>

<span class="kd">lemma</span> <span class="n">submodule.span_as_sum</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span>
  <span class="o">{</span><span class="n">m</span> <span class="o">:</span> <span class="n">M</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">M</span><span class="o">}</span> <span class="o">(</span><span class="n">hm</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">∈</span> <span class="n">submodule.span</span> <span class="n">R</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">c</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→₀</span> <span class="n">R</span><span class="o">,</span> <span class="o">(</span><span class="n">c.support</span> <span class="o">:</span> <span class="n">set</span> <span class="n">M</span><span class="o">)</span> <span class="bp">⊆</span> <span class="n">s</span> <span class="bp">∧</span> <span class="o">(</span><span class="n">c.sum</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="o">(</span><span class="n">smul_add_hom</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span><span class="bp">.</span><span class="n">flip</span> <span class="n">i</span><span class="o">))</span> <span class="bp">=</span> <span class="n">m</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">refine</span> <span class="n">span_induction</span> <span class="n">hm</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span> <span class="n">_</span><span class="o">)</span> <span class="o">⟨</span><span class="mi">0</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">⟩</span> <span class="n">_</span> <span class="n">_</span><span class="bp">;</span> <span class="n">clear</span> <span class="n">hm</span> <span class="n">m</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">refine</span> <span class="o">⟨</span><span class="n">finsupp.single</span> <span class="n">x</span> <span class="mi">1</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">y</span> <span class="n">hy</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">⟩,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">finset.mem_coe</span><span class="o">,</span> <span class="n">mem_support_single</span><span class="o">]</span> <span class="n">at</span> <span class="n">hy</span><span class="o">,</span>
    <span class="n">rwa</span> <span class="n">hy.1</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rintros</span> <span class="n">x</span> <span class="n">y</span> <span class="o">⟨</span><span class="n">c</span><span class="o">,</span> <span class="n">hc</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">d</span><span class="o">,</span> <span class="n">hd</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span>
    <span class="n">refine</span> <span class="o">⟨</span><span class="n">c</span> <span class="bp">+</span> <span class="n">d</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">⟩,</span>
    <span class="n">refine</span> <span class="n">set.subset.trans</span> <span class="n">_</span> <span class="o">(</span><span class="n">set.union_subset</span> <span class="n">hc</span> <span class="n">hd</span><span class="o">),</span>
    <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">finset.coe_union</span><span class="o">,</span> <span class="n">finset.coe_subset</span><span class="o">],</span>
    <span class="n">exact</span> <span class="n">support_add</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rintros</span> <span class="n">r</span> <span class="n">m</span> <span class="o">⟨</span><span class="n">c</span><span class="o">,</span> <span class="n">hc</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span>
    <span class="n">refine</span> <span class="o">⟨</span><span class="n">r</span> <span class="bp">•</span> <span class="n">c</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span> <span class="n">hc</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">finset.mem_coe</span><span class="o">,</span> <span class="n">mem_support_iff</span><span class="o">]</span> <span class="n">at</span> <span class="n">hx</span> <span class="bp">⊢</span><span class="o">,</span>
      <span class="n">rw</span> <span class="o">[</span><span class="n">finsupp.coe_smul</span><span class="o">]</span> <span class="n">at</span> <span class="n">hx</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">right_ne_zero_of_mul</span> <span class="n">hx</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="n">sum_smul_index'</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">M</span><span class="o">),</span> <span class="n">_</span><span class="o">),</span>
      <span class="o">{</span> <span class="n">convert</span> <span class="o">(</span><span class="n">add_monoid_hom.map_finsupp_sum</span> <span class="o">(</span><span class="n">smul_add_hom</span> <span class="n">R</span> <span class="n">M</span> <span class="n">r</span><span class="o">)</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="o">,</span>
        <span class="n">ext</span> <span class="n">m</span> <span class="n">s</span><span class="o">,</span>
        <span class="n">simp</span> <span class="o">[</span><span class="n">mul_smul</span> <span class="n">r</span> <span class="n">s</span> <span class="n">m</span><span class="o">]</span> <span class="o">},</span>
      <span class="o">{</span> <span class="n">exact</span> <span class="o">(((</span><span class="n">smul_add_hom</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span><span class="bp">.</span><span class="n">flip</span><span class="o">)</span> <span class="n">m</span><span class="o">)</span><span class="bp">.</span><span class="n">map_zero</span> <span class="o">}</span> <span class="o">}</span> <span class="o">}</span>
<span class="kd">end</span>

<span class="k">#check</span> <span class="bp">@</span><span class="n">submodule.span_as_sum</span>
<span class="c">/-</span><span class="cm"></span>
<span class="cm">submodule.span_as_sum.{u_1 u_2 u_3} :</span>
<span class="cm">  ∀ {R : Type u_1} {M : Type (max u_2 u_3)} [_inst_1 : semiring.{u_1} R] [_inst_2 : add_comm_group.{(max u_2 u_3)} M]</span>
<span class="cm">  [_inst_3 : semimodule.{u_1 (max u_2 u_3)} R M] {m : M} {s : set.{(max u_2 u_3)} M},</span>
<span class="cm">    m ∈ span.{u_1 (max u_2 u_3)} R s →</span>
<span class="cm">    (∃ (c : M →₀ R),</span>
<span class="cm">       ↑(c.support) ⊆ s ∧ c.sum (λ (i : M), ⇑(⇑((smul_add_hom.{u_1 (max u_2 u_3)} R M).flip) i)) = m)</span>
<span class="cm">-/</span>
</code></pre></div>
<p>I have R and M in two different universes, but somehow M's universe has become the max of two unspecified universes which I can't figure out the origin of. Paging through the proof I didn't spot any occurrence of <code>u_2</code> or <code>u_3</code> outside <code>max u_2 u_3</code>. Furthermore if I change <code>{M : Type*}</code> to <code>{M : Type u}</code> then the proof compiles just the same and the universes in the goal are what I would expect -- one for R and one for M and that's it. </p>
<p>What's going on?</p>



<a name="228074938"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universe%20issue%20with%20%60Type%2A%60/near/228074938" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universe.20issue.20with.20.60Type*.60.html#228074938">(Feb 27 2021 at 18:34)</a>:</h4>
<p>Oh it's not even the proof -- if I sorry the proof I still observe the same phenomenon.</p>



<a name="228075818"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universe%20issue%20with%20%60Type%2A%60/near/228075818" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universe.20issue.20with.20.60Type*.60.html#228075818">(Feb 27 2021 at 18:51)</a>:</h4>
<p>If I change <code>(λ i, (smul_add_hom R M).flip i)</code> to <code>(λ m r, r • m)</code> the issue disappears</p>



<a name="228075886"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universe%20issue%20with%20%60Type%2A%60/near/228075886" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universe.20issue.20with.20.60Type*.60.html#228075886">(Feb 27 2021 at 18:52)</a>:</h4>
<p>Got it -- it's <code>add_monoid_hom.flip</code>.</p>



<a name="228076072"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universe%20issue%20with%20%60Type%2A%60/near/228076072" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universe.20issue.20with.20.60Type*.60.html#228076072">(Feb 27 2021 at 18:56)</a>:</h4>
<p>I am still confused by this.  Is there an explicit argument that <code>smul_add_hom</code> wants that is not there, then?</p>



<a name="228076089"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universe%20issue%20with%20%60Type%2A%60/near/228076089" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universe.20issue.20with.20.60Type*.60.html#228076089">(Feb 27 2021 at 18:56)</a>:</h4>
<p>Should there be an extra <code>R</code> somewhere?</p>



<a name="228076524"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universe%20issue%20with%20%60Type%2A%60/near/228076524" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universe.20issue.20with.20.60Type*.60.html#228076524">(Feb 27 2021 at 19:05)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/add_monoid_hom.flip">docs#add_monoid_hom.flip</a> for reference</p>



<a name="228076528"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universe%20issue%20with%20%60Type%2A%60/near/228076528" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universe.20issue.20with.20.60Type*.60.html#228076528">(Feb 27 2021 at 19:05)</a>:</h4>
<p>OK so here is some behaviour I find counterintuitive:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.module.basic</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span>

<span class="kd">def</span> <span class="n">a</span> <span class="o">:</span> <span class="n">R</span> <span class="bp">→+</span> <span class="n">M</span> <span class="bp">→+</span> <span class="n">M</span> <span class="o">:=</span> <span class="n">smul_add_hom</span> <span class="n">R</span> <span class="n">M</span>

<span class="k">#check</span> <span class="bp">@</span><span class="n">a</span> <span class="c1">-- Π {R : Type u_3} {M : Type u_4}</span>

<span class="kd">def</span> <span class="n">b</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span>
 <span class="o">:</span> <span class="n">M</span> <span class="bp">→+</span> <span class="n">R</span> <span class="bp">→+</span> <span class="n">M</span> <span class="o">:=</span> <span class="o">(</span><span class="n">smul_add_hom</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span><span class="bp">.</span><span class="n">flip</span>

<span class="k">#check</span> <span class="bp">@</span><span class="n">b</span> <span class="c1">-- Π {R : Type u_3} {M : Type (max u_4 u_5)}  ...</span>

<span class="kd">def</span> <span class="n">c</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→+</span> <span class="n">R</span> <span class="bp">→+</span> <span class="n">M</span> <span class="o">:=</span> <span class="o">(</span><span class="n">smul_add_hom</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span><span class="bp">.</span><span class="n">flip</span>

<span class="k">#check</span> <span class="bp">@</span><span class="n">c</span> <span class="c1">-- Π {R : Type u_3} {M : Type u_4} ...</span>

<span class="kd">def</span> <span class="n">d</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→+</span> <span class="n">R</span> <span class="bp">→+</span> <span class="n">M</span> <span class="o">:=</span> <span class="n">a.flip</span>
<span class="c">/-</span><span class="cm"></span>
<span class="cm">type mismatch at application</span>
<span class="cm">  a.flip</span>
<span class="cm">term</span>
<span class="cm">  a</span>
<span class="cm">has type</span>
<span class="cm">  ?m_1 →+ ?m_2 →+ ?m_2 : Type (max ? ?)</span>
<span class="cm">but is expected to have type</span>
<span class="cm">  ?m_1 →+ ?m_2 →+ ?m_3 : Type (max ? ? ?)</span>
<span class="cm">Additional information:</span>
<span class="cm">/home/buzzard/active-lean-projects/mathlib/scratch/scratch5.lean: context: switched to simple application elaboration procedure because failed to use expected type to elaborate it, error message</span>
<span class="cm">  type mismatch at application</span>
<span class="cm">    a.flip</span>
<span class="cm">  term</span>
<span class="cm">    a</span>
<span class="cm">  has type</span>
<span class="cm">    ?m_1 →+ ?m_2 →+ ?m_2 : Type (max ? ?)</span>
<span class="cm">  but is expected to have type</span>
<span class="cm">    ?m_1 →+ ?m_2 →+ ?m_3 : Type (max ? ? ?)</span>
<span class="cm">-/</span>
</code></pre></div>



<a name="228076605"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universe%20issue%20with%20%60Type%2A%60/near/228076605" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universe.20issue.20with.20.60Type*.60.html#228076605">(Feb 27 2021 at 19:06)</a>:</h4>
<p><code>Type*</code> in a lemma or definition is adjusted based on its use</p>



<a name="228076807"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universe%20issue%20with%20%60Type%2A%60/near/228076807" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universe.20issue.20with.20.60Type*.60.html#228076807">(Feb 27 2021 at 19:07)</a>:</h4>
<p><code>Type*</code> in variables always means "just make another universe"</p>



<a name="228076834"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universe%20issue%20with%20%60Type%2A%60/near/228076834" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universe.20issue.20with.20.60Type*.60.html#228076834">(Feb 27 2021 at 19:07)</a>:</h4>
<p>I've seen this a lot where I write <code>Sort*</code> in a lemma, but lean has worked out that my typeclasses require <code>Type*</code> and changed it for me silently</p>



<a name="228077059"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universe%20issue%20with%20%60Type%2A%60/near/228077059" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universe.20issue.20with.20.60Type*.60.html#228077059">(Feb 27 2021 at 19:11)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variables</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>

<span class="kd">def</span> <span class="n">a</span> <span class="o">:</span> <span class="n">R</span> <span class="bp">→</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">M</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">r</span> <span class="n">m</span><span class="o">,</span> <span class="n">m</span>

<span class="k">#check</span> <span class="bp">@</span><span class="n">a</span> <span class="c1">-- Π {R : Type u_3} {M : Type u_4}</span>

<span class="kd">def</span> <span class="n">b</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">R</span> <span class="bp">→</span> <span class="n">M</span> <span class="o">:=</span> <span class="n">flip</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">r</span> <span class="n">m</span><span class="o">,</span> <span class="n">m</span><span class="o">)</span>

<span class="k">#check</span> <span class="bp">@</span><span class="n">b</span> <span class="c1">-- Π {R : Type u_3} {M : Type u_4}  ...</span>
</code></pre></div>
<p>So the phenomenon doesn't persist for bare functions.</p>



<a name="228077566"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universe%20issue%20with%20%60Type%2A%60/near/228077566" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universe.20issue.20with.20.60Type*.60.html#228077566">(Feb 27 2021 at 19:20)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.module.basic</span>

<span class="kd">universes</span> <span class="n">u</span> <span class="n">v</span> <span class="n">w</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">N</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">{</span><span class="n">P</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">w</span><span class="o">}</span>
  <span class="o">[</span><span class="n">add_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">add_monoid</span> <span class="n">N</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">P</span><span class="o">]</span>

<span class="k">#check</span> <span class="n">flip</span> <span class="c1">-- (M → N → P) → N → M → P</span>
<span class="k">#check</span> <span class="o">(</span><span class="n">M</span> <span class="bp">→</span> <span class="n">N</span> <span class="bp">→</span> <span class="n">P</span><span class="o">)</span> <span class="bp">→</span> <span class="n">N</span> <span class="bp">→</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">P</span> <span class="c1">-- Type (max (max u v w) v u w)</span>

<span class="k">#check</span> <span class="n">add_monoid_hom.flip</span> <span class="c1">-- (M →+ N →+ P) → N →+ M →+ P</span>

<span class="k">#check</span> <span class="o">(</span><span class="n">M</span> <span class="bp">→+</span> <span class="n">N</span> <span class="bp">→+</span> <span class="n">P</span><span class="o">)</span> <span class="bp">→</span> <span class="n">N</span> <span class="bp">→+</span> <span class="n">M</span> <span class="bp">→+</span> <span class="n">P</span> <span class="c1">-- Type (max (max u v w) v u w)</span>
</code></pre></div>
<p>This is the issue I think. <code>add_monoid_hom.flip</code>, and even <code>flip</code>, produce terms whose types have some pretty crazy universes.</p>



<a name="228077583"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universe%20issue%20with%20%60Type%2A%60/near/228077583" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universe.20issue.20with.20.60Type*.60.html#228077583">(Feb 27 2021 at 19:21)</a>:</h4>
<p>I think we need to simp those universe parameters</p>



<a name="228078073"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universe%20issue%20with%20%60Type%2A%60/near/228078073" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universe.20issue.20with.20.60Type*.60.html#228078073">(Feb 27 2021 at 19:31)</a>:</h4>
<p>I can't reproduce with normal functions :-/ I'm still wondering if this can be fixed in the sense that one could get <code>a.flip</code> working.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.module.basic</span>

<span class="kd">universes</span> <span class="n">u</span> <span class="n">v</span> <span class="n">w</span>

<span class="kd">structure</span> <span class="n">foo</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">N</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">w</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">hom</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">N</span> <span class="bp">→</span> <span class="n">P</span><span class="o">)</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">N</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">{</span><span class="n">P</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">w</span><span class="o">}</span> <span class="o">[</span><span class="n">has_scalar</span> <span class="n">M</span> <span class="n">N</span><span class="o">]</span>

<span class="kd">def</span> <span class="n">foo.flip</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">foo</span> <span class="n">M</span> <span class="n">N</span> <span class="n">P</span><span class="o">)</span> <span class="o">:</span> <span class="n">foo</span> <span class="n">N</span> <span class="n">M</span> <span class="n">P</span> <span class="o">:=</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">n</span> <span class="n">m</span><span class="o">,</span> <span class="n">c.hom</span> <span class="n">m</span> <span class="n">n</span><span class="o">⟩</span>

<span class="kd">def</span> <span class="n">a</span> <span class="o">:</span> <span class="n">foo</span> <span class="n">M</span> <span class="n">N</span> <span class="n">N</span> <span class="o">:=</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">m</span> <span class="n">n</span><span class="o">,</span> <span class="n">m</span> <span class="bp">•</span> <span class="n">n</span><span class="o">⟩</span>

<span class="k">#check</span> <span class="bp">@</span><span class="n">a</span> <span class="c1">-- Π {M : Type u_1} {N : Type u_2} ...</span>

<span class="kd">def</span> <span class="n">b</span> <span class="o">{</span><span class="n">M</span> <span class="n">N</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">has_scalar</span> <span class="n">M</span> <span class="n">N</span><span class="o">]:</span> <span class="n">foo</span> <span class="n">N</span> <span class="n">M</span> <span class="n">N</span> <span class="o">:=</span> <span class="o">(⟨</span><span class="bp">λ</span> <span class="n">m</span> <span class="n">n</span><span class="o">,</span> <span class="n">m</span> <span class="bp">•</span> <span class="n">n</span><span class="o">⟩</span> <span class="o">:</span> <span class="n">foo</span> <span class="n">M</span> <span class="n">N</span> <span class="n">N</span><span class="o">)</span><span class="bp">.</span><span class="n">flip</span>

<span class="k">#check</span> <span class="bp">@</span><span class="n">b</span> <span class="c1">-- Π {M : Type u_1} {N : Type u_2} ...</span>
</code></pre></div>



<a name="228117564"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universe%20issue%20with%20%60Type%2A%60/near/228117564" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universe.20issue.20with.20.60Type*.60.html#228117564">(Feb 28 2021 at 09:08)</a>:</h4>
<p>This is usually the fault of a bad definition, which has two universe arguments and only uses <code>max u v</code>, like you found. But looking at <code>add_monoid_hom.flip</code> I don't see anything suspicious, it uses exactly as many universes as one would expect.</p>
<p>EDIT: Actually the issue is <code>add_monoid_hom.flip</code>, or more specifically the unification problem that arises when you match an argument of type <code>R →+ M →+ M</code> against the input to <code>add_monoid_hom.flip</code>, because this basically looks like</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">@</span><span class="n">add_monoid_hom.</span><span class="o">{</span><span class="bp">?</span><span class="n">l_1</span> <span class="bp">?</span><span class="n">l_2</span><span class="o">}</span> <span class="o">(</span><span class="bp">@</span><span class="n">add_monoid_hom.</span><span class="o">{</span><span class="bp">?</span><span class="n">l_2</span> <span class="bp">?</span><span class="n">l_2</span><span class="o">}</span> <span class="n">M</span> <span class="n">M</span><span class="o">)</span>
</code></pre></div>
<p>vs</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">@</span><span class="n">add_monoid_hom.</span><span class="o">{</span><span class="bp">?</span><span class="n">l_3</span> <span class="o">(</span><span class="n">max</span> <span class="bp">?</span><span class="n">l_4</span> <span class="bp">?</span><span class="n">l_5</span><span class="o">)}</span> <span class="bp">?</span><span class="n">m_6</span> <span class="o">(</span><span class="bp">@</span><span class="n">add_monoid_hom.</span><span class="o">{</span><span class="bp">?</span><span class="n">l_4</span> <span class="bp">?</span><span class="n">l_5</span><span class="o">}</span> <span class="bp">?</span><span class="n">m_7</span> <span class="bp">?</span><span class="n">m_8</span><span class="o">))</span>
</code></pre></div>
<p>which results in unifying <code>?l_2</code> against <code>max ?l_4 ?l_5</code>, resulting in two free universe metavariables that are later turned into real variables at the end.</p>
<p>The fix for this is simple: Use explicit universes in this particular theorem.  This is an issue with the universe unification strategy, maybe it can be fixed, maybe not, but I still think it is best to let the algorithm handle universe variables where possible, in spite of these rare issues</p>



<a name="228117858"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universe%20issue%20with%20%60Type%2A%60/near/228117858" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universe.20issue.20with.20.60Type*.60.html#228117858">(Feb 28 2021 at 09:14)</a>:</h4>
<p>So you're saying that I should just not worry about this and use <code>Type u</code> instead of <code>Type*</code> for the original theorem? That's fine by me! It's also kind of telling me to go back to using Type u in general.</p>



<a name="228117958"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universe%20issue%20with%20%60Type%2A%60/near/228117958" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universe.20issue.20with.20.60Type*.60.html#228117958">(Feb 28 2021 at 09:16)</a>:</h4>
<p>It is my impression that this doesn't happen very often</p>



<a name="228117984"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universe%20issue%20with%20%60Type%2A%60/near/228117984" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universe.20issue.20with.20.60Type*.60.html#228117984">(Feb 28 2021 at 09:17)</a>:</h4>
<p>I think if you use <code>variables {R M : Type*}</code> then it will use fresh universe variables, instead of metavariables, which are not susceptible to these spurious unification issues</p>



<a name="228118035"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universe%20issue%20with%20%60Type%2A%60/near/228118035" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universe.20issue.20with.20.60Type*.60.html#228118035">(Feb 28 2021 at 09:18)</a>:</h4>
<p>Arguably this is more natural default behavior</p>



<a name="228118109"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universe%20issue%20with%20%60Type%2A%60/near/228118109" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universe.20issue.20with.20.60Type*.60.html#228118109">(Feb 28 2021 at 09:20)</a>:</h4>
<p>I'm not sure which of these two is more expected:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variables</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">=</span> <span class="n">B</span> <span class="o">:=</span> <span class="gr">sorry</span> <span class="c1">-- fail</span>
<span class="kd">example</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">=</span> <span class="n">B</span> <span class="o">:=</span> <span class="gr">sorry</span> <span class="c1">-- ok</span>
</code></pre></div>



<a name="228119818"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universe%20issue%20with%20%60Type%2A%60/near/228119818" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universe.20issue.20with.20.60Type*.60.html#228119818">(Feb 28 2021 at 09:56)</a>:</h4>
<p>Thanks!  At the moment, the theorem is stated with the <code>M</code> universe explicit.</p>



<a name="228126808"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universe%20issue%20with%20%60Type%2A%60/near/228126808" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universe.20issue.20with.20.60Type*.60.html#228126808">(Feb 28 2021 at 12:11)</a>:</h4>
<p>If you use variables you can go back to Type*, if you care</p>



<a name="228126940"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universe%20issue%20with%20%60Type%2A%60/near/228126940" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universe.20issue.20with.20.60Type*.60.html#228126940">(Feb 28 2021 at 12:13)</a>:</h4>
<p>Given that this lemma went in the middle of a file, where there were other conventions about <code>variables</code>, I think that I prefer to leave it as is.  Had it been on a file that I started with this purpose in mind, I maybe would not have realized, since I might indeed had <code>R</code> and <code>M</code> declared as variables at the beginning.</p>



<a name="228136392"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universe%20issue%20with%20%60Type%2A%60/near/228136392" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nick Scheel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universe.20issue.20with.20.60Type*.60.html#228136392">(Feb 28 2021 at 15:17)</a>:</h4>
<p>I didn’t quite follow: was the problem determined to be that there were two universe variables that only appeared together as a <code>max u v</code> but never separately?</p>
<p>I think this situation is bound to come up, but if the type theory is parametric over universes it is okay to solve them to be the same variable. (The one I am studying has this property, so I will do that.) But I think in Lean, because you have LEM and things like ordinals and cardinals which change depending on their universe, it is no longer parametric? Correct me if I am wrong.</p>



<a name="228136619"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universe%20issue%20with%20%60Type%2A%60/near/228136619" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nick Scheel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universe.20issue.20with.20.60Type*.60.html#228136619">(Feb 28 2021 at 15:21)</a>:</h4>
<p>Or was the problem that the parts that should have determined the variables were also implicit?</p>



<a name="228138910"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universe%20issue%20with%20%60Type%2A%60/near/228138910" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universe.20issue.20with.20.60Type*.60.html#228138910">(Feb 28 2021 at 16:01)</a>:</h4>
<p>The problem was that an equation which one has to solve using universes was solved in a suboptimal way if you ask the system to solve it in a certain way</p>



<a name="229906001"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universe%20issue%20with%20%60Type%2A%60/near/229906001" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universe.20issue.20with.20.60Type*.60.html#229906001">(Mar 11 2021 at 18:58)</a>:</h4>
<p>Is this related?</p>
<p>Right now on master</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">topology.algebra.group</span>

<span class="kd">set_option</span> <span class="n">pp.universes</span> <span class="n">true</span>
<span class="c">/-</span><span class="cm"></span>
<span class="cm">topological_group.of_nhds_one.{u_1 u_2} :</span>
<span class="cm">  ∀ {G : Type (max u_1 u_2)} [_inst_5 : group.{(max u_1 u_2)} G] [_inst_6 : topological_space.{(max u_1 u_2)} G],</span>
<span class="cm">    filter.tendsto.{(max u_1 u_2) (max u_1 u_2)}</span>
<span class="cm">      (function.uncurry.{(max u_1 u_2) (max u_1 u_2) (max u_1 u_2)} has_mul.mul.{(max u_1 u_2)})</span>
<span class="cm">      ((nhds.{(max u_1 u_2)} 1).prod (nhds.{(max u_1 u_2)} 1))</span>
<span class="cm">      (nhds.{(max u_1 u_2)} 1) →</span>
<span class="cm">    filter.tendsto.{(max u_1 u_2) (max u_1 u_2)} (λ (x : G), x⁻¹) (nhds.{(max u_1 u_2)} 1)</span>
<span class="cm">      (nhds.{(max u_1 u_2)} 1) →</span>
<span class="cm">    (∀ (x₀ : G),</span>
<span class="cm">       nhds.{(max u_1 u_2)} x₀ =</span>
<span class="cm">         filter.map.{(max u_1 u_2) (max u_1 u_2)} (λ (x : G), x₀ * x) (nhds.{(max u_1 u_2)} 1)) →</span>
<span class="cm">    (∀ (x₀ : G),</span>
<span class="cm">       filter.tendsto.{(max u_1 u_2) (max u_1 u_2)} (λ (x : G), x₀ * x * x₀⁻¹) (nhds.{(max u_1 u_2)} 1)</span>
<span class="cm">         (nhds.{(max u_1 u_2)} 1)) →</span>
<span class="cm">    topological_group.{(max u_1 u_2)} G</span>
<span class="cm">All Messages (1)</span>

<span class="cm">-/</span>
</code></pre></div>
<p>Changing <code>Type*</code> to <code>Type u</code> in <a href="https://github.com/leanprover-community/mathlib/issues/6647">#6647</a> fixes this issue.</p>



<a name="229907169"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universe%20issue%20with%20%60Type%2A%60/near/229907169" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universe.20issue.20with.20.60Type*.60.html#229907169">(Mar 11 2021 at 19:05)</a>:</h4>
<p>yep</p>



<a name="229907245"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universe%20issue%20with%20%60Type%2A%60/near/229907245" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universe.20issue.20with.20.60Type*.60.html#229907245">(Mar 11 2021 at 19:06)</a>:</h4>
<p>I think it's <code>tendsto (uncurry ((*) : G → G → G))</code> that causes the bad unify here</p>



<a name="229940415"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universe%20issue%20with%20%60Type%2A%60/near/229940415" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universe.20issue.20with.20.60Type*.60.html#229940415">(Mar 11 2021 at 22:33)</a>:</h4>
<p>I've put <a href="https://github.com/leanprover-community/mathlib/issues/6647">#6647</a> on the queue. We should add a library note for this if we find some more examples.</p>



<a name="229983413"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universe%20issue%20with%20%60Type%2A%60/near/229983413" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universe.20issue.20with.20.60Type*.60.html#229983413">(Mar 12 2021 at 06:30)</a>:</h4>
<p>It was <code>flip</code> before IIRC, which is of a similar nature to uncurry.</p>



<a name="230035360"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universe%20issue%20with%20%60Type%2A%60/near/230035360" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universe.20issue.20with.20.60Type*.60.html#230035360">(Mar 12 2021 at 14:16)</a>:</h4>
<p>I want to point my finger at expressions like <code>G → G → G</code>, where the type of the implication is something like <code>imax u (imax u u)</code> where <code>u</code> is the sort of <code>G</code>. That simplifies to <code>u</code> when it's a variable, but when that expression appears in stages, where <code>?u</code> is a metavariable, it's not obvious that it's going to normalize at first. When it is <code>G → H → G</code> when the universes are actually different there is no issue because lean guesses correctly.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
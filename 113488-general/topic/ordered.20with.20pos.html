---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/ordered.20with.20pos.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ordered.20with.20pos.html">ordered with pos</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="241912529"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ordered%20with%20pos/near/241912529" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ordered.20with.20pos.html#241912529">(Jun 08 2021 at 12:44)</a>:</h4>
<p>Dear All,</p>
<p>I am about to start preparing a PR to push the <code>ordered</code> refactor across types with <code>add</code> <em>and</em> <code>mul</code>.  This essentially involves asserting that multiplication by <em>strictly positive</em> elements be monotone (on top of what is already there for monotonicity of addition).  While this is relatively easy to implement, there are two possible approaches that I have played with.  I think that, in the long run, maybe we should implement both, but, for the moment, I would start with one.  Below are the two approaches that I have in mind: let me know if you have a preference for either one of them or if you see problems/benefits with one or the other!</p>
<p>Thanks!</p>
<p>Approach 1: <em>monotone multiplication</em>.  Simply introduce new typeclasses asserting</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">N</span><span class="o">)</span> <span class="o">{</span><span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">N</span><span class="o">},</span> <span class="o">(</span><span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">a</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">b</span> <span class="bp">≤</span> <span class="n">c</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">c</span><span class="o">)</span>
</code></pre></div>
<p>with various layers according to whether the inequality is strict or not, or whether multiplication is on the left or on the right.  This is relatively straightforward.  The main drawback is that it uses <em>homogeneous</em> multiplication.  Thus, it may cause problems when trying to multiply a <code>(unit nnreal)</code> by an <code>ennreal</code>.</p>
<p>Approach 2: <em>monotone action</em>.  Introduce a more general typeclass allowing an action of a Type <code>M</code> on a second Type <code>N</code> and asserting</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">∀</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">M</span><span class="o">)</span> <span class="o">{</span><span class="n">n₁</span> <span class="n">n₂</span> <span class="o">:</span> <span class="n">N</span><span class="o">},</span> <span class="o">(</span><span class="n">n₁</span> <span class="bp">≤</span> <span class="n">n₂</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">m</span> <span class="bp">•</span> <span class="n">n₁</span> <span class="bp">≤</span> <span class="n">m</span> <span class="bp">•</span> <span class="n">n₂</span><span class="o">)</span>
</code></pre></div>
<p>This approach of course allows for more general statements, and would work better developing some API for "positive subtypes" of types with an order.  In the first instance, this can be quite short, only introducing a "Type of positive elements" whenever a type <code>has_zero</code> and <code>has_lt</code>.</p>
<p>My preference is for Approach 2.  This works well in abstract Types, but also in concrete cases where you might want to multiply a positive rational number by an <code>ennreal</code> and know that multiplication is monotone.</p>
<p>What are people's opinions on this?  Should I create a poll?</p>



<a name="241913518"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ordered%20with%20pos/near/241913518" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ordered.20with.20pos.html#241913518">(Jun 08 2021 at 12:51)</a>:</h4>
<p><span class="user-mention silent" data-user-id="321459">Damiano Testa</span> <a href="#narrow/stream/113488-general/topic/ordered.20with.20pos/near/241912529">said</a>:</p>
<blockquote>
<p>Thus, it may cause problems when trying to multiply a <code>(unit nnreal)</code> by an <code>ennreal</code>.</p>
</blockquote>
<p>Can you maybe give another example?  You can multiply a <code>units nnreal</code> and an <code>ennreal</code> just fine (the unit will just coerce to an ennreal).</p>



<a name="241917717"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ordered%20with%20pos/near/241917717" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ordered.20with.20pos.html#241917717">(Jun 08 2021 at 13:22)</a>:</h4>
<p>At the moment, I am actually failing to identify an example where there may not be a coercion saving the day.  Maybe there is no need for the extra generality of the "proper action" and all can be resolved using coercions+multiplication?</p>
<p>I can only think of the following "dynamical-systems-like" example.<br>
Suppose that you have a Type <code>X</code> with a self-map <code>f : X → X</code>.  This determines an action of <code>ℕ</code> on <code>X</code> by iterating <code>f</code>.  You can then act on <code>set X</code> elementwise via <code>f^[n] ''</code>.  On <code>set X</code> there is an addition (taking unions) and a <code>≤</code> (taking subsets) and the <code>ℕ</code>-action is monotone.  At this level, there is no coercion from <code>ℕ</code> to <code>set X</code> that would work, I think.</p>
<p>Does this count?  The answer could well be: "this is too contrived, so we do not need the greater generality"!</p>



<a name="241918596"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ordered%20with%20pos/near/241918596" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ordered.20with.20pos.html#241918596">(Jun 08 2021 at 13:27)</a>:</h4>
<p>I guess that the main take-away from the example is that you do not need a multiplication on <code>N</code> to have a monotonicity of <em>something</em> acting on it.  I feel like I should know a good example of this, but I am not managing to bring it to my conscience!</p>



<a name="241932590"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ordered%20with%20pos/near/241932590" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ordered.20with.20pos.html#241932590">(Jun 08 2021 at 14:55)</a>:</h4>
<p>Your approach 2 looks like a weaker version of <a href="https://leanprover-community.github.io/mathlib_docs/find/smul_lt_smul_of_pos">docs#smul_lt_smul_of_pos</a></p>



<a name="241932873"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ordered%20with%20pos/near/241932873" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ordered.20with.20pos.html#241932873">(Jun 08 2021 at 14:57)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110043">Gabriel Ebner</span> <a href="#narrow/stream/113488-general/topic/ordered.20with.20pos/near/241913518">said</a>:</p>
<blockquote>
<p>You can multiply a <code>units nnreal</code> and an <code>ennreal</code> just fine (the unit will just coerce to an ennreal).</p>
</blockquote>
<p>It's not really the point of this thread, but I think there should be a <code>algebra nnreal ennreal</code> instance somewhere, from which we'd get <code>has_scalar (units nnreal) ennreal</code> automatically.</p>



<a name="241933087"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ordered%20with%20pos/near/241933087" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ordered.20with.20pos.html#241933087">(Jun 08 2021 at 14:58)</a>:</h4>
<p><code>algebra R A</code> assumes that <code>A</code> is a semiring, right? But <code>ennreal</code> isn't.</p>



<a name="241935854"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ordered%20with%20pos/near/241935854" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ordered.20with.20pos.html#241935854">(Jun 08 2021 at 15:14)</a>:</h4>
<p>Eric, thank you for digging out something that would likely be an application of Approach 2, (should Approach 2 become part of mathlib)!</p>
<p>While it is possible that most applications of the <code>ordered</code> refactor could be solved by instances, I still think that it might be worthwhile to pursue both Approach 1 <em>and</em> Approach 2, although not in the same PR.  I am now going to propose a poll, to see with which one to begin!</p>



<a name="241936154"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ordered%20with%20pos/near/241936154" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ordered.20with.20pos.html#241936154">(Jun 08 2021 at 15:16)</a>:</h4>
<p>/poll mul_pos_monotone<br>
Approach 1: monotone multiplication <code>∀ (a : N) {b c : N}, (0 &lt; a) → (b ≤ c) → (a * b ≤ a * c)</code><br>
Approach 2: monotone action <code>∀ (m : M) {n₁ n₂ : N}, (n₁ ≤ n₂) → (m • n₁ ≤ m • n₂)</code></p>



<a name="241936360"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ordered%20with%20pos/near/241936360" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ordered.20with.20pos.html#241936360">(Jun 08 2021 at 15:17)</a>:</h4>
<p>Oh, I totally missed that. Then I guess I mean there should be a <code>mul_action nnreal ennreal</code>?</p>



<a name="241936630"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ordered%20with%20pos/near/241936630" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ordered.20with.20pos.html#241936630">(Jun 08 2021 at 15:19)</a>:</h4>
<p>Damiano, is the idea behind approach 2 to use a subtype <code>M</code> for the <code>0 &lt; a</code> condition?</p>



<a name="241937035"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ordered%20with%20pos/near/241937035" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ordered.20with.20pos.html#241937035">(Jun 08 2021 at 15:22)</a>:</h4>
<p>Eric, yes, I would use the subtype that you mention to apply it, but only if approach 1 is not also developed.</p>



<a name="241937098"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ordered%20with%20pos/near/241937098" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ordered.20with.20pos.html#241937098">(Jun 08 2021 at 15:22)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/113488-general/topic/ordered.20with.20pos/near/241933087">said</a>:</p>
<blockquote>
<p><code>algebra R A</code> assumes that <code>A</code> is a semiring, right? But <code>ennreal</code> isn't.</p>
</blockquote>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/ennreal.canonically_ordered_comm_semiring">docs#ennreal.canonically_ordered_comm_semiring</a>  suggests to me that ennreal is a semiring</p>



<a name="241937169"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ordered%20with%20pos/near/241937169" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ordered.20with.20pos.html#241937169">(Jun 08 2021 at 15:23)</a>:</h4>
<p>(I do not view the two approaches as opposing: sometimes the "unbundled" approach 1 is better, other times the "bundled" approach 2 is better.  it is not difficult to go from one to the other, though having direct paths both ways may be convenient)</p>



<a name="241937447"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ordered%20with%20pos/near/241937447" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ordered.20with.20pos.html#241937447">(Jun 08 2021 at 15:25)</a>:</h4>
<p>In approach 2 you are adding the assumption <code>0 &lt; m</code> right?</p>



<a name="241937544"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ordered%20with%20pos/near/241937544" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ordered.20with.20pos.html#241937544">(Jun 08 2021 at 15:25)</a>:</h4>
<p>In approach 2 you do not need to add the assumption <code>0 &lt; m</code>, since you would only get an instance of that type if multiplication is monotone.</p>



<a name="241937575"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ordered%20with%20pos/near/241937575" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ordered.20with.20pos.html#241937575">(Jun 08 2021 at 15:25)</a>:</h4>
<p><span class="user-mention" data-user-id="310045">@Eric Wieser</span> you're right. my bad</p>



<a name="241937689"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ordered%20with%20pos/near/241937689" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ordered.20with.20pos.html#241937689">(Jun 08 2021 at 15:26)</a>:</h4>
<p>In other words, if multiplication of a type on another is monotone, <em>likely</em> the action of the first type is by positive elements.</p>



<a name="241937783"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ordered%20with%20pos/near/241937783" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ordered.20with.20pos.html#241937783">(Jun 08 2021 at 15:26)</a>:</h4>
<p>But you need not have even an order relation on the acting type in order to get monotonicity of the action: the inequalities are all on the target type <code>N</code>.</p>



<a name="241938063"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ordered%20with%20pos/near/241938063" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ordered.20with.20pos.html#241938063">(Jun 08 2021 at 15:28)</a>:</h4>
<p>Ah, I see.</p>



<a name="241938074"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ordered%20with%20pos/near/241938074" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ordered.20with.20pos.html#241938074">(Jun 08 2021 at 15:28)</a>:</h4>
<p>Thus, Approach 2 is outsourcing to the typeclass system to make sure that you have a proof that the elements of the Type <code>M</code> actually do have the correct monotonicity.</p>



<a name="241938078"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ordered%20with%20pos/near/241938078" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ordered.20with.20pos.html#241938078">(Jun 08 2021 at 15:28)</a>:</h4>
<p>One advantage of approach 2 is that it generalizes both approach 1 and the current <code>covariant_class</code>, right?</p>



<a name="241938210"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ordered%20with%20pos/near/241938210" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ordered.20with.20pos.html#241938210">(Jun 08 2021 at 15:29)</a>:</h4>
<p>Yes, indeed, <code>covariant_class</code> would be applying approach 2 with twice the same type (i.e. <code>M = N</code>).<br>
and the "positive multiplication" would be using approach 2 with the "type of positive elements" acting on the actual type.</p>



<a name="241939063"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ordered%20with%20pos/near/241939063" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ordered.20with.20pos.html#241939063">(Jun 08 2021 at 15:34)</a>:</h4>
<p>Mathematically, there is little difference.  In Lean, instead of multiplying by the elements of a Type <code>N</code> that happen to be positive, you allow yourself to act on <code>N</code> with the elements of another type <code>M</code>.</p>
<p>The use case is of course the one where <code>M</code> is the subtype of the positive elements of <code>N</code>, though this would not be required by the definitions.</p>



<a name="241939376"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ordered%20with%20pos/near/241939376" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ordered.20with.20pos.html#241939376">(Jun 08 2021 at 15:36)</a>:</h4>
<p>I think approach 2 is worth trying.</p>



<a name="241940191"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ordered%20with%20pos/near/241940191" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ordered.20with.20pos.html#241940191">(Jun 08 2021 at 15:42)</a>:</h4>
<p>How about a third appoach:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">is_monotone</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">B</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">out</span> <span class="o">:</span> <span class="n">monotone</span> <span class="n">f</span><span class="o">)</span>
</code></pre></div>
<p>which you can then write approach 2 as using <code>[∀ m : M, is_monotone ((•) m : N → N)]</code></p>



<a name="241940728"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ordered%20with%20pos/near/241940728" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ordered.20with.20pos.html#241940728">(Jun 08 2021 at 15:45)</a>:</h4>
<p>Eric, I like your suggestion, although I would also want to allow the freedom of having <code>strict_mono</code>.  In other words, I was thinking of leaving the (order) relation as an input of the class, like for <code>covariant</code>.</p>



<a name="241940812"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ordered%20with%20pos/near/241940812" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ordered.20with.20pos.html#241940812">(Jun 08 2021 at 15:46)</a>:</h4>
<p>So, I could sometimes assume that multiplication is monotone and sometimes strictly monotone.</p>



<a name="241944470"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ordered%20with%20pos/near/241944470" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ordered.20with.20pos.html#241944470">(Jun 08 2021 at 16:10)</a>:</h4>
<p>Wait, <code>covariant_class</code> can be used to do approach 2, right? <code>covariant_class {x : M // 0 &lt; x} M (•) (≤)</code></p>



<a name="241945811"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ordered%20with%20pos/near/241945811" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ordered.20with.20pos.html#241945811">(Jun 08 2021 at 16:19)</a>:</h4>
<p><span class="user-mention silent" data-user-id="321459">Damiano Testa</span> <a href="#narrow/stream/113488-general/topic/ordered.20with.20pos/near/241940728">said</a>:</p>
<blockquote>
<p>Eric, I like your suggestion, although I would also want to allow the freedom of having <code>strict_mono</code>.  In other words, I was thinking of leaving the (order) relation as an input of the class, like for <code>covariant</code>.</p>
</blockquote>
<p>my experiments in <a href="https://github.com/leanprover-community/mathlib/issues/7834">#7834</a> suggest that typeclasses with lots of (dependent) inputs as you're suggesting might be a bad idea - but it's also possible my problem is something else</p>



<a name="241948014"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ordered%20with%20pos/near/241948014" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ordered.20with.20pos.html#241948014">(Jun 08 2021 at 16:35)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/113488-general/topic/ordered.20with.20pos/near/241937575">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> you're right. my bad</p>
</blockquote>
<p><a href="https://github.com/leanprover-community/mathlib/issues/7846">#7846</a></p>



<a name="241948742"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ordered%20with%20pos/near/241948742" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ordered.20with.20pos.html#241948742">(Jun 08 2021 at 16:39)</a>:</h4>
<p>Eric, some similar comments on times had been raised before the introduction of <code>covariant_class though some timings performed by Jannis Limperg suggested that the </code>covariant<code> approach was (very marginally) faster than the current one with </code>ordered_...`.  In any case, I will try to see how it works and then we can decide what is best.  This will likely be tomorrow, though!</p>



<a name="241948855"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ordered%20with%20pos/near/241948855" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ordered.20with.20pos.html#241948855">(Jun 08 2021 at 16:40)</a>:</h4>
<p>Floris, I think that I had tried to recycle <code>covariant_class</code>, but had failed.  I will try again and see how it works!</p>



<a name="241948869"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ordered%20with%20pos/near/241948869" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ordered.20with.20pos.html#241948869">(Jun 08 2021 at 16:40)</a>:</h4>
<p>In any case, thank you all for the support!</p>



<a name="241952021"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ordered%20with%20pos/near/241952021" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ordered.20with.20pos.html#241952021">(Jun 08 2021 at 17:00)</a>:</h4>
<p>My concern is not so much about speed, but about whether typeclass search will get stuck on the resulting dependent types.</p>



<a name="241952199"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ordered%20with%20pos/near/241952199" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ordered.20with.20pos.html#241952199">(Jun 08 2021 at 17:01)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/113488-general/topic/ordered.20with.20pos/near/241932873">said</a>:</p>
<blockquote>
<p>I think there should be a <code>algebra nnreal ennreal</code> instance somewhere, from which we'd get <code>has_scalar (units nnreal) ennreal</code> automatically.</p>
</blockquote>
<p><a href="https://github.com/leanprover-community/mathlib/issues/7846">#7846</a> now provides <code>distrib_mul_action (units ℝ≥0) ℝ≥0∞</code></p>



<a name="242064608"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ordered%20with%20pos/near/242064608" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ordered.20with.20pos.html#242064608">(Jun 09 2021 at 13:29)</a>:</h4>
<p>Dear All,</p>
<p>here is a follow up, based on the discussion that we were having yesterday.  Below is a beginning of code to convert lemmas about <code>ordered_semiring</code>s into lemmas about <code>covariant_class M N (some_action) (&lt;)</code>.</p>
<p>[Floris, this seems to work: I think that I had something more general in mind that would require <em>three</em> types, instead of two.]</p>
<p>Main question.  Can I make the final proof of <code>mul_lt_mul_of_pos_left</code>"simpler"?</p>
<p>Side question.  How would you improve the code?</p>
<p>Thanks!</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.ordered_ring</span>

<span class="sd">/--  The positive elements of a type. -/</span>
<span class="kd">def</span> <span class="n">posi</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">has_zero</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">has_lt</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">a</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">//</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">a</span> <span class="o">}</span>

<span class="kn">namespace</span> <span class="n">posi</span>

<span class="sd">/--  An element of `posi α` can be coerced into `α`. -/</span>
<span class="kd">instance</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">has_zero</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">has_lt</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">has_coe</span> <span class="o">(</span><span class="n">posi</span> <span class="n">α</span><span class="o">)</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">coe</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="n">a.1</span> <span class="o">}</span>

<span class="sd">/--  A positive element of `α` can be lifted into `posi α`. -/</span>
<span class="kd">instance</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">has_zero</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">has_lt</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">can_lift</span> <span class="n">α</span> <span class="o">(</span><span class="n">posi</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">coe</span>  <span class="o">:=</span> <span class="n">coe</span><span class="o">,</span>
  <span class="n">cond</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">a</span><span class="o">,</span>
  <span class="n">prf</span>  <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">ha</span><span class="o">,</span> <span class="n">Exists.intro</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">ha</span><span class="o">⟩</span> <span class="n">rfl</span> <span class="o">}</span>

<span class="sd">/--  An ordered semiring automatically inherits a covariant_class for strictly monotone</span>
<span class="sd">multiplication by positive elements. -/</span>
<span class="kd">instance</span> <span class="n">ordered_semiring.to_covariant_class_posi_left</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">ordered_semiring</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">covariant_class</span> <span class="o">(</span><span class="n">posi</span> <span class="n">α</span><span class="o">)</span> <span class="n">α</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="bp">&lt;</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">covc</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">bc</span><span class="o">,</span> <span class="n">mul_lt_mul_of_pos_left</span> <span class="n">bc</span> <span class="n">a.2</span> <span class="o">}</span>

<span class="c">/-</span><span class="cm">  The lemma in general. -/</span>
<span class="kd">lemma</span> <span class="n">mul_lt_mul_of_pos</span> <span class="o">{</span><span class="n">M</span> <span class="n">N</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">μ</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">N</span> <span class="bp">→</span> <span class="n">N</span><span class="o">)</span> <span class="o">[</span><span class="n">has_lt</span> <span class="n">N</span><span class="o">]</span> <span class="o">[</span><span class="n">covariant_class</span> <span class="n">M</span> <span class="n">N</span> <span class="n">μ</span> <span class="o">(</span><span class="bp">&lt;</span><span class="o">)]</span>
  <span class="o">{</span><span class="n">m</span> <span class="o">:</span> <span class="n">M</span><span class="o">}</span> <span class="o">{</span><span class="n">n</span> <span class="n">o</span> <span class="o">:</span> <span class="n">N</span><span class="o">}</span> <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="n">o</span><span class="o">)</span> <span class="o">:</span> <span class="n">μ</span> <span class="n">m</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="n">μ</span> <span class="n">m</span> <span class="n">o</span> <span class="o">:=</span>
<span class="n">covariant_class.covc</span> <span class="n">_</span> <span class="n">h₁</span>

<span class="c">/-</span><span class="cm">  If possible, I would like this proof to be simply an application of the general lemma. -/</span>
<span class="kd">lemma</span> <span class="n">mul_lt_mul_of_pos_left</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">ordered_semiring</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span>
  <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">h₂</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">c</span><span class="o">)</span> <span class="o">:</span> <span class="n">c</span> <span class="bp">*</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">c</span> <span class="bp">*</span> <span class="n">b</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span>  <span class="n">lift</span> <span class="n">c</span> <span class="n">to</span> <span class="o">(</span><span class="n">posi</span> <span class="n">α</span><span class="o">)</span> <span class="n">using</span> <span class="n">h₂</span><span class="o">,</span>
      <span class="n">convert</span> <span class="n">posi.mul_lt_mul_of_pos</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">posi</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span> <span class="n">h₁</span> <span class="o">}</span>

<span class="kd">end</span> <span class="n">posi</span>
</code></pre></div>



<a name="242066677"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ordered%20with%20pos/near/242066677" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ordered.20with.20pos.html#242066677">(Jun 09 2021 at 13:42)</a>:</h4>
<p>(also, I do not mind if a few initial lemmas have some awkwardness, but I would like to simply be able to apply most of the general lemmas in the <code>ordered_semiring</code> context, without having to juggle around type-theoretic assumptions all the time.)</p>



<a name="242079881"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ordered%20with%20pos/near/242079881" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ordered.20with.20pos.html#242079881">(Jun 09 2021 at 15:03)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">has_zero</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">has_lt</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">can_lift</span> <span class="n">α</span> <span class="o">(</span><span class="n">posi</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">coe</span>  <span class="o">:=</span> <span class="n">coe</span><span class="o">,</span>
  <span class="n">cond</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">a</span><span class="o">,</span>
  <span class="n">prf</span>  <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">ha</span><span class="o">,</span> <span class="o">⟨⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">ha</span><span class="o">⟩,</span> <span class="n">rfl</span><span class="o">⟩</span> <span class="o">}</span>
</code></pre></div>



<a name="242080802"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ordered%20with%20pos/near/242080802" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ordered.20with.20pos.html#242080802">(Jun 09 2021 at 15:08)</a>:</h4>
<p>Thanks Kevin!  I edited the code above, to implement your suggestion!</p>



<a name="242082517"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ordered%20with%20pos/near/242082517" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ordered.20with.20pos.html#242082517">(Jun 09 2021 at 15:20)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">local</span> <span class="kn">attribute</span> <span class="o">[</span><span class="n">elab_simple</span><span class="o">]</span> <span class="n">mul_lt_mul_of_pos</span>

<span class="kd">lemma</span> <span class="n">mul_lt_mul_of_pos_left'</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">ordered_semiring</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span>
  <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">h₂</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">c</span><span class="o">)</span> <span class="o">:</span> <span class="o">((⟨</span><span class="n">c</span><span class="o">,</span> <span class="n">h₂</span><span class="o">⟩</span> <span class="o">:</span> <span class="n">posi</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="bp">*</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">c</span> <span class="bp">*</span> <span class="n">b</span> <span class="o">:=</span>
<span class="n">mul_lt_mul_of_pos</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">y</span> <span class="o">:</span> <span class="n">posi</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="n">h₁</span>

<span class="kd">lemma</span> <span class="n">mul_lt_mul_of_pos_left</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">ordered_semiring</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span>
  <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">h₂</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">c</span><span class="o">)</span> <span class="o">:</span> <span class="n">c</span> <span class="bp">*</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">c</span> <span class="bp">*</span> <span class="n">b</span> <span class="o">:=</span>
<span class="n">mul_lt_mul_of_pos_left'</span> <span class="n">h₁</span> <span class="n">h₂</span>
</code></pre></div>



<a name="242082750"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ordered%20with%20pos/near/242082750" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ordered.20with.20pos.html#242082750">(Jun 09 2021 at 15:21)</a>:</h4>
<p>not sure if that's the answer you wanted!</p>



<a name="242082835"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ordered%20with%20pos/near/242082835" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ordered.20with.20pos.html#242082835">(Jun 09 2021 at 15:22)</a>:</h4>
<p>I need to digest it, but it might be close to what I had in mind!</p>



<a name="242082951"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ordered%20with%20pos/near/242082951" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ordered.20with.20pos.html#242082951">(Jun 09 2021 at 15:23)</a>:</h4>
<p>The idea would be that "under the hood" you prove the lemmas with the <code>'</code> in that style, but then you are allowed to use them in the familiar context with the "explicit" positivity assumption, rather than the one implicit in the subtype?</p>



<a name="242083320"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ordered%20with%20pos/near/242083320" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ordered.20with.20pos.html#242083320">(Jun 09 2021 at 15:25)</a>:</h4>
<p>(I am also toying around with introducing a smul between <code>posi α</code> and <code>α</code>, but that is also a little heavy: having the explicit <code>0 &lt; c</code> or <code>0 \le c</code> assumption in context is convenient, certainly for <em>thinking</em> about these lemmas.)</p>



<a name="242085319"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ordered%20with%20pos/near/242085319" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ordered.20with.20pos.html#242085319">(Jun 09 2021 at 15:37)</a>:</h4>
<p>I'm not sure I know the idea, I was just trying to solve the puzzle you set :-)</p>



<a name="242086074"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ordered%20with%20pos/near/242086074" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ordered.20with.20pos.html#242086074">(Jun 09 2021 at 15:41)</a>:</h4>
<p>Yes, that is a great start: thank you so much for your help!</p>



<a name="242106491"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ordered%20with%20pos/near/242106491" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ordered.20with.20pos.html#242106491">(Jun 09 2021 at 18:05)</a>:</h4>
<p>If you make the <code>m</code> in <code>mul_lt_mul_of_pos</code> explicit (which it should be), then the following also works:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">mul_lt_mul_of_pos_left</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">ordered_semiring</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span>
  <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">h₂</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">c</span><span class="o">)</span> <span class="o">:</span> <span class="n">c</span> <span class="bp">*</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">c</span> <span class="bp">*</span> <span class="n">b</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">posi.mul_lt_mul_of_pos</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">posi</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span> <span class="o">⟨</span><span class="n">c</span><span class="o">,</span> <span class="n">h₂</span><span class="o">⟩</span> <span class="n">h₁</span> <span class="o">:</span> <span class="n">_</span><span class="o">)</span>
</code></pre></div>



<a name="242115089"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ordered%20with%20pos/near/242115089" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ordered.20with.20pos.html#242115089">(Jun 09 2021 at 19:11)</a>:</h4>
<p>Aah, this is the correct solution. I knew you shouldn't be messing with the elaboration strategies but I've realised recently that I still don't properly understand the rules for which inputs should be explicit.</p>



<a name="242116767"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ordered%20with%20pos/near/242116767" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ordered.20with.20pos.html#242116767">(Jun 09 2021 at 19:24)</a>:</h4>
<p>Floris, thank you so much!  I had the correct argument explicit in the definition of <code>covariant_class</code> but got lazy here: I will be more careful!</p>



<a name="242139252"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ordered%20with%20pos/near/242139252" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ordered.20with.20pos.html#242139252">(Jun 09 2021 at 22:30)</a>:</h4>
<p>Is there a reason to (at least in Approach 1) only require multiplication by <em>positive</em> elements to be monotone? It seems better mathematically to include the case <code>0 = a</code>. For example, the product of two types satisfying the condition with <code>0 &lt; a</code> won't necessarily also satisfy it, because <code>0 &lt; (a, a')</code> doesn't imply <code>0 &lt; a</code>.</p>
<p>Is this a historical artifact perhaps? I seem to recall the Lean core library's definition of an ordered ring being odd, involving strict inequalities where <code>&lt;=</code> would be more natural.</p>



<a name="242139622"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ordered%20with%20pos/near/242139622" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ordered.20with.20pos.html#242139622">(Jun 09 2021 at 22:34)</a>:</h4>
<p>Of course in any sensible context it shouldn't matter since when <code>0 = a</code> we have <code>0 * b = 0 = 0 * c</code>.</p>



<a name="242158255"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ordered%20with%20pos/near/242158255" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ordered.20with.20pos.html#242158255">(Jun 10 2021 at 04:26)</a>:</h4>
<p>Dear Reid,</p>
<p>you are completely right, of course!</p>
<p>The reason I chose specifically strict monotonicity was simply because I still want the existing lemmas in mathlib to "just work".  In fact, the whole <code>ordered</code> refactor started because I felt that the existing system was not designed to deal with order relations interacting with general algebraic operations, not necessarily commutative, for instance.  Thus, I plan to prove lemmas for strict and non-strict monotonicity, but I certainly want to preserve the existing lemmas.</p>



<a name="242222489"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ordered%20with%20pos/near/242222489" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ordered.20with.20pos.html#242222489">(Jun 10 2021 at 15:10)</a>:</h4>
<p>OK, I don't know what order of refactors is best, but the eventually desired state should be one in which <code>ordered_ring</code> has only <code>mul_nonneg</code> as an axiom and not <code>mul_pos</code>.</p>



<a name="242225507"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ordered%20with%20pos/near/242225507" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ruben Van de Velde <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ordered.20with.20pos.html#242225507">(Jun 10 2021 at 15:32)</a>:</h4>
<p><em>order</em> of refactors, huh</p>



<a name="242228874"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ordered%20with%20pos/near/242228874" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ordered.20with.20pos.html#242228874">(Jun 10 2021 at 15:55)</a>:</h4>
<p>Reid, at the moment, I am simply introducing typeclasses for proving statements with more flexible (typeclass) assumptions.  I am not thinking of changing the definition of <code>ordered_ring</code>.  At least, not yet!</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/function.20expected.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/function.20expected.html">function expected</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="198074366"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/function%20expected/near/198074366" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/function.20expected.html#198074366">(May 19 2020 at 14:33)</a>:</h4>
<p>Is there any chance we can do something about errors like this?</p>
<div class="codehilite"><pre><span></span><code><span class="n">function</span> <span class="n">expected</span> <span class="n">at</span>
  <span class="n">aeval</span> <span class="n">ℚ</span> <span class="o">(</span><span class="n">mv_polynomial</span> <span class="o">(</span><span class="n">idx</span> <span class="bp">×</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="n">ℚ</span><span class="o">)</span> <span class="o">(</span><span class="n">witt_structure_rat</span> <span class="n">p</span> <span class="err">Φ</span><span class="o">)</span>
<span class="n">term</span> <span class="n">has</span> <span class="n">type</span>
  <span class="n">mv_polynomial</span> <span class="bp">ℕ</span> <span class="n">ℚ</span> <span class="bp">→</span><span class="err">ₐ</span><span class="o">[</span><span class="n">ℚ</span><span class="o">]</span> <span class="n">mv_polynomial</span> <span class="o">(</span><span class="n">idx</span> <span class="bp">×</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="n">ℚ</span>
</code></pre></div>


<p>Lean has correctly figured out the type... but by the time it didit's too late to check whether we can coerce to a function (if I understand the problem correctly). Maybe we can teach lean that there are second chances?</p>



<a name="198075233"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/function%20expected/near/198075233" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/function.20expected.html#198075233">(May 19 2020 at 14:38)</a>:</h4>
<p>Are you sure there aren't any funny metavariables lurking beneath the surface?</p>



<a name="198075294"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/function%20expected/near/198075294" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/function.20expected.html#198075294">(May 19 2020 at 14:38)</a>:</h4>
<p>There are</p>



<a name="198075400"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/function%20expected/near/198075400" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/function.20expected.html#198075400">(May 19 2020 at 14:39)</a>:</h4>
<p>But I want lean to not care about them, because it clearly figured out enough info to print this error message, and hence it should also be able to figure out the function.</p>



<a name="198075534"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/function%20expected/near/198075534" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/function.20expected.html#198075534">(May 19 2020 at 14:40)</a>:</h4>
<p>Oh, but then this is just the usual problem with coercions to function.</p>



<a name="198075584"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/function%20expected/near/198075584" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/function.20expected.html#198075584">(May 19 2020 at 14:40)</a>:</h4>
<p>Yes, maybe we should think about doing something about it.</p>



<a name="198075591"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/function%20expected/near/198075591" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/function.20expected.html#198075591">(May 19 2020 at 14:40)</a>:</h4>
<p>Yes, I know. Maybe I should have explained better.</p>



<a name="198077325"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/function%20expected/near/198077325" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/function.20expected.html#198077325">(May 19 2020 at 14:51)</a>:</h4>
<p>At the moment, this statement works... but I don't think it's very readable</p>
<div class="codehilite"><pre><span></span><code><span class="kn">theorem</span> <span class="n">witt_structure_rat_prop</span> <span class="o">(</span><span class="err">Φ</span> <span class="o">:</span> <span class="n">mv_polynomial</span> <span class="n">idx</span> <span class="n">ℚ</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">aeval</span> <span class="n">ℚ</span> <span class="o">(</span><span class="n">mv_polynomial</span> <span class="o">(</span><span class="n">idx</span> <span class="bp">×</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="n">ℚ</span><span class="o">)</span> <span class="o">(</span><span class="n">witt_structure_rat</span> <span class="n">p</span> <span class="err">Φ</span><span class="o">)</span> <span class="o">:</span>
    <span class="bp">_</span> <span class="bp">→</span> <span class="o">(</span><span class="n">mv_polynomial</span> <span class="o">(</span><span class="n">idx</span> <span class="bp">×</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="n">ℚ</span><span class="o">))</span> <span class="o">(</span><span class="n">witt_polynomial</span> <span class="n">p</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span>
  <span class="o">(</span><span class="n">aeval</span> <span class="n">ℚ</span> <span class="o">(</span><span class="n">mv_polynomial</span> <span class="o">(</span><span class="n">idx</span> <span class="bp">×</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="n">ℚ</span><span class="o">)</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="n">b</span> <span class="o">:</span> <span class="n">idx</span><span class="o">,</span> <span class="o">((</span><span class="n">witt_polynomial</span> <span class="n">p</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">rename</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="o">(</span><span class="n">b</span><span class="o">,</span><span class="n">i</span><span class="o">))))</span> <span class="o">:</span>
     <span class="bp">_</span> <span class="bp">→</span> <span class="o">(</span><span class="n">mv_polynomial</span> <span class="o">(</span><span class="n">idx</span> <span class="bp">×</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="n">ℚ</span><span class="o">))</span> <span class="err">Φ</span> <span class="o">:=</span>
</code></pre></div>



<a name="198077706"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/function%20expected/near/198077706" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/function.20expected.html#198077706">(May 19 2020 at 14:53)</a>:</h4>
<p>My understanding is that currently Lean refuses to even consider the possibility of applying a coercion to function when the type in question contains metavariables. I think changing the behavior of instance search as discussed at <a class="stream-topic" data-stream-id="113488" href="/#narrow/stream/113488-general/topic/unusable.20arguments">#general &gt; unusable arguments</a> is a prerequisite for changing this.</p>



<a name="198085148"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/function%20expected/near/198085148" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/function.20expected.html#198085148">(May 19 2020 at 15:41)</a>:</h4>
<p>Why this is a prerequisite? <span class="user-mention" data-user-id="110043">@Gabriel Ebner</span> is it hard to do the following?</p>
<ul>
<li>catch "function expected" error,</li>
<li>try to fill class instance metavariables using instance search, </li>
<li>if succeeded, try <code>has_coe_to_fun</code>?</li>
</ul>



<a name="198085325"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/function%20expected/near/198085325" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/function.20expected.html#198085325">(May 19 2020 at 15:43)</a>:</h4>
<p>That's what we do right now?</p>



<a name="198085402"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/function%20expected/near/198085402" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/function.20expected.html#198085402">(May 19 2020 at 15:43)</a>:</h4>
<p>It's just that instance search doesn't work (for no good reason) if the type contains metavariables.</p>



<a name="198086047"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/function%20expected/near/198086047" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/function.20expected.html#198086047">(May 19 2020 at 15:48)</a>:</h4>
<p>I'm not sure there is no good reason, but I also don't remember the exact supposed reason.</p>



<a name="198087613"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/function%20expected/near/198087613" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/function.20expected.html#198087613">(May 19 2020 at 15:58)</a>:</h4>
<p><a href="https://github.com/leanprover-community/lean/issues/251">lean#251</a> ?</p>



<a name="198088875"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/function%20expected/near/198088875" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/function.20expected.html#198088875">(May 19 2020 at 16:07)</a>:</h4>
<p>Allowing mvars in the input problem sounds like a bad idea when you have overlapping instances. You really don't want to get a <em>different</em> solution when the elaborator hasn't resolved quite as many arguments as in a similar context.</p>



<a name="198089078"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/function%20expected/near/198089078" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/function.20expected.html#198089078">(May 19 2020 at 16:08)</a>:</h4>
<p>Overlapping instances are always bad.  We're actively removing them from mathlib.</p>



<a name="198089166"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/function%20expected/near/198089166" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/function.20expected.html#198089166">(May 19 2020 at 16:09)</a>:</h4>
<p>There's little difference in doing type class resolution in a polymorphic declaration and then instantiating the polymorphic declaration, or doing typeclass resolution where the type contains a metavariable.</p>



<a name="198089294"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/function%20expected/near/198089294" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/function.20expected.html#198089294">(May 19 2020 at 16:10)</a>:</h4>
<p>Right, this is a good way to look at it.</p>



<a name="198089301"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/function%20expected/near/198089301" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/function.20expected.html#198089301">(May 19 2020 at 16:10)</a>:</h4>
<p>Maybe I should clarify: overlapping instances are ok if they are definitionally equal.  But they cause huge problems if they aren't.</p>



<a name="198089449"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/function%20expected/near/198089449" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/function.20expected.html#198089449">(May 19 2020 at 16:11)</a>:</h4>
<p>In GHC type variables that are bound by the type signature of a polymorphic function are called "rigid type variables", and we should think of metavariables in instance search problems as "rigid" too.</p>



<a name="198089632"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/function%20expected/near/198089632" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/function.20expected.html#198089632">(May 19 2020 at 16:12)</a>:</h4>
<p>At least, certainly the ones which existed prior to instance search. I'm still not entirely sure what Lean 3 implements.</p>



<a name="198089652"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/function%20expected/near/198089652" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/function.20expected.html#198089652">(May 19 2020 at 16:13)</a>:</h4>
<p>From what you describe: rigid = regular.</p>



<a name="198089674"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/function%20expected/near/198089674" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/function.20expected.html#198089674">(May 19 2020 at 16:13)</a>:</h4>
<p>That is, exactly what <a href="https://github.com/leanprover-community/lean/issues/251">lean#251</a> implements.</p>



<a name="198089715"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/function%20expected/near/198089715" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/function.20expected.html#198089715">(May 19 2020 at 16:13)</a>:</h4>
<p>As opposed to temporary?</p>



<a name="198089720"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/function%20expected/near/198089720" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/function.20expected.html#198089720">(May 19 2020 at 16:13)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110043">Gabriel Ebner</span> <a href="#narrow/stream/113488-general/topic/function.20expected/near/198089166">said</a>:</p>
<blockquote>
<p>There's little difference in doing type class resolution in a polymorphic declaration and then instantiating the polymorphic declaration, or doing typeclass resolution where the type contains a metavariable.</p>
</blockquote>
<p>Sure, but I haven't heard of any issues yet where the elaborator applies an unexpected degree of polymorphism. Instanciveness of mvars is super-brittle on the other hand.</p>



<a name="198090189"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/function%20expected/near/198090189" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/function.20expected.html#198090189">(May 19 2020 at 16:17)</a>:</h4>
<p>Anyways, the test looks good! You could also backport <a href="https://github.com/leanprover/lean4/blob/master/tests/elabissues/Reid1.lean">https://github.com/leanprover/lean4/blob/master/tests/elabissues/Reid1.lean</a> but it looks essentially the same. I suspect we won't run into issues in practice, because our <code>has_coe_to_fun</code> instances are (mostly?) for type constructors applied to a bunch of variables, and so don't involve further matching. (We must already have determined the outermost type constructor of <code>e</code> to get to this point, so that we know it's not <code>-&gt;</code>, right?)</p>



<a name="198090220"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/function%20expected/near/198090220" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/function.20expected.html#198090220">(May 19 2020 at 16:17)</a>:</h4>
<p>By polymorphic I mean <code>def foo {α} := ... synthesize `has_one (α × α)` here ...</code>.  Sure, in a small example the user has a bit more control in the sense that we search for <code>has_one (α × α)</code> and not <code>has_one β</code>.  But over a large library, some definition will very likely infer the type class in the most general setting imaginable.</p>



<a name="198090695"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/function%20expected/near/198090695" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/function.20expected.html#198090695">(May 19 2020 at 16:21)</a>:</h4>
<p>I really hope this works in practice! <span aria-label="fingers crossed" class="emoji emoji-1f91e" role="img" title="fingers crossed">:fingers_crossed:</span> This would be way more exciting than a lousy 2x speed increase <span aria-label="upside down" class="emoji emoji-1f643" role="img" title="upside down">:upside_down:</span></p>



<a name="198091820"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/function%20expected/near/198091820" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/function.20expected.html#198091820">(May 19 2020 at 16:29)</a>:</h4>
<p>Ok, I'll build mathlib with the change and see what happens.</p>



<a name="198099782"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/function%20expected/near/198099782" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/function.20expected.html#198099782">(May 19 2020 at 17:24)</a>:</h4>
<p>I tried to drop some of <code>: _ → _</code> and failed.</p>



<a name="198099830"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/function%20expected/near/198099830" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/function.20expected.html#198099830">(May 19 2020 at 17:25)</a>:</h4>
<p>Where?</p>



<a name="198099895"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/function%20expected/near/198099895" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/function.20expected.html#198099895">(May 19 2020 at 17:25)</a>:</h4>
<p>More precisely, I tried to drop <code>: _ → _</code> in line 405 of <code>group_theory/free_monoid_product</code> in the <code>free_monoid_prod</code> branch.</p>



<a name="198100048"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/function%20expected/near/198100048" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/function.20expected.html#198100048">(May 19 2020 at 17:26)</a>:</h4>
<p>Sorry for not using <code>master</code> for the test.</p>



<a name="198100297"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/function%20expected/near/198100297" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/function.20expected.html#198100297">(May 19 2020 at 17:28)</a>:</h4>
<p>I think the test is not whether you can drop <code>: _ → _</code>, but whether you can replace arguments to things that will be coerced to functions by <code>_</code>s.</p>



<a name="198100335"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/function%20expected/near/198100335" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/function.20expected.html#198100335">(May 19 2020 at 17:28)</a>:</h4>
<p>Then we can go and make those arguments implicit.</p>



<a name="198100385"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/function%20expected/near/198100385" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/function.20expected.html#198100385">(May 19 2020 at 17:29)</a>:</h4>
<p>The reason for making them explicit is that otherwise you'll need <code>: _ → _</code> everywhere.</p>



<a name="198100449"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/function%20expected/near/198100449" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/function.20expected.html#198100449">(May 19 2020 at 17:29)</a>:</h4>
<p>And the problem is that the missing argument in my case is <code>[decidable_eq _]</code>.</p>



<a name="198100457"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/function%20expected/near/198100457" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/function.20expected.html#198100457">(May 19 2020 at 17:29)</a>:</h4>
<p>In my experience even adding that <code>: _ → _</code> is not enough</p>



<a name="198100553"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/function%20expected/near/198100553" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/function.20expected.html#198100553">(May 19 2020 at 17:30)</a>:</h4>
<p>Sorry, I meant <code>: α → β</code> with full types for <code>α</code> and <code>β</code>.</p>



<a name="198100683"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/function%20expected/near/198100683" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/function.20expected.html#198100683">(May 19 2020 at 17:31)</a>:</h4>
<p>With <code>pp.all</code> I get the following error:</p>
<div class="codehilite"><pre><span></span><code><span class="n">function</span> <span class="n">expected</span> <span class="n">at</span>
  <span class="bp">@</span><span class="n">free_monoid_product</span><span class="bp">.</span><span class="n">normalized</span><span class="bp">.</span><span class="n">of</span><span class="bp">.</span><span class="o">{</span><span class="n">u_1</span> <span class="n">u_2</span><span class="o">}</span> <span class="n">ι</span> <span class="n">M</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ι</span><span class="o">),</span> <span class="bp">_</span><span class="n">inst_1</span> <span class="n">i</span><span class="o">)</span> <span class="err">?</span><span class="n">m_1</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ι</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">M</span> <span class="n">i</span><span class="o">),</span> <span class="bp">_</span><span class="n">inst_3</span> <span class="n">i</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span>
    <span class="o">(</span><span class="bp">@</span><span class="n">sigma</span><span class="bp">.</span><span class="n">fst</span><span class="bp">.</span><span class="o">{</span><span class="n">u_1</span> <span class="n">u_2</span><span class="o">}</span> <span class="n">ι</span>
       <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ι</span><span class="o">),</span>
          <span class="bp">@</span><span class="n">subtype</span><span class="bp">.</span><span class="o">{</span><span class="n">u_2</span><span class="bp">+</span><span class="mi">1</span><span class="o">}</span> <span class="o">(</span><span class="n">M</span> <span class="n">i</span><span class="o">)</span>
            <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">M</span> <span class="n">i</span><span class="o">),</span> <span class="bp">@</span><span class="n">ne</span><span class="bp">.</span><span class="o">{</span><span class="n">u_2</span><span class="bp">+</span><span class="mi">1</span><span class="o">}</span> <span class="o">(</span><span class="n">M</span> <span class="n">i</span><span class="o">)</span> <span class="n">x</span> <span class="o">(</span><span class="bp">@</span><span class="n">has_one</span><span class="bp">.</span><span class="n">one</span><span class="bp">.</span><span class="o">{</span><span class="n">u_2</span><span class="o">}</span> <span class="o">(</span><span class="n">M</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="bp">@</span><span class="n">monoid</span><span class="bp">.</span><span class="n">to_has_one</span><span class="bp">.</span><span class="o">{</span><span class="n">u_2</span><span class="o">}</span> <span class="o">(</span><span class="n">M</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="bp">_</span><span class="n">inst_1</span> <span class="n">i</span><span class="o">)))))</span>
       <span class="n">a</span><span class="o">)</span>
<span class="n">term</span> <span class="n">has</span> <span class="n">type</span>
  <span class="bp">@</span><span class="n">monoid_hom</span><span class="bp">.</span><span class="o">{</span><span class="n">u_2</span> <span class="o">(</span><span class="n">max</span> <span class="n">u_1</span> <span class="n">u_2</span><span class="o">)}</span>
    <span class="o">(</span><span class="n">M</span>
       <span class="o">(</span><span class="bp">@</span><span class="n">sigma</span><span class="bp">.</span><span class="n">fst</span><span class="bp">.</span><span class="o">{</span><span class="n">u_1</span> <span class="n">u_2</span><span class="o">}</span> <span class="n">ι</span>
          <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ι</span><span class="o">),</span>
             <span class="bp">@</span><span class="n">subtype</span><span class="bp">.</span><span class="o">{</span><span class="n">u_2</span><span class="bp">+</span><span class="mi">1</span><span class="o">}</span> <span class="o">(</span><span class="n">M</span> <span class="n">i</span><span class="o">)</span>
               <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">M</span> <span class="n">i</span><span class="o">),</span>
                  <span class="bp">@</span><span class="n">ne</span><span class="bp">.</span><span class="o">{</span><span class="n">u_2</span><span class="bp">+</span><span class="mi">1</span><span class="o">}</span> <span class="o">(</span><span class="n">M</span> <span class="n">i</span><span class="o">)</span> <span class="n">x</span> <span class="o">(</span><span class="bp">@</span><span class="n">has_one</span><span class="bp">.</span><span class="n">one</span><span class="bp">.</span><span class="o">{</span><span class="n">u_2</span><span class="o">}</span> <span class="o">(</span><span class="n">M</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="bp">@</span><span class="n">monoid</span><span class="bp">.</span><span class="n">to_has_one</span><span class="bp">.</span><span class="o">{</span><span class="n">u_2</span><span class="o">}</span> <span class="o">(</span><span class="n">M</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="bp">_</span><span class="n">inst_1</span> <span class="n">i</span><span class="o">)))))</span>
          <span class="n">a</span><span class="o">))</span>
    <span class="o">(</span><span class="bp">@</span><span class="n">free_monoid_product</span><span class="bp">.</span><span class="n">normalized</span><span class="bp">.</span><span class="o">{</span><span class="n">u_1</span> <span class="n">u_2</span><span class="o">}</span> <span class="n">ι</span> <span class="n">M</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ι</span><span class="o">),</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ι</span><span class="o">),</span> <span class="bp">_</span><span class="n">inst_1</span> <span class="n">i</span><span class="o">)</span> <span class="n">i</span><span class="o">))</span>
    <span class="o">((</span><span class="bp">λ</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ι</span><span class="o">),</span> <span class="bp">_</span><span class="n">inst_1</span> <span class="n">i</span><span class="o">)</span>
       <span class="o">(</span><span class="bp">@</span><span class="n">sigma</span><span class="bp">.</span><span class="n">fst</span><span class="bp">.</span><span class="o">{</span><span class="n">u_1</span> <span class="n">u_2</span><span class="o">}</span> <span class="n">ι</span>
          <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ι</span><span class="o">),</span>
             <span class="bp">@</span><span class="n">subtype</span><span class="bp">.</span><span class="o">{</span><span class="n">u_2</span><span class="bp">+</span><span class="mi">1</span><span class="o">}</span> <span class="o">(</span><span class="n">M</span> <span class="n">i</span><span class="o">)</span>
               <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">M</span> <span class="n">i</span><span class="o">),</span>
                  <span class="bp">@</span><span class="n">ne</span><span class="bp">.</span><span class="o">{</span><span class="n">u_2</span><span class="bp">+</span><span class="mi">1</span><span class="o">}</span> <span class="o">(</span><span class="n">M</span> <span class="n">i</span><span class="o">)</span> <span class="n">x</span> <span class="o">(</span><span class="bp">@</span><span class="n">has_one</span><span class="bp">.</span><span class="n">one</span><span class="bp">.</span><span class="o">{</span><span class="n">u_2</span><span class="o">}</span> <span class="o">(</span><span class="n">M</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="bp">@</span><span class="n">monoid</span><span class="bp">.</span><span class="n">to_has_one</span><span class="bp">.</span><span class="o">{</span><span class="n">u_2</span><span class="o">}</span> <span class="o">(</span><span class="n">M</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="bp">_</span><span class="n">inst_1</span> <span class="n">i</span><span class="o">)))))</span>
          <span class="n">a</span><span class="o">))</span>
    <span class="o">(</span><span class="bp">@</span><span class="n">free_monoid_product</span><span class="bp">.</span><span class="n">normalized</span><span class="bp">.</span><span class="n">monoid</span><span class="bp">.</span><span class="o">{</span><span class="n">u_1</span> <span class="n">u_2</span><span class="o">}</span> <span class="n">ι</span> <span class="n">M</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ι</span><span class="o">),</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ι</span><span class="o">),</span> <span class="bp">_</span><span class="n">inst_1</span> <span class="n">i</span><span class="o">)</span> <span class="n">i</span><span class="o">)</span>
       <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ι</span><span class="o">),</span> <span class="err">?</span><span class="n">m_1</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span>
       <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ι</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">M</span> <span class="n">i</span><span class="o">),</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ι</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">M</span> <span class="n">i</span><span class="o">),</span> <span class="bp">_</span><span class="n">inst_3</span> <span class="n">i</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="n">i</span> <span class="n">a</span> <span class="n">b</span><span class="o">))</span>
</code></pre></div>



<a name="198100698"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/function%20expected/near/198100698" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/function.20expected.html#198100698">(May 19 2020 at 17:31)</a>:</h4>
<p>But even this is not enough! Since the problem is exactly that it fails to infer metavariables of <code>e</code> in <code>e x</code> from the expected type of <code>e</code> as a function.</p>



<a name="198100715"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/function%20expected/near/198100715" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/function.20expected.html#198100715">(May 19 2020 at 17:31)</a>:</h4>
<p>It needs to be, for example, <code>(e : equiv a b) x</code>.</p>



<a name="198101082"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/function%20expected/near/198101082" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/function.20expected.html#198101082">(May 19 2020 at 17:34)</a>:</h4>
<p><span class="user-mention" data-user-id="214703">@Yury G. Kudryashov</span> Works for me:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">lemma</span> <span class="n">cons_eq_of_mul</span> <span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">xs</span> <span class="o">:</span> <span class="n">normalized</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">cons</span> <span class="n">a</span> <span class="n">xs</span> <span class="bp">=</span> <span class="n">of</span> <span class="n">M</span> <span class="n">a</span><span class="bp">.</span><span class="mi">1</span> <span class="n">a</span><span class="bp">.</span><span class="mi">2</span> <span class="bp">*</span> <span class="n">xs</span> <span class="o">:=</span>
<span class="k">by</span> <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">of_eq_of&#39;</span><span class="o">,</span> <span class="n">of&#39;_val</span><span class="o">,</span> <span class="n">sigma</span><span class="bp">.</span><span class="n">eta</span><span class="o">],</span> <span class="n">refl</span> <span class="o">}</span>
</code></pre></div>



<a name="198101253"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/function%20expected/near/198101253" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/function.20expected.html#198101253">(May 19 2020 at 17:35)</a>:</h4>
<p>You can also remove fancier arrows:</p>
<div class="codehilite"><pre><span></span><code><span class="bp">@</span><span class="o">[</span><span class="n">ext</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">hom_eq</span> <span class="o">⦃</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">normalized</span> <span class="n">M</span> <span class="bp">→*</span> <span class="n">N</span><span class="o">⦄</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">of</span> <span class="n">M</span> <span class="n">i</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">g</span> <span class="o">(</span><span class="n">of</span> <span class="n">M</span> <span class="n">i</span> <span class="n">x</span><span class="o">))</span> <span class="o">:</span>
  <span class="n">f</span> <span class="bp">=</span> <span class="n">g</span> <span class="o">:</span>
</code></pre></div>



<a name="198101407"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/function%20expected/near/198101407" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/function.20expected.html#198101407">(May 19 2020 at 17:37)</a>:</h4>
<p>Or make some arguments implicit:</p>
<div class="codehilite"><pre><span></span><code><span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">lift_of</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">i</span><span class="o">,</span> <span class="n">M</span> <span class="n">i</span> <span class="bp">→*</span> <span class="n">N</span><span class="o">)</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ι</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">M</span> <span class="n">i</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">lift</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">f</span> <span class="o">(</span><span class="n">of</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="bp">_</span> <span class="n">x</span> <span class="o">:=</span>
</code></pre></div>



<a name="198101528"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/function%20expected/near/198101528" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/function.20expected.html#198101528">(May 19 2020 at 17:38)</a>:</h4>
<p>Sorry, I created a branch but didn't switch to it.</p>



<a name="198101604"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/function%20expected/near/198101604" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/function.20expected.html#198101604">(May 19 2020 at 17:38)</a>:</h4>
<p>Rebuilding</p>



<a name="198101706"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/function%20expected/near/198101706" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/function.20expected.html#198101706">(May 19 2020 at 17:39)</a>:</h4>
<p>Just to make this clear: this is with <a href="https://github.com/leanprover-community/lean/issues/251">lean#251</a></p>



<a name="198103686"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/function%20expected/near/198103686" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/function.20expected.html#198103686">(May 19 2020 at 17:55)</a>:</h4>
<p><span class="user-mention" data-user-id="110024">@Sebastian Ullrich</span> You should hurry up with Lean 4, because Gabriel is solving all issues of Lean 3 without waiting.</p>



<a name="198103967"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/function%20expected/near/198103967" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/function.20expected.html#198103967">(May 19 2020 at 17:57)</a>:</h4>
<p>It works!!</p>



<a name="198287206"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/function%20expected/near/198287206" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/function.20expected.html#198287206">(May 21 2020 at 05:08)</a>:</h4>
<p>This is really cool! As in: <span aria-label="cool" class="emoji emoji-1f192" role="img" title="cool">:cool:</span></p>



<a name="198287238"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/function%20expected/near/198287238" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/function.20expected.html#198287238">(May 21 2020 at 05:09)</a>:</h4>
<p>Now it's time for me to come back to <code>polynomial</code>s review...</p>



<a name="198287239"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/function%20expected/near/198287239" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/function.20expected.html#198287239">(May 21 2020 at 05:09)</a>:</h4>
<p>But I'm getting headaches of the looming <code>mv_polynomial</code> refactor that is waiting for us now that we can have readable ring_hom versions of <code>C</code>, <code>eval</code>, <code>eval\2</code>, <code>map</code>, <code>rename</code>, and all the other friends</p>



<a name="198287279"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/function%20expected/near/198287279" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/function.20expected.html#198287279">(May 21 2020 at 05:10)</a>:</h4>
<p>Hah, great minds think alike... (fools never differ...)</p>



<a name="198287309"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/function%20expected/near/198287309" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/function.20expected.html#198287309">(May 21 2020 at 05:11)</a>:</h4>
<p>It's really crazy how big the difference is between lean 3.11 (last week) and lean 3.14 (yesterday)</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
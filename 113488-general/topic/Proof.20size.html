---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/Proof.20size.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proof.20size.html">Proof size</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="182374889"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proof%20size/near/182374889" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proof.20size.html#182374889">(Dec 02 2019 at 18:33)</a>:</h4>
<p>This is a meta-question. How would you measure the size of a proof? Consider for instance <code>rat.mul_one</code>, from <code>data/rat/basic.lean</code>. This is a two lines, 111 characters long tactic proof, including a call to <code>simp</code>. </p>
<div class="codehilite"><pre><span></span><span class="kn">protected</span> <span class="kn">theorem</span> <span class="n">mul_one</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">*</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">a</span> <span class="o">:=</span>
<span class="n">num_denom_cases_on&#39;</span> <span class="n">a</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">n</span> <span class="n">d</span> <span class="n">h</span><span class="o">,</span>
<span class="k">by</span> <span class="n">change</span> <span class="o">(</span><span class="mi">1</span><span class="o">:</span><span class="n">ℚ</span><span class="o">)</span> <span class="k">with</span> <span class="mi">1</span> <span class="bp">/.</span> <span class="mi">1</span><span class="bp">;</span> <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">]</span>
</pre></div>


<p>Then try:</p>
<div class="codehilite"><pre><span></span><span class="kn">open</span> <span class="n">tactic</span>
<span class="n">run_cmd</span>
<span class="n">do</span> <span class="n">env</span> <span class="err">←</span> <span class="n">get_env</span><span class="o">,</span>
   <span class="n">decl</span> <span class="err">←</span> <span class="n">env</span><span class="bp">.</span><span class="n">get</span> <span class="bp">`</span><span class="n">rat</span><span class="bp">.</span><span class="n">mul_one</span><span class="o">,</span>
   <span class="n">trace</span> <span class="o">(</span><span class="n">sizeof</span> <span class="err">$</span> <span class="n">to_string</span> <span class="n">decl</span><span class="bp">.</span><span class="n">value</span><span class="o">)</span>

<span class="n">run_cmd</span>
<span class="n">do</span> <span class="n">env</span> <span class="err">←</span> <span class="n">get_env</span><span class="o">,</span>
   <span class="n">decl</span> <span class="err">←</span> <span class="n">env</span><span class="bp">.</span><span class="n">get</span> <span class="bp">`</span><span class="n">rat</span><span class="bp">.</span><span class="n">mul_one</span><span class="o">,</span>
   <span class="k">proof</span> <span class="err">←</span> <span class="n">pp</span> <span class="n">decl</span><span class="bp">.</span><span class="n">value</span><span class="o">,</span>
   <span class="n">trace</span> <span class="o">(</span><span class="n">sizeof</span> <span class="err">$</span> <span class="n">to_string</span> <span class="k">proof</span><span class="o">)</span>
</pre></div>


<p>The first command says this proof is 7751 character long, and the second one says it pretty prints to 2015 characters. How long would you say this proof is? Do you have a better way to ask Lean what it thinks about this?</p>



<a name="182392920"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proof%20size/near/182392920" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proof.20size.html#182392920">(Dec 02 2019 at 21:39)</a>:</h4>
<p>I think the best measure would be something like "number of nodes in the <code>expr</code>"</p>



<a name="182393012"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proof%20size/near/182393012" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proof.20size.html#182393012">(Dec 02 2019 at 21:40)</a>:</h4>
<p>And how would you compute that?</p>



<a name="182393549"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proof%20size/near/182393549" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proof.20size.html#182393549">(Dec 02 2019 at 21:46)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">namespace</span> <span class="n">level</span>
<span class="n">meta</span> <span class="n">def</span> <span class="n">size</span> <span class="o">:</span> <span class="n">level</span> <span class="bp">→</span> <span class="bp">ℕ</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">succ</span> <span class="n">l</span><span class="o">)</span>     <span class="o">:=</span> <span class="n">size</span> <span class="n">l</span> <span class="bp">+</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">max</span> <span class="n">l₁</span> <span class="n">l₂</span><span class="o">)</span>  <span class="o">:=</span> <span class="n">size</span> <span class="n">l₁</span> <span class="bp">+</span> <span class="n">size</span> <span class="n">l₂</span> <span class="bp">+</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">imax</span> <span class="n">l₁</span> <span class="n">l₂</span><span class="o">)</span> <span class="o">:=</span> <span class="n">size</span> <span class="n">l₁</span> <span class="bp">+</span> <span class="n">size</span> <span class="n">l₂</span> <span class="bp">+</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="bp">_</span>            <span class="o">:=</span> <span class="mi">1</span>
<span class="kn">end</span> <span class="n">level</span>

<span class="kn">namespace</span> <span class="n">expr</span>
<span class="n">meta</span> <span class="n">def</span> <span class="n">size</span> <span class="o">:</span> <span class="n">expr</span> <span class="bp">→</span> <span class="bp">ℕ</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">var</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">sort</span> <span class="n">l</span><span class="o">)</span> <span class="o">:=</span> <span class="n">l</span><span class="bp">.</span><span class="n">size</span> <span class="bp">+</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">const</span> <span class="n">n</span> <span class="n">ls</span><span class="o">)</span> <span class="o">:=</span> <span class="n">list</span><span class="bp">.</span><span class="n">sum</span> <span class="o">(</span><span class="n">level</span><span class="bp">.</span><span class="n">size</span> <span class="bp">&lt;</span><span class="err">$</span><span class="bp">&gt;</span> <span class="n">ls</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">mvar</span> <span class="n">n</span> <span class="n">m</span> <span class="n">t</span><span class="o">)</span>   <span class="o">:=</span> <span class="n">size</span> <span class="n">t</span> <span class="bp">+</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">local_const</span> <span class="n">n</span> <span class="n">m</span> <span class="n">bi</span> <span class="n">t</span><span class="o">)</span> <span class="o">:=</span> <span class="n">size</span> <span class="n">t</span> <span class="bp">+</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">app</span> <span class="n">e</span> <span class="n">f</span><span class="o">)</span> <span class="o">:=</span> <span class="n">size</span> <span class="n">e</span> <span class="bp">+</span> <span class="n">size</span> <span class="n">f</span> <span class="bp">+</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">lam</span> <span class="n">n</span> <span class="n">bi</span> <span class="n">e</span> <span class="n">t</span><span class="o">)</span> <span class="o">:=</span> <span class="n">size</span> <span class="n">e</span> <span class="bp">+</span> <span class="n">size</span> <span class="n">t</span> <span class="bp">+</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">pi</span> <span class="n">n</span> <span class="n">bi</span> <span class="n">e</span> <span class="n">t</span><span class="o">)</span> <span class="o">:=</span> <span class="n">size</span> <span class="n">e</span> <span class="bp">+</span> <span class="n">size</span> <span class="n">t</span> <span class="bp">+</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">elet</span> <span class="n">n</span> <span class="n">g</span> <span class="n">e</span> <span class="n">f</span><span class="o">)</span> <span class="o">:=</span> <span class="n">size</span> <span class="n">g</span> <span class="bp">+</span> <span class="n">size</span> <span class="n">e</span> <span class="bp">+</span> <span class="n">size</span> <span class="n">f</span> <span class="bp">+</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">macro</span> <span class="n">d</span> <span class="n">args</span><span class="o">)</span> <span class="o">:=</span> <span class="n">list</span><span class="bp">.</span><span class="n">sum</span> <span class="o">(</span><span class="n">size</span> <span class="bp">&lt;</span><span class="err">$</span><span class="bp">&gt;</span> <span class="n">args</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">1</span>
<span class="kn">end</span> <span class="n">expr</span>

<span class="bp">#</span><span class="kn">eval</span> <span class="n">do</span>
  <span class="n">d</span> <span class="err">←</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">get_decl</span> <span class="bp">``</span><span class="n">rat</span><span class="bp">.</span><span class="n">mul_one</span><span class="o">,</span>
  <span class="n">tactic</span><span class="bp">.</span><span class="n">trace</span> <span class="n">d</span><span class="bp">.</span><span class="n">value</span><span class="bp">.</span><span class="n">size</span> <span class="c1">-- 2256</span>
</pre></div>



<a name="182393595"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proof%20size/near/182393595" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proof.20size.html#182393595">(Dec 02 2019 at 21:47)</a>:</h4>
<p>Then again, this has a tendency to overcount duplicate subproofs. A better count would deduplicate those</p>



<a name="182393809"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proof%20size/near/182393809" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proof.20size.html#182393809">(Dec 02 2019 at 21:50)</a>:</h4>
<p>Would it be easy to deduplicate these? Maybe using Simon's traversing technology and collecting a list of subproofs? I don't know what I'm talking about.</p>



<a name="182395471"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proof%20size/near/182395471" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proof.20size.html#182395471">(Dec 02 2019 at 22:10)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">rat</span>

<span class="kn">namespace</span> <span class="n">level</span>
<span class="n">meta</span> <span class="n">def</span> <span class="n">size</span> <span class="o">:</span> <span class="n">level</span> <span class="bp">→</span> <span class="bp">ℕ</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">succ</span> <span class="n">l</span><span class="o">)</span>     <span class="o">:=</span> <span class="n">size</span> <span class="n">l</span> <span class="bp">+</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">max</span> <span class="n">l₁</span> <span class="n">l₂</span><span class="o">)</span>  <span class="o">:=</span> <span class="n">size</span> <span class="n">l₁</span> <span class="bp">+</span> <span class="n">size</span> <span class="n">l₂</span> <span class="bp">+</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">imax</span> <span class="n">l₁</span> <span class="n">l₂</span><span class="o">)</span> <span class="o">:=</span> <span class="n">size</span> <span class="n">l₁</span> <span class="bp">+</span> <span class="n">size</span> <span class="n">l₂</span> <span class="bp">+</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="bp">_</span>            <span class="o">:=</span> <span class="mi">1</span>

<span class="n">meta</span> <span class="n">def</span> <span class="n">dedup_size_aux</span> <span class="o">:</span> <span class="n">level</span> <span class="bp">→</span> <span class="n">state</span> <span class="o">(</span><span class="n">native</span><span class="bp">.</span><span class="n">rb_set</span> <span class="n">level</span><span class="o">)</span> <span class="bp">ℕ</span> <span class="bp">|</span> <span class="n">l</span> <span class="o">:=</span> <span class="n">do</span>
  <span class="n">s</span> <span class="err">←</span> <span class="n">get</span><span class="o">,</span>
  <span class="k">if</span> <span class="n">s</span><span class="bp">.</span><span class="n">contains</span> <span class="n">l</span> <span class="k">then</span> <span class="n">return</span> <span class="mi">1</span> <span class="k">else</span>
  <span class="k">match</span> <span class="n">l</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="o">(</span><span class="n">succ</span> <span class="n">l</span><span class="o">)</span>     <span class="o">:=</span> <span class="n">do</span>
    <span class="n">n</span> <span class="err">←</span> <span class="n">dedup_size_aux</span> <span class="n">l</span><span class="o">,</span>
    <span class="n">return</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>
  <span class="bp">|</span> <span class="o">(</span><span class="n">max</span> <span class="n">l₁</span> <span class="n">l₂</span><span class="o">)</span>  <span class="o">:=</span> <span class="n">do</span>
    <span class="n">n₁</span> <span class="err">←</span> <span class="n">dedup_size_aux</span> <span class="n">l₁</span><span class="o">,</span>
    <span class="n">n₂</span> <span class="err">←</span> <span class="n">dedup_size_aux</span> <span class="n">l₂</span><span class="o">,</span>
    <span class="n">return</span> <span class="o">(</span><span class="n">n₁</span> <span class="bp">+</span> <span class="n">n₂</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>
  <span class="bp">|</span> <span class="o">(</span><span class="n">imax</span> <span class="n">l₁</span> <span class="n">l₂</span><span class="o">)</span> <span class="o">:=</span> <span class="n">do</span>
    <span class="n">n₁</span> <span class="err">←</span> <span class="n">dedup_size_aux</span> <span class="n">l₁</span><span class="o">,</span>
    <span class="n">n₂</span> <span class="err">←</span> <span class="n">dedup_size_aux</span> <span class="n">l₂</span><span class="o">,</span>
    <span class="n">return</span> <span class="o">(</span><span class="n">n₁</span> <span class="bp">+</span> <span class="n">n₂</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">l</span>            <span class="o">:=</span> <span class="n">return</span> <span class="mi">1</span>
  <span class="kn">end</span> <span class="bp">&lt;*</span> <span class="n">modify</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">s</span><span class="o">,</span> <span class="n">s</span><span class="bp">.</span><span class="n">insert</span> <span class="n">l</span><span class="o">)</span>

<span class="n">meta</span> <span class="n">def</span> <span class="n">dedup_size</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">level</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="o">:=</span>
<span class="n">prod</span><span class="bp">.</span><span class="n">fst</span> <span class="err">$</span> <span class="o">(</span><span class="n">dedup_size_aux</span> <span class="n">l</span><span class="o">)</span><span class="bp">.</span><span class="n">run</span> <span class="err">$</span>
<span class="bp">@</span><span class="n">native</span><span class="bp">.</span><span class="n">mk_rb_set</span> <span class="bp">_</span> <span class="bp">⟨λ</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">level</span><span class="o">,</span> <span class="n">a</span><span class="bp">.</span><span class="n">lt</span> <span class="n">b</span><span class="bp">⟩</span> <span class="bp">_</span>

<span class="kn">end</span> <span class="n">level</span>

<span class="kn">namespace</span> <span class="n">expr</span>
<span class="n">meta</span> <span class="n">def</span> <span class="n">size</span> <span class="o">:</span> <span class="n">expr</span> <span class="bp">→</span> <span class="bp">ℕ</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">var</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">sort</span> <span class="n">l</span><span class="o">)</span> <span class="o">:=</span> <span class="n">l</span><span class="bp">.</span><span class="n">size</span> <span class="bp">+</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">const</span> <span class="n">n</span> <span class="n">ls</span><span class="o">)</span> <span class="o">:=</span> <span class="n">list</span><span class="bp">.</span><span class="n">sum</span> <span class="o">(</span><span class="n">level</span><span class="bp">.</span><span class="n">size</span> <span class="bp">&lt;</span><span class="err">$</span><span class="bp">&gt;</span> <span class="n">ls</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">mvar</span> <span class="n">n</span> <span class="n">m</span> <span class="n">t</span><span class="o">)</span>   <span class="o">:=</span> <span class="n">size</span> <span class="n">t</span> <span class="bp">+</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">local_const</span> <span class="n">n</span> <span class="n">m</span> <span class="n">bi</span> <span class="n">t</span><span class="o">)</span> <span class="o">:=</span> <span class="n">size</span> <span class="n">t</span> <span class="bp">+</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">app</span> <span class="n">e</span> <span class="n">f</span><span class="o">)</span> <span class="o">:=</span> <span class="n">size</span> <span class="n">e</span> <span class="bp">+</span> <span class="n">size</span> <span class="n">f</span> <span class="bp">+</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">lam</span> <span class="n">n</span> <span class="n">bi</span> <span class="n">e</span> <span class="n">t</span><span class="o">)</span> <span class="o">:=</span> <span class="n">size</span> <span class="n">e</span> <span class="bp">+</span> <span class="n">size</span> <span class="n">t</span> <span class="bp">+</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">pi</span> <span class="n">n</span> <span class="n">bi</span> <span class="n">e</span> <span class="n">t</span><span class="o">)</span> <span class="o">:=</span> <span class="n">size</span> <span class="n">e</span> <span class="bp">+</span> <span class="n">size</span> <span class="n">t</span> <span class="bp">+</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">elet</span> <span class="n">n</span> <span class="n">g</span> <span class="n">e</span> <span class="n">f</span><span class="o">)</span> <span class="o">:=</span> <span class="n">size</span> <span class="n">g</span> <span class="bp">+</span> <span class="n">size</span> <span class="n">e</span> <span class="bp">+</span> <span class="n">size</span> <span class="n">f</span> <span class="bp">+</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">macro</span> <span class="n">d</span> <span class="n">args</span><span class="o">)</span> <span class="o">:=</span> <span class="n">list</span><span class="bp">.</span><span class="n">sum</span> <span class="o">(</span><span class="n">size</span> <span class="bp">&lt;</span><span class="err">$</span><span class="bp">&gt;</span> <span class="n">args</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">1</span>

<span class="n">meta</span> <span class="n">def</span> <span class="n">lift</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="n">state</span> <span class="o">(</span><span class="n">native</span><span class="bp">.</span><span class="n">rb_set</span> <span class="n">level</span><span class="o">)</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">state</span> <span class="o">(</span><span class="n">native</span><span class="bp">.</span><span class="n">rb_set</span> <span class="n">level</span> <span class="bp">×</span> <span class="n">native</span><span class="bp">.</span><span class="n">rb_set</span> <span class="n">expr</span><span class="o">)</span> <span class="n">α</span>
<span class="bp">|</span> <span class="bp">⟨</span><span class="n">f</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="bp">⟨λ</span> <span class="bp">⟨</span><span class="n">s</span><span class="o">,</span> <span class="n">t</span><span class="bp">⟩</span><span class="o">,</span> <span class="k">let</span> <span class="bp">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">s&#39;</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">f</span> <span class="n">s</span> <span class="k">in</span> <span class="bp">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">s&#39;</span><span class="o">,</span> <span class="n">t</span><span class="bp">⟩⟩</span>

<span class="n">meta</span> <span class="n">def</span> <span class="n">dedup_size_aux</span> <span class="o">:</span> <span class="n">expr</span> <span class="bp">→</span> <span class="n">state</span> <span class="o">(</span><span class="n">native</span><span class="bp">.</span><span class="n">rb_set</span> <span class="n">level</span> <span class="bp">×</span> <span class="n">native</span><span class="bp">.</span><span class="n">rb_set</span> <span class="n">expr</span><span class="o">)</span> <span class="bp">ℕ</span>
<span class="bp">|</span> <span class="n">e</span> <span class="o">:=</span> <span class="n">do</span>
  <span class="n">s</span> <span class="err">←</span> <span class="n">get</span><span class="o">,</span>
  <span class="k">if</span> <span class="n">s</span><span class="bp">.</span><span class="mi">2</span><span class="bp">.</span><span class="n">contains</span> <span class="n">e</span> <span class="k">then</span> <span class="n">return</span> <span class="mi">1</span> <span class="k">else</span>
  <span class="k">match</span> <span class="n">e</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="o">(</span><span class="n">sort</span> <span class="n">l</span><span class="o">)</span> <span class="o">:=</span> <span class="n">do</span>
    <span class="n">n</span> <span class="err">←</span> <span class="n">lift</span> <span class="n">l</span><span class="bp">.</span><span class="n">dedup_size_aux</span><span class="o">,</span>
    <span class="n">return</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>
  <span class="bp">|</span> <span class="o">(</span><span class="n">const</span> <span class="n">n</span> <span class="n">ls</span><span class="o">)</span> <span class="o">:=</span> <span class="n">do</span>
    <span class="n">ns</span> <span class="err">←</span> <span class="n">list</span><span class="bp">.</span><span class="n">traverse</span> <span class="o">(</span><span class="n">lift</span> <span class="err">∘</span> <span class="n">level</span><span class="bp">.</span><span class="n">dedup_size_aux</span><span class="o">)</span> <span class="n">ls</span><span class="o">,</span>
    <span class="n">return</span> <span class="o">(</span><span class="n">list</span><span class="bp">.</span><span class="n">sum</span> <span class="n">ns</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>
  <span class="bp">|</span> <span class="o">(</span><span class="n">mvar</span> <span class="n">n</span> <span class="n">m</span> <span class="n">t</span><span class="o">)</span> <span class="o">:=</span> <span class="n">do</span>
    <span class="n">n</span> <span class="err">←</span> <span class="n">t</span><span class="bp">.</span><span class="n">dedup_size_aux</span><span class="o">,</span>
    <span class="n">return</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>
  <span class="bp">|</span> <span class="o">(</span><span class="n">local_const</span> <span class="n">n</span> <span class="n">m</span> <span class="n">bi</span> <span class="n">t</span><span class="o">)</span> <span class="o">:=</span> <span class="n">do</span>
    <span class="n">n</span> <span class="err">←</span> <span class="n">t</span><span class="bp">.</span><span class="n">dedup_size_aux</span><span class="o">,</span>
    <span class="n">return</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>
  <span class="bp">|</span> <span class="o">(</span><span class="n">app</span> <span class="n">e</span> <span class="n">f</span><span class="o">)</span> <span class="o">:=</span> <span class="n">do</span>
    <span class="n">n₁</span> <span class="err">←</span> <span class="n">e</span><span class="bp">.</span><span class="n">dedup_size_aux</span><span class="o">,</span>
    <span class="n">n₂</span> <span class="err">←</span> <span class="n">f</span><span class="bp">.</span><span class="n">dedup_size_aux</span><span class="o">,</span>
    <span class="n">return</span> <span class="o">(</span><span class="n">n₁</span> <span class="bp">+</span> <span class="n">n₂</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>
  <span class="bp">|</span> <span class="o">(</span><span class="n">lam</span> <span class="n">n</span> <span class="n">bi</span> <span class="n">e</span> <span class="n">t</span><span class="o">)</span> <span class="o">:=</span> <span class="n">do</span>
    <span class="n">n₁</span> <span class="err">←</span> <span class="n">e</span><span class="bp">.</span><span class="n">dedup_size_aux</span><span class="o">,</span>
    <span class="n">n₂</span> <span class="err">←</span> <span class="n">t</span><span class="bp">.</span><span class="n">dedup_size_aux</span><span class="o">,</span>
    <span class="n">return</span> <span class="o">(</span><span class="n">n₁</span> <span class="bp">+</span> <span class="n">n₂</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>
  <span class="bp">|</span> <span class="o">(</span><span class="n">pi</span> <span class="n">n</span> <span class="n">bi</span> <span class="n">e</span> <span class="n">t</span><span class="o">)</span> <span class="o">:=</span> <span class="n">do</span>
    <span class="n">n₁</span> <span class="err">←</span> <span class="n">e</span><span class="bp">.</span><span class="n">dedup_size_aux</span><span class="o">,</span>
    <span class="n">n₂</span> <span class="err">←</span> <span class="n">t</span><span class="bp">.</span><span class="n">dedup_size_aux</span><span class="o">,</span>
    <span class="n">return</span> <span class="o">(</span><span class="n">n₁</span> <span class="bp">+</span> <span class="n">n₂</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>
  <span class="bp">|</span> <span class="o">(</span><span class="n">elet</span> <span class="n">n</span> <span class="n">g</span> <span class="n">e</span> <span class="n">f</span><span class="o">)</span> <span class="o">:=</span> <span class="n">do</span>
    <span class="n">n₁</span> <span class="err">←</span> <span class="n">g</span><span class="bp">.</span><span class="n">dedup_size_aux</span><span class="o">,</span>
    <span class="n">n₂</span> <span class="err">←</span> <span class="n">e</span><span class="bp">.</span><span class="n">dedup_size_aux</span><span class="o">,</span>
    <span class="n">n₃</span>  <span class="err">←</span> <span class="n">f</span><span class="bp">.</span><span class="n">dedup_size_aux</span><span class="o">,</span>
    <span class="n">return</span> <span class="o">(</span><span class="n">n₁</span> <span class="bp">+</span> <span class="n">n₂</span> <span class="bp">+</span> <span class="n">n₃</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>
  <span class="bp">|</span> <span class="o">(</span><span class="n">macro</span> <span class="n">d</span> <span class="n">args</span><span class="o">)</span> <span class="o">:=</span> <span class="n">do</span>
    <span class="n">ns</span> <span class="err">←</span> <span class="n">list</span><span class="bp">.</span><span class="n">traverse</span> <span class="n">dedup_size_aux</span> <span class="n">args</span><span class="o">,</span>
    <span class="n">return</span> <span class="o">(</span><span class="n">list</span><span class="bp">.</span><span class="n">sum</span> <span class="n">ns</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>
  <span class="bp">|</span> <span class="bp">_</span> <span class="o">:=</span> <span class="n">return</span> <span class="mi">1</span>
  <span class="kn">end</span> <span class="bp">&lt;*</span> <span class="n">modify</span> <span class="o">(</span><span class="bp">λ</span> <span class="bp">⟨</span><span class="n">s₁</span><span class="o">,</span> <span class="n">s₂</span><span class="bp">⟩</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">s₁</span><span class="o">,</span> <span class="n">s₂</span><span class="bp">.</span><span class="n">insert</span> <span class="n">e</span><span class="bp">⟩</span><span class="o">)</span>

<span class="n">meta</span> <span class="n">def</span> <span class="n">dedup_size</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">expr</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="o">:=</span>
<span class="n">prod</span><span class="bp">.</span><span class="n">fst</span> <span class="err">$</span> <span class="o">(</span><span class="n">dedup_size_aux</span> <span class="n">e</span><span class="o">)</span><span class="bp">.</span><span class="n">run</span>
<span class="o">(</span><span class="bp">@</span><span class="n">native</span><span class="bp">.</span><span class="n">mk_rb_set</span> <span class="bp">_</span> <span class="bp">⟨λ</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">level</span><span class="o">,</span> <span class="n">a</span><span class="bp">.</span><span class="n">lt</span> <span class="n">b</span><span class="bp">⟩</span> <span class="bp">_</span><span class="o">,</span>
 <span class="bp">@</span><span class="n">native</span><span class="bp">.</span><span class="n">mk_rb_set</span> <span class="bp">_</span> <span class="bp">⟨λ</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">expr</span><span class="o">,</span> <span class="n">a</span><span class="bp">.</span><span class="n">lt</span> <span class="n">b</span><span class="bp">⟩</span> <span class="bp">_</span><span class="o">)</span>
<span class="kn">end</span> <span class="n">expr</span>

<span class="bp">#</span><span class="kn">eval</span> <span class="n">do</span>
  <span class="n">d</span> <span class="err">←</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">get_decl</span> <span class="bp">``</span><span class="n">rat</span><span class="bp">.</span><span class="n">mul_one</span><span class="o">,</span>
  <span class="n">tactic</span><span class="bp">.</span><span class="n">trace</span> <span class="n">d</span><span class="bp">.</span><span class="n">value</span><span class="bp">.</span><span class="n">size</span> <span class="c1">-- 2256</span>

<span class="bp">#</span><span class="kn">eval</span> <span class="n">do</span>
  <span class="n">d</span> <span class="err">←</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">get_decl</span> <span class="bp">``</span><span class="n">rat</span><span class="bp">.</span><span class="n">mul_one</span><span class="o">,</span>
  <span class="n">tactic</span><span class="bp">.</span><span class="n">trace</span> <span class="n">d</span><span class="bp">.</span><span class="n">value</span><span class="bp">.</span><span class="n">dedup_size</span> <span class="c1">-- 633</span>
</pre></div>



<a name="182397164"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proof%20size/near/182397164" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proof.20size.html#182397164">(Dec 02 2019 at 22:33)</a>:</h4>
<p>Thank you very much! I'll need time to decipher this, but first I must sleep...</p>



<a name="286367521"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proof%20size/near/286367521" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proof.20size.html#286367521">(Jun 16 2022 at 15:13)</a>:</h4>
<p>I'd be mildly interested to see a timeseries of the median proof size in Mathlib for some longish history (sampled monthly, say). Is that easy to generate?</p>



<a name="286367658"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proof%20size/near/286367658" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proof.20size.html#286367658">(Jun 16 2022 at 15:14)</a>:</h4>
<p>(I emphasise <em>mildly</em>, nobody should go to trouble over this.)</p>



<a name="286452762"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proof%20size/near/286452762" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arndt Schnabel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proof.20size.html#286452762">(Jun 17 2022 at 06:57)</a>:</h4>
<p>I once did something similar for Metamaths' <a href="https://github.com/metamath/set.mm#readme">set.mm</a>, it definitely looks cool: <a href="https://github.com/void4/mmplot#readme">https://github.com/void4/mmplot#readme</a> <a href="/user_uploads/3121/LLzQ2P-MER8T1gzUEUMZyfL1/image.png">log of expanded (including duplicate) number of proof steps vs number of subtheorems</a> :)</p>
<div class="message_inline_image"><a href="/user_uploads/3121/LLzQ2P-MER8T1gzUEUMZyfL1/image.png" title="log of expanded (including duplicate) number of proof steps vs number of subtheorems"><img src="/user_uploads/3121/LLzQ2P-MER8T1gzUEUMZyfL1/image.png"></a></div>



<a name="286462973"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proof%20size/near/286462973" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arndt Schnabel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proof.20size.html#286462973">(Jun 17 2022 at 08:58)</a>:</h4>
<p>Going through the natural number game, it might be neat to visualize what the "induction depths" of the proofs are! Say, the expression <code>0^succ(0)</code> seems to require 4 levels (definition of natural numbers, addition, multiplication and power). What "level of induction" are modern mathematical proofs on?!</p>



<a name="286463447"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proof%20size/near/286463447" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proof.20size.html#286463447">(Jun 17 2022 at 09:03)</a>:</h4>
<p>Some proofs do require nested inductions (the commutativity of addition is a famous example), but anything about concrete natural numbers like <code>0 ^ 1</code> doesn't because we can just use the definitional equations a bunch of times. (On the other hand, sometimes induction can be used to speed up a proof that can be done without it: <code>0 ^ 1000</code> can be evaluated to <code>1</code> with no inductions by using <code>pow_succ</code> 1000 times, or with one level of induction by proving <code>0 ^ (n+1) = 1</code>.)</p>



<a name="286464713"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proof%20size/near/286464713" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arndt Schnabel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proof.20size.html#286464713">(Jun 17 2022 at 09:16)</a>:</h4>
<p>Not sure how easily this is possible in Lean, but seeing the number of <code>induction</code> tactics the verifier encounters while checking the full (deduplicated) dependency DAG would be interesting to plot for all proofs in the database!</p>



<a name="286466787"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proof%20size/near/286466787" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proof.20size.html#286466787">(Jun 17 2022 at 09:35)</a>:</h4>
<p>yes, that sounds doable</p>



<a name="286475517"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proof%20size/near/286475517" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proof.20size.html#286475517">(Jun 17 2022 at 11:17)</a>:</h4>
<p>Here's an approximate implementation of how many "nested inductions" are needed to prove a theorem. It's too slow to run on all of mathlib, but I've run it on some of the core theorems from NNG:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic.core</span>
<span class="kn">open</span> <span class="n">tactic</span>

<span class="kd">meta</span> <span class="kd">mutual</span> <span class="kd">def</span> <span class="n">get_expr_depth</span><span class="o">,</span> <span class="n">get_const_depth</span>
  <span class="o">(</span><span class="n">env</span> <span class="o">:</span> <span class="n">environment</span><span class="o">)</span> <span class="o">(</span><span class="n">consts</span> <span class="o">:</span> <span class="n">ref</span> <span class="o">(</span><span class="n">name_map</span> <span class="o">(</span><span class="n">bool</span> <span class="bp">×</span> <span class="n">ℕ</span><span class="o">)))</span> <span class="o">(</span><span class="n">exprs</span> <span class="o">:</span> <span class="n">ref</span> <span class="o">(</span><span class="n">expr_map</span> <span class="o">(</span><span class="n">bool</span> <span class="bp">×</span> <span class="n">ℕ</span><span class="o">)))</span>
<span class="k">with</span> <span class="n">get_expr_depth</span> <span class="o">:</span> <span class="n">expr</span> <span class="bp">→</span> <span class="n">tactic</span> <span class="o">(</span><span class="n">bool</span> <span class="bp">×</span> <span class="n">ℕ</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">e</span> <span class="o">:=</span> <span class="k">do</span>
  <span class="n">s</span> <span class="bp">←</span> <span class="n">read_ref</span> <span class="n">exprs</span><span class="o">,</span>
  <span class="k">match</span> <span class="n">s.find</span> <span class="n">e</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">some</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">pure</span> <span class="n">n</span>
  <span class="bp">|</span> <span class="n">none</span> <span class="o">:=</span> <span class="k">do</span>
    <span class="k">let</span> <span class="o">(</span><span class="n">f</span><span class="o">,</span> <span class="n">es</span><span class="o">)</span> <span class="o">:=</span> <span class="n">e.get_app_fn_args</span><span class="o">,</span>
    <span class="n">b</span> <span class="bp">←</span> <span class="n">es.mfoldl</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="n">e</span><span class="o">,</span> <span class="o">(</span><span class="n">max</span> <span class="n">x</span> <span class="bp">∘</span> <span class="n">prod.snd</span><span class="o">)</span> <span class="bp">&lt;$&gt;</span> <span class="n">get_expr_depth</span> <span class="n">e</span><span class="o">)</span> <span class="mi">0</span><span class="o">,</span>
    <span class="n">v</span> <span class="bp">←</span> <span class="k">match</span> <span class="n">f</span> <span class="k">with</span>
    <span class="bp">|</span> <span class="o">(</span><span class="n">expr.const</span> <span class="n">n</span> <span class="n">_</span><span class="o">)</span> <span class="o">:=</span> <span class="k">do</span> <span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">a</span><span class="o">)</span> <span class="bp">←</span> <span class="n">get_const_depth</span> <span class="n">n</span><span class="o">,</span> <span class="n">pure</span> <span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="k">if</span> <span class="n">i</span> <span class="k">then</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span> <span class="k">else</span> <span class="n">max</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span>
    <span class="bp">|</span> <span class="o">(</span><span class="n">expr.lam</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">e</span><span class="o">)</span> <span class="o">:=</span> <span class="k">do</span> <span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">a</span><span class="o">)</span> <span class="bp">←</span> <span class="n">get_expr_depth</span> <span class="n">e</span><span class="o">,</span> <span class="n">pure</span> <span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">max</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span>
    <span class="bp">|</span> <span class="o">(</span><span class="n">expr.elet</span> <span class="n">_</span> <span class="n">_</span> <span class="n">e</span> <span class="n">f</span><span class="o">)</span> <span class="o">:=</span> <span class="k">do</span>
      <span class="o">(</span><span class="n">_</span><span class="o">,</span> <span class="n">a₁</span><span class="o">)</span> <span class="bp">←</span> <span class="n">get_expr_depth</span> <span class="n">e</span><span class="o">,</span>
      <span class="o">(</span><span class="n">_</span><span class="o">,</span> <span class="n">a₂</span><span class="o">)</span> <span class="bp">←</span> <span class="n">get_expr_depth</span> <span class="n">f</span><span class="o">,</span>
      <span class="n">pure</span> <span class="o">(</span><span class="n">ff</span><span class="o">,</span> <span class="n">max</span> <span class="o">(</span><span class="n">max</span> <span class="n">a₁</span> <span class="n">a₂</span><span class="o">)</span> <span class="n">b</span><span class="o">)</span>
    <span class="bp">|</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">pure</span> <span class="o">(</span><span class="n">ff</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span>
    <span class="kd">end</span><span class="o">,</span>
    <span class="n">v</span> <span class="bp">&lt;$</span> <span class="n">write_ref</span> <span class="n">exprs</span> <span class="o">(</span><span class="n">s.insert</span> <span class="n">e</span> <span class="n">v</span><span class="o">)</span>
  <span class="kd">end</span>
<span class="k">with</span> <span class="n">get_const_depth</span> <span class="o">:</span> <span class="n">name</span> <span class="bp">→</span> <span class="n">tactic</span> <span class="o">(</span><span class="n">bool</span> <span class="bp">×</span> <span class="n">ℕ</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">n</span> <span class="o">:=</span> <span class="k">do</span>
  <span class="n">m</span> <span class="bp">←</span> <span class="n">read_ref</span> <span class="n">consts</span><span class="o">,</span>
  <span class="k">match</span> <span class="n">m.find</span> <span class="n">n</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">some</span> <span class="n">sp</span> <span class="o">:=</span> <span class="n">pure</span> <span class="n">sp</span>
  <span class="bp">|</span> <span class="n">none</span> <span class="o">:=</span> <span class="k">do</span>
    <span class="n">d</span> <span class="bp">←</span> <span class="n">env.get</span> <span class="n">n</span><span class="o">,</span>
    <span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span> <span class="bp">←</span> <span class="k">match</span> <span class="n">d</span> <span class="k">with</span>
    <span class="bp">|</span> <span class="o">(</span><span class="n">declaration.defn</span> <span class="n">n</span> <span class="n">us</span> <span class="n">t</span> <span class="n">v</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span> <span class="o">:=</span> <span class="n">get_expr_depth</span> <span class="n">v</span>
    <span class="bp">|</span> <span class="o">(</span><span class="n">declaration.thm</span> <span class="n">n</span> <span class="n">us</span> <span class="n">t</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span> <span class="n">get_expr_depth</span> <span class="n">v.get</span>
    <span class="bp">|</span> <span class="o">(</span><span class="n">declaration.cnst</span> <span class="n">n</span> <span class="n">us</span> <span class="n">t</span> <span class="n">_</span><span class="o">)</span> <span class="o">:=</span> <span class="n">pure</span> <span class="o">(</span><span class="k">if</span> <span class="n">env.is_recursor</span> <span class="n">n</span> <span class="k">then</span> <span class="o">(</span><span class="n">tt</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span> <span class="k">else</span> <span class="o">(</span><span class="n">ff</span><span class="o">,</span> <span class="mi">0</span><span class="o">))</span>
    <span class="bp">|</span> <span class="o">(</span><span class="n">declaration.ax</span> <span class="n">n</span> <span class="n">us</span> <span class="n">t</span><span class="o">)</span> <span class="o">:=</span> <span class="n">pure</span> <span class="o">(</span><span class="k">if</span> <span class="n">env.is_recursor</span> <span class="n">n</span> <span class="k">then</span> <span class="o">(</span><span class="n">tt</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span> <span class="k">else</span> <span class="o">(</span><span class="n">ff</span><span class="o">,</span> <span class="mi">0</span><span class="o">))</span>
    <span class="kd">end</span><span class="o">,</span>
    <span class="n">pure</span> <span class="o">(</span><span class="n">b</span> <span class="bp">&amp;&amp;</span> <span class="n">d.type.pi_codomain.get_app_fn.is_var</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span>
  <span class="kd">end</span>

<span class="kd">run_cmd</span>
  <span class="n">using_new_ref</span> <span class="n">mk_name_map</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">m</span><span class="o">,</span> <span class="n">using_new_ref</span> <span class="o">(</span><span class="n">expr_map.mk</span> <span class="n">_</span><span class="o">)</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">r</span><span class="o">,</span> <span class="k">do</span>
    <span class="n">env</span> <span class="bp">←</span> <span class="n">tactic.get_env</span><span class="o">,</span>
    <span class="o">[</span><span class="bp">``</span><span class="n">nat.rec</span><span class="o">,</span> <span class="bp">``</span><span class="n">nat.rec_on</span><span class="o">,</span> <span class="bp">``</span><span class="n">nat.cases_on</span><span class="o">,</span> <span class="bp">``</span><span class="n">nat.below</span><span class="o">,</span> <span class="bp">``</span><span class="n">nat.brec_on</span><span class="o">,</span>
      <span class="bp">``</span><span class="n">nat.succ</span><span class="o">,</span> <span class="bp">``</span><span class="n">nat.pred</span><span class="o">,</span>
      <span class="bp">``</span><span class="n">nat.add</span><span class="o">,</span> <span class="bp">``</span><span class="n">nat.add_zero</span><span class="o">,</span> <span class="bp">``</span><span class="n">nat.add_succ</span><span class="o">,</span> <span class="bp">``</span><span class="n">nat.zero_add</span><span class="o">,</span> <span class="bp">``</span><span class="n">nat.succ_add</span><span class="o">,</span>
      <span class="bp">``</span><span class="n">nat.add_comm</span><span class="o">,</span> <span class="bp">``</span><span class="n">nat.add_assoc</span><span class="o">,</span> <span class="bp">``</span><span class="n">nat.add_left_comm</span><span class="o">,</span>
      <span class="bp">``</span><span class="n">nat.mul</span><span class="o">,</span> <span class="bp">``</span><span class="n">nat.mul_zero</span><span class="o">,</span> <span class="bp">``</span><span class="n">nat.mul_succ</span><span class="o">,</span> <span class="bp">``</span><span class="n">nat.zero_mul</span><span class="o">,</span> <span class="bp">``</span><span class="n">nat.succ_mul</span><span class="o">,</span>
      <span class="bp">``</span><span class="n">nat.right_distrib</span><span class="o">,</span> <span class="bp">``</span><span class="n">nat.mul_comm</span><span class="o">,</span>
      <span class="bp">``</span><span class="n">nat.left_distrib</span><span class="o">,</span> <span class="bp">``</span><span class="n">nat.mul_assoc</span>
    <span class="o">]</span><span class="bp">.</span><span class="n">mmap'</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">d</span><span class="o">,</span> <span class="k">do</span>
      <span class="o">(</span><span class="n">_</span><span class="o">,</span> <span class="n">n</span><span class="o">)</span> <span class="bp">←</span> <span class="n">get_const_depth</span> <span class="n">env</span> <span class="n">m</span> <span class="n">r</span> <span class="n">d</span><span class="o">,</span>
      <span class="n">trace</span> <span class="o">(</span><span class="n">d</span><span class="o">,</span> <span class="n">n</span><span class="o">))</span>
</code></pre></div>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="o">(</span><span class="n">nat.rec</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span>
<span class="o">(</span><span class="n">nat.rec_on</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span>
<span class="o">(</span><span class="n">nat.cases_on</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span>
<span class="o">(</span><span class="n">nat.below</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span>
<span class="o">(</span><span class="n">nat.brec_on</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>
<span class="o">(</span><span class="n">nat.succ</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span>
<span class="o">(</span><span class="n">nat.pred</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span>
<span class="o">(</span><span class="n">nat.add</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>
<span class="o">(</span><span class="n">nat.add_zero</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>
<span class="o">(</span><span class="n">nat.add_succ</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>
<span class="o">(</span><span class="n">nat.zero_add</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>
<span class="o">(</span><span class="n">nat.succ_add</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>
<span class="o">(</span><span class="n">nat.add_comm</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span>
<span class="o">(</span><span class="n">nat.add_assoc</span><span class="o">,</span> <span class="mi">10</span><span class="o">)</span>
<span class="o">(</span><span class="n">nat.add_left_comm</span><span class="o">,</span> <span class="mi">10</span><span class="o">)</span>
<span class="o">(</span><span class="n">nat.mul</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>
<span class="o">(</span><span class="n">nat.mul_zero</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>
<span class="o">(</span><span class="n">nat.mul_succ</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>
<span class="o">(</span><span class="n">nat.zero_mul</span><span class="o">,</span> <span class="mi">11</span><span class="o">)</span>
<span class="o">(</span><span class="n">nat.succ_mul</span><span class="o">,</span> <span class="mi">15</span><span class="o">)</span>
<span class="o">(</span><span class="n">nat.right_distrib</span><span class="o">,</span> <span class="mi">15</span><span class="o">)</span>
<span class="o">(</span><span class="n">nat.mul_comm</span><span class="o">,</span> <span class="mi">18</span><span class="o">)</span>
<span class="o">(</span><span class="n">nat.left_distrib</span><span class="o">,</span> <span class="mi">18</span><span class="o">)</span>
<span class="o">(</span><span class="n">nat.mul_assoc</span><span class="o">,</span> <span class="mi">21</span><span class="o">)</span>
</code></pre></div>



<a name="286475755"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proof%20size/near/286475755" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proof.20size.html#286475755">(Jun 17 2022 at 11:20)</a>:</h4>
<p>These numbers are probably a lot larger than you might expect. Part of that is because the method is pessimistic when it comes to definitions that look like recursors with arguments in weird places that have more recursors in them, and the other part is that lean uses some "unnecessary" recursions to do some of its definitions, especially anything written with the equation compiler - these always go through <code>nat.brec_on</code> which itself requires a nested induction to define, which means for example that <code>nat.add</code> needs two nested inductions to define</p>



<a name="286482334"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proof%20size/near/286482334" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Johnson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proof.20size.html#286482334">(Jun 17 2022 at 12:29)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113488-general/topic/Proof.20size/near/286463447">said</a>:</p>
<blockquote>
<p>Some proofs do require nested inductions (the commutativity of addition is a famous example).</p>
</blockquote>
<p>Your algorithm doesn't agree with that :)</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">nat.add_comm'</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">+</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">m</span> <span class="o">:=</span> <span class="k">let</span> <span class="n">r</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">nat.rec_on</span> <span class="k">in</span>
<span class="kd">begin</span>
  <span class="n">apply</span> <span class="n">r</span> <span class="n">n</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">apply</span> <span class="n">r</span> <span class="n">m</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">refl</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">rintro</span> <span class="n">n</span> <span class="n">h</span><span class="o">,</span> <span class="n">change</span> <span class="n">n.succ</span> <span class="bp">=</span> <span class="o">(</span><span class="mi">0</span> <span class="bp">+</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">succ</span><span class="o">,</span> <span class="n">rw</span> <span class="bp">←</span><span class="n">h</span><span class="o">,</span> <span class="n">refl</span> <span class="o">}},</span>
  <span class="o">{</span> <span class="k">have</span> <span class="n">h₁</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">m.succ</span> <span class="bp">+</span> <span class="n">n</span> <span class="bp">=</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">succ</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">rintro</span> <span class="n">m</span> <span class="n">n</span><span class="o">,</span> <span class="n">apply</span> <span class="n">r</span> <span class="n">n</span><span class="o">,</span>
      <span class="o">{</span> <span class="n">refl</span> <span class="o">},</span>
      <span class="o">{</span> <span class="n">rintro</span> <span class="n">n</span> <span class="n">h</span><span class="o">,</span> <span class="n">change</span> <span class="o">(</span><span class="n">m.succ</span> <span class="bp">+</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">succ</span> <span class="bp">=</span> <span class="n">_</span><span class="o">,</span> <span class="n">rw</span> <span class="n">h</span><span class="o">,</span> <span class="n">refl</span> <span class="o">}},</span>
    <span class="n">rintro</span> <span class="n">n</span> <span class="n">h</span><span class="o">,</span> <span class="n">rw</span> <span class="o">[</span><span class="n">h₁</span><span class="o">,</span> <span class="bp">←</span><span class="n">h</span><span class="o">],</span> <span class="n">refl</span><span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>
<p>It says <code>(nat.add_comm', 1)</code></p>



<a name="286491080"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proof%20size/near/286491080" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proof.20size.html#286491080">(Jun 17 2022 at 13:45)</a>:</h4>
<p>That's why I said it's an approximation. It's actually pretty hard to get a straight answer to how many inductions there are in a thing when you can create higher order functions that might be hiding an induction and apply them an unbounded number of times</p>



<a name="286491227"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proof%20size/near/286491227" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proof.20size.html#286491227">(Jun 17 2022 at 13:46)</a>:</h4>
<p>It is a lot easier to do this analysis over, say, PA where you have to explicitly apply the induction axiom (although it is still hard to count whether one induction proof is "nested inside" another)</p>



<a name="286491420"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proof%20size/near/286491420" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proof.20size.html#286491420">(Jun 17 2022 at 13:48)</a>:</h4>
<p>Gentzen's proof of consistency of PA actually does this kind of accounting, but the nesting depths correspond not to natural numbers but to ordinals less than <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ϵ</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">\epsilon_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">ϵ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p>



<a name="286491560"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proof%20size/near/286491560" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proof.20size.html#286491560">(Jun 17 2022 at 13:49)</a>:</h4>
<p>In lean I think you can make much more fearsome inductive proofs, which unfold to a transfinitely nested application of the induction axiom</p>



<a name="286508996"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proof%20size/near/286508996" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arndt Schnabel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proof.20size.html#286508996">(Jun 17 2022 at 15:57)</a>:</h4>
<p>Another question: With algorithms, a <a href="https://en.wikipedia.org/wiki/Space%E2%80%93time_tradeoff">space-time tradeoff</a> is often possible. Has something similar been observed with proofs (e.g. for proof length or depth), with more abstract 'resources' as tradeable parameters (e.g. like the number of induction tactics used)?</p>



<a name="286510940"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proof%20size/near/286510940" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arndt Schnabel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proof.20size.html#286510940">(Jun 17 2022 at 16:11)</a>:</h4>
<p>I'm not sure if such noob/crank deliberations are welcome here, but I've always wondered how mathematicians reason about "proof space", and if anything can be metamathematically proven about it.</p>
<p>Mathematicians reason about proof space in practice <em>somehow</em>, but problems like</p>
<blockquote>
<p>Q: Given a set of proofs, is it possible to estimate the deduction distance and other properties of yet unproven statements, saving resources during the proof search?</p>
</blockquote>
<p>are in the most general case impossible to automate.</p>
<blockquote>
<p>A: For all but the simplest systems and properties, the problem of telling whether a formula has that property with respect to that system is undecidable; and even for very simple systems and properties, this problem is almost always computationally infeasible.</p>
</blockquote>
<p>from: <a href="https://math.stackexchange.com/questions/3477810/estimating-meta-mathematical-properties-of-conjectures">https://math.stackexchange.com/questions/3477810/estimating-meta-mathematical-properties-of-conjectures</a></p>
<p>Yet, mathematicians do it. Intuitions like "this unsolved problem is hard" can be approximated through social knowledge ('many have tried and failed') or own failed attempts ('it's difficult to approach/reason about this', 'i'm lacking knowledge'). Unlike programming, there are no syntactic or semantic limits, so it must be extremely difficult to judge something like the proof complexity/depth of an unsolved problem in advance. Yet, could there be <em>provably</em> accurate heuristics?</p>



<a name="286513451"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proof%20size/near/286513451" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proof.20size.html#286513451">(Jun 17 2022 at 16:33)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113488-general/topic/Proof.20size/near/286491227">said</a>:</p>
<blockquote>
<p>It is a lot easier to do this analysis over, say, PA where you have to explicitly apply the induction axiom (although it is still hard to count whether one induction proof is "nested inside" another)</p>
</blockquote>
<p>IIRC you only need a single (obviously non-nested) induction in PA (though you're getting more quantifiers in the induction formula as a tradeoff).</p>



<a name="286518817"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proof%20size/near/286518817" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proof.20size.html#286518817">(Jun 17 2022 at 17:21)</a>:</h4>
<p>Hm, that's interesting. Do you have a reference, or a sketch for how to e.g. prove the ackermann function exists without using two nested inductions?</p>



<a name="286522564"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proof%20size/near/286522564" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proof.20size.html#286522564">(Jun 17 2022 at 17:53)</a>:</h4>
<p>Ah, I got it:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">constant</span> <span class="n">A</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="kd">axiom</span> <span class="n">A_0</span> <span class="o">:</span> <span class="n">A</span> <span class="mi">0</span> <span class="mi">0</span>
<span class="kd">axiom</span> <span class="n">A_0_succ</span> <span class="o">{</span><span class="n">n</span><span class="o">}</span> <span class="o">:</span> <span class="n">A</span> <span class="mi">0</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">A</span> <span class="mi">0</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>
<span class="kd">axiom</span> <span class="n">A_succ_0</span> <span class="o">{</span><span class="n">m</span><span class="o">}</span> <span class="o">:</span> <span class="n">A</span> <span class="n">m</span> <span class="mi">1</span> <span class="bp">→</span> <span class="n">A</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="mi">0</span>
<span class="kd">axiom</span> <span class="n">A_succ_succ</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span><span class="o">}</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">A</span> <span class="n">m</span> <span class="n">n</span><span class="o">)</span> <span class="bp">→</span> <span class="n">A</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">A</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>

<span class="kd">theorem</span> <span class="n">ack</span> <span class="o">(</span><span class="n">m</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">A</span> <span class="n">m</span> <span class="n">n</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">have</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span>
    <span class="n">A</span> <span class="mi">0</span> <span class="n">n</span> <span class="bp">∧</span>
    <span class="o">(</span><span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">b</span><span class="o">,</span> <span class="n">A</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="bp">→</span> <span class="n">A</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">n</span><span class="o">)</span> <span class="bp">∧</span>
    <span class="o">((</span><span class="bp">∀</span> <span class="n">b</span><span class="o">,</span> <span class="n">A</span> <span class="mi">0</span> <span class="n">b</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">b</span><span class="o">,</span> <span class="n">A</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">∀</span> <span class="n">b</span><span class="o">,</span> <span class="n">A</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">b</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">∀</span> <span class="n">b</span><span class="o">,</span> <span class="n">A</span> <span class="n">n</span> <span class="n">b</span><span class="o">),</span>
  <span class="o">{</span> <span class="n">intro</span> <span class="n">n</span><span class="o">,</span> <span class="n">induction</span> <span class="n">n</span> <span class="k">with</span> <span class="n">n</span> <span class="n">IH</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="o">⟨</span><span class="n">A_0</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">h1</span><span class="o">,</span> <span class="n">A_succ_0</span> <span class="o">(</span><span class="n">h1</span> <span class="n">_</span><span class="o">),</span> <span class="bp">λ</span> <span class="n">h1</span> <span class="n">h2</span><span class="o">,</span> <span class="n">h1</span><span class="o">⟩</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">obtain</span> <span class="o">⟨</span><span class="n">IH1</span><span class="o">,</span> <span class="n">IH2</span><span class="o">,</span> <span class="n">IH3</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">IH</span><span class="o">,</span>
      <span class="n">exact</span> <span class="o">⟨</span><span class="n">A_0_succ</span> <span class="n">IH1</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">h1</span><span class="o">,</span> <span class="n">A_succ_succ</span> <span class="n">h1</span> <span class="o">(</span><span class="n">IH2</span> <span class="n">_</span> <span class="n">h1</span><span class="o">),</span> <span class="bp">λ</span> <span class="n">h1</span> <span class="n">h2</span><span class="o">,</span> <span class="n">h2</span> <span class="n">_</span> <span class="o">(</span><span class="n">IH3</span> <span class="n">h1</span> <span class="n">h2</span><span class="o">)⟩</span> <span class="o">}</span> <span class="o">},</span>
  <span class="n">exact</span> <span class="o">(</span><span class="n">this</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span><span class="bp">.</span><span class="mi">2</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">n</span><span class="o">,</span> <span class="o">(</span><span class="n">this</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span> <span class="n">h1</span> <span class="n">b</span><span class="o">,</span> <span class="o">(</span><span class="n">this</span> <span class="n">b</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span><span class="bp">.</span><span class="mi">1</span> <span class="n">_</span> <span class="n">h1</span><span class="o">)</span> <span class="n">_</span>
<span class="kd">end</span>
</code></pre></div>



<a name="286523008"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proof%20size/near/286523008" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proof.20size.html#286523008">(Jun 17 2022 at 17:56)</a>:</h4>
<p>for comparison here's the "obvious" proof using nested inductions:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">ack</span> <span class="o">(</span><span class="n">m</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">A</span> <span class="n">m</span> <span class="n">n</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">induction</span> <span class="n">m</span> <span class="k">with</span> <span class="n">m</span> <span class="n">IH</span> <span class="n">generalizing</span> <span class="n">n</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">induction</span> <span class="n">n</span> <span class="k">with</span> <span class="n">n</span> <span class="n">ih</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">A_0</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">A_0_succ</span> <span class="n">ih</span> <span class="o">}</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">induction</span> <span class="n">n</span> <span class="k">with</span> <span class="n">n</span> <span class="n">ih</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">A_succ_0</span> <span class="o">(</span><span class="n">IH</span> <span class="n">_</span><span class="o">)</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">A_succ_succ</span> <span class="n">IH</span> <span class="n">ih</span> <span class="o">}</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>



<a name="286532055"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proof%20size/near/286532055" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proof.20size.html#286532055">(Jun 17 2022 at 19:17)</a>:</h4>
<p>It's a fairly trivial observation.  You just make a big conjunction (essentially).  My advisor used to point this out all the time, here's a paper with that observation among other stuff: <a href="https://lmcs.episciences.org/4071">https://lmcs.episciences.org/4071</a></p>



<a name="286536759"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proof%20size/near/286536759" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proof.20size.html#286536759">(Jun 17 2022 at 20:06)</a>:</h4>
<p>The part that I was struggling with was how to do a bunch of inductions where the result of one depends on having done another part of the proof. The solution is to add these parts as additional hypotheses in the implication (these are the hypotheses in the third conjunct of the IH in the example) and stitch everything back together after the induction proof.</p>



<a name="286627744"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proof%20size/near/286627744" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Johnson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proof.20size.html#286627744">(Jun 18 2022 at 04:25)</a>:</h4>
<p>Interesting. It means the commutativity of addition can also be proved using only one induction without "cheating"</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">nat.add_comm'</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">+</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">m</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">have</span> <span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="o">(</span><span class="mi">0</span> <span class="bp">+</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">b.succ</span> <span class="bp">+</span> <span class="n">a</span> <span class="bp">=</span> <span class="o">(</span><span class="n">b</span> <span class="bp">+</span> <span class="n">a</span><span class="o">)</span><span class="bp">.</span><span class="n">succ</span><span class="o">)</span> <span class="bp">∧</span>
    <span class="bp">∀</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="mi">0</span> <span class="bp">+</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">b.succ</span> <span class="bp">+</span> <span class="n">a</span> <span class="bp">=</span> <span class="o">(</span><span class="n">b</span> <span class="bp">+</span> <span class="n">a</span><span class="o">)</span><span class="bp">.</span><span class="n">succ</span><span class="o">)</span> <span class="bp">→</span>
    <span class="n">b</span> <span class="bp">+</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intro</span> <span class="n">a</span><span class="o">,</span> <span class="n">induction</span> <span class="n">a</span> <span class="k">with</span> <span class="n">a</span> <span class="n">ih</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="o">⟨</span><span class="n">rfl</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">b</span><span class="o">,</span> <span class="n">rfl</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">b</span> <span class="n">h</span> <span class="n">_</span><span class="o">,</span> <span class="o">(</span><span class="n">h</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="o">⟩</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">rcases</span> <span class="n">ih</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">ih₁</span><span class="o">,</span> <span class="n">ih₂</span><span class="o">,</span> <span class="n">ih₃</span><span class="o">⟩,</span> <span class="n">refine</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">b</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">b</span> <span class="n">h₁</span> <span class="n">h₂</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
      <span class="o">{</span> <span class="n">change</span> <span class="o">(</span><span class="mi">0</span> <span class="bp">+</span> <span class="n">a</span><span class="o">)</span><span class="bp">.</span><span class="n">succ</span> <span class="bp">=</span> <span class="n">_</span><span class="o">,</span> <span class="n">rw</span> <span class="n">ih₁</span> <span class="o">},</span>
      <span class="o">{</span> <span class="n">change</span> <span class="o">(</span><span class="n">b.succ</span> <span class="bp">+</span> <span class="n">a</span><span class="o">)</span><span class="bp">.</span><span class="n">succ</span> <span class="bp">=</span> <span class="n">_</span><span class="o">,</span> <span class="n">rw</span> <span class="n">ih₂</span><span class="o">,</span> <span class="n">refl</span> <span class="o">},</span>
      <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">h₂</span><span class="o">,</span> <span class="bp">←</span><span class="n">ih₃</span> <span class="n">_</span> <span class="n">h₁</span> <span class="n">h₂</span><span class="o">],</span> <span class="n">refl</span> <span class="o">}}},</span>
  <span class="n">exact</span> <span class="o">(</span><span class="n">h</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span><span class="bp">.</span><span class="mi">2</span> <span class="n">_</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="o">(</span><span class="n">h</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="o">(</span><span class="n">h</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span><span class="bp">.</span><span class="mi">1</span> <span class="n">_</span><span class="o">),</span>
<span class="kd">end</span>
</code></pre></div>
<p>Although the algorithm says <code>(nat.add_comm', 10)</code>, probably because we use local proof <code>h</code> multiple times.</p>



<a name="286631473"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proof%20size/near/286631473" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proof.20size.html#286631473">(Jun 18 2022 at 05:44)</a>:</h4>
<p>I think the issue might be that <code>eq.rec</code> counts as a recursion that is nested inside the <code>nat.rec</code> proof</p>



<a name="286631509"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proof%20size/near/286631509" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proof.20size.html#286631509">(Jun 18 2022 at 05:45)</a>:</h4>
<p>using a hypothesis multiple times does not count against you in that method</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/synthesized.20type.20class.20instance.20is.20not.20definitionally.20equal.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/synthesized.20type.20class.20instance.20is.20not.20definitionally.20equal.html">synthesized type class instance is not definitionally equal</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="224589753"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/synthesized%20type%20class%20instance%20is%20not%20definitionally%20equal/near/224589753" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Paul van Wamelen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/synthesized.20type.20class.20instance.20is.20not.20definitionally.20equal.html#224589753">(Jan 30 2021 at 15:17)</a>:</h4>
<p>I'd like to prove the lemma below, but lean doesn't like my statement. Is there a nice way around this problem?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">linear_algebra.determinant</span>

<span class="kd">noncomputable theory</span>
<span class="n">open_locale</span> <span class="n">classical</span>

<span class="kd">universes</span> <span class="n">u</span> <span class="n">v</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">m</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">m</span><span class="o">]</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span>

<span class="kd">def</span> <span class="n">to_square_block</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="n">matrix</span> <span class="n">m</span> <span class="n">m</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">matrix</span> <span class="o">{</span><span class="n">a</span> <span class="bp">//</span> <span class="n">p</span> <span class="n">a</span><span class="o">}</span> <span class="o">{</span><span class="n">a</span> <span class="bp">//</span> <span class="n">p</span> <span class="n">a</span><span class="o">}</span> <span class="n">R</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span> <span class="n">M</span> <span class="bp">↑</span><span class="n">i</span> <span class="bp">↑</span><span class="n">j</span>

<span class="kd">lemma</span> <span class="n">upper_two_block_triangular_det</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="n">matrix</span> <span class="n">m</span> <span class="n">m</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="bp">¬</span><span class="n">p</span> <span class="n">i</span><span class="o">)</span> <span class="n">j</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="n">p</span> <span class="n">j</span><span class="o">),</span> <span class="n">M</span> <span class="n">i</span> <span class="n">j</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">M.det</span> <span class="bp">=</span> <span class="o">(</span><span class="n">to_square_block</span> <span class="n">M</span> <span class="n">p</span><span class="o">)</span><span class="bp">.</span><span class="n">det</span> <span class="bp">*</span> <span class="o">(</span><span class="n">to_square_block</span> <span class="n">M</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="bp">¬</span><span class="o">(</span><span class="n">p</span> <span class="n">i</span><span class="o">)))</span><span class="bp">.</span><span class="n">det</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="gr">sorry</span>
<span class="kd">end</span>
</code></pre></div>
<p>The error I get is:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">synthesized</span> <span class="n">type</span> <span class="kd">class</span> <span class="kd">instance</span> <span class="n">is</span> <span class="n">not</span> <span class="n">definitionally</span> <span class="n">equal</span> <span class="n">to</span> <span class="n">expression</span> <span class="n">inferred</span> <span class="kd">by</span> <span class="n">typing</span> <span class="n">rules</span><span class="o">,</span> <span class="n">synthesized</span>
  <span class="n">subtype.fintype</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">m</span><span class="o">),</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">m</span><span class="o">),</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">m</span><span class="o">),</span> <span class="bp">¬</span><span class="n">p</span> <span class="n">i</span><span class="o">)</span> <span class="n">a</span><span class="o">)</span> <span class="n">x</span><span class="o">)</span>
<span class="n">inferred</span>
  <span class="n">subtype.fintype</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">m</span><span class="o">),</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">m</span><span class="o">),</span> <span class="bp">¬</span><span class="n">p</span> <span class="n">i</span><span class="o">)</span> <span class="n">a</span><span class="o">)</span>
</code></pre></div>
<p>I could do</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">upper_two_block_triangular_det'</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="n">matrix</span> <span class="n">m</span> <span class="n">m</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">q</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">q</span> <span class="bp">=</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="bp">¬</span><span class="o">(</span><span class="n">p</span> <span class="n">i</span><span class="o">)))</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="bp">¬</span><span class="n">p</span> <span class="n">i</span><span class="o">)</span> <span class="n">j</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="n">p</span> <span class="n">j</span><span class="o">),</span> <span class="n">M</span> <span class="n">i</span> <span class="n">j</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">M.det</span> <span class="bp">=</span> <span class="o">(</span><span class="n">to_square_block</span> <span class="n">M</span> <span class="n">p</span><span class="o">)</span><span class="bp">.</span><span class="n">det</span> <span class="bp">*</span> <span class="o">(</span><span class="n">to_square_block</span> <span class="n">M</span> <span class="n">q</span><span class="o">)</span><span class="bp">.</span><span class="n">det</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="gr">sorry</span>
<span class="kd">end</span>
</code></pre></div>
<p>but that seems a bit sad. More generally is there a way of adding some abbreviation\notation like "let <code>q :=</code> ..." into the conclusion of a theorem statement?</p>



<a name="224589926"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/synthesized%20type%20class%20instance%20is%20not%20definitionally%20equal/near/224589926" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/synthesized.20type.20class.20instance.20is.20not.20definitionally.20equal.html#224589926">(Jan 30 2021 at 15:21)</a>:</h4>
<p>Probably adding <code>[decidable_pred p]</code> will solve the issue</p>



<a name="224591360"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/synthesized%20type%20class%20instance%20is%20not%20definitionally%20equal/near/224591360" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/synthesized.20type.20class.20instance.20is.20not.20definitionally.20equal.html#224591360">(Jan 30 2021 at 15:52)</a>:</h4>
<p>I don't think it does. The issue is that mathematics is happening here, and <code>fintype</code> is the natural way to say "this type is finite" but it's not Prop-valued. I think we need a Prop-valued fintype to solve this nicely. Do we have one? I might be wrong about this. The issue seems to be that something is not being beta-reduced in time for type class inference to get unconfused.</p>



<a name="224591455"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/synthesized%20type%20class%20instance%20is%20not%20definitionally%20equal/near/224591455" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/synthesized.20type.20class.20instance.20is.20not.20definitionally.20equal.html#224591455">(Jan 30 2021 at 15:55)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">linear_algebra.determinant</span>

<span class="kd">noncomputable theory</span>
<span class="n">open_locale</span> <span class="n">classical</span>

<span class="kd">universes</span> <span class="n">u</span> <span class="n">v</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">m</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">m</span><span class="o">]</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span>

<span class="kd">def</span> <span class="n">to_square_block</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="n">matrix</span> <span class="n">m</span> <span class="n">m</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_pred</span> <span class="n">p</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">matrix</span> <span class="o">{</span><span class="n">a</span> <span class="bp">//</span> <span class="n">p</span> <span class="n">a</span><span class="o">}</span> <span class="o">{</span><span class="n">a</span> <span class="bp">//</span> <span class="n">p</span> <span class="n">a</span><span class="o">}</span> <span class="n">R</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span> <span class="n">M</span> <span class="bp">↑</span><span class="n">i</span> <span class="bp">↑</span><span class="n">j</span>

<span class="kd">lemma</span> <span class="n">upper_two_block_triangular_det</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="n">matrix</span> <span class="n">m</span> <span class="n">m</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="bp">¬</span><span class="n">p</span> <span class="n">i</span><span class="o">)</span> <span class="n">j</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="n">p</span> <span class="n">j</span><span class="o">),</span> <span class="n">M</span> <span class="n">i</span> <span class="n">j</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">M.det</span> <span class="bp">=</span> <span class="o">(</span><span class="n">to_square_block</span> <span class="n">M</span> <span class="n">p</span><span class="o">)</span><span class="bp">.</span><span class="n">det</span> <span class="bp">*</span> <span class="o">(</span><span class="n">to_square_block</span> <span class="n">M</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="bp">¬</span><span class="o">(</span><span class="n">p</span> <span class="n">i</span><span class="o">)))</span><span class="bp">.</span><span class="n">det</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="gr">sorry</span>
<span class="kd">end</span>
</code></pre></div>
<p>works for me</p>



<a name="224591577"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/synthesized%20type%20class%20instance%20is%20not%20definitionally%20equal/near/224591577" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/synthesized.20type.20class.20instance.20is.20not.20definitionally.20equal.html#224591577">(Jan 30 2021 at 15:58)</a>:</h4>
<p>Yes you're right, I wonder what I managed to do (I thought I checked).</p>



<a name="224591703"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/synthesized%20type%20class%20instance%20is%20not%20definitionally%20equal/near/224591703" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Paul van Wamelen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/synthesized.20type.20class.20instance.20is.20not.20definitionally.20equal.html#224591703">(Jan 30 2021 at 16:00)</a>:</h4>
<p>Oh! I tried adding it to the lemma. Adding it to the <code>def</code> works for me too!<br>
Is this all just a trick to learn, or is there some reason I should have known to try this? In particular why does the <code>decidable_pred</code> allow the beta reduction?</p>



<a name="224591922"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/synthesized%20type%20class%20instance%20is%20not%20definitionally%20equal/near/224591922" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/synthesized.20type.20class.20instance.20is.20not.20definitionally.20equal.html#224591922">(Jan 30 2021 at 16:05)</a>:</h4>
<p>Aah, I also added it to the lemma.</p>



<a name="224592005"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/synthesized%20type%20class%20instance%20is%20not%20definitionally%20equal/near/224592005" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/synthesized.20type.20class.20instance.20is.20not.20definitionally.20equal.html#224592005">(Jan 30 2021 at 16:06)</a>:</h4>
<p>My rule of thumb is that defs are better off with decidability assumptions rather than going classical, but when you're stating or proving lemmas you can either give explicit decidability constraints or just go classical and it shouldn't make a difference</p>



<a name="224592117"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/synthesized%20type%20class%20instance%20is%20not%20definitionally%20equal/near/224592117" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Paul van Wamelen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/synthesized.20type.20class.20instance.20is.20not.20definitionally.20equal.html#224592117">(Jan 30 2021 at 16:09)</a>:</h4>
<p>Thanks Bhavik, I'll keep that in mind.</p>



<a name="252634988"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/synthesized%20type%20class%20instance%20is%20not%20definitionally%20equal/near/252634988" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/synthesized.20type.20class.20instance.20is.20not.20definitionally.20equal.html#252634988">(Sep 09 2021 at 14:28)</a>:</h4>
<p>How should I interpret this error?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">synthesized</span> <span class="n">type</span> <span class="kd">class</span> <span class="kd">instance</span> <span class="n">is</span> <span class="n">not</span> <span class="n">definitionally</span> <span class="n">equal</span> <span class="n">to</span> <span class="n">expression</span> <span class="n">inferred</span> <span class="kd">by</span> <span class="n">typing</span> <span class="n">rules</span><span class="o">,</span> <span class="n">synthesized</span>
  <span class="n">construction.is_tensor_product</span> <span class="n">R</span> <span class="n">R</span> <span class="n">M</span>
<span class="n">inferred</span>
  <span class="bp">?</span><span class="n">m_1</span>
</code></pre></div>
<p>My gut reaction is: "Well, if you inferred some meta-variable, why don't you instantiate it to the thing you synthesized?"<br>
Why can't that be done?</p>



<a name="252638819"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/synthesized%20type%20class%20instance%20is%20not%20definitionally%20equal/near/252638819" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/synthesized.20type.20class.20instance.20is.20not.20definitionally.20equal.html#252638819">(Sep 09 2021 at 14:48)</a>:</h4>
<p>I seem to recall running into similar errors when playing with tensor products when lean couldn't figure out what to take a tensor product over. Do you have a <a href="https://leanprover-community.github.io/mwe.html">#mwe</a> ?</p>



<a name="252657046"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/synthesized%20type%20class%20instance%20is%20not%20definitionally%20equal/near/252657046" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/synthesized.20type.20class.20instance.20is.20not.20definitionally.20equal.html#252657046">(Sep 09 2021 at 16:43)</a>:</h4>
<p>It happened on a branch that is doing a major refactor of tensor products. So I'm not sure if I can easily create a <a href="https://leanprover-community.github.io/mwe.html">#mwe</a>.</p>



<a name="258373075"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/synthesized%20type%20class%20instance%20is%20not%20definitionally%20equal/near/258373075" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/synthesized.20type.20class.20instance.20is.20not.20definitionally.20equal.html#258373075">(Oct 20 2021 at 14:04)</a>:</h4>
<p>I'm hitting an issue I don't understand:<br>
The following code:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">ring_theory.polynomial.cyclotomic</span>

<span class="kn">open</span> <span class="n">polynomial</span>
<span class="kd">variable</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span>
<span class="kd">set_option</span> <span class="n">pp.all</span> <span class="n">true</span>
<span class="k">#check</span> <span class="n">splitting_field</span> <span class="o">(</span><span class="n">cyclotomic</span> <span class="n">n</span> <span class="n">ℚ</span><span class="o">)</span>
</code></pre></div>
<p>produces</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">synthesized</span> <span class="n">type</span> <span class="kd">class</span> <span class="kd">instance</span> <span class="n">is</span> <span class="n">not</span> <span class="n">definitionally</span> <span class="n">equal</span> <span class="n">to</span> <span class="n">expression</span> <span class="n">inferred</span> <span class="kd">by</span> <span class="n">typing</span> <span class="n">rules</span><span class="o">,</span> <span class="n">synthesized</span>
  <span class="bp">@</span><span class="n">normed_ring.to_ring.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">rat</span>
    <span class="o">(</span><span class="bp">@</span><span class="n">normed_comm_ring.to_normed_ring.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">rat</span> <span class="o">(</span><span class="bp">@</span><span class="n">normed_field.to_normed_comm_ring.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">rat</span> <span class="n">rat.normed_field</span><span class="o">))</span>
<span class="n">inferred</span>
  <span class="bp">@</span><span class="n">division_ring.to_ring.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">rat</span> <span class="o">(</span><span class="bp">@</span><span class="n">field.to_division_ring.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">rat</span> <span class="bp">?</span><span class="n">m_1</span><span class="o">)</span>
</code></pre></div>
<p>I don't understand why there is a metavariable in the inferred class, or why this is causing issues at all, if I fill in the metavariable by hand and check that things are defeq using rfl it always seems to work, so I'm a bit confused</p>



<a name="258374873"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/synthesized%20type%20class%20instance%20is%20not%20definitionally%20equal/near/258374873" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/synthesized.20type.20class.20instance.20is.20not.20definitionally.20equal.html#258374873">(Oct 20 2021 at 14:11)</a>:</h4>
<p>Both of these variations work:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#check</span> <span class="o">(</span><span class="n">splitting_field</span> <span class="o">(</span><span class="bp">@</span><span class="n">cyclotomic</span> <span class="n">n</span> <span class="n">ℚ</span> <span class="n">_</span><span class="o">))</span>
<span class="k">#check</span> <span class="o">(</span><span class="n">splitting_field</span> <span class="o">(</span><span class="bp">@</span><span class="n">cyclotomic</span> <span class="n">n</span> <span class="n">ℚ</span> <span class="o">(</span><span class="kd">by</span> <span class="n">apply_instance</span><span class="o">)))</span>
</code></pre></div>



<a name="258476108"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/synthesized%20type%20class%20instance%20is%20not%20definitionally%20equal/near/258476108" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/synthesized.20type.20class.20instance.20is.20not.20definitionally.20equal.html#258476108">(Oct 21 2021 at 02:08)</a>:</h4>
<p>Does it help if you add an explicit instance for <code>ring rat</code>?</p>



<a name="258845711"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/synthesized%20type%20class%20instance%20is%20not%20definitionally%20equal/near/258845711" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/synthesized.20type.20class.20instance.20is.20not.20definitionally.20equal.html#258845711">(Oct 23 2021 at 22:23)</a>:</h4>
<p>It doesn't seem to help no</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
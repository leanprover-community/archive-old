---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/huge.20term.20trees.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/huge.20term.20trees.html">huge term trees</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="185818122"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/huge%20term%20trees/near/185818122" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/huge.20term.20trees.html#185818122">(Jan 16 2020 at 14:17)</a>:</h4>
<p>I have been doing more performance analysis on mathlib, and I found something rather intriguing. At some point during compilation, there is a typeclass <strong>goal</strong> with a ~1GB string representation. The consequences of such huge term trees are subtle. Although I did not compute the size of the term DAG (as opposed to the term tree), my suspicion is that it is relatively small. Most modules in Lean3 (and Lean4) are careful to traverse expressions as DAGs instead of as trees, and for these modules, explosion in term tree sizes may not have much ill-effect. Indeed, typeclass synthesis only takes 5ms for this example despite the enormous term tree size. However, not all modules are designed to avoid this blowup, and so huge term trees do carry the risk of massive slowdowns in some parts of the system. In some cases, Lean has even been consciously removing support for efficiently handling huge term trees, since many of the things it seems to require actually hurt performance in the majority of cases. In particular, there is no current plan for Lean4 to address performance problems arising from huge term trees.</p>
<p>What is causing these huge term trees? Can you design the libraries in a way that avoids this blowup?</p>



<a name="185818133"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/huge%20term%20trees/near/185818133" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/huge.20term.20trees.html#185818133">(Jan 16 2020 at 14:17)</a>:</h4>
<p>In case it helps, here are the first 1,000 characters of the typeclass goal mentioned above:</p>
<p>"""<br>
decidable (Pi {X : category_theory.functor.{v‚ÇÅ (max u‚ÇÇ v‚ÇÉ) u‚ÇÅ (max v‚ÇÇ v‚ÇÉ u‚ÇÇ u‚ÇÉ)} C ùíû (category_theory.functor.{v‚ÇÇ v‚ÇÉ u‚ÇÇ u‚ÇÉ} D ùíü E ‚Ñ∞) (category_theory.functor.category.{v‚ÇÇ v‚ÇÉ u‚ÇÇ u‚ÇÉ} D ùíü E ‚Ñ∞)} {Y : category_theory.functor.{v‚ÇÅ (max u‚ÇÇ v‚ÇÉ) u‚ÇÅ (max v‚ÇÇ v‚ÇÉ u‚ÇÇ u‚ÇÉ)} C ùíû (category_theory.functor.{v‚ÇÇ v‚ÇÉ u‚ÇÇ u‚ÇÉ} D ùíü E ‚Ñ∞) (category_theory.functor.category.{v‚ÇÇ v‚ÇÉ u‚ÇÇ u‚ÇÉ} D ùíü E ‚Ñ∞)} {Z : category_theory.functor.{v‚ÇÅ (max u‚ÇÇ v‚ÇÉ) u‚ÇÅ (max v‚ÇÇ v‚ÇÉ u‚ÇÇ u‚ÇÉ)} C ùíû (category_theory.functor.{v‚ÇÇ v‚ÇÉ u‚ÇÇ u‚ÇÉ} D ùíü E ‚Ñ∞) (category_theory.functor.category.{v‚ÇÇ v‚ÇÉ u‚ÇÇ u‚ÇÉ} D ùíü E ‚Ñ∞)} (f : category_theory.has_hom.hom.{(max u‚ÇÅ u‚ÇÇ v‚ÇÉ) (max v‚ÇÅ (max u‚ÇÇ v‚ÇÉ) u‚ÇÅ v‚ÇÇ v‚ÇÉ u‚ÇÇ u‚ÇÉ)} (category_theory.functor.{v‚ÇÅ (max u‚ÇÇ v‚ÇÉ) u‚ÇÅ (max v‚ÇÇ v‚ÇÉ u‚ÇÇ u‚ÇÉ)} C ùíû (category_theory.functor.{v‚ÇÇ v‚ÇÉ u‚ÇÇ u‚ÇÉ} D ùíü E ‚Ñ∞) (category_theory.functor.category.{v‚ÇÇ v‚ÇÉ u‚ÇÇ u‚ÇÉ} D ùíü E ‚Ñ∞)) (category_theory.category_struct.to_has_hom.{(max u‚ÇÅ u‚ÇÇ v‚ÇÉ) (max v‚ÇÅ (max u‚ÇÇ v‚ÇÉ) u‚ÇÅ v‚ÇÇ v‚ÇÉ u‚ÇÇ u‚ÇÉ)} (category_theory.functor.{v‚ÇÅ (max u‚ÇÇ v‚ÇÉ) u‚ÇÅ (max v‚ÇÇ v‚ÇÉ u‚ÇÇ u‚ÇÉ)} C ùíû (category_theory.functor.{v‚ÇÇ v‚ÇÉ '<br>
"""</p>



<a name="185818383"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/huge%20term%20trees/near/185818383" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/huge.20term.20trees.html#185818383">(Jan 16 2020 at 14:20)</a>:</h4>
<p>And here is a toy pattern that could explain:</p>
<div class="codehilite"><pre><span></span><span class="n">class</span> <span class="n">C1</span> <span class="o">(</span><span class="n">Œ±</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span>  <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="o">(</span><span class="n">u</span><span class="o">:</span><span class="n">Unit</span><span class="o">:=())</span>
<span class="kn">instance</span> <span class="o">(</span><span class="n">Œ±</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span>  <span class="o">:</span> <span class="n">C1</span> <span class="n">Œ±</span> <span class="o">:=</span> <span class="o">{}</span>
<span class="n">class</span> <span class="n">C2</span> <span class="o">(</span><span class="n">Œ±</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">C1</span> <span class="n">Œ±</span><span class="o">]</span>  <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="o">(</span><span class="n">u</span><span class="o">:</span><span class="n">Unit</span><span class="o">:=())</span>
<span class="kn">instance</span> <span class="o">(</span><span class="n">Œ±</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">C1</span> <span class="n">Œ±</span><span class="o">]</span>  <span class="o">:</span> <span class="n">C2</span> <span class="n">Œ±</span> <span class="o">:=</span> <span class="o">{}</span>
<span class="n">class</span> <span class="n">C3</span> <span class="o">(</span><span class="n">Œ±</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">C1</span> <span class="n">Œ±</span><span class="o">]</span> <span class="o">[</span><span class="n">C2</span> <span class="n">Œ±</span><span class="o">]</span>  <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="o">(</span><span class="n">u</span><span class="o">:</span><span class="n">Unit</span><span class="o">:=())</span>
<span class="kn">instance</span> <span class="o">(</span><span class="n">Œ±</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">C1</span> <span class="n">Œ±</span><span class="o">]</span> <span class="o">[</span><span class="n">C2</span> <span class="n">Œ±</span><span class="o">]</span>  <span class="o">:</span> <span class="n">C3</span> <span class="n">Œ±</span> <span class="o">:=</span> <span class="o">{}</span>
<span class="n">class</span> <span class="n">C4</span> <span class="o">(</span><span class="n">Œ±</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">C1</span> <span class="n">Œ±</span><span class="o">]</span> <span class="o">[</span><span class="n">C2</span> <span class="n">Œ±</span><span class="o">]</span> <span class="o">[</span><span class="n">C3</span> <span class="n">Œ±</span><span class="o">]</span>  <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="o">(</span><span class="n">u</span><span class="o">:</span><span class="n">Unit</span><span class="o">:=())</span>
<span class="kn">instance</span> <span class="o">(</span><span class="n">Œ±</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">C1</span> <span class="n">Œ±</span><span class="o">]</span> <span class="o">[</span><span class="n">C2</span> <span class="n">Œ±</span><span class="o">]</span> <span class="o">[</span><span class="n">C3</span> <span class="n">Œ±</span><span class="o">]</span>  <span class="o">:</span> <span class="n">C4</span> <span class="n">Œ±</span> <span class="o">:=</span> <span class="o">{}</span>
<span class="n">class</span> <span class="n">C5</span> <span class="o">(</span><span class="n">Œ±</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">C1</span> <span class="n">Œ±</span><span class="o">]</span> <span class="o">[</span><span class="n">C2</span> <span class="n">Œ±</span><span class="o">]</span> <span class="o">[</span><span class="n">C3</span> <span class="n">Œ±</span><span class="o">]</span> <span class="o">[</span><span class="n">C4</span> <span class="n">Œ±</span><span class="o">]</span>  <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="o">(</span><span class="n">u</span><span class="o">:</span><span class="n">Unit</span><span class="o">:=())</span>
<span class="kn">instance</span> <span class="o">(</span><span class="n">Œ±</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">C1</span> <span class="n">Œ±</span><span class="o">]</span> <span class="o">[</span><span class="n">C2</span> <span class="n">Œ±</span><span class="o">]</span> <span class="o">[</span><span class="n">C3</span> <span class="n">Œ±</span><span class="o">]</span> <span class="o">[</span><span class="n">C4</span> <span class="n">Œ±</span><span class="o">]</span>  <span class="o">:</span> <span class="n">C5</span> <span class="n">Œ±</span> <span class="o">:=</span> <span class="o">{}</span>
<span class="c1">-- and so on</span>
</pre></div>



<a name="185818568"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/huge%20term%20trees/near/185818568" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/huge.20term.20trees.html#185818568">(Jan 16 2020 at 14:23)</a>:</h4>
<p>First of all: Thanks for all your efforts. The Lean 4 team is doing a really great job!<br>
That said:</p>
<blockquote>
<p>Can you design the libraries in a way that avoids this blowup?</p>
</blockquote>
<p>I understand this question. But my first reaction is: mathematicians shouldn't have to care...</p>



<a name="185818655"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/huge%20term%20trees/near/185818655" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/huge.20term.20trees.html#185818655">(Jan 16 2020 at 14:24)</a>:</h4>
<p><span class="user-mention" data-user-id="230999">@Daniel Selsam</span> Do you have the name and line numbers for this instance in mathlib?</p>



<a name="185863167"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/huge%20term%20trees/near/185863167" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/huge.20term.20trees.html#185863167">(Jan 16 2020 at 21:31)</a>:</h4>
<blockquote>
<p>In particular, there is no current plan for Lean4 to address performance problems arising from huge term trees.</p>
</blockquote>
<p>This is a bad idea. Large trees before deduplication is an inevitable consequence of dependent type theory due to redundancy inside types and dependent arguments. It's not a thing you can easily work around as a user. This will be <em>the</em> thing that we will all notice and hope to be improved in the next version if you don't fix it at this early stage.</p>



<a name="185863279"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/huge%20term%20trees/near/185863279" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/huge.20term.20trees.html#185863279">(Jan 16 2020 at 21:32)</a>:</h4>
<p>There is a coq paper about typeclass slowness using exactly your C1-C5 example</p>



<a name="185864985"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/huge%20term%20trees/near/185864985" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/huge.20term.20trees.html#185864985">(Jan 16 2020 at 21:49)</a>:</h4>
<blockquote>
<p>There is a coq paper about typeclass slowness using exactly your C1-C5 example</p>
</blockquote>
<p>Using unbundled typeclasses.</p>



<a name="185865318"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/huge%20term%20trees/near/185865318" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/huge.20term.20trees.html#185865318">(Jan 16 2020 at 21:49)</a>:</h4>
<p>I think that's what you are doing in the example as well</p>



<a name="185865442"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/huge%20term%20trees/near/185865442" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/huge.20term.20trees.html#185865442">(Jan 16 2020 at 21:50)</a>:</h4>
<p>the parameters are stacking up, and each one refers to all the previous, so instances on C5 are already O(n^5)</p>



<a name="185865456"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/huge%20term%20trees/near/185865456" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/huge.20term.20trees.html#185865456">(Jan 16 2020 at 21:50)</a>:</h4>
<blockquote>
<p>I think that's what you are doing in the example as well</p>
</blockquote>
<p>Yes, but that is not the way typeclasses are generally used in mathlib.</p>



<a name="185865489"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/huge%20term%20trees/near/185865489" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/huge.20term.20trees.html#185865489">(Jan 16 2020 at 21:50)</a>:</h4>
<p>It is, when more types get involved</p>



<a name="185865534"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/huge%20term%20trees/near/185865534" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/huge.20term.20trees.html#185865534">(Jan 16 2020 at 21:51)</a>:</h4>
<p>For example <code>module A B</code> needs <code>ring A</code> and <code>add_group B</code> as parameters</p>



<a name="185865562"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/huge%20term%20trees/near/185865562" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/huge.20term.20trees.html#185865562">(Jan 16 2020 at 21:51)</a>:</h4>
<p>And <code>topological_vector_space</code> needs ...</p>



<a name="185865568"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/huge%20term%20trees/near/185865568" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/huge.20term.20trees.html#185865568">(Jan 16 2020 at 21:51)</a>:</h4>
<p>I'm not exactly sure where your example is coming from but category theory has a similar problem with mandatory dependencies</p>



<a name="185865710"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/huge%20term%20trees/near/185865710" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/huge.20term.20trees.html#185865710">(Jan 16 2020 at 21:53)</a>:</h4>
<p>Yes but <code>ring A</code> and <code>add_group B</code> internally bundle many layers. Do you know which class in mathlib takes the most instance parameters? It seems harder to accidentally take a ton of instance parameters in Lean since it doesn't support the implicit generalization that Coq does.</p>



<a name="185865766"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/huge%20term%20trees/near/185865766" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/huge.20term.20trees.html#185865766">(Jan 16 2020 at 21:53)</a>:</h4>
<p>topological vector space is probably a contender</p>



<a name="185865820"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/huge%20term%20trees/near/185865820" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/huge.20term.20trees.html#185865820">(Jan 16 2020 at 21:54)</a>:</h4>
<p>complete topological vector space?</p>



<a name="185865827"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/huge%20term%20trees/near/185865827" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/huge.20term.20trees.html#185865827">(Jan 16 2020 at 21:54)</a>:</h4>
<p>In Coq, the same example looks harmless :</p>
<div class="codehilite"><pre><span></span><span class="kn">Class</span> <span class="n">C1</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kn">Set</span><span class="o">)</span> <span class="o">:</span> <span class="kn">Set</span> <span class="o">:=</span> <span class="o">{}.</span>
<span class="kn">Instance</span> <span class="n">I1</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kn">Set</span><span class="o">)</span> <span class="o">:</span> <span class="n">C1</span> <span class="n">X</span> <span class="o">:=</span> <span class="o">{}.</span>
<span class="kn">Class</span> <span class="n">C2</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kn">Set</span><span class="o">)</span> <span class="o">`{</span><span class="n">C1</span> <span class="n">X</span><span class="o">}</span> <span class="o">:</span> <span class="kn">Set</span> <span class="o">:=</span> <span class="o">{}.</span>
<span class="kn">Instance</span> <span class="n">I2</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kn">Set</span><span class="o">)</span> <span class="o">`{</span><span class="n">C1</span> <span class="n">X</span><span class="o">}</span> <span class="o">:</span> <span class="n">C2</span> <span class="n">X</span> <span class="o">:=</span> <span class="o">{}.</span>
<span class="kn">Class</span> <span class="n">C3</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kn">Set</span><span class="o">)</span> <span class="o">`{</span><span class="n">C2</span> <span class="n">X</span><span class="o">}</span> <span class="o">:</span> <span class="kn">Set</span> <span class="o">:=</span> <span class="o">{}.</span>
<span class="kn">Instance</span> <span class="n">I3</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kn">Set</span><span class="o">)</span> <span class="o">`{</span><span class="n">C2</span> <span class="n">X</span><span class="o">}</span> <span class="o">:</span> <span class="n">C3</span> <span class="n">X</span> <span class="o">:=</span> <span class="o">{}.</span>
<span class="kn">Class</span> <span class="n">C4</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kn">Set</span><span class="o">)</span> <span class="o">`{</span><span class="n">C3</span> <span class="n">X</span><span class="o">}</span> <span class="o">:</span> <span class="kn">Set</span> <span class="o">:=</span> <span class="o">{}.</span>
<span class="kn">Instance</span> <span class="n">I4</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kn">Set</span><span class="o">)</span> <span class="o">`{</span><span class="n">C3</span> <span class="n">X</span><span class="o">}</span> <span class="o">:</span> <span class="n">C4</span> <span class="n">X</span> <span class="o">:=</span> <span class="o">{}.</span>
<span class="kn">Class</span> <span class="n">C5</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kn">Set</span><span class="o">)</span> <span class="o">`{</span><span class="n">C4</span> <span class="n">X</span><span class="o">}</span> <span class="o">:</span> <span class="kn">Set</span> <span class="o">:=</span> <span class="o">{}.</span>
<span class="kn">Instance</span> <span class="n">I5</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kn">Set</span><span class="o">)</span> <span class="o">`{</span><span class="n">C4</span> <span class="n">X</span><span class="o">}</span> <span class="o">:</span> <span class="n">C5</span> <span class="n">X</span> <span class="o">:=</span> <span class="o">{}.</span>
<span class="kn">Example</span> <span class="n">failing_tower</span> <span class="o">:</span> <span class="n">C5</span> <span class="n">unit</span> <span class="o">:=</span> <span class="o">_.</span>
</pre></div>



<a name="185865855"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/huge%20term%20trees/near/185865855" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/huge.20term.20trees.html#185865855">(Jan 16 2020 at 21:54)</a>:</h4>
<p>I recall that being a feature request on lean 3</p>



<a name="185866009"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/huge%20term%20trees/near/185866009" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/huge.20term.20trees.html#185866009">(Jan 16 2020 at 21:56)</a>:</h4>
<p>Looking harmless was a feature request?</p>



<a name="185866070"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/huge%20term%20trees/near/185866070" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/huge.20term.20trees.html#185866070">(Jan 16 2020 at 21:56)</a>:</h4>
<p>Being able to write <code>[module A B]</code> and getting <code>{A} {B} [ring A] [add_group B] [module A B]</code> automatically</p>



<a name="185866134"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/huge%20term%20trees/near/185866134" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/huge.20term.20trees.html#185866134">(Jan 16 2020 at 21:57)</a>:</h4>
<p>This is very nice when you are doing e.g. linear algebra between two or three vector spaces</p>



<a name="185866161"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/huge%20term%20trees/near/185866161" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/huge.20term.20trees.html#185866161">(Jan 16 2020 at 21:57)</a>:</h4>
<p>Oooh...</p>



<a name="185866243"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/huge%20term%20trees/near/185866243" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/huge.20term.20trees.html#185866243">(Jan 16 2020 at 21:58)</a>:</h4>
<p>I didn't even know you could ask Santa Claus to get that.</p>



<a name="185866296"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/huge%20term%20trees/near/185866296" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/huge.20term.20trees.html#185866296">(Jan 16 2020 at 21:59)</a>:</h4>
<p>It would be delicate to get right -- if B was already an add_group for some other reason then you don't want to add it again.</p>



<a name="185866403"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/huge%20term%20trees/near/185866403" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/huge.20term.20trees.html#185866403">(Jan 16 2020 at 22:00)</a>:</h4>
<p>I would have pointed to the issue page but they are all gone :(</p>



<a name="185876715"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/huge%20term%20trees/near/185876715" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/huge.20term.20trees.html#185876715">(Jan 17 2020 at 00:26)</a>:</h4>
<blockquote>
<blockquote>
<p>In particular, there is no current plan for Lean4 to address performance problems arising from huge term trees.</p>
</blockquote>
<p>This is a bad idea. Large trees before deduplication is an inevitable consequence of dependent type theory due to redundancy inside types and dependent arguments. It's not a thing you can easily work around as a user. This will be <em>the</em> thing that we will all notice and hope to be improved in the next version if you don't fix it at this early stage.</p>
</blockquote>
<p>I agree that it might be this critical, but I don't have enough information yet to have an informed opinion about what to do. In particular, there might be acceptable ways of keeping the heights of these towers acceptably bounded, and the possible backend solutions might all have substantial downsides. For now, let us all work together to investigate the problem and to assess our options.</p>



<a name="185876962"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/huge%20term%20trees/near/185876962" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/huge.20term.20trees.html#185876962">(Jan 17 2020 at 00:30)</a>:</h4>
<blockquote>
<p><span class="user-mention silent" data-user-id="230999">Daniel Selsam</span> Do you have the name and line numbers for this instance in mathlib?</p>
</blockquote>
<p>Unfortunately, no. It would take quite a bit more bookkeeping to get location information for arbitrary typeclass queries, and I won't have time or CPU cycles for this for several days. Is somebody else able to investigate in the meantime with the new (and much improved) leancrawler? It is very well-documented. Here is what I suggest to start: create a lean file that imports all of mathlib, export it to a <code>.yaml</code> as described in the README, and run a simple script like the following:</p>
<div class="codehilite"><pre><span></span><span class="kn">from</span> <span class="nn">crawler</span> <span class="kn">import</span> <span class="n">LeanLib</span>
<span class="kn">import</span> <span class="nn">networkx</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Loading export.yaml&quot;</span><span class="p">)</span>
<span class="n">lib</span> <span class="o">=</span> <span class="n">LeanLib</span><span class="o">.</span><span class="n">from_yaml</span><span class="p">(</span><span class="s1">&#39;FindBig&#39;</span><span class="p">,</span> <span class="s1">&#39;export.yaml&#39;</span><span class="p">)</span>

<span class="n">decls</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">lib</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Top-10 biggest decls by type:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="n">decls</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="p">(</span><span class="k">lambda</span> <span class="n">decl</span><span class="p">:</span> <span class="o">-</span> <span class="n">decl</span><span class="o">.</span><span class="n">type_size</span><span class="p">))</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">decl</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">decls</span><span class="p">[:</span><span class="mi">10</span><span class="p">]):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">decl</span><span class="p">,</span> <span class="n">decl</span><span class="o">.</span><span class="n">type_size</span><span class="p">,</span> <span class="n">decl</span><span class="o">.</span><span class="n">type_dedup_size</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Top-10 biggest decls by value:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="n">decls</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="p">(</span><span class="k">lambda</span> <span class="n">decl</span><span class="p">:</span> <span class="o">-</span> <span class="n">decl</span><span class="o">.</span><span class="n">value_size</span><span class="p">))</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">decl</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">decls</span><span class="p">[:</span><span class="mi">10</span><span class="p">]):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">decl</span><span class="p">,</span> <span class="n">decl</span><span class="o">.</span><span class="n">value_size</span><span class="p">,</span> <span class="n">decl</span><span class="o">.</span><span class="n">value_dedup_size</span><span class="p">)</span>
</pre></div>



<a name="185877007"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/huge%20term%20trees/near/185877007" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/huge.20term.20trees.html#185877007">(Jan 17 2020 at 00:31)</a>:</h4>
<p>I just ran this, but only importing a few mathlib theories. This was the output:</p>
<div class="codehilite"><pre><span></span>Top-10 biggest decls by type:

category_theory.limits.is_colimit.hom_desc 35592 1159
category_theory.limits.is_limit.hom_lift 7508 1350
gcd_domain.mk.inj 6650 3306
gcd_domain.mk.inj_arrow 6643 3319
algebraic_geometry.PresheafedSpace.ext 6407 549
decidable_linear_ordered_semiring.mk.inj 6387 3709
decidable_linear_ordered_semiring.mk.inj_arrow 6378 3758
lattice.complete_boolean_algebra.mk.inj 6252 4008
lattice.complete_boolean_algebra.mk.inj_arrow 6241 4025
linear_ordered_semiring.mk.inj 5958 3444

Top-10 biggest decls by value:

filter.is_lawful_monad 100044499 36343
algebraic_geometry.PresheafedSpace.stalk_map.comp 63928223 16816
emetric.countable_closure_of_compact 6553913 35855
real.exists_sup 6422084 11798
Top.presheaf.stalk_pushforward.comp 4524414 13016
category_theory.equivalence.unit_inverse_comp 3779575 9474
is_measurable.diff_null 1158921 7082
set.is_lawful_monad 987060 26209
free_group.is_lawful_monad 961500 23022
Top.presheaf.stalk_pushforward.id 899051 5074
</pre></div>



<a name="185879772"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/huge%20term%20trees/near/185879772" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/huge.20term.20trees.html#185879772">(Jan 17 2020 at 01:29)</a>:</h4>
<p>Also, to stress: most parts of the system are very careful to only traverse terms as DAGs. So, even with the status quo I don't think a term with a <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>10</mn></msup></mrow><annotation encoding="application/x-tex">2^{10}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></span> tree-to-DAG ratio would in general suffer anywhere near <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>10</mn></msup></mrow><annotation encoding="application/x-tex">2^{10}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></span> overhead overall. But if 10 becomes 20 or 30, then any weak link anywhere in the system could cause epic slowdowns.</p>



<a name="185889854"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/huge%20term%20trees/near/185889854" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/huge.20term.20trees.html#185889854">(Jan 17 2020 at 05:49)</a>:</h4>
<p>This is completely crazy. The top two entries are</p>
<div class="codehilite"><pre><span></span>category_theory.limits.is_colimit.hom_desc 35592 1159
category_theory.limits.is_limit.hom_lift 7508 1350
</pre></div>


<p>which are exactly each others duals. So why does the first one get a <code>35592</code> and the second one a <code>7508</code>.</p>



<a name="185889860"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/huge%20term%20trees/near/185889860" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/huge.20term.20trees.html#185889860">(Jan 17 2020 at 05:49)</a>:</h4>
<p><span class="user-mention" data-user-id="230999">@Daniel Selsam</span> Thanks for this little demo. I'm sure we can find a machine to crunch some numbers for us.</p>



<a name="186456082"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/huge%20term%20trees/near/186456082" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/huge.20term.20trees.html#186456082">(Jan 24 2020 at 01:50)</a>:</h4>
<p>Here is the experiment I suggest starting with:</p>
<ul>
<li>import all of mathlib (as described at <a href="https://github.com/leanprover-community/mathlib/pull/1281" target="_blank" title="https://github.com/leanprover-community/mathlib/pull/1281">https://github.com/leanprover-community/mathlib/pull/1281</a>)</li>
<li>use leancrawler and the script above to find the biggest top-level types and values</li>
<li>for the def with the biggest value, list the K biggest subterms that appear &gt;N times for some big Ns.</li>
<li>if there is a blowup, hopefully this list will provide a strong hint as to the cause</li>
</ul>



<a name="186482164"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/huge%20term%20trees/near/186482164" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tim Daly <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/huge.20term.20trees.html#186482164">(Jan 24 2020 at 11:18)</a>:</h4>
<p>There is a phenomena in computer algebra called "intermediate expression swell". A computation can start with a small input and end with a small output but the intermediate steps generate many megabytes. I wonder if there is a similar phenomena that occurs in certain proofs. It may not be a "bug" per se, just an emergent property of the particular proof technique.</p>



<a name="186520177"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/huge%20term%20trees/near/186520177" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/huge.20term.20trees.html#186520177">(Jan 24 2020 at 18:33)</a>:</h4>
<p>Ran the script posted above on all of mathlib:<br>
"""<br>
Top-10 biggest decls by value:</p>
<p>tangent_bundle_model_space_chart_at 2499367138 21824<br>
Gromov_Hausdorff.totally_bounded 2448909819 42588<br>
...<br>
"""<br>
With commas: 21,824 -&gt; 2,499,367,138 which is &gt;100,000x tree-to-dag ratio.</p>



<a name="186520527"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/huge%20term%20trees/near/186520527" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/huge.20term.20trees.html#186520527">(Jan 24 2020 at 18:37)</a>:</h4>
<p>The proof seems to be mostly <code>simp</code>. Could someone who understands the proof comment on why there might be so much sharing?</p>



<a name="186520702"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/huge%20term%20trees/near/186520702" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/huge.20term.20trees.html#186520702">(Jan 24 2020 at 18:39)</a>:</h4>
<p><span class="user-mention" data-user-id="110050">@Sebastien Gouezel</span> Is the expert on that proof. <span class="user-mention" data-user-id="230999">@Daniel Selsam</span> I'm trying to understand what you mean. What are those numbers representing?</p>



<a name="186520717"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/huge%20term%20trees/near/186520717" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/huge.20term.20trees.html#186520717">(Jan 24 2020 at 18:39)</a>:</h4>
<p>The number of nodes in a dag (resp. tree) representation of the proof?</p>



<a name="186520736"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/huge%20term%20trees/near/186520736" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/huge.20term.20trees.html#186520736">(Jan 24 2020 at 18:40)</a>:</h4>
<blockquote>
<p>The number of nodes in a dag (resp. tree) representation of the proof?</p>
</blockquote>
<p>Yes.</p>



<a name="186521378"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/huge%20term%20trees/near/186521378" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/huge.20term.20trees.html#186521378">(Jan 24 2020 at 18:46)</a>:</h4>
<p>To clarify: this kind of repeated subterm might not be a problem at all. Based on Lean3's <code>--profile</code> report, it seems to only take a few seconds to elaborate and type-check it, and the moderate slowness might not even have anything to do with the tree size.</p>



<a name="186521833"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/huge%20term%20trees/near/186521833" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/huge.20term.20trees.html#186521833">(Jan 24 2020 at 18:51)</a>:</h4>
<p><span class="user-mention" data-user-id="230999">@Daniel Selsam</span> <a href="https://github.com/leanprover-community/mathlib/blob/9ac26cb6220deec0960f8a719572a82ead25f90e/src/geometry/manifold/basic_smooth_bundle.lean#L540L571" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/9ac26cb6220deec0960f8a719572a82ead25f90e/src/geometry/manifold/basic_smooth_bundle.lean#L540L571">https://github.com/leanprover-community/mathlib/blob/9ac26cb6220deec0960f8a719572a82ead25f90e/src/geometry/manifold/basic_smooth_bundle.lean#L540L571</a><br>
I can't really parse this proof. But it's clear that it's doing some massive simps (-;</p>



<a name="186521908"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/huge%20term%20trees/near/186521908" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/huge.20term.20trees.html#186521908">(Jan 24 2020 at 18:52)</a>:</h4>
<p>I don't think I can really help here</p>



<a name="186521971"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/huge%20term%20trees/near/186521971" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/huge.20term.20trees.html#186521971">(Jan 24 2020 at 18:53)</a>:</h4>
<p>There's something kind of funny going on there with the <code>simp</code>s followed by <code>erw</code> too.</p>



<a name="186523015"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/huge%20term%20trees/near/186523015" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/huge.20term.20trees.html#186523015">(Jan 24 2020 at 19:05)</a>:</h4>
<p><span class="user-mention" data-user-id="230999">@Daniel Selsam</span> just to let you know in case you didn't already -- this work by <span class="user-mention" data-user-id="110050">@Sebastien Gouezel</span>  on real manifolds is mathematics which is not in any of the other theorem provers. It is interesting to note that it is also (final year) undergraduate-level mathematics. I have argued that the fact that Lean could do it at all means that Lean is more suitable for formalising all mathematics than Isabelle is. Isabelle is good at analysis but never got this far into the complex definitions in the theory.</p>



<a name="186526363"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/huge%20term%20trees/near/186526363" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/huge.20term.20trees.html#186526363">(Jan 24 2020 at 19:39)</a>:</h4>
<blockquote>
<p>Ran the script posted above on all of mathlib:<br>
"""<br>
Top-10 biggest decls by value:<br>
Top-10 biggest decls by value:</p>
<p>tangent_bundle_model_space_chart_at 2499367138 21824<br>
Gromov_Hausdorff.totally_bounded 2448909819 42588<br>
"""<br>
With commas: 21,824 -&gt; 2,499,367,138 which is &gt;100,000x tree-to-dag ratio.</p>
</blockquote>
<p>It's funny, I am responsible for both of them in two unrelated areas. What I can tell is that both involve complicated objects, but otherwise they are of a somewhat different nature. The first one has big simps, but otherwise it is mostly unfolding definitions. The main unusual point in the second one involves constructing new types depending on some objects in the proof.</p>



<a name="186566491"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/huge%20term%20trees/near/186566491" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/huge.20term.20trees.html#186566491">(Jan 25 2020 at 09:55)</a>:</h4>
<p>For the very big tree-to-dag ratio in <code>Gromov_Hausdorff.totally_bounded</code>, this proof uses a lot the Hausdorff distance. I remember that at the beginning these proofs were super-slow, and this was solved by making Hausdorff distance irreducible. If I understand correctly, making something irreducible does not change anything for the kernel, which still has to deal with the full definition. So maybe the definition of Hausdorff distance is already big, and since it appears a lot of times in the proof this might explain what is going on. Hausdorff distance is defined in terms of supremums of infimums of real numbers, which are themselves defined with Cauchy sequences, so depending on the inner workings this might definitely be huge.</p>



<a name="186566557"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/huge%20term%20trees/near/186566557" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/huge.20term.20trees.html#186566557">(Jan 25 2020 at 09:57)</a>:</h4>
<p>The kernel will only see this if it is unfolded. Making it irreducible should prevent the elaborator from creating terms which require such unfolding</p>



<a name="186566789"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/huge%20term%20trees/near/186566789" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/huge.20term.20trees.html#186566789">(Jan 25 2020 at 10:04)</a>:</h4>
<p>I think what is actually happening is that those <code>have</code> statements are not actual <code>have</code>s, they are repeated subterms. For example, I can clearly see the full proof of</p>
<div class="codehilite"><pre><span></span>  <span class="k">have</span> <span class="o">:</span> <span class="bp">‚àÄ</span><span class="n">p</span><span class="o">:</span><span class="n">GH_space</span><span class="o">,</span> <span class="bp">‚àÉ</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">p</span><span class="bp">.</span><span class="n">rep</span><span class="o">),</span> <span class="bp">‚àÉ</span><span class="n">N</span> <span class="bp">‚â§</span> <span class="n">K</span> <span class="n">n</span><span class="o">,</span> <span class="bp">‚àÉ</span><span class="n">E</span> <span class="o">:</span> <span class="n">equiv</span> <span class="n">s</span> <span class="o">(</span><span class="n">fin</span> <span class="n">N</span><span class="o">),</span>
    <span class="n">p</span> <span class="err">‚àà</span> <span class="n">t</span> <span class="bp">‚Üí</span> <span class="n">univ</span> <span class="err">‚äÜ</span> <span class="err">‚ãÉ</span><span class="n">x</span><span class="err">‚àà</span><span class="n">s</span><span class="o">,</span> <span class="n">ball</span> <span class="n">x</span> <span class="o">(</span><span class="n">u</span> <span class="n">n</span><span class="o">),</span>
</pre></div>


<p>copied many times in the <code>#print</code> output</p>



<a name="186567831"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/huge%20term%20trees/near/186567831" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/huge.20term.20trees.html#186567831">(Jan 25 2020 at 10:35)</a>:</h4>
<p>Hm, I tried writing a variant of <code>have</code> that actually inserts beta redexes in the term, but they might be optimized away by <code>intro</code> or another tactic</p>



<a name="186568020"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/huge%20term%20trees/near/186568020" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/huge.20term.20trees.html#186568020">(Jan 25 2020 at 10:40)</a>:</h4>
<p>Looks like <code>intro_core</code> will check to see if the current result has the form <code>?m a</code> and replaces it with <code>?m'[a]</code>, causing the substitution to occur when the metavariable is filled</p>



<a name="186568229"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/huge%20term%20trees/near/186568229" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/huge.20term.20trees.html#186568229">(Jan 25 2020 at 10:46)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">:</span> <span class="n">true</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">tactic</span><span class="bp">.</span><span class="n">assertv_core</span> <span class="bp">`</span><span class="n">H</span> <span class="bp">`</span><span class="o">(</span><span class="n">true</span><span class="o">)</span> <span class="bp">`</span><span class="o">(</span><span class="n">trivial</span> <span class="o">:</span> <span class="n">true</span><span class="o">),</span>
  <span class="n">tactic</span><span class="bp">.</span><span class="n">result</span> <span class="bp">&gt;&gt;=</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">trace</span><span class="o">,</span> <span class="c1">-- ?m_1 trivial</span>
  <span class="n">intro</span> <span class="n">z</span><span class="o">,</span>
  <span class="n">tactic</span><span class="bp">.</span><span class="n">result</span> <span class="bp">&gt;&gt;=</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">trace</span><span class="o">,</span> <span class="c1">-- ?m_1[trivial]</span>
  <span class="n">exact</span> <span class="n">trivial</span><span class="o">,</span>
  <span class="n">tactic</span><span class="bp">.</span><span class="n">result</span> <span class="bp">&gt;&gt;=</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">trace</span><span class="o">,</span> <span class="c1">-- trivial</span>
<span class="kn">end</span>
</pre></div>



<a name="186568303"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/huge%20term%20trees/near/186568303" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/huge.20term.20trees.html#186568303">(Jan 25 2020 at 10:49)</a>:</h4>
<p>It's a nice optimization that probably avoids a lot of superfluous redexes, but it's not obvious how to work around it from the lean side. I think you just have to detect these on the C++ side and introduce <code>have</code>s then. (Lean can't see subterm sharing, which limits the ability to do anything about this. It also means that you can't write any efficient dag traversal tactics in lean. I guess lean 4 must have fixed this, if you wrote the elaborator in lean.)</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
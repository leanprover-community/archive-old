---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/Weirdness.20in.20product.20of.20groupoids.20attempt.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Weirdness.20in.20product.20of.20groupoids.20attempt.html">Weirdness in product of groupoids attempt</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="264962309"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Weirdness%20in%20product%20of%20groupoids%20attempt/near/264962309" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Praneeth Kolichala <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Weirdness.20in.20product.20of.20groupoids.20attempt.html#264962309">(Dec 15 2021 at 03:54)</a>:</h4>
<p>I'm trying to show that the product of groupoids is a groupoid. In words, this is because for groupoids <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span>, if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>‚àà</mo><mi>X</mi><mo>√ó</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">x,y \in X\times Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">‚àà</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">√ó</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span> are objects and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>f</mi><mo separator="true">,</mo><mi>g</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(f, g)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mclose">)</span></span></span></span> a morphism between them, then <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>f</mi><mo separator="true">,</mo><mi>g</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(f, g)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mclose">)</span></span></span></span> has an inverse, namely <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msup><mi>f</mi><mrow><mo>‚àí</mo><mn>1</mn></mrow></msup><mo separator="true">,</mo><msup><mi>g</mi><mrow><mo>‚àí</mo><mn>1</mn></mrow></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(f^{-1}, g^{-1})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">‚àí</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">‚àí</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>.</p>
<p>This is a very simple fact, and it might already be in mathlib. In any case, I'm (re)proving it, and I have this so far (which works correctly):</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">universe</span> <span class="n">u</span>

<span class="kd">abbreviation</span> <span class="n">inv</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">category_theory.groupoid.inv</span>

<span class="kd">instance</span> <span class="n">groupoid_prod</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">category_theory.groupoid.</span><span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="n">X</span><span class="o">]</span>
                    <span class="o">{</span><span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">category_theory.groupoid.</span><span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="n">Y</span><span class="o">]</span>
                  <span class="o">:</span> <span class="n">category_theory.groupoid.</span><span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">X</span> <span class="bp">√ó</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span>
  <span class="n">inv</span> <span class="o">:=</span> <span class="bp">Œª</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">√ó</span> <span class="n">Y</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="o">(</span><span class="n">x.1</span> <span class="bp">‚ü∂</span> <span class="n">y.1</span><span class="o">)</span> <span class="bp">√ó</span> <span class="o">(</span><span class="n">x.2</span> <span class="bp">‚ü∂</span> <span class="n">y.2</span><span class="o">)),</span>
            <span class="o">(</span><span class="n">inv</span> <span class="n">f.1</span><span class="o">,</span> <span class="n">inv</span> <span class="n">f.2</span><span class="o">),</span>
  <span class="n">inv_comp'</span> <span class="o">:=</span>
  <span class="kd">begin</span>
    <span class="n">intros</span> <span class="n">x</span> <span class="n">y</span> <span class="n">f</span><span class="o">,</span>
    <span class="c1">-- change ((inv f.1, inv f.2) : y ‚ü∂ x) ‚â´ ((f.1, f.2) : x ‚ü∂ y) = ùüô y,</span>
    <span class="k">let</span> <span class="n">inv_f</span> <span class="o">:</span> <span class="n">y</span> <span class="bp">‚ü∂</span> <span class="n">x</span> <span class="o">:=</span> <span class="o">(</span><span class="n">inv</span> <span class="n">f.1</span><span class="o">,</span> <span class="n">inv</span> <span class="n">f.2</span><span class="o">),</span>
    <span class="k">let</span> <span class="n">f_hom</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">‚ü∂</span> <span class="n">y</span> <span class="o">:=</span> <span class="o">(</span><span class="n">f.1</span><span class="o">,</span> <span class="n">f.2</span><span class="o">),</span>
    <span class="n">change</span> <span class="n">inv_f</span> <span class="bp">‚â´</span> <span class="n">f_hom</span> <span class="bp">=</span> <span class="mi">ùüô</span> <span class="n">y</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">prodcomp</span> <span class="o">:</span> <span class="o">(</span><span class="n">inv_f</span> <span class="bp">‚â´</span> <span class="n">f_hom</span> <span class="bp">=</span> <span class="n">_</span><span class="o">)</span>
    <span class="o">:=</span> <span class="bp">@</span><span class="n">category_theory.prod_comp</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span>
      <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">inv_f</span> <span class="n">f_hom</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">prodcomp</span><span class="o">,</span>
    <span class="n">simpa</span><span class="o">,</span>
  <span class="kd">end</span><span class="o">,</span>

  <span class="n">comp_inv'</span> <span class="o">:=</span>
  <span class="kd">begin</span>
    <span class="c1">-- Removed for clarity, essentially the same as inv_comp'</span>
  <span class="kd">end</span><span class="o">,</span>
<span class="o">}</span>
</code></pre></div>
<p>This works, but it feels very clunky. For example, I wanted to use the line <code>change ((inv f.1, inv f.2) : y ‚ü∂ x) ‚â´ ((f.1, f.2) : x ‚ü∂ y) = ùüô y</code>,<br>
but for some reason Lean gives a type error. My workaround (after lots of tinkering) was to use two let statements with explicit types. I don't understand why this works but the other way doesn't.</p>
<p>Next, something even more mysterious (to me). I wanted to use something like:<br>
<code>rw category_theory.prod_comp  inv_f f_hom</code></p>
<p>Unfortunately, the only way I could make it work was as shown in the original code. Specifically, I had to move it to a variable <code>prodcomp</code>, which also has to have an explicit type, and use <code>@</code> even though all the parameters are underscores. If I don't give it an explicit type, Lean infers the correct type (in fact, the type doesn't change at all!), but the rewrite fails for some reason.</p>
<p>Can anyone explain what's going on?</p>
<p>Also, I noticed that if I put enough blank lines after the begin statement, the goal randomly changes according to VS Code (to <code>‚àÄ {X_1 Y_1 : X √ó Y} (f : X_1 ‚ü∂ Y_1), ùüô X_1 ‚â´ f = f</code>, which I guess is easier to prove). This doesn't help in proving the theorem, because as soon as you do a tactic like <code>intro</code>, it changes back to what it was supposed to be, so this is probably a small bug in Lean/VS Code. Still, it's not helping my suspicion that my version of Lean is haunted.</p>



<a name="264963136"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Weirdness%20in%20product%20of%20groupoids%20attempt/near/264963136" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Praneeth Kolichala <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Weirdness.20in.20product.20of.20groupoids.20attempt.html#264963136">(Dec 15 2021 at 04:11)</a>:</h4>
<p>I'm able to reproduce the blank lines bug in the online WebAssembly version of Lean <a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20category_theory.groupoid%0Aimport%20category_theory.products.basic%0A%0A%0A%0A%0A%0A%0A%0Auniverse%20u%0A%0Aabbreviation%20inv%20%3A%3D%20%40category_theory.groupoid.inv%0A%0Ainstance%20groupoid_prod%20%7BX%20%3A%20Type%20u%7D%20%5Bcategory_theory.groupoid.%7Bu%7D%20X%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7BY%20%3A%20Type%20u%7D%20%5Bcategory_theory.groupoid.%7Bu%7D%20Y%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3A%20category_theory.groupoid.%7Bu%7D%20%28X%20%C3%97%20Y%29%20%3A%3D%20%0A%7B%0A%20%20inv%20%3A%3D%20%CE%BB%20%28x%20y%20%3A%20X%20%C3%97%20Y%29%20%28f%20%3A%20%28x.1%20%E2%9F%B6%20y.1%29%20%C3%97%20%28x.2%20%E2%9F%B6%20y.2%29%29%2C%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%28inv%20f.1%2C%20inv%20f.2%29%2C%0A%20%20inv_comp'%20%3A%3D%0A%20%20begin%0A%0A%0A%0A%0A%0A%0A%0A%0A%20%20%20%20skip%2C%0A%0A%0A%0A%0A%0A%0A%0A%0A%0A%20%20%20%20intros%20x%20y%20f%2C%0A%20%20%20%20--%20change%20%28%28inv%20f.1%2C%20inv%20f.2%29%20%3A%20y%20%E2%9F%B6%20x%29%20%E2%89%AB%20%28%28f.1%2C%20f.2%29%20%3A%20x%20%E2%9F%B6%20y%29%20%3D%20%F0%9D%9F%99%20y%2C%0A%20%20%20%20let%20inv_f%20%3A%20y%20%E2%9F%B6%20x%20%3A%3D%20%28inv%20f.1%2C%20inv%20f.2%29%2C%0A%20%20%20%20let%20f_hom%20%3A%20x%20%E2%9F%B6%20y%20%3A%3D%20%28f.1%2C%20f.2%29%2C%0A%20%20%20%20change%20inv_f%20%E2%89%AB%20f_hom%20%3D%20%F0%9D%9F%99%20y%2C%0A%20%20%20%20have%20prodcomp%20%3A%20%28inv_f%20%E2%89%AB%20f_hom%20%3D%20_%29%20%0A%20%20%20%20%3A%3D%20%40category_theory.prod_comp%20_%20_%20_%20_%0A%20%20%20%20%20%20_%20_%20_%20_%20_%20_%20inv_f%20f_hom%2C%0A%20%20%20%20rw%20prodcomp%2C%0A%20%20%20%20simpa%2C%0A%20%20end%2C%0A%20%20%0A%20%20comp_inv'%20%3A%3D%0A%20%20begin%0A%20%20%20%20intros%20x%20y%20f%2C%0A%20%20%20%20let%20inv_f%20%3A%20y%20%E2%9F%B6%20x%20%3A%3D%20%28inv%20f.1%2C%20inv%20f.2%29%2C%0A%20%20%20%20let%20f_hom%20%3A%20x%20%E2%9F%B6%20y%20%3A%3D%20%28f.1%2C%20f.2%29%2C%0A%20%20%20%20change%20f_hom%20%E2%89%AB%20inv_f%20%3D%20%F0%9D%9F%99%20x%2C%0A%20%20%20%20have%20prodcomp%20%3A%20%28f_hom%20%E2%89%AB%20inv_f%20%3D%20_%29%20%0A%20%20%20%20%3A%3D%20%40category_theory.prod_comp%20_%20_%20_%20_%0A%20%20%20%20%20%20_%20_%20_%20_%20_%20_%20f_hom%20inv_f%2C%0A%20%20%20%20rw%20prodcomp%2C%0A%20%20%20%20simpa%2C%0A%20%20end%2C%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%0A%7D%0A%0A%0A%0A">here</a>.</p>
<p>You have to use the exact number of blank lines; no more, no less. The <code>skip</code> is not necessary, it just illustrates the goal change. Any tactic which creates a new node in the syntax tree will do I think.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
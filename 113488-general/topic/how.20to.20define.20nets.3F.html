---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/how.20to.20define.20nets.3F.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20to.20define.20nets.3F.html">how to define nets?</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="213711317"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20to%20define%20nets%3F/near/213711317" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aron <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20to.20define.20nets.3F.html#213711317">(Oct 18 2020 at 15:27)</a>:</h4>
<p>I don't think mathlib has an entry for nets, as defined here:<br>
A function from an upward directed set to a set.<br>
How would I go about defining updirsets and then nets?</p>



<a name="213712112"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20to%20define%20nets%3F/near/213712112" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20to.20define.20nets.3F.html#213712112">(Oct 18 2020 at 15:46)</a>:</h4>
<p>I'm not sure whether directed sets exist in mathlib.  But preorders do, so you probably want to start with that notion (<a href="https://leanprover-community.github.io/mathlib_docs/find/preorder">docs#preorder</a>), and add extra hypotheses from there.</p>



<a name="213712136"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20to%20define%20nets%3F/near/213712136" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20to.20define.20nets.3F.html#213712136">(Oct 18 2020 at 15:47)</a>:</h4>
<p>Note that mathlib's topology is built around filters (<a href="https://leanprover-community.github.io/mathlib_docs/find/filter">docs#filter</a>), which are a little more general than nets.</p>



<a name="213712676"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20to%20define%20nets%3F/near/213712676" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20to.20define.20nets.3F.html#213712676">(Oct 18 2020 at 16:00)</a>:</h4>
<p>We have <a href="https://leanprover-community.github.io/mathlib_docs/find/directed_order">docs#directed_order</a></p>



<a name="213712682"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20to%20define%20nets%3F/near/213712682" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20to.20define.20nets.3F.html#213712682">(Oct 18 2020 at 16:00)</a>:</h4>
<p>But most theorems assume <code>[semilattice_sup α]</code> instead</p>



<a name="213712847"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20to%20define%20nets%3F/near/213712847" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20to.20define.20nets.3F.html#213712847">(Oct 18 2020 at 16:04)</a>:</h4>
<p>If you want to migrate theorems to <code>directed_order</code>, you should</p>
<ul>
<li>add a typeclass for the dual notion;</li>
<li>add instance from <code>semilattice_sup</code> to <code>directed_order</code>;</li>
<li>replace <code>[semilattice_sup α]</code> with <code>[directed_order α]</code> in many theorems, e.g., those about <a href="https://leanprover-community.github.io/mathlib_docs/find/filter.at_top">docs#filter.at_top</a></li>
</ul>



<a name="213716374"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20to%20define%20nets%3F/near/213716374" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20to.20define.20nets.3F.html#213716374">(Oct 18 2020 at 17:27)</a>:</h4>
<p>We should have a FAQ entry about why we use filters instead of nets. Filters are much more versatile than nets, and have much better formal properties. There are really much better than nets from every point of view except for the initial learning curve. It doesn't mean people shouldn't have fun formalizing nets using Lean, but we clearly won't switch in mathlib. We could have the definition in mathlib, but duplicating too many things would be very counter-productive and confusing.</p>



<a name="213716605"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20to%20define%20nets%3F/near/213716605" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20to.20define.20nets.3F.html#213716605">(Oct 18 2020 at 17:32)</a>:</h4>
<p>We can switch theorems from <code>[semilattice_sup α]</code> to <code>[directed_order α]</code>, and say "if you want to talk about nets, then use <code>{α : Type*} [directed_order α] [nonempty α] {f : α → β} {l : filter β} (h : tendsto f at_top l)</code></p>



<a name="213929095"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20to%20define%20nets%3F/near/213929095" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aron <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20to.20define.20nets.3F.html#213929095">(Oct 20 2020 at 14:41)</a>:</h4>
<p>Filters might be better than nets, but my professor has a hardon for nets.<br>
I tried doing this on my own, and I'm probably far off the mark:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">topology.metric_space.basic</span> <span class="n">topology.uniform_space.basic</span> <span class="n">order.rel_classes</span> <span class="n">algebra.order</span> <span class="n">order</span>

<span class="kd">class</span> <span class="n">my_updirorder</span> <span class="o">(</span><span class="n">α</span><span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">preorder</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">le_updir</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">c</span> <span class="o">:</span> <span class="n">α</span> <span class="o">,</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">c</span> <span class="bp">∧</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">c</span><span class="o">)</span>
<span class="kd">structure</span> <span class="n">my_updirset</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">):=</span>
<span class="o">(</span><span class="n">set</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span> <span class="o">)</span>
<span class="o">(</span><span class="n">order</span> <span class="o">:</span> <span class="n">my_updirorder</span> <span class="n">α</span> <span class="o">)</span>
<span class="kd">def</span> <span class="n">my_eventually</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="n">Z</span><span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">my_updirset</span> <span class="n">Z</span><span class="o">]</span> <span class="o">[</span><span class="n">set</span> <span class="n">X</span><span class="o">]</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">Z</span> <span class="bp">→</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">Y</span><span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">):=</span><span class="bp">∃</span> <span class="o">(</span><span class="n">n</span><span class="o">:</span><span class="n">Z</span><span class="o">),</span><span class="bp">∀</span> <span class="o">(</span><span class="n">m</span><span class="o">:</span><span class="n">Z</span><span class="o">),</span> <span class="n">m</span> <span class="bp">≥</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">c</span> <span class="n">m</span> <span class="bp">∈</span> <span class="n">Y</span>
</code></pre></div>

<p>The error happens in my_eventually:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">failed</span> <span class="n">to</span> <span class="n">synthesize</span> <span class="n">type</span> <span class="kd">class</span> <span class="kd">instance</span> <span class="n">for</span>
<span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span> <span class="bp">?</span><span class="o">,</span>
<span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span> <span class="bp">?</span><span class="o">,</span>
<span class="n">Z</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">,</span>
<span class="n">_inst_1</span> <span class="o">:</span> <span class="n">my_updirset</span> <span class="n">Z</span><span class="o">,</span>
<span class="n">_inst_2</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">,</span>
<span class="n">c</span> <span class="o">:</span> <span class="n">Z</span> <span class="bp">→</span> <span class="n">X</span><span class="o">,</span>
<span class="n">Y</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">,</span>
<span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="n">Z</span>
<span class="bp">⊢</span> <span class="n">has_le</span> <span class="n">Z</span>
</code></pre></div>

<p>I think it doesn't want to extend has_le from preorder?</p>



<a name="213933367"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20to%20define%20nets%3F/near/213933367" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aron <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20to.20define.20nets.3F.html#213933367">(Oct 20 2020 at 15:11)</a>:</h4>
<p>figured it out, just abandon my_updirset.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
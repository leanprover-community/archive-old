---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/.60multiplicity.60.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60multiplicity.60.html">`multiplicity`</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="209703199"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60multiplicity%60/near/209703199" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60multiplicity.60.html#209703199">(Sep 10 2020 at 20:14)</a>:</h4>
<p><code>multiplicity a b : enat</code> is the biggest <code>n</code> such that <code>a^n</code> divides <code>b</code> (or +infty if a^n divides b for all nats n). Now <code>enat</code> is implemented using <code>roption</code>, and <code>ring_theory.multiplicity</code> is full of <code>get</code>s which are really annoying to use. I think for what I'm doing (valuation rings) it might be much easier to just have this map taking values in <code>with_top nat</code>. </p>
<p>Why is <code>multiplicity</code> <code>enat</code>-valued, and is there room for a <code>with_top nat</code>-valued version of this function? I'm running into all sorts of decidability issues with <code>enat</code>, because <code>0.dom</code> is decidable because <code>0</code> is in nat, but other things are decidable because I'm a mathematician so everything is decidable, and I'm getting type class diamonds.</p>



<a name="209703226"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60multiplicity%60/near/209703226" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60multiplicity.60.html#209703226">(Sep 10 2020 at 20:14)</a>:</h4>
<p>Should I just refactor <code>multiplicity</code>?</p>



<a name="209703667"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60multiplicity%60/near/209703667" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60multiplicity.60.html#209703667">(Sep 10 2020 at 20:19)</a>:</h4>
<p>the answer to "why is <code>multiplicity</code> <code>enat</code>-valued" is "because it was written 2 years ago"</p>



<a name="209703862"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60multiplicity%60/near/209703862" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60multiplicity.60.html#209703862">(Sep 10 2020 at 20:20)</a>:</h4>
<p>more precisely, <a href="https://github.com/leanprover-community/mathlib/commit/b9c5eb05effa1dd3a9d9e10efef7e164d9752f47#diff-c5c00511a698cb8c90e4cc2268ac7694">on Jan 6, 2019</a></p>



<a name="209704130"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60multiplicity%60/near/209704130" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60multiplicity.60.html#209704130">(Sep 10 2020 at 20:22)</a>:</h4>
<p>you can Ctrl+F <code>computable</code> in <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/generalizing.20padic_val.html"><code>maths &gt; generalizing padic_val</code></a></p>



<a name="209704198"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60multiplicity%60/near/209704198" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60multiplicity.60.html#209704198">(Sep 10 2020 at 20:23)</a>:</h4>
<p>also related: <a href="https://github.com/leanprover-community/mathlib/issues/523">#523</a> feat(ring_theory/multiplicity): multiplicity of elements of a ring</p>



<a name="209705112"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60multiplicity%60/near/209705112" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60multiplicity.60.html#209705112">(Sep 10 2020 at 20:31)</a>:</h4>
<p>So you would approve of it being changed to take values in <code>with_top nat</code>?</p>



<a name="209705346"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60multiplicity%60/near/209705346" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60multiplicity.60.html#209705346">(Sep 10 2020 at 20:33)</a>:</h4>
<p>yes</p>



<a name="209706427"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60multiplicity%60/near/209706427" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60multiplicity.60.html#209706427">(Sep 10 2020 at 20:43)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113488-general/topic/.60multiplicity.60/near/209705112">said</a>:</p>
<blockquote>
<p>So you would approve of it being changed to take values in <code>with_top nat</code>?</p>
</blockquote>
<p>Does that really change things?</p>



<a name="209706488"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60multiplicity%60/near/209706488" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60multiplicity.60.html#209706488">(Sep 10 2020 at 20:44)</a>:</h4>
<p>With a good API, you shouldn't be able to tell the difference, right?</p>



<a name="209706691"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60multiplicity%60/near/209706691" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60multiplicity.60.html#209706691">(Sep 10 2020 at 20:46)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span> I think the problem is the same with <code>fintype.card</code></p>



<a name="209706761"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60multiplicity%60/near/209706761" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60multiplicity.60.html#209706761">(Sep 10 2020 at 20:46)</a>:</h4>
<p>i.e. it takes in a typeclass as an argument</p>



<a name="209706775"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60multiplicity%60/near/209706775" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60multiplicity.60.html#209706775">(Sep 10 2020 at 20:46)</a>:</h4>
<p>which causes diamonds</p>



<a name="209706798"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60multiplicity%60/near/209706798" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60multiplicity.60.html#209706798">(Sep 10 2020 at 20:46)</a>:</h4>
<p>if API could solve problems then we wouldn't need to have <code>fincard</code></p>



<a name="209707251"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60multiplicity%60/near/209707251" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60multiplicity.60.html#209707251">(Sep 10 2020 at 20:50)</a>:</h4>
<p>I think the idea is that you can always decide the <code>some</code>ness of an <code>option</code>/<code>with_top</code> by case analysis, so that should remove the need for decidability hypotheses in the API</p>



<a name="209707279"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60multiplicity%60/near/209707279" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60multiplicity.60.html#209707279">(Sep 10 2020 at 20:50)</a>:</h4>
<p>whether or not it just shuffles them elsewhere is another question</p>



<a name="209710594"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60multiplicity%60/near/209710594" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60multiplicity.60.html#209710594">(Sep 10 2020 at 21:18)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span> you can have two different decidability instances on <code>o.dom</code>. Some lemmas about <code>enat</code> are proved with open_locale classical open and some aren't. There's an add order equiv from enat to with_top nat.</p>



<a name="209712968"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60multiplicity%60/near/209712968" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60multiplicity.60.html#209712968">(Sep 10 2020 at 21:38)</a>:</h4>
<p>Is it possible that the problem is actually that <code>enat</code> should be defined as <code>option</code>/<code>with_top</code>/a custom inductive type rather than in terms of <code>roption</code>?</p>



<a name="209713455"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60multiplicity%60/near/209713455" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60multiplicity.60.html#209713455">(Sep 10 2020 at 21:42)</a>:</h4>
<p>That change would also work for me</p>



<a name="209713641"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60multiplicity%60/near/209713641" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60multiplicity.60.html#209713641">(Sep 10 2020 at 21:45)</a>:</h4>
<p>I mean <code>option nat</code> is a perfectly sensible thing to use in computation as well, it's just different from <code>roption nat</code>. So I don't see an obvious reason, if we're going to pick one to call <code>enat</code> and use for math reasoning purposes, to select <code>roption nat</code></p>



<a name="209713662"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60multiplicity%60/near/209713662" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60multiplicity.60.html#209713662">(Sep 10 2020 at 21:45)</a>:</h4>
<p>Here's an example of something which wasn't much fun.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">nat</span><span class="bp">.</span><span class="n">enat</span>

<span class="n">open_locale</span> <span class="n">classical</span>

<span class="kn">namespace</span> <span class="n">enat</span>

<span class="kn">namespace</span> <span class="n">to_with_top_int</span>

<span class="n">noncomputable</span> <span class="n">def</span> <span class="n">coe</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">enat</span><span class="o">)</span> <span class="o">:</span> <span class="n">with_top</span> <span class="bp">ℤ</span> <span class="o">:=</span> <span class="n">option</span><span class="bp">.</span><span class="n">map</span> <span class="n">int</span><span class="bp">.</span><span class="n">of_nat</span> <span class="o">(</span><span class="n">to_with_top</span> <span class="n">n</span><span class="o">)</span>

<span class="n">noncomputable</span> <span class="kn">instance</span> <span class="o">:</span> <span class="n">has_coe</span> <span class="n">enat</span> <span class="o">(</span><span class="n">with_top</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="n">coe</span><span class="bp">⟩</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">,</span> <span class="n">norm_cast</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">coe_zero</span> <span class="o">:</span> <span class="o">((</span><span class="mi">0</span> <span class="o">:</span> <span class="n">enat</span><span class="o">)</span> <span class="o">:</span> <span class="n">with_top</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="c1">-- the next line doesn&#39;t work and I have no idea why</span>
  <span class="c1">-- unfold_coes,</span>
  <span class="k">have</span> <span class="n">ZZZ</span> <span class="o">:</span> <span class="n">option</span><span class="bp">.</span><span class="n">map</span> <span class="n">int</span><span class="bp">.</span><span class="n">of_nat</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">enat</span><span class="o">)</span><span class="bp">.</span><span class="n">to_with_top</span> <span class="bp">=</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">with_top</span> <span class="bp">ℤ</span><span class="o">),</span>
    <span class="n">simp</span><span class="o">,</span> <span class="n">refl</span><span class="o">,</span>
  <span class="c1">-- my understanding of Lean is that the proof below can&#39;t ever work</span>
  <span class="n">convert</span> <span class="n">ZZZ</span><span class="o">,</span>
  <span class="n">dunfold</span> <span class="n">coe</span> <span class="n">lift_t</span> <span class="n">has_lift_t</span><span class="bp">.</span><span class="n">lift</span> <span class="n">coe_t</span> <span class="n">has_coe_t</span><span class="bp">.</span><span class="n">coe</span> <span class="n">coe_b</span> <span class="n">has_coe</span><span class="bp">.</span><span class="n">coe</span><span class="o">,</span>
  <span class="n">unfold</span> <span class="n">coe</span><span class="o">,</span>
  <span class="n">congr&#39;</span>
<span class="kn">end</span>

<span class="kn">end</span> <span class="n">to_with_top_int</span>

<span class="kn">end</span> <span class="n">enat</span>
</code></pre></div>



<a name="209714508"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60multiplicity%60/near/209714508" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60multiplicity.60.html#209714508">(Sep 10 2020 at 21:54)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/113488-general/topic/.60multiplicity.60/near/209713641">said</a>:</p>
<blockquote>
<p>I mean <code>option nat</code> is a perfectly sensible thing to use in computation as well, it's just different from <code>roption nat</code>. So I don't see an obvious reason, if we're going to pick one to call <code>enat</code> and use for math reasoning purposes, to select <code>roption nat</code></p>
</blockquote>
<p>We already have an <code>enat</code> and it's <code>roption nat</code> :-/</p>
<p>I want to do some math reasoning and I had thought I wanted to use <code>multiplicity</code>, but what I want to use is a version of <code>multiplicity</code> taking values in <code>with_top nat</code>. So I have three options:</p>
<p>1) complete refactor of enat<br>
2) leave enat but complete refactor of multiplicity so it takes values in with_top nat<br>
3) make new <code>multiplicity'</code>.</p>
<p>I'm happy with any decision but I don't want to make the decision myself and then find at the PR stage that the maintainers would rather a different solution.</p>



<a name="209714542"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60multiplicity%60/near/209714542" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60multiplicity.60.html#209714542">(Sep 10 2020 at 21:55)</a>:</h4>
<p>Why is everything so horrible?</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">nat</span><span class="bp">.</span><span class="n">enat</span>

<span class="n">open_locale</span> <span class="n">classical</span>

<span class="kn">namespace</span> <span class="n">enat</span>

<span class="n">noncomputable</span> <span class="n">def</span> <span class="n">coe</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">enat</span><span class="o">)</span> <span class="o">:</span> <span class="n">with_top</span> <span class="bp">ℤ</span> <span class="o">:=</span> <span class="n">option</span><span class="bp">.</span><span class="n">map</span> <span class="n">int</span><span class="bp">.</span><span class="n">of_nat</span> <span class="o">(</span><span class="n">to_with_top</span> <span class="n">n</span><span class="o">)</span>

<span class="kn">namespace</span> <span class="n">to_with_top_int</span>

<span class="n">noncomputable</span> <span class="kn">instance</span> <span class="o">:</span> <span class="n">has_coe</span> <span class="n">enat</span> <span class="o">(</span><span class="n">with_top</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="n">coe</span><span class="bp">⟩</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">,</span> <span class="n">norm_cast</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">coe_zero</span> <span class="o">:</span> <span class="o">((</span><span class="mi">0</span> <span class="o">:</span> <span class="n">enat</span><span class="o">)</span> <span class="o">:</span> <span class="n">with_top</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="c1">--  unfold_coes, -- this doesn&#39;t work</span>
<span class="c1">--  unfold coe, -- this doesn&#39;t work</span>
<span class="c1">-- last few coes don&#39;t do anything here</span>
  <span class="n">dunfold</span> <span class="n">coe</span> <span class="n">lift_t</span> <span class="n">has_lift_t</span><span class="bp">.</span><span class="n">lift</span> <span class="n">coe_t</span> <span class="n">has_coe_t</span><span class="bp">.</span><span class="n">coe</span> <span class="n">coe_b</span> <span class="n">has_coe</span><span class="bp">.</span><span class="n">coe</span> <span class="n">coe</span> <span class="n">coe</span> <span class="n">coe</span> <span class="n">coe</span> <span class="n">coe</span> <span class="n">coe</span><span class="o">,</span>
  <span class="n">unfold</span> <span class="n">coe</span><span class="o">,</span>
  <span class="c1">-- we have finally unfolded a coe</span>
  <span class="n">simp</span><span class="o">,</span> <span class="n">refl</span>
<span class="kn">end</span>

<span class="kn">end</span> <span class="n">to_with_top_int</span>

<span class="kn">end</span> <span class="n">enat</span>
</code></pre></div>


<p>I'm convinced this would all be fixed if we were using <code>with_top nat</code> directly.</p>



<a name="209742659"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60multiplicity%60/near/209742659" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60multiplicity.60.html#209742659">(Sep 11 2020 at 05:42)</a>:</h4>
<p>There is a tactic called <code>unfold_coes</code> just for that monstrous first line</p>



<a name="209743267"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60multiplicity%60/near/209743267" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60multiplicity.60.html#209743267">(Sep 11 2020 at 05:56)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> The comments say that it doesn't work</p>



<a name="209743533"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60multiplicity%60/near/209743533" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60multiplicity.60.html#209743533">(Sep 11 2020 at 06:01)</a>:</h4>
<p>Ah, missed that. There is still way too much defeq abuse in this snippet. <code>option.map</code> itself is kind of a problematic definition here since it's using the defeq to option, but this works:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">nat</span><span class="bp">.</span><span class="n">enat</span>

<span class="n">open_locale</span> <span class="n">classical</span>

<span class="kn">namespace</span> <span class="n">enat</span>

<span class="n">noncomputable</span> <span class="n">def</span> <span class="n">coe</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">enat</span><span class="o">)</span> <span class="o">:</span> <span class="n">with_top</span> <span class="bp">ℤ</span> <span class="o">:=</span> <span class="n">option</span><span class="bp">.</span><span class="n">map</span> <span class="n">int</span><span class="bp">.</span><span class="n">of_nat</span> <span class="o">(</span><span class="n">to_with_top</span> <span class="n">n</span><span class="o">)</span>

<span class="kn">namespace</span> <span class="n">to_with_top_int</span>

<span class="n">noncomputable</span> <span class="kn">instance</span> <span class="o">:</span> <span class="n">has_coe</span> <span class="n">enat</span> <span class="o">(</span><span class="n">with_top</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="n">coe</span><span class="bp">⟩</span>

<span class="kn">theorem</span> <span class="n">coe_val</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">enat</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">with_top</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="bp">=</span> <span class="n">option</span><span class="bp">.</span><span class="n">map</span> <span class="n">int</span><span class="bp">.</span><span class="n">of_nat</span> <span class="o">(</span><span class="n">to_with_top</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">,</span> <span class="n">norm_cast</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">coe_zero</span> <span class="o">:</span> <span class="o">((</span><span class="mi">0</span> <span class="o">:</span> <span class="n">enat</span><span class="o">)</span> <span class="o">:</span> <span class="n">with_top</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="k">by</span> <span class="o">{</span><span class="n">simp</span> <span class="o">[</span><span class="n">coe_val</span><span class="o">],</span> <span class="n">refl</span><span class="o">}</span>

<span class="kn">end</span> <span class="n">to_with_top_int</span>

<span class="kn">end</span> <span class="n">enat</span>
</code></pre></div>



<a name="209743832"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60multiplicity%60/near/209743832" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60multiplicity.60.html#209743832">(Sep 11 2020 at 06:07)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">nat</span><span class="bp">.</span><span class="n">enat</span>

<span class="n">open_locale</span> <span class="n">classical</span>

<span class="n">def</span> <span class="n">with_top</span><span class="bp">.</span><span class="n">map</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">}</span> <span class="o">:</span> <span class="o">(</span><span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="bp">→</span> <span class="n">with_top</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">with_top</span> <span class="n">β</span> <span class="o">:=</span> <span class="n">option</span><span class="bp">.</span><span class="n">map</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">theorem</span> <span class="n">with_top</span><span class="bp">.</span><span class="n">map_top</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">with_top</span><span class="bp">.</span><span class="n">map</span> <span class="n">f</span> <span class="err">⊤</span> <span class="bp">=</span> <span class="err">⊤</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">theorem</span> <span class="n">with_top</span><span class="bp">.</span><span class="n">map_val</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">with_top</span><span class="bp">.</span><span class="n">map</span> <span class="n">f</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kn">namespace</span> <span class="n">enat</span>

<span class="n">noncomputable</span> <span class="n">def</span> <span class="n">coe</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">enat</span><span class="o">)</span> <span class="o">:</span> <span class="n">with_top</span> <span class="bp">ℤ</span> <span class="o">:=</span> <span class="n">with_top</span><span class="bp">.</span><span class="n">map</span> <span class="n">int</span><span class="bp">.</span><span class="n">of_nat</span> <span class="o">(</span><span class="n">to_with_top</span> <span class="n">n</span><span class="o">)</span>

<span class="kn">namespace</span> <span class="n">to_with_top_int</span>

<span class="n">noncomputable</span> <span class="kn">instance</span> <span class="o">:</span> <span class="n">has_coe</span> <span class="n">enat</span> <span class="o">(</span><span class="n">with_top</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="n">coe</span><span class="bp">⟩</span>

<span class="kn">theorem</span> <span class="n">coe_val</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">enat</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">with_top</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="bp">=</span> <span class="n">with_top</span><span class="bp">.</span><span class="n">map</span> <span class="n">int</span><span class="bp">.</span><span class="n">of_nat</span> <span class="o">(</span><span class="n">to_with_top</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">,</span> <span class="n">norm_cast</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">coe_zero</span> <span class="o">:</span> <span class="o">((</span><span class="mi">0</span> <span class="o">:</span> <span class="n">enat</span><span class="o">)</span> <span class="o">:</span> <span class="n">with_top</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">coe_val</span><span class="o">,</span> <span class="err">←</span> <span class="n">with_top</span><span class="bp">.</span><span class="n">coe_zero</span><span class="o">]</span>

<span class="kn">end</span> <span class="n">to_with_top_int</span>

<span class="kn">end</span> <span class="n">enat</span>
</code></pre></div>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/nat.2Epow.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/nat.2Epow.html">nat.pow</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="196340778"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/nat.pow/near/196340778" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/nat.2Epow.html#196340778">(May 05 2020 at 17:39)</a>:</h4>
<p>Someone just privately asked me how to prove 1 &lt;= 2^k, and applying <code>one_le_pow_of_one_le</code> doesn't work because <code>nat.has_pow</code> is not definitionally <code>monoid.has_pow</code>. We were always told that nothing could be done about this because it was in core. Is this something which can now be changed though? Or would it just break a gazillion things and nobody can be bothered to fix them? The issue I'm concerned about is that the two functions have different conventions about the succ case: <code>nat.pow</code> is <code>b^n*b</code> and <code>monoid.pow</code> is <code>a*a^n</code> :-(</p>



<a name="196340955"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/nat.pow/near/196340955" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/nat.2Epow.html#196340955">(May 05 2020 at 17:40)</a>:</h4>
<p>I think it mostly requires having someone with enough time and energy.</p>



<a name="196341288"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/nat.pow/near/196341288" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/nat.2Epow.html#196341288">(May 05 2020 at 17:43)</a>:</h4>
<p>there is a theorem to rewrite one in terms of the other</p>



<a name="196341459"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/nat.pow/near/196341459" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/nat.2Epow.html#196341459">(May 05 2020 at 17:45)</a>:</h4>
<p><a href="https://github.com/leanprover-community/lean/pull/128#issuecomment-610281436" title="https://github.com/leanprover-community/lean/pull/128#issuecomment-610281436">https://github.com/leanprover-community/lean/pull/128#issuecomment-610281436</a></p>



<a name="208287624"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/nat.pow/near/208287624" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/nat.2Epow.html#208287624">(Aug 27 2020 at 23:13)</a>:</h4>
<p>an amusing proof that relies on the current <code>nat.pow</code>, perhaps found by <code>library_search</code>?<br>
<a href="https://github.com/leanprover-community/mathlib/blob/master/src/number_theory/primorial.lean#L163-L164">https://github.com/leanprover-community/mathlib/blob/master/src/number_theory/primorial.lean#L163-L164</a></p>



<a name="208304217"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/nat.pow/near/208304217" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/nat.2Epow.html#208304217">(Aug 28 2020 at 04:30)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110043">Gabriel Ebner</span> <a href="#narrow/stream/113488-general/topic/nat.2Epow/near/196341459">said</a>:</p>
<blockquote>
<p><a href="https://github.com/leanprover-community/lean/pull/128#issuecomment-610281436">https://github.com/leanprover-community/lean/pull/128#issuecomment-610281436</a></p>
</blockquote>
<p>I replied to this on github, but let me also ask it here. Lean has VM implementations for <code>nat.pow</code> for reasons of efficiency. But does the VM care whether <code>nat.pow</code> is defined as <code>a*a^n</code> or <code>a^n*a</code>?<br>
If I understand things correctly, it doesn't, right?</p>



<a name="208308428"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/nat.pow/near/208308428" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/nat.2Epow.html#208308428">(Aug 28 2020 at 06:00)</a>:</h4>
<p>It doesn't use either one</p>



<a name="208308450"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/nat.pow/near/208308450" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/nat.2Epow.html#208308450">(Aug 28 2020 at 06:00)</a>:</h4>
<p>But it does care that the function being called is <code>nat.pow</code></p>



<a name="208308474"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/nat.pow/near/208308474" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/nat.2Epow.html#208308474">(Aug 28 2020 at 06:01)</a>:</h4>
<p>if you call another function it won't be automagically replaced with the efficient C++ implementation</p>



<a name="208308495"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/nat.pow/near/208308495" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/nat.2Epow.html#208308495">(Aug 28 2020 at 06:01)</a>:</h4>
<p>Right. Than it is like I expected.</p>



<a name="208350912"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/nat.pow/near/208350912" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/nat.2Epow.html#208350912">(Aug 28 2020 at 14:40)</a>:</h4>
<p>I've seen contradictory comments on whether <code>nat.pow</code> actually has special VM support at all. It seems to me that it doesn't:</p>
<div class="codehilite"><pre><span></span><code><span class="gp">rwbarton@scw-capybara:~/lean/lean$</span> git grep <span class="s1">&#39;&quot;pow&quot;&#39;</span>
<span class="go">src/library/vm/vm_float.cpp:    DECLARE_VM_BUILTIN(name({&quot;native&quot;, &quot;float&quot;, &quot;pow&quot;}),   [](vm_obj const &amp; a1, vm_obj const &amp; a2) {return mk_vm_float(std::pow(to_float(a1), to_float(a2)));});</span>
<span class="gp">rwbarton@scw-capybara:~/lean/lean$</span> git grep <span class="s1">&#39;&quot;mul&quot;&#39;</span>
<span class="go">src/library/vm/vm_float.cpp:    DECLARE_VM_BUILTIN(name({&quot;native&quot;, &quot;float&quot;, &quot;mul&quot;}),   [](vm_obj const &amp; a1, vm_obj const &amp; a2) {return mk_vm_float(to_float(a1) * to_float(a2));});</span>
<span class="go">src/library/vm/vm_int.cpp:    DECLARE_VM_BUILTIN(name({&quot;int&quot;, &quot;mul&quot;}),              int_mul);</span>
<span class="go">src/library/vm/vm_nat.cpp:    DECLARE_VM_BUILTIN(name({&quot;nat&quot;, &quot;mul&quot;}),              nat_mul);</span>
</code></pre></div>



<a name="208351268"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/nat.pow/near/208351268" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/nat.2Epow.html#208351268">(Aug 28 2020 at 14:43)</a>:</h4>
<p>You're right, only the bitwise operations have VM support.  Feel free to <del>r+</del> merge master into the nat.pow removal then.</p>



<a name="208351906"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/nat.pow/near/208351906" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/nat.2Epow.html#208351906">(Aug 28 2020 at 14:48)</a>:</h4>
<p>Whut? So we can just remove <code>nat.pow</code> from core?</p>



<a name="208351927"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/nat.pow/near/208351927" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/nat.2Epow.html#208351927">(Aug 28 2020 at 14:48)</a>:</h4>
<p>Wouldn't it actually be better to add VM support?</p>



<a name="208351935"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/nat.pow/near/208351935" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/nat.2Epow.html#208351935">(Aug 28 2020 at 14:48)</a>:</h4>
<p>Do you  mean Chris's old PR? It didn't build because some of the removed lemmas are used elsewhere in core.<br>
But I'm preparing a new PR that removes everything that depends on <code>nat.pow</code> (including the whole of <code>data.bitvec</code>) with the intention of adding corresponding lemmas about <code>^</code> = <code>monoid.pow</code> to mathlib.</p>



<a name="208351962"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/nat.pow/near/208351962" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/nat.2Epow.html#208351962">(Aug 28 2020 at 14:48)</a>:</h4>
<p>I wasn't necessarily expecting that to work, but it seems to be working.</p>



<a name="208352077"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/nat.pow/near/208352077" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/nat.2Epow.html#208352077">(Aug 28 2020 at 14:49)</a>:</h4>
<p>There's not really that much point in using an optimized <code>nat.pow</code> implementation unless you're calculating <code>0^n</code> or <code>1^n</code> for large <code>n</code>.</p>



<a name="208352556"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/nat.pow/near/208352556" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/nat.2Epow.html#208352556">(Aug 28 2020 at 14:52)</a>:</h4>
<p>Removing <code>nat.pow</code> completely is preferable to having <code>nat.pow</code> with the old implementation because it means there won't be lemmas about the old <code>nat.pow</code>.</p>



<a name="208352814"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/nat.pow/near/208352814" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/nat.2Epow.html#208352814">(Aug 28 2020 at 14:54)</a>:</h4>
<p>I'm pretty sure that you can do better than the naive recursive version though.  You can do <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>n</mi><mn>32</mn></msup></mrow><annotation encoding="application/x-tex">n^{32}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span> in 5 multiplications instead of 31.  There is also a dedicated pow function in gmp.</p>



<a name="208353097"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/nat.pow/near/208353097" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/nat.2Epow.html#208353097">(Aug 28 2020 at 14:57)</a>:</h4>
<p><span class="user-mention" data-user-id="110043">@Gabriel Ebner</span> the naive version uses 32 multiplications, right <span aria-label="grinning face with smiling eyes" class="emoji emoji-1f601" role="img" title="grinning face with smiling eyes">:grinning_face_with_smiling_eyes:</span> <span aria-label="stuck out tongue wink" class="emoji emoji-1f61c" role="img" title="stuck out tongue wink">:stuck_out_tongue_wink:</span></p>



<a name="208455462"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/nat.pow/near/208455462" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/nat.2Epow.html#208455462">(Aug 29 2020 at 21:44)</a>:</h4>
<p>The change to Lean has landed, so <a href="https://github.com/leanprover-community/mathlib/commit/f4aa77ead65d6fc1ee7675b3d21fe2e352134a27">here's</a> my current progrress on the required mathlib changes. Primarily I still need to finish splitting up <code>algebra.group_power</code> and seeing what lemmas I can reuse in <code>data.nat.lemmas</code>. Later, if there are lemmas in the <code>nat</code> namespace that are exactly specializations of their general <code>group_power</code> counterparts, we can remove them completely.</p>
<p>Question: Is it worth adding a <code>has_pow nat nat</code> instance with the normal priority 1000, to be picked up immediately by instance search? I'm inclined to say it doesn't matter much since there are only a total of 12 instances of <code>has_pow</code> in mathlib, and 2 in core. If we do add it (now or in the future) we need to add back the corresponding parts of <code>norm_num</code> and <code>ring</code> (which I have just commented out for now).</p>



<a name="208456768"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/nat.pow/near/208456768" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/nat.2Epow.html#208456768">(Aug 29 2020 at 22:22)</a>:</h4>
<p>I think it is not necessary to have a separate instance <code>has_pow nat nat</code>.</p>



<a name="208457154"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/nat.pow/near/208457154" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/nat.2Epow.html#208457154">(Aug 29 2020 at 22:33)</a>:</h4>
<p>If the plan is to make it defeq to the monoid pow one then do we need it? If the plan is to make it the other one then...well, this can't be the plan, because the plan is to solve the problem, and this is the problem.</p>



<a name="208457166"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/nat.pow/near/208457166" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/nat.2Epow.html#208457166">(Aug 29 2020 at 22:33)</a>:</h4>
<p>There isn't going to be any other one.</p>



<a name="208457192"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/nat.pow/near/208457192" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/nat.2Epow.html#208457192">(Aug 29 2020 at 22:34)</a>:</h4>
<p>The only reason to add it would be so that it gets tried earlier in the instance search order</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/Default.20proofs.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Default.20proofs.html">Default proofs</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="253161425"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Default%20proofs/near/253161425" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Default.20proofs.html#253161425">(Sep 13 2021 at 21:14)</a>:</h4>
<p>So I know how I can provide default arguments to fields of a class, but how can I provide default proofs <em>about them</em>? I know that for <code>nsmul</code> we use a tactic, which makes me fear I can't write a default as I would have wanted to.</p>
<p>Here's what I'm working on (wink wink Anne):</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.finset.basic</span>

<span class="kd">class</span> <span class="n">locally_finite_order</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">preorder</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_rel</span> <span class="o">((</span><span class="bp">≤</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">finset_Icc</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)</span>
<span class="o">(</span><span class="n">finset_Ico</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">finset</span> <span class="n">α</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="o">(</span><span class="n">finset_Icc</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span><span class="bp">.</span><span class="n">filter</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="bp">¬</span><span class="n">b</span> <span class="bp">≤</span> <span class="n">x</span><span class="o">))</span>
<span class="o">(</span><span class="n">finset_Ioc</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">finset</span> <span class="n">α</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="o">(</span><span class="n">finset_Icc</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span><span class="bp">.</span><span class="n">filter</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="bp">¬</span><span class="n">a</span> <span class="bp">≤</span> <span class="n">x</span><span class="o">))</span>
<span class="o">(</span><span class="n">finset_Ioo</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">finset</span> <span class="n">α</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="o">(</span><span class="n">finset_Icc</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span><span class="bp">.</span><span class="n">filter</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="bp">¬</span><span class="n">a</span> <span class="bp">≤</span> <span class="n">x</span> <span class="bp">∧</span> <span class="bp">¬</span><span class="n">b</span> <span class="bp">≤</span> <span class="n">x</span><span class="o">))</span>
<span class="o">(</span><span class="n">finset_mem_Icc</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">finset_Icc</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">↔</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">x</span> <span class="bp">∧</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">b</span><span class="o">)</span>
<span class="o">(</span><span class="n">finset_mem_Ico</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">finset_Ico</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">↔</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">x</span> <span class="bp">∧</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">b</span> <span class="o">:=</span>  <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">x</span><span class="o">,</span> <span class="kd">begin</span>
  <span class="c1">-- I would like to replace `finset_Ico` by `(finset_Icc a b).filter (λ x, ¬a ≤ x)`</span>
<span class="kd">end</span><span class="o">)</span>
<span class="o">(</span><span class="n">finset_mem_Ioc</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">finset_Ioc</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">↔</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">x</span> <span class="bp">∧</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">b</span><span class="o">)</span>
<span class="o">(</span><span class="n">finset_mem_Ioo</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">finset_Ioo</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">↔</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">x</span> <span class="bp">∧</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">b</span><span class="o">)</span>
</code></pre></div>



<a name="253162424"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Default%20proofs/near/253162424" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Default.20proofs.html#253162424">(Sep 13 2021 at 21:20)</a>:</h4>
<p>Indeed, you can only use <code>:= default_val</code> syntax if <code>default_val</code> works always, not only for default arguments.</p>



<a name="253162544"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Default%20proofs/near/253162544" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Default.20proofs.html#253162544">(Sep 13 2021 at 21:21)</a>:</h4>
<p>You can create a bunch of lemmas, write a tactic <code>meta def mytac := </code>[apply_rules [my_lemmas]]<code>, then use </code>. mytac`.</p>



<a name="253162917"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Default%20proofs/near/253162917" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Default.20proofs.html#253162917">(Sep 13 2021 at 21:24)</a>:</h4>
<p>Should be pretty easy here!</p>



<a name="253162936"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Default%20proofs/near/253162936" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Default.20proofs.html#253162936">(Sep 13 2021 at 21:24)</a>:</h4>
<p>But that's disappointing Lean doesn't allow that. Is there any technical limitation?</p>



<a name="253163827"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Default%20proofs/near/253163827" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Default.20proofs.html#253163827">(Sep 13 2021 at 21:30)</a>:</h4>
<p>Yes, the field has to be type correct</p>



<a name="253163852"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Default%20proofs/near/253163852" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Default.20proofs.html#253163852">(Sep 13 2021 at 21:31)</a>:</h4>
<p>I suppose you could call that a technical limitation</p>



<a name="253163912"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Default%20proofs/near/253163912" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Default.20proofs.html#253163912">(Sep 13 2021 at 21:31)</a>:</h4>
<p>Hmm... <span aria-label="thinking" class="emoji emoji-1f914" role="img" title="thinking">:thinking:</span></p>



<a name="253163989"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Default%20proofs/near/253163989" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Default.20proofs.html#253163989">(Sep 13 2021 at 21:32)</a>:</h4>
<p>The standard workaround for this is to use tactics instead, like Yury says. For example see the lt fields in <a href="https://leanprover-community.github.io/mathlib_docs/find/preorder">docs#preorder</a></p>



<a name="253164030"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Default%20proofs/near/253164030" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Default.20proofs.html#253164030">(Sep 13 2021 at 21:32)</a>:</h4>
<p>The technical limitation rather sounds like you can't "undefault" a field that depends on another default field that's been provided by the user.</p>



<a name="253164052"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Default%20proofs/near/253164052" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Default.20proofs.html#253164052">(Sep 13 2021 at 21:32)</a>:</h4>
<p><code>order_laws_tac</code> is just <code>intros; refl</code></p>



<a name="253164164"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Default%20proofs/near/253164164" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Default.20proofs.html#253164164">(Sep 13 2021 at 21:33)</a>:</h4>
<p>Exactly; you would be in trouble if you have <code>def foo (a := 1) (b : a = 1 := rfl)</code> and then decided to use <code>foo 2 _</code></p>



<a name="253164236"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Default%20proofs/near/253164236" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Default.20proofs.html#253164236">(Sep 13 2021 at 21:34)</a>:</h4>
<p>or more to the point, <code>@foo 2</code></p>



<a name="253164274"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Default%20proofs/near/253164274" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Default.20proofs.html#253164274">(Sep 13 2021 at 21:34)</a>:</h4>
<p>which has the type <code>\forall  (b : 2 = 1 := rfl), ...</code> which doesn't typecheck</p>



<a name="253164286"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Default%20proofs/near/253164286" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Default.20proofs.html#253164286">(Sep 13 2021 at 21:34)</a>:</h4>
<p>I guess I don't know how default arguments work.</p>



<a name="253164384"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Default%20proofs/near/253164384" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Default.20proofs.html#253164384">(Sep 13 2021 at 21:35)</a>:</h4>
<p>A default argument <code>(a : nat := 1)</code> is just sugar for <code>(a : opt_param nat 1)</code></p>



<a name="253164424"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Default%20proofs/near/253164424" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Default.20proofs.html#253164424">(Sep 13 2021 at 21:35)</a>:</h4>
<p>I guess I don't know how <code>out_param</code> works <span aria-label="rofl" class="emoji emoji-1f923" role="img" title="rofl">:rofl:</span></p>



<a name="253164426"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Default%20proofs/near/253164426" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Default.20proofs.html#253164426">(Sep 13 2021 at 21:35)</a>:</h4>
<p>and the type signature of <a href="https://leanprover-community.github.io/mathlib_docs/find/opt_param">docs#opt_param</a> makes it clear that you can't put a default value that doesn't match the type</p>



<a name="253164527"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Default%20proofs/near/253164527" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Default.20proofs.html#253164527">(Sep 13 2021 at 21:36)</a>:</h4>
<p>that is, <code>opt_param (2 = 1) rfl</code> doesn't typecheck because <code>rfl : 2 = 1</code> fails</p>



<a name="253164559"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Default%20proofs/near/253164559" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Default.20proofs.html#253164559">(Sep 13 2021 at 21:36)</a>:</h4>
<p>this is before we've even used the definition, mind</p>



<a name="253164587"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Default%20proofs/near/253164587" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Default.20proofs.html#253164587">(Sep 13 2021 at 21:37)</a>:</h4>
<p>Urf, yeah</p>



<a name="253164654"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Default%20proofs/near/253164654" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Default.20proofs.html#253164654">(Sep 13 2021 at 21:38)</a>:</h4>
<p>using tactics ("auto_param") works around this because we don't try to elaborate it until the definition is used</p>



<a name="253164888"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Default%20proofs/near/253164888" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Default.20proofs.html#253164888">(Sep 13 2021 at 21:39)</a>:</h4>
<p><span class="user-mention silent" data-user-id="387244">Yaël Dillies</span> <a href="#narrow/stream/113488-general/topic/Default.20proofs/near/253164424">said</a>:</p>
<blockquote>
<p>I guess I don't know how <code>out_param</code> works <span aria-label="rofl" class="emoji emoji-1f923" role="img" title="rofl">:rofl:</span></p>
</blockquote>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[reducible]</span> <span class="kd">def</span> <span class="n">out_param</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span> <span class="o">:=</span> <span class="n">α</span>
</code></pre></div>
<p>What could be simpler? It's just <code>id</code>!</p>



<a name="253164897"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Default%20proofs/near/253164897" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Default.20proofs.html#253164897">(Sep 13 2021 at 21:39)</a>:</h4>
<p>unfortunately you can't actually specify a tactic block in lean 3 (lean 4 lets you do this) because <code>tactic</code> is <code>meta</code> so terms of that type can't appear in definitions, so instead you have to specify the name of a tactic like <code>order_laws_tac</code></p>



<a name="253164971"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Default%20proofs/near/253164971" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Default.20proofs.html#253164971">(Sep 13 2021 at 21:40)</a>:</h4>
<p>which is the reason for all the indirection</p>



<a name="253165007"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Default%20proofs/near/253165007" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Default.20proofs.html#253165007">(Sep 13 2021 at 21:40)</a>:</h4>
<p>actually that's <code>out_param</code>, not <code>opt_param</code></p>



<a name="253165067"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Default%20proofs/near/253165067" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Default.20proofs.html#253165067">(Sep 13 2021 at 21:40)</a>:</h4>
<p><code>opt_param</code> is only slightly more complicated:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[reducible]</span> <span class="kd">def</span> <span class="n">opt_param</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">default</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span> <span class="o">:=</span> <span class="n">α</span>
</code></pre></div>



<a name="253165247"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Default%20proofs/near/253165247" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Default.20proofs.html#253165247">(Sep 13 2021 at 21:42)</a>:</h4>
<p>In maths we call that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><msub><mi>r</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">pr_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">p</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p>



<a name="253165355"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Default%20proofs/near/253165355" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Default.20proofs.html#253165355">(Sep 13 2021 at 21:43)</a>:</h4>
<p>It was when you were working on modules a few years ago that it all dawned on me that stuff like id can be harder than it looks.</p>



<a name="253178465"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Default%20proofs/near/253178465" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Default.20proofs.html#253178465">(Sep 13 2021 at 23:57)</a>:</h4>
<p>When does the elaborator populate an opt_param with its default vs leaving it as a binder?</p>



<a name="253179699"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Default%20proofs/near/253179699" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Default.20proofs.html#253179699">(Sep 14 2021 at 00:08)</a>:</h4>
<p>If it is a regular application <code>f a b</code> and the third argument is <code>c := ...</code> then it will insert the default value</p>



<a name="253179751"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Default%20proofs/near/253179751" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Default.20proofs.html#253179751">(Sep 14 2021 at 00:09)</a>:</h4>
<p>basically, if there are any pis left over in a regular application and they are auto/opt params then it will insert them</p>



<a name="253179868"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Default%20proofs/near/253179868" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Default.20proofs.html#253179868">(Sep 14 2021 at 00:11)</a>:</h4>
<p>Unlike implicits and typeclass args, they don't work if used out of order:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">foo</span> <span class="o">(</span><span class="n">a</span> <span class="o">:=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:=</span> <span class="mi">1</span>
<span class="k">#check</span> <span class="n">foo</span> <span class="n">_</span> <span class="mi">3</span> <span class="c1">-- foo ?M_1 3 : ℕ</span>
</code></pre></div>



<a name="253179896"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Default%20proofs/near/253179896" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Default.20proofs.html#253179896">(Sep 14 2021 at 00:11)</a>:</h4>
<p>If you use <code>@foo</code> or <code>@@foo</code> then it will disable all argument insertion</p>



<a name="253215380"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Default%20proofs/near/253215380" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Default.20proofs.html#253215380">(Sep 14 2021 at 08:28)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113488-general/topic/Default.20proofs/near/253164654">said</a>:</p>
<blockquote>
<p>using tactics ("auto_param") works around this because we don't try to elaborate it until the definition is used</p>
</blockquote>
<p>Why can't this be the default behavior?</p>



<a name="253216746"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Default%20proofs/near/253216746" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Default.20proofs.html#253216746">(Sep 14 2021 at 08:40)</a>:</h4>
<p>Also, I tried the customized tactic trick, but I'm stuck because I can't reproduce the state that the tactic must solve. With the same example as above, if I do not provide <code>finset_Ico</code>, I get in <code>finset_mem_Ico</code> the goal I expect except for the fact that <code>finset_Icc</code> has been replaced by its definition (which stops me from using <code>finset_mem_Icc</code>). But when I do not provide <code>finset_mem_Ico</code> either, my tactic sees a goal where <code>finset_Ico</code> nor  <code>finset_Icc</code> have been replaced by their definitions, but <code>unfold locally_finite_order.finset_Ico</code> or <code>rw locally_finite_order.finset_Ico</code>won't do anything.</p>



<a name="253216868"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Default%20proofs/near/253216868" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Default.20proofs.html#253216868">(Sep 14 2021 at 08:42)</a>:</h4>
<p>/me is writing a MWE</p>



<a name="253225307"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Default%20proofs/near/253225307" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Default.20proofs.html#253225307">(Sep 14 2021 at 10:00)</a>:</h4>
<p>I don't understand what's happening in either case.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.set.finite</span>

<span class="kn">section</span> <span class="n">tactic</span>
<span class="kn">open</span> <span class="n">tactic</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">finset_Ico_laws_tac</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="n">whnf_target</span> <span class="bp">&gt;&gt;</span> <span class="n">intros</span> <span class="bp">&gt;&gt;</span> <span class="n">to_expr</span><span class="bp">``</span><span class="o">(</span><span class="kd">begin</span>
  <span class="n">unfold</span> <span class="n">locally_finite_order.finset_Ico</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">finset.mem_filter</span><span class="o">,</span> <span class="n">finset_mem_Icc</span><span class="o">,</span> <span class="n">and_assoc</span><span class="o">,</span> <span class="n">lt_iff_le_not_le</span><span class="o">]</span>
<span class="kd">end</span><span class="o">)</span> <span class="bp">&gt;&gt;=</span> <span class="n">exact</span>

<span class="kd">end</span> <span class="n">tactic</span>

<span class="kn">open</span> <span class="n">finset</span>

<span class="kd">class</span> <span class="n">locally_finite_order</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">preorder</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_rel</span> <span class="o">((</span><span class="bp">≤</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">finset_Icc</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)</span>
<span class="o">(</span><span class="n">finset_Ico</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">finset</span> <span class="n">α</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="o">(</span><span class="n">finset_Icc</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span><span class="bp">.</span><span class="n">filter</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="bp">¬</span><span class="n">b</span> <span class="bp">≤</span> <span class="n">x</span><span class="o">))</span>
<span class="o">(</span><span class="n">finset_mem_Icc</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">finset_Icc</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">↔</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">x</span> <span class="bp">∧</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">b</span><span class="o">)</span>
<span class="o">(</span><span class="n">finset_mem_Ico</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">finset_Ico</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">↔</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">x</span> <span class="bp">∧</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="n">b</span> <span class="bp">.</span> <span class="n">finset_Ico_laws_tac</span><span class="o">)</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">preorder</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_rel</span> <span class="o">((</span><span class="bp">≤</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)]</span>

<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">locally_finite_order_of_finite_Icc'</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="o">(</span><span class="n">set.Icc</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span><span class="bp">.</span><span class="n">finite</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">locally_finite_order</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">finset_Icc</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="o">(</span><span class="n">h</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span><span class="bp">.</span><span class="n">to_finset</span><span class="o">,</span>
  <span class="n">finset_mem_Icc</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">x</span><span class="o">,</span> <span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">set.finite.mem_to_finset</span><span class="o">,</span> <span class="n">set.mem_Icc</span><span class="o">]</span> <span class="o">}</span>
<span class="c">/-</span><span class="cm">simplify tactic failed to simplify</span>
<span class="cm">state:</span>
<span class="cm">α : Type u_1,</span>
<span class="cm">_inst_1 : preorder α,</span>
<span class="cm">_inst_2 : decidable_rel has_le.le,</span>
<span class="cm">h : ∀ (a b : α), (set.Icc a b).finite,</span>
<span class="cm">a b x : α</span>
<span class="cm">⊢ ?m_1</span>
<span class="cm">state:</span>
<span class="cm">α : Type u_1,</span>
<span class="cm">_inst_1 : preorder α,</span>
<span class="cm">_inst_2 : decidable_rel has_le.le,</span>
<span class="cm">h : ∀ (a b : α), (set.Icc a b).finite,</span>
<span class="cm">a b x : α</span>
<span class="cm">⊢ x ∈ filter (λ (x : α), ¬preorder.le b x) _.to_finset ↔ a ≤ x ∧ x &lt; b-/</span>

<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">locally_finite_order_of_finite_Icc</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="o">(</span><span class="n">set.Icc</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span><span class="bp">.</span><span class="n">finite</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">locally_finite_order</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">finset_Icc</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="o">(</span><span class="n">h</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span><span class="bp">.</span><span class="n">to_finset</span><span class="o">,</span>
  <span class="n">finset_mem_Icc</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">x</span><span class="o">,</span> <span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">set.finite.mem_to_finset</span><span class="o">,</span> <span class="n">set.mem_Icc</span><span class="o">],</span>
  <span class="n">finset_mem_Ico</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">x</span><span class="o">,</span> <span class="kd">begin</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">finset.mem_filter</span><span class="o">,</span> <span class="n">finset_mem_Icc</span><span class="o">,</span> <span class="n">and_assoc</span><span class="o">,</span> <span class="n">lt_iff_le_not_le</span><span class="o">],</span> <span class="c1">-- finset_mem_Icc</span>
  <span class="kd">end</span> <span class="o">}</span>
</code></pre></div>



<a name="253288816"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Default%20proofs/near/253288816" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Default.20proofs.html#253288816">(Sep 14 2021 at 17:21)</a>:</h4>
<p>Bump! Has anybody ideas?</p>



<a name="253289313"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Default%20proofs/near/253289313" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Default.20proofs.html#253289313">(Sep 14 2021 at 17:24)</a>:</h4>
<p>I switched to <code>change</code> and it seems more reliable, but I'm still blindcoding</p>



<a name="253306704"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Default%20proofs/near/253306704" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Default.20proofs.html#253306704">(Sep 14 2021 at 19:14)</a>:</h4>
<p>Why don't you just write a lemma instead of reproving the lemma every time someone uses your theorem?</p>



<a name="253309509"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Default%20proofs/near/253309509" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Default.20proofs.html#253309509">(Sep 14 2021 at 19:31)</a>:</h4>
<p>Hm, this has the unfortunate requirement that it needs <code>finset_mem_Icc</code> to be a hypothesis in scope, so you have to write the thing a little weirdly if you want to avoid repeating yourself:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.set.finite</span>

<span class="kd">theorem</span> <span class="n">locally_finite_order.mem_Ico_of_mem_Icc</span>
  <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">preorder</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_rel</span> <span class="o">((</span><span class="bp">≤</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)]</span>
  <span class="o">{</span><span class="n">finset_Icc</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">finset</span> <span class="n">α</span><span class="o">}</span>
  <span class="o">(</span><span class="n">finset_mem_Icc</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">finset_Icc</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">↔</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">x</span> <span class="bp">∧</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">b</span><span class="o">)</span>
  <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="o">(</span><span class="n">finset_Icc</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span><span class="bp">.</span><span class="n">filter</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="bp">¬</span><span class="n">b</span> <span class="bp">≤</span> <span class="n">x</span><span class="o">)</span> <span class="bp">↔</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">x</span> <span class="bp">∧</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="n">b</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">finset.mem_filter</span><span class="o">,</span> <span class="n">finset_mem_Icc</span><span class="o">,</span> <span class="n">and_assoc</span><span class="o">,</span> <span class="n">lt_iff_le_not_le</span><span class="o">]</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">finset_Ico_laws_tac</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="bp">`</span><span class="o">[</span><span class="n">exact</span> <span class="n">locally_finite_order.mem_Ico_of_mem_Icc</span> <span class="n">finset_mem_Icc</span><span class="o">]</span>

<span class="kd">class</span> <span class="n">locally_finite_order</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">preorder</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_rel</span> <span class="o">((</span><span class="bp">≤</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">finset_Icc</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)</span>
<span class="o">(</span><span class="n">finset_Ico</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">finset</span> <span class="n">α</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="o">(</span><span class="n">finset_Icc</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span><span class="bp">.</span><span class="n">filter</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="bp">¬</span><span class="n">b</span> <span class="bp">≤</span> <span class="n">x</span><span class="o">))</span>
<span class="o">(</span><span class="n">finset_mem_Icc</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">finset_Icc</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">↔</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">x</span> <span class="bp">∧</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">b</span><span class="o">)</span>
<span class="o">(</span><span class="n">finset_mem_Ico</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">finset_Ico</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">↔</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">x</span> <span class="bp">∧</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="n">b</span> <span class="bp">.</span> <span class="n">finset_Ico_laws_tac</span><span class="o">)</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">preorder</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_rel</span> <span class="o">((</span><span class="bp">≤</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)]</span>

<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">locally_finite_order_of_finite_Icc'</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="o">(</span><span class="n">set.Icc</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span><span class="bp">.</span><span class="n">finite</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">locally_finite_order</span> <span class="n">α</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">suffices</span> <span class="n">finset_mem_Icc</span><span class="o">,</span>
  <span class="n">exact</span> <span class="o">{</span> <span class="n">finset_Icc</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="o">(</span><span class="n">h</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span><span class="bp">.</span><span class="n">to_finset</span><span class="o">,</span>
          <span class="n">finset_mem_Icc</span> <span class="o">:=</span> <span class="n">finset_mem_Icc</span> <span class="o">},</span>
  <span class="n">exact</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">x</span><span class="o">,</span> <span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">set.finite.mem_to_finset</span><span class="o">,</span> <span class="n">set.mem_Icc</span><span class="o">],</span>
<span class="kd">end</span>
</code></pre></div>



<a name="253309671"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Default%20proofs/near/253309671" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Default.20proofs.html#253309671">(Sep 14 2021 at 19:31)</a>:</h4>
<p><span class="user-mention" data-user-id="387244">@Yaël Dillies</span></p>



<a name="253312289"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Default%20proofs/near/253312289" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Default.20proofs.html#253312289">(Sep 14 2021 at 19:47)</a>:</h4>
<p>Why can <code>order_laws_tac</code> work using the definition of <code>≤</code> while<code>finset_Ico_laws_tac</code> can't use <code>finset_mem_Icc</code>?</p>



<a name="253312640"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Default%20proofs/near/253312640" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Default.20proofs.html#253312640">(Sep 14 2021 at 19:49)</a>:</h4>
<p>Is what I'm trying to achieve that exotic?</p>



<a name="253313168"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Default%20proofs/near/253313168" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Default.20proofs.html#253313168">(Sep 14 2021 at 19:52)</a>:</h4>
<p>Because <code>order_laws_tac</code> doesn't need to reference anything outside its own statement for the proof, the proof is just <code>rfl</code> if you leave the default alone</p>



<a name="253313240"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Default%20proofs/near/253313240" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Default.20proofs.html#253313240">(Sep 14 2021 at 19:53)</a>:</h4>
<p>In your case, the proof for <code>finset_mem_Ico</code> depends on the proof of <code>finset_mem_Icc</code></p>



<a name="253313726"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Default%20proofs/near/253313726" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Default.20proofs.html#253313726">(Sep 14 2021 at 19:56)</a>:</h4>
<p>I have a very hackish idea to get around this that would look for the current goal metavariable in the "result" (the term under construction), and hunt around in the parent of that expression to find the sibling proof of <code>finset_mem_Ico</code></p>



<a name="253313982"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Default%20proofs/near/253313982" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Default.20proofs.html#253313982">(Sep 14 2021 at 19:58)</a>:</h4>
<p>That's the behavior I would have expected <span aria-label="smiley" class="emoji emoji-1f603" role="img" title="smiley">:smiley:</span></p>



<a name="253314092"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Default%20proofs/near/253314092" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Default.20proofs.html#253314092">(Sep 14 2021 at 19:58)</a>:</h4>
<p>because you can make fields dependent on others anyway, so that makes sense to be able to reference them.</p>



<a name="253314421"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Default%20proofs/near/253314421" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Default.20proofs.html#253314421">(Sep 14 2021 at 20:00)</a>:</h4>
<p>Here's a way to use spurious dependencies to make it work:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.set.finite</span>

<span class="kd">abbreviation</span> <span class="n">id_annotate</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">{</span><span class="n">β</span><span class="o">}</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">:=</span> <span class="n">b</span>

<span class="kd">theorem</span> <span class="n">locally_finite_order.mem_Ico_of_mem_Icc</span>
  <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">preorder</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_rel</span> <span class="o">((</span><span class="bp">≤</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)]</span>
  <span class="o">{</span><span class="n">finset_Icc</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">finset</span> <span class="n">α</span><span class="o">}</span>
  <span class="o">(</span><span class="n">finset_mem_Icc</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">finset_Icc</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">↔</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">x</span> <span class="bp">∧</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">id_annotate</span> <span class="n">finset_mem_Icc</span>
    <span class="o">(</span><span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">x</span> <span class="bp">∈</span> <span class="o">(</span><span class="n">finset_Icc</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span><span class="bp">.</span><span class="n">filter</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="bp">¬</span><span class="n">b</span> <span class="bp">≤</span> <span class="n">x</span><span class="o">)</span> <span class="bp">↔</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">x</span> <span class="bp">∧</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">x</span><span class="o">,</span> <span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">finset.mem_filter</span><span class="o">,</span> <span class="n">finset_mem_Icc</span><span class="o">,</span> <span class="n">and_assoc</span><span class="o">,</span> <span class="n">lt_iff_le_not_le</span><span class="o">]</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">finset_Ico_laws_tac</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="bp">`</span><span class="o">[</span><span class="n">exact</span> <span class="n">locally_finite_order.mem_Ico_of_mem_Icc</span> <span class="n">_</span><span class="o">]</span>

<span class="kd">class</span> <span class="n">locally_finite_order</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">preorder</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_rel</span> <span class="o">((</span><span class="bp">≤</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">finset_Icc</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)</span>
<span class="o">(</span><span class="n">finset_Ico</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">finset</span> <span class="n">α</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="o">(</span><span class="n">finset_Icc</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span><span class="bp">.</span><span class="n">filter</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="bp">¬</span><span class="n">b</span> <span class="bp">≤</span> <span class="n">x</span><span class="o">))</span>
<span class="o">(</span><span class="n">finset_mem_Icc</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">finset_Icc</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">↔</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">x</span> <span class="bp">∧</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">b</span><span class="o">)</span>
<span class="o">(</span><span class="n">finset_mem_Ico</span> <span class="o">:</span> <span class="n">id_annotate</span> <span class="n">finset_mem_Icc</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">finset_Ico</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">↔</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">x</span> <span class="bp">∧</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="n">b</span><span class="o">)</span> <span class="bp">.</span> <span class="n">finset_Ico_laws_tac</span><span class="o">)</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">preorder</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_rel</span> <span class="o">((</span><span class="bp">≤</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)]</span>

<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">locally_finite_order_of_finite_Icc'</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="o">(</span><span class="n">set.Icc</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span><span class="bp">.</span><span class="n">finite</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">locally_finite_order</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">finset_Icc</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="o">(</span><span class="n">h</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span><span class="bp">.</span><span class="n">to_finset</span><span class="o">,</span>
  <span class="n">finset_mem_Icc</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">x</span><span class="o">,</span> <span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">set.finite.mem_to_finset</span><span class="o">,</span> <span class="n">set.mem_Icc</span><span class="o">]</span> <span class="o">}</span>
</code></pre></div>



<a name="253315053"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Default%20proofs/near/253315053" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Default.20proofs.html#253315053">(Sep 14 2021 at 20:04)</a>:</h4>
<p>Ahah! The trick is to force <code>finset_mem_Icc</code> to appear in the context?</p>



<a name="253315114"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Default%20proofs/near/253315114" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Default.20proofs.html#253315114">(Sep 14 2021 at 20:04)</a>:</h4>
<p>You're a wizard, Mario. Thank you.</p>



<a name="253315117"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Default%20proofs/near/253315117" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Default.20proofs.html#253315117">(Sep 14 2021 at 20:04)</a>:</h4>
<p>in this case, we aren't putting it in the context, we're putting it in the <em>type</em> of the goal</p>



<a name="253315208"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Default%20proofs/near/253315208" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Default.20proofs.html#253315208">(Sep 14 2021 at 20:05)</a>:</h4>
<p>so lean can figure it out by unification</p>



<a name="253315284"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Default%20proofs/near/253315284" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Default.20proofs.html#253315284">(Sep 14 2021 at 20:05)</a>:</h4>
<p>I'm not sure I understand, but I'll keep that in mind for when I'll learn more about metaprogramming.</p>



<a name="253315370"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Default%20proofs/near/253315370" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Default.20proofs.html#253315370">(Sep 14 2021 at 20:06)</a>:</h4>
<p>If you actually want to prove <code>finset_mem_Ico</code> it is now uglified a bit, but autoparams also uglify the goal so I guess it's not that much worse</p>



<a name="253315470"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Default%20proofs/near/253315470" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Default.20proofs.html#253315470">(Sep 14 2021 at 20:06)</a>:</h4>
<p>this is actually pretty light on actual metaprogramming, this is more like elaborator-programming</p>



<a name="253315481"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Default%20proofs/near/253315481" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Default.20proofs.html#253315481">(Sep 14 2021 at 20:06)</a>:</h4>
<p>Can the abbreviation be made local?</p>



<a name="253315546"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Default%20proofs/near/253315546" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Default.20proofs.html#253315546">(Sep 14 2021 at 20:07)</a>:</h4>
<p>Actually I would probably want to lift it to <code>init.core</code> or <code>logic.basic</code> or so</p>



<a name="253315559"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Default%20proofs/near/253315559" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Default.20proofs.html#253315559">(Sep 14 2021 at 20:07)</a>:</h4>
<p>as you can see it's quite general</p>



<a name="253315709"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Default%20proofs/near/253315709" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Default.20proofs.html#253315709">(Sep 14 2021 at 20:08)</a>:</h4>
<p>But I didn't see an exact match among the annotation identity functions that lean has already</p>



<a name="253315720"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Default%20proofs/near/253315720" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Default.20proofs.html#253315720">(Sep 14 2021 at 20:08)</a>:</h4>
<p>Ah yeah, why not (even though it probably already exists?), but I was more thinking about stopping it from appearing in the goal.</p>



<a name="253315776"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Default%20proofs/near/253315776" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Default.20proofs.html#253315776">(Sep 14 2021 at 20:08)</a>:</h4>
<p>it's reducible so probably breathing lightly on it will make it go away</p>



<a name="253315855"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Default%20proofs/near/253315855" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Default.20proofs.html#253315855">(Sep 14 2021 at 20:09)</a>:</h4>
<p>in particular, if you want to prove that goal the first thing you do will probably be <code>intros a b x</code> and that will get rid of the junk</p>



<a name="253315859"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Default%20proofs/near/253315859" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Default.20proofs.html#253315859">(Sep 14 2021 at 20:09)</a>:</h4>
<p>What a metaphor. What else is there to scare it away?</p>



<a name="253315893"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Default%20proofs/near/253315893" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Default.20proofs.html#253315893">(Sep 14 2021 at 20:09)</a>:</h4>
<p>Ah yeah! then that's probably fine.</p>



<a name="253316167"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Default%20proofs/near/253316167" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Default.20proofs.html#253316167">(Sep 14 2021 at 20:11)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113488-general/topic/Default.20proofs/near/253315546">said</a>:</p>
<blockquote>
<p>Actually I would probably want to lift it to <code>init.core</code> or <code>logic.basic</code> or so</p>
</blockquote>
<p>Do <em>you</em> want to do that? I have no idea how to name it nor where to put it further than what you said.</p>



<a name="253316916"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Default%20proofs/near/253316916" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Default.20proofs.html#253316916">(Sep 14 2021 at 20:16)</a>:</h4>
<p>Put it in the <code>miscellaneous</code> section of <code>logic.basic</code> for now, if you are working on a PR</p>



<a name="253414120"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Default%20proofs/near/253414120" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Itai Bar-Natan <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Default.20proofs.html#253414120">(Sep 15 2021 at 13:35)</a>:</h4>
<p>Perhaps it's possible to use something like <code>ite</code> to make the dependent field only take a default value if the base field is the default value? Something that looks roughly like</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">finset_mem_Ico</span> <span class="o">:</span> <span class="n">ite</span> <span class="o">(</span><span class="n">finset_Ico</span> <span class="bp">=</span> <span class="n">default_value</span><span class="o">)</span>
  <span class="o">(</span><span class="n">opt_param</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">finset_Icc</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">↔</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">x</span> <span class="bp">∧</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="bp">...</span><span class="o">))</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">finset_Icc</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">↔</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">x</span> <span class="bp">∧</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">b</span><span class="o">)</span>
</code></pre></div>
<p>I don't think <code>ite</code> is definitionally equal to the <code>opt_param</code> option and even if it is I'm worried the optional parameter mechanism won't evaluate the type to recognize <code>opt_param</code>, but maybe some modification of this (perhaps with the ". tactic" system that I haven't learned yet) can be used for a general mechanism for dependent optional parameters.</p>



<a name="253419164"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Default%20proofs/near/253419164" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Default.20proofs.html#253419164">(Sep 15 2021 at 14:03)</a>:</h4>
<p>This can't work like that because <code>finset_Ico = default_value</code> is always true for correct <code>locally_finite_order</code> declarations. <code>=</code> can't distinguish between propositional and definitional equality. But maybe you can instead put in a tactic that tries <code>refl</code> and changes branch depending on its success or failure?<br>
Also note that an <code>ite</code>can't do it because you need the hypothesis <code>finset_Ico = default_value</code> to fill in the <code>(...)</code>. You must use <code>dite</code> instead.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/Notation.20for.20set(like).20product.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Notation.20for.20set(like).20product.html">Notation for set(like) product</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="267023179"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Notation%20for%20set%28like%29%20product/near/267023179" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Notation.20for.20set(like).20product.html#267023179">(Jan 06 2022 at 04:00)</a>:</h4>
<p>I want to introduce</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">has_set_prod</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">γ</span> <span class="o">:</span> <span class="n">out_param</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">prod</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">γ</span><span class="o">)</span>

<span class="kd">infix</span> <span class="bp">`×ˢ`</span><span class="o">:</span><span class="mi">72</span> <span class="o">:=</span> <span class="n">has_set_prod.prod</span>
</code></pre></div>
<p>with instances for <code>set</code>s, <code>finset</code>s, <code>sub*</code> structures.</p>



<a name="267023271"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Notation%20for%20set%28like%29%20product/near/267023271" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Notation.20for.20set(like).20product.html#267023271">(Jan 06 2022 at 04:01)</a>:</h4>
<p>For non-sets we'll probably need a class that extends <code>has_set_prod</code> and adds an axiom <code>(x, y) ∈ s ×ˢ t = x ∈ s ∧ y ∈ t</code>.</p>



<a name="267023333"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Notation%20for%20set%28like%29%20product/near/267023333" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Notation.20for.20set(like).20product.html#267023333">(Jan 06 2022 at 04:02)</a>:</h4>
<p>Actually, we can add some <code>has_mem</code> arguments to <code>has_set_prod</code> and require <code>(x, y) ∈ s ×ˢ t = x ∈ s ∧ y ∈ t</code> right away.</p>



<a name="267023372"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Notation%20for%20set%28like%29%20product/near/267023372" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Notation.20for.20set(like).20product.html#267023372">(Jan 06 2022 at 04:03)</a>:</h4>
<p>What do you think? What precedence should I use (72 is just a number above 70 which is used for intersection)?</p>



<a name="267023394"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Notation%20for%20set%28like%29%20product/near/267023394" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Notation.20for.20set(like).20product.html#267023394">(Jan 06 2022 at 04:04)</a>:</h4>
<p>I'm quite a fan of this. Right now we have to use <code>.prod</code> right?</p>



<a name="267023636"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Notation%20for%20set%28like%29%20product/near/267023636" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Notation.20for.20set(like).20product.html#267023636">(Jan 06 2022 at 04:08)</a>:</h4>
<p>Yes.</p>



<a name="267023728"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Notation%20for%20set%28like%29%20product/near/267023728" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Notation.20for.20set(like).20product.html#267023728">(Jan 06 2022 at 04:10)</a>:</h4>
<p>A downside is that Lean can no longer infer the types of <code>s</code> and <code>t</code> in <code>s ×ˢ t</code> from the type of the expression.</p>



<a name="267023889"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Notation%20for%20set%28like%29%20product/near/267023889" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Notation.20for.20set(like).20product.html#267023889">(Jan 06 2022 at 04:14)</a>:</h4>
<p>This is a good idea! An analogue for pi types would be great too!</p>



<a name="267024212"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Notation%20for%20set%28like%29%20product/near/267024212" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Notation.20for.20set(like).20product.html#267024212">(Jan 06 2022 at 04:22)</a>:</h4>
<p>I don't want to do 2 refactors at once. Every time I tried it, I failed and merged none to the master.</p>



<a name="267024374"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Notation%20for%20set%28like%29%20product/near/267024374" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Notation.20for.20set(like).20product.html#267024374">(Jan 06 2022 at 04:26)</a>:</h4>
<p>I'll start by migrating <code>set.prod</code>.</p>



<a name="267026912"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Notation%20for%20set%28like%29%20product/near/267026912" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Notation.20for.20set(like).20product.html#267026912">(Jan 06 2022 at 05:21)</a>:</h4>
<p>Here's another sort of design for this that, while isn't quite so universe polymorphic, is able to say how it's related to the Cartesian product:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">universes</span> <span class="n">u</span>

<span class="kd">class</span> <span class="n">has_set_prod</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">set_prod</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">},</span> <span class="n">S</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">S</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">S</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">β</span><span class="o">))</span>

<span class="kd">infix</span> <span class="bp">`×ˢ`</span><span class="o">:</span><span class="mi">72</span> <span class="o">:=</span> <span class="n">has_set_prod.set_prod</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_set_prod</span> <span class="n">set</span> <span class="o">:=</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">α</span> <span class="n">β</span> <span class="n">s</span> <span class="n">t</span><span class="o">,</span> <span class="n">s.prod</span> <span class="n">t</span><span class="o">⟩</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">s</span> <span class="n">t</span> <span class="n">u</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">×ˢ</span> <span class="n">t</span> <span class="bp">×ˢ</span> <span class="n">u</span> <span class="bp">=</span> <span class="o">(</span><span class="n">s.prod</span> <span class="n">t</span><span class="o">)</span><span class="bp">.</span><span class="n">prod</span> <span class="n">u</span> <span class="o">:=</span> <span class="n">rfl</span>
</code></pre></div>
<p>I'm not sure if there's a good way to fix it, except for it taking three functions as arguments.  Too bad there's not a way, at the typeclass level, to say "these are all the same function but with different universe variables", since there's not really a good <code>out_param</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">has_set_prod</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span> <span class="bp">→</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">S'</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span> <span class="bp">→</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">S''</span> <span class="o">:</span> <span class="n">out_param</span> <span class="bp">$</span> <span class="kt">Type</span><span class="bp">*</span> <span class="bp">→</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">set_prod</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">},</span> <span class="n">S</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">S'</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">S''</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">β</span><span class="o">))</span>

<span class="kd">infix</span> <span class="bp">`×ˢ`</span><span class="o">:</span><span class="mi">72</span> <span class="o">:=</span> <span class="n">has_set_prod.set_prod</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_set_prod</span> <span class="n">set</span> <span class="n">set</span> <span class="n">set</span> <span class="o">:=</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">α</span> <span class="n">β</span> <span class="n">s</span> <span class="n">t</span><span class="o">,</span> <span class="n">s.prod</span> <span class="n">t</span><span class="o">⟩</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">s</span> <span class="n">t</span> <span class="n">u</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">×ˢ</span> <span class="n">t</span> <span class="bp">×ˢ</span> <span class="n">u</span> <span class="bp">=</span> <span class="o">(</span><span class="n">s.prod</span> <span class="n">t</span><span class="o">)</span><span class="bp">.</span><span class="n">prod</span> <span class="n">u</span> <span class="o">:=</span> <span class="n">rfl</span>
</code></pre></div>



<a name="267027166"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Notation%20for%20set%28like%29%20product/near/267027166" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Notation.20for.20set(like).20product.html#267027166">(Jan 06 2022 at 05:27)</a>:</h4>
<p>I don't think that your approach will work better with elaborator. And it won't work with <code>submonoid</code>s because <code>submonoid</code> takes <code>M : Type*</code> and <code>[monoid M]</code>.</p>



<a name="267226383"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Notation%20for%20set%28like%29%20product/near/267226383" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Notation.20for.20set(like).20product.html#267226383">(Jan 07 2022 at 18:46)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/pull/11300">#11300</a></p>



<a name="267707732"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Notation%20for%20set%28like%29%20product/near/267707732" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Notation.20for.20set(like).20product.html#267707732">(Jan 12 2022 at 10:47)</a>:</h4>
<p>In the sphere eversion project I'm getting some unfortunate errors like this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">don't</span> <span class="n">know</span> <span class="n">how</span> <span class="n">to</span> <span class="n">synthesize</span> <span class="n">placeholder</span>
<span class="bp">⊢</span> <span class="n">has_set_prod</span> <span class="o">(</span><span class="n">set</span> <span class="bp">?</span><span class="n">m_1</span><span class="o">)</span> <span class="o">(</span><span class="n">set</span> <span class="o">(</span><span class="n">ι</span> <span class="bp">→</span> <span class="n">F</span><span class="o">))</span> <span class="o">(</span><span class="n">set</span> <span class="o">(</span><span class="n">F</span> <span class="bp">×</span> <span class="o">(</span><span class="n">ι</span> <span class="bp">→</span> <span class="n">F</span><span class="o">)))</span>
</code></pre></div>
<p>Is the intended notation now to give the explicit type to <code>univ</code> when using it in a product, like this: <code>@univ A ×ˢ s</code>?</p>



<a name="267707828"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Notation%20for%20set%28like%29%20product/near/267707828" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Notation.20for.20set(like).20product.html#267707828">(Jan 12 2022 at 10:48)</a>:</h4>
<p>cc <span class="user-mention" data-user-id="214703">@Yury G. Kudryashov</span></p>



<a name="267710192"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Notation%20for%20set%28like%29%20product/near/267710192" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Notation.20for.20set(like).20product.html#267710192">(Jan 12 2022 at 11:12)</a>:</h4>
<p>Probably <code>(univ : set A)</code> is the intended spelling</p>



<a name="267710262"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Notation%20for%20set%28like%29%20product/near/267710262" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Notation.20for.20set(like).20product.html#267710262">(Jan 12 2022 at 11:13)</a>:</h4>
<p>I think the problem is that there is no way for <code>×ˢ</code> to know that its left and right arguments are the same type of container, as <code>set A</code> and <code>set B</code> are not even the same families of type when A and B are in different universes</p>



<a name="267712297"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Notation%20for%20set%28like%29%20product/near/267712297" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Notation.20for.20set(like).20product.html#267712297">(Jan 12 2022 at 11:36)</a>:</h4>
<p>Maybe there's some janky <code>same_family</code> typeclass we can use like</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/-- A class that finds a version of `f`, a family of types in universe `u`,</span>
<span class="sd">that lives in universe `v` -/</span>
<span class="kd">class</span> <span class="n">same_family</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">out_param</span> <span class="o">(</span><span class="n">ι</span> <span class="bp">→</span> <span class="kt">Sort</span> <span class="n">v</span><span class="o">))</span><span class="bp">.</span>
</code></pre></div>
<p>which would help the elaborator with this kind of thing</p>



<a name="267716094"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Notation%20for%20set%28like%29%20product/near/267716094" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Notation.20for.20set(like).20product.html#267716094">(Jan 12 2022 at 12:21)</a>:</h4>
<p>Would that work for <code>α</code> and <code>β</code> in different universes? Then we can't use the same <code>ι</code>, right?</p>



<a name="267719096"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Notation%20for%20set%28like%29%20product/near/267719096" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Notation.20for.20set(like).20product.html#267719096">(Jan 12 2022 at 12:50)</a>:</h4>
<p>Oh, good point</p>



<a name="267798263"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Notation%20for%20set%28like%29%20product/near/267798263" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Notation.20for.20set(like).20product.html#267798263">(Jan 12 2022 at 22:50)</a>:</h4>
<p>/poll It seems that we have the following options:<br>
continue using <code>set.prod</code>, <code>submonoid.prod</code> etc;<br>
introduce different notations for <code>set.prod</code>, <code>submonoid.prod</code> etc;<br>
have to specify the type of <code>univ</code> in <code>univ ×ˢ t</code> (and similarly for the empty set)</p>



<a name="267798620"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Notation%20for%20set%28like%29%20product/near/267798620" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Notation.20for.20set(like).20product.html#267798620">(Jan 12 2022 at 22:54)</a>:</h4>
<p>Given that we can use dot notation, I'm happy to keep the <code>set.prod</code>, <code>submonoid.prod</code> alternative. This also keeps it in line with all the other type-like operations, like <a href="https://leanprover-community.github.io/mathlib_docs/find/finset.sigma">docs#finset.sigma</a>, <code>finset.disj_sum</code> (in <a href="https://github.com/leanprover-community/mathlib/pull/11355">#11355</a>), <a href="https://leanprover-community.github.io/mathlib_docs/find/finset.pi">docs#finset.pi</a>, <a href="https://leanprover-community.github.io/mathlib_docs/find/finset.dfinsupp">docs#finset.dfinsupp</a>, <a href="https://leanprover-community.github.io/mathlib_docs/find/finset.sym">docs#finset.sym</a>, ...</p>



<a name="267799888"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Notation%20for%20set%28like%29%20product/near/267799888" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Notation.20for.20set(like).20product.html#267799888">(Jan 12 2022 at 23:06)</a>:</h4>
<p>We can have notation for <code>s.prod t</code> without specifying which prod is meant</p>



<a name="267799908"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Notation%20for%20set%28like%29%20product/near/267799908" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Notation.20for.20set(like).20product.html#267799908">(Jan 12 2022 at 23:06)</a>:</h4>
<p>Notation supports that</p>



<a name="267799959"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Notation%20for%20set%28like%29%20product/near/267799959" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Notation.20for.20set(like).20product.html#267799959">(Jan 12 2022 at 23:07)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/finset.product">docs#finset.product</a></p>



<a name="267806953"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Notation%20for%20set%28like%29%20product/near/267806953" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Notation.20for.20set(like).20product.html#267806953">(Jan 13 2022 at 00:12)</a>:</h4>
<p>So, should we revert <a href="https://github.com/leanprover-community/mathlib/pull/11300">#11300</a>?</p>



<a name="267828426"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Notation%20for%20set%28like%29%20product/near/267828426" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Notation.20for.20set(like).20product.html#267828426">(Jan 13 2022 at 06:17)</a>:</h4>
<p>For what it's worth, I really liked what <a href="https://github.com/leanprover-community/mathlib/pull/11300">#11300</a> did.</p>



<a name="267835132"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Notation%20for%20set%28like%29%20product/near/267835132" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Notation.20for.20set(like).20product.html#267835132">(Jan 13 2022 at 08:05)</a>:</h4>
<p>I don't care much either way, but I'll probably keep using <code>.prod</code> myself.</p>



<a name="267926464"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Notation%20for%20set%28like%29%20product/near/267926464" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Notation.20for.20set(like).20product.html#267926464">(Jan 13 2022 at 20:34)</a>:</h4>
<p>You can't use <code>.prod</code> with <a href="https://github.com/leanprover-community/mathlib/pull/11300">#11300</a></p>



<a name="267926485"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Notation%20for%20set%28like%29%20product/near/267926485" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Notation.20for.20set(like).20product.html#267926485">(Jan 13 2022 at 20:34)</a>:</h4>
<p>(for <code>set</code>s)</p>



<a name="267927084"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Notation%20for%20set%28like%29%20product/near/267927084" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Notation.20for.20set(like).20product.html#267927084">(Jan 13 2022 at 20:40)</a>:</h4>
<p>I think that despite this issue of having to provide explicit arguments to <code>univ</code>, I still prefer the new situation over the old one.</p>



<a name="267927103"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Notation%20for%20set%28like%29%20product/near/267927103" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Notation.20for.20set(like).20product.html#267927103">(Jan 13 2022 at 20:40)</a>:</h4>
<p>Oh</p>



<a name="267927426"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Notation%20for%20set%28like%29%20product/near/267927426" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Notation.20for.20set(like).20product.html#267927426">(Jan 13 2022 at 20:43)</a>:</h4>
<p>I prefer the new notation (otherwise I wouldn't have introduced it) but this is not a strong preference. If someone will really wants to revert this change, then I'm OK with it (especially if I'm not the one who resolves conflicts after <code>git revert 2865d8c2278c86</code>).</p>



<a name="267933520"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Notation%20for%20set%28like%29%20product/near/267933520" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Notation.20for.20set(like).20product.html#267933520">(Jan 13 2022 at 21:28)</a>:</h4>
<p>I genuinely don't mind much either way, so let's keep it like that for now.</p>



<a name="267957684"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Notation%20for%20set%28like%29%20product/near/267957684" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Notation.20for.20set(like).20product.html#267957684">(Jan 14 2022 at 01:43)</a>:</h4>
<p>If we decide to leave this notation for set product, then the next question is whether we should migrate <code>submonoid.prod</code> etc to this notation (e.g., by introducing a typeclass <code>set_like.has_prod</code> that extends <code>has_set_prod</code> and adds an assumption <code>(x, y) ∈ s ×ˢ t ↔ x ∈ s ∧ y ∈ t</code>)?</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
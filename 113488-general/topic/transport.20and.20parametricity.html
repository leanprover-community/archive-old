---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/transport.20and.20parametricity.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html">transport and parametricity</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="164621456"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/164621456" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#164621456">(May 01 2019 at 13:02)</a>:</h4>
<p>I could put some time on transfer and parametricity. I'll have to get a refresher on parametricity though. But this project is still useful. Although it will likely be replaced in Lean 4, when we do have a FFI, we can start building CS applications that themselves may be more portable.</p>



<a name="164621612"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/164621612" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#164621612">(May 01 2019 at 13:05)</a>:</h4>
<p>The math is moving forward pretty nicely. Meanwhile the CS side of mathlib and other Lean packages is still under furnished. Please forgive us for spending time on it ;-)</p>



<a name="164621748"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/164621748" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#164621748">(May 01 2019 at 13:07)</a>:</h4>
<p>Btw, do you have any time for parametricity and transfer? We could pick it up today if you like</p>



<a name="164621804"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/164621804" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#164621804">(May 01 2019 at 13:08)</a>:</h4>
<p>I have time today, but I don't have the required knowledge</p>



<a name="164621813"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/164621813" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#164621813">(May 01 2019 at 13:08)</a>:</h4>
<p>I can only repeat what Kevin wrote hundreds of times</p>



<a name="164621816"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/164621816" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#164621816">(May 01 2019 at 13:08)</a>:</h4>
<p>Maybe I should talk to <span class="user-mention" data-user-id="110193">@Cyril Cohen</span> again</p>



<a name="164621826"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/164621826" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#164621826">(May 01 2019 at 13:09)</a>:</h4>
<p>We need Lean to understand that isomorphic stuff have the same properties, for any property that makes sense</p>



<a name="164622622"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/164622622" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#164622622">(May 01 2019 at 13:22)</a>:</h4>
<p>Simon, if you want a nice project for today, you could redo my leancrawler correctly. The goal is to be able to display the graph of all concepts in a Lean project, where each declaration is a node, and each edge means a declaration uses another declaration. Mine is unfortunately really bad, many edges are missing</p>



<a name="164623443"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/164623443" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#164623443">(May 01 2019 at 13:35)</a>:</h4>
<p>You misunderstand me. I'm not looking for new projects. I'm trying to find help for the projects I already have</p>



<a name="164623646"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/164623646" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Keeley Hoek <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#164623646">(May 01 2019 at 13:38)</a>:</h4>
<p><span class="user-mention" data-user-id="110031">@Patrick Massot</span> a bit of an aside, but a fellow one of Scott's students has just started working on <code>iso_induction</code>, using an isomorphism <code>X ≅ Y</code> to replace every object <code>Y</code> that's in your goal with an <code>X</code> (and hopefully changing nothing else). At the moment it can show that for <code>X</code> and <code>Y</code> isomorphic types, to prove <code>inhabited Y</code> it suffices to show <code>inhabited X</code>! But this is done with some very general typeclass instances pertaining to functoriality. Not too long from now you should be able to add a command after the definition of e.g. <code>local_ring</code> which generates a proof of functoriality of the construction, and then be done with transporting such structure. (At least that's the plan, anyway!)</p>



<a name="164623953"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/164623953" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#164623953">(May 01 2019 at 13:43)</a>:</h4>
<p>Interesting. I got a fair amount of push back when I tried focusing on isomorphisms for transport. That seemed like a good goal to me but Johannes didn't seem to like that idea</p>



<a name="164630636"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/164630636" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#164630636">(May 01 2019 at 15:13)</a>:</h4>
<p>I wish I understood all of this better. I still keep coming back to the same idea -- if R is a local ring and S is isomorphic to R then S is local, and I cannot see why Lean can't auto-generate this theorem using some sequence of <code>equiv</code>s. <code>R</code> and <code>S</code> are ring-equiv, so the lattice of ideals of R and of S are lattice-equiv, and the definition of local ring is some predicate on these lattices which only depends on the lattice structure so commutes with the equiv. If someone wants to update <a href="https://github.com/leanprover-community/mathlib/issues/408" target="_blank" title="https://github.com/leanprover-community/mathlib/issues/408">https://github.com/leanprover-community/mathlib/issues/408</a> so I understand better the plan for implementing this in Lean, maybe I would get less frustrated by this issue :-/</p>



<a name="164630718"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/164630718" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#164630718">(May 01 2019 at 15:14)</a>:</h4>
<p>(deleted)</p>



<a name="164972721"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/164972721" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#164972721">(May 06 2019 at 11:05)</a>:</h4>
<p>I have two fintypes <code>S</code> and <code>T</code>, an equiv <code>S \equiv T</code>, a proof that all reflexive binary relations on <code>S</code> are transitive, and I want to deduce that all reflexive binary relations on <code>T</code> are transitive.  I am adding this to my list of transport complaints ;-) The maths proof is: "consider a reflexive binary relation on <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.13889em;">T</span></span></span></span>; this obviously induces a reflexive binary relation on <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.05764em;">S</span></span></span></span>; the induced relation is transitive; hence obviously the original relation is transitive". </p>
<p>How to do this in Lean in a clean and clear way?</p>
<hr>
<p>Background: I asked my students (in last year's exam) to prove that if <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.02778em;">r</span></span></span></span> was a reflexive binary relation on a set <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.05764em;">S</span></span></span></span> with two elements, then <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.02778em;">r</span></span></span></span> was transitive. <span class="user-mention" data-user-id="130500">@Abhimanyu Pallavi Sudhir</span> wrote up the solutions in Lean and he assumed that <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.05764em;">S</span></span></span></span> was <code>fin 2</code>. In a solution to such a question a mathematician would not think twice if a student wrote "WLOG <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>=</mo><mo>{</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo>}</mo></mrow><annotation encoding="application/x-tex">S=\{0,1\}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mrel">=</span><span class="mopen">{</span><span class="mord mathrm">0</span><span class="mpunct">,</span><span class="mord mathrm">1</span><span class="mclose">}</span></span></span></span>"; it is indistinguishable from "let the elements of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.05764em;">S</span></span></span></span> be called <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">x</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.03588em;">y</span></span></span></span>". In fact assuming <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.05764em;">S</span></span></span></span> is <code>bool</code> makes life even easier, but then one is faced with the question above.</p>



<a name="164973498"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/164973498" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#164973498">(May 06 2019 at 11:21)</a>:</h4>
<p>I don't think this is the answer you wanted but</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">equiv</span><span class="bp">.</span><span class="n">basic</span>

<span class="kn">example</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">α</span> <span class="err">≃</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">r</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">,</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">r</span> <span class="n">x</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span><span class="o">,</span> <span class="n">r</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">r</span> <span class="n">y</span> <span class="n">z</span> <span class="bp">→</span> <span class="n">r</span> <span class="n">x</span> <span class="n">z</span><span class="o">))</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">r</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">β</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">,</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">r</span> <span class="n">x</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span><span class="o">,</span> <span class="n">r</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">r</span> <span class="n">y</span> <span class="n">z</span> <span class="bp">→</span> <span class="n">r</span> <span class="n">x</span> <span class="n">z</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">r</span> <span class="n">hrefl</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="n">hxy</span> <span class="n">hyz</span><span class="o">,</span> <span class="k">begin</span>
  <span class="n">rw</span> <span class="o">[</span><span class="err">←</span> <span class="n">equiv</span><span class="bp">.</span><span class="n">apply_symm_apply</span> <span class="n">e</span> <span class="n">x</span><span class="o">,</span> <span class="err">←</span> <span class="n">equiv</span><span class="bp">.</span><span class="n">apply_symm_apply</span> <span class="n">e</span> <span class="n">z</span><span class="o">],</span>
  <span class="n">rw</span> <span class="o">[</span><span class="err">←</span> <span class="n">equiv</span><span class="bp">.</span><span class="n">apply_symm_apply</span> <span class="n">e</span> <span class="n">x</span><span class="o">,</span> <span class="err">←</span> <span class="n">equiv</span><span class="bp">.</span><span class="n">apply_symm_apply</span> <span class="n">e</span> <span class="n">y</span><span class="o">]</span> <span class="n">at</span> <span class="n">hxy</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="err">←</span> <span class="n">equiv</span><span class="bp">.</span><span class="n">apply_symm_apply</span> <span class="n">e</span> <span class="n">y</span><span class="o">,</span> <span class="err">←</span> <span class="n">equiv</span><span class="bp">.</span><span class="n">apply_symm_apply</span> <span class="n">e</span> <span class="n">z</span><span class="o">]</span> <span class="n">at</span> <span class="n">hyz</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">h</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">r</span> <span class="o">(</span><span class="n">e</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">e</span> <span class="n">y</span><span class="o">))</span> <span class="o">(</span><span class="bp">λ</span> <span class="bp">_</span><span class="o">,</span> <span class="n">hrefl</span> <span class="bp">_</span><span class="o">)</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">hxy</span> <span class="n">hyz</span>
<span class="kn">end</span>
</pre></div>



<a name="164973691"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/164973691" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#164973691">(May 06 2019 at 11:25)</a>:</h4>
<p>Now Kenny golfs it (-;</p>



<a name="164973732"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/164973732" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#164973732">(May 06 2019 at 11:26)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">equiv</span><span class="bp">.</span><span class="n">basic</span>

<span class="kn">example</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">α</span> <span class="err">≃</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">r</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">,</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">r</span> <span class="n">x</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span><span class="o">,</span> <span class="n">r</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">r</span> <span class="n">y</span> <span class="n">z</span> <span class="bp">→</span> <span class="n">r</span> <span class="n">x</span> <span class="n">z</span><span class="o">))</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">r</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">β</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">,</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">r</span> <span class="n">x</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span><span class="o">,</span> <span class="n">r</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">r</span> <span class="n">y</span> <span class="n">z</span> <span class="bp">→</span> <span class="n">r</span> <span class="n">x</span> <span class="n">z</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">r</span> <span class="n">hrefl</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="n">hxy</span> <span class="n">hyz</span><span class="o">,</span> <span class="k">begin</span>
  <span class="n">rw</span> <span class="o">[</span><span class="err">←</span> <span class="n">equiv</span><span class="bp">.</span><span class="n">apply_symm_apply</span> <span class="n">e</span> <span class="n">x</span><span class="o">,</span> <span class="err">←</span> <span class="n">equiv</span><span class="bp">.</span><span class="n">apply_symm_apply</span> <span class="n">e</span> <span class="n">z</span><span class="o">]</span> <span class="n">at</span> <span class="err">\</span><span class="bp">|-</span> <span class="n">hxy</span> <span class="n">hyz</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">h</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">r</span> <span class="o">(</span><span class="n">e</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">e</span> <span class="n">y</span><span class="o">))</span> <span class="o">(</span><span class="bp">λ</span> <span class="bp">_</span><span class="o">,</span> <span class="n">hrefl</span> <span class="bp">_</span><span class="o">)</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">hxy</span> <span class="n">hyz</span>
<span class="kn">end</span>
</pre></div>



<a name="164973840"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/164973840" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#164973840">(May 06 2019 at 11:27)</a>:</h4>
<p>Also, you missed the chance to use projection notation</p>



<a name="164973841"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/164973841" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#164973841">(May 06 2019 at 11:27)</a>:</h4>
<p>You clearly didn't run that one</p>



<a name="164973889"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/164973889" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#164973889">(May 06 2019 at 11:28)</a>:</h4>
<p>I haven't fired up Lean since a long time</p>



<a name="164973900"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/164973900" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#164973900">(May 06 2019 at 11:28)</a>:</h4>
<p>And your internal type checker is rusty (-;</p>



<a name="164973950"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/164973950" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#164973950">(May 06 2019 at 11:29)</a>:</h4>
<p>You're still running Lean 3.4.1, aren't you?</p>



<a name="164974024"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/164974024" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#164974024">(May 06 2019 at 11:30)</a>:</h4>
<p>I'm staying off Lean until after the exam</p>



<a name="164974108"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/164974108" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#164974108">(May 06 2019 at 11:31)</a>:</h4>
<p>Too bad that your exam is also staying off Lean</p>



<a name="164993381"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/164993381" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#164993381">(May 06 2019 at 15:54)</a>:</h4>
<p>Yeah, I can prove it too; but I just know deep down that this is a special case of a general principle; given <code>e</code> and <code>h</code>, a mathematician knows in their soul that the goal is true, and doesn't want to prove it. The question, I think, is how to prove it with a tactic. I have more time for this now; Mario posted something a month or two ago but I was completely focussed on the perfectoid project at the time and didn't want to get distracted; now I am interested again.</p>
<p>My proof was more mundane: given rb on beta I literally built ra on alpha using the equiv, proved that the relationship on beta one can build from ra is rb again, and then just transferred everything manually.</p>
<p>But my point is that this should somehow be a one-liner.</p>



<a name="164998189"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/164998189" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jesse Michael Han <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#164998189">(May 06 2019 at 16:50)</a>:</h4>
<p>essentially Kevin's approach, but <code>big_bertha</code> style:</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">equiv</span><span class="bp">.</span><span class="n">basic</span>

<span class="kn">example</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">α</span> <span class="err">≃</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">r</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">,</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">r</span> <span class="n">x</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span><span class="o">,</span> <span class="n">r</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">r</span> <span class="n">y</span> <span class="n">z</span> <span class="bp">→</span> <span class="n">r</span> <span class="n">x</span> <span class="n">z</span><span class="o">))</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">r</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">β</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">,</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">r</span> <span class="n">x</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span><span class="o">,</span> <span class="n">r</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">r</span> <span class="n">y</span> <span class="n">z</span> <span class="bp">→</span> <span class="n">r</span> <span class="n">x</span> <span class="n">z</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">intros</span> <span class="n">r</span> <span class="n">H</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">r&#39;</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">r</span> <span class="o">(</span><span class="n">e</span><span class="bp">.</span><span class="mi">1</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">e</span><span class="bp">.</span><span class="mi">1</span> <span class="n">b</span><span class="o">),</span>
  <span class="n">specialize</span> <span class="n">h</span> <span class="n">r&#39;</span> <span class="o">(</span><span class="k">by</span> <span class="n">finish</span><span class="o">)</span> <span class="o">(</span><span class="n">e</span><span class="bp">.</span><span class="mi">2</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">e</span><span class="bp">.</span><span class="mi">2</span> <span class="n">y</span><span class="o">)</span> <span class="o">(</span><span class="n">e</span><span class="bp">.</span><span class="mi">2</span> <span class="n">z</span><span class="o">),</span>
  <span class="o">{[</span><span class="n">smt</span><span class="o">]</span> <span class="n">eblast_using</span><span class="o">[</span><span class="n">e</span><span class="bp">.</span><span class="mi">4</span><span class="o">,</span> <span class="o">(</span><span class="k">by</span> <span class="n">simp</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">r</span> <span class="o">(</span><span class="n">e</span><span class="bp">.</span><span class="mi">1</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">e</span><span class="bp">.</span><span class="mi">1</span> <span class="n">b</span><span class="o">)</span> <span class="bp">↔</span> <span class="n">r&#39;</span> <span class="n">a</span> <span class="n">b</span><span class="o">)]}</span>
<span class="kn">end</span>
</pre></div>



<a name="164999356"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/164999356" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jesse Michael Han <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#164999356">(May 06 2019 at 17:05)</a>:</h4>
<p>this doesn't quite do what Kevin wants, but we can see that proving the transfer is automatic; we just have to state it. all the constructed data/lemmas in the above proof are very follow-your-nose, so it's conceivable that one could whip up a tactic that attempts to use <code>equiv.to_fun</code> and <code>equiv.inv_fun</code> to produce the requisite data when it sees a lemma in context like <code>h</code> which is applicable "modulo equivalence"</p>



<a name="165023729"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/165023729" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#165023729">(May 06 2019 at 22:14)</a>:</h4>
<p>There is a transfer style proof of this theorem. Floris mentioned wanting to get working on adding more transfer lemmas; I should PR <code>equiv.rel</code> if it hasn't made it in yet, it's pretty important for these kinds of proofs</p>



<a name="167886462"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/167886462" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#167886462">(Jun 11 2019 at 20:15)</a>:</h4>
<p><a href="http://scholar.google.co.uk/scholar_url?url=http://www2.mat.ulaval.ca/fileadmin/Pages_personnelles_des_profs/hm/H14_Mac_Lane_Phil_Math_1996.pdf&amp;hl=en&amp;sa=X&amp;scisig=AAGBfm2Jux_hxs-Oz__pML2nCyJqSwH5vw&amp;nossl=1&amp;oi=scholarr" target="_blank" title="http://scholar.google.co.uk/scholar_url?url=http://www2.mat.ulaval.ca/fileadmin/Pages_personnelles_des_profs/hm/H14_Mac_Lane_Phil_Math_1996.pdf&amp;hl=en&amp;sa=X&amp;scisig=AAGBfm2Jux_hxs-Oz__pML2nCyJqSwH5vw&amp;nossl=1&amp;oi=scholarr">In this old paper by MacLane</a> he sketches on p179 what he says Bourbaki calls a "type" of "structure". His definition of structure is sufficiently general to allow topological spaces.</p>
<p>What is confusing me is the claim on p180 that a type of structure leads to the notion of morphism from one model of the structure to another; I'm not sure these words mean the same thing nowadays but what he's saying is that the axioms for a group give you a structure and now you can figure out what a homomorphism of groups is. But he's also saying that the axioms for a topological space give you a structure and now you can figure out what a homomorphism of topological spaces is. I did not know this. Is it true? MacLane offers no proof. I am fine with the idea that you can figure out what an <em>isomorphism</em> of structures is, but I don't see how to guess what a morphism of topological spaces is. There are some vague comments about how the power set can be covariant or contravariant, but I am confused about whether this co/contravariance is supposed to be part of the structure. Is this just a load of old codswallop or is there something here which can be made rigorous?</p>



<a name="167887254"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/167887254" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#167887254">(Jun 11 2019 at 20:26)</a>:</h4>
<p><span class="user-mention" data-user-id="210057">@Fabian Glöckle</span> <span aria-label="up" class="emoji emoji-2b06" role="img" title="up">:up:</span> This might be relevant to what you are implementing</p>



<a name="167887817"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/167887817" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#167887817">(Jun 11 2019 at 20:33)</a>:</h4>
<p>Does anyone know the reference to Bourbaki where they define these "types of structures"?</p>



<a name="167892115"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/167892115" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#167892115">(Jun 11 2019 at 21:29)</a>:</h4>
<p><a href="https://link-springer-com.iclibezp1.cc.ic.ac.uk/content/pdf/10.1007%2F978-3-540-34035-5.pdf" target="_blank" title="https://link-springer-com.iclibezp1.cc.ic.ac.uk/content/pdf/10.1007%2F978-3-540-34035-5.pdf">https://link-springer-com.iclibezp1.cc.ic.ac.uk/content/pdf/10.1007%2F978-3-540-34035-5.pdf</a> I think.<br>
Chaiptre IV is called structures. It's in Théorie des ensembles</p>



<a name="167894846"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/167894846" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#167894846">(Jun 11 2019 at 22:08)</a>:</h4>
<p>Thanks Chris. I've found it. Bourbaki don't just define a morphism between two structures, they have some additional data (basically the axioms that the map has to satisfy!). They explicitly give the example of topological spaces and how morphisms can either be open maps or continuous maps depending on the additional data (denoted <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.03588em;">σ</span></span></span></span>), on p215 of the pdf, section 2.1 of chapter IV. In fact they explicitly flag with a bendy road sign the fact that given just a structure, you don't have enough information to define morphisms of structures.</p>



<a name="167918782"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/167918782" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Fabian Glöckle <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#167918782">(Jun 12 2019 at 06:16)</a>:</h4>
<p>I have some thoughts on this.<br>
1) I already implemented the easy case: <a href="https://github.com/faabian/mathlib/blob/3.5/meta.lean" target="_blank" title="https://github.com/faabian/mathlib/blob/3.5/meta.lean">https://github.com/faabian/mathlib/blob/3.5/meta.lean</a><br>
Take a structure definition (like <code>ordered_ring</code>) and generate the corresponding type of homomorphisms (of maps compatible with all additional structure). I will now head for generating the category instances, forgetful functors etc.<br>
2) I didn't know about this before, but think MacLane may be correct about being able to find out what a continuous map is:</p>
<p>In logic/model theory, there are two types of homomorphisms, weak ones (respecting relations as in <code>R(x_1, ..., x_n) \implies R(f x_1, ..., f x_n)</code>) and strong ones (the same with Iff). Which one would one choose in category theory? Answer: weak ones, as they correspond to precomposition with <code>f</code> if we view relations as maps <code>X \times ... \times X \to Prop</code>.<br>
Then a subset of X is the same as a predicate (unary relation) on X or Y, and for a map <code>f : X \to Y</code>and a subset U \subset Y, the composition "characteristic function of U \comp f" is the characteristic function of the preimage of U under f.<br>
Then topologies are subsets of the powersets, so predicates on the power sets. We already found out that the natural map between the powersets is taking preimages. So a weak homomorphism means: "open U \subset Y \implies open (f^{-1} U) \subset X", the definition of a continuous map. (Or: the preimage of the topology of X under the map "take preimage under f" is the topology on Y).</p>
<p>I didn't check in the paper, but hope this is what he meant.</p>



<a name="167920167"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/167920167" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#167920167">(Jun 12 2019 at 06:46)</a>:</h4>
<p>The issue is that Bourbaki's definition of "structure" allows more things than functions and relations -- it allows things like "functions from the power set of the power set of X to the product of X and the power set of X". It seems to me that MacLane just throws comments around like "let's say power set is contravariant" when talking about topologies, but without making it clear what he means in the general case. Is the thing I just mentioned covariant or contravariant? I'm not sure what I asked there even makes sense. Bourbaki avoid this by simply writing down the things they want to remain invariant <em>first</em>, calling them sigma, and then defining a sigma-morphism to be something that preserves sigma. They make it expressly clear that there is no "abstract nonsense" definition of a morphism between structures which does not involve choosing a sigma first.</p>



<a name="167921705"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/167921705" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Fabian Glöckle <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#167921705">(Jun 12 2019 at 07:12)</a>:</h4>
<p>But does this contradict the statement that in some cases there is a canonical way of finding sigma? I think MacLane says taking powerset to be contravariant is natural, and thus continuous maps are (unlike open maps) the natural choice. Do we know structures where this "canonical" choice of morphisms is not correct?</p>



<a name="167922147"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/167922147" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Fabian Glöckle <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#167922147">(Jun 12 2019 at 07:21)</a>:</h4>
<p>Concerning your example, the X part should be covariant, the (X to Prop) part contravariant. I think this is fully algorithmical as the only rule is "whenever the structure X itself appears, use f to get to Y". This can mean both pre- or postcomposition. Then draw a diagram and say it must commute.</p>



<a name="167924077"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/167924077" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#167924077">(Jun 12 2019 at 08:00)</a>:</h4>
<p>So if a monotonic function is <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>≤</mo><mi>y</mi><mspace width="0.277778em"></mspace><mo>⟹</mo><mspace width="0.277778em"></mspace><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>≤</mo><mi>f</mi><mo>(</mo><mi>y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">x \le y \implies f(x) \le f(y)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit">x</span><span class="mrel">≤</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mrel"><span class="mspace thickspace"></span><span class="mrel">⟹</span></span><span class="mord mathit"><span class="mspace thickspace"></span><span class="mord mathit" style="margin-right:0.10764em;">f</span></span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mclose">)</span><span class="mrel">≤</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>, we're using the order on Prop somehow, or we're just saying an order is a category, so a morphism is a functor? What's the canonical "weak" morphism on a metric space? Is it <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo><mo>≤</mo><mi>d</mi><mo>(</mo><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo separator="true">,</mo><mi>f</mi><mo>(</mo><mi>y</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">d(x,y) \le d(f(x),f(y))</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit">d</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mrel">≤</span><span class="mord mathit">d</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></p>



<a name="167924208"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/167924208" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Fabian Glöckle <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#167924208">(Jun 12 2019 at 08:03)</a>:</h4>
<p>Yes, somehow prop gets special treatment..</p>



<a name="167924304"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/167924304" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Fabian Glöckle <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#167924304">(Jun 12 2019 at 08:04)</a>:</h4>
<p>The metric spaces though are a great example showing that there are more than just the algebraic structures.</p>



<a name="167924584"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/167924584" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Fabian Glöckle <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#167924584">(Jun 12 2019 at 08:09)</a>:</h4>
<p>The algebraic version of a metric space map would be d(x,y) = d(f(x),f(y)) (called isometry?)</p>



<a name="167925016"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/167925016" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#167925016">(Jun 12 2019 at 08:17)</a>:</h4>
<p>Locally ringed spaces are a great example showing that a structure in the sense of Bourbaki is not everything that a mathematician cares about. It is surely impossible to automatically generate the definition of a morphism of locally ringed spaces. But I am not sure that a locally ringed space falls into this whole structure definition at all. On the other hand it is clearly possible to define an isomorphism of locally ringed spaces, even though they are a more complex structure than what I think is allowed by Bourbaki.</p>



<a name="167925105"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/167925105" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#167925105">(Jun 12 2019 at 08:19)</a>:</h4>
<blockquote>
<p>Concerning your example, the X part should be covariant, the (X to Prop) part contravariant.</p>
</blockquote>
<p>Does this make sense? Let's define a structure called <code>foo</code>, and a <code>foo</code> is a type <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.07847em;">X</span></span></span></span> plus a subset of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi><mo>×</mo><mrow><mi mathvariant="script">P</mi></mrow><mo>(</mo><mi>X</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">X\times\mathcal{P}(X)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.07847em;">X</span><span class="mbin">×</span><span class="mord"><span class="mord mathcal" style="margin-right:0.08222em;">P</span></span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span></span> (the product of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.07847em;">X</span></span></span></span> and its power set). How are you going to define morphisms? How can you be covariant in part of the data and contravariant in the other part? I just don't understand how to make this precise.</p>



<a name="167958320"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/167958320" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#167958320">(Jun 12 2019 at 15:30)</a>:</h4>
<blockquote>
<p>Locally ringed spaces are a great example showing that a structure in the sense of Bourbaki is not everything that a mathematician cares about. It is surely impossible to automatically generate the definition of a morphism of locally ringed spaces. But I am not sure that a locally ringed space falls into this whole structure definition at all. On the other hand it is clearly possible to define an isomorphism of locally ringed spaces, even though they are a more complex structure than what I think is allowed by Bourbaki.</p>
</blockquote>
<p>A naive autogenerated type-theoretic isom of locally ringed spaces would probably be wrong. Because the isom is a 2-categorical thing. HoTT would automatically get it right, I guess.<br>
But if you aren't careful, the autogenerated thing would ask for the <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mo>∗</mo></msub><msub><mi mathvariant="script">O</mi><mi>X</mi></msub><mo>=</mo><msub><mi mathvariant="script">O</mi><mi>Y</mi></msub></mrow><annotation encoding="application/x-tex">f_* \mathcal{O}_X = \mathcal{O}_Y</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.175696em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mord"><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">O</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right:0.07847em;">X</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mrel">=</span><span class="mord"><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">O</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right:0.22222em;">Y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span> (with equality on the nose). Of course the isom should actually include extra data, namely an isom between those two sheaves.</p>



<a name="167958549"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/167958549" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#167958549">(Jun 12 2019 at 15:32)</a>:</h4>
<p>But how could Lean ever figure out that it should automatically include such an isom in the autogenerated definition of an iso of LRS's? This only seems plausible if we tightly couple the categorical nature of sheaves to the definition of a sheaf. Otherwise it will just treat <code>sheaf X</code> as a discrete thing. But we want to consider them "up to homotopy".</p>



<a name="167961114"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/167961114" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#167961114">(Jun 12 2019 at 15:56)</a>:</h4>
<p>I am not sure that locally ringed spaces are covered by this Bourbaki definition of structure, so probably you have to put extra allowances in for all the extra types kicking around; terms have to be equal but types just have to be isomorphic.</p>



<a name="167965900"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/167965900" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#167965900">(Jun 12 2019 at 16:49)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> I'm not yet convinced that one can automagically produce the definition of isoms of LRS's...</p>



<a name="167966005"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/167966005" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#167966005">(Jun 12 2019 at 16:50)</a>:</h4>
<p>If we endow everything with category instances... then maybe. Otherwise you either need to give the system a helping hand, or something clever has to be done.</p>



<a name="167967909"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/167967909" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#167967909">(Jun 12 2019 at 17:16)</a>:</h4>
<p>The isomorphism of topological spaces enables you to push one sheaf over to the other space and now we want an isomorphism of sheaves. I don't see the problem but given that transfer seems to be such a key issue I'm still listening. I still believe that given any structure that Lean could make, it should be able to construct the notion of isomorphism between two instances of that structure (modulo possible universe issues)</p>



<a name="167968108"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/167968108" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#167968108">(Jun 12 2019 at 17:19)</a>:</h4>
<p>How should the transfer tactic realise that an isomorphism of LRS requires an isomorphism between <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mo>∗</mo></msub><msub><mi mathvariant="script">O</mi><mi>X</mi></msub></mrow><annotation encoding="application/x-tex">f_* \mathcal{O}_X</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.175696em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mord"><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">O</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right:0.07847em;">X</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="script">O</mi><mi>Y</mi></msub></mrow><annotation encoding="application/x-tex">\mathcal{O}_Y</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base"><span class="mord"><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">O</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right:0.22222em;">Y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span>, instead of an equality?</p>



<a name="167968506"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/167968506" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#167968506">(Jun 12 2019 at 17:23)</a>:</h4>
<p>I've got <code>(X Y : LRS)</code>. I'm a robot. I need to figure out what is an isomorphism between <code>X</code> and <code>Y</code>. Well... an <code>LRS</code> consists of a topological space, a sheaf on that space, and some other junk.<br>
Great, I figure out what is an isomorphism of topological spaces. So I decide that an isom of <code>LRS</code>s consists of a topological isom <code>f : X.carrier \iso Y.carrier</code>. Using generic transfer blabla, this allows me to transfer the sheaf <code>X.sheaf</code> from <code>X.carrier</code> to <code>Y.carrier</code> along <code>f</code>. Now, I've got two terms of type <code>sheaf Y.carrier</code>. I decide that it is very reasonable that these two terms should be equal.<br>
Finally, this equality trivially preserves all the other junk. I have figured out what an isomorphism between <code>X</code> and <code>Y</code> is.<br>
I'm a robot.</p>



<a name="167968727"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/167968727" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#167968727">(Jun 12 2019 at 17:26)</a>:</h4>
<p>Well there are <code>Type</code>s inside <code>sheaf</code>, so presumably you would need to construct a notion of "equal" that doesn't involve literal equality of types</p>



<a name="167968737"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/167968737" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#167968737">(Jun 12 2019 at 17:26)</a>:</h4>
<p>by induction over the syntax of the structure</p>



<a name="167968779"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/167968779" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#167968779">(Jun 12 2019 at 17:26)</a>:</h4>
<p>This very much feels like reinventing HoTT's transport.</p>



<a name="167969474"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/167969474" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#167969474">(Jun 12 2019 at 17:35)</a>:</h4>
<p>That is kind of the goal, right?</p>



<a name="167970737"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/167970737" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#167970737">(Jun 12 2019 at 17:48)</a>:</h4>
<p>Hmmm... maybe it does work.</p>



<a name="167970792"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/167970792" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#167970792">(Jun 12 2019 at 17:49)</a>:</h4>
<p><span class="user-mention" data-user-id="210057">@Fabian Glöckle</span> How hard would it be for you to automatically generate such an <code>equiv</code> for an arbitrary structure using the framework that you have so far?</p>



<a name="167974907"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/167974907" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#167974907">(Jun 12 2019 at 18:36)</a>:</h4>
<p>A difference is that in HoTT the equality is an intrinsic part of the theory, while here we're trying to emulate it by meta-level considerations, building up by induction on the structure what we expect the right interpretation of "equality" to be.</p>



<a name="167974932"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/167974932" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#167974932">(Jun 12 2019 at 18:36)</a>:</h4>
<p>Equality of types in HoTT is not <em>defined</em> to be isomorphism any more than equality of ordered pairs is defined to be equality of each component</p>



<a name="168673712"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/168673712" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Cyril Cohen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#168673712">(Jun 21 2019 at 11:36)</a>:</h4>
<p><span class="user-mention" data-user-id="110026">@Simon Hudon</span> did someone progress on this while I was away?</p>



<a name="168677105"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/168677105" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#168677105">(Jun 21 2019 at 12:33)</a>:</h4>
<p>I didn't. I think it's at the same point it was before</p>



<a name="170762941"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/170762941" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#170762941">(Jul 12 2019 at 23:26)</a>:</h4>
<p>OK so we have <a href="https://github.com/leanprover-community/mathlib/blob/5a48be3e29dacbb2f02071db4749dcdfa74fb79d/src/measure_theory/bochner_integration.lean#L83" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/5a48be3e29dacbb2f02071db4749dcdfa74fb79d/src/measure_theory/bochner_integration.lean#L83">Bochner integration in Lean</a>! This work has helped me to formalise a question which might be related to this transfer/transport stuff.</p>
<p>Let's say I have a smart computer scientist undergrad who is intested in analysis and logic, and wants to do something cool in Lean. Say they read this thread and then say to me "This Bochner integral definition -- it mentions the real numbers, and in Lean the real numbers are defined to be the Cauchy reals. Do you think it would be interesting to port the entire Bochner integral definition over to the Dedekind reals? Here's my plan. First I write an interface with Dedekind reals at the back end, providing an interface to exactly those functions and definitions and other things that are in the <code>real</code> namespace the moment the real numbers are defined in Lean (as Cauchy reals). The proofs should then barely need modifying, and everything should just port over". And I say "sounds great, go ahead" and I think "I knew this transport stuff was easy". A week later the student comes back and says that they have run into trouble. Turns out that some of the maps between Cauchy and Dedekind reals were noncomputable, the API for the Cauchy reals built with the Dedekind reals as backend is also noncomputable, all the proofs have ported beautifully but then loads of them don't work because sometimes computer scientists used <code>simp</code> which used to work but didn't any more because of some computability issue. We then come onto the chat asking how we can fix the proof and deduce our Bochner integral thing for the Dedekind reals. We are fine if everything is noncomputable by the way -- we are mathematicians. Feel free to use all your axioms.</p>



<a name="170763114"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/170763114" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#170763114">(Jul 12 2019 at 23:31)</a>:</h4>
<p><span class="user-mention" data-user-id="110026">@Simon Hudon</span> <span class="user-mention" data-user-id="111080">@Floris van Doorn</span> does the above post make any sense?</p>



<a name="170763329"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/170763329" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#170763329">(Jul 12 2019 at 23:37)</a>:</h4>
<p>I don't get why computability becomes an issue. I see why the transport might be non-computable but since you're accepting that, what's the problem?</p>



<a name="170763488"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/170763488" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#170763488">(Jul 12 2019 at 23:40)</a>:</h4>
<p>Could this approach actually work to port the Bochner stuff over to Dedekind reals?</p>



<a name="170763574"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/170763574" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#170763574">(Jul 12 2019 at 23:43)</a>:</h4>
<p>Surely some of the functions defined in the API for data.real.basic will allow some kind of computational reductions which the analogous objects in the Dedekind-backend reals would not satisfy, so some <code>rfl</code> proofs might break? Or am I talking nonsense?</p>



<a name="170763598"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/170763598" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#170763598">(Jul 12 2019 at 23:43)</a>:</h4>
<p>I'm no logician</p>



<a name="170763649"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/170763649" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#170763649">(Jul 12 2019 at 23:44)</a>:</h4>
<p>Your concern is theoretically justified, but you should replace <code>simp</code> in the example with <code>rfl</code> or <code>dsimp</code></p>



<a name="170763670"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/170763670" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#170763670">(Jul 12 2019 at 23:45)</a>:</h4>
<p>The proofs that were going to break <em>did</em> break, and were fixed, when real was made irreducible</p>



<a name="170763674"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/170763674" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#170763674">(Jul 12 2019 at 23:45)</a>:</h4>
<p>it basically makes it impossible to prove facts about real numbers by rfl</p>



<a name="170763727"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/170763727" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#170763727">(Jul 12 2019 at 23:46)</a>:</h4>
<p>so now (in theory) you could completely swap out the definition of reals with something else and fix the API theorems and nothing further should break</p>



<a name="170763729"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/170763729" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#170763729">(Jul 12 2019 at 23:46)</a>:</h4>
<p>How do I know that some rogue proof didn't unfold <code>real</code>?</p>



<a name="170763740"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/170763740" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#170763740">(Jul 12 2019 at 23:47)</a>:</h4>
<p>you have to write some really horrible looking tactic code to unfold real</p>



<a name="170763744"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/170763744" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#170763744">(Jul 12 2019 at 23:47)</a>:</h4>
<p>I'll get Chris onto it.</p>



<a name="170763798"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/170763798" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#170763798">(Jul 12 2019 at 23:48)</a>:</h4>
<p>So it's not impossible, but a proof that does this is visibly ugly</p>



<a name="170763800"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/170763800" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#170763800">(Jul 12 2019 at 23:48)</a>:</h4>
<p>You have to write some really horrible looking maths to say anything about the real numbers for which the answer would be different for Dedekind cuts and Cauchy sequences.</p>



<a name="170763809"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/170763809" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#170763809">(Jul 12 2019 at 23:48)</a>:</h4>
<p>A proof that did that would be visibly weird.</p>



<a name="170763847"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/170763847" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#170763847">(Jul 12 2019 at 23:49)</a>:</h4>
<p>In fact a proof which used anything other than the Officially Mathematically Sanctioned Axioms For The Real Numbers, which is something about them being some complete archimedean field, would be visibly ugly.</p>



<a name="170764043"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/170764043" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#170764043">(Jul 12 2019 at 23:54)</a>:</h4>
<blockquote>
<p>So it's not impossible, but a proof that does this is visibly ugly</p>
</blockquote>
<p>I think that you should then replace <code>real</code> by a constant and just provide an API to the proof that they satisfy those complete archimedean field axioms.</p>



<a name="170764056"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/170764056" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#170764056">(Jul 12 2019 at 23:55)</a>:</h4>
<p>Then you'd know that you could not fall off the straight and narrow.</p>



<a name="170764149"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/170764149" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#170764149">(Jul 12 2019 at 23:57)</a>:</h4>
<p>Computer-generated tactics of the future might unfold <code>real</code></p>



<a name="170764295"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/170764295" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#170764295">(Jul 13 2019 at 00:00)</a>:</h4>
<p>Yes, it would be nice if we could do this in lean. Unfortunately the only way to truly be bulletproof is to use a constant and that pollutes the <code>#print axioms</code> list (and requires people to be careful not to introduce unsoundness)</p>



<a name="170764411"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/170764411" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Ashworth <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#170764411">(Jul 13 2019 at 00:03)</a>:</h4>
<p>Isn't the bulletproof way just to define a complete archimedean field typeclass? the reals would just be an alias for a declaration of a type and the associated instance</p>



<a name="170764498"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/170764498" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Ashworth <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#170764498">(Jul 13 2019 at 00:05)</a>:</h4>
<p>maybe not. I just googled the topic and came up with a paper where people have all sorts of axioms for the real numbers</p>



<a name="170764500"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/170764500" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Ashworth <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#170764500">(Jul 13 2019 at 00:05)</a>:</h4>
<p><a href="https://arxiv.org/pdf/1402.6645.pdf" target="_blank" title="https://arxiv.org/pdf/1402.6645.pdf">https://arxiv.org/pdf/1402.6645.pdf</a></p>



<a name="170765309"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/170765309" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#170765309">(Jul 13 2019 at 00:25)</a>:</h4>
<p>Should we make the construction of the localization of a ring at a submonoid irreducible as well?</p>



<a name="170766094"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/170766094" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#170766094">(Jul 13 2019 at 00:45)</a>:</h4>
<p>There's another approach. You could make <code>real</code> into a structure that contains it's construction. Then, you have to use introduction and elimination rules to work on the construction</p>



<a name="170784613"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/170784613" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#170784613">(Jul 13 2019 at 10:35)</a>:</h4>
<p>Let's say that this summer I get a beginner Lean student to formalise the statement of the Birch and Swinnerton-Dyer conjecture (BSD), which says that for every cubic equation in two variables with rational coefficients,  the behaviour of the set of rational solutions of the equation is related to a value of a certain complex function which depends on the equation. The student certainly doesn't write any weird meta code and doesn't unfold any definitions of real. Note that they do use the complex numbers though, so they do use <code>real</code>. And let's say that I get a second student working on a Dedekind real library for Lean and they get some kind of regular expression going which automatically ports a bunch of mathlib over to the Dedekind reals, including the statement of BSD.</p>
<p>Let's then say that in 2020 some team led by Christian Szegedy at  Google announces a fully formalised AI-generated incomprehensible long Lean 3.4.2 proof of BSD as formalised by my Cauchy student. My Dedekind student attempts to apply the regex to port the proof over to the Dedekind reals, but the port fails because it turns out that Szegedy has unfolded the reals in his proof for performance reasons.</p>
<p>Do we know for sure in this situation that there is a Lean proof of BSD for Dedekind reals?</p>



<a name="170785860"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/170785860" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Keeley Hoek <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#170785860">(Jul 13 2019 at 11:17)</a>:</h4>
<p>Isn't your last statement Kevin an essentially purely "conventional" mathematical question? something like "(All with normal set-theory): If there exists a proof of a particular proposition P involving real numbers:</p>
<ul>
<li>but whose statement requires only certain axiomatised properties of the reals which we can write down in a list and agree on,</li>
<li>and whose proof proceeds by using Cauchy-reals (meant just as some definition in terms of sets),</li>
</ul>
<p>does there exist a proof of the same fact which uses Dedekind-reals?"</p>
<p>In which case, surely the answer is "it depends on the strength of the list of axioms which we can agree on".</p>



<a name="170786610"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/170786610" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#170786610">(Jul 13 2019 at 11:43)</a>:</h4>
<p>My question is completely precise and does not depend on conventions. I completely agree that there is an analogous question in ZFC.</p>



<a name="170791236"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/170791236" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#170791236">(Jul 13 2019 at 14:07)</a>:</h4>
<p>In particular we don't have to have any sort of debate beforehand. For the Lean question I'm talking about a Lean proof and for the ZFC question I'm talking about a proof in eg Mizar. The basic question is whether a conjecture whose statement can be written using only the usual interface but whose proof might not follow this rule can always be ported to the Dedekind case because of some general theorem of logic</p>



<a name="170795943"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/170795943" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#170795943">(Jul 13 2019 at 16:20)</a>:</h4>
<p>I can envisage how the ZFC proof might go but I'm less good at type theory</p>



<a name="170800448"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/170800448" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#170800448">(Jul 13 2019 at 18:33)</a>:</h4>
<p>Yes, provided the statement itself falls within the "mathematically acceptable" subset, you can translate the "BSD for cauchy reals" statement to "BSD for dedekind reals", and they will be provably equivalent using transfer theorems</p>



<a name="170800506"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/170800506" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#170800506">(Jul 13 2019 at 18:35)</a>:</h4>
<p>For comparison, the proof of dirichlet's theorem in lean via metamath has a similar flavor. The proof uses some crazy techniques using some completely different notion of reals, natural numbers, etc, but because the statement is comprehensible you can just translate the predicates across until you get the conventional lean statement.</p>



<a name="170805562"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/170805562" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#170805562">(Jul 13 2019 at 21:16)</a>:</h4>
<p>For the transfer tactic to work one needs to ensure that every single thing you can do for the Cauchy reals has some sort of analogue for the Dedekind reals.  Does the proof of this start something like "we replace Cauchy reals with Dedekind reals, we replace the constructor with a function which takes a Cauchy sequence and returns the corresponding Dedekind limit, and we replace the eliminator with the function which takes the same inputs as the Cauchy eliminator and returns a function from the Dedekind reals instead". But then how do you prove that the proof still works? Switching out the constructor and eliminator so they work for Dedekind reals instead is easy, you just use the equiv between Cauchy and Dedekind reals. But now there must be something to do to check that the corresponding term has the appropriate type.</p>



<a name="170807378"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/170807378" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Ashworth <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#170807378">(Jul 13 2019 at 22:16)</a>:</h4>
<p>I don't follow - why can't you rely on Lean to typecheck the transferred expression for you?</p>



<a name="170807955"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/170807955" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Ashworth <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#170807955">(Jul 13 2019 at 22:37)</a>:</h4>
<p>Maybe my understanding of what <code>transfer</code> does is flawed. I think about it in terms of a specialized source-to-source transpiler. What comes out is just another Lean <code>expr</code> that will by typechecked by Lean itself.</p>



<a name="170811373"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/170811373" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#170811373">(Jul 14 2019 at 00:42)</a>:</h4>
<blockquote>
<p>For the transfer tactic to work one needs to ensure that every single thing you can do for the Cauchy reals has some sort of analogue for the Dedekind reals.</p>
</blockquote>
<p>No, what is needed is only that everything mathematically reasonable that you can do to the Cauchy reals has an analogue. If in this Szegedy fictional proof other things that aren't mathematically reasonable are exploited, it doesn't matter for the transfer. Since the resulting theorem (BSD) is a mathematically reasonable proposition, you should be able to translate it</p>



<a name="170811378"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/170811378" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#170811378">(Jul 14 2019 at 00:43)</a>:</h4>
<p>You aren't transferring the proof, you are transferring the statement</p>



<a name="170813312"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/170813312" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#170813312">(Jul 14 2019 at 01:48)</a>:</h4>
<blockquote>
<p>Does the proof of this start something like "we replace Cauchy reals with Dedekind reals, we replace the constructor with a function which takes a Cauchy sequence and returns the corresponding Dedekind limit, and we replace the eliminator with the function which takes the same inputs as the Cauchy eliminator and returns a function from the Dedekind reals instead". But then how do you prove that the proof still works?</p>
</blockquote>
<p>For simple proofs, where the proof itself is entirely mathematically reasonable, then this works. But it's not foolproof, and can break proofs that unfold <code>real</code>.</p>
<p>For complicated proofs, we aren't shifting anything under the foundation of the proof itself at all. We just use the statement "BSD is true for cauchy reals" as is, without inspecting or modifying the proof in any way. The idea is to prove statements of the form "P is true for cauchy iff P' is true for dedekind" where P and P' are analogous</p>



<a name="170836123"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/170836123" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#170836123">(Jul 14 2019 at 14:29)</a>:</h4>
<p>I am currently a bit confused about what the straight answer is to my straight question. If I have a Lean-formalised mathematical conjecture about complete ordered archimedean fields (i.e. about all constructions of the real numbers) and if I have a possibly "mathematically unreasonable" but Lean-accepted proof of this conjecture in the special case of the Cauchy reals, it is a theorem that there exists a Lean-accepted proof of the special case of Dedekind reals? If so, what is the proof? Secondly, were I to present such a conjecture and (1000 line long) proof for the Cauchy reals, what needs to be done in practice to get a proof for the Dedekind reals?</p>



<a name="170836741"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/170836741" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#170836741">(Jul 14 2019 at 14:48)</a>:</h4>
<p>Here's another question. The Bochner integral is defined in Lean using the Cauchy reals. What if I want a version for Dedekind reals? The analogous function but in the Dedekind situation. Again this is a very precise question -- as far as I can see -- I would like to generate the term which would have been made if <code>real</code> had been defined using the Dedekind reals.</p>



<a name="170838412"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/170838412" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#170838412">(Jul 14 2019 at 15:45)</a>:</h4>
<blockquote>
<p>If so, what is the proof?</p>
</blockquote>
<p>We can prove today that "BSD for cauchy reals holds iff BSD for dedekind reals holds", so if we get any proof, even an unreasonable one, of BSD for cauchy reals, by composing it with this we get a proof of BSD for dedekind reals.</p>
<blockquote>
<p>Here's another question. The Bochner integral is defined in Lean using the Cauchy reals. What if I want a version for Dedekind reals? The analogous function but in the Dedekind situation. Again this is a very precise question -- as far as I can see -- I would like to generate the term which would have been made if real had been defined using the Dedekind reals.</p>
</blockquote>
<p>There are a few kinds of definitions based on reals. Some of them don't actually depend on it being any kind of reals, for example you can replace "real is an ordered field" with "real' is an ordered field" reusing the same predicate "ordered field".  Other definitions have the reals embedded inside; for example the Bochner integral is defined for functions over a real vector space, and so you would need Bochner' integral defined for functions over a real' vector space. The only proofs that have to be translated are those that are involved in stating the theorem, and they can either be translated similarly by replacing real with real' everywhere, or they can be explicitly transferred by proving that all sub-formulas of the statement of the theorem hold for real' iff they hold of real.</p>



<a name="170844273"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/170844273" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#170844273">(Jul 14 2019 at 18:56)</a>:</h4>
<blockquote>
<p>We can prove today that "BSD for cauchy reals holds iff BSD for dedekind reals holds"</p>
</blockquote>
<p>What is the proof of that?</p>
<p>You are talking again and again about transferring statements, but I want to see how to transfer a proof, especially a proof which we cannot guarantee is "normal". Regarding translating the Bochner integral function, I can see that this is possible in theory because no way will there be any weird real-unfolding, but I can't imagine how to do it in practice.</p>



<a name="170844788"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/170844788" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Ashworth <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#170844788">(Jul 14 2019 at 19:12)</a>:</h4>
<p>you can't give a 1-line explanation, the algorithm involved is hairy, but if you want to read a paper about it, try this one: &lt;deleted, see below&gt;</p>



<a name="170845761"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/170845761" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Ashworth <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#170845761">(Jul 14 2019 at 19:42)</a>:</h4>
<p>there are differences between the paper I linked which is in Coq and the <code>transfer</code> tactic from isabelle which we are trying to port to Lean, but I can't say what they are...</p>



<a name="170846701"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/170846701" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#170846701">(Jul 14 2019 at 20:09)</a>:</h4>
<p>What is this random paper? It has no date or hint about where it was/will be published. Is it OK? By default I tend to be skeptical about random pdfs on the internet (I've seen a lot of crap maths). Just paranoid by default. I find computer science papers hard to read. I am looking for a theorem and a proof. The theorem says that something can <em>always</em> be done (X_for_Cauchy -&gt; X_for_Dedekind), the paper says "we describe a new tactic". I guess our two cultures think about these things differently.</p>



<a name="170846775"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/170846775" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Ashworth <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#170846775">(Jul 14 2019 at 20:10)</a>:</h4>
<p>ahh, perhaps a better link would be to it's home in the Journal of Formalised Reasoning</p>



<a name="170846777"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/170846777" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Ashworth <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#170846777">(Jul 14 2019 at 20:10)</a>:</h4>
<p>apparently I linked a pre-print</p>



<a name="170846779"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/170846779" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Ashworth <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#170846779">(Jul 14 2019 at 20:10)</a>:</h4>
<p><a href="https://jfr.unibo.it/article/view/1574" target="_blank" title="https://jfr.unibo.it/article/view/1574">https://jfr.unibo.it/article/view/1574</a></p>



<a name="170846788"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/170846788" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Ashworth <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#170846788">(Jul 14 2019 at 20:11)</a>:</h4>
<p>or something, weird</p>



<a name="170846916"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/170846916" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Ashworth <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#170846916">(Jul 14 2019 at 20:14)</a>:</h4>
<p>I am not sure where the theorem you want is stated, we'll just have to wait for a type theory specialist to chime in.</p>



<a name="170847168"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/170847168" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Ashworth <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#170847168">(Jul 14 2019 at 20:21)</a>:</h4>
<p>What would a proof look like, though? The basic idea of the tactic  is: define an equivalence relation for the two isomorphic types you are interested in. For the reals, this relation would be based on the axioms of a complete ordered field. For the more advanced objects you work with, the "Strickland" predicates you have on defined on various unnamed types. Then, mechanically go through each proof. For each definition or proof used on one type, generate a proof obligation that it is a morphism and substitute.</p>



<a name="170847219"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/170847219" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Ashworth <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#170847219">(Jul 14 2019 at 20:22)</a>:</h4>
<p>If you write some definition or function that is not a morphism, this tactic will fail, and you'll be stuck.</p>



<a name="170847383"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/170847383" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Ashworth <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#170847383">(Jul 14 2019 at 20:27)</a>:</h4>
<p>X_for_Cauchy -&gt; X_for_Dedekind is false in general</p>



<a name="170847452"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/170847452" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Ashworth <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#170847452">(Jul 14 2019 at 20:28)</a>:</h4>
<p>Under what circumstances is X_for_Cauchy -&gt; X_for_Dedekind always true? Only if for each definition or function used in X, it is defined only in terms of the axioms of a complete archimedian field, which are the properties shared by both, or if we can derive complete_arch_field -&gt; (X_for_Cauchy /\ X_for_Dedekind) . So for mathlib's reals, if we try and transfer a certain definition over the Cauchy reals to the Dedekind reals, that depends on construction details of the Cauchy reals, we won't be able to because we won't be able to prove that it is a morphism. It just won't type-check.</p>



<a name="170848215"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/170848215" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Ashworth <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#170848215">(Jul 14 2019 at 20:45)</a>:</h4>
<p>ps: this is extremely tedious. If you thought adding additional functions to your baby <code>ring</code> tactic was a pain, this dials it up to 11 if you are working with a complex, many-propertied object. This is a generalization of the method of how ring works.</p>



<a name="170848433"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/170848433" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Ashworth <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#170848433">(Jul 14 2019 at 20:50)</a>:</h4>
<p>If at all possible if you know you want to reason about many kinds of isomorphic objects, define the appropriate equivalence class and work with that instead as soon as possible.</p>



<a name="170850123"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/170850123" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#170850123">(Jul 14 2019 at 21:31)</a>:</h4>
<p>I think you guys are always thinking about the details of the construction. I can quite believe it's difficult. I'm trying to understand this "Stricklandization" way of thinking. But there is also a <em>theorem</em> somewhere which says that if X is a true/false statement about compete ordered Archimedean fields then X is true for Cauchy reals iff it's true for Dedekind reals. I was hoping for a reference for this. There might be some analogous theorems about localisations or kaehler one forms, and these are the things I'm really interested in, but it's easier to talk about real numbers because more people know what they are</p>



<a name="170853627"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/170853627" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Ashworth <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#170853627">(Jul 14 2019 at 23:25)</a>:</h4>
<p>Yes? This is the Liskov substitution principle. <a href="https://en.wikipedia.org/wiki/Liskov_substitution_principle" target="_blank" title="https://en.wikipedia.org/wiki/Liskov_substitution_principle">https://en.wikipedia.org/wiki/Liskov_substitution_principle</a></p>



<a name="170854045"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/170854045" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Ashworth <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#170854045">(Jul 14 2019 at 23:38)</a>:</h4>
<p>summoning <span class="user-mention" data-user-id="110049">@Mario Carneiro</span> because I have no idea if this has a formal proof in CIC</p>



<a name="170865229"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/170865229" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Ashworth <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#170865229">(Jul 15 2019 at 05:28)</a>:</h4>
<p>Ah, nevermind, that isn't the proof you're looking for. I haven't been able to find anything about the theorem as stated, except that it's unprovable by computers and equivalent to the halting problem in general, if you're willing to write a degenerate enough proposition that depends on the truth or falsity of, say, the Goldbach conjectures. But that says nothing about if it exists or not in all cases.</p>



<a name="170905337"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/170905337" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#170905337">(Jul 15 2019 at 15:46)</a>:</h4>
<p>Is there already an established name for these sort of predicates? Otherwise I propose to call them <em>characteristic predicates</em>.</p>



<a name="170907863"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/170907863" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Ashworth <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#170907863">(Jul 15 2019 at 16:15)</a>:</h4>
<p>Apparently in type theory we call "complete archimedean field" a type and the cauchy, dedekind reals a "(strong) behavioral subtype".</p>



<a name="170907910"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/170907910" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Ashworth <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#170907910">(Jul 15 2019 at 16:15)</a>:</h4>
<p>The process of deducing isomorphism invariant properties is called "interface extraction" as in <a href="https://refactoring.guru/extract-interface" target="_blank" title="https://refactoring.guru/extract-interface">https://refactoring.guru/extract-interface</a> . (I guess in Rust this would be "extract trait". In Python this would be defining an abstract base superclass.)</p>



<a name="170908173"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/170908173" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Ashworth <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#170908173">(Jul 15 2019 at 16:18)</a>:</h4>
<p>and I looked some more and I found people saying that the Liskov substitution principle is actually necessary and sufficient for the theorem Kevin wanted, but I can't find a formulation explicitly in the terms he gave (that is, getting rid of all the programming related statements and deriving it purely in proof-theoretical terms). I would be shocked if it wasn't in the type theory literature somewhere, though.</p>



<a name="170908782"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/170908782" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#170908782">(Jul 15 2019 at 16:25)</a>:</h4>
<p>I couldn't work out how to get Liskov substitution to do it. There must be more details which I'm missing.</p>



<a name="170908860"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/170908860" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#170908860">(Jul 15 2019 at 16:26)</a>:</h4>
<p>I might ask a more mathsy version of my question on mathoverflow to see what the logicians make of it. They speak a language closer to my own.</p>



<a name="170910553"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/170910553" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Ashworth <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#170910553">(Jul 15 2019 at 16:48)</a>:</h4>
<p>I can get behind characteristic predicate, it's shorter than "isomorphic invariant properties"</p>



<a name="170910638"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/170910638" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Ashworth <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#170910638">(Jul 15 2019 at 16:49)</a>:</h4>
<p>not by much, though</p>



<a name="170910902"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/170910902" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Ashworth <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#170910902">(Jul 15 2019 at 16:52)</a>:</h4>
<p>it's also less creepy than the category theory term "skeletonization"</p>



<a name="170917699"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/170917699" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#170917699">(Jul 15 2019 at 18:14)</a>:</h4>
<p>Should we also have a "characteristic predicate" for constructions like <code>mv_polynomial</code>?</p>



<a name="170920311"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/170920311" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#170920311">(Jul 15 2019 at 18:46)</a>:</h4>
<p>Do we need one? One thing (unrelated to transfer) about mv_polynomial is that I think someone should take a look at what instances are defined on it, and ask if they have sensible priorities</p>



<a name="170926736"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/170926736" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#170926736">(Jul 15 2019 at 20:02)</a>:</h4>
<p>The proof of X_for_Cauchy &lt;-&gt; X_for_Dedekind depends on X and is not always true. It is true for what I am calling "mathematically reasonable" propositions to mimic your claims about things mathematicians refuse to do with their language, but that term is also deliberately vague so that there is no general metatheorem being applied here</p>



<a name="170927882"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/170927882" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Ashworth <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#170927882">(Jul 15 2019 at 20:17)</a>:</h4>
<p>So the Liskov substitution principle is necessary and sufficient for Hoare logic according to Wikipedia. Is there something analogous for the calculus of inductive constructions?</p>



<a name="170927965"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/170927965" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Ashworth <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#170927965">(Jul 15 2019 at 20:18)</a>:</h4>
<p>I figure it ought to be simpler since there's no mutability, but I'm not a type theorist..</p>



<a name="170928369"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/170928369" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#170928369">(Jul 15 2019 at 20:23)</a>:</h4>
<p>The substitution principle in this generality is basically HoTT's domain. If you require it for all predicates then you can easily show it's equivalent to saying "Cauchy_reals = Dedekind_reals"</p>



<a name="170928530"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/170928530" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Ashworth <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#170928530">(Jul 15 2019 at 20:25)</a>:</h4>
<p>I can see how that makes sense. The only way to get 100% semantic equality would be for the two types to be exactly the same.</p>



<a name="170928771"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/170928771" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#170928771">(Jul 15 2019 at 20:28)</a>:</h4>
<p>I actually don't mean exactly the same, I mean equal according to the = predicate in DTT, which as you know is a more subtle thing</p>



<a name="170928793"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/170928793" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#170928793">(Jul 15 2019 at 20:29)</a>:</h4>
<p>And in HoTT the difference between = and defeq is center stage</p>



<a name="170939770"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/170939770" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#170939770">(Jul 15 2019 at 23:06)</a>:</h4>
<p>But something funny is going on here because we're not using HoTT and it <em>is</em> true that for "mathematically reasonable statements" they're true for the Cauchy reals iff they're true for the Dedekind reals, so something is missing from my understanding. I asked at MO and, as is unfortunately sometimes the case with logic questions, I've caused a great deal of noise :-/ <a href="https://mathoverflow.net/questions/336191/cauchy-reals-and-dedekind-reals-satisfy-the-same-mathematical-theorems" target="_blank" title="https://mathoverflow.net/questions/336191/cauchy-reals-and-dedekind-reals-satisfy-the-same-mathematical-theorems">https://mathoverflow.net/questions/336191/cauchy-reals-and-dedekind-reals-satisfy-the-same-mathematical-theorems</a></p>



<a name="170940850"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/170940850" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Ashworth <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#170940850">(Jul 15 2019 at 23:24)</a>:</h4>
<p>I think the answer is buried there, though, in one comment. <a href="https://math.stackexchange.com/questions/437948/do-isomorphic-structures-always-satisfy-the-same-second-order-sentences" target="_blank" title="https://math.stackexchange.com/questions/437948/do-isomorphic-structures-always-satisfy-the-same-second-order-sentences">https://math.stackexchange.com/questions/437948/do-isomorphic-structures-always-satisfy-the-same-second-order-sentences</a>. The answer is true for 1st-order propositions, and false for higher order.</p>



<a name="170941048"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/170941048" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#170941048">(Jul 15 2019 at 23:28)</a>:</h4>
<p>I'm hoping I can get Noah Schweber to write more details. I feel like we're making progress in the sense that I'm learning something.</p>



<a name="170941657"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/170941657" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jesse Michael Han <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#170941657">(Jul 15 2019 at 23:39)</a>:</h4>
<p>noah's sketch seems like the "just transfer the higher-order statements you need" approach (he's probably adding extra sorts so he can quantify over things like subsets) but with more bookkeeping (this is probably the path to a uniform transfer theorem for constructions of CAOFs)</p>
<p>amusingly, terry tao is essentially recommending that we just roll with a CAOF typeclass</p>



<a name="170941863"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/170941863" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#170941863">(Jul 15 2019 at 23:42)</a>:</h4>
<p>What's a CAOF typeclass?</p>



<a name="170941964"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/170941964" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jesse Michael Han <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#170941964">(Jul 15 2019 at 23:44)</a>:</h4>
<p>the hypothetical typeclass for complete archimedean ordered fields, so that every instance of it corresponds to an interpretation of the generic symbol <strong>R</strong> mentioned by terry in his comment</p>



<a name="170943622"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/170943622" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François G. Dorais <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#170943622">(Jul 16 2019 at 00:19)</a>:</h4>
<p><span class="user-mention" data-user-id="116045">@Jesse Michael Han</span>  Why is the typeclass hypothetical? It's easy to write down several variants.</p>



<a name="170945462"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/170945462" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#170945462">(Jul 16 2019 at 01:00)</a>:</h4>
<p>The typeclass approach isn't quite flexible enough, because of the need to deal with n-ary predicates with a variety of different relations between objects at the same time</p>



<a name="170945476"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/170945476" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jesse Michael Han <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#170945476">(Jul 16 2019 at 01:00)</a>:</h4>
<p><span class="user-mention" data-user-id="119741">@François G. Dorais</span>  it's hypothetical because i don't think anyone's PR'd it to <code>mathlib</code> yet :^)</p>
<p>but indeed it shouldn't be difficult</p>



<a name="170945495"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/170945495" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#170945495">(Jul 16 2019 at 01:01)</a>:</h4>
<p>oops, spoke too soon. It's possible to have a typeclass for "real-like thing" but we are embedding it in definitions <em>exactly because</em> we are not anticipating to change the definition of the reals any time soon</p>



<a name="170947169"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/170947169" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François G. Dorais <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#170947169">(Jul 16 2019 at 01:42)</a>:</h4>
<p>Ah, got it. In that case, let me record my favorite version: R is the terminal object in the category of archimedean ordered fields.</p>
<div class="codehilite"><pre><span></span><span class="n">class</span> <span class="n">real_field</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="kn">extends</span> <span class="n">linear_ordered_field</span> <span class="n">α</span><span class="o">,</span> <span class="n">archimedean</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">term</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">linear_ordered_field</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">archimedean</span> <span class="n">β</span><span class="o">]</span> <span class="o">:</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">α</span><span class="o">),</span> <span class="n">is_field_hom</span> <span class="n">f</span><span class="o">)</span>
</pre></div>


<p>It's a bit harder to get off the ground with this one, but it's very entertaining to see how it works. (The restriction to Type is not a typo. Archimedean ordered fields are so fantastically rigid, this is enough to ensure that this is a terminal object for all universe levels.)</p>



<a name="170950893"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/170950893" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François G. Dorais <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/transport.20and.20parametricity.html#170950893">(Jul 16 2019 at 03:21)</a>:</h4>
<p>I answered <span class="user-mention" data-user-id="110038">@Kevin Buzzard</span>'s question on MO but in the context of ZFC. In the context of Lean, having a real typeclass is the best since that will make transfer happen automatically. That said, mathlib's current reals are essentially harmless. As I explained on MO, to transfer a theorem about reals (or whatever) the only key ingredient is that the _statement_ only mentions equality and external structure between real numbers and never looks under the hood at the innards. Because mathlib's reals are opaque, it's really hard to write anything that uses the innards of mathlib's reals. Nevertheless, opaque is quite a few shades lighter than pitch black... I am still very comfortable to assert that mathlib's reals are 99.9999% transferable. The main reason I feel so comfortable is that mathlib's reals are basically computationally useless, so I doubt anyone would have had the idea to breach the opaqueness barrier unless it was absolutely necessary.</p>
<p>The same kind of trick I mentioned on MO works for Lean but it's a much harder argument involving carefully crafted comma category-like stuff and such. I had a similar thing come up recently and I ran out of steam before I could even write down what needed to be done. This is really hard work but it's a one-time deal, so it might be worth it. (I do not have time to do it.)</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
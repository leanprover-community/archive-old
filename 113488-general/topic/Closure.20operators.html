---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/Closure.20operators.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html">Closure operators</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="235993951"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/235993951" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#235993951">(Apr 24 2021 at 18:36)</a>:</h4>
<p><span class="user-mention" data-user-id="246273">@Bhavik Mehta</span> baked us an API for closure operators (in order/closure.lean). It provides a bundled version of a closure operator. Should we refactor <code>closure</code>, <code>convex_hull</code> and other, or should we instead prove an unbundled version as an instance for each of them?</p>



<a name="235994272"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/235994272" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#235994272">(Apr 24 2021 at 18:40)</a>:</h4>
<p>Would this work for a bundled version of say <a href="https://leanprover-community.github.io/mathlib_docs/find/submonoid.closure">docs#submonoid.closure</a>? What would that look like if so?</p>



<a name="235998368"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/235998368" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#235998368">(Apr 24 2021 at 19:29)</a>:</h4>
<p>Actually, you already have a Galois insertion on submonoids, which is better than a closure operator. So I don't think it's applicable there, apart from exempting from proving some lemmas by hand.</p>



<a name="236002483"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/236002483" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#236002483">(Apr 24 2021 at 20:23)</a>:</h4>
<p>Do we have a way to downgrade a galois insertion to a closure operator then?</p>



<a name="236005275"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/236005275" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#236005275">(Apr 24 2021 at 20:58)</a>:</h4>
<p>Yeah, we do! It's <code>galois_insertion.closure_operator</code>. We might want to rename it to <code>galois_insertion.to_closure_operator</code>.</p>



<a name="236005468"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/236005468" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#236005468">(Apr 24 2021 at 21:00)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/galois_insertion.closure_operator">docs#galois_insertion.closure_operator</a>?</p>



<a name="236005831"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/236005831" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#236005831">(Apr 24 2021 at 21:01)</a>:</h4>
<p>Ah oops, it's rather <a href="https://leanprover-community.github.io/mathlib_docs/find/galois_connection.closure_operator">docs#galois_connection.closure_operator</a></p>



<a name="236006123"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/236006123" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#236006123">(Apr 24 2021 at 21:02)</a>:</h4>
<p>Actually, it's not much that the Galois insertion (or connection?) is more powerful than the closure operator but rather that <code>submonoid</code> is bundled. I can easily define the closure operator to output the carrier of <code>submonoid.closure</code>, but not with the information that it's a submonoid  built in.</p>



<a name="236006249"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/236006249" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#236006249">(Apr 24 2021 at 21:03)</a>:</h4>
<p>In contrast, it works great for <code>convex_hull</code> because <code>convex</code> is unbundled.</p>



<a name="236673228"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/236673228" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#236673228">(Apr 29 2021 at 13:33)</a>:</h4>
<p>Actually, I'm thinking there's something to be done there. The pattern "closure operator that's actually not quite one because it outputs the closure bundled with more info" is ultra common: subgroups, submonoids, subspaces... and I'm sure you can think of more than I do. What we could do would be to define <code>bundled_closure_operator</code> as a closure operator bundled with the information that its output is a submonoid/subgroup/subspace...<br>
What's your opinion?</p>



<a name="236673415"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/236673415" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#236673415">(Apr 29 2021 at 13:34)</a>:</h4>
<p>How is this different from a galois insertion?</p>



<a name="236673809"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/236673809" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#236673809">(Apr 29 2021 at 13:37)</a>:</h4>
<p>Oh, is it how Galois insertions work already?</p>



<a name="236673950"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/236673950" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#236673950">(Apr 29 2021 at 13:38)</a>:</h4>
<p>It seems to me that you're describing exactly a galois insertion, which is already there for submonoids, subgroups etc</p>



<a name="236674453"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/236674453" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#236674453">(Apr 29 2021 at 13:41)</a>:</h4>
<p>In particular, you turn <a href="https://leanprover-community.github.io/mathlib_docs/find/subgroup.gi">docs#subgroup.gi</a> into a closure operator by forgetting the bundled info after applying <a href="https://leanprover-community.github.io/mathlib_docs/find/subgroup.closure">docs#subgroup.closure</a>.</p>



<a name="236674681"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/236674681" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#236674681">(Apr 29 2021 at 13:43)</a>:</h4>
<p><span class="user-mention silent" data-user-id="246273">Bhavik Mehta</span> <a href="#narrow/stream/113488-general/topic/Closure.20operators/near/236673950">said</a>:</p>
<blockquote>
<p>It seems to me that you're describing exactly a galois insertion, which is already there for submonoids, subgroups etc</p>
</blockquote>
<p>No, that's not how it works. Take for example <code>submonoid.closure</code>. It's defined as <code>\la s, Inf {S : submonoid M | s ⊆ ↑S}</code>. What I'm offering is to define it as</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">bundled_closure_operator</span>
<span class="o">(</span><span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">\</span><span class="n">la</span> <span class="n">s</span><span class="o">,</span> <span class="n">Inf</span> <span class="o">{</span><span class="n">S</span> <span class="o">:</span> <span class="n">submonoid</span> <span class="n">M</span> <span class="bp">|</span> <span class="n">s</span> <span class="bp">⊆</span> <span class="bp">↑</span><span class="n">S</span><span class="o">})</span>
<span class="o">(</span><span class="n">to_coe</span> <span class="o">:=</span> <span class="bp">\</span><span class="n">la</span> <span class="n">s</span><span class="o">,</span> <span class="n">Inf</span> <span class="o">{</span><span class="n">t</span> <span class="bp">|</span> <span class="n">s</span> <span class="bp">⊆</span> <span class="n">t</span> <span class="bp">\</span><span class="n">and</span> <span class="bp">\</span><span class="n">ex</span> <span class="n">S</span> <span class="o">:</span> <span class="n">submonoid</span> <span class="n">M</span><span class="o">,</span> <span class="n">t</span> <span class="bp">=</span> <span class="bp">↑</span><span class="n">S</span><span class="o">})</span>
<span class="o">(</span><span class="bp">&lt;</span><span class="n">more</span> <span class="n">infos</span> <span class="n">to</span> <span class="n">make</span> <span class="n">to_coe</span> <span class="n">a</span> <span class="n">closure</span> <span class="n">operator</span><span class="bp">&gt;</span><span class="o">)</span>
</code></pre></div>
<p>or something of sort</p>



<a name="236674948"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/236674948" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#236674948">(Apr 29 2021 at 13:44)</a>:</h4>
<p>My point is that we could change the way the info is bundled so that we can actually use the theorems associated with closure operators.</p>



<a name="236676425"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/236676425" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#236676425">(Apr 29 2021 at 13:53)</a>:</h4>
<p>Are you asking for a shorter name for <code>subgroup.gc.closure_operator</code>?</p>



<a name="236676751"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/236676751" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#236676751">(Apr 29 2021 at 13:56)</a>:</h4>
<p>Is this the kind of thing you're looking for?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">group_theory.subgroup</span>

<span class="sd">/-- The `has_closure A B` typeclass represents types with</span>
<span class="sd">a canonical injection `coe : A → set B`, which has a left adjoint `closure : set B → A`.</span>
<span class="sd">-/</span>
<span class="kd">class</span> <span class="n">has_closure</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">B</span> <span class="o">:</span> <span class="n">out_param</span> <span class="bp">$</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">set_like</span> <span class="n">A</span> <span class="n">B</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">closure</span> <span class="o">:</span> <span class="n">set</span> <span class="n">B</span> <span class="bp">→</span> <span class="n">A</span><span class="o">)</span>
<span class="o">(</span><span class="n">gi</span> <span class="o">:</span> <span class="n">galois_insertion</span> <span class="n">closure</span> <span class="n">coe</span><span class="o">)</span>

<span class="kn">namespace</span> <span class="n">has_closure</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>

<span class="kd">instance</span> <span class="o">[</span><span class="n">has_closure</span> <span class="n">A</span> <span class="n">B</span><span class="o">]</span> <span class="o">:</span> <span class="n">complete_lattice</span> <span class="n">A</span> <span class="o">:=</span>
<span class="n">has_closure.gi.lift_complete_lattice</span>

<span class="kd">end</span> <span class="n">has_closure</span>

<span class="kd">instance</span> <span class="n">subgroup.has_closure</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">has_closure</span> <span class="o">(</span><span class="n">subgroup</span> <span class="n">G</span><span class="o">)</span> <span class="n">G</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">closure</span> <span class="o">:=</span> <span class="n">subgroup.closure</span><span class="o">,</span>
  <span class="n">gi</span> <span class="o">:=</span> <span class="n">subgroup.gi</span> <span class="n">G</span><span class="o">,</span>
  <span class="bp">..</span> <span class="n">subgroup.set_like</span> <span class="o">}</span>
</code></pre></div>



<a name="236677288"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/236677288" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#236677288">(Apr 29 2021 at 13:59)</a>:</h4>
<p>(This doesn't work great because you can't infer which <code>closure</code> you're taking from the arguments, so you need to keep writing <code>x ∈ (closure s : subgroup G)</code>.)</p>



<a name="236677733"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/236677733" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#236677733">(Apr 29 2021 at 14:02)</a>:</h4>
<p>I don't think that's going to work well, because we define <code>closure</code> in terms of the complete lattice structure</p>



<a name="236677827"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/236677827" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#236677827">(Apr 29 2021 at 14:03)</a>:</h4>
<p>I have a refactor in progress that replaces <code>subgroup</code> with <code>subtype is_subgroup</code>, that might make it easier to generalize this type of thing</p>



<a name="236678208"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/236678208" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#236678208">(Apr 29 2021 at 14:05)</a>:</h4>
<p>Yeah, as it is set up currently it wouldn't work in some places where <code>closure</code> is defined in terms of <code>Inf</code>. However, instances like  <a href="https://leanprover-community.github.io/mathlib_docs/find/intermediate_field.complete_lattice">docs#intermediate_field.complete_lattice</a> already use this technique and would definitely see advantages in terms of deduplication.</p>



<a name="236679853"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/236679853" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#236679853">(Apr 29 2021 at 14:15)</a>:</h4>
<p>For example, here are the first few <code>closure</code> lemmas in <code>subgroup.lean</code>, which are really just <code>galois_insertion _ coe</code> lemmas:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">subset_closure</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">⊆</span> <span class="o">(</span><span class="n">closure</span> <span class="n">s</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">has_closure.gi.gc.le_u</span> <span class="o">(</span><span class="n">le_refl</span> <span class="n">_</span><span class="o">)</span>

<span class="kd">lemma</span> <span class="n">closure_le</span> <span class="o">:</span> <span class="n">closure</span> <span class="n">s</span> <span class="bp">≤</span> <span class="n">S</span> <span class="bp">↔</span> <span class="n">s</span> <span class="bp">⊆</span> <span class="n">S</span> <span class="o">:=</span>
<span class="n">has_closure.gi.gc</span> <span class="n">_</span> <span class="n">_</span>

<span class="kd">lemma</span> <span class="n">mem_closure</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">B</span><span class="o">}</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="o">(</span><span class="n">closure</span> <span class="n">s</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="bp">↔</span> <span class="bp">∀</span> <span class="n">S</span> <span class="o">:</span> <span class="n">A</span><span class="o">,</span> <span class="n">s</span> <span class="bp">⊆</span> <span class="n">S</span> <span class="bp">→</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">S</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">simp_rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">set_like.mem_coe</span><span class="o">,</span> <span class="bp">←</span> <span class="n">set.singleton_subset_iff</span><span class="o">,</span> <span class="bp">←</span> <span class="n">closure_le</span><span class="o">],</span>
     <span class="n">exact</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">h</span> <span class="n">S</span><span class="o">,</span> <span class="n">le_trans</span> <span class="n">h</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">h</span> <span class="n">_</span> <span class="o">(</span><span class="n">le_refl</span> <span class="n">_</span><span class="o">)⟩</span> <span class="o">}</span>

<span class="kd">lemma</span> <span class="n">closure_eq_of_le</span> <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">⊆</span> <span class="n">S</span><span class="o">)</span> <span class="o">(</span><span class="n">h₂</span> <span class="o">:</span> <span class="n">S</span> <span class="bp">≤</span> <span class="n">closure</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span> <span class="n">closure</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">S</span> <span class="o">:=</span>
<span class="n">le_antisymm</span> <span class="o">(</span><span class="n">closure_le.2</span> <span class="n">h₁</span><span class="o">)</span> <span class="n">h₂</span>
</code></pre></div>



<a name="236682532"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/236682532" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#236682532">(Apr 29 2021 at 14:31)</a>:</h4>
<p>Yes, you very much got my point. Sorry for being unclear. I'm mostly worried about the duplication I'm seeing all over the place (have a look at <code>convex_hull</code>, for example).</p>



<a name="236682777"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/236682777" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#236682777">(Apr 29 2021 at 14:32)</a>:</h4>
<p>I'm now planning on bundling closure operators whose output is unbundled. I already spotted convex hull, topological closure, transitive closure, reflexive closure.<br>
What do you think?</p>



<a name="236683871"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/236683871" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#236683871">(Apr 29 2021 at 14:38)</a>:</h4>
<p>The radical of an ideal is another example :)</p>



<a name="236683989"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/236683989" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#236683989">(Apr 29 2021 at 14:39)</a>:</h4>
<p>Ooh, right! The radical of a natural too, but I'm not sure that already exists/there's a nice way to formulate it without using ideals.</p>



<a name="236684131"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/236684131" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#236684131">(Apr 29 2021 at 14:40)</a>:</h4>
<p>I think radical of a natural should be an interior operator rather than a closure operator?</p>



<a name="236684323"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/236684323" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#236684323">(Apr 29 2021 at 14:41)</a>:</h4>
<p>rad n is literally the natural number corresponding to the radical of nZ.</p>



<a name="236684733"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/236684733" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#236684733">(Apr 29 2021 at 14:43)</a>:</h4>
<p>Sure, but the radical of a natural can be smaller (in divisibility or the usual ordering) than the natural itself</p>



<a name="236685048"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/236685048" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#236685048">(Apr 29 2021 at 14:45)</a>:</h4>
<p>Ah right. Am I correct thinking that an interior operator is literally a closure operator with respect to the dual order?</p>



<a name="236687464"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/236687464" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#236687464">(Apr 29 2021 at 14:59)</a>:</h4>
<p>Yup!</p>



<a name="236701325"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/236701325" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#236701325">(Apr 29 2021 at 16:09)</a>:</h4>
<p>The inequality on ideals is dual to the divisibility operator on naturals :-)</p>



<a name="236733881"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/236733881" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#236733881">(Apr 29 2021 at 19:46)</a>:</h4>
<p>Just spotted <code>zorn.chain_closure</code> and <code>field_theory.perfect_closure</code> in the wild.</p>



<a name="236737281"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/236737281" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#236737281">(Apr 29 2021 at 20:10)</a>:</h4>
<p>I think another closure operator that we should add ASAP is the relative algebraic closure of a set in a field extension. The general stuff about closure operators would then let us define transcendence degree, transcendence bases, etc.</p>



<a name="236737951"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/236737951" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#236737951">(Apr 29 2021 at 20:15)</a>:</h4>
<p>Do you already have a definition and only need a refactor, or do you need to set up the theory as well?</p>



<a name="236738147"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/236738147" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#236738147">(Apr 29 2021 at 20:16)</a>:</h4>
<p>I thought there's content to the assertion that transcendence degree is well-defined? It's some matroid property?</p>



<a name="236738248"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/236738248" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#236738248">(Apr 29 2021 at 20:17)</a>:</h4>
<p>That's right. you need the exchange axiom</p>



<a name="236738364"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/236738364" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#236738364">(Apr 29 2021 at 20:18)</a>:</h4>
<p><span class="user-mention silent" data-user-id="387244">Yaël Dillies</span> <a href="#narrow/stream/113488-general/topic/Closure.20operators/near/236737951">said</a>:</p>
<blockquote>
<p>Do you already have a definition and only need a refactor, or do you need to set up the theory as well?</p>
</blockquote>
<p>No, as far as I'm aware the definition of relative algebraic closure is not in mathlib</p>



<a name="236785176"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/236785176" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#236785176">(Apr 30 2021 at 04:45)</a>:</h4>
<p>What is the "relative algebraic closure"? Is this just the "algebraic closure of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span> in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">L</span></span></span></span>"? Because that's the same as the integral closure, which mathlib knows about.</p>



<a name="236796225"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/236796225" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#236796225">(Apr 30 2021 at 07:26)</a>:</h4>
<p>How do we want to deal with interior operators? Do we want to make a specific API, or just define the ones we have as closure operators on the dual order?</p>



<a name="236796441"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/236796441" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#236796441">(Apr 30 2021 at 07:29)</a>:</h4>
<p>in particular, is there any general interaction between interior and closure operators?</p>



<a name="236797397"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/236797397" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#236797397">(Apr 30 2021 at 07:39)</a>:</h4>
<p>The problem with this question is that there are people who feel that the principled approach is to do everything twice, and there are people who feel that duplicating code can't be the right idea, so you might not get a coherent answer about how to make an <code>interior</code> API. The only way I've seen interior and closure interact is via <code>frontier</code>, which is closure minus interior and has its own little API.</p>



<a name="237308436"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/237308436" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#237308436">(May 04 2021 at 11:41)</a>:</h4>
<p>Oh, I found a funny one.  <code>span_points</code> and <code>affine_span</code> are the unbundled and bundled variant of the same closure operator. Here it seems that my approach is well worth some thought. <br>
My idea is that, given a partial order on <code>α</code> and a structure <code>S α</code> on <code>α</code> (think of <code>(≤)</code> and <code>subgroup</code>), we could define a "bundled closure operator" on <code>α</code> as an object that could be coerced to a function <code>α → S α</code>, knowing that the output of this function could itself be coerced to <code>α</code>. That way, we could get the best off both worlds.</p>



<a name="237310275"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/237310275" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#237310275">(May 04 2021 at 11:58)</a>:</h4>
<p>What I don't know is whether it's possible to feed in such a structure (<code>subgroup</code>, <code>submonoid</code>, <code>affine_subspace</code>...) to a constructor. Is it?</p>



<a name="237311047"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/237311047" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#237311047">(May 04 2021 at 12:03)</a>:</h4>
<p>We have things like <code>is_subgroup</code> (a predicate on subsets) which can sometimes be useful in situations like this.</p>



<a name="237311616"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/237311616" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#237311616">(May 04 2021 at 12:07)</a>:</h4>
<p><span class="user-mention" data-user-id="387244">@Yaël Dillies</span>, you might look at the design of <code>concrete_category</code>, and for example how we set up <code>Mon</code>, <code>Group</code>, <code>Module</code>, and so on, to see one approach to be polymorphic in typeclasses.</p>



<a name="237359969"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/237359969" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#237359969">(May 04 2021 at 16:49)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/113488-general/topic/Closure.20operators/near/235994272">said</a>:</p>
<blockquote>
<p>Would this work for a bundled version of say <a href="https://leanprover-community.github.io/mathlib_docs/find/submonoid.closure">docs#submonoid.closure</a>? What would that look like if so?</p>
</blockquote>
<p>Turns out it works! The trick is to simply change <code>closure_operator extends α →ₘ α</code> to <code>closure_operator extends α →ₘ β</code> and ask for the instance <code>[has_coe_t β α]</code> (if anyone knows how to ask this coercion to be monotone, please tell me!).</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">order.closure</span>
<span class="kn">import</span> <span class="n">group_theory.submonoid.basic</span>

<span class="kn">open</span> <span class="n">set</span> <span class="n">submonoid</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">mul_one_class</span> <span class="n">M</span><span class="o">]</span>

<span class="kd">def</span> <span class="n">submonoid.neo_closure</span> <span class="o">:</span> <span class="n">closure_operator</span> <span class="o">(</span><span class="n">set</span> <span class="n">M</span><span class="o">)</span> <span class="o">(</span><span class="n">submonoid</span> <span class="n">M</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">s</span><span class="o">,</span> <span class="n">Inf</span> <span class="o">{</span><span class="n">S</span> <span class="o">:</span> <span class="n">submonoid</span> <span class="n">M</span> <span class="bp">|</span> <span class="n">s</span> <span class="bp">⊆</span> <span class="bp">↑</span><span class="n">S</span><span class="o">},</span>
  <span class="n">le_closure'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">s</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span> <span class="n">mem_Inf.2</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">S</span> <span class="n">hS</span><span class="o">,</span> <span class="n">hS</span> <span class="n">hx</span><span class="o">,</span>
  <span class="n">idempotent'</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="n">monotone'</span> <span class="o">:=</span> <span class="gr">sorry</span> <span class="o">}</span>
</code></pre></div>
<p>I left <code>idempotent'</code> and <code> monotone'</code> sorried because the easy way to prove them is to use my new constructors, which I haven't yet bothered to translate in this new two types closure operators paradigm.</p>



<a name="237403973"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/237403973" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#237403973">(May 04 2021 at 21:33)</a>:</h4>
<p><span class="user-mention silent" data-user-id="238446">Anne Baanen</span> <a href="#narrow/stream/113488-general/topic/Closure.20operators/near/236677288">said</a>:</p>
<blockquote>
<p>(This doesn't work great because you can't infer which <code>closure</code> you're taking from the arguments, so you need to keep writing <code>x ∈ (closure s : subgroup G)</code>.)</p>
</blockquote>
<p>In my conception of things, we would rather define <code>group.closure</code> and then write <code>x ∈ G.closure s</code>. The example I posted just above should clear up my intentions.</p>



<a name="237465472"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/237465472" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#237465472">(May 05 2021 at 09:23)</a>:</h4>
<p>Ah good idea! I didn't like the idea of defining <code>subgroup.closure</code> and <code>submonoid.closure</code> and <code>submodule.span</code> and ... because you would have to copy over all (<code>simp</code>) lemmas, but instantiating it as a bundled type fixes that.</p>



<a name="237467051"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/237467051" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#237467051">(May 05 2021 at 09:38)</a>:</h4>
<p>Is this the place you need your <code>has_coe_t</code> to be either <code>id</code> or the map sending subobjects to the carrier set? I think you're looking for the <a href="https://leanprover-community.github.io/mathlib_docs/find/set_like">docs#set_like</a> typeclass in that case.</p>



<a name="237467191"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/237467191" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#237467191">(May 05 2021 at 09:39)</a>:</h4>
<p>I haven't been following this thread properly but if we're going to define some fancy new <code>submodule.span</code> then we might want to do the same for <a href="https://leanprover-community.github.io/mathlib_docs/find/lie_submodule.lie_span">docs#lie_submodule.lie_span</a></p>



<a name="237467211"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/237467211" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#237467211">(May 05 2021 at 09:39)</a>:</h4>
<p>Sorry, just realized this is being discussed further here: <a href="#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/monotone.20coercion">https://leanprover.zulipchat.com/#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/monotone.20coercion</a></p>



<a name="237467310"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/237467310" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#237467310">(May 05 2021 at 09:40)</a>:</h4>
<p><span class="user-mention silent" data-user-id="240862">Oliver Nash</span> <a href="#narrow/stream/113488-general/topic/Closure.20operators/near/237467191">said</a>:</p>
<blockquote>
<p>I haven't been following this thread properly but if we're going to define some fancy new <code>submodule.span</code> then we might want to do the same for <a href="https://leanprover-community.github.io/mathlib_docs/find/lie_submodule.lie_span">docs#lie_submodule.lie_span</a></p>
</blockquote>
<p>Definitely! If the <code>lie_span</code> of <code>s</code> is the smallest <code>lie_submodule</code> whose carrier set contains <code>s</code>, then it should be defined as a closure operator.</p>



<a name="237467349"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/237467349" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#237467349">(May 05 2021 at 09:41)</a>:</h4>
<p>It is indeed, according to the docstring :)</p>



<a name="237470753"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/237470753" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#237470753">(May 05 2021 at 10:11)</a>:</h4>
<p>A refactor I've been considering is redefining <code>submodule</code> as <code>subtype is_submodule</code>, which means we can have a general <code>closure</code> operator which just means <code>closure (s : set A) (p : set A \to Prop) : subtype p := Inf { x : subtype p | s \sub \u x}</code></p>



<a name="237470907"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/237470907" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#237470907">(May 05 2021 at 10:13)</a>:</h4>
<p>(this would obsolete set_like)</p>



<a name="237471894"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/237471894" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#237471894">(May 05 2021 at 10:23)</a>:</h4>
<p>Interesting idea, I don't know if it would completely obsolete <code>set_like</code> though: wouldn't you have to choose between writing <code>subtype (is_subobject X)</code> everywhere, or writing <code>subobject X</code> and copying over all <code>subtype</code> lemmas?</p>



<a name="237471967"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/237471967" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#237471967">(May 05 2021 at 10:24)</a>:</h4>
<p>(An appropriate version of <code>set_like</code> would basically automate the latter.)</p>



<a name="237479939"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/237479939" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#237479939">(May 05 2021 at 11:36)</a>:</h4>
<p>... or define <code>submodule M</code> as <code>subobject (Module.of R M)</code>... :-) I really haven't thought whether it is at all plausible. There is a complete lattice structure on <code>subobject X</code> with reasonable assumption, however, and various functoriality / pullback / pushforward operations.</p>



<a name="237562418"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/237562418" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#237562418">(May 05 2021 at 20:45)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/113488-general/topic/Closure.20operators/near/237470753">said</a>:</p>
<blockquote>
<p>A refactor I've been considering is redefining <code>submodule</code> as <code>subtype is_submodule</code>, which means we can have a general <code>closure</code> operator which just means <code>closure (s : set A) (p : set A \to Prop) [complete_lattice (subtype p)] : subtype p := Inf {x : subtype p | s ⊆ ↑x}</code></p>
</blockquote>
<p>How does that interact with my refactor proposition? Would you do that instead of mine, or layer both?</p>



<a name="237625793"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/237625793" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#237625793">(May 06 2021 at 08:50)</a>:</h4>
<p>Ah actually wouldn't there be the problem that closure operators don't need complete lattices to work? Partial order is enough, but I don't know whether any of the closure operators we deal with in practice are partial orders but not complete lattices.</p>



<a name="237716058"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/237716058" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#237716058">(May 06 2021 at 19:32)</a>:</h4>
<p>This isn’t a redefinition of <code>closure_operator</code>, it’s a specific function that could be made into a <code>closure_operator</code></p>



<a name="238174485"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/238174485" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#238174485">(May 10 2021 at 16:48)</a>:</h4>
<p>Okay so we have Galois connections and closure operators. Which way do we want go? Should we build Galois connections from closure operators, or closure operators from Galois connections?</p>
<p>If we start from Galois connections, then we're kind of burying the actual closure and maybe it will be harder to work with in practice (is there any way to systematically simplify it?). Further, I don't think we ever use Galois connections in expression. They rather tend to be passed as instances. The current way things are set up is that we first define the closure operator, and then prove the <code>galois_connection</code>/<code>galois_insertion</code> instance.</p>
<p>If we start from closure operators, I don't think we have the problem that closure operators do not uniquely determine Galois connections because we're bundling them with the functions. But we might want to change the definition we currently have to get rid of the <code>galois_connection</code> field:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">fully_bundled</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">preorder</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">preorder</span> <span class="n">β</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span>
<span class="o">(</span><span class="n">u</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span>
<span class="o">(</span><span class="n">gc</span> <span class="o">:</span> <span class="n">galois_connection</span> <span class="n">l</span> <span class="n">u</span><span class="o">)</span>

<span class="kd">structure</span> <span class="n">partially_bundled</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">preorder</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">preorder</span> <span class="n">β</span><span class="o">]</span> <span class="o">(</span><span class="n">u</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span>
<span class="o">(</span><span class="n">gc</span> <span class="o">:</span> <span class="n">galois_connection</span> <span class="n">l</span> <span class="n">u</span><span class="o">)</span>
</code></pre></div>
<p>Actually, given that <code>closure_operator</code> and <code>galois_connection</code> take in the same infos and that <code>galois_connection</code> isn't really used apart from instances, wouldn't there be a way to unify them under a single structure that would both have a <code>coe_to_fun</code> and be useful as an instance on its own?</p>



<a name="238175157"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/238175157" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#238175157">(May 10 2021 at 16:52)</a>:</h4>
<p>Galois connections are used in lots of places in mathlib.</p>



<a name="238175561"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/238175561" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#238175561">(May 10 2021 at 16:55)</a>:</h4>
<p>But are they used in a way that's incompatible with giving them dot notation?</p>



<a name="238206093"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/238206093" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#238206093">(May 10 2021 at 20:25)</a>:</h4>
<p>My concrete proposal (<a href="#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/monotone.20coercion">from the other thread</a>) would be to use <code>partially_bundled</code> galois insertions (connections), because I foresee a major use case will be for subobjects, where the <code>u</code> is instantiated to be <code>coe : subfoo α → set α</code>.</p>



<a name="238206110"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/238206110" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#238206110">(May 10 2021 at 20:25)</a>:</h4>
<p>Let me write out a bit of code...</p>



<a name="238208154"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/238208154" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#238208154">(May 10 2021 at 20:39)</a>:</h4>
<p>This is how I would rewrite lines 540-563 of <code>group_theory/subgroup.lean</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">group_theory.subgroup</span>

<span class="kd">structure</span> <span class="n">lower_adjoint</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">preorder</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">preorder</span> <span class="n">β</span><span class="o">]</span> <span class="o">(</span><span class="n">u</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">to_fun</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span>
<span class="o">(</span><span class="n">gi'</span> <span class="o">:</span> <span class="n">galois_insertion</span> <span class="n">to_fun</span> <span class="n">u</span><span class="o">)</span>

<span class="kn">namespace</span> <span class="n">lower_adjoint</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">preorder</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">preorder</span> <span class="n">β</span><span class="o">]</span> <span class="o">{</span><span class="n">u</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">lower_adjoint</span> <span class="n">u</span><span class="o">)</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_coe_to_fun</span> <span class="o">(</span><span class="n">lower_adjoint</span> <span class="n">u</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">F</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">,</span> <span class="n">coe</span> <span class="o">:=</span> <span class="n">to_fun</span> <span class="o">}</span>

<span class="n">initialize_simps_projections</span> <span class="n">lower_adjoint</span> <span class="o">(</span><span class="n">to_fun</span> <span class="bp">→</span> <span class="n">apply</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">gi</span> <span class="o">:</span> <span class="n">galois_insertion</span> <span class="n">l</span> <span class="n">u</span> <span class="o">:=</span> <span class="n">l.gi'</span>

<span class="kd">end</span> <span class="n">lower_adjoint</span>

<span class="kd">@[simps?]</span> <span class="kd">def</span> <span class="n">subgroup.closure'</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">lower_adjoint</span> <span class="o">(</span><span class="n">coe</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">G</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">G</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="n">subgroup.closure</span><span class="o">,</span>
  <span class="n">gi'</span> <span class="o">:=</span> <span class="n">subgroup.gi</span> <span class="n">G</span> <span class="o">}</span>

<span class="c1">-- Lemmas for `lower_adjoint (coe : α → set β)`, where `set_like α β`</span>
<span class="kn">section</span> <span class="n">coe_to_set</span>

<span class="kn">namespace</span> <span class="n">lower_adjoint</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">set_like</span> <span class="n">α</span> <span class="n">β</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">(</span><span class="n">closure</span> <span class="o">:</span> <span class="n">lower_adjoint</span> <span class="o">(</span><span class="n">coe</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">β</span><span class="o">))</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">β</span><span class="o">}</span> <span class="o">{</span><span class="n">S</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span>

<span class="kd">lemma</span> <span class="n">subset</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">⊆</span> <span class="o">(</span><span class="n">closure</span> <span class="n">s</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">closure.gi.gc.le_u</span> <span class="o">(</span><span class="n">le_refl</span> <span class="n">_</span><span class="o">)</span>

<span class="kd">lemma</span> <span class="n">le_iff</span> <span class="o">:</span> <span class="n">closure</span> <span class="n">s</span> <span class="bp">≤</span> <span class="n">S</span> <span class="bp">↔</span> <span class="n">s</span> <span class="bp">⊆</span> <span class="n">S</span> <span class="o">:=</span>
<span class="n">closure.gi.gc</span> <span class="n">_</span> <span class="n">_</span>

<span class="kd">lemma</span> <span class="n">mem_iff</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">β</span><span class="o">}</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="o">(</span><span class="n">closure</span> <span class="n">s</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="bp">↔</span> <span class="bp">∀</span> <span class="n">S</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">s</span> <span class="bp">⊆</span> <span class="n">S</span> <span class="bp">→</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">S</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">simp_rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">set_like.mem_coe</span><span class="o">,</span> <span class="bp">←</span> <span class="n">set.singleton_subset_iff</span><span class="o">,</span> <span class="bp">←</span> <span class="n">closure.le_iff</span><span class="o">],</span>
     <span class="n">exact</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">h</span> <span class="n">S</span><span class="o">,</span> <span class="n">le_trans</span> <span class="n">h</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">h</span> <span class="n">_</span> <span class="o">(</span><span class="n">le_refl</span> <span class="n">_</span><span class="o">)⟩</span> <span class="o">}</span>

<span class="kd">lemma</span> <span class="n">closure_eq_of_le</span> <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">⊆</span> <span class="n">S</span><span class="o">)</span> <span class="o">(</span><span class="n">h₂</span> <span class="o">:</span> <span class="n">S</span> <span class="bp">≤</span> <span class="n">closure</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span> <span class="n">closure</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">S</span> <span class="o">:=</span>
<span class="n">le_antisymm</span> <span class="o">(</span><span class="n">closure.le_iff.2</span> <span class="n">h₁</span><span class="o">)</span> <span class="n">h₂</span>

<span class="kd">end</span> <span class="n">lower_adjoint</span>

<span class="kd">end</span> <span class="n">coe_to_set</span>
</code></pre></div>



<a name="238208302"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/238208302" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#238208302">(May 10 2021 at 20:40)</a>:</h4>
<p>(Definitely not going to stick to these names, but the overall structure seems viable to me.)</p>



<a name="238212219"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/238212219" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#238212219">(May 10 2021 at 21:07)</a>:</h4>
<p>Are those the only four lemma that can be generalized in this way, or are there more and you just picked them as examples?</p>



<a name="238216532"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/238216532" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#238216532">(May 10 2021 at 21:41)</a>:</h4>
<p>There are definitely more, these were just the first ones I did before I got bored.</p>



<a name="238216958"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/238216958" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#238216958">(May 10 2021 at 21:45)</a>:</h4>
<p>E.g. from <code>submodule.span</code> we'd also get (untested, just copied and renamed)</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">mono</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">⊆</span> <span class="n">t</span><span class="o">)</span> <span class="o">:</span> <span class="n">closure</span> <span class="n">s</span> <span class="bp">≤</span> <span class="n">closure</span> <span class="n">t</span> <span class="o">:=</span>
<span class="n">closure.le_iff.2</span> <span class="bp">$</span> <span class="n">subset.trans</span> <span class="n">h</span> <span class="n">closure.subset</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">apply_self</span> <span class="o">:</span> <span class="n">closure</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">β</span><span class="o">)</span> <span class="bp">=</span> <span class="n">S</span> <span class="o">:=</span>
<span class="n">closure.eq_of_le</span> <span class="n">closure.subset</span> <span class="o">(</span><span class="n">le_refl</span> <span class="n">_</span><span class="o">)</span>
</code></pre></div>



<a name="238217459"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/238217459" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#238217459">(May 10 2021 at 21:50)</a>:</h4>
<p>And then there's the other complete lattice operators:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">map_empty</span> <span class="o">:</span> <span class="n">closure</span> <span class="o">(</span><span class="bp">∅</span> <span class="o">:</span> <span class="n">set</span> <span class="n">β</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">⊥</span> <span class="o">:=</span>
<span class="n">closure.gi.gc.l_bot</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">map_univ</span> <span class="o">:</span> <span class="n">closure</span> <span class="o">(</span><span class="n">univ</span> <span class="o">:</span> <span class="n">set</span> <span class="n">M</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">⊤</span> <span class="o">:=</span>
<span class="n">eq_top_iff.2</span> <span class="bp">$</span> <span class="n">set_like.le_def.2</span> <span class="bp">$</span> <span class="n">closure.subset</span>

<span class="kd">lemma</span> <span class="n">map_union</span> <span class="o">(</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">set</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">closure</span> <span class="o">(</span><span class="n">s</span> <span class="bp">∪</span> <span class="n">t</span><span class="o">)</span> <span class="bp">=</span> <span class="n">closure</span> <span class="n">s</span> <span class="bp">⊔</span> <span class="n">closure</span> <span class="n">t</span> <span class="o">:=</span>
<span class="n">closure.gi.gc.l_sup</span>

<span class="kd">lemma</span> <span class="n">map_Union</span> <span class="o">{</span><span class="n">ι</span><span class="o">}</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">closure</span> <span class="o">(</span><span class="bp">⋃</span> <span class="n">i</span><span class="o">,</span> <span class="n">s</span> <span class="n">i</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">⨆</span> <span class="n">i</span><span class="o">,</span> <span class="n">closure</span> <span class="o">(</span><span class="n">s</span> <span class="n">i</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">closure.gc.l_supr</span>

<span class="kd">lemma</span> <span class="n">eq_supr_closure_singleton</span> <span class="o">:</span> <span class="n">closure</span> <span class="n">s</span> <span class="bp">=</span> <span class="bp">⨆</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">,</span> <span class="n">closure</span> <span class="o">{</span><span class="n">x</span><span class="o">}</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="bp">←</span><span class="n">map_Union</span><span class="o">,</span> <span class="n">set.bUnion_of_singleton</span> <span class="n">s</span><span class="o">]</span>
</code></pre></div>
<p>etc.</p>



<a name="238431888"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/238431888" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#238431888">(May 12 2021 at 07:19)</a>:</h4>
<p>So <code>lower_adjoint</code> would act like the closure operator? And you want to feed in a <code>galois_insertion</code> inside it, then take it out?<br>
Let's see if I can do something with that.</p>



<a name="238431897"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/238431897" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#238431897">(May 12 2021 at 07:19)</a>:</h4>
<p>Note that a closure operator only requires a <code>galois_connection</code>.</p>



<a name="238440192"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/238440192" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#238440192">(May 12 2021 at 08:36)</a>:</h4>
<p>Ah sorry, yes. It should probably be <code>galois_connection</code>, I just took the previous code where the <code>closure</code> map was defined in a typeclass and adjusted it, overlooking that difference.</p>



<a name="238440294"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/238440294" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#238440294">(May 12 2021 at 08:37)</a>:</h4>
<p>I tried making dot notation work but it turns out weird because <code>group</code> is unbundled.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[simps]</span> <span class="kd">def</span> <span class="n">group.closure</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">hG</span> <span class="o">:</span> <span class="n">group</span> <span class="n">G</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">lower_adjoint</span> <span class="o">(</span><span class="n">coe</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">G</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">G</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">k</span><span class="o">,</span> <span class="n">Inf</span> <span class="o">{</span><span class="n">K</span> <span class="bp">|</span> <span class="n">k</span> <span class="bp">⊆</span> <span class="n">K</span><span class="o">},</span>
  <span class="n">gc'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">k</span> <span class="n">K</span><span class="o">,</span>
    <span class="o">⟨</span><span class="n">set.subset.trans</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span> <span class="n">subgroup.mem_Inf.2</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">K</span> <span class="n">hK</span><span class="o">,</span> <span class="n">hK</span> <span class="n">hx</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">Inf_le</span> <span class="n">h</span><span class="o">⟩</span> <span class="o">}</span>

<span class="kd">lemma</span> <span class="n">subset_closure</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">h</span> <span class="o">:</span> <span class="n">group</span> <span class="n">G</span><span class="o">]</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">G</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">s</span> <span class="bp">⊆</span> <span class="n">h.closure</span> <span class="n">s</span> <span class="o">:=</span>
<span class="n">h.closure.gc.le_u</span> <span class="o">(</span><span class="n">le_refl</span> <span class="n">_</span><span class="o">)</span>
</code></pre></div>



<a name="238440689"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/238440689" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#238440689">(May 12 2021 at 08:40)</a>:</h4>
<p>Do you think there's any chance we'll need <code>upper_adjoint</code>? If I'm correct this is an interior operator.</p>



<a name="238440887"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/238440887" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#238440887">(May 12 2021 at 08:42)</a>:</h4>
<p>I kind of find it weird to name a closure operator <code>lower_adjoint</code> but I guess it's more accurate as the actual closure operator is the composition of both adjoints.</p>



<a name="238441172"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/238441172" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#238441172">(May 12 2021 at 08:45)</a>:</h4>
<p>The name <code>lower_adjoin</code> is definitely something of a placeholder, which I used because I'm more at home with (basic) category theory than order theory.</p>



<a name="238441487"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/238441487" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#238441487">(May 12 2021 at 08:48)</a>:</h4>
<p>Note that we already have <a href="https://leanprover-community.github.io/mathlib_docs/find/monoid.closure">docs#monoid.closure</a> but it has quite a different type; so I think <code>group.closure</code> is a bad name.</p>



<a name="238441575"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/238441575" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#238441575">(May 12 2021 at 08:49)</a>:</h4>
<p>I would follow the existing mathlib convention and call it <code>subgroup.closure</code>. Dot notation seems unlikely to work well, especially since there are things like the smallest ideal of <code>R</code> containing <code>s</code> that would become <code>module.span</code> with your convention, and there's no easy way to name the <code>module R R</code> instance.</p>



<a name="238441725"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/238441725" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#238441725">(May 12 2021 at 08:50)</a>:</h4>
<p>That is, I would rather write <code>ideal.span s</code> (or <code>submodule.span R s</code>) than <code>(@semiring.to_module R).span s</code></p>



<a name="238441841"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/238441841" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#238441841">(May 12 2021 at 08:51)</a>:</h4>
<p>Yeah, I think so too. But I think there are also cases where dot notation turns out fine.</p>



<a name="238442031"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/238442031" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#238442031">(May 12 2021 at 08:53)</a>:</h4>
<p>So what's there to be done?</p>



<a name="238442133"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/238442133" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#238442133">(May 12 2021 at 08:54)</a>:</h4>
<p>I think we can just go through <code>order/closure.lean</code> and see what needs changing.</p>



<a name="238442206"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/238442206" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#238442206">(May 12 2021 at 08:55)</a>:</h4>
<p>Ah yeah, I wanted to try out the case <code>α = β</code> as I suspect the <code>id</code> will turn out weird.</p>



<a name="238442670"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/238442670" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#238442670">(May 12 2021 at 08:59)</a>:</h4>
<p>Ugh, yeah it does: <code>(λ (s : set E), ⋂ (t : set E) (hst : s ⊆ t) (ht : convex t), t) s ≤ t ↔ s ≤ id t</code></p>



<a name="238442780"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/238442780" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#238442780">(May 12 2021 at 09:00)</a>:</h4>
<p>Then maybe we can restrict <code>closure_operator</code> to same-set closure operators and <code>lower_adjoint</code> (or however we end up calling it) to the other cases?</p>



<a name="238443033"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/238443033" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#238443033">(May 12 2021 at 09:02)</a>:</h4>
<p>Is that <code>id</code> a problem?</p>



<a name="238443111"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/238443111" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#238443111">(May 12 2021 at 09:03)</a>:</h4>
<p>I don't know, you tell me. But I wouldn't want <code>id</code>s to clutter all expressions involving convex hulls and stuff.</p>



<a name="238443858"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/238443858" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#238443858">(May 12 2021 at 09:09)</a>:</h4>
<p><span class="user-mention silent" data-user-id="387244">Yaël Dillies</span> <a href="#narrow/stream/113488-general/topic/Closure.20operators/near/238442780">said</a>:</p>
<blockquote>
<p>Then maybe we can restrict <code>closure_operator</code> to same-set closure operators and <code>lower_adjoint</code> (or however we end up calling it) to the other cases?</p>
</blockquote>
<p><span class="user-mention" data-user-id="246273">@Bhavik Mehta</span> is that how you saw things (with <code>galois_insertion</code> instead of <code>lower_adjoint</code>) when introducing <code>order/closure.lean</code>?</p>



<a name="238452055"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/238452055" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#238452055">(May 12 2021 at 10:29)</a>:</h4>
<p><span class="user-mention silent" data-user-id="238446">Anne Baanen</span> <a href="#narrow/stream/113488-general/topic/Closure.20operators/near/238208154">said</a>:</p>
<blockquote>
<p>This is how I would rewrite lines 540-563 of <code>group_theory/subgroup.lean</code>:</p>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">group_theory.subgroup</span>

<span class="kd">structure</span> <span class="n">lower_adjoint</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">preorder</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">preorder</span> <span class="n">β</span><span class="o">]</span> <span class="o">(</span><span class="n">u</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">to_fun</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span>
<span class="o">(</span><span class="n">gi'</span> <span class="o">:</span> <span class="n">galois_insertion</span> <span class="n">to_fun</span> <span class="n">u</span><span class="o">)</span>

<span class="kn">namespace</span> <span class="n">lower_adjoint</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">preorder</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">preorder</span> <span class="n">β</span><span class="o">]</span> <span class="o">{</span><span class="n">u</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">lower_adjoint</span> <span class="n">u</span><span class="o">)</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_coe_to_fun</span> <span class="o">(</span><span class="n">lower_adjoint</span> <span class="n">u</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">F</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">,</span> <span class="n">coe</span> <span class="o">:=</span> <span class="n">to_fun</span> <span class="o">}</span>

<span class="n">initialize_simps_projections</span> <span class="n">lower_adjoint</span> <span class="o">(</span><span class="n">to_fun</span> <span class="bp">→</span> <span class="n">apply</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">gi</span> <span class="o">:</span> <span class="n">galois_insertion</span> <span class="n">l</span> <span class="n">u</span> <span class="o">:=</span> <span class="n">l.gi'</span>

<span class="kd">end</span> <span class="n">lower_adjoint</span>

<span class="kd">@[simps?]</span> <span class="kd">def</span> <span class="n">subgroup.closure'</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">lower_adjoint</span> <span class="o">(</span><span class="n">coe</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">G</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">G</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="n">subgroup.closure</span><span class="o">,</span>
  <span class="n">gi'</span> <span class="o">:=</span> <span class="n">subgroup.gi</span> <span class="n">G</span> <span class="o">}</span>

<span class="c1">-- Lemmas for `lower_adjoint (coe : α → set β)`, where `set_like α β`</span>
<span class="kn">section</span> <span class="n">coe_to_set</span>

<span class="kn">namespace</span> <span class="n">lower_adjoint</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">set_like</span> <span class="n">α</span> <span class="n">β</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">(</span><span class="n">closure</span> <span class="o">:</span> <span class="n">lower_adjoint</span> <span class="o">(</span><span class="n">coe</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">β</span><span class="o">))</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">β</span><span class="o">}</span> <span class="o">{</span><span class="n">S</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span>

<span class="kd">lemma</span> <span class="n">subset</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">⊆</span> <span class="o">(</span><span class="n">closure</span> <span class="n">s</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">closure.gi.gc.le_u</span> <span class="o">(</span><span class="n">le_refl</span> <span class="n">_</span><span class="o">)</span>

<span class="kd">lemma</span> <span class="n">le_iff</span> <span class="o">:</span> <span class="n">closure</span> <span class="n">s</span> <span class="bp">≤</span> <span class="n">S</span> <span class="bp">↔</span> <span class="n">s</span> <span class="bp">⊆</span> <span class="n">S</span> <span class="o">:=</span>
<span class="n">closure.gi.gc</span> <span class="n">_</span> <span class="n">_</span>

<span class="kd">lemma</span> <span class="n">mem_iff</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">β</span><span class="o">}</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="o">(</span><span class="n">closure</span> <span class="n">s</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="bp">↔</span> <span class="bp">∀</span> <span class="n">S</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">s</span> <span class="bp">⊆</span> <span class="n">S</span> <span class="bp">→</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">S</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">simp_rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">set_like.mem_coe</span><span class="o">,</span> <span class="bp">←</span> <span class="n">set.singleton_subset_iff</span><span class="o">,</span> <span class="bp">←</span> <span class="n">closure.le_iff</span><span class="o">],</span>
     <span class="n">exact</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">h</span> <span class="n">S</span><span class="o">,</span> <span class="n">le_trans</span> <span class="n">h</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">h</span> <span class="n">_</span> <span class="o">(</span><span class="n">le_refl</span> <span class="n">_</span><span class="o">)⟩</span> <span class="o">}</span>

<span class="kd">lemma</span> <span class="n">eq_of_le</span> <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">⊆</span> <span class="n">S</span><span class="o">)</span> <span class="o">(</span><span class="n">h₂</span> <span class="o">:</span> <span class="n">S</span> <span class="bp">≤</span> <span class="n">closure</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span> <span class="n">closure</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">S</span> <span class="o">:=</span>
<span class="n">le_antisymm</span> <span class="o">(</span><span class="n">closure.le_iff.2</span> <span class="n">h₁</span><span class="o">)</span> <span class="n">h₂</span>

<span class="kd">end</span> <span class="n">lower_adjoint</span>

<span class="kd">end</span> <span class="n">coe_to_set</span>
</code></pre></div><br>
</p>
</blockquote>
<p>What's the point of introducing <code>gi'</code> first versus just putting <code>gi</code> as a field?</p>



<a name="238452413"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/238452413" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#238452413">(May 12 2021 at 10:32)</a>:</h4>
<p><code>x.gi'</code> is about <code>x.to_fun</code>, <code>x.gi</code> is about <code>⇑x</code></p>



<a name="238452433"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/238452433" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#238452433">(May 12 2021 at 10:32)</a>:</h4>
<p>It's like <a href="https://leanprover-community.github.io/mathlib_docs/find/add_monoid_hom.map_add">docs#add_monoid_hom.map_add</a> vs <a href="https://leanprover-community.github.io/mathlib_docs/find/add_monoid_hom.map_add'">docs#add_monoid_hom.map_add'</a></p>



<a name="238452743"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/238452743" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#238452743">(May 12 2021 at 10:35)</a>:</h4>
<p>Aaah, I see :)</p>



<a name="238455528"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/238455528" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#238455528">(May 12 2021 at 11:04)</a>:</h4>
<p>The original reason I wanted closure operators wasn't to make algebraic structures easier, but to be able to talk about results for general closure operators. So as long as there's a type for closure operators on a type, I'm happy</p>



<a name="238455740"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/238455740" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#238455740">(May 12 2021 at 11:06)</a>:</h4>
<p>And when you talk about general closure operators, you mean <code>α → α</code>, right?</p>



<a name="238455827"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/238455827" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#238455827">(May 12 2021 at 11:07)</a>:</h4>
<p>Yup</p>



<a name="238456672"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/238456672" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#238456672">(May 12 2021 at 11:15)</a>:</h4>
<p>Uh, I'm confused. This is wrong</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">closure_operator.lower_adjoint</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">closure_operator</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">lower_adjoint</span> <span class="o">(</span><span class="n">id</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="n">c.to_fun</span><span class="o">,</span>
  <span class="n">gc'</span> <span class="o">:=</span> <span class="n">_</span> <span class="o">}</span>
</code></pre></div>



<a name="238456893"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/238456893" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#238456893">(May 12 2021 at 11:17)</a>:</h4>
<p><code>lower_adjoint id</code> seems to rather correspond to an interior operator, but <code>lower_adjoint</code> does give closure operators. I'm confused.</p>



<a name="238457554"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/238457554" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#238457554">(May 12 2021 at 11:23)</a>:</h4>
<p>Maybe for that we need an antitone Galois connection? That's weird.</p>



<a name="238462052"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/238462052" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#238462052">(May 12 2021 at 12:03)</a>:</h4>
<p>I think I just tangled myself up and it actually works.</p>



<a name="238479876"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/238479876" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#238479876">(May 12 2021 at 14:10)</a>:</h4>
<p>So here's how it looks</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">G</span><span class="o">:</span> <span class="kt">Type</span> <span class="n">u_1</span>
<span class="n">h</span><span class="o">:</span> <span class="n">group</span> <span class="n">G</span>
<span class="n">s</span><span class="o">:</span> <span class="n">set</span> <span class="n">G</span>
<span class="bp">⊢</span> <span class="n">s</span> <span class="bp">⊆</span> <span class="bp">↑</span><span class="o">(</span><span class="bp">⇑</span><span class="n">subgroup.closure'</span> <span class="n">s</span><span class="o">)</span>
</code></pre></div>
<p>Is it too coercion-frightening?</p>



<a name="238518992"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/238518992" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#238518992">(May 12 2021 at 18:09)</a>:</h4>
<p>So Bhavik and I have been thinking about creating a constructor from a <code>complete_lattice</code>structure on `` and here's how it goes</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/-- Constructor from a `complete_lattice`. It is a commonplace construction with</span>
<span class="sd">`u := (coe : β → α)` -/</span>
<span class="kd">@[simps]</span> <span class="kd">def</span> <span class="n">complete_lattice.closure</span> <span class="o">(</span><span class="n">hu</span> <span class="o">:</span> <span class="n">monotone</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">hu₂</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">β</span><span class="o">,</span> <span class="n">u</span> <span class="o">(</span><span class="n">Inf</span> <span class="bp">...</span><span class="o">)</span> <span class="bp">=</span> <span class="n">lub</span> <span class="o">(</span><span class="n">u</span> <span class="bp">...</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">lower_adjoint</span> <span class="n">u</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">k</span><span class="o">,</span> <span class="n">Inf</span> <span class="o">{</span><span class="n">K</span> <span class="bp">|</span> <span class="n">k</span> <span class="bp">≤</span> <span class="n">u</span> <span class="n">K</span><span class="o">},</span>
  <span class="n">gc'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">k</span> <span class="n">K</span><span class="o">,</span>
  <span class="o">⟨</span><span class="kd">begin</span>
    <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
    <span class="gr">sorry</span>
  <span class="kd">end</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">Inf_le</span> <span class="n">h</span><span class="o">⟩</span>
<span class="o">}</span>
</code></pre></div>



<a name="238521244"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/238521244" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#238521244">(May 12 2021 at 18:25)</a>:</h4>
<p>It seems that it's hard to get back <code>galois_connection</code> from <code>complete_lattice</code>. And I say "get back" because most of the <code>complete_lattice</code> instances we're concerned about use at one point or another the <code>galois_connection</code> in disguise.</p>



<a name="238523322"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/238523322" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#238523322">(May 12 2021 at 18:37)</a>:</h4>
<p>So I think the way to do would be basic stuff -&gt; <code>lower_adjoint</code> (sorry, <span class="user-mention silent" data-user-id="238446">Anne Baanen</span>  this is slowly settling as the name <span aria-label="stuck out tongue" class="emoji emoji-1f61b" role="img" title="stuck out tongue">:stuck_out_tongue:</span>) -&gt; lemmas about the closure -&gt; <code>complete_lattice</code> -&gt; more stuff</p>



<a name="238533438"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/238533438" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#238533438">(May 12 2021 at 19:49)</a>:</h4>
<p>Here's where stuff happens: <a href="https://github.com/leanprover-community/mathlib/tree/yael/lower_adjoint">https://github.com/leanprover-community/mathlib/tree/yael/lower_adjoint</a></p>



<a name="238548511"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/238548511" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#238548511">(May 12 2021 at 21:37)</a>:</h4>
<p>Would it make sense to define <code>upper_adjoint</code> in a similar fashion?</p>



<a name="238548672"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/238548672" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#238548672">(May 12 2021 at 21:38)</a>:</h4>
<p>Also, <code>order.semiconj_Sup</code> now ought to disappear, as what's in there just got heavily generalised.</p>



<a name="238927050"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure%20operators/near/238927050" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Closure.20operators.html#238927050">(May 15 2021 at 21:35)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/issues/7608">#7608</a></p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
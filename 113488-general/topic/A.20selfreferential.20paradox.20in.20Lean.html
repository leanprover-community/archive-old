---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/A.20selfreferential.20paradox.20in.20Lean.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20selfreferential.20paradox.20in.20Lean.html">A selfreferential paradox in Lean</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="285495230"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20selfreferential%20paradox%20in%20Lean/near/285495230" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Raphael Appenzeller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20selfreferential.20paradox.20in.20Lean.html#285495230">(Jun 09 2022 at 07:19)</a>:</h4>
<p>Consider the following definition: A real number <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> is said to be <strong>conceivable</strong> if there is a Lean-program that defines <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> and proves that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> is a real number.<br>
Example: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi></mrow><annotation encoding="application/x-tex">\pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span></span></span></span> is conceivable, because the following Lean program exists:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">analysis.special_functions.exp</span>
<span class="kn">import</span> <span class="n">data.set.intervals.infinite</span>
<span class="kn">import</span> <span class="n">analysis.special_functions.trigonometric.basic</span>
<span class="kd">noncomputable theory</span>
<span class="kn">namespace</span> <span class="n">real</span>
   <span class="kn">protected</span> <span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">pi</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="o">:=</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">classical.some</span> <span class="n">exists_cos_eq_zero</span>
<span class="kd">end</span> <span class="n">real</span>
</code></pre></div>
<p><strong>Question 1:</strong> Is it possible to implement the definition of conceivable in Lean and to prove in Lean that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi></mrow><annotation encoding="application/x-tex">\pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span></span></span></span> is conceivable?<br>
Now we argue that there can be at most countably many conceivable numbers: since for every conceivable number <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> there is a .lean-file <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">ℓ</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\ell(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">ℓ</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span> and an associated integer <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo stretchy="false">(</mo><mi mathvariant="normal">ℓ</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">i(\ell(x))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">i</span><span class="mopen">(</span><span class="mord">ℓ</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">))</span></span></span></span> which is the number you get when you consider the .lean-file as a binary number in computer memory. The function <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>∘</mo><mi mathvariant="normal">ℓ</mi></mrow><annotation encoding="application/x-tex">i \circ \ell</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∘</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord">ℓ</span></span></span></span> is an injective function from the conceivable numbers to the natural numbers.<br>
<strong>Question 2:</strong> Is it possible to implement in Lean the proof that there is an injective function from the conceivables to the naturals? <br>
Now paradoxically we claim that the injection above cannot exist, by Cantor's diagonal argument: given the injection <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>∘</mo><mi mathvariant="normal">ℓ</mi></mrow><annotation encoding="application/x-tex">i \circ \ell</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∘</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord">ℓ</span></span></span></span> we can define a new conceivable number <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> as follows: The <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> th decimal digit of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> should always be <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> unless <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> is in the image of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>∘</mo><mi mathvariant="normal">ℓ</mi></mrow><annotation encoding="application/x-tex">i \circ \ell</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∘</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord">ℓ</span></span></span></span> and the conceivable number <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> with <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo stretchy="false">(</mo><mi mathvariant="normal">ℓ</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">i (\ell(x))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">i</span><span class="mopen">(</span><span class="mord">ℓ</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">))</span></span></span></span> already has a <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> at its <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> th decimal digit (in this case we set the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> th decimal digit of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> to be <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>).<br>
<strong>Question 3:</strong> Is this new real number conceivable, i.e. is it possible to implement this definition (and the proof that it is a real number) in Lean?<br>
If so, we have a conceivable number <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> whose $$i(\ell(y))$$th digit has to be <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> and nonzero at the same time, thus a contradiction.<br>
<strong>Question 4:</strong> Is there a flaw in my intuitive argument for this contradiction?<br>
<strong>Question 5:</strong> At which step is it no longer possible to implement the argument in Lean?</p>



<a name="285495397"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20selfreferential%20paradox%20in%20Lean/near/285495397" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20selfreferential.20paradox.20in.20Lean.html#285495397">(Jun 09 2022 at 07:21)</a>:</h4>
<p>I'm pretty sure you can't prove anything about Lean in lean. What you can do is make a model of Lean in Lean, and prove things about that model</p>



<a name="285495412"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20selfreferential%20paradox%20in%20Lean/near/285495412" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20selfreferential.20paradox.20in.20Lean.html#285495412">(Jun 09 2022 at 07:21)</a>:</h4>
<p>Q1: no, you cannot define conceivable</p>



<a name="285495429"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20selfreferential%20paradox%20in%20Lean/near/285495429" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20selfreferential.20paradox.20in.20Lean.html#285495429">(Jun 09 2022 at 07:21)</a>:</h4>
<p>it would need to quantify over all universes</p>



<a name="285495557"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20selfreferential%20paradox%20in%20Lean/near/285495557" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20selfreferential.20paradox.20in.20Lean.html#285495557">(Jun 09 2022 at 07:22)</a>:</h4>
<p>Can you elaborate on where universe quantification comes into play here?</p>



<a name="285495657"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20selfreferential%20paradox%20in%20Lean/near/285495657" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20selfreferential.20paradox.20in.20Lean.html#285495657">(Jun 09 2022 at 07:23)</a>:</h4>
<p>To say that a number is conceivable, you need to define a modeling relation between strings representing lean files and elements of the universe. This relation would have to involve arbitrarily large universes since you don't know in advance how many universes will be used in the construction of a given e.g. real number</p>



<a name="285495784"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20selfreferential%20paradox%20in%20Lean/near/285495784" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20selfreferential.20paradox.20in.20Lean.html#285495784">(Jun 09 2022 at 07:24)</a>:</h4>
<p>you could define something like "definable using only n universes" but there would be some definable numbers that are left out in this definition</p>



<a name="285495925"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20selfreferential%20paradox%20in%20Lean/near/285495925" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20selfreferential.20paradox.20in.20Lean.html#285495925">(Jun 09 2022 at 07:26)</a>:</h4>
<p>Ah, so you're saying even with the "model of Lean in Lean" approach it's still not possible</p>



<a name="285495938"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20selfreferential%20paradox%20in%20Lean/near/285495938" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20selfreferential.20paradox.20in.20Lean.html#285495938">(Jun 09 2022 at 07:26)</a>:</h4>
<p>right, lean can't prove there exists a model of lean</p>



<a name="285495954"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20selfreferential%20paradox%20in%20Lean/near/285495954" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20selfreferential.20paradox.20in.20Lean.html#285495954">(Jun 09 2022 at 07:26)</a>:</h4>
<p>that's just a variation on Goedel's second incompleteness theorem</p>



<a name="285495976"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20selfreferential%20paradox%20in%20Lean/near/285495976" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20selfreferential.20paradox.20in.20Lean.html#285495976">(Jun 09 2022 at 07:27)</a>:</h4>
<p>lean can prove there exists a model of lean with only n universes though</p>



<a name="285495977"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20selfreferential%20paradox%20in%20Lean/near/285495977" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20selfreferential.20paradox.20in.20Lean.html#285495977">(Jun 09 2022 at 07:27)</a>:</h4>
<p>What's the largest difference in mathlib between the universe of the type of a value and the universe needed to construct it?</p>



<a name="285496019"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20selfreferential%20paradox%20in%20Lean/near/285496019" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20selfreferential.20paradox.20in.20Lean.html#285496019">(Jun 09 2022 at 07:27)</a>:</h4>
<p>There is an old thread where I determined that the largest universe that appears in mathlib is 4</p>



<a name="285496101"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20selfreferential%20paradox%20in%20Lean/near/285496101" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20selfreferential.20paradox.20in.20Lean.html#285496101">(Jun 09 2022 at 07:28)</a>:</h4>
<p>We still have a long way till we need 37 universes <span aria-label="rofl" class="emoji emoji-1f923" role="img" title="rofl">:rofl:</span></p>



<a name="285496123"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20selfreferential%20paradox%20in%20Lean/near/285496123" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20selfreferential.20paradox.20in.20Lean.html#285496123">(Jun 09 2022 at 07:28)</a>:</h4>
<p>but in the process I also found that there is an easy way to pump up the universe level of a definition by adding identity functions</p>



<a name="285496151"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20selfreferential%20paradox%20in%20Lean/near/285496151" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20selfreferential.20paradox.20in.20Lean.html#285496151">(Jun 09 2022 at 07:28)</a>:</h4>
<p>Yes, that's what came to mind. My question was whether we have some things in Type 0 which rely on defs in Type 4 or similar</p>



<a name="285496183"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20selfreferential%20paradox%20in%20Lean/near/285496183" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20selfreferential.20paradox.20in.20Lean.html#285496183">(Jun 09 2022 at 07:29)</a>:</h4>
<p><a href="#narrow/stream/113488-general/topic/Highest.20universe.20in.20mathlib/near/266024694">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Highest.20universe.20in.20mathlib/near/266024694</a></p>



<a name="285496499"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20selfreferential%20paradox%20in%20Lean/near/285496499" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20selfreferential.20paradox.20in.20Lean.html#285496499">(Jun 09 2022 at 07:32)</a>:</h4>
<p>The specific example there was that <code>finsum_mem_empty.{0 0}</code> is a definition (well, a theorem) which relies on definitions in <code>Sort 4</code></p>



<a name="285496565"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20selfreferential%20paradox%20in%20Lean/near/285496565" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20selfreferential.20paradox.20in.20Lean.html#285496565">(Jun 09 2022 at 07:33)</a>:</h4>
<p>I'm still skeptical of this claim. How do you see the 4?</p>



<a name="285496589"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20selfreferential%20paradox%20in%20Lean/near/285496589" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20selfreferential.20paradox.20in.20Lean.html#285496589">(Jun 09 2022 at 07:33)</a>:</h4>
<p>I go over it in detail in that thread (you were also skeptical then)</p>



<a name="285496676"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20selfreferential%20paradox%20in%20Lean/near/285496676" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20selfreferential.20paradox.20in.20Lean.html#285496676">(Jun 09 2022 at 07:34)</a>:</h4>
<p>It's not that I believe that this use is <em>necessary</em>, but rather that it is literally present if you unfold all the definitions</p>



<a name="285496682"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20selfreferential%20paradox%20in%20Lean/near/285496682" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20selfreferential.20paradox.20in.20Lean.html#285496682">(Jun 09 2022 at 07:34)</a>:</h4>
<p>I think I failed to reproduce :-) I'll give it another go</p>



<a name="285496761"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20selfreferential%20paradox%20in%20Lean/near/285496761" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20selfreferential.20paradox.20in.20Lean.html#285496761">(Jun 09 2022 at 07:35)</a>:</h4>
<p>the challenge is to figure out how to formalize a lean model such that the really large universes are only "half-baked" in some as-yet-undetermined way such that they can validate games with <code>id</code> applications but such that they are not full models of ZFC</p>



<a name="285496868"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20selfreferential%20paradox%20in%20Lean/near/285496868" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20selfreferential.20paradox.20in.20Lean.html#285496868">(Jun 09 2022 at 07:37)</a>:</h4>
<p>I suspect that it suffices to say that the universes either don't support inductive types at all, or only "simple" inductive types (where "simple" is intended to exclude the really axiomatically strong examples like <a href="https://leanprover-community.github.io/mathlib_docs/find/pSet">docs#pSet</a>)</p>



<a name="285497712"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20selfreferential%20paradox%20in%20Lean/near/285497712" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20selfreferential.20paradox.20in.20Lean.html#285497712">(Jun 09 2022 at 07:46)</a>:</h4>
<p>By the way, in case you are wondering how there could be "more real numbers" if you tweak something as abstract as the number of universes used in the definition, consider this.</p>
<p>Real numbers are equivalent to sets of natural numbers so let's talk about those instead. An example of a <code>nat -&gt; Prop</code> function which is not definable with fewer than n+1 universes is the truth predicate for formulas that talk about a model of lean with n universes. The existence of such a predicate implies the consistency of Lean_n, so Lean_n can't prove it exists and you need n+1 universes to prove it</p>



<a name="285497884"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A%20selfreferential%20paradox%20in%20Lean/near/285497884" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/A.20selfreferential.20paradox.20in.20Lean.html#285497884">(Jun 09 2022 at 07:49)</a>:</h4>
<p>This phenomenon does not happen with <code>nat</code>, only <code>real</code> or <code>nat -&gt; Prop</code> because <code>nat</code> is <a href="https://en.wikipedia.org/wiki/Absoluteness">absolute</a> but the powerset function is not.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
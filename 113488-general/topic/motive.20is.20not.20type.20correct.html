---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/motive.20is.20not.20type.20correct.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/motive.20is.20not.20type.20correct.html">motive is not type correct</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="204738496"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/motive%20is%20not%20type%20correct/near/204738496" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shing Tak Lam <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/motive.20is.20not.20type.20correct.html#204738496">(Jul 23 2020 at 00:24)</a>:</h4>
<p>I'm not sure where this belongs, probably not <a class="stream" data-stream-id="113489" href="/#narrow/stream/113489-new-members">#new members</a> , so <a class="stream" data-stream-id="113488" href="/#narrow/stream/113488-general">#general</a> it is.</p>
<p>In <a href="https://github.com/leanprover-community/mathlib/issues/3498">#3498</a>, Floris raised the idea that an approach going through a list of digits might be nicer than strong induction on the natural numbers. However that requires the lemma that <code>0 &lt; (digits b m).last _</code>, which from what I can tell is not in mathlib yet. However, when I try to write a proof for this, I get stuck with <code>motive is not type correct</code> or just <code>failed</code> when I'm rewriting. What does this mean? and any suggestions are welcome.</p>
<p>cc <span class="user-mention" data-user-id="304229">@Angela Li</span> </p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">nat</span><span class="bp">.</span><span class="n">digits</span>

<span class="kn">lemma</span> <span class="n">digits_ne_nil_iff_ne_zero</span> <span class="o">(</span><span class="n">b</span> <span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">digits</span> <span class="n">b</span> <span class="n">n</span> <span class="bp">≠</span> <span class="o">[]</span> <span class="bp">↔</span> <span class="n">n</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="kn">lemma</span> <span class="n">last_digit_ne_zero</span> <span class="o">(</span><span class="n">b</span> <span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">hm</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">digits</span> <span class="n">b</span> <span class="n">m</span><span class="o">)</span><span class="bp">.</span><span class="n">last</span> <span class="o">((</span><span class="n">digits_ne_nil_iff_ne_zero</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">)</span><span class="bp">.</span><span class="n">mpr</span> <span class="n">hm</span><span class="o">)</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">rcases</span> <span class="n">b</span> <span class="k">with</span> <span class="bp">_|_|</span><span class="n">b</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">sorry</span> <span class="c">/-</span><span class="cm"> This one is trivial, proof omitted -/</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">sorry</span> <span class="c">/-</span><span class="cm"> This one can be done by existing lemmas, proof omitted -/</span> <span class="o">},</span>
  <span class="o">{</span> <span class="c">/-</span><span class="cm"> This case I haven&#39;t got a clue for -/</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">digits</span><span class="o">],</span> <span class="c">/-</span><span class="cm"> Why does `simp` work and `rw` not work? -/</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">digits_aux_def</span><span class="o">],</span> <span class="c">/-</span><span class="cm"> motive is not type correct? But now `simp` also fails... -/</span>
    <span class="n">sorry</span> <span class="o">}</span>
<span class="kn">end</span>
</code></pre></div>



<a name="204738628"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/motive%20is%20not%20type%20correct/near/204738628" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/motive.20is.20not.20type.20correct.html#204738628">(Jul 23 2020 at 00:26)</a>:</h4>
<p>does <code>simp_rw</code> work?</p>



<a name="204738680"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/motive%20is%20not%20type%20correct/near/204738680" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/motive.20is.20not.20type.20correct.html#204738680">(Jul 23 2020 at 00:27)</a>:</h4>
<p>The problem is that the <code>_</code> in your goal also has a copy of <code>digits_aux ...</code> in it, and when you try to rewrite the visible one, Lean complains that the type-dependency might break.</p>



<a name="204738696"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/motive%20is%20not%20type%20correct/near/204738696" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shing Tak Lam <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/motive.20is.20not.20type.20correct.html#204738696">(Jul 23 2020 at 00:27)</a>:</h4>
<p>It does work when I change the <code>simp</code> to <code>simp_rw</code>, but not when I change the <code>rw</code> to <code>simp_rw</code></p>



<a name="204738794"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/motive%20is%20not%20type%20correct/near/204738794" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shing Tak Lam <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/motive.20is.20not.20type.20correct.html#204738794">(Jul 23 2020 at 00:28)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110087">Scott Morrison</span> <a href="#narrow/stream/113488-general/topic/motive.20is.20not.20type.20correct/near/204738680">said</a>:</p>
<blockquote>
<p>The problem is that the <code>_</code> in your goal also has a copy of <code>digits_aux ...</code> in it, and when you try to rewrite the visible one, Lean complains that the type-dependency might break.</p>
</blockquote>
<p>Right, so am I approaching this from a wrong perspective? Is the fact that <code>list.last</code> takes a proof which depends on rest of the term causing the issue here?</p>



<a name="204739223"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/motive%20is%20not%20type%20correct/near/204739223" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/motive.20is.20not.20type.20correct.html#204739223">(Jul 23 2020 at 00:35)</a>:</h4>
<p>Yes.</p>



<a name="204739249"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/motive%20is%20not%20type%20correct/near/204739249" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shing Tak Lam <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/motive.20is.20not.20type.20correct.html#204739249">(Jul 23 2020 at 00:35)</a>:</h4>
<p>Just in case this is <a href="https://en.wikipedia.org/wiki/XY_problem">#xy</a>, <a href="https://gist.github.com/shingtaklam1324/3fe981a9162ef2b62a9e6e26226f8297">here</a> is the rest of the code in context of that PR, but this lemma is probably nice to have anyways</p>



<a name="204739898"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/motive%20is%20not%20type%20correct/near/204739898" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/motive.20is.20not.20type.20correct.html#204739898">(Jul 23 2020 at 00:46)</a>:</h4>
<p>Does this (incomplete) help:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">lemma</span> <span class="n">foo</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">L</span> <span class="n">M</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">L</span> <span class="bp">=</span> <span class="n">M</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span><span class="o">)</span> <span class="o">:</span> <span class="n">L</span><span class="bp">.</span><span class="n">last</span> <span class="n">p</span> <span class="bp">=</span> <span class="n">M</span><span class="bp">.</span><span class="n">last</span> <span class="n">q</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">],</span>
<span class="kn">end</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">bar</span> <span class="o">(</span><span class="n">b</span> <span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="mi">2</span> <span class="bp">≤</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">w</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">digits</span> <span class="n">b</span> <span class="n">n</span> <span class="bp">=</span> <span class="o">((</span><span class="n">n</span> <span class="err">%</span> <span class="n">b</span><span class="o">)</span> <span class="bp">::</span> <span class="n">digits</span> <span class="n">b</span> <span class="o">(</span><span class="n">n</span> <span class="bp">/</span> <span class="n">b</span><span class="o">))</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">rcases</span> <span class="n">b</span> <span class="k">with</span> <span class="bp">_|_|</span><span class="n">b</span><span class="o">,</span> <span class="n">sorry</span><span class="o">,</span> <span class="n">sorry</span><span class="o">,</span>
  <span class="n">rcases</span> <span class="n">n</span> <span class="k">with</span> <span class="bp">_|</span><span class="n">n</span><span class="o">,</span> <span class="n">sorry</span><span class="o">,</span>
  <span class="n">simp</span><span class="o">,</span>
<span class="kn">end</span>

<span class="kn">lemma</span> <span class="n">digits_last</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="mi">2</span> <span class="bp">≤</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">hm</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">m</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">digits</span> <span class="n">b</span> <span class="n">m</span><span class="o">)</span><span class="bp">.</span><span class="n">last</span> <span class="n">p</span> <span class="bp">=</span> <span class="o">(</span><span class="n">digits</span> <span class="n">b</span> <span class="o">(</span><span class="n">m</span><span class="bp">/</span><span class="n">b</span><span class="o">))</span><span class="bp">.</span><span class="n">last</span> <span class="n">q</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">rw</span> <span class="n">foo</span> <span class="o">(</span><span class="n">bar</span> <span class="n">b</span> <span class="n">m</span> <span class="n">h</span> <span class="n">hm</span><span class="o">),</span>
<span class="kn">end</span>
</code></pre></div>



<a name="204751741"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/motive%20is%20not%20type%20correct/near/204751741" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shing Tak Lam <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/motive.20is.20not.20type.20correct.html#204751741">(Jul 23 2020 at 01:12)</a>:</h4>
<p>It does help, but then I feel like I'm going to need strong induction for this at some point, since I would need a statement about <code>digits b (m/b)</code>. Trying <code>nat.strong_induction_on m</code> doesn't work, presumably for the same reason.  So I'm not sure what approach to take here.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">lemma</span> <span class="n">last_digit_ne_zero</span> <span class="o">(</span><span class="n">b</span> <span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">hm</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span><span class="o">):</span>
  <span class="o">(</span><span class="n">digits</span> <span class="n">b</span> <span class="n">m</span><span class="o">)</span><span class="bp">.</span><span class="n">last</span> <span class="n">p</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">rcases</span> <span class="n">b</span> <span class="k">with</span> <span class="bp">_|_|</span><span class="n">b</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">sorry</span> <span class="c">/-</span><span class="cm"> This one is trivial, proof omitted -/</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">sorry</span> <span class="c">/-</span><span class="cm"> This one can be done by existing lemmas, proof omitted -/</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">apply</span> <span class="n">nat</span><span class="bp">.</span><span class="n">strong_induction_on</span> <span class="n">m</span><span class="o">,</span> <span class="c1">-- error about failed unification,kind of expected</span>
   <span class="o">}</span>
<span class="kn">end</span>
</code></pre></div>



<a name="274225535"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/motive%20is%20not%20type%20correct/near/274225535" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/motive.20is.20not.20type.20correct.html#274225535">(Mar 05 2022 at 06:58)</a>:</h4>
<p>Some students are asking me what all this "motive is not type correct" stuff is about, and I realise I can't explain it properly. Here's something pretty minimal which I managed to knock up:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">P</span> <span class="n">Q</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">hQ</span> <span class="o">:</span> <span class="n">Q</span><span class="o">)</span> <span class="o">(</span><span class="n">hPQ</span> <span class="o">:</span> <span class="n">P</span> <span class="bp">↔</span> <span class="n">Q</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable</span> <span class="n">P</span><span class="o">]</span> <span class="o">:</span>
<span class="n">ite</span> <span class="n">P</span> <span class="mi">1</span> <span class="mi">2</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="c1">-- rw hPQ, -- motive is not type correct</span>
  <span class="c1">-- `simp_rw [hPQ]` and `simp only [hPQ]` don't work either</span>
  <span class="n">delta</span> <span class="n">ite</span><span class="o">,</span> <span class="c1">-- _inst_1.rec_on (λ (hnc : ¬P), 2) (λ (hc : P), 1) = 1</span>
  <span class="c1">-- oh look, a term `_inst_1` whose type mentions `P`</span>
  <span class="n">unfreezingI</span> <span class="o">{</span><span class="n">cases</span> <span class="n">_inst_1</span> <span class="k">with</span> <span class="n">hfalse</span> <span class="n">htrue</span><span class="o">},</span>
  <span class="o">{</span> <span class="n">dsimp</span><span class="o">,</span> <span class="c1">-- ⊢ 2 = 1 but contradictory hypotheses</span>
    <span class="n">finish</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">dsimp</span><span class="o">,</span> <span class="c1">-- ⊢ 1 = 1</span>
    <span class="n">refl</span><span class="o">,</span>
  <span class="o">}</span>
<span class="kd">end</span>

<span class="c1">-- The previous proof uses propext somewhere. This one uses it</span>
<span class="c1">-- explicitly</span>
<span class="kd">example</span> <span class="o">(</span><span class="n">P</span> <span class="n">Q</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">hQ</span> <span class="o">:</span> <span class="n">Q</span><span class="o">)</span> <span class="o">(</span><span class="n">hPQ</span> <span class="o">:</span> <span class="n">P</span> <span class="bp">↔</span> <span class="n">Q</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable</span> <span class="n">P</span><span class="o">]</span> <span class="o">:</span>
<span class="n">ite</span> <span class="n">P</span> <span class="mi">1</span> <span class="mi">2</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">have</span> <span class="n">hPQ'</span> <span class="o">:=</span> <span class="n">propext</span> <span class="n">hPQ</span><span class="o">,</span> <span class="c1">-- now P and Q are *equal*</span>
  <span class="n">subst</span> <span class="n">hPQ'</span><span class="o">,</span> <span class="c1">-- `hQ : P` lol</span>
  <span class="n">rw</span> <span class="n">if_pos</span> <span class="n">hQ</span><span class="o">,</span> <span class="c1">-- we win</span>
<span class="kd">end</span>
</code></pre></div>
<p>Is it possible to solve every "motive is not type correct" error just by manually taking stuff apart?</p>
<p>I have finally discovered how to search for old threads in a stream. Click on a stream, click "more topics" at the bottom of the list and then search for the topic you want. Doing this I navigated to this old thread above. <span class="user-mention" data-user-id="266440">@Shing Tak Lam</span> these were really nice puzzles. Do we still need any of the below?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">data.nat.digits</span>

<span class="kn">open</span> <span class="n">nat</span>

<span class="c1">--set_option pp.proofs true</span>
<span class="kd">lemma</span> <span class="n">digits_ne_nil_iff_ne_zero</span> <span class="o">(</span><span class="n">b</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">digits</span> <span class="n">b</span> <span class="n">n</span> <span class="bp">≠</span> <span class="o">[]</span> <span class="bp">↔</span> <span class="n">n</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">refine</span> <span class="n">not_congr</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
  <span class="o">{</span> <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">n</span> <span class="k">with</span> <span class="n">d</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">refl</span> <span class="o">},</span>
    <span class="o">{</span> <span class="c1">-- tidy up</span>
      <span class="k">suffices</span> <span class="o">:</span> <span class="n">b.digits</span> <span class="n">d.succ</span> <span class="bp">≠</span> <span class="n">list.nil</span><span class="o">,</span> <span class="kd">by</span> <span class="n">contradiction</span><span class="o">,</span>
      <span class="n">clear</span> <span class="n">h</span><span class="o">,</span>
      <span class="c1">-- next line only works for b&gt;=2 so deal with base cases first</span>
      <span class="n">rcases</span> <span class="n">b</span> <span class="k">with</span> <span class="n">rfl</span> <span class="bp">|</span> <span class="n">rfl</span> <span class="bp">|</span> <span class="n">b</span><span class="o">,</span>
      <span class="o">{</span> <span class="n">rintro</span> <span class="o">⟨</span><span class="n">h</span><span class="o">⟩</span> <span class="o">},</span>
      <span class="o">{</span> <span class="n">rintro</span> <span class="o">⟨</span><span class="n">h</span><span class="o">⟩</span> <span class="o">},</span>
      <span class="o">{</span> <span class="k">suffices</span> <span class="n">h</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">b.succ.succ.digits</span> <span class="n">d.succ</span> <span class="bp">=</span> <span class="n">x</span> <span class="o">::</span> <span class="n">b.succ.succ.digits</span> <span class="n">y</span><span class="o">,</span>
        <span class="o">{</span> <span class="n">rcases</span> <span class="n">h</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩,</span>
          <span class="n">rw</span> <span class="n">h</span><span class="o">,</span>
          <span class="n">rintro</span> <span class="o">⟨⟩</span> <span class="o">},</span>
        <span class="n">refine</span> <span class="o">⟨</span><span class="n">d.succ</span> <span class="bp">%</span> <span class="n">b.succ.succ</span><span class="o">,</span> <span class="n">d.succ</span> <span class="bp">/</span> <span class="n">b.succ.succ</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
        <span class="n">rw</span> <span class="bp">←</span> <span class="n">digits_add</span> <span class="n">b.succ.succ</span> <span class="n">dec_trivial</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="n">mod_lt</span> <span class="n">_</span> <span class="n">dec_trivial</span><span class="o">),</span>
        <span class="o">{</span> <span class="n">congr'</span><span class="o">,</span>
          <span class="n">convert</span> <span class="o">(</span><span class="n">nat.div_add_mod</span> <span class="n">_</span> <span class="n">b.succ.succ</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span> <span class="n">using</span> <span class="mi">1</span><span class="o">,</span>
          <span class="n">ring</span> <span class="o">},</span>
        <span class="o">{</span> <span class="n">by_contra</span> <span class="n">h</span><span class="o">,</span>
          <span class="n">push_neg</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
          <span class="n">rcases</span> <span class="n">h</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">h1</span><span class="o">,</span> <span class="n">h2</span><span class="o">⟩,</span>
          <span class="n">rw</span> <span class="n">nonpos_iff_eq_zero</span> <span class="n">at</span> <span class="n">h1</span> <span class="n">h2</span><span class="o">,</span>
          <span class="n">apply</span> <span class="o">(</span><span class="n">dec_trivial</span> <span class="o">:</span> <span class="n">d.succ</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">),</span>
          <span class="n">rw</span> <span class="bp">←</span> <span class="n">nat.div_add_mod</span> <span class="n">d.succ</span> <span class="n">b.succ.succ</span><span class="o">,</span>
          <span class="n">simp</span> <span class="o">[</span><span class="n">h1</span><span class="o">,</span> <span class="n">h2</span><span class="o">]</span> <span class="o">},</span>
      <span class="o">},</span>
    <span class="o">}</span>
  <span class="o">},</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="o">{</span><span class="n">contextual</span> <span class="o">:=</span> <span class="n">tt</span><span class="o">}</span> <span class="o">}</span>
<span class="kd">end</span>

<span class="c1">--#eval nat.digits 0 4</span>
<span class="c1">--#eval nat.digits_aux 2 dec_trivial 6</span>
<span class="c1">--#check list.last_repeat_succ</span>

<span class="kd">lemma</span> <span class="n">nat.digits_succ</span> <span class="o">(</span><span class="n">b</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">digits</span> <span class="n">b</span> <span class="n">n.succ</span> <span class="bp">≠</span> <span class="o">[]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">digits_ne_nil_iff_ne_zero</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span> <span class="o">(</span><span class="n">nat.succ_ne_zero</span> <span class="n">n</span><span class="o">)</span>

<span class="c1">--#check @one_le_div</span>
<span class="c1">--#where</span>
<span class="c1">--#check le_div_iff_mul_le -- ambiguous overload</span>

<span class="c1">-- couldn't find this lemma in mathlib</span>
<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">nat.one_le_div</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">hb</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="mi">1</span> <span class="bp">≤</span> <span class="n">a</span> <span class="bp">/</span> <span class="n">b</span> <span class="bp">↔</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">a</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="n">nat.le_div_iff_mul_le</span> <span class="n">_</span> <span class="n">_</span> <span class="n">hb</span><span class="o">,</span>
  <span class="n">congr'</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">one_mul</span> <span class="n">b</span><span class="o">,</span>
<span class="kd">end</span>


<span class="c1">--set_option pp.proofs true</span>

<span class="c1">-- b=0,1 special cases dealt with directly;</span>
<span class="c1">-- b&gt;=2 use strong induction and nat.digits_add_two_add_one</span>
<span class="kd">lemma</span> <span class="n">last_digit_succ_ne_zero</span> <span class="o">(</span><span class="n">b</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">digits</span> <span class="n">b</span> <span class="n">n.succ</span><span class="o">)</span><span class="bp">.</span><span class="n">last</span>
  <span class="o">(</span><span class="n">nat.digits_succ</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="c1">-- b = 0</span>
  <span class="n">cases</span> <span class="n">b</span> <span class="k">with</span> <span class="n">b</span><span class="o">,</span> <span class="o">{</span> <span class="n">rintro</span> <span class="o">⟨</span><span class="n">h</span><span class="o">⟩</span> <span class="o">},</span>
  <span class="c1">-- b = 1</span>
  <span class="n">cases</span> <span class="n">b</span> <span class="k">with</span> <span class="n">b</span><span class="o">,</span> <span class="o">{</span> <span class="n">convert</span> <span class="n">one_ne_zero</span><span class="o">,</span>
    <span class="n">swap</span><span class="o">,</span> <span class="n">apply_instance</span><span class="o">,</span> <span class="c1">-- come on Lean -- is that a bug in convert?</span>
    <span class="k">have</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">digits_one</span> <span class="n">n.succ</span><span class="o">,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">h</span><span class="o">,</span> <span class="n">list.last_repeat_succ</span><span class="o">]</span> <span class="o">},</span> <span class="c1">-- worked</span>
  <span class="n">apply</span> <span class="n">nat.strong_induction_on</span> <span class="n">n</span><span class="o">,</span> <span class="n">clear</span> <span class="n">n</span><span class="o">,</span>
  <span class="n">intros</span> <span class="n">n</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">rcases</span> <span class="n">lt_or_le</span> <span class="n">n.succ</span> <span class="n">b.succ.succ</span> <span class="k">with</span> <span class="o">(</span><span class="n">hnb</span> <span class="bp">|</span> <span class="o">(</span><span class="n">hbn</span> <span class="o">:</span> <span class="o">(</span><span class="n">b</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">)</span> <span class="bp">≤</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))),</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">digits_of_lt</span> <span class="n">b.succ.succ</span> <span class="n">n.succ</span> <span class="n">dec_trivial</span> <span class="n">hnb</span><span class="o">]</span> <span class="o">},</span>
  <span class="o">{</span> <span class="c1">-- boss level 2≤b</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">digits_add_two_add_one</span><span class="o">],</span>
    <span class="k">have</span> <span class="n">foo</span> <span class="o">:</span> <span class="mi">1</span> <span class="bp">≤</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">/</span> <span class="o">(</span><span class="n">b</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">),</span>
    <span class="o">{</span> <span class="n">rwa</span> <span class="n">nat.one_le_div</span> <span class="o">(</span><span class="k">show</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">b</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">,</span> <span class="k">from</span> <span class="n">dec_trivial</span><span class="o">)</span> <span class="o">},</span>
    <span class="n">rw</span> <span class="n">list.last_cons</span><span class="o">,</span>
    <span class="n">swap</span><span class="o">,</span> <span class="c1">-- remove easier leg first</span>
    <span class="o">{</span> <span class="n">convert</span> <span class="n">nat.digits_succ</span> <span class="o">(</span><span class="n">b</span><span class="bp">+</span><span class="mi">2</span><span class="o">)</span> <span class="o">((</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">/</span> <span class="o">(</span><span class="n">b</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">)</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">),</span>
      <span class="n">exact</span> <span class="o">(</span><span class="n">nat.sub_add_cancel</span> <span class="n">foo</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span> <span class="o">},</span>
    <span class="o">{</span> <span class="c1">-- use induction hypothesis</span>
      <span class="n">convert</span> <span class="n">h</span> <span class="o">((</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">/</span> <span class="o">(</span><span class="n">b</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">)</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">)</span> <span class="n">_</span><span class="o">,</span>
      <span class="o">{</span> <span class="n">exact</span> <span class="o">(</span><span class="n">nat.sub_add_cancel</span> <span class="n">foo</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span> <span class="o">},</span>
      <span class="n">refine</span> <span class="n">lt_of_lt_of_le</span> <span class="o">(</span><span class="n">nat.sub_lt</span> <span class="n">foo</span> <span class="n">zero_lt_one</span><span class="o">)</span> <span class="n">_</span><span class="o">,</span>
      <span class="n">apply</span> <span class="n">nat.div_le_of_le_mul'</span><span class="o">,</span>
      <span class="n">nlinarith</span> <span class="o">}</span> <span class="o">}</span> <span class="c1">-- wow,</span>
<span class="kd">end</span>
</code></pre></div>
<p>Again I could always wriggle out of the motive is not type correct thing by using <code>change</code> to change nasty <code>eq.rec</code> or whatever embedded proofs into nicer ones.</p>



<a name="274261555"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/motive%20is%20not%20type%20correct/near/274261555" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/motive.20is.20not.20type.20correct.html#274261555">(Mar 05 2022 at 19:49)</a>:</h4>
<p>The motive is whatever you're left with once you take out every occurrence of the term you want to rewrite. So if you want to rewrite <code>P</code> in <code>@ite P (_inst : decidable P) 1 2</code>, the motive looks something like <code>@ite ? (_inst : decidable ?) 1 2</code>. And <code>_inst : decidable ?</code> is not type-correct if <code>?</code> is a free variable, so you get a type error.</p>



<a name="274261658"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/motive%20is%20not%20type%20correct/near/274261658" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/motive.20is.20not.20type.20correct.html#274261658">(Mar 05 2022 at 19:51)</a>:</h4>
<p>Similarly for the induction, the motive is what you're left with once you take out the induction variable.</p>



<a name="274261751"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/motive%20is%20not%20type%20correct/near/274261751" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/motive.20is.20not.20type.20correct.html#274261751">(Mar 05 2022 at 19:53)</a>:</h4>
<p>(They are really the same thing since rewriting is just induction on <code>eq</code>.)</p>



<a name="274261881"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/motive%20is%20not%20type%20correct/near/274261881" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/motive.20is.20not.20type.20correct.html#274261881">(Mar 05 2022 at 19:56)</a>:</h4>
<p>So this error really is a consequence of dependent types: the term that you are trying to rewrite appears in the type of some other subterm. Sometimes you can fix it by providing a better motive along the lines of <code>refine @nat.induction_on (λ k, some_predicate_on k (but_not n)) n _ _</code> (or using the <code>occurrences</code> option of <code>rw</code>). Other times you can get rid of the dependent type entirely.</p>



<a name="274262631"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/motive%20is%20not%20type%20correct/near/274262631" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/motive.20is.20not.20type.20correct.html#274262631">(Mar 05 2022 at 20:12)</a>:</h4>
<p>Right -- I saw examples of this yesterday. The dependent type was embedded in a proof and I could supply another much simpler proof of the same statement, insert it with <code>change</code> and then the rewrite would work</p>



<a name="274297857"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/motive%20is%20not%20type%20correct/near/274297857" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alexander Bentkamp <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/motive.20is.20not.20type.20correct.html#274297857">(Mar 06 2022 at 10:21)</a>:</h4>
<p>It seems that the motive could always be made type-correct by inserting <code>cast</code>s in the right places? Maybe that could even be done automatically?</p>



<a name="274303712"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/motive%20is%20not%20type%20correct/near/274303712" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/motive.20is.20not.20type.20correct.html#274303712">(Mar 06 2022 at 12:37)</a>:</h4>
<p>This is done automatically, by <code>simp</code></p>



<a name="274361513"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/motive%20is%20not%20type%20correct/near/274361513" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Fabian Glöckle <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/motive.20is.20not.20type.20correct.html#274361513">(Mar 07 2022 at 08:31)</a>:</h4>
<p>Which leaves the question why <code>simp</code> does not always solve "motive not type correct" situations.<br>
Or does it?</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/Projection.20on.20inductive.20types.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Projection.20on.20inductive.20types.html">Projection on inductive types</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="270458510"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Projection%20on%20inductive%20types/near/270458510" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> AdLucem <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Projection.20on.20inductive.20types.html#270458510">(Feb 02 2022 at 21:13)</a>:</h4>
<p>Hello, how does one define projection on inductive types? For eg:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">atom</span>  <span class="o">:</span> <span class="kt">Prop</span>
  <span class="bp">|</span> <span class="n">intro</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">atom</span>
</code></pre></div>
<p>Given this piece of code, I want to define a function on <code>atom</code> that will return <code>n</code>.</p>



<a name="270459146"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Projection%20on%20inductive%20types/near/270459146" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Projection.20on.20inductive.20types.html#270459146">(Feb 02 2022 at 21:18)</a>:</h4>
<p>How could it? You need to <strong>provide</strong> <code>n</code> to make it a Prop, and once ypou have a Prop you can't expect to retrieve what you put in (except that in that case one of the two <code>n</code> is possible from the type).</p>



<a name="270459180"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Projection%20on%20inductive%20types/near/270459180" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Projection.20on.20inductive.20types.html#270459180">(Feb 02 2022 at 21:18)</a>:</h4>
<p>Also, did you mean to have to have two separate <code>n</code>?</p>



<a name="270459554"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Projection%20on%20inductive%20types/near/270459554" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Projection.20on.20inductive.20types.html#270459554">(Feb 02 2022 at 21:21)</a>:</h4>
<p>Probably, you actually want some other type. Could you please post an <a href="https://leanprover-community.github.io/mwe.html">#mwe</a> with the way you are going to use this type?</p>



<a name="270459567"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Projection%20on%20inductive%20types/near/270459567" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> AdLucem <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Projection.20on.20inductive.20types.html#270459567">(Feb 02 2022 at 21:21)</a>:</h4>
<p>Oh no, that was a mistake!<br>
Okay, so I can't retrieve <code>n</code> from the <code>Prop</code></p>



<a name="270459621"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Projection%20on%20inductive%20types/near/270459621" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Projection.20on.20inductive.20types.html#270459621">(Feb 02 2022 at 21:21)</a>:</h4>
<p>(Did you really want to make it a <code>Prop</code>? It seems weird with the name <code>atom</code>)</p>



<a name="270459637"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Projection%20on%20inductive%20types/near/270459637" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Johnson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Projection.20on.20inductive.20types.html#270459637">(Feb 02 2022 at 21:22)</a>:</h4>
<p>Note that <code>atom</code> parameter <code>n</code> is unrelated to <code>atom.intro</code> parameter <code>n</code>. Which <code>n</code> do you want to extract? You probably want this instead:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">atom</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">intro</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">atom</span> <span class="n">n</span>

<span class="kd">def</span> <span class="n">atom.n</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">atom</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="n">n</span>
</code></pre></div>
<p>Or maybe this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">atom</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">intro</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">atom</span>

<span class="kd">def</span> <span class="n">atom.n</span> <span class="o">:</span> <span class="n">atom</span> <span class="bp">→</span> <span class="n">ℕ</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">atom.intro</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="n">n</span>
</code></pre></div>
<p>In general, you cannot extract parameters of proposition constructors (because of proof irrelevance).</p>



<a name="270460009"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Projection%20on%20inductive%20types/near/270460009" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> AdLucem <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Projection.20on.20inductive.20types.html#270460009">(Feb 02 2022 at 21:24)</a>:</h4>
<p><span class="user-mention" data-user-id="214703">@Yury G. Kudryashov</span> I want to define equality over <code>atom</code> -</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">eq</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">atom</span><span class="o">)</span> <span class="o">:</span> <span class="n">bool</span>
</code></pre></div>
<p>So I need to get <code>n</code> for testing equality</p>



<a name="270460060"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Projection%20on%20inductive%20types/near/270460060" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vincent Beffara <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Projection.20on.20inductive.20types.html#270460060">(Feb 02 2022 at 21:24)</a>:</h4>
<p>If you make it <code>Type</code> instead of <code>Prop</code> then you can:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">atom</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">intro</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">atom</span>

<span class="kd">def</span> <span class="n">extract</span> <span class="o">:</span> <span class="n">atom</span> <span class="bp">→</span> <span class="n">ℕ</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">atom.intro</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="n">n</span>
</code></pre></div>



<a name="270460135"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Projection%20on%20inductive%20types/near/270460135" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Projection.20on.20inductive.20types.html#270460135">(Feb 02 2022 at 21:25)</a>:</h4>
<p>But in this case you can just use</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">atom</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span>
</code></pre></div>



<a name="270460319"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Projection%20on%20inductive%20types/near/270460319" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Projection.20on.20inductive.20types.html#270460319">(Feb 02 2022 at 21:26)</a>:</h4>
<p>Or <code>nat</code> <span aria-label="stuck out tongue wink" class="emoji emoji-1f61c" role="img" title="stuck out tongue wink">:stuck_out_tongue_wink:</span></p>



<a name="270460457"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Projection%20on%20inductive%20types/near/270460457" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> AdLucem <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Projection.20on.20inductive.20types.html#270460457">(Feb 02 2022 at 21:27)</a>:</h4>
<p><span class="user-mention" data-user-id="456794">@Patrick Johnson</span> wait you can pattern match that way? that is useful thank you!<br>
 (ref: <code>def atom.n {n : ℕ} (a : atom n) := n</code>)</p>



<a name="270460669"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Projection%20on%20inductive%20types/near/270460669" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> AdLucem <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Projection.20on.20inductive.20types.html#270460669">(Feb 02 2022 at 21:28)</a>:</h4>
<p><span class="user-mention" data-user-id="214703">@Yury G. Kudryashov</span> No, I need to be able to use <code>atom</code> as a constructor for type <code>Prop</code>. i.e: <code>atom &lt;some number&gt; :: Prop</code></p>



<a name="270460787"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Projection%20on%20inductive%20types/near/270460787" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Projection.20on.20inductive.20types.html#270460787">(Feb 02 2022 at 21:29)</a>:</h4>
<p>This sounds like an <a href="https://en.wikipedia.org/wiki/XY_problem">#xy</a> problem. Can you give us the greater picture?</p>



<a name="270461186"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Projection%20on%20inductive%20types/near/270461186" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> AdLucem <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Projection.20on.20inductive.20types.html#270461186">(Feb 02 2022 at 21:32)</a>:</h4>
<p>Greater picture is that I'm building propositional logic in lean ( _not_ using lean's existinginfrastructure since this is for a teaching exercise).  I want to be able to build "atoms" - propositional variables, essentially- and then build propositions out of them. Can I actually post the entire code that I'm trying? (I posted a simplified version of the problem- essentially that I defined <code>atom</code> as an inductive type and needed to get a struct-type <code>projection</code> for it)</p>



<a name="270461427"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Projection%20on%20inductive%20types/near/270461427" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Projection.20on.20inductive.20types.html#270461427">(Feb 02 2022 at 21:34)</a>:</h4>
<p>Yeah sure, go on! Are you one of Kevin's students by any chance?</p>



<a name="270461790"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Projection%20on%20inductive%20types/near/270461790" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Projection.20on.20inductive.20types.html#270461790">(Feb 02 2022 at 21:36)</a>:</h4>
<p>You definitely can post the code.</p>



<a name="270461825"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Projection%20on%20inductive%20types/near/270461825" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> AdLucem <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Projection.20on.20inductive.20types.html#270461825">(Feb 02 2022 at 21:36)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">var</span> <span class="o">:=</span>
  <span class="n">mk</span> <span class="o">::</span> <span class="o">(</span><span class="n">idx</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span>

<span class="kd">notation</span> <span class="bp">`</span><span class="n">Prp</span><span class="bp">`</span> <span class="o">:=</span> <span class="kt">Sort</span> <span class="mi">1</span>

<span class="kd">inductive</span> <span class="n">atom</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">var</span><span class="o">)</span> <span class="o">:</span> <span class="n">Prp</span>
  <span class="bp">|</span> <span class="n">intro</span> <span class="o">:</span> <span class="n">var</span> <span class="bp">-&gt;</span> <span class="n">atom</span>


<span class="kd">def</span> <span class="n">p1</span> <span class="o">:=</span> <span class="n">atom</span> <span class="o">(</span><span class="n">var.mk</span> <span class="mi">1</span><span class="o">)</span>
<span class="kd">def</span> <span class="n">p2</span> <span class="o">:=</span> <span class="n">atom</span> <span class="o">(</span><span class="n">var.mk</span> <span class="mi">2</span><span class="o">)</span>
<span class="kd">def</span> <span class="n">p3</span> <span class="o">:=</span> <span class="n">atom</span> <span class="o">(</span><span class="n">var.mk</span> <span class="mi">3</span><span class="o">)</span>

<span class="k">#check</span> <span class="n">p1</span>
</code></pre></div>
<p>The intention is: to define the 'fundamental' of propositional logic as a propositional variable (so as to not go straight to semantics, like lean does with <code>true</code> and <code>false</code>) and then define a Proposition as combinations of type variables- so as you can see, I define the homemade <code>Prp</code> (Proposition) in place of <code>Type</code>.</p>



<a name="270461921"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Projection%20on%20inductive%20types/near/270461921" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> AdLucem <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Projection.20on.20inductive.20types.html#270461921">(Feb 02 2022 at 21:37)</a>:</h4>
<p><span class="user-mention silent" data-user-id="387244">Yaël Dillies</span> <a href="#narrow/stream/113488-general/topic/Projection.20on.20inductive.20types/near/270461427">said</a>:</p>
<blockquote>
<p>Yeah sure, go on! Are you one of Kevin's students by any chance?</p>
</blockquote>
<p>ah, no? I'm working with a prof who is introducing propositional logic with lean.</p>



<a name="270461954"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Projection%20on%20inductive%20types/near/270461954" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Projection.20on.20inductive.20types.html#270461954">(Feb 02 2022 at 21:37)</a>:</h4>
<p>What is the mathematical meaning of <code>atom v</code>?</p>



<a name="270461963"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Projection%20on%20inductive%20types/near/270461963" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Projection.20on.20inductive.20types.html#270461963">(Feb 02 2022 at 21:37)</a>:</h4>
<p>Oh, who is it? Altenkirch?</p>



<a name="270462079"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Projection%20on%20inductive%20types/near/270462079" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Projection.20on.20inductive.20types.html#270462079">(Feb 02 2022 at 21:38)</a>:</h4>
<p>Can you write "pen and paper" definitions for <code>atom</code>, <code>var</code>, etc?</p>



<a name="270462104"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Projection%20on%20inductive%20types/near/270462104" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> AdLucem <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Projection.20on.20inductive.20types.html#270462104">(Feb 02 2022 at 21:39)</a>:</h4>
<p><span class="user-mention silent" data-user-id="214703">Yury G. Kudryashov</span> <a href="#narrow/stream/113488-general/topic/Projection.20on.20inductive.20types/near/270461954">said</a>:</p>
<blockquote>
<p>What is the mathematical meaning of <code>atom v</code>?</p>
</blockquote>
<p><code>Atom v</code> - atomic propositional variable <code>v</code></p>



<a name="270462143"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Projection%20on%20inductive%20types/near/270462143" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Projection.20on.20inductive.20types.html#270462143">(Feb 02 2022 at 21:39)</a>:</h4>
<p>How is it different from <code>v : var</code>?</p>



<a name="270462271"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Projection%20on%20inductive%20types/near/270462271" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Projection.20on.20inductive.20types.html#270462271">(Feb 02 2022 at 21:40)</a>:</h4>
<p>If <code>Prp = Sort 1</code> (equivalently, <code>Type</code>), then you can extract information from inductive structures in <code>Prp</code>.</p>



<a name="270462348"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Projection%20on%20inductive%20types/near/270462348" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> AdLucem <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Projection.20on.20inductive.20types.html#270462348">(Feb 02 2022 at 21:40)</a>:</h4>
<p><span class="user-mention silent" data-user-id="214703">Yury G. Kudryashov</span> <a href="#narrow/stream/113488-general/topic/Projection.20on.20inductive.20types/near/270462079">said</a>:</p>
<blockquote>
<p>Can you write "pen and paper" definitions for <code>atom</code>, <code>var</code>, etc?</p>
</blockquote>
<p>var : set of variables v1, v2... </p>
<p>p ∈ Var<br>
-------  VAR-INTRO<br>
p ∈ Exp</p>



<a name="270462572"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Projection%20on%20inductive%20types/near/270462572" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Projection.20on.20inductive.20types.html#270462572">(Feb 02 2022 at 21:42)</a>:</h4>
<p>What are <code>Var</code> and <code>Exp</code> here?</p>



<a name="270462580"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Projection%20on%20inductive%20types/near/270462580" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> AdLucem <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Projection.20on.20inductive.20types.html#270462580">(Feb 02 2022 at 21:42)</a>:</h4>
<p><span class="user-mention silent" data-user-id="387244">Yaël Dillies</span> <a href="#narrow/stream/113488-general/topic/Projection.20on.20inductive.20types/near/270461963">said</a>:</p>
<blockquote>
<p>Oh, who is it? Altenkirch?</p>
</blockquote>
<p>Hmm no, I'm in a college called IIIT-H. Although- I think my professor might appreciate course notes/resources from other professors teaching in lean!</p>



<a name="270462629"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Projection%20on%20inductive%20types/near/270462629" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Projection.20on.20inductive.20types.html#270462629">(Feb 02 2022 at 21:42)</a>:</h4>
<p>And I meant <strong>actual textbook-style definitions</strong>.</p>



<a name="270462705"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Projection%20on%20inductive%20types/near/270462705" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Projection.20on.20inductive.20types.html#270462705">(Feb 02 2022 at 21:43)</a>:</h4>
<p>Or at least very readable explanations.</p>



<a name="270462747"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Projection%20on%20inductive%20types/near/270462747" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> AdLucem <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Projection.20on.20inductive.20types.html#270462747">(Feb 02 2022 at 21:43)</a>:</h4>
<p><span class="user-mention silent" data-user-id="214703">Yury G. Kudryashov</span> <a href="#narrow/stream/113488-general/topic/Projection.20on.20inductive.20types/near/270462572">said</a>:</p>
<blockquote>
<p>What are <code>Var</code> and <code>Exp</code> here?</p>
</blockquote>
<p>Var : set of propositional variables<br>
Exp: set of expressions in the language of propositional logic</p>
<p>I'm sort of writing an interpreter for a propositional logic language, so like- <code>Var</code> is the (only) atomic value in the language, Exp is the set of all expressions in the language</p>



<a name="270462854"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Projection%20on%20inductive%20types/near/270462854" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Projection.20on.20inductive.20types.html#270462854">(Feb 02 2022 at 21:44)</a>:</h4>
<p>Why do you also need <code>atom</code>?</p>



<a name="270462974"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Projection%20on%20inductive%20types/near/270462974" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> AdLucem <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Projection.20on.20inductive.20types.html#270462974">(Feb 02 2022 at 21:45)</a>:</h4>
<p><span class="user-mention silent" data-user-id="214703">Yury G. Kudryashov</span> <a href="#narrow/stream/113488-general/topic/Projection.20on.20inductive.20types/near/270462629">said</a>:</p>
<blockquote>
<p>And I meant <strong>actual textbook-style definitions</strong>.</p>
</blockquote>
<p>Ah I'm sorry! Thing is we construct Exp inductively, so a mathematical definition for <code>Exp</code> will be:</p>
<p><code>Exp := Atom | not Exp | Exp and Exp | Exp or Exp | Exp implies Exp</code> (and, or, not etc. being operators)<br>
and <code>Atom := Atom var</code></p>



<a name="270462994"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Projection%20on%20inductive%20types/near/270462994" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Projection.20on.20inductive.20types.html#270462994">(Feb 02 2022 at 21:45)</a>:</h4>
<p>When <code>and</code>, <code>or</code> etc enter the scene?</p>



<a name="270463082"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Projection%20on%20inductive%20types/near/270463082" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Projection.20on.20inductive.20types.html#270463082">(Feb 02 2022 at 21:46)</a>:</h4>
<p>Ah, OK</p>



<a name="270463295"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Projection%20on%20inductive%20types/near/270463295" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> AdLucem <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Projection.20on.20inductive.20types.html#270463295">(Feb 02 2022 at 21:47)</a>:</h4>
<p><span class="user-mention silent" data-user-id="214703">Yury G. Kudryashov</span> <a href="#narrow/stream/113488-general/topic/Projection.20on.20inductive.20types/near/270462271">said</a>:</p>
<blockquote>
<p>If <code>Prp = Sort 1</code> (equivalently, <code>Type</code>), then you can extract information from inductive structures in <code>Prp</code>.</p>
</blockquote>
<p>what do you mean by extracting information from inductive structures in <code>Prp</code> ?</p>



<a name="270463300"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Projection%20on%20inductive%20types/near/270463300" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Projection.20on.20inductive.20types.html#270463300">(Feb 02 2022 at 21:47)</a>:</h4>
<p>So, you actually need something like</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">namespace</span> <span class="n">hidden</span>

<span class="kd">inductive</span> <span class="n">expr</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">atom</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">var</span><span class="o">)</span> <span class="o">:</span> <span class="n">expr</span>
<span class="bp">|</span> <span class="n">not</span> <span class="o">:</span> <span class="n">expr</span> <span class="bp">→</span> <span class="n">expr</span>
<span class="bp">|</span> <span class="n">and</span> <span class="o">:</span> <span class="n">expr</span> <span class="bp">→</span> <span class="n">expr</span> <span class="bp">→</span> <span class="n">expr</span>
<span class="bp">|</span> <span class="n">or</span> <span class="o">:</span> <span class="n">expr</span> <span class="bp">→</span> <span class="n">expr</span> <span class="bp">→</span> <span class="n">expr</span>
</code></pre></div>



<a name="270463369"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Projection%20on%20inductive%20types/near/270463369" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Projection.20on.20inductive.20types.html#270463369">(Feb 02 2022 at 21:48)</a>:</h4>
<p>I mean that you can <code>match</code> on them.</p>



<a name="270463389"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Projection%20on%20inductive%20types/near/270463389" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Projection.20on.20inductive.20types.html#270463389">(Feb 02 2022 at 21:48)</a>:</h4>
<p>Or use equation compiler.</p>



<a name="270463408"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Projection%20on%20inductive%20types/near/270463408" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Projection.20on.20inductive.20types.html#270463408">(Feb 02 2022 at 21:48)</a>:</h4>
<p>Any two proofs of the same proposition are definitionally equal in Lean.</p>



<a name="270463636"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Projection%20on%20inductive%20types/near/270463636" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Projection.20on.20inductive.20types.html#270463636">(Feb 02 2022 at 21:50)</a>:</h4>
<p>So, once you have <code>(p : Prop) (h : p)</code>, you can't extract information from <code>h</code>.</p>



<a name="270463777"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Projection%20on%20inductive%20types/near/270463777" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> AdLucem <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Projection.20on.20inductive.20types.html#270463777">(Feb 02 2022 at 21:51)</a>:</h4>
<p>I did try defining <code>expr</code> as an inductive type, yes! Since this is for a teaching exercise, I was trying to see if this was an alternate method of doing the same thing:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">not</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">Prp</span><span class="o">)</span> <span class="o">:</span> <span class="n">Prp</span>
<span class="bp">|</span> <span class="n">intro</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">-&gt;</span> <span class="n">not</span>

<span class="kd">inductive</span> <span class="n">and</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">Prp</span><span class="o">)</span> <span class="o">:</span> <span class="n">Prp</span>
<span class="bp">|</span> <span class="n">intro</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">-&gt;</span> <span class="n">q</span> <span class="bp">-&gt;</span> <span class="n">and</span>

<span class="kd">inductive</span> <span class="n">or</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">Prp</span><span class="o">)</span> <span class="o">:</span> <span class="n">Prp</span>
<span class="bp">|</span> <span class="n">intro</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">-&gt;</span> <span class="n">q</span> <span class="bp">-&gt;</span> <span class="n">or</span>

<span class="kd">inductive</span> <span class="n">impl</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">Prp</span><span class="o">)</span> <span class="o">:</span> <span class="n">Prp</span>
<span class="bp">|</span> <span class="n">intro</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">-&gt;</span> <span class="n">q</span> <span class="bp">-&gt;</span> <span class="n">impl</span>
</code></pre></div>



<a name="270463899"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Projection%20on%20inductive%20types/near/270463899" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> AdLucem <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Projection.20on.20inductive.20types.html#270463899">(Feb 02 2022 at 21:52)</a>:</h4>
<p><span class="user-mention silent" data-user-id="214703">Yury G. Kudryashov</span> <a href="#narrow/stream/113488-general/topic/Projection.20on.20inductive.20types/near/270463408">said</a>:</p>
<blockquote>
<p>Any two proofs of the same proposition are definitionally equal in Lean.</p>
</blockquote>
<p>Oh that explains why you can't extract info from things of type <code>Prop</code>- thanks!</p>



<a name="270464021"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Projection%20on%20inductive%20types/near/270464021" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> AdLucem <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Projection.20on.20inductive.20types.html#270464021">(Feb 02 2022 at 21:53)</a>:</h4>
<p><span class="user-mention silent" data-user-id="214703">Yury G. Kudryashov</span> <a href="#narrow/stream/113488-general/topic/Projection.20on.20inductive.20types/near/270463389">said</a>:</p>
<blockquote>
<p>Or use equation compiler.</p>
</blockquote>
<p>hmm is there any way to see what equation compiler does? documentation etc..</p>



<a name="270464070"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Projection%20on%20inductive%20types/near/270464070" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> AdLucem <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Projection.20on.20inductive.20types.html#270464070">(Feb 02 2022 at 21:53)</a>:</h4>
<p><span class="user-mention silent" data-user-id="214703">Yury G. Kudryashov</span> <a href="#narrow/stream/113488-general/topic/Projection.20on.20inductive.20types/near/270463369">said</a>:</p>
<blockquote>
<p>I mean that you can <code>match</code> on them.</p>
</blockquote>
<p>I will try this, thanks</p>



<a name="270471755"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Projection%20on%20inductive%20types/near/270471755" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Projection.20on.20inductive.20types.html#270471755">(Feb 02 2022 at 22:52)</a>:</h4>
<p>This is not the same thing</p>



<a name="270471792"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Projection%20on%20inductive%20types/near/270471792" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Projection.20on.20inductive.20types.html#270471792">(Feb 02 2022 at 22:53)</a>:</h4>
<p>Because you can't use two operations in the same formula</p>



<a name="270472823"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Projection%20on%20inductive%20types/near/270472823" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Projection.20on.20inductive.20types.html#270472823">(Feb 02 2022 at 23:01)</a>:</h4>
<p>There is potential for confusion here because you are trying to define a type of "propositions" while Lean also has a different notion that it calls propositions.</p>



<a name="270472909"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Projection%20on%20inductive%20types/near/270472909" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Projection.20on.20inductive.20types.html#270472909">(Feb 02 2022 at 23:02)</a>:</h4>
<p>As far as Lean is concerned, your propositional formulas might as well be any other inductive type such as <code>list</code>.</p>



<a name="270476908"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Projection%20on%20inductive%20types/near/270476908" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Projection.20on.20inductive.20types.html#270476908">(Feb 02 2022 at 23:40)</a>:</h4>
<p>If you want to define formulas etc. before you decide what operations are allowed, then you can use this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">var</span> <span class="o">:=</span> <span class="n">ℕ</span>

<span class="kd">structure</span> <span class="n">operation</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">arity</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span>
<span class="o">(</span><span class="n">ev</span> <span class="o">:</span> <span class="n">vector</span> <span class="n">bool</span> <span class="n">arity</span> <span class="bp">→</span> <span class="n">bool</span><span class="o">)</span>

<span class="kd">inductive</span> <span class="n">preexpr</span> <span class="o">(</span><span class="n">ops</span> <span class="o">:</span> <span class="n">set</span> <span class="n">operation</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">atom</span> <span class="o">:</span> <span class="n">var</span> <span class="bp">→</span> <span class="n">preexpr</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="n">op</span> <span class="o">(</span><span class="n">o</span> <span class="o">:</span> <span class="n">operation</span><span class="o">)</span> <span class="o">(</span><span class="n">ho</span> <span class="o">:</span> <span class="n">o</span> <span class="bp">∈</span> <span class="n">ops</span><span class="o">)</span> <span class="o">:</span> <span class="n">preexpr</span> <span class="n">o.arity</span>
<span class="bp">|</span> <span class="n">apply</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">preexpr</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">preexpr</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span> <span class="n">preexpr</span> <span class="n">n</span>

<span class="c1">-- Exercise: fill in the blanks</span>
<span class="kd">def</span> <span class="n">preexpr.eval</span> <span class="o">{</span><span class="n">ops</span> <span class="o">:</span> <span class="n">set</span> <span class="n">operation</span><span class="o">}</span> <span class="o">(</span><span class="n">ev</span> <span class="o">:</span> <span class="n">var</span> <span class="bp">→</span> <span class="n">bool</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">Π</span> <span class="n">n</span><span class="o">,</span> <span class="n">preexpr</span> <span class="n">ops</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">vector</span> <span class="n">bool</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">bool</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">(</span><span class="n">preexpr.atom</span> <span class="n">v</span><span class="o">)</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">_</span>
<span class="bp">|</span> <span class="n">_</span> <span class="o">(</span><span class="n">preexpr.op</span> <span class="n">o</span> <span class="n">ho</span><span class="o">)</span> <span class="n">f</span> <span class="o">:=</span> <span class="n">_</span>
<span class="bp">|</span> <span class="n">n</span> <span class="o">(</span><span class="n">preexpr.apply</span> <span class="n">f</span> <span class="n">e</span><span class="o">)</span> <span class="n">g</span> <span class="o">:=</span> <span class="n">_</span>
</code></pre></div>



<a name="270477771"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Projection%20on%20inductive%20types/near/270477771" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Projection.20on.20inductive.20types.html#270477771">(Feb 02 2022 at 23:49)</a>:</h4>
<p>UPD: in the last definition you need to tell Lean that it is decreasing on the second argument, not on the first one. I don't remember how to do it.</p>



<a name="270479769"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Projection%20on%20inductive%20types/near/270479769" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Projection.20on.20inductive.20types.html#270479769">(Feb 03 2022 at 00:10)</a>:</h4>
<blockquote>
<p>hmm is there any way to see what equation compiler does? documentation etc..</p>
</blockquote>
<p>Chapters 7 and 8 of <a href="https://leanprover.github.io/theorem_proving_in_lean/">#tpil</a> talk about inductive types and the equation compiler.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
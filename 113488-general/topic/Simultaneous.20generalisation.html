---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/Simultaneous.20generalisation.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Simultaneous.20generalisation.html">Simultaneous generalisation</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="199514716"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Simultaneous%20generalisation/near/199514716" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jannis Limperg <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Simultaneous.20generalisation.html#199514716">(Jun 02 2020 at 16:04)</a>:</h4>
<p>I need a tactic that works like <code>generalize</code>, but for multiple terms at once. Does this already exist?</p>
<p>Background: Generalising over multiple terms at once is not the same thing as generalising one after the other. Consider the following (slightly contrived) example:</p>
<div class="codehilite"><pre><span></span><code><span class="n">universes</span> <span class="n">u</span>

<span class="kn">inductive</span> <span class="n">Vec</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="n">Sort</span> <span class="n">u</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">Sort</span> <span class="o">(</span><span class="n">max</span> <span class="mi">1</span> <span class="n">u</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">nil</span> <span class="o">:</span> <span class="n">Vec</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="n">cons</span> <span class="o">{</span><span class="n">n</span><span class="o">}</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">Vec</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">Vec</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>

<span class="kn">namespace</span> <span class="n">Vec</span>

<span class="kn">inductive</span> <span class="n">eq</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span> <span class="n">m</span><span class="o">,</span> <span class="n">Vec</span> <span class="n">α</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">Vec</span> <span class="n">α</span> <span class="n">m</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">nil</span> <span class="o">:</span> <span class="n">eq</span> <span class="mi">0</span> <span class="mi">0</span> <span class="n">nil</span> <span class="n">nil</span>
<span class="bp">|</span> <span class="n">cons</span> <span class="o">{</span><span class="n">n</span> <span class="n">m</span><span class="o">}</span> <span class="o">{</span><span class="n">xs</span> <span class="o">:</span> <span class="n">Vec</span> <span class="n">α</span> <span class="n">n</span><span class="o">}</span> <span class="o">{</span><span class="n">ys</span> <span class="o">:</span> <span class="n">Vec</span> <span class="n">α</span> <span class="n">m</span><span class="o">}</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="bp">→</span>
  <span class="n">eq</span> <span class="n">n</span> <span class="n">m</span> <span class="n">xs</span> <span class="n">ys</span> <span class="bp">→</span>
  <span class="n">eq</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">cons</span> <span class="n">x</span> <span class="n">xs</span><span class="o">)</span> <span class="o">(</span><span class="n">cons</span> <span class="n">y</span> <span class="n">ys</span><span class="o">)</span>

<span class="kn">end</span> <span class="n">Vec</span>

<span class="kn">example</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="n">Sort</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="n">n</span> <span class="n">m</span><span class="o">}</span> <span class="o">{</span><span class="n">xs</span> <span class="o">:</span> <span class="n">Vec</span> <span class="n">α</span> <span class="n">n</span><span class="o">}</span> <span class="o">{</span><span class="n">ys</span> <span class="o">:</span> <span class="n">Vec</span> <span class="n">α</span> <span class="n">m</span><span class="o">}</span>
  <span class="o">:</span> <span class="n">Vec</span><span class="bp">.</span><span class="n">eq</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">Vec</span><span class="bp">.</span><span class="n">cons</span> <span class="n">x</span> <span class="n">xs</span><span class="o">)</span> <span class="o">(</span><span class="n">Vec</span><span class="bp">.</span><span class="n">cons</span> <span class="n">y</span> <span class="n">ys</span><span class="o">)</span>
  <span class="bp">→</span> <span class="n">Vec</span><span class="bp">.</span><span class="n">eq</span> <span class="n">n</span> <span class="n">m</span> <span class="n">xs</span> <span class="n">ys</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
  <span class="c1">-- generalize eq : n + 1 = i₁,         -- The `n + 1`         in h is not generalised.</span>
  <span class="c1">-- generalize eq : Vec.cons x xs = i₁, -- The `Vec.cons x xs` in h is not generalised.</span>
  <span class="n">refine</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">i₁</span> <span class="n">i₂</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">i₃</span> <span class="o">:</span> <span class="n">Vec</span> <span class="n">α</span> <span class="n">i₁</span><span class="o">)</span> <span class="o">(</span><span class="n">i₄</span> <span class="o">:</span> <span class="n">Vec</span> <span class="n">α</span> <span class="n">i₂</span><span class="o">)</span>
      <span class="o">(</span><span class="n">i₁_eq</span> <span class="o">:</span> <span class="n">i₁</span> <span class="bp">=</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">i₂_eq</span> <span class="o">:</span> <span class="n">i₂</span> <span class="bp">=</span> <span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">i₃_eq</span> <span class="o">:</span> <span class="n">i₃</span> <span class="bp">==</span> <span class="n">Vec</span><span class="bp">.</span><span class="n">cons</span> <span class="n">x</span> <span class="n">xs</span><span class="o">)</span>
      <span class="o">(</span><span class="n">i₄_eq</span> <span class="o">:</span> <span class="n">i₄</span> <span class="bp">==</span> <span class="n">Vec</span><span class="bp">.</span><span class="n">cons</span> <span class="n">y</span> <span class="n">ys</span><span class="o">)</span> <span class="o">(</span><span class="n">h&#39;</span> <span class="o">:</span> <span class="n">Vec</span><span class="bp">.</span><span class="n">eq</span> <span class="n">i₁</span> <span class="n">i₂</span> <span class="n">i₃</span> <span class="n">i₄</span><span class="o">),</span>
      <span class="o">(</span><span class="bp">_</span> <span class="o">:</span> <span class="n">Vec</span><span class="bp">.</span><span class="n">eq</span> <span class="n">n</span> <span class="n">m</span> <span class="n">xs</span> <span class="n">ys</span><span class="o">))</span>
    <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">Vec</span><span class="bp">.</span><span class="n">cons</span> <span class="n">x</span> <span class="n">xs</span><span class="o">)</span> <span class="o">(</span><span class="n">Vec</span><span class="bp">.</span><span class="n">cons</span> <span class="n">y</span> <span class="n">ys</span><span class="o">)</span> <span class="n">rfl</span> <span class="n">rfl</span> <span class="n">heq</span><span class="bp">.</span><span class="n">rfl</span> <span class="n">heq</span><span class="bp">.</span><span class="n">rfl</span> <span class="n">h</span><span class="o">,</span>
  <span class="c1">-- This is the state I want after generalising `n + 1`, `m + 1`, `Vec.cons x xs` and `Vec.cons y ys`.</span>
   <span class="n">cases</span> <span class="n">h</span><span class="bp">;</span> <span class="n">assumption</span>
<span class="kn">end</span>
</code></pre></div>


<p>The individual generalisations can't be performed because the resulting term would not be type-correct -- but when we generalise everything at once, it works out.</p>



<a name="199516508"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Simultaneous%20generalisation/near/199516508" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Simultaneous.20generalisation.html#199516508">(Jun 02 2020 at 16:16)</a>:</h4>
<p>have you tried <code>generalize_hyp</code>?</p>



<a name="199518238"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Simultaneous%20generalisation/near/199518238" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jannis Limperg <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Simultaneous.20generalisation.html#199518238">(Jun 02 2020 at 16:29)</a>:</h4>
<p>Ah yes, sorry, <code>generalize</code> only works on the target. I've fixed the example, but the problem remains.</p>



<a name="199519680"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Simultaneous%20generalisation/near/199519680" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Simultaneous.20generalisation.html#199519680">(Jun 02 2020 at 16:40)</a>:</h4>
<p>There's also <code>h_generalize</code> for issues arising with heterogeneous types / equality but you might want to take a step back and make the types in your theorem less dependent. For instance, you might want to define a function from vector to list, reason about list equality and reflect that equality back into a statement about vectors</p>



<a name="199522486"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Simultaneous%20generalisation/near/199522486" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jannis Limperg <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Simultaneous.20generalisation.html#199522486">(Jun 02 2020 at 17:02)</a>:</h4>
<p>I've looked into <code>h_generalize</code>, but it doesn't seem applicable to this particular problem.</p>
<p>The generalisation step is supposed to be part of a larger tactic and I'd like to support use cases like this, even if it may be wiser to reduce the amount of dependency. (Also, this issue originally came up in a more realistic example, so it's not entirely academic.) Seems like I'll have to just write the tactic.</p>



<a name="199523501"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Simultaneous%20generalisation/near/199523501" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Simultaneous.20generalisation.html#199523501">(Jun 02 2020 at 17:10)</a>:</h4>
<p>Umm... isn't the proof here just <code>intro h, cases h, assumption</code>?</p>



<a name="199523553"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Simultaneous%20generalisation/near/199523553" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jannis Limperg <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Simultaneous.20generalisation.html#199523553">(Jun 02 2020 at 17:10)</a>:</h4>
<p>Yes, that's the 'contrived' part of the example. ;)</p>



<a name="199523594"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Simultaneous%20generalisation/near/199523594" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Simultaneous.20generalisation.html#199523594">(Jun 02 2020 at 17:11)</a>:</h4>
<p>When I have more nontrivial variants on <code>generalize</code> I just write out the <code>suffices</code> term manually</p>



<a name="199523680"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Simultaneous%20generalisation/near/199523680" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Simultaneous.20generalisation.html#199523680">(Jun 02 2020 at 17:12)</a>:</h4>
<p>usually this is before an induction and I find I want to make other changes to the state as well, such that straight double generalize wouldn't cut it</p>



<a name="199523762"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Simultaneous%20generalisation/near/199523762" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Simultaneous.20generalisation.html#199523762">(Jun 02 2020 at 17:12)</a>:</h4>
<p>Plus, the description of the problem here is more or less guaranteed to create <code>heq</code> terms</p>



<a name="199523851"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Simultaneous%20generalisation/near/199523851" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Simultaneous.20generalisation.html#199523851">(Jun 02 2020 at 17:13)</a>:</h4>
<p>If you want just <code>generalize : a = x</code> and not <code>generalize e : a = x</code> then it is easier</p>



<a name="199523914"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Simultaneous%20generalisation/near/199523914" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Simultaneous.20generalisation.html#199523914">(Jun 02 2020 at 17:13)</a>:</h4>
<p>which is probably the right approach in these situations anyway</p>



<a name="199524279"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Simultaneous%20generalisation/near/199524279" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Simultaneous.20generalisation.html#199524279">(Jun 02 2020 at 17:16)</a>:</h4>
<p>Do you have a more realistic example? You can also use <code>match</code> to perform multiple generalizes like this but it probably also requires the target type</p>



<a name="199524397"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Simultaneous%20generalisation/near/199524397" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jannis Limperg <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Simultaneous.20generalisation.html#199524397">(Jun 02 2020 at 17:17)</a>:</h4>
<p>No, I need the equations. This is indeed for a smarter induction tactic which properly generalises over compound index arguments (basically McBride's "Elimination with a Motive" tactic). The heqs often aren't an issue because they will be eliminated, or at least turned into homogeneous equations, after the fact. The example is realistic if you pretend that <code>cases</code> doesn't already exist: <code>induction</code> should be a generalisation of <code>cases</code>.</p>



<a name="199524584"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Simultaneous%20generalisation/near/199524584" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Simultaneous.20generalisation.html#199524584">(Jun 02 2020 at 17:19)</a>:</h4>
<p>well you can always get the equations with a multiple generalize, you know</p>



<a name="199524627"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Simultaneous%20generalisation/near/199524627" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Simultaneous.20generalisation.html#199524627">(Jun 02 2020 at 17:19)</a>:</h4>
<p>it's just one more dependent arg</p>



<a name="199524746"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Simultaneous%20generalisation/near/199524746" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Simultaneous.20generalisation.html#199524746">(Jun 02 2020 at 17:20)</a>:</h4>
<blockquote>
<p>The heqs often aren't an issue because they will be eliminated, or at least turned into homogeneous equations, after the fact</p>
</blockquote>
<p>What's confusing me about this example is that I would be fighting to turn the goal after the tactic into the one before the tactic</p>



<a name="199524982"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Simultaneous%20generalisation/near/199524982" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Simultaneous.20generalisation.html#199524982">(Jun 02 2020 at 17:22)</a>:</h4>
<blockquote>
<p><code>induction</code> should be a generalisation of <code>cases</code></p>
</blockquote>
<p>The generalizes done in <code>cases</code> are generally bad for <code>induction</code>, because they limit the inductive hypothesis too much and usually make it useless</p>



<a name="199526504"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Simultaneous%20generalisation/near/199526504" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Simultaneous.20generalisation.html#199526504">(Jun 02 2020 at 17:34)</a>:</h4>
<p>Do you have an example where this better induction tactic would be useful and <code>cases</code> / <code>induction</code> fail?</p>



<a name="199570804"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Simultaneous%20generalisation/near/199570804" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jannis Limperg <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Simultaneous.20generalisation.html#199570804">(Jun 03 2020 at 01:04)</a>:</h4>
<p>My <code>induction</code> is essentially a reimplementation of Coq's <code>dependent induction</code> and should be broadly equivalent to Agda's pattern matching, Coq's <code>Equations</code> plugin and Lean's equation compiler, so it's not exactly a radical new idea. Here's an example from Jasmin's course (which motivates the whole project):</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">state</span> <span class="o">:=</span>
<span class="n">string</span> <span class="bp">→</span> <span class="bp">ℕ</span>

<span class="n">def</span> <span class="n">state</span><span class="bp">.</span><span class="n">update</span> <span class="o">(</span><span class="n">name</span> <span class="o">:</span> <span class="n">string</span><span class="o">)</span> <span class="o">(</span><span class="n">val</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">state</span><span class="o">)</span> <span class="o">:</span> <span class="n">state</span> <span class="o">:=</span>
<span class="bp">λ</span><span class="n">name&#39;</span><span class="o">,</span> <span class="k">if</span> <span class="n">name&#39;</span> <span class="bp">=</span> <span class="n">name</span> <span class="k">then</span> <span class="n">val</span> <span class="k">else</span> <span class="n">s</span> <span class="n">name&#39;</span>

<span class="kn">notation</span> <span class="n">s</span> <span class="bp">`</span><span class="o">{</span><span class="bp">`</span> <span class="n">name</span> <span class="bp">`</span> <span class="err">↦</span> <span class="bp">`</span> <span class="n">val</span> <span class="bp">`</span><span class="o">}</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">state</span><span class="bp">.</span><span class="n">update</span> <span class="n">name</span> <span class="n">val</span> <span class="n">s</span>

<span class="kn">inductive</span> <span class="n">stmt</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">skip</span>   <span class="o">:</span> <span class="n">stmt</span>
<span class="bp">|</span> <span class="n">assign</span> <span class="o">:</span> <span class="n">string</span> <span class="bp">→</span> <span class="o">(</span><span class="n">state</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="bp">→</span> <span class="n">stmt</span>
<span class="bp">|</span> <span class="n">seq</span>    <span class="o">:</span> <span class="n">stmt</span> <span class="bp">→</span> <span class="n">stmt</span> <span class="bp">→</span> <span class="n">stmt</span>
<span class="bp">|</span> <span class="n">ite</span>    <span class="o">:</span> <span class="o">(</span><span class="n">state</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="bp">→</span> <span class="n">stmt</span> <span class="bp">→</span> <span class="n">stmt</span> <span class="bp">→</span> <span class="n">stmt</span>
<span class="bp">|</span> <span class="n">while</span>  <span class="o">:</span> <span class="o">(</span><span class="n">state</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="bp">→</span> <span class="n">stmt</span> <span class="bp">→</span> <span class="n">stmt</span>

<span class="kn">inductive</span> <span class="n">big_step</span> <span class="o">:</span> <span class="n">stmt</span> <span class="bp">×</span> <span class="n">state</span> <span class="bp">→</span> <span class="n">state</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">skip</span> <span class="o">{</span><span class="n">s</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">big_step</span> <span class="o">(</span><span class="n">skip</span><span class="o">,</span> <span class="n">s</span><span class="o">)</span> <span class="n">s</span>
<span class="bp">|</span> <span class="n">assign</span> <span class="o">{</span><span class="n">x</span> <span class="n">a</span> <span class="n">s</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">big_step</span> <span class="o">(</span><span class="n">assign</span> <span class="n">x</span> <span class="n">a</span><span class="o">,</span> <span class="n">s</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span><span class="o">{</span><span class="n">x</span> <span class="err">↦</span> <span class="n">a</span> <span class="n">s</span><span class="o">})</span>
<span class="bp">|</span> <span class="n">seq</span> <span class="o">{</span><span class="n">S</span> <span class="n">T</span> <span class="n">s</span> <span class="n">t</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">hS</span> <span class="o">:</span> <span class="n">big_step</span> <span class="o">(</span><span class="n">S</span><span class="o">,</span> <span class="n">s</span><span class="o">)</span> <span class="n">t</span><span class="o">)</span>
    <span class="o">(</span><span class="n">hT</span> <span class="o">:</span> <span class="n">big_step</span> <span class="o">(</span><span class="n">T</span><span class="o">,</span> <span class="n">t</span><span class="o">)</span> <span class="n">u</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">big_step</span> <span class="o">(</span><span class="n">seq</span> <span class="n">S</span> <span class="n">T</span><span class="o">,</span> <span class="n">s</span><span class="o">)</span> <span class="n">u</span>
<span class="bp">|</span> <span class="n">ite_true</span> <span class="o">{</span><span class="n">b</span> <span class="o">:</span> <span class="n">state</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">{</span><span class="n">S</span> <span class="n">T</span> <span class="n">s</span> <span class="n">t</span><span class="o">}</span> <span class="o">(</span><span class="n">hcond</span> <span class="o">:</span> <span class="n">b</span> <span class="n">s</span><span class="o">)</span>
    <span class="o">(</span><span class="n">hbody</span> <span class="o">:</span> <span class="n">big_step</span> <span class="o">(</span><span class="n">S</span><span class="o">,</span> <span class="n">s</span><span class="o">)</span> <span class="n">t</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">big_step</span> <span class="o">(</span><span class="n">ite</span> <span class="n">b</span> <span class="n">S</span> <span class="n">T</span><span class="o">,</span> <span class="n">s</span><span class="o">)</span> <span class="n">t</span>
<span class="bp">|</span> <span class="n">ite_false</span> <span class="o">{</span><span class="n">b</span> <span class="o">:</span> <span class="n">state</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">{</span><span class="n">S</span> <span class="n">T</span> <span class="n">s</span> <span class="n">t</span><span class="o">}</span> <span class="o">(</span><span class="n">hcond</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">b</span> <span class="n">s</span><span class="o">)</span>
    <span class="o">(</span><span class="n">hbody</span> <span class="o">:</span> <span class="n">big_step</span> <span class="o">(</span><span class="n">T</span><span class="o">,</span> <span class="n">s</span><span class="o">)</span> <span class="n">t</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">big_step</span> <span class="o">(</span><span class="n">ite</span> <span class="n">b</span> <span class="n">S</span> <span class="n">T</span><span class="o">,</span> <span class="n">s</span><span class="o">)</span> <span class="n">t</span>
<span class="bp">|</span> <span class="n">while_true</span> <span class="o">{</span><span class="n">b</span> <span class="o">:</span> <span class="n">state</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">{</span><span class="n">S</span> <span class="n">s</span> <span class="n">t</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">hcond</span> <span class="o">:</span> <span class="n">b</span> <span class="n">s</span><span class="o">)</span>
    <span class="o">(</span><span class="n">hbody</span> <span class="o">:</span> <span class="n">big_step</span> <span class="o">(</span><span class="n">S</span><span class="o">,</span> <span class="n">s</span><span class="o">)</span> <span class="n">t</span><span class="o">)</span>
    <span class="o">(</span><span class="n">hrest</span> <span class="o">:</span> <span class="n">big_step</span> <span class="o">(</span><span class="n">while</span> <span class="n">b</span> <span class="n">S</span><span class="o">,</span> <span class="n">t</span><span class="o">)</span> <span class="n">u</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">big_step</span> <span class="o">(</span><span class="n">while</span> <span class="n">b</span> <span class="n">S</span><span class="o">,</span> <span class="n">s</span><span class="o">)</span> <span class="n">u</span>
<span class="bp">|</span> <span class="n">while_false</span> <span class="o">{</span><span class="n">b</span> <span class="o">:</span> <span class="n">state</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">{</span><span class="n">S</span> <span class="n">s</span><span class="o">}</span> <span class="o">(</span><span class="n">hcond</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">b</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">big_step</span> <span class="o">(</span><span class="n">while</span> <span class="n">b</span> <span class="n">S</span><span class="o">,</span> <span class="n">s</span><span class="o">)</span> <span class="n">s</span>

<span class="kn">infix</span> <span class="bp">`</span> <span class="err">⟹</span> <span class="bp">`</span><span class="o">:</span><span class="mi">110</span> <span class="o">:=</span> <span class="n">big_step</span>

<span class="kn">lemma</span> <span class="n">not_big_step_while_true</span> <span class="o">{</span><span class="n">S</span> <span class="n">s</span> <span class="n">t</span><span class="o">}</span> <span class="o">:</span>
  <span class="bp">¬</span> <span class="o">(</span><span class="n">while</span> <span class="o">(</span><span class="bp">λ_</span><span class="o">,</span> <span class="n">true</span><span class="o">)</span> <span class="n">S</span><span class="o">,</span> <span class="n">s</span><span class="o">)</span> <span class="err">⟹</span> <span class="n">t</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">intro</span> <span class="n">hw</span><span class="o">,</span>
  <span class="n">induction&#39;</span> <span class="n">hw</span><span class="o">,</span>
  <span class="n">case</span> <span class="n">while_true</span> <span class="o">{</span>
    <span class="n">exact</span> <span class="n">ih_hw_1</span>
  <span class="o">},</span>
  <span class="n">case</span> <span class="n">while_false</span> <span class="o">{</span>
    <span class="n">apply</span> <span class="n">hcond</span><span class="o">,</span>
    <span class="n">trivial</span>
  <span class="o">}</span>
<span class="kn">end</span>
</code></pre></div>


<p><code>cases</code> wouldn't suffice here; the proof requires induction. Regular <code>induction</code> leaves us with an unprovable <code>while_false</code> case because the naive generalisation it performs throws information away. So you have to know how to generalise the goal yourself; my <code>induction'</code> does this for you. It also recognises that most of the cases are impossible and solves them automatically.</p>
<p>Now, this example doesn't have the dependencies between index argument that are the topic of this thread. But having hopefully established the utility of <code>induction'</code>, the only question is whether it should randomly fail on perfectly good hypotheses because I was too lazy to implement a more general procedure for simultaneous generalisation. That would seem unfortunate to me.</p>



<a name="199570893"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Simultaneous%20generalisation/near/199570893" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Simultaneous.20generalisation.html#199570893">(Jun 03 2020 at 01:06)</a>:</h4>
<p>Right, this is the sort of thing I don't think you can get right in general</p>



<a name="199571003"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Simultaneous%20generalisation/near/199571003" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Simultaneous.20generalisation.html#199571003">(Jun 03 2020 at 01:09)</a>:</h4>
<p>picking the right induction hypothesis is a very difficult problem. You may have a heuristic that works for this problem but then it fails for a different use case. In this case you need to know that the left arg is a <code>while true</code> but if <code>s</code> was a more specific thing like <code>\lam _, 0</code> then you might accidentally hold that fixed as well and then it wouldn't be provable</p>



<a name="199571100"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Simultaneous%20generalisation/near/199571100" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Simultaneous.20generalisation.html#199571100">(Jun 03 2020 at 01:10)</a>:</h4>
<p>I believe that <code>induction</code> has the correct default behavior, and it is best to have the user manually use generalize to indicate what they want to hold fixed in the induction hypothesis</p>



<a name="199571937"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Simultaneous%20generalisation/near/199571937" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jannis Limperg <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Simultaneous.20generalisation.html#199571937">(Jun 03 2020 at 01:30)</a>:</h4>
<p>I'm not claiming that this tactic can intuit the correct level of generality for every lemma. But in my experience, it is usually right if you state the lemma at the right level of generality. And I should stress again that I'm doing more or less exactly what the equation compiler is doing:</p>
<div class="codehilite"><pre><span></span><code><span class="n">meta</span> <span class="n">def</span> <span class="n">not_big_step_while_true&#39;</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">S</span> <span class="n">s</span> <span class="n">t</span><span class="o">},</span> <span class="o">(</span><span class="n">while</span> <span class="o">(</span><span class="bp">λ_</span><span class="o">,</span> <span class="n">true</span><span class="o">)</span> <span class="n">S</span><span class="o">,</span> <span class="n">s</span><span class="o">)</span> <span class="err">⟹</span> <span class="n">t</span> <span class="bp">→</span> <span class="n">false</span>
<span class="bp">|</span> <span class="n">S</span> <span class="n">s</span> <span class="n">u</span> <span class="o">(</span><span class="bp">@</span><span class="n">while_true</span> <span class="n">b</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">t</span> <span class="bp">_</span> <span class="n">hcond</span> <span class="n">hbody</span> <span class="n">hrest</span><span class="o">)</span> <span class="o">:=</span> <span class="n">not_big_step_while_true&#39;</span> <span class="n">hrest</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="o">(</span><span class="n">while_false</span> <span class="n">hcond</span><span class="o">)</span> <span class="o">:=</span> <span class="n">hcond</span> <span class="n">trivial</span>
</code></pre></div>


<p>(The termination checker complains for whatever reason, hence the <code>meta</code>.) If every modern dependently typed language employs this strategy, it's probably a decent strategy.</p>



<a name="199572778"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Simultaneous%20generalisation/near/199572778" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Simultaneous.20generalisation.html#199572778">(Jun 03 2020 at 01:51)</a>:</h4>
<p>The termination checker complains because the equation compiler actually failed in this example!</p>



<a name="199572783"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Simultaneous%20generalisation/near/199572783" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Simultaneous.20generalisation.html#199572783">(Jun 03 2020 at 01:51)</a>:</h4>
<p>It fell back on well founded recursion which has pretty bad error messages</p>



<a name="199572980"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Simultaneous%20generalisation/near/199572980" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Simultaneous.20generalisation.html#199572980">(Jun 03 2020 at 01:57)</a>:</h4>
<p>If you are replicating the equation compiler in lean, that's a big project (that I encourage). But I would suggest a principled approach to it rather than chaining tactics because this is more likely to create brittleness and edge cases (some of which exist already in <code>induction</code>, <code>cases</code>, and the equation compiler)</p>



<a name="199573269"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Simultaneous%20generalisation/near/199573269" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jannis Limperg <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Simultaneous.20generalisation.html#199573269">(Jun 03 2020 at 02:05)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113488-general/topic/Simultaneous.20generalisation/near/199572778">said</a>:</p>
<blockquote>
<p>The termination checker complains because the equation compiler actually failed in this example!</p>
</blockquote>
<p>I see. That's a problem with the equation compiler though; Agda would have no issue with this definition.</p>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113488-general/topic/Simultaneous.20generalisation/near/199572980">said</a>:</p>
<blockquote>
<p>If you are replicating the equation compiler in lean, that's a big project (that I encourage). But I would suggest a principled approach to it rather than chaining tactics because this is more likely to create brittleness and edge cases (some of which exist already in <code>induction</code>, <code>cases</code>, and the equation compiler)</p>
</blockquote>
<p>That's fair. My goal is much more modest: an induction tactic that can handle Jasmin's course contents with minimal ceremony.</p>



<a name="199573430"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Simultaneous%20generalisation/near/199573430" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Simultaneous.20generalisation.html#199573430">(Jun 03 2020 at 02:09)</a>:</h4>
<p>FWIW the way I write proofs of theorems like your example is:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">lemma</span> <span class="n">not_big_step_while_true</span> <span class="o">{</span><span class="n">S</span> <span class="n">s</span> <span class="n">t</span><span class="o">}</span> <span class="o">:</span>
  <span class="bp">¬</span> <span class="o">(</span><span class="n">while</span> <span class="o">(</span><span class="bp">λ_</span><span class="o">,</span> <span class="n">true</span><span class="o">)</span> <span class="n">S</span><span class="o">,</span> <span class="n">s</span><span class="o">)</span> <span class="err">⟹</span> <span class="n">t</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">generalize</span> <span class="n">e</span> <span class="o">:</span> <span class="o">(</span><span class="n">while</span> <span class="o">(</span><span class="bp">λ_</span><span class="o">,</span> <span class="n">true</span><span class="o">)</span> <span class="n">S</span><span class="o">,</span> <span class="n">s</span><span class="o">)</span> <span class="bp">=</span> <span class="n">c</span><span class="o">,</span>
  <span class="n">intro</span> <span class="n">hw</span><span class="o">,</span>
  <span class="n">induction</span> <span class="n">hw</span> <span class="n">generalizing</span> <span class="n">s</span><span class="bp">;</span> <span class="n">cases</span> <span class="n">e</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">hw_ih_hrest</span> <span class="n">rfl</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">apply</span> <span class="n">hw_hcond</span><span class="o">,</span>
    <span class="n">trivial</span> <span class="o">}</span>
<span class="kn">end</span>
</code></pre></div>



<a name="199573515"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Simultaneous%20generalisation/near/199573515" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Simultaneous.20generalisation.html#199573515">(Jun 03 2020 at 02:11)</a>:</h4>
<p>Unfortunately this throws away the case tags so you can't use <code>case</code>, and <code>propagate_tags</code> doesn't work because of the unique rename problem</p>



<a name="199573588"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Simultaneous%20generalisation/near/199573588" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Simultaneous.20generalisation.html#199573588">(Jun 03 2020 at 02:13)</a>:</h4>
<blockquote>
<p>I see. That's a problem with the equation compiler though; Agda would have no issue with this definition.</p>
</blockquote>
<p>Do you know how Agda's equation compiler works? It is the most complex equation compiler I am aware of, and because the things it does are axiomatic it has a lot of leeway to just do things and not worry about the reason behind them</p>



<a name="199573654"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Simultaneous%20generalisation/near/199573654" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Simultaneous.20generalisation.html#199573654">(Jun 03 2020 at 02:15)</a>:</h4>
<p>But from my point of view there is a very real issue that explains why <code>induction</code> and <code>cases</code> use different inductive hypotheses</p>



<a name="199573671"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Simultaneous%20generalisation/near/199573671" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Simultaneous.20generalisation.html#199573671">(Jun 03 2020 at 02:16)</a>:</h4>
<p>One thing that's not clear to me about <code>induction'</code> is how you decide what to generalize</p>



<a name="199573716"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Simultaneous%20generalisation/near/199573716" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Simultaneous.20generalisation.html#199573716">(Jun 03 2020 at 02:16)</a>:</h4>
<p>In order for that theorem to be provable you need to generalize at least <code>s</code>, as well as some <code>S'</code> that is equal to <code>(while (λ_, true) S, s)</code></p>



<a name="199573783"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Simultaneous%20generalisation/near/199573783" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Simultaneous.20generalisation.html#199573783">(Jun 03 2020 at 02:18)</a>:</h4>
<p>If you are thinking to just generalize everything, that will limit its usefulness when this is an induction buried inside a larger proof. Or are you expecting that <code>induction'</code> should always be the first tactic in the proof, and the goal state is already curated for consumption?</p>



<a name="199574353"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Simultaneous%20generalisation/near/199574353" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jannis Limperg <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Simultaneous.20generalisation.html#199574353">(Jun 03 2020 at 02:33)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113488-general/topic/Simultaneous.20generalisation/near/199573430">said</a>:</p>
<blockquote>
<p>FWIW the way I write proofs of theorems like your example is: [...]</p>
</blockquote>
<p>Yeah, that's exactly what the tactic does as well. Generalise indices, induction, eliminate the equations for the generalised indices, simplify the induction hypothesis.</p>
<p><code>with_cases</code> preserves the case tags:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">lemma</span> <span class="n">not_big_step_while_true</span> <span class="o">{</span><span class="n">S</span> <span class="n">s</span> <span class="n">t</span><span class="o">}</span> <span class="o">:</span>
  <span class="bp">¬</span> <span class="o">(</span><span class="n">while</span> <span class="o">(</span><span class="bp">λ_</span><span class="o">,</span> <span class="n">true</span><span class="o">)</span> <span class="n">S</span><span class="o">,</span> <span class="n">s</span><span class="o">)</span> <span class="err">⟹</span> <span class="n">t</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">generalize</span> <span class="n">e</span> <span class="o">:</span> <span class="o">(</span><span class="n">while</span> <span class="o">(</span><span class="bp">λ_</span><span class="o">,</span> <span class="n">true</span><span class="o">)</span> <span class="n">S</span><span class="o">,</span> <span class="n">s</span><span class="o">)</span> <span class="bp">=</span> <span class="n">c</span><span class="o">,</span>
  <span class="n">intro</span> <span class="n">hw</span><span class="o">,</span>
  <span class="n">with_cases</span> <span class="o">{</span> <span class="n">induction</span> <span class="n">hw</span> <span class="n">generalizing</span> <span class="n">s</span><span class="bp">;</span> <span class="n">cases</span> <span class="n">e</span> <span class="o">},</span>
  <span class="n">case</span> <span class="n">while_true</span> <span class="o">{</span>
    <span class="n">exact</span> <span class="n">hw_ih_hrest</span> <span class="n">rfl</span>
  <span class="o">},</span>
  <span class="n">case</span> <span class="n">while_false</span> <span class="o">{</span>
    <span class="n">apply</span> <span class="n">hw_hcond</span><span class="o">,</span>
    <span class="n">trivial</span>
  <span class="o">}</span>
<span class="kn">end</span>
</code></pre></div>


<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113488-general/topic/Simultaneous.20generalisation/near/199573588">said</a>:</p>
<blockquote>
<p>Do you know how Agda's equation compiler works? It is the most complex equation compiler I am aware of, and because the things it does are axiomatic it has a lot of leeway to just do things and not worry about the reason behind them</p>
</blockquote>
<p>Not in any detail. I know that it translates the patterns to case trees, but not to eliminators. Termination checking is a separate pass based on a 'size-change' criterion, but I don't actually know what that is. If I wanted to build an equation compiler, I'd start with Jesper Cockx's <a href="https://jesper.sikanda.be/files/proof-relevant-unification.pdf">paper</a> on proof-relevant unification. Matthieu Sozeau probably also has a paper on the Equations plugin.</p>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113488-general/topic/Simultaneous.20generalisation/near/199573671">said</a>:</p>
<blockquote>
<p>One thing that's not clear to me about <code>induction'</code> is how you decide what to generalize</p>
</blockquote>
<p>It generalises every compound index argument of the hypothesis we eliminate ('eliminee'), here <code>(while (λ_, true) S, s)</code>. It then reverts every hypothesis that doesn't occur in the eliminee to get the most general induction hypothesis. (This can be overridden with a 'fixing' clause akin to <code>induction</code>'s 'generalizing'.)</p>
<p>There is currently no way to prevent compound index arguments from being generalised, though I could add a flag to that effect. I would indeed assume that most uses of induction are near the top of the proof. This is certainly the case for the boring programming languages proofs where this tactic will be most useful. For induction within a longer proof, I would tend to use a lemma or <code>assert</code>.</p>



<a name="199574540"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Simultaneous%20generalisation/near/199574540" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Simultaneous.20generalisation.html#199574540">(Jun 03 2020 at 02:38)</a>:</h4>
<p>another common pattern in boring PL proofs is <code>induction h1; cases h2; cases equality</code></p>



<a name="199574547"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Simultaneous%20generalisation/near/199574547" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Simultaneous.20generalisation.html#199574547">(Jun 03 2020 at 02:38)</a>:</h4>
<p>for example in proving determinism with a small step semantics</p>



<a name="199574557"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Simultaneous%20generalisation/near/199574557" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Simultaneous.20generalisation.html#199574557">(Jun 03 2020 at 02:38)</a>:</h4>
<p>or big step for that matter</p>



<a name="200052957"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Simultaneous%20generalisation/near/200052957" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jannis Limperg <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Simultaneous.20generalisation.html#200052957">(Jun 08 2020 at 02:14)</a>:</h4>
<p>PR: <a href="https://github.com/leanprover-community/mathlib/issues/2982">#2982</a></p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
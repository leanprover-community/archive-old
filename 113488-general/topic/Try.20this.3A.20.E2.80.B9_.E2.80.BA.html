---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/Try.20this.3A.20.E2.80.B9_.E2.80.BA.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Try.20this.3A.20.E2.80.B9_.E2.80.BA.html">Try this: ‹_›</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="258254335"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Try%20this%3A%20%E2%80%B9_%E2%80%BA/near/258254335" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Try.20this.3A.20.E2.80.B9_.E2.80.BA.html#258254335">(Oct 19 2021 at 19:06)</a>:</h4>
<p>I want to do a Lean demo where I don't name hypotheses that I add with <code>have</code>. So they all end up being called <code>this</code>. Now <code>library_search</code> get's mightily confused over this, and thinks that some of them should be called <code>this_1</code> etc.<br>
How hard is it to get a variant of <code>library_search</code> and/or <code>suggest</code> that will write <code>‹N ≠ 1›</code> instead of <code>this_2</code> in it's "Try this:" output?</p>



<a name="258261456"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Try%20this%3A%20%E2%80%B9_%E2%80%BA/near/258261456" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Try.20this.3A.20.E2.80.B9_.E2.80.BA.html#258261456">(Oct 19 2021 at 19:56)</a>:</h4>
<p>Wouldn't it be much easier to just call the hypotheses h1, h2 etc? Remember that this is what mathematicians do in real life!</p>



<a name="258261727"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Try%20this%3A%20%E2%80%B9_%E2%80%BA/near/258261727" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Try.20this.3A.20.E2.80.B9_.E2.80.BA.html#258261727">(Oct 19 2021 at 19:58)</a>:</h4>
<p>What? I've never seen <code>h1</code> or <code>h2</code> in latex docs.</p>



<a name="258261878"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Try%20this%3A%20%E2%80%B9_%E2%80%BA/near/258261878" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Try.20this.3A.20.E2.80.B9_.E2.80.BA.html#258261878">(Oct 19 2021 at 19:59)</a>:</h4>
<p>It's always of the form: Let <code>p</code> denote <code>N.min_fac</code>. Note that obviously <code>N ≠ 1</code>, hence <code>p</code> is prime.</p>



<a name="258261905"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Try%20this%3A%20%E2%80%B9_%E2%80%BA/near/258261905" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Try.20this.3A.20.E2.80.B9_.E2.80.BA.html#258261905">(Oct 19 2021 at 19:59)</a>:</h4>
<p>No <code>h1</code>s or <code>h2</code>s involved.</p>



<a name="258299188"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Try%20this%3A%20%E2%80%B9_%E2%80%BA/near/258299188" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Try.20this.3A.20.E2.80.B9_.E2.80.BA.html#258299188">(Oct 20 2021 at 01:30)</a>:</h4>
<p>cheap solution: <code>Try this: dedup, exact foobar this_1</code></p>



<a name="258308982"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Try%20this%3A%20%E2%80%B9_%E2%80%BA/near/258308982" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Try.20this.3A.20.E2.80.B9_.E2.80.BA.html#258308982">(Oct 20 2021 at 04:00)</a>:</h4>
<p>Thanks. That works, I guess. But the suggested proofs don't look nice, if you get what I mean.</p>



<a name="258315027"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Try%20this%3A%20%E2%80%B9_%E2%80%BA/near/258315027" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Try.20this.3A.20.E2.80.B9_.E2.80.BA.html#258315027">(Oct 20 2021 at 05:37)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span> I've got something that <em>almost</em> works, but it seems like it might need a modification to <code>src/frontends/lean/pp.cpp</code> in Lean itself if there's not some other trick.</p>
<p>It looks for anything called <code>this</code> in the local context and wraps it in a special identity function that I called <code>tactic.the</code>, and if you have </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">notation</span> <span class="bp">`</span><span class="o">‹</span><span class="bp">`</span> <span class="n">α</span> <span class="bp">`</span><span class="o">›</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">tactic.the</span> <span class="n">α</span> <span class="n">_</span>
</code></pre></div>
<p>you can make it print out as you want (at the cost of breaking the usual <code>‹...›</code> notation...). Examples:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span><span class="o">:</span> <span class="n">nat</span><span class="o">}</span> <span class="o">(</span><span class="n">this</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">c</span><span class="o">)</span> <span class="o">(</span><span class="n">this</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">d</span><span class="o">)</span> <span class="o">:</span> <span class="n">max</span> <span class="o">(</span><span class="n">c</span> <span class="bp">+</span> <span class="n">d</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">c</span> <span class="bp">+</span> <span class="n">d</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">library_search'</span> <span class="o">[</span><span class="n">add_lt_add</span><span class="o">],</span> <span class="c1">-- Try this: exact max_eq_left_of_lt (add_lt_add ‹a &lt; c› ‹b &lt; d›)</span>
<span class="kd">end</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">this</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">library_search'</span><span class="o">,</span> <span class="c1">-- Try this: exact pos_iff_ne_zero.mpr ‹n ≠ 0›,</span>
<span class="kd">end</span>
</code></pre></div>
<div class="spoiler-block"><div class="spoiler-header">
</div><div class="spoiler-content" aria-hidden="true">
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kn">namespace</span> <span class="n">tactic</span>

<span class="kd">def</span> <span class="n">the</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="n">x</span>

<span class="kn">namespace</span> <span class="n">solve_by_elim</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">mk_assumption_set'</span> <span class="o">(</span><span class="n">no_dflt</span> <span class="o">:</span> <span class="n">bool</span><span class="o">)</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="n">list</span> <span class="n">simp_arg_type</span><span class="o">)</span> <span class="o">(</span><span class="n">attr</span> <span class="o">:</span> <span class="n">list</span> <span class="n">name</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">tactic</span> <span class="o">(</span><span class="n">list</span> <span class="o">(</span><span class="n">tactic</span> <span class="n">expr</span><span class="o">)</span> <span class="bp">×</span> <span class="n">tactic</span> <span class="o">(</span><span class="n">list</span> <span class="n">expr</span><span class="o">))</span> <span class="o">:=</span>
<span class="c1">-- We lock the tactic state so that any spurious goals generated during</span>
<span class="c1">-- elaboration of pre-expressions are discarded</span>
<span class="n">lock_tactic_state</span> <span class="bp">$</span>
<span class="k">do</span>
  <span class="c1">-- `hs` are expressions specified explicitly,</span>
  <span class="c1">-- `hex` are exceptions (specified via `solve_by_elim [-h]`) referring to local hypotheses,</span>
  <span class="c1">-- `gex` are the other exceptions</span>
  <span class="o">(</span><span class="n">hs</span><span class="o">,</span> <span class="n">gex</span><span class="o">,</span> <span class="n">hex</span><span class="o">,</span> <span class="n">all_hyps</span><span class="o">)</span> <span class="bp">←</span> <span class="n">decode_simp_arg_list</span> <span class="n">hs</span><span class="o">,</span>
  <span class="c1">-- Recall, per the discussion above, we produce `tactic expr` thunks rather than actual `expr`s.</span>
  <span class="c1">-- Note that while we evaluate these thunks on two occasions below while preparing the list,</span>
  <span class="c1">-- this is a one-time cost during `mk_assumption_set`, rather than a cost proportional to the</span>
  <span class="c1">-- length of the search `solve_by_elim` executes.</span>
  <span class="k">let</span> <span class="n">hs</span> <span class="o">:=</span> <span class="n">hs.map</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">i_to_expr_for_apply</span> <span class="n">h</span><span class="o">),</span>
  <span class="n">l</span> <span class="bp">←</span> <span class="n">attr.mmap</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="kn">attribute</span><span class="bp">.</span><span class="n">get_instances</span> <span class="n">a</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">l</span> <span class="o">:=</span> <span class="n">l.join</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">m</span> <span class="o">:=</span> <span class="n">l.map</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">mk_const</span> <span class="n">h</span><span class="o">),</span>
  <span class="c1">-- In order to remove the expressions we need to evaluate the thunks.</span>
  <span class="n">hs</span> <span class="bp">←</span> <span class="o">(</span><span class="n">hs</span> <span class="bp">++</span> <span class="n">m</span><span class="o">)</span><span class="bp">.</span><span class="n">mfilter</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="o">(</span><span class="k">do</span> <span class="n">h</span> <span class="bp">←</span> <span class="n">h</span><span class="o">,</span> <span class="n">return</span> <span class="bp">$</span> <span class="n">expr.const_name</span> <span class="n">h</span> <span class="bp">∉</span> <span class="n">gex</span><span class="o">),</span>
  <span class="k">let</span> <span class="n">hs</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">no_dflt</span> <span class="k">then</span> <span class="n">hs</span> <span class="k">else</span>
    <span class="o">([</span><span class="bp">`</span><span class="n">rfl</span><span class="o">,</span> <span class="bp">`</span><span class="n">trivial</span><span class="o">,</span> <span class="bp">`</span><span class="n">congr_fun</span><span class="o">,</span> <span class="bp">`</span><span class="n">congr_arg</span><span class="o">]</span><span class="bp">.</span><span class="n">map</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">n</span><span class="o">,</span> <span class="o">(</span><span class="n">mk_const</span> <span class="n">n</span><span class="o">)))</span> <span class="bp">++</span> <span class="n">hs</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">locals</span> <span class="o">:</span> <span class="n">tactic</span> <span class="o">(</span><span class="n">list</span> <span class="n">expr</span><span class="o">)</span> <span class="o">:=</span> <span class="k">if</span> <span class="bp">¬</span> <span class="n">no_dflt</span> <span class="bp">∨</span> <span class="n">all_hyps</span> <span class="k">then</span> <span class="k">do</span>
    <span class="n">ctx</span> <span class="bp">←</span> <span class="n">local_context</span><span class="o">,</span>
    <span class="c1">-- Remove local exceptions specified in `hex`:</span>
    <span class="k">let</span> <span class="n">ctx</span> <span class="o">:=</span> <span class="n">ctx.filter</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">h</span> <span class="o">:</span> <span class="n">expr</span><span class="o">,</span> <span class="n">h.local_uniq_name</span> <span class="bp">∉</span> <span class="n">hex</span><span class="o">),</span>
    <span class="c1">--  -------- Changed here:</span>
    <span class="c1">-- replace hypotheses named `this : α` with `‹α›`</span>
    <span class="n">ctx</span> <span class="bp">←</span> <span class="n">ctx.mmap</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">h</span> <span class="o">:</span> <span class="n">expr</span><span class="o">,</span> <span class="o">(</span><span class="k">do</span>
      <span class="k">if</span> <span class="n">h.local_pp_name</span> <span class="bp">=</span> <span class="s2">"this"</span> <span class="k">then</span> <span class="k">do</span>
        <span class="n">t</span> <span class="bp">←</span> <span class="n">tactic.infer_type</span> <span class="n">h</span><span class="o">,</span>
        <span class="n">tactic.i_to_expr</span> <span class="bp">``</span><span class="o">(</span><span class="bp">@</span><span class="n">tactic.the</span> <span class="bp">%%</span><span class="n">t</span> <span class="bp">%%</span><span class="n">h</span><span class="o">)</span>
      <span class="k">else</span>
        <span class="n">return</span> <span class="n">h</span>
    <span class="o">),</span>
    <span class="n">return</span> <span class="bp">$</span> <span class="n">ctx</span>
  <span class="k">else</span> <span class="n">return</span> <span class="o">[],</span>
  <span class="c1">-- Finally, run all of the tactics: any that return an expression without metavariables can safely</span>
  <span class="c1">-- be replaced by a `return` tactic.</span>
  <span class="n">hs</span> <span class="bp">←</span> <span class="n">hs.mmap</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">h</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">expr</span><span class="o">,</span> <span class="k">do</span>
    <span class="n">e</span> <span class="bp">←</span> <span class="n">h</span><span class="o">,</span>
    <span class="k">if</span> <span class="n">e.has_meta_var</span> <span class="k">then</span> <span class="n">return</span> <span class="n">h</span> <span class="k">else</span> <span class="n">return</span> <span class="o">(</span><span class="n">return</span> <span class="n">e</span><span class="o">)),</span>
  <span class="n">return</span> <span class="o">(</span><span class="n">hs</span><span class="o">,</span> <span class="n">locals</span><span class="o">)</span>

<span class="kd">end</span> <span class="n">solve_by_elim</span>

<span class="kn">open</span> <span class="n">suggest</span>

<span class="kn">namespace</span> <span class="n">interactive</span>
<span class="kn">open</span> <span class="n">tactic</span>
<span class="kn">open</span> <span class="n">interactive</span>
<span class="kn">open</span> <span class="n">lean.parser</span>
<span class="kn">open</span> <span class="n">interactive.types</span>
<span class="kn">open</span> <span class="n">solve_by_elim</span>
<span class="kn">local</span> <span class="kd">postfix</span> <span class="bp">`?`</span><span class="o">:</span><span class="mi">9001</span> <span class="o">:=</span> <span class="n">optional</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">library_search'</span> <span class="o">(</span><span class="n">semireducible</span> <span class="o">:</span> <span class="n">parse</span> <span class="bp">$</span> <span class="n">optional</span> <span class="o">(</span><span class="n">tk</span> <span class="s2">"!"</span><span class="o">))</span>
  <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="n">parse</span> <span class="n">simp_arg_list</span><span class="o">)</span> <span class="o">(</span><span class="n">attr_names</span> <span class="o">:</span> <span class="n">parse</span> <span class="n">with_ident_list</span><span class="o">)</span>
  <span class="o">(</span><span class="n">use</span> <span class="o">:</span> <span class="n">parse</span> <span class="bp">$</span> <span class="o">(</span><span class="n">tk</span> <span class="s2">"using"</span> <span class="bp">*&gt;</span> <span class="n">many</span> <span class="n">ident_</span><span class="o">)</span> <span class="bp">&lt;|&gt;</span> <span class="n">return</span> <span class="o">[])</span>
  <span class="o">(</span><span class="n">opt</span> <span class="o">:</span> <span class="n">opt</span> <span class="o">:=</span> <span class="o">{</span> <span class="o">})</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="k">do</span> <span class="o">(</span><span class="n">lemma_thunks</span><span class="o">,</span> <span class="n">ctx_thunk</span><span class="o">)</span> <span class="bp">←</span> <span class="n">mk_assumption_set'</span> <span class="n">ff</span> <span class="n">hs</span> <span class="n">attr_names</span><span class="o">,</span>        <span class="c1">-- changed in this line</span>
   <span class="n">use</span> <span class="bp">←</span> <span class="n">use.mmap</span> <span class="n">get_local</span><span class="o">,</span>
   <span class="o">(</span><span class="n">tactic.library_search</span>
     <span class="o">{</span> <span class="n">compulsory_hyps</span> <span class="o">:=</span> <span class="n">use</span><span class="o">,</span>
       <span class="n">backtrack_all_goals</span> <span class="o">:=</span> <span class="n">tt</span><span class="o">,</span>
       <span class="n">lemma_thunks</span> <span class="o">:=</span> <span class="n">some</span> <span class="n">lemma_thunks</span><span class="o">,</span>
       <span class="n">ctx_thunk</span> <span class="o">:=</span> <span class="n">ctx_thunk</span><span class="o">,</span>
       <span class="n">md</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">semireducible.is_some</span> <span class="k">then</span>
         <span class="n">tactic.transparency.semireducible</span> <span class="k">else</span> <span class="n">tactic.transparency.reducible</span><span class="o">,</span>
       <span class="bp">..</span><span class="n">opt</span> <span class="o">}</span> <span class="bp">&gt;&gt;=</span>
   <span class="k">if</span> <span class="n">is_trace_enabled_for</span> <span class="bp">`</span><span class="n">silence_library_search</span> <span class="k">then</span>
     <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">skip</span><span class="o">)</span>
   <span class="k">else</span>
     <span class="n">trace</span><span class="o">)</span> <span class="bp">&lt;|&gt;</span>
   <span class="n">fail</span>
<span class="s2">"`library_search` failed.</span>
<span class="s2">If you aren't sure what to do next, you can also</span>
<span class="s2">try `library_search!`, `suggest`, or `hint`.</span>

<span class="s2">Possible reasons why `library_search` failed:</span>
<span class="s2">* `library_search` will only apply a single lemma from the library,</span>
<span class="s2">  and then try to fill in its hypotheses from local hypotheses.</span>
<span class="s2">* If you haven't already, try stating the theorem you want in its own lemma.</span>
<span class="s2">* Sometimes the library has one version of a lemma</span>
<span class="s2">  but not a very similar version obtained by permuting arguments.</span>
<span class="s2">  Try replacing `a + b` with `b + a`, or `a - b &lt; c` with `a &lt; b + c`,</span>
<span class="s2">  to see if maybe the lemma exists but isn't stated quite the way you would like.</span>
<span class="s2">* Make sure that you have all the side conditions for your theorem to be true.</span>
<span class="s2">  For example you won't find `a - b + b = a` for natural numbers in the library because it's false!</span>
<span class="s2">  Search for `b ≤ a → a - b + b = a` instead.</span>
<span class="s2">* If a definition you made is in the goal,</span>
<span class="s2">  you won't find any theorems about it in the library.</span>
<span class="s2">  Try unfolding the definition using `unfold my_definition`.</span>
<span class="s2">* If all else fails, ask on https://leanprover.zulipchat.com/,</span>
<span class="s2">  and maybe we can improve the library and/or `library_search` for next time."</span>

<span class="kd">end</span> <span class="n">interactive</span>

<span class="kd">end</span> <span class="n">tactic</span>

<span class="kd">notation</span> <span class="bp">`</span><span class="o">‹</span><span class="bp">`</span> <span class="n">α</span> <span class="bp">`</span><span class="o">›</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">tactic.the</span> <span class="n">α</span> <span class="n">_</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span><span class="o">:</span> <span class="n">nat</span><span class="o">}</span> <span class="o">(</span><span class="n">this</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">c</span><span class="o">)</span> <span class="o">(</span><span class="n">this</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">d</span><span class="o">)</span> <span class="o">:</span> <span class="n">max</span> <span class="o">(</span><span class="n">c</span> <span class="bp">+</span> <span class="n">d</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">c</span> <span class="bp">+</span> <span class="n">d</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">library_search'</span> <span class="o">[</span><span class="n">add_lt_add</span><span class="o">],</span> <span class="c1">-- Try this: exact max_eq_left_of_lt (add_lt_add ‹a &lt; c› ‹b &lt; d›)</span>
<span class="kd">end</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">this</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">library_search'</span><span class="o">,</span> <span class="c1">-- Try this: exact pos_iff_ne_zero.mpr ‹n ≠ 0›,</span>
<span class="kd">end</span>
</code></pre></div>
</div></div>



<a name="258315115"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Try%20this%3A%20%E2%80%B9_%E2%80%BA/near/258315115" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Try.20this.3A.20.E2.80.B9_.E2.80.BA.html#258315115">(Oct 20 2021 at 05:38)</a>:</h4>
<p>The thing this is working around is the fact that <code>library_search</code> and <code>suggest</code> end up using the pretty printer to make the <code>Try this</code> lines for actual expressions, and as far as I understand it, you can't have <code>‹...›</code> in an elaborated expression because it involves <code>by assumption</code>, which will be expanded.</p>



<a name="258315306"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Try%20this%3A%20%E2%80%B9_%E2%80%BA/near/258315306" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Try.20this.3A.20.E2.80.B9_.E2.80.BA.html#258315306">(Oct 20 2021 at 05:41)</a>:</h4>
<p><span class="user-mention" data-user-id="306601">@Kyle Miller</span> Thanks! Interesting hack (-;</p>



<a name="258315385"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Try%20this%3A%20%E2%80%B9_%E2%80%BA/near/258315385" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Try.20this.3A.20.E2.80.B9_.E2.80.BA.html#258315385">(Oct 20 2021 at 05:42)</a>:</h4>
<p>So somehow we need a post processing step on the pretty printed output that is used for the <code>Try this</code> line.</p>



<a name="258315548"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Try%20this%3A%20%E2%80%B9_%E2%80%BA/near/258315548" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Try.20this.3A.20.E2.80.B9_.E2.80.BA.html#258315548">(Oct 20 2021 at 05:44)</a>:</h4>
<p>Or maybe modify the pretty printer so that if a certain <code>pp</code> flag is set, local constants named <code>this</code> (or whatever the criterion) are instead printed using the <code>‹...›</code> notation? Then this would automatically affect <code>library_search</code>, <code>suggest</code>, etc.</p>



<a name="258315693"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Try%20this%3A%20%E2%80%B9_%E2%80%BA/near/258315693" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Try.20this.3A.20.E2.80.B9_.E2.80.BA.html#258315693">(Oct 20 2021 at 05:46)</a>:</h4>
<p>Ooh! That's an interesting idea. But also sounds like it involves a decent amount of core hacking.</p>



<a name="258317163"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Try%20this%3A%20%E2%80%B9_%E2%80%BA/near/258317163" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Try.20this.3A.20.E2.80.B9_.E2.80.BA.html#258317163">(Oct 20 2021 at 06:08)</a>:</h4>
<p>Assuming we're talking about your proof you posted earlier of the infinitude of primes, which just had a bunch of <code>have : ..., by library_search</code>, I still don't see what's wrong with <code>have h3: ..., by library_search</code>. It's not a sin to manually name hypotheses! Sure mathematicians name hypotheses.</p>
<p>The problem with hacking lean to make it look nicer it that it's not reproducible. There's an old video of Scott's where he proves infinitude of primes, and it's on YouTube, and if you type what he types then it just doesn't work, because he works on a branch which makes it look good but isn't master. I would say that there are disadvantages as well as advantages of presenting something which looks slick but which isn't actually master, in some sense it's deceiving the audience.</p>



<a name="258317636"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Try%20this%3A%20%E2%80%B9_%E2%80%BA/near/258317636" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Try.20this.3A.20.E2.80.B9_.E2.80.BA.html#258317636">(Oct 20 2021 at 06:15)</a>:</h4>
<p>Right, so having a <code>pp</code> flag that "fixes" this is not going to happen before my talk tomorrow. But it still sounds like a nice feature.</p>



<a name="258317711"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Try%20this%3A%20%E2%80%B9_%E2%80%BA/near/258317711" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Try.20this.3A.20.E2.80.B9_.E2.80.BA.html#258317711">(Oct 20 2021 at 06:16)</a>:</h4>
<p>I think that trying to make these proofs look good is a worthwhile exercise. <code>master</code> does have the <code>by_contra'</code> tactic as a result of these attempts.</p>



<a name="258322445"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Try%20this%3A%20%E2%80%B9_%E2%80%BA/near/258322445" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Try.20this.3A.20.E2.80.B9_.E2.80.BA.html#258322445">(Oct 20 2021 at 07:13)</a>:</h4>
<p>Just advertising here that <code>librarySearch</code> in mathlib4 is already a big improvement over the one in mathlib3. It is _fast_. (Thanks Gabriel.)</p>



<a name="258322474"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Try%20this%3A%20%E2%80%B9_%E2%80%BA/near/258322474" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Try.20this.3A.20.E2.80.B9_.E2.80.BA.html#258322474">(Oct 20 2021 at 07:13)</a>:</h4>
<p>(Although it doesn't yet have feature parity, e.g. automatically using both directions on an <code>iff</code>.)</p>



<a name="258322571"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Try%20this%3A%20%E2%80%B9_%E2%80%BA/near/258322571" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Try.20this.3A.20.E2.80.B9_.E2.80.BA.html#258322571">(Oct 20 2021 at 07:14)</a>:</h4>
<p>For demo purposes we really should make an <code>observe</code> tactic as Johan suggested earlier.</p>



<a name="258323079"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Try%20this%3A%20%E2%80%B9_%E2%80%BA/near/258323079" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Try.20this.3A.20.E2.80.B9_.E2.80.BA.html#258323079">(Oct 20 2021 at 07:19)</a>:</h4>
<p>Looking forward to <code>observe4</code>. Maybe I should give a Lean 4 demo, during my talk.</p>



<a name="258323124"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Try%20this%3A%20%E2%80%B9_%E2%80%BA/near/258323124" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Try.20this.3A.20.E2.80.B9_.E2.80.BA.html#258323124">(Oct 20 2021 at 07:19)</a>:</h4>
<p>We can probably get a proof of infinitude of primes up and running in a couple of hours.</p>



<a name="258324702"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Try%20this%3A%20%E2%80%B9_%E2%80%BA/near/258324702" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Try.20this.3A.20.E2.80.B9_.E2.80.BA.html#258324702">(Oct 20 2021 at 07:34)</a>:</h4>
<p>I dunno -- you'll need a bunch of API about primes which probably needs a bunch of API about gcd's...</p>



<a name="258325407"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Try%20this%3A%20%E2%80%B9_%E2%80%BA/near/258325407" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Try.20this.3A.20.E2.80.B9_.E2.80.BA.html#258325407">(Oct 20 2021 at 07:41)</a>:</h4>
<p>What is this <code>observe</code> tactic?  I looked through your comments Johann, but I didn't find a tactic suggestion (besides making library search print correct syntax).</p>



<a name="258325736"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Try%20this%3A%20%E2%80%B9_%E2%80%BA/near/258325736" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Try.20this.3A.20.E2.80.B9_.E2.80.BA.html#258325736">(Oct 20 2021 at 07:44)</a>:</h4>
<p>I think <code>observe X</code> might just be <code>have : X, by library_search</code></p>



<a name="258325793"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Try%20this%3A%20%E2%80%B9_%E2%80%BA/near/258325793" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Try.20this.3A.20.E2.80.B9_.E2.80.BA.html#258325793">(Oct 20 2021 at 07:45)</a>:</h4>
<p>It's just to make tactic scripts look less scary to mathematicians</p>



<a name="258326205"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Try%20this%3A%20%E2%80%B9_%E2%80%BA/near/258326205" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Try.20this.3A.20.E2.80.B9_.E2.80.BA.html#258326205">(Oct 20 2021 at 07:49)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/issues/9820">#9820</a> adds an option field so that "Try this"-lines can be disabled on a one-by-one basis in <code>suggest</code> and <code>library_search</code>. (It's not so useful for <code>suggest</code>, I know.)</p>



<a name="258326235"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Try%20this%3A%20%E2%80%B9_%E2%80%BA/near/258326235" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Try.20this.3A.20.E2.80.B9_.E2.80.BA.html#258326235">(Oct 20 2021 at 07:49)</a>:</h4>
<p><span class="user-mention" data-user-id="110043">@Gabriel Ebner</span> <code>observe</code> was in another thread. Let me find it.</p>



<a name="258326370"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Try%20this%3A%20%E2%80%B9_%E2%80%BA/near/258326370" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Try.20this.3A.20.E2.80.B9_.E2.80.BA.html#258326370">(Oct 20 2021 at 07:51)</a>:</h4>
<p>Voila: <a href="#narrow/stream/113488-general/topic/proof_by_contra/near/256598946">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/proof_by_contra/near/256598946</a></p>



<a name="258326444"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Try%20this%3A%20%E2%80%B9_%E2%80%BA/near/258326444" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Try.20this.3A.20.E2.80.B9_.E2.80.BA.html#258326444">(Oct 20 2021 at 07:51)</a>:</h4>
<p>With <a href="https://github.com/leanprover-community/mathlib/issues/9820">#9820</a>, <code>observe : foo</code> would be <code>have  : foo, by library_search { try_this := ff }</code>.</p>



<a name="258326565"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Try%20this%3A%20%E2%80%B9_%E2%80%BA/near/258326565" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Try.20this.3A.20.E2.80.B9_.E2.80.BA.html#258326565">(Oct 20 2021 at 07:52)</a>:</h4>
<p>because mathematicians all know how to prove it :-) and seeing that it's <code>apply set.subset_inter_comm</code> is not something they need to know :-)</p>



<a name="258326726"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Try%20this%3A%20%E2%80%B9_%E2%80%BA/near/258326726" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Try.20this.3A.20.E2.80.B9_.E2.80.BA.html#258326726">(Oct 20 2021 at 07:54)</a>:</h4>
<p>And least not during their first romantic date with Lean <span aria-label="smiley" class="emoji emoji-1f603" role="img" title="smiley">:smiley:</span></p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
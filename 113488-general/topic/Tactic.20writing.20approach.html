---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/Tactic.20writing.20approach.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tactic.20writing.20approach.html">Tactic writing approach</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="200914280"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tactic%20writing%20approach/near/200914280" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tactic.20writing.20approach.html#200914280">(Jun 15 2020 at 16:39)</a>:</h4>
<p>I decided to give tactic writing a serious go recently, so as an exercise I wrote a tactic to prove equality of group expressions. I did it without using the simplifier so it would not be a trivial exercise. Code <a href="https://gist.github.com/ChrisHughes24/56ae39e65792b87780d7cf1d3d2ee640">here</a>. The approach I tried was to define the type <code>group_term</code>, and the define an inductive relation <code>rel</code> on <code>group_term</code> that said they were equal as group elements. </p>
<div class="codehilite"><pre><span></span><code><span class="bp">@</span><span class="o">[</span><span class="n">derive</span> <span class="n">decidable_eq</span><span class="o">,</span> <span class="n">derive</span> <span class="n">has_reflect</span><span class="o">]</span> <span class="kn">inductive</span> <span class="n">group_term</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">of</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">group_term</span>
<span class="bp">|</span> <span class="n">one</span> <span class="o">:</span> <span class="n">group_term</span>
<span class="bp">|</span> <span class="n">mul</span> <span class="o">:</span> <span class="n">group_term</span> <span class="bp">→</span> <span class="n">group_term</span> <span class="bp">→</span> <span class="n">group_term</span>
<span class="bp">|</span> <span class="n">inv</span> <span class="o">:</span> <span class="n">group_term</span> <span class="bp">→</span> <span class="n">group_term</span>
</code></pre></div>


<p>The relation <code>rel</code> was defined to be in <code>Type</code> rather than <code>Prop</code>. I defined a function that would return the term of type <code>option (rel a b)</code>, returning <code>some</code> whenever <code>a</code> and <code>b</code> were equal as group elements. This function in principal need not be a meta function, it is in my example, but only because I didn't prove termination. I wrote a tactic <code>suffices_rel</code> that given an equality in a group, proved that it suffices to prove two explicit <code>group_term</code>s were <code>rel</code>. I wrote a <code>reflect : rel a v -&gt; expr</code>, and once my goal was to prove <code>rel a b</code>, I could compute the term of type <code>rel</code> and reflect it. This approach worked and I have a group tactic.</p>
<p>My questions are</p>
<ol>
<li>
<p>When writing a tactic that solves non trivial maths problems, is it a sensible approach to write a non-meta program that does the hard work of solving the maths problem and producing a certificate, and then a small amount of meta code interfacing this with the tactic state? I find it very ugly to have stuff about meta objects mixed in with code that solves a maths problem that has nothing to do with any meta objects. Maybe equality of group expressions is too trivial for this approach, but is it sensible for harder problems?</p>
</li>
<li>
<p>Why is my <code>group_tac</code> so slow? It seems like most of the time is spent on <code>rel.reflect</code> reflecting the certificate, not actually computing the certificate. The derive handler doesn't work for dependent types, so I my own <code>reflect</code> function.</p>
</li>
</ol>



<a name="200914674"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tactic%20writing%20approach/near/200914674" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tactic.20writing.20approach.html#200914674">(Jun 15 2020 at 16:42)</a>:</h4>
<p>You don't have enough type of group terms. What about <code>g^n</code>?</p>



<a name="200914854"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tactic%20writing%20approach/near/200914854" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tactic.20writing.20approach.html#200914854">(Jun 15 2020 at 16:44)</a>:</h4>
<p>This is an exercise, so I didn't bother with that</p>



<a name="200928538"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tactic%20writing%20approach/near/200928538" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tactic.20writing.20approach.html#200928538">(Jun 15 2020 at 18:36)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110044">Chris Hughes</span> <a href="#narrow/stream/113488-general/topic/Tactic.20writing.20approach/near/200914280">said</a>:</p>
<blockquote>
<ol>
<li>When writing a tactic that solves non trivial maths problems, is it a sensible approach to write a non-meta program that does the hard work of solving the maths problem and producing a certificate, and then a small amount of meta code interfacing this with the tactic state? I find it very ugly to have stuff about meta objects mixed in with code that solves a maths problem that has nothing to do with any meta objects. Maybe equality of group expressions is too trivial for this approach, but is it sensible for harder problems?</li>
</ol>
</blockquote>
<p>Yes, this can be sensible. It's the approach taken by <code>omega</code>, and used quite a bit in Coq. I think the general sense we have is that producing and checking proof terms is faster in Lean than relying on kernel reduction. (The Coq people warn about impossibly large expressions doing this.) <code>ring2</code> uses proof by reflection like you describe, but Mario concluded a while ago that he couldn't make it as fast as <code>ring</code> which produces proof terms.</p>



<a name="200928616"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tactic%20writing%20approach/near/200928616" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tactic.20writing.20approach.html#200928616">(Jun 15 2020 at 18:37)</a>:</h4>
<p>Lean will be particularly slow evaluating anything defined non-meta with well-founded recursion, even if you're evaluating in the VM. <span class="user-mention" data-user-id="110043">@Gabriel Ebner</span> pointed this out to me very recently.</p>



<a name="200928763"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tactic%20writing%20approach/near/200928763" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tactic.20writing.20approach.html#200928763">(Jun 15 2020 at 18:39)</a>:</h4>
<p>I'll see if I can find the slow part of your code when I have a chance, probably not tonight though.</p>



<a name="200930249"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tactic%20writing%20approach/near/200930249" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tactic.20writing.20approach.html#200930249">(Jun 15 2020 at 18:53)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110596">Rob Lewis</span> <a href="#narrow/stream/113488-general/topic/Tactic.20writing.20approach/near/200928538">said</a>:</p>
<blockquote>
<p>I think the general sense we have is that producing and checking proof terms is faster in Lean than relying on kernel reduction. </p>
</blockquote>
<p>I didn't mean to rely on kernel reduction. The <code>group_tac</code> I wrote reflects a term of type <code>rel _ _</code>, but it shouldn't be any work to type check this term. It seems easier to me to define an inductive language capable of proving only the problems I'm interested in, which is a far simpler type than a Lean <code>expr</code>, and prove soundness. I can reflect a term of this type at the end to give the Lean proofs. This seems easier because you're guaranteed that whatever it comes up with will type check, and you won't be using meta constants which I don't understand the precise behaviour of and give me <code>app_builder</code> errors.</p>



<a name="200931536"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tactic%20writing%20approach/near/200931536" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jannis Limperg <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tactic.20writing.20approach.html#200931536">(Jun 15 2020 at 19:06)</a>:</h4>
<p>Your approach is fairly close to the well-known recipe for "proof by reflection" (with some divergence where you move into meta land; typical proof by reflection would implement the decision procedure as a non-meta function and prove it sound). Rob already points out some of the Lean-specific performance issues, which I assume could be solved with more engineering hours; I'll add some more conceptual considerations:</p>
<ul>
<li>This approach is fairly closed: you have to define the entire language of your problem up front. Contrast this with tactics, where you can often provide 'hooks' that allow people to fill in their own domain-specific simplification strategies or whatever. There's research into compositional proof by reflection, but that's a big hammer.</li>
<li>You usually want to have a notion of 'uninterpreted term' in your <code>group_term</code> language. An uninterpreted term is an arbitrary inhabitant of the group you're interested in (e.g. Patrick's <code>g^n</code>) which you treat as a constant. You never inspect these terms; you just carry them around. This allows you to work with terms that don't strictly fit into your little language. Adding this is not too hard, but may lead to some technical issues.</li>
<li>The complexity of this approach really blows up when you move into expression languages with more than one type. Your <code>group_term</code>s are unityped: every <code>group_term</code> denotes an element of some given group. But if you try to scale this to, say, a simplification procedure for category theoretic expressions, you now need expressions that denote elements of a category, other elements that denote arrows between specific elements, other elements that denote functors between specific categories, etc. In the extreme, you're implementing a type checker for a little dependently typed language, which is well known to be unpleasant. (I tried this in Agda once and walked away with little to show for it.)</li>
<li>In particular, when you want to deal with things at different universe levels (e.g. categories), you're probably just screwed. In Agda, I still have some hope since it has first-class universe expressions, but Lean is much  more restrictive in this regard.</li>
</ul>
<p>I'm being maybe a little too critical here -- when the approach works, it's very nice and elegant (and fast if your computation is fast). But these limitations make me sceptical about scaling from toy problems to bigger domains.</p>



<a name="200932841"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tactic%20writing%20approach/near/200932841" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tactic.20writing.20approach.html#200932841">(Jun 15 2020 at 19:18)</a>:</h4>
<blockquote>
<p>ring2 uses proof by reflection like you describe, but Mario concluded a while ago that he couldn't make it as fast as ring which produces proof terms.</p>
</blockquote>
<p>Actually there is a further distinction to be made here. One option is to have an inductive type that represents some kind of certificate and write non-meta functions over them and evaluate them in the VM as part of tactic execution. This is what omega does, and I would recommend it especially if you need to perform some nontrivial computation / search before actually producing the result. I don't use this method in <code>ring</code> mainly because it is almost entirely doing straight "consume input expr -&gt; produce proof" and so there is little to be gained by an intermediate type that would still need to be translated to and from expr.</p>
<p><code>ring2</code> is doing something different, what is called computational (large-scale) reflection in the Coq community. This is characterized by a "heavy rfl" proof after some small reification step; this means the evaluation of the non-meta function is being done in the kernel instead of the VM, and the emitted proof is small (essentially constant size no matter the complexity of the algorithm). In order to make this efficient in lean you need to use careful data structures (many of the usual data structures in the library are inefficient because they carry proofs as invariants or use a pathologically bad encoding e.g. <code>nat</code>), and even then it's slower than VM evaluation by a small margin.</p>



<a name="200933110"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tactic%20writing%20approach/near/200933110" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tactic.20writing.20approach.html#200933110">(Jun 15 2020 at 19:21)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110596">Rob Lewis</span> <a href="#narrow/stream/113488-general/topic/Tactic.20writing.20approach/near/200928616">said</a>:</p>
<blockquote>
<p>Lean will be particularly slow evaluating anything defined non-meta with well-founded recursion, even if you're evaluating in the VM. <span class="user-mention silent" data-user-id="110043">Gabriel Ebner</span> pointed this out to me very recently.</p>
</blockquote>
<p>This is news to me. My understanding was that the VM uses the same method for compiling non-meta wf (or other eqn compiler) recursions as for meta recursions, namely unguarded recursion. What is the cause for the performance gap?</p>



<a name="200933718"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tactic%20writing%20approach/near/200933718" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tactic.20writing.20approach.html#200933718">(Jun 15 2020 at 19:26)</a>:</h4>
<p>It was always planned, but then Lean 4 came along IIRC.  The reason is that the VM compilation happens long after the equation compiler is finished with them and has added the WF-encoding to the environment.  Meta declarations are added without translation to the environment (using the <code>rec_fn_macro</code>).</p>



<a name="200933810"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tactic%20writing%20approach/near/200933810" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tactic.20writing.20approach.html#200933810">(Jun 15 2020 at 19:27)</a>:</h4>
<p>I'm not sure if there is a difference with <em>unary</em> well-founded functions, but for binary functions the encoding causes a big slowdown in the VM.</p>



<a name="200933845"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tactic%20writing%20approach/near/200933845" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tactic.20writing.20approach.html#200933845">(Jun 15 2020 at 19:27)</a>:</h4>
<p>I'm trying to do deciding single relation on a group tactic, i.e. given <code>t₁ = t₂</code> in a group, prove <code>t₃ = t₄</code>. This doesn't seem to have the problems that Jannis pointed out, everything will just be one type, although there is more than one group involved, so multiple Types. It also seems to be mostly just a computation, so I guess the heavy rfl approach might be best.</p>



<a name="200934321"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tactic%20writing%20approach/near/200934321" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tactic.20writing.20approach.html#200934321">(Jun 15 2020 at 19:31)</a>:</h4>
<p>From what I can tell, I think an approach like <code>ring</code> would be the most efficient. One thing that is "searchy" about the algorithm is identity testing: you have to determine whether to apply a cancellation rule or not, when the proof should just do it without a test</p>



<a name="200934507"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tactic%20writing%20approach/near/200934507" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tactic.20writing.20approach.html#200934507">(Jun 15 2020 at 19:33)</a>:</h4>
<p>What is the approach of ring?</p>



<a name="200934540"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tactic%20writing%20approach/near/200934540" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tactic.20writing.20approach.html#200934540">(Jun 15 2020 at 19:33)</a>:</h4>
<p>Pattern match on the expression, apply small step proof rules recursively</p>



<a name="200934612"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tactic%20writing%20approach/near/200934612" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tactic.20writing.20approach.html#200934612">(Jun 15 2020 at 19:34)</a>:</h4>
<p>this is very straightforward for <code>group</code></p>



<a name="200934629"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tactic%20writing%20approach/near/200934629" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tactic.20writing.20approach.html#200934629">(Jun 15 2020 at 19:34)</a>:</h4>
<p>The single relation tactic is not straightforward.</p>



<a name="200934654"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tactic%20writing%20approach/near/200934654" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tactic.20writing.20approach.html#200934654">(Jun 15 2020 at 19:34)</a>:</h4>
<p>Single relation?</p>



<a name="200934678"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tactic%20writing%20approach/near/200934678" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tactic.20writing.20approach.html#200934678">(Jun 15 2020 at 19:34)</a>:</h4>
<p>you know one relation and you're trying to prove an identity</p>



<a name="200934705"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tactic%20writing%20approach/near/200934705" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tactic.20writing.20approach.html#200934705">(Jun 15 2020 at 19:35)</a>:</h4>
<p>oh I missed the context</p>



<a name="200934710"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tactic%20writing%20approach/near/200934710" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tactic.20writing.20approach.html#200934710">(Jun 15 2020 at 19:35)</a>:</h4>
<p>Given <code>t₁ = t₂</code> prove <code>t₃ = t₄</code></p>



<a name="200934715"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tactic%20writing%20approach/near/200934715" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tactic.20writing.20approach.html#200934715">(Jun 15 2020 at 19:35)</a>:</h4>
<p>e.g. if you know ab=ba you want to be able to deduce a^2b^3=b^3a^2</p>



<a name="200934741"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tactic%20writing%20approach/near/200934741" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tactic.20writing.20approach.html#200934741">(Jun 15 2020 at 19:35)</a>:</h4>
<p>or if you know abcd=1 you want to be able to deduce cdab=1</p>



<a name="200934881"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tactic%20writing%20approach/near/200934881" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tactic.20writing.20approach.html#200934881">(Jun 15 2020 at 19:36)</a>:</h4>
<p>That's true, but you still only need data structures other than <code>expr</code> when you are trying to remember your place in the algorithm</p>



<a name="200934941"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tactic%20writing%20approach/near/200934941" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tactic.20writing.20approach.html#200934941">(Jun 15 2020 at 19:36)</a>:</h4>
<p>The general pattern is to use <code>expr</code> for the input and the output (because you have to) and use custom data structures for everything else</p>



<a name="200934962"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tactic%20writing%20approach/near/200934962" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tactic.20writing.20approach.html#200934962">(Jun 15 2020 at 19:37)</a>:</h4>
<p>I don't fully understand the algorithm yet, but the very approximate gist is to keep changing the basis of the free group, until your relation is a generator.</p>



<a name="200934964"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tactic%20writing%20approach/near/200934964" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tactic.20writing.20approach.html#200934964">(Jun 15 2020 at 19:37)</a>:</h4>
<p>and don't produce any proof terms that are not a syntactic match (i.e. no heavy rfl)</p>



<a name="200934993"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tactic%20writing%20approach/near/200934993" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tactic.20writing.20approach.html#200934993">(Jun 15 2020 at 19:37)</a>:</h4>
<p>the kernel never sees your data structures, it sees you applying theorems about groups</p>



<a name="200935000"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tactic%20writing%20approach/near/200935000" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tactic.20writing.20approach.html#200935000">(Jun 15 2020 at 19:37)</a>:</h4>
<p>So defining my mini inductive language would be sensible?</p>



<a name="200935122"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tactic%20writing%20approach/near/200935122" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tactic.20writing.20approach.html#200935122">(Jun 15 2020 at 19:38)</a>:</h4>
<p>The certificate may well just be a list of conjugates of my relation and it's inverse that my goal is the product of.</p>



<a name="200935168"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tactic%20writing%20approach/near/200935168" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tactic.20writing.20approach.html#200935168">(Jun 15 2020 at 19:39)</a>:</h4>
<p>It may be, but I suspect that you can straightforwardly compose <code>snormalize</code> and <code>rel.reflect</code> and skip the middle man</p>



<a name="200935277"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tactic%20writing%20approach/near/200935277" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tactic.20writing.20approach.html#200935277">(Jun 15 2020 at 19:40)</a>:</h4>
<p>For the single relation tactic I mean. I'm sure that <code>group_tac</code> is not optimised, and it's more to test the approach.</p>



<a name="200935304"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tactic%20writing%20approach/near/200935304" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tactic.20writing.20approach.html#200935304">(Jun 15 2020 at 19:40)</a>:</h4>
<p>I would only suggest using <code>rel</code> if you are constructing proofs that you sometimes discard</p>



<a name="200935360"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tactic%20writing%20approach/near/200935360" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tactic.20writing.20approach.html#200935360">(Jun 15 2020 at 19:41)</a>:</h4>
<p>in a lot of cases if you structure the control flow of the tactic right everything you construct will appear in the final proof so there is no need</p>



<a name="200935491"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tactic%20writing%20approach/near/200935491" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tactic.20writing.20approach.html#200935491">(Jun 15 2020 at 19:42)</a>:</h4>
<p>I don't actually know the one relation algorithm, so I can't comment on the difficulty (besides noting that the paper I recall seeing seemed pretty long)</p>



<a name="200935829"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tactic%20writing%20approach/near/200935829" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tactic.20writing.20approach.html#200935829">(Jun 15 2020 at 19:45)</a>:</h4>
<p>Supervising an MSc project has never been so easy!</p>



<a name="200936111"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tactic%20writing%20approach/near/200936111" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tactic.20writing.20approach.html#200936111">(Jun 15 2020 at 19:47)</a>:</h4>
<p>Reading the code, I see that you are relying on kernel reduction for evaluating <code>eval</code>, which is not horrible but probably not a great idea</p>



<a name="200936283"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tactic%20writing%20approach/near/200936283" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tactic.20writing.20approach.html#200936283">(Jun 15 2020 at 19:48)</a>:</h4>
<p>You also forgot to use <code>id_rhs</code> to protect the target type. If you return an expression of the wrong type it might unfold in an unfavorable way</p>



<a name="200936618"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tactic%20writing%20approach/near/200936618" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tactic.20writing.20approach.html#200936618">(Jun 15 2020 at 19:50)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113488-general/topic/Tactic.20writing.20approach/near/200936283">said</a>:</p>
<blockquote>
<p>You also forgot to use <code>id_rhs</code> to protect the target type. If you return an expression of the wrong type it might unfold in an unfavorable way</p>
</blockquote>
<p>Where should I have used <code>id_rhs</code>?</p>



<a name="200936694"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tactic%20writing%20approach/near/200936694" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tactic.20writing.20approach.html#200936694">(Jun 15 2020 at 19:51)</a>:</h4>
<p>Just before the exact on L224</p>



<a name="200936737"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tactic%20writing%20approach/near/200936737" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tactic.20writing.20approach.html#200936737">(Jun 15 2020 at 19:51)</a>:</h4>
<p>I think there is a function that wraps this pattern up</p>



<a name="200937040"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tactic%20writing%20approach/near/200937040" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tactic.20writing.20approach.html#200937040">(Jun 15 2020 at 19:53)</a>:</h4>
<p>there is <code>mk_id_proof</code> although that just uses <code>id</code>. I think it should work</p>



<a name="200937147"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tactic%20writing%20approach/near/200937147" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tactic.20writing.20approach.html#200937147">(Jun 15 2020 at 19:54)</a>:</h4>
<p>you give it your proof and the type you want it to have (which is different from the inferred type, resulting in kernel computation of the <code>eval</code> function)</p>



<a name="200937176"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tactic%20writing%20approach/near/200937176" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tactic.20writing.20approach.html#200937176">(Jun 15 2020 at 19:54)</a>:</h4>
<p>and <code>nth</code>, etc</p>



<a name="200937578"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tactic%20writing%20approach/near/200937578" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tactic.20writing.20approach.html#200937578">(Jun 15 2020 at 19:57)</a>:</h4>
<p>You also have an <code>eq.rec_on</code> in your <code>snormalize</code>. I'm not really sure what happens there once it gets reflected. It's a bit weird that <code>rel</code> is dependent type here</p>



<a name="200938033"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tactic%20writing%20approach/near/200938033" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tactic.20writing.20approach.html#200938033">(Jun 15 2020 at 20:00)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113488-general/topic/Tactic.20writing.20approach/near/200937578">said</a>:</p>
<blockquote>
<p>You also have an <code>eq.rec_on</code> in your <code>snormalize</code>. I'm not really sure what happens there once it gets reflected. It's a bit weird that <code>rel</code> is dependent type here</p>
</blockquote>
<p>I agree it's a bit weird, that's why I asked about it, particularly given that there's no handler for <code>derive reflect</code> for dependent types. I thought the <code>eq.rec_on</code> was okay, because I'm doing basically nothing with to make a <code>group_term</code> other than applying constructors, and using no functions on <code>nat</code>, so it's going to typecheck easily.</p>



<a name="200938257"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tactic%20writing%20approach/near/200938257" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tactic.20writing.20approach.html#200938257">(Jun 15 2020 at 20:02)</a>:</h4>
<p>I realised there would be a problem if the <code>eq.rec_on</code> used <code>funext</code>, and the type depended on a function, or similar with <code>Prop</code> and <code>propext</code>, but it should be fine with an inductive type like <code>group_term</code>.</p>



<a name="200938333"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tactic%20writing%20approach/near/200938333" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tactic.20writing.20approach.html#200938333">(Jun 15 2020 at 20:03)</a>:</h4>
<p>I think any <code>eq.rec_on</code> could be problematic if it's not definitional in the result</p>



<a name="200938439"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tactic%20writing%20approach/near/200938439" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tactic.20writing.20approach.html#200938439">(Jun 15 2020 at 20:04)</a>:</h4>
<p>because the <code>has_reflect</code> instance doesn't know to add them back and will likely produce a not well typed term</p>



<a name="200938449"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tactic%20writing%20approach/near/200938449" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tactic.20writing.20approach.html#200938449">(Jun 15 2020 at 20:04)</a>:</h4>
<p>When will it not be definitional in the result? Provided it's an inductive type without <code>pi</code> types or <code>Sort</code>s as constructors it should be fine right?</p>



<a name="200938486"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tactic%20writing%20approach/near/200938486" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tactic.20writing.20approach.html#200938486">(Jun 15 2020 at 20:04)</a>:</h4>
<p>If it's any random equality, from the context or something</p>



<a name="200938505"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Tactic%20writing%20approach/near/200938505" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Tactic.20writing.20approach.html#200938505">(Jun 15 2020 at 20:04)</a>:</h4>
<p>If two <code>group_term</code>s are equal they're defeq right?</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
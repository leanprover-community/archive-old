---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/ZF-style.20functions.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ZF-style.20functions.html">ZF-style functions</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="254004942"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ZF-style%20functions/near/254004942" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ZF-style.20functions.html#254004942">(Sep 20 2021 at 06:53)</a>:</h4>
<p>I guess this has been discussed many times but I'd like to be sure. In Lean's foundation, is there any way to turn a functional relation into a function without using extra axioms (especially choice)?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">foo</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">β</span><span class="o">)}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="bp">∃!</span> <span class="n">b</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>



<a name="254007130"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ZF-style%20functions/near/254007130" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ZF-style.20functions.html#254007130">(Sep 20 2021 at 07:16)</a>:</h4>
<p>You can't move from <code>Prop</code> to <code>Type</code> without AC so I'm pretty sure the answer to your question is "no". My understanding is that in ZFC you can do it but not here.</p>



<a name="254007302"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ZF-style%20functions/near/254007302" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ZF-style.20functions.html#254007302">(Sep 20 2021 at 07:18)</a>:</h4>
<p>It's equivalent to unique choice</p>



<a name="254007359"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ZF-style%20functions/near/254007359" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ZF-style.20functions.html#254007359">(Sep 20 2021 at 07:19)</a>:</h4>
<p>which is derivable in ZF but requires additional axioms in lean</p>



<a name="254007475"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ZF-style%20functions/near/254007475" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ZF-style.20functions.html#254007475">(Sep 20 2021 at 07:20)</a>:</h4>
<p>saying it "requires choice" is not really true, you can do it with genuinely weaker axioms, but if you want to say which of the three official axioms you would need to prove it, yes you need choice</p>



<a name="254007625"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ZF-style%20functions/near/254007625" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ZF-style.20functions.html#254007625">(Sep 20 2021 at 07:21)</a>:</h4>
<p>Ok, this is what I had in mind when writing a message. But it never occurred to me before than differences between ZF and CIC would impact such a basic thing.</p>



<a name="254007770"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ZF-style%20functions/near/254007770" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ZF-style.20functions.html#254007770">(Sep 20 2021 at 07:23)</a>:</h4>
<p>The specific context I had was defining the function induced on a quotient (lifted in our non-sensical terminology). I always explained this using a section of the quotient, which requires choice. But I realized that defining the associated relation doesn't seem to require axioms.</p>



<a name="254007839"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ZF-style%20functions/near/254007839" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ZF-style.20functions.html#254007839">(Sep 20 2021 at 07:24)</a>:</h4>
<p>One way to think about ZF is that it's like CIC but where everything is in a <code>Prop</code> context, since it's all sets. So every function is really a functional relation, and every set is a predicate</p>



<a name="254007905"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ZF-style%20functions/near/254007905" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ZF-style.20functions.html#254007905">(Sep 20 2021 at 07:24)</a>:</h4>
<p>If <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi><mo>:</mo><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">\pi : X \to Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span> is surjective with associated relation <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∼</mo></mrow><annotation encoding="application/x-tex">\sim</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">∼</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>X</mi><mo>→</mo><mi>Z</mi></mrow><annotation encoding="application/x-tex">f : X \to Z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span></span></span></span> is compatible with <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∼</mo></mrow><annotation encoding="application/x-tex">\sim</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">∼</span></span></span></span> then you can define <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>f</mi><mo>ˉ</mo></mover></mrow><annotation encoding="application/x-tex">\bar f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0256599999999998em;vertical-align:-0.19444em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8312199999999998em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span><span style="top:-3.26344em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.08332999999999999em;"><span class="mord">ˉ</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span></span></span> as a relation as <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mo stretchy="false">(</mo><mi>y</mi><mo separator="true">,</mo><mi>z</mi><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∀</mi><mi>x</mi><mo separator="true">,</mo><mi>π</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>y</mi><mtext>  </mtext><mo>⟹</mo><mtext>  </mtext><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>z</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{(y, z) | \forall x, \pi(x) = y \implies f(x) = z\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mclose">)</span><span class="mord">∣∀</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7194400000000001em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⟹</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mclose">}</span></span></span></span></p>



<a name="254007968"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ZF-style%20functions/near/254007968" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ZF-style.20functions.html#254007968">(Sep 20 2021 at 07:25)</a>:</h4>
<p>Sorry about the notation mess while I edited the above message</p>



<a name="254008134"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ZF-style%20functions/near/254008134" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ZF-style.20functions.html#254008134">(Sep 20 2021 at 07:27)</a>:</h4>
<p>Yes, set-quotients in CIC need unique choice</p>



<a name="254008290"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ZF-style%20functions/near/254008290" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ZF-style.20functions.html#254008290">(Sep 20 2021 at 07:29)</a>:</h4>
<p>You can live with just having a functional relation instead of a function though. That's sort of what I mean about ZF, it's basically doing this for everything in the language so nothing is "data" and everything is (vacuously) "computable"</p>



<a name="254008392"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ZF-style%20functions/near/254008392" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ZF-style.20functions.html#254008392">(Sep 20 2021 at 07:30)</a>:</h4>
<p>so "data" is some kind of added thing in CIC</p>



<a name="254009106"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ZF-style%20functions/near/254009106" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ZF-style.20functions.html#254009106">(Sep 20 2021 at 07:38)</a>:</h4>
<p>Thanks</p>



<a name="254009226"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ZF-style%20functions/near/254009226" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ZF-style.20functions.html#254009226">(Sep 20 2021 at 07:39)</a>:</h4>
<p>If you have <code>fintype α</code> then you can use <a href="https://leanprover-community.github.io/mathlib_docs/find/fintype.choose">docs#fintype.choose</a> to get your function</p>



<a name="254009364"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ZF-style%20functions/near/254009364" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ZF-style.20functions.html#254009364">(Sep 20 2021 at 07:40)</a>:</h4>
<p>Of course I understand all those questions are vacuous in a finite context.</p>



<a name="254068815"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ZF-style%20functions/near/254068815" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ZF-style.20functions.html#254068815">(Sep 20 2021 at 15:32)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/erased">docs#erased</a> turns out to be a way to work with "classical" values, if that's something you'd be willing to use. (The name "erased" has to do with how it's represented internally by Lean.  It probably could stand to have a more intuitive name that means "I am thinking of a specific term, but I can't tell you what it is.")</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.erased</span>

<span class="sd">/-- Short version, uses the axiom of choice but is still not noncomputable. -/</span>
<span class="kd">def</span> <span class="n">foo</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">β</span><span class="o">)}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="bp">∃!</span> <span class="n">b</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">erased</span> <span class="n">β</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="o">(</span><span class="n">h</span> <span class="n">x</span><span class="o">)</span><span class="bp">.</span><span class="n">some</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span>

<span class="sd">/-- Longer version, does not use the axiom of choice. -/</span>
<span class="kd">def</span> <span class="n">foo'</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">β</span><span class="o">)}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="bp">∃!</span> <span class="n">b</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">erased</span> <span class="n">β</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="o">⟨(</span><span class="bp">λ</span> <span class="n">b</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">),</span> <span class="kd">begin</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">b</span><span class="o">,</span> <span class="n">hb</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">h</span> <span class="n">a</span><span class="o">,</span>
  <span class="n">use</span> <span class="n">b</span><span class="o">,</span>
  <span class="n">ext</span> <span class="n">y</span><span class="o">,</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rintro</span> <span class="n">rfl</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">hb.1</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">intro</span> <span class="n">h'</span><span class="o">,</span>
    <span class="n">exact</span> <span class="o">(</span><span class="n">hb.2</span> <span class="n">y</span> <span class="n">h'</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="o">,</span> <span class="o">},</span>
<span class="kd">end</span><span class="o">⟩</span>

<span class="c1">-- erased.out is what noncomputably extracts the value from erased,</span>
<span class="c1">-- and we can check the above definitions are correct with respect</span>
<span class="c1">-- to foo'':</span>

<span class="kd">noncomputable</span>
<span class="kd">def</span> <span class="n">foo''</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">β</span><span class="o">)}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="bp">∃!</span> <span class="n">b</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="o">(</span><span class="n">h</span> <span class="n">a</span><span class="o">)</span><span class="bp">.</span><span class="n">some</span>

<span class="kd">lemma</span> <span class="n">foo_prop</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">β</span><span class="o">)}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="bp">∃!</span> <span class="n">b</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">foo</span> <span class="n">h</span> <span class="n">a</span><span class="o">)</span><span class="bp">.</span><span class="n">out</span> <span class="bp">=</span> <span class="n">foo''</span> <span class="n">h</span> <span class="n">a</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">change</span> <span class="o">(</span><span class="n">erased.out</span> <span class="o">(</span><span class="n">erased.mk</span> <span class="n">_</span><span class="o">))</span> <span class="bp">=</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">foo''</span><span class="o">],</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">foo'_prop</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">β</span><span class="o">)}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="bp">∃!</span> <span class="n">b</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">foo'</span> <span class="n">h</span> <span class="n">a</span><span class="o">)</span><span class="bp">.</span><span class="n">out</span> <span class="bp">=</span> <span class="n">foo''</span> <span class="n">h</span> <span class="n">a</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">convert</span> <span class="n">foo_prop</span> <span class="n">h</span> <span class="n">a</span> <span class="n">using</span> <span class="mi">2</span><span class="o">,</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">foo</span><span class="o">,</span> <span class="n">foo'</span><span class="o">],</span>
  <span class="n">congr</span><span class="o">,</span>
  <span class="n">ext</span> <span class="n">y</span><span class="o">,</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intro</span> <span class="n">h'</span><span class="o">,</span>
    <span class="n">exact</span> <span class="o">((</span><span class="n">h</span> <span class="n">a</span><span class="o">)</span><span class="bp">.</span><span class="n">some_spec.2</span> <span class="n">y</span> <span class="n">h'</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rintro</span> <span class="n">rfl</span><span class="o">,</span>
    <span class="n">exact</span> <span class="o">(</span><span class="n">h</span> <span class="n">a</span><span class="o">)</span><span class="bp">.</span><span class="n">some_spec.1</span><span class="o">,</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>



<a name="254070817"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ZF-style%20functions/near/254070817" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ZF-style.20functions.html#254070817">(Sep 20 2021 at 15:42)</a>:</h4>
<p>How does obtain work without choice?</p>



<a name="254071259"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ZF-style%20functions/near/254071259" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ZF-style.20functions.html#254071259">(Sep 20 2021 at 15:45)</a>:</h4>
<p>The goal is a <code>Prop</code>, so it can eliminate the existential.</p>



<a name="254104062"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ZF-style%20functions/near/254104062" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ZF-style.20functions.html#254104062">(Sep 20 2021 at 19:24)</a>:</h4>
<p>Thanks Kyle. I should have clarified that my question wasn't a Lean question. I was only interested in the abstract foundation question.</p>



<a name="254109494"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ZF-style%20functions/near/254109494" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ZF-style.20functions.html#254109494">(Sep 20 2021 at 20:05)</a>:</h4>
<p>Using propositional truncation instead of the <code>Prop</code> universe, it can be defined</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.quot</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">X</span> <span class="bp">×</span> <span class="n">Y</span><span class="o">))</span>
  <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">,</span> <span class="n">trunc</span> <span class="o">{</span> <span class="n">y</span> <span class="o">:</span> <span class="n">Y</span> <span class="bp">//</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">f</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="n">z</span><span class="o">,</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">z</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">f</span> <span class="bp">→</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">y</span><span class="o">})</span> <span class="o">:</span>
  <span class="n">X</span> <span class="bp">→</span> <span class="n">Y</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">trunc.lift_on</span> <span class="o">(</span><span class="n">hf</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">y</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">y</span> <span class="n">z</span><span class="o">,</span> <span class="n">subtype.eq</span> <span class="bp">$</span> <span class="n">z.2.2</span> <span class="n">y</span> <span class="n">y.2.1</span><span class="o">)</span>
</code></pre></div>



<a name="254114780"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ZF-style%20functions/near/254114780" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ZF-style.20functions.html#254114780">(Sep 20 2021 at 20:42)</a>:</h4>
<p>This doesn't surprise me -- I think I kind of have the hang of <code>trunc</code> now. The point is that subsingleton data is still data so you don't need AC to make data from it.</p>



<a name="254115103"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ZF-style%20functions/near/254115103" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ZF-style.20functions.html#254115103">(Sep 20 2021 at 20:45)</a>:</h4>
<p>I don't understand what that <code>trunc</code> thing means (philosophically).</p>



<a name="254115433"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ZF-style%20functions/near/254115433" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ZF-style.20functions.html#254115433">(Sep 20 2021 at 20:47)</a>:</h4>
<p><code>trunc</code> is a subsingleton type, but it is "data" (in the sense mentioned <a href="#narrow/stream/113488-general/topic/ZF-style.20functions/near/254008392">above</a>)</p>



<a name="254115441"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ZF-style%20functions/near/254115441" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ZF-style.20functions.html#254115441">(Sep 20 2021 at 20:47)</a>:</h4>
<p>Instead of saying "there exists a basis of this vector space" you're saying "let's choose an equivalence class of bases where two bases are always defined to be equivalent". Because this is data you can use the universal property of quotients to define things which don't depend on the choice of basis</p>



<a name="254115709"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ZF-style%20functions/near/254115709" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ZF-style.20functions.html#254115709">(Sep 20 2021 at 20:50)</a>:</h4>
<p>Making "data" a more concrete notion is done most easily by thinking about (a simplified model of) VM computation, in which all proofs and types are erased (replaced with stubs) while all "data" is preserved, and axioms are banned for computing "data"</p>



<a name="254115872"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ZF-style%20functions/near/254115872" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ZF-style.20functions.html#254115872">(Sep 20 2021 at 20:51)</a>:</h4>
<p>With that model, if you look at the type of <code>choice : \forall A, nonempty A -&gt; A</code> you can see clearly that it takes in two stubs and outputs some data, which is an impossible feat</p>



<a name="254115911"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ZF-style%20functions/near/254115911" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ZF-style.20functions.html#254115911">(Sep 20 2021 at 20:51)</a>:</h4>
<p><code>unique_choice : \forall A, nonempty (unique A) -&gt; A</code> has exactly the same problem</p>



<a name="254116194"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ZF-style%20functions/near/254116194" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ZF-style.20functions.html#254116194">(Sep 20 2021 at 20:53)</a>:</h4>
<p>But <code>trunc.out : trunc A -&gt; A</code> doesn't have that problem, because <code>trunc A</code> is not a stub, it is represented the same as <code>A</code> in the VM, so this is really an identity function</p>



<a name="254116358"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ZF-style%20functions/near/254116358" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ZF-style.20functions.html#254116358">(Sep 20 2021 at 20:54)</a>:</h4>
<p>At the logical level it is of course not an identity function, because the notion of identity is different on <code>trunc A</code> vs <code>A</code>. But the "computational realizers" aka bytes in the machine used to represent values, are the same</p>



<a name="254116698"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ZF-style%20functions/near/254116698" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ZF-style.20functions.html#254116698">(Sep 20 2021 at 20:57)</a>:</h4>
<p>I won't deny that this "data" thing is a weird concept, and it is odd that we are bringing a notion of computation to a mathematical/philosophical question. But that's just how CIC is, it lifts a notion of computation into the proof theory</p>



<a name="254119209"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ZF-style%20functions/near/254119209" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ZF-style.20functions.html#254119209">(Sep 20 2021 at 21:13)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110031">Patrick Massot</span> <a href="#narrow/stream/113488-general/topic/ZF-style.20functions/near/254007905">said</a>:</p>
<blockquote>
<p>If <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi><mo>:</mo><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">\pi : X \to Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span> is surjective with associated relation <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∼</mo></mrow><annotation encoding="application/x-tex">\sim</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">∼</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>X</mi><mo>→</mo><mi>Z</mi></mrow><annotation encoding="application/x-tex">f : X \to Z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span></span></span></span> is compatible with <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∼</mo></mrow><annotation encoding="application/x-tex">\sim</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">∼</span></span></span></span> then you can define <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>f</mi><mo>ˉ</mo></mover></mrow><annotation encoding="application/x-tex">\bar f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0256599999999998em;vertical-align:-0.19444em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8312199999999998em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span><span style="top:-3.26344em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.08332999999999999em;"><span class="mord">ˉ</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span></span></span> as a relation as <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mo stretchy="false">(</mo><mi>y</mi><mo separator="true">,</mo><mi>z</mi><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∀</mi><mi>x</mi><mo separator="true">,</mo><mi>π</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>y</mi><mtext>  </mtext><mo>⟹</mo><mtext>  </mtext><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>z</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{(y, z) | \forall x, \pi(x) = y \implies f(x) = z\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mclose">)</span><span class="mord">∣∀</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7194400000000001em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⟹</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mclose">}</span></span></span></span></p>
</blockquote>
<p>I remember being pretty confused about this issue precisely because the quoted statement is also true in a topos, and the internal logic of a topos is generally considered to be constructive. Furthermore, you can construct the factorization through the quotient in HoTT, too. That basically amounts to the version with <code>trunc</code> that Chris wrote.</p>



<a name="254119370"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ZF-style%20functions/near/254119370" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ZF-style.20functions.html#254119370">(Sep 20 2021 at 21:14)</a>:</h4>
<p>It's really the fact that Lean has these <em>two</em> separate things, <code>Prop</code>s and subsingletons, and you need the version with subsingletons to define the factorization through the quotient, but <code>surjective</code> is only the <code>Prop</code> version. It's not something intrinsic to constructive reasoning in general.</p>



<a name="254125008"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ZF-style%20functions/near/254125008" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ZF-style.20functions.html#254125008">(Sep 20 2021 at 21:59)</a>:</h4>
<p>One thing I learnt from trolling constructivists on Twitter is that in constructive land there might be more than one way to express what in classical mathematics is "one idea", for example being Hausdorff. Is this an existence statement or an actual function which eats two points and spits out two opens?</p>



<a name="254125160"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ZF-style%20functions/near/254125160" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ZF-style.20functions.html#254125160">(Sep 20 2021 at 22:00)</a>:</h4>
<p>These two things live in different universes but are indistinguishable to a classical mathematician</p>



<a name="254151558"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ZF-style%20functions/near/254151558" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ZF-style.20functions.html#254151558">(Sep 21 2021 at 03:42)</a>:</h4>
<p>In the Hausdorff example these notions should already be distinct in ZF (without C), let alone in a general topos. The failure of unique choice is a qualitatively different thing than the failure of choice.</p>



<a name="254151675"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ZF-style%20functions/near/254151675" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ZF-style.20functions.html#254151675">(Sep 21 2021 at 03:45)</a>:</h4>
<p>Actually there are 3 ways you could define Hausdorff: (1) For any distinct x and y there exist U and V such that blah. (2) There exists a function which sends a pair (x, y) of distinct points to a pair (U, V) such that blah. (3) A Hausdorff space is a topological space together with a specific function as in (2).</p>



<a name="254151714"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ZF-style%20functions/near/254151714" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ZF-style.20functions.html#254151714">(Sep 21 2021 at 03:45)</a>:</h4>
<p>(3) is not even classically the correct notion, but if you work in a theory without quotients or propositional truncation you might have no way to express something classically correct.</p>



<a name="254152114"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ZF-style%20functions/near/254152114" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ZF-style.20functions.html#254152114">(Sep 21 2021 at 03:53)</a>:</h4>
<p>I guess you could argue that it doesn't matter that (3) is the "wrong notion" because you define the maps of Hausdorff spaces to totally ignore the "Hausdorff structure", and you still get the right category up to equivalence. But then it's a bit weird that your isomorphisms are not the structural ones.</p>



<a name="254153260"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ZF-style%20functions/near/254153260" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ZF-style.20functions.html#254153260">(Sep 21 2021 at 04:14)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/113488-general/topic/ZF-style.20functions/near/254151675">said</a>:</p>
<blockquote>
<p>Actually there are 3 ways you could define Hausdorff: (1) For any distinct x and y there exist U and V such that blah. (2) There exists a function which sends a pair (x, y) of distinct points to a pair (U, V) such that blah. (3) A Hausdorff space is a topological space together with a specific function as in (2).</p>
</blockquote>
<p>You didn't mention the one that contrapositives the whole statement: if all open sets around x and y intersect, then x = y</p>



<a name="254158442"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ZF-style%20functions/near/254158442" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/ZF-style.20functions.html#254158442">(Sep 21 2021 at 05:45)</a>:</h4>
<p>Basically the mathematics which we're all brought up with in maths departments (where none of this is ever even mentioned) is maths in easy mode, which is appealling because we can get much further (FLT, Poincaré conjecture etc)</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
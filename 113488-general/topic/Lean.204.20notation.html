---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/Lean.204.20notation.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.204.20notation.html">Lean 4 notation</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="204640004"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%204%20notation/near/204640004" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.204.20notation.html#204640004">(Jul 22 2020 at 08:14)</a>:</h4>
<p>That notation would introduce ambiguity with the singleton set notation</p>



<a name="204640157"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%204%20notation/near/204640157" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.204.20notation.html#204640157">(Jul 22 2020 at 08:16)</a>:</h4>
<p>Would the notation  <code>{p * q * p\-1 * q\-1 | p q : α}</code> work?</p>



<a name="204640242"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%204%20notation/near/204640242" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.204.20notation.html#204640242">(Jul 22 2020 at 08:18)</a>:</h4>
<p>I would be equally happy with this, because that is another notation which is completely acceptable to mathematicians -- it's clear to read.</p>



<a name="204640338"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%204%20notation/near/204640338" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.204.20notation.html#204640338">(Jul 22 2020 at 08:19)</a>:</h4>
<p>It would require some C++ hacking though, apparenly binders cannot appear after the things they bind</p>



<a name="204640434"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%204%20notation/near/204640434" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.204.20notation.html#204640434">(Jul 22 2020 at 08:20)</a>:</h4>
<p>No problem in Lean 4</p>



<a name="204640442"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%204%20notation/near/204640442" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.204.20notation.html#204640442">(Jul 22 2020 at 08:20)</a>:</h4>
<p>Another notation question, this time where Lean is being too good:</p>
<div class="codehilite"><pre><span></span><code><span class="c1">-- Let G be a group</span>
<span class="kn">variables</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span>
<span class="c1">-- A mathematician:</span>
<span class="c1">-- &quot;The Abelianization *of G* is the quotient blah blah blah&quot;</span>
<span class="c1">-- Works in Lean 3:</span>
<span class="n">def</span> <span class="n">abelianization</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="o">:=</span>
<span class="n">quotient_group</span><span class="bp">.</span><span class="n">quotient</span> <span class="o">(</span><span class="n">commutator</span> <span class="n">G</span><span class="o">)</span>
<span class="c1">-- Can&#39;t get it to work (maybe I&#39;m bad at variables?)</span>
<span class="n">def</span> <span class="n">abelianization</span> <span class="o">(</span><span class="n">G</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="o">:=</span>
<span class="n">quotient_group</span><span class="bp">.</span><span class="n">quotient</span> <span class="o">(</span><span class="n">commutator</span> <span class="n">G</span><span class="o">)</span>
</code></pre></div>



<a name="204640591"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%204%20notation/near/204640591" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.204.20notation.html#204640591">(Jul 22 2020 at 08:23)</a>:</h4>
<p>your <code>(G)</code> overrides the <code>G</code> outside</p>



<a name="204640597"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%204%20notation/near/204640597" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.204.20notation.html#204640597">(Jul 22 2020 at 08:23)</a>:</h4>
<p>so there is no <code>group</code> instance</p>



<a name="204640906"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%204%20notation/near/204640906" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.204.20notation.html#204640906">(Jul 22 2020 at 08:27)</a>:</h4>
<p>I think that when a mathematician says "let G be a group" they still want access to the notation "a <em>subgroup</em> of G is ..." when making definitions like <code>subgroup</code>, rather than having the reader having to figure out that we're talking about a subgroup of a group as opposed to of a foo.</p>



<a name="204645855"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%204%20notation/near/204645855" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.204.20notation.html#204645855">(Jul 22 2020 at 09:28)</a>:</h4>
<p><span class="user-mention silent" data-user-id="238446">Anne Baanen</span> <a href="#narrow/stream/113488-general/topic/Lean.204.20notation/near/204640338">said</a>:</p>
<blockquote>
<p>It would require some C++ hacking though, apparenly binders cannot appear after the things they bind</p>
</blockquote>
<p>It's a giant mess and broken in many places, but I made syntax for set replacement notation work:</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">successors</span> <span class="o">:</span> <span class="n">set</span> <span class="n">nat</span> <span class="o">:=</span> <span class="o">{(</span><span class="n">x</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">|</span> <span class="n">x</span><span class="o">}</span>
<span class="kn">lemma</span> <span class="n">successors_correct</span> <span class="o">:</span> <span class="n">successors</span> <span class="bp">=</span> <span class="o">{</span><span class="n">x</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="n">y</span><span class="o">,</span> <span class="n">y</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">x</span><span class="o">}</span> <span class="o">:=</span> <span class="n">rfl</span>
</code></pre></div>


<p>I chose to require parentheses around the expression to avoid backtracking and possibly ambiguity. It parses the expression before the binder, so Lean will do ugly things if <code>x</code> is a definition somewhere else.</p>



<a name="204645985"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%204%20notation/near/204645985" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.204.20notation.html#204645985">(Jul 22 2020 at 09:30)</a>:</h4>
<p>Do we actually want this right now, or wait for <span aria-label="four leaf clover" class="emoji emoji-1f340" role="img" title="four leaf clover">:four_leaf_clover:</span>?</p>



<a name="204646025"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%204%20notation/near/204646025" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.204.20notation.html#204646025">(Jul 22 2020 at 09:31)</a>:</h4>
<p>I wouldn't classify it as high priority <span aria-label="wink" class="emoji emoji-1f609" role="img" title="wink">:wink:</span></p>



<a name="204646893"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%204%20notation/near/204646893" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.204.20notation.html#204646893">(Jul 22 2020 at 09:44)</a>:</h4>
<p>does <code>{(x + 1) | x &lt; 0}</code> work? :P</p>



<a name="204647221"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%204%20notation/near/204647221" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.204.20notation.html#204647221">(Jul 22 2020 at 09:48)</a>:</h4>
<p>Not yet! Even <code>{(x + 1) | x : nat}</code> doesn't work yet. I'm trying to figure out whether I can get the parser to go back to parsing the expression after it has finished with the binders.</p>



<a name="204648428"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%204%20notation/near/204648428" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.204.20notation.html#204648428">(Jul 22 2020 at 10:04)</a>:</h4>
<p>I don't need it. I am preparing a performance, not writing code. I can say "I have been told by experts that we will be able to write it in this more familiar way in Lean 4".</p>



<a name="204648914"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%204%20notation/near/204648914" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.204.20notation.html#204648914">(Jul 22 2020 at 10:11)</a>:</h4>
<p>Aha: we can parse every variable as being in the local scope, then use <code>patexpr_to_expr</code> to update the references.</p>



<a name="204651691"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%204%20notation/near/204651691" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.204.20notation.html#204651691">(Jul 22 2020 at 10:51)</a>:</h4>
<p>After applying <code>patexpr_to_expr</code>, the rest was not too difficult:</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">between_1_and_5</span> <span class="o">:</span> <span class="n">set</span> <span class="n">nat</span> <span class="o">:=</span> <span class="o">{(</span><span class="n">x</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">|</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="mi">5</span><span class="o">}</span>
<span class="kn">lemma</span> <span class="n">between_1_and_5_correct</span> <span class="o">:</span> <span class="n">between_1_and_5</span> <span class="bp">=</span> <span class="o">{</span><span class="n">y</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="mi">5</span><span class="o">),</span> <span class="n">x</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">y</span><span class="o">}</span> <span class="o">:=</span> <span class="n">rfl</span>
</code></pre></div>



<a name="204653575"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%204%20notation/near/204653575" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.204.20notation.html#204653575">(Jul 22 2020 at 11:22)</a>:</h4>
<p>And here is the corresponding Lean 4 implementation (in two lines, after reimplementing the existing Lean 3 notations):</p>
<div class="codehilite"><pre><span></span><code><span class="n">new_frontend</span>

<span class="n">declare_syntax_cat</span> <span class="n">quantifierBinder</span>
<span class="n">syntax</span> <span class="n">ident</span><span class="bp">*</span> <span class="o">(</span><span class="s2">&quot; : &quot;</span> <span class="n">term</span><span class="o">)</span><span class="err">?</span> <span class="o">:</span> <span class="n">quantifierBinder</span>
<span class="n">syntax</span> <span class="n">ident</span> <span class="s2">&quot; &lt; &quot;</span> <span class="n">term</span> <span class="o">:</span> <span class="n">quantifierBinder</span>

<span class="n">syntax</span> <span class="s2">&quot;∃&quot;</span> <span class="n">quantifierBinder</span> <span class="s2">&quot;, &quot;</span> <span class="n">term</span> <span class="o">:</span> <span class="n">term</span>
<span class="n">macro_rules</span>
<span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="bp">∃</span> <span class="err">$</span><span class="n">xs</span><span class="o">:</span><span class="n">ident</span><span class="bp">*</span> <span class="o">:</span> <span class="err">$</span><span class="n">τ</span><span class="o">,</span> <span class="err">$</span><span class="n">P</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="n">xs</span><span class="bp">.</span><span class="n">foldrM</span> <span class="o">(</span><span class="k">fun</span> <span class="n">x</span> <span class="n">P</span> <span class="bp">=&gt;</span> <span class="bp">`</span><span class="o">(</span><span class="n">Exists</span> <span class="o">(</span><span class="k">fun</span> <span class="o">(</span><span class="err">$</span><span class="n">x</span> <span class="o">:</span> <span class="err">$</span><span class="n">τ</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="err">$</span><span class="n">P</span><span class="o">)))</span> <span class="n">P</span>
<span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="bp">∃</span> <span class="err">$</span><span class="n">xs</span><span class="o">:</span><span class="n">ident</span><span class="bp">*</span><span class="o">,</span> <span class="err">$</span><span class="n">P</span><span class="o">)</span>      <span class="bp">=&gt;</span> <span class="bp">`</span><span class="o">(</span><span class="bp">∃</span> <span class="err">$</span><span class="n">xs</span><span class="o">:</span><span class="n">ident</span><span class="bp">*</span> <span class="o">:</span> <span class="bp">_</span><span class="o">,</span> <span class="err">$</span><span class="n">P</span><span class="o">)</span>
<span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="bp">∃</span> <span class="err">$</span><span class="n">x</span><span class="o">:</span><span class="n">ident</span> <span class="bp">&lt;</span> <span class="err">$</span><span class="n">e</span><span class="o">,</span> <span class="err">$</span><span class="n">P</span><span class="o">)</span>   <span class="bp">=&gt;</span> <span class="bp">`</span><span class="o">(</span><span class="bp">∃</span> <span class="err">$</span><span class="n">x</span><span class="o">:</span><span class="n">ident</span><span class="o">,</span> <span class="err">$</span><span class="n">x</span><span class="o">:</span><span class="n">ident</span> <span class="bp">&lt;</span> <span class="err">$</span><span class="n">e</span> <span class="bp">∧</span> <span class="err">$</span><span class="n">P</span><span class="o">)</span>

<span class="kn">axiom</span> <span class="n">Set</span> <span class="o">:</span> <span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span>
<span class="kn">axiom</span> <span class="n">Set</span><span class="bp">.</span><span class="n">sep</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">Set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">Set</span> <span class="n">α</span>
<span class="kn">axiom</span> <span class="n">Set</span><span class="bp">.</span><span class="n">univ</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">:</span> <span class="n">Set</span> <span class="n">α</span>
<span class="n">macro</span> <span class="s2">&quot;{&quot;</span> <span class="n">x</span><span class="o">:</span><span class="n">ident</span> <span class="s2">&quot; | &quot;</span> <span class="n">p</span><span class="o">:</span><span class="n">term</span> <span class="s2">&quot;}&quot;</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">=&gt;</span>
<span class="bp">`</span><span class="o">(</span><span class="n">Set</span><span class="bp">.</span><span class="n">sep</span> <span class="o">(</span><span class="k">fun</span> <span class="err">$</span><span class="n">x</span> <span class="bp">=&gt;</span> <span class="err">$</span><span class="n">p</span><span class="o">)</span> <span class="n">Set</span><span class="bp">.</span><span class="n">univ</span><span class="o">)</span>

<span class="n">macro</span> <span class="s2">&quot;{&quot;</span> <span class="n">e</span><span class="o">:</span><span class="n">term</span> <span class="s2">&quot; | &quot;</span> <span class="n">b</span><span class="o">:</span><span class="n">quantifierBinder</span> <span class="s2">&quot;}&quot;</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">=&gt;</span>
<span class="bp">`</span><span class="o">({</span><span class="n">y</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="err">$</span><span class="n">b</span><span class="o">,</span> <span class="n">y</span> <span class="bp">=</span> <span class="err">$</span><span class="n">e</span> <span class="o">})</span>

<span class="bp">#</span><span class="kn">check</span> <span class="o">{</span><span class="n">a</span> <span class="bp">|</span> <span class="n">a</span> <span class="bp">≠</span> <span class="n">a</span><span class="o">}</span>
<span class="bp">#</span><span class="kn">check</span> <span class="o">{</span><span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">|</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">}</span>
<span class="bp">#</span><span class="kn">check</span> <span class="o">({</span><span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">|</span> <span class="n">a</span> <span class="n">b</span><span class="o">}</span> <span class="o">:</span> <span class="n">Set</span> <span class="n">Nat</span><span class="o">)</span>
<span class="bp">#</span><span class="kn">check</span> <span class="o">{</span><span class="n">a</span> <span class="bp">|</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="mi">10</span><span class="o">}</span>  <span class="c1">-- ambiguous</span>
<span class="bp">#</span><span class="kn">check</span> <span class="o">{</span><span class="mi">2</span> <span class="bp">*</span> <span class="n">a</span> <span class="bp">|</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="mi">10</span><span class="o">}</span>
</code></pre></div>


<p><code>{a * b | a b}</code> without a type ascription looks pretty strange and probably shouldn't be allowed. The other interesting one is <code>{a | a &lt; 10}</code>, which can be read either way (filtering all <code>a</code> by a predicate vs. selecting <code>a</code> for all <code>a &lt; 10</code>) and thus is ambiguous. Not sure there is a good solution for that except for merging both notations into a single one that first tries one interpretation, then the other one.</p>



<a name="204658165"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%204%20notation/near/204658165" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.204.20notation.html#204658165">(Jul 22 2020 at 12:22)</a>:</h4>
<p>Created PR <a href="https://github.com/leanprover-community/lean/issues/402">lean#402</a>.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
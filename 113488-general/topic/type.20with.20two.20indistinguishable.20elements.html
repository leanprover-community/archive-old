---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/type.20with.20two.20indistinguishable.20elements.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/type.20with.20two.20indistinguishable.20elements.html">type with two indistinguishable elements</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="204292958"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20with%20two%20indistinguishable%20elements/near/204292958" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/type.20with.20two.20indistinguishable.20elements.html#204292958">(Jul 18 2020 at 09:21)</a>:</h4>
<p>I am currently derailing the "Hahn-Banach" topic thread on differential geometry by talking about a field (in the maths sense) which is isomorphic to the complex numbers but not canonically. I've realised that in some sense I don't know how to formalise such an object and I think it boils down to a purely type-theoretic question which I can ask here.</p>
<p>First the maths background. The real numbers turn out to be completely characterised by a list of axioms: they are the unique complete totally ordered archimedean field, up to unique isomorphism. The complex numbers however has this non-identity automorphism, namely complex conjugation, sending <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>+</mo><mi>i</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">x+iy</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span> to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>−</mo><mi>i</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">x-iy</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>. This automorphism commutes with all the algebraic structure (<code>one</code>, <code>mul</code> etc) and all the topological structure too. The complex numbers have two square roots of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-1</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span>, namely (using Lean's terminology) <code>I</code> and <code>-I</code>. These square roots "have names".</p>
<p>I sometimes work with an "abstract" algebraic closure of the real numbers however. This is a field <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> equipped with a map <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">R</mi><mo>→</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">\mathbb{R}\to k</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">R</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>,  such that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> is isomorphic to the complex numbers, but there are two isomorphisms. The polynomial <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">x^2+1</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> has two roots in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>; if you choose a root of this polynomial then you get an isomorphism <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">C</mi><mo>→</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">\mathbb{C}\to k</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">C</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> sending <code>I</code> to this root.</p>
<p>But in my mental model of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>, the two square roots are "completely indistinguishable". In the past I have constructed <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> in the following way. Take a diagram category with two un-named objects and one isomorphism between these objects. Now take a functor from this category into the category of fields, sending both unnamed objects to the complexes, and sending the isomorphism to complex conjugation. Now take the (or a) limit of this diagram. It's a field, isomorphic to both of the copies of the complexes, but "with no preferred isomorphism". Except that when I mentioned this to Scott, he pointed out that when making the diagram category you probably named the two objects, so you can just choose the object whose name is the first in the alphabet and hence get a "lexicographically first" isomorphism, and argue that it is "preferred". </p>
<p>Is there any way of making the object I want? This has nothing to do with the complex numbers. I am asking for a type which has two terms, and whilst the terms are definitely distinct, it is "impossible" to choose one? I'm sorry that this is such a vague question. I am not even sure what I entirely mean here. I am just looking for a way of formalising my mental model -- I literally want to make it impossible to "choose a term of type X" without assuming some form of choice principle -- I want them to be as anonymous as possible. Can anyone make sense of what I'm saying?</p>



<a name="204294099"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20with%20two%20indistinguishable%20elements/near/204294099" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Dima Pasechnik <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/type.20with.20two.20indistinguishable.20elements.html#204294099">(Jul 18 2020 at 09:58)</a>:</h4>
<p>Aren't you constructing your field by taking C[x]/(x^2+1)C[x] ?</p>
<p>Where is the choice of what is i, and what is -i, entering the picture there (as long as you are not fixing the embedding of your field into a copy of C) ?</p>
<p>Is Scott's objection merely staying that an order can be assumed?</p>



<a name="204294206"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20with%20two%20indistinguishable%20elements/near/204294206" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/type.20with.20two.20indistinguishable.20elements.html#204294206">(Jul 18 2020 at 10:01)</a>:</h4>
<p>When writing <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">C</mi><mo stretchy="false">[</mo><mi>X</mi><mo stretchy="false">]</mo><mi mathvariant="normal">/</mi><mo stretchy="false">(</mo><msup><mi>X</mi><mn>2</mn></msup><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathbb{C}[X]/(X^2+1)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathbb">C</span></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">]</span><span class="mord">/</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>, there is definitely a preferred root of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>X</mi><mn>2</mn></msup><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">X^2+1</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>, the image of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span> in the quotient.</p>



<a name="204294248"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20with%20two%20indistinguishable%20elements/near/204294248" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/type.20with.20two.20indistinguishable.20elements.html#204294248">(Jul 18 2020 at 10:02)</a>:</h4>
<p>And I think Kevin is asking a question in psychology that has neither math content nor type theory content.</p>



<a name="204294261"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20with%20two%20indistinguishable%20elements/near/204294261" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/type.20with.20two.20indistinguishable.20elements.html#204294261">(Jul 18 2020 at 10:03)</a>:</h4>
<p>There are certainly variations on this question that make sense, talking about stuff commuting with automorphisms or functorial constructions.</p>



<a name="204294264"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20with%20two%20indistinguishable%20elements/near/204294264" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/type.20with.20two.20indistinguishable.20elements.html#204294264">(Jul 18 2020 at 10:03)</a>:</h4>
<p>I think Patrick is right here -- we're entering philosophical territory about the possibility of forgetting something you once knew. (Easy to demonstrate in practice, of course!)</p>



<a name="204294304"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20with%20two%20indistinguishable%20elements/near/204294304" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/type.20with.20two.20indistinguishable.20elements.html#204294304">(Jul 18 2020 at 10:04)</a>:</h4>
<p>I think you shouldn't be upset at all by my objection.</p>



<a name="204294308"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20with%20two%20indistinguishable%20elements/near/204294308" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/type.20with.20two.20indistinguishable.20elements.html#204294308">(Jul 18 2020 at 10:04)</a>:</h4>
<p>It's just fine to forget the identity of the two objects that you used as crutches in building the limit diagram.</p>



<a name="204294319"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20with%20two%20indistinguishable%20elements/near/204294319" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/type.20with.20two.20indistinguishable.20elements.html#204294319">(Jul 18 2020 at 10:05)</a>:</h4>
<p>(That is, my objection was in jest.)</p>



<a name="204295696"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20with%20two%20indistinguishable%20elements/near/204295696" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/type.20with.20two.20indistinguishable.20elements.html#204295696">(Jul 18 2020 at 10:52)</a>:</h4>
<p>Oh OK -- I'm happy to accept that my question is psychological. It's definitely how my mental model works though.</p>



<a name="204295704"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20with%20two%20indistinguishable%20elements/near/204295704" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/type.20with.20two.20indistinguishable.20elements.html#204295704">(Jul 18 2020 at 10:53)</a>:</h4>
<p>(Patrick and Dima -- your C's should be R's but I know what you mean)</p>



<a name="204296137"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20with%20two%20indistinguishable%20elements/near/204296137" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ruben Van de Velde <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/type.20with.20two.20indistinguishable.20elements.html#204296137">(Jul 18 2020 at 11:05)</a>:</h4>
<p>Is there even a way to tell that the <code>I</code> in mathlib is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> rather than <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">-i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord mathdefault">i</span></span></span></span>?</p>



<a name="204296180"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20with%20two%20indistinguishable%20elements/near/204296180" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/type.20with.20two.20indistinguishable.20elements.html#204296180">(Jul 18 2020 at 11:06)</a>:</h4>
<p>It is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> by definition. It's not a meaningful question.</p>



<a name="204296257"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20with%20two%20indistinguishable%20elements/near/204296257" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/type.20with.20two.20indistinguishable.20elements.html#204296257">(Jul 18 2020 at 11:09)</a>:</h4>
<p>What is the purpose of forgetting which root is preferred? Is it more or less a psychological trick to make sure that my definitions are about rings or whatever, and not rings with a constant so I can transfer proofs of them across ring isomorphisms and not just ring isomorphisms that the preserve the constant. This is more or less it, right? But that's not really necessary in a theorem prover since it's impossible to make mistakes anyway.</p>



<a name="204296562"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20with%20two%20indistinguishable%20elements/near/204296562" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/type.20with.20two.20indistinguishable.20elements.html#204296562">(Jul 18 2020 at 11:18)</a>:</h4>
<p>One time when I used it was when I made a conceptual definition in the Langlands program, by choosing an isomorphism of R-bar with C, and then I checked that my definition was independent of the choice, which gave me evidence that the definition was the one I was looking for.</p>



<a name="204298403"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20with%20two%20indistinguishable%20elements/near/204298403" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/type.20with.20two.20indistinguishable.20elements.html#204298403">(Jul 18 2020 at 12:16)</a>:</h4>
<p>What about the type of all degree 2 extensions of R?</p>



<a name="204299653"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20with%20two%20indistinguishable%20elements/near/204299653" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/type.20with.20two.20indistinguishable.20elements.html#204299653">(Jul 18 2020 at 12:57)</a>:</h4>
<p><span class="user-mention silent" data-user-id="243562">Adam Topaz</span> <a href="#narrow/stream/113488-general/topic/type.20with.20two.20indistinguishable.20elements/near/204298403">said</a>:</p>
<blockquote>
<p>What about the type of all degree 2 extensions of R?</p>
</blockquote>
<p>As far as I understand, this is the <em>type</em> of the object Kevin is asking for. The question is how to construct a generic term of this type. I'm not so sure this is the right question -- I think instead you want to prove things for arbitrary terms of the type. But if you want a generic term, you can take the one given by <code>classical.choice</code> -- it has no preferred isomorphism with <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">C</mi></mrow><annotation encoding="application/x-tex">\mathbb C</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord mathbb">C</span></span></span></span>.</p>
<p>FWIW, this type is (morally) equivalent to "the type of two-element types" -- map a field to the type of square roots of -1. So the question could be stated more elementarily as "how to construct a generic two-element type".</p>



<a name="204300359"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20with%20two%20indistinguishable%20elements/near/204300359" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Reichelt <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/type.20with.20two.20indistinguishable.20elements.html#204300359">(Jul 18 2020 at 13:19)</a>:</h4>
<p>Not sure if this is a good solution, but: If you state and prove, as a <code>Prop</code>, that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">R</mi></mrow><annotation encoding="application/x-tex">\R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">R</span></span></span></span></span> has an algebraic closure, then use <code>classical.some</code> to obtain one such closure, I believe the two roots of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-1</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span> will be indistinguishable.</p>



<a name="204300741"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20with%20two%20indistinguishable%20elements/near/204300741" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/type.20with.20two.20indistinguishable.20elements.html#204300741">(Jul 18 2020 at 13:30)</a>:</h4>
<p>Yes, I believe this works -- this is what I meant by "take the one given by <code>classical.choice</code>"</p>



<a name="204300746"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20with%20two%20indistinguishable%20elements/near/204300746" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/type.20with.20two.20indistinguishable.20elements.html#204300746">(Jul 18 2020 at 13:30)</a>:</h4>
<p>Aren't Lean 4 constants meant to also do something like this?</p>



<a name="204300862"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20with%20two%20indistinguishable%20elements/near/204300862" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/type.20with.20two.20indistinguishable.20elements.html#204300862">(Jul 18 2020 at 13:34)</a>:</h4>
<p>Probably this is only useful if you can internalise some metatheorems like "any subset of R-bar which can be defined without using choice is stable under conjugation"</p>



<a name="204302095"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20with%20two%20indistinguishable%20elements/near/204302095" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/type.20with.20two.20indistinguishable.20elements.html#204302095">(Jul 18 2020 at 14:13)</a>:</h4>
<p>This is just about Galois theory. The <em>category</em> of algebraic closures of R has many objects, but it's equivalent to a category with a single object whose automorphism group is Z/2. But this is just an equivalence of categories. I guess from the point of view of HoTT, the type of algebraic closures of a field is homotopy equivalent to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mi>G</mi></mrow><annotation encoding="application/x-tex">BG</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord mathdefault">G</span></span></span></span> where G is the absolute Galois group.</p>



<a name="204302164"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20with%20two%20indistinguishable%20elements/near/204302164" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/type.20with.20two.20indistinguishable.20elements.html#204302164">(Jul 18 2020 at 14:14)</a>:</h4>
<p>But of course the homotopy point of view doesn't mean anything in lean</p>



<a name="204303009"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20with%20two%20indistinguishable%20elements/near/204303009" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/type.20with.20two.20indistinguishable.20elements.html#204303009">(Jul 18 2020 at 14:40)</a>:</h4>
<p>In Lean, there will always be a distinguished root of <code>-1</code>, the one that is given by the <code>choice</code> function applied to the predicate "there exists <code>x</code> such that <code>x ^ 2 = -1</code>"!</p>



<a name="204303176"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20with%20two%20indistinguishable%20elements/near/204303176" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/type.20with.20two.20indistinguishable.20elements.html#204303176">(Jul 18 2020 at 14:45)</a>:</h4>
<p>Agreed, but I think this is an instance where it is natural to think of that predicate having two distinct proofs :)</p>



<a name="204306764"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20with%20two%20indistinguishable%20elements/near/204306764" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/type.20with.20two.20indistinguishable.20elements.html#204306764">(Jul 18 2020 at 16:20)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110050">Sebastien Gouezel</span> <a href="#narrow/stream/113488-general/topic/type.20with.20two.20indistinguishable.20elements/near/204303009">said</a>:</p>
<blockquote>
<p>In Lean, there will always be a distinguished root of <code>-1</code>, the one that is given by the <code>choice</code> function applied to the predicate "there exists <code>x</code> such that <code>x ^ 2 = -1</code>"!</p>
</blockquote>
<p>OK I give in :-) What I want can't be done in Lean.</p>



<a name="204308961"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20with%20two%20indistinguishable%20elements/near/204308961" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/type.20with.20two.20indistinguishable.20elements.html#204308961">(Jul 18 2020 at 17:13)</a>:</h4>
<p>It can certainly be done in type theory, you just need a few axioms to allow the construction of types with stated isomorphisms</p>



<a name="204308971"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20with%20two%20indistinguishable%20elements/near/204308971" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/type.20with.20two.20indistinguishable.20elements.html#204308971">(Jul 18 2020 at 17:13)</a>:</h4>
<p>This sounds much like "nominal sets"</p>



<a name="204309031"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20with%20two%20indistinguishable%20elements/near/204309031" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/type.20with.20two.20indistinguishable.20elements.html#204309031">(Jul 18 2020 at 17:14)</a>:</h4>
<p>It might not be possible in lean without choice (it's obviously not possible in lean with choice), but I feel like you can do something with quotient types here</p>



<a name="204309111"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20with%20two%20indistinguishable%20elements/near/204309111" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/type.20with.20two.20indistinguishable.20elements.html#204309111">(Jul 18 2020 at 17:16)</a>:</h4>
<p>I want a proof that the type has two terms but I want it to be very hard to create a term of that type without using choice</p>



<a name="204309131"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20with%20two%20indistinguishable%20elements/near/204309131" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/type.20with.20two.20indistinguishable.20elements.html#204309131">(Jul 18 2020 at 17:17)</a>:</h4>
<p>hm, when you put it that way it does sound rather unlikely; in lean without choice there aren't many ways to prove the existence of terms that doesn't produce an actual term</p>



<a name="204309412"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20with%20two%20indistinguishable%20elements/near/204309412" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/type.20with.20two.20indistinguishable.20elements.html#204309412">(Jul 18 2020 at 17:24)</a>:</h4>
<p>To reiterate, though, the easy solution is to say</p>
<div class="codehilite"><pre><span></span><code><span class="kn">constant</span> <span class="n">T</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="kn">axiom</span> <span class="n">T_not_subsing</span> <span class="o">:</span> <span class="err">\</span><span class="n">exists</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">T</span><span class="o">,</span> <span class="n">a</span> <span class="bp">!=</span> <span class="n">b</span>
</code></pre></div>


<p>You might argue that I cheated by adding a new axiom, but this is exactly as respectable as the construction of quotient types (which is also a family of axioms), and it's obviously consistent. It just needs to be cleaned up a bit to give it an air of respectability as an axiom</p>



<a name="204312058"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20with%20two%20indistinguishable%20elements/near/204312058" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Reichelt <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/type.20with.20two.20indistinguishable.20elements.html#204312058">(Jul 18 2020 at 18:26)</a>:</h4>
<p>Maybe I'm missing the point, but doesn't this yield a generic two-element type?</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">set_theory</span><span class="bp">.</span><span class="n">cardinal</span>

<span class="kn">lemma</span> <span class="n">two_element_type_exists</span><span class="o">:</span> <span class="bp">∃</span> <span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">,</span> <span class="n">cardinal</span><span class="bp">.</span><span class="n">mk</span> <span class="n">α</span> <span class="bp">=</span> <span class="mi">2</span> <span class="o">:=</span> <span class="k">begin</span>
  <span class="n">use</span> <span class="n">bool</span><span class="o">,</span>
  <span class="n">simp</span>
<span class="kn">end</span>

<span class="n">def</span> <span class="n">two_element_type</span> <span class="o">:=</span> <span class="n">classical</span><span class="bp">.</span><span class="n">some</span> <span class="n">two_element_type_exists</span>
</code></pre></div>



<a name="204312409"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20with%20two%20indistinguishable%20elements/near/204312409" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/type.20with.20two.20indistinguishable.20elements.html#204312409">(Jul 18 2020 at 18:35)</a>:</h4>
<p>Why not just use <code>variable</code>?</p>



<a name="204313975"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20with%20two%20indistinguishable%20elements/near/204313975" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jack J Garzella <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/type.20with.20two.20indistinguishable.20elements.html#204313975">(Jul 18 2020 at 19:19)</a>:</h4>
<p>At risk of making a philosophical statement, what's wrong with "pretending that lexicographical order doesn't exist"? At a low enough, all computer memory is ordered bits and bytes, so there is always some implicit order, even when we write an "unordered set"  or "hash table" data structure, for example. Writing such a structure is (more or less) shielding the user from knowledge of the implicit order. So why not just use the same ordered type with two elements, but pinky-promise not to ever use the first lexicographical element? Or even better, write a layer of abstraction that prevents the user from doing this?</p>



<a name="204314055"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20with%20two%20indistinguishable%20elements/near/204314055" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jack J Garzella <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/type.20with.20two.20indistinguishable.20elements.html#204314055">(Jul 18 2020 at 19:21)</a>:</h4>
<p>In addition, I'd like to point that this question isn't as esoteric as it first looks: there are many reasons why one might want to think of a number field like <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">Q</mi><mo stretchy="false">(</mo><msqrt><mn>2</mn></msqrt><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathbb{Q} (\sqrt{2})</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.1572200000000001em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathbb">Q</span></span><span class="mopen">(</span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.90722em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord">2</span></span></span><span style="top:-2.86722em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg height="1.08em" preserveAspectRatio="xMinYMin slice" viewBox="0 0 400000 1080" width="400em"><path d="M95,702 c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14 c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54 c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10 s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429 c69,-144,104.5,-217.7,106.5,-221 l0 -0 c5.3,-9.3,12,-14,20,-14 H400000v40H845.2724 s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7 c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z M834 80h400000v40h-400000z"></path></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.13278em;"><span></span></span></span></span></span><span class="mclose">)</span></span></span></span> as an abstract field with two indistinguishable real embeddings rather than a subset of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">R</mi></mrow><annotation encoding="application/x-tex">\R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">R</span></span></span></span></span> with a fixed embedding.</p>



<a name="204315796"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20with%20two%20indistinguishable%20elements/near/204315796" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/type.20with.20two.20indistinguishable.20elements.html#204315796">(Jul 18 2020 at 20:11)</a>:</h4>
<p>Yes this is all coming from infinite places of number fields and local-global compatibility in the Langlands program.</p>



<a name="204326767"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20with%20two%20indistinguishable%20elements/near/204326767" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/type.20with.20two.20indistinguishable.20elements.html#204326767">(Jul 19 2020 at 01:42)</a>:</h4>
<p><span class="user-mention" data-user-id="198266">@Sebastian Reichelt</span>, this is an embarrassing demonstration of how I don't know how to work with the <code>cardinal</code> API, but this sort of trick is no obstacle to the power of <code>classical.some</code>:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">set_theory</span><span class="bp">.</span><span class="n">cardinal</span>
<span class="kn">import</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">fin_cases</span>

<span class="kn">open</span> <span class="n">cardinal</span>

<span class="kn">lemma</span> <span class="n">two_element_type_exists</span><span class="o">:</span> <span class="bp">∃</span> <span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">,</span> <span class="n">mk</span> <span class="n">α</span> <span class="bp">=</span> <span class="mi">2</span> <span class="o">:=</span> <span class="k">begin</span>
  <span class="n">use</span> <span class="n">bool</span><span class="o">,</span>
  <span class="n">simp</span>
<span class="kn">end</span>

<span class="n">def</span> <span class="n">two_element_type</span> <span class="o">:=</span> <span class="n">classical</span><span class="bp">.</span><span class="n">some</span> <span class="n">two_element_type_exists</span>

<span class="kn">lemma</span> <span class="n">A</span> <span class="o">:</span> <span class="n">mk</span> <span class="n">two_element_type</span> <span class="bp">=</span> <span class="mi">2</span> <span class="o">:=</span> <span class="n">classical</span><span class="bp">.</span><span class="n">some_spec</span> <span class="n">two_element_type_exists</span>

<span class="n">noncomputable</span> <span class="n">def</span> <span class="n">B</span> <span class="o">:</span> <span class="n">two_element_type</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="k">have</span> <span class="n">nz</span> <span class="o">:</span> <span class="n">mk</span> <span class="n">two_element_type</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="o">:=</span>
  <span class="k">begin</span>
    <span class="n">rw</span> <span class="n">A</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">ne_of_gt</span><span class="o">,</span>
    <span class="n">transitivity</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">cardinal</span><span class="o">),</span>
    <span class="o">{</span> <span class="n">apply</span> <span class="n">not_le</span><span class="bp">.</span><span class="mi">1</span><span class="o">,</span>
      <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
      <span class="k">have</span> <span class="o">:</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">cardinal</span><span class="o">)</span> <span class="bp">=</span> <span class="n">mk</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span> <span class="n">rw</span> <span class="n">mk_fin</span><span class="o">,</span> <span class="n">simp</span><span class="o">,</span> <span class="o">},</span>
      <span class="n">conv</span> <span class="n">at</span> <span class="n">h</span> <span class="o">{</span> <span class="n">to_rhs</span><span class="o">,</span> <span class="n">rw</span> <span class="n">this</span> <span class="o">},</span>
      <span class="n">rw</span> <span class="n">two_le_iff</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
      <span class="n">rcases</span> <span class="n">h</span> <span class="k">with</span> <span class="bp">⟨</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="o">,</span><span class="n">h</span><span class="bp">⟩</span><span class="o">,</span>
      <span class="n">fin_cases</span> <span class="n">x</span><span class="o">,</span> <span class="n">fin_cases</span> <span class="n">y</span><span class="o">,</span> <span class="n">simpa</span> <span class="kn">using</span> <span class="n">h</span><span class="o">,</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">zero_lt_one</span><span class="o">,</span> <span class="o">}</span>
  <span class="kn">end</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">ne</span> <span class="o">:=</span> <span class="n">ne_zero_iff_nonempty</span><span class="bp">.</span><span class="mi">1</span> <span class="n">nz</span><span class="o">,</span>
  <span class="n">apply</span> <span class="bp">@</span><span class="n">classical</span><span class="bp">.</span><span class="n">some</span> <span class="bp">_</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">true</span><span class="o">),</span>
  <span class="n">cases</span> <span class="n">ne</span> <span class="k">with</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">exact</span> <span class="bp">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">trivial</span><span class="bp">⟩</span><span class="o">,</span>
<span class="kn">end</span>
</code></pre></div>



<a name="204337294"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20with%20two%20indistinguishable%20elements/near/204337294" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/type.20with.20two.20indistinguishable.20elements.html#204337294">(Jul 19 2020 at 07:28)</a>:</h4>
<p>Surely this informal notion of "choice-free construction on R-bar" translates to "hygienic construction on an arbitrary alg closure of R", where hygienic means "functorial in isomorphisms", and arbitrary means "takes any alg closure as input" (i.e. use variable instead of axiom)</p>
<p>What <code>classical.some</code> shows is that hygiene is non-vacuous in Lean -- it is possible to write down non-hygienic constructions</p>



<a name="204337610"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20with%20two%20indistinguishable%20elements/near/204337610" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/type.20with.20two.20indistinguishable.20elements.html#204337610">(Jul 19 2020 at 07:40)</a>:</h4>
<p>You should checkout my <code>iso_transport</code> branch, which is a total mess, but tries formalise <code>hygienic</code> and provide some associated tactics.</p>



<a name="204341128"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20with%20two%20indistinguishable%20elements/near/204341128" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/type.20with.20two.20indistinguishable.20elements.html#204341128">(Jul 19 2020 at 09:32)</a>:</h4>
<p>The problem with algebraic closures is that they are <em>not</em> functorial! They are unique up to non-unique isomorphism. If K-&gt;L is a morphism of fields then you don't get a natural Kbar-&gt;Lbar. Pedantic mathematicians write "Let Kbar be an algebraic closure of K". It is exactly like turning a nonempty space into a pointed space. You can choose a point in each space, but then don't expect all morphisms of spaces to turn into morphisms of pointed spaces.</p>



<a name="204344680"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20with%20two%20indistinguishable%20elements/near/204344680" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/type.20with.20two.20indistinguishable.20elements.html#204344680">(Jul 19 2020 at 11:17)</a>:</h4>
<p>That's what makes this interesting :-)<br>
The category (indeed groupoid) of algebraic closures of R is non-trivial -- we are interested in functors from it</p>



<a name="204346808"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20with%20two%20indistinguishable%20elements/near/204346808" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Reichelt <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/type.20with.20two.20indistinguishable.20elements.html#204346808">(Jul 19 2020 at 12:17)</a>:</h4>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span> I had no doubt that you could pick an arbitrary element of <code>two_element_type</code> using <code>classical.some</code>. But <span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113488-general/topic/type.20with.20two.20indistinguishable.20elements/near/204292958">said</a>:</p>
<blockquote>
<p>I literally want to make it impossible to "choose a term of type X" without assuming some form of choice principle.</p>
</blockquote>
<p>I would argue that everything that can be constructed from or proved about <code>two_element_type</code> must follow from the fact that it has two elements, i.e. nothing else is "known" about that type.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
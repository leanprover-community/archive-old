---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/subgroup.20of.20subgroup.20of.2E.2E.2E.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subgroup.20of.20subgroup.20of.2E.2E.2E.html">subgroup of subgroup of...</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="207761430"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subgroup%20of%20subgroup%20of.../near/207761430" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subgroup.20of.20subgroup.20of.2E.2E.2E.html#207761430">(Aug 23 2020 at 07:55)</a>:</h4>
<p>Can I state the theorem "... of the subgroup of the subgroup of ... G" is a subgroup of G?</p>



<a name="207762175"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subgroup%20of%20subgroup%20of.../near/207762175" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subgroup.20of.20subgroup.20of.2E.2E.2E.html#207762175">(Aug 23 2020 at 08:18)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">group_theory</span><span class="bp">.</span><span class="n">subgroup</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">G</span><span class="o">)</span> <span class="o">(</span><span class="n">K</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">H</span><span class="o">)</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">G</span> <span class="o">:=</span>
<span class="n">subgroup</span><span class="bp">.</span><span class="n">map</span> <span class="o">((</span><span class="k">by</span> <span class="n">library_search</span><span class="o">)</span> <span class="o">:</span> <span class="n">H</span> <span class="bp">→*</span> <span class="n">G</span><span class="o">)</span> <span class="n">K</span>
</code></pre></div>



<a name="207762777"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subgroup%20of%20subgroup%20of.../near/207762777" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subgroup.20of.20subgroup.20of.2E.2E.2E.html#207762777">(Aug 23 2020 at 08:38)</a>:</h4>
<p>yes but I want an infinite chain of subgroups</p>



<a name="207763238"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subgroup%20of%20subgroup%20of.../near/207763238" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subgroup.20of.20subgroup.20of.2E.2E.2E.html#207763238">(Aug 23 2020 at 08:53)</a>:</h4>
<p>Oh!</p>



<a name="207763301"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subgroup%20of%20subgroup%20of.../near/207763301" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subgroup.20of.20subgroup.20of.2E.2E.2E.html#207763301">(Aug 23 2020 at 08:55)</a>:</h4>
<p>Of course you can still do it but maybe you want to set things up differently</p>



<a name="207765155"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subgroup%20of%20subgroup%20of.../near/207765155" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subgroup.20of.20subgroup.20of.2E.2E.2E.html#207765155">(Aug 23 2020 at 09:53)</a>:</h4>
<p>I wanted a similar type of dependent sequences in another context, but I couldn't figure out how to get it to work.</p>
<p>Here's one thing I tried:</p>
<div class="codehilite"><pre><span></span><code><span class="c">/-</span><span class="cm">-</span>
<span class="cm">A list of groups, where each is a subgroup of the previous</span>
<span class="cm">-/</span>
<span class="kn">inductive</span> <span class="n">subgroup_chain</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">],</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">u</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">group</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span> <span class="o">:</span> <span class="n">subgroup_chain</span> <span class="n">G</span>
<span class="bp">|</span> <span class="n">subgroup</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span> <span class="o">(</span><span class="n">G&#39;</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">G</span><span class="o">)</span> <span class="o">(</span><span class="n">tail</span> <span class="o">:</span> <span class="n">subgroup_chain</span> <span class="n">G&#39;</span><span class="o">)</span> <span class="o">:</span> <span class="n">subgroup_chain</span> <span class="n">G</span>

<span class="c">/-</span><span class="cm">-</span>
<span class="cm">Drop last subgroup off the `subgroup_chain`.  FAILS: &quot;dependent pattern matching result is not a constructor application&quot;</span>
<span class="cm">-/</span>
<span class="n">def</span> <span class="n">sc_init</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">h</span> <span class="o">:</span> <span class="n">group</span> <span class="n">G</span><span class="o">],</span> <span class="bp">@</span><span class="n">subgroup_chain</span> <span class="n">G</span> <span class="n">h</span> <span class="bp">→</span> <span class="bp">@</span><span class="n">subgroup_chain</span> <span class="n">G</span> <span class="n">h</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="bp">_</span> <span class="o">(</span><span class="bp">@</span><span class="n">subgroup_chain</span><span class="bp">.</span><span class="n">group</span> <span class="n">G</span> <span class="n">h</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">subgroup_chain</span><span class="bp">.</span><span class="n">group</span> <span class="n">G</span> <span class="n">h</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="bp">_</span> <span class="o">(</span><span class="bp">@</span><span class="n">subgroup_chain</span><span class="bp">.</span><span class="n">subgroup</span> <span class="n">G</span> <span class="n">h</span> <span class="n">G&#39;</span> <span class="o">(</span><span class="bp">@</span><span class="n">subgroup_chain</span><span class="bp">.</span><span class="n">group</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">))</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">subgroup_chain</span><span class="bp">.</span><span class="n">group</span> <span class="n">G</span> <span class="n">h</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="bp">_</span> <span class="o">(</span><span class="bp">@</span><span class="n">subgroup_chain</span><span class="bp">.</span><span class="n">subgroup</span> <span class="n">G</span> <span class="n">h</span> <span class="n">G&#39;</span> <span class="n">tail</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">subgroup_chain</span><span class="bp">.</span><span class="n">subgroup</span> <span class="n">G</span> <span class="n">h</span> <span class="n">G&#39;</span> <span class="o">(</span><span class="n">sc_init</span> <span class="n">tail</span><span class="o">)</span>

<span class="kn">structure</span> <span class="n">subgroup_sequence</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">subgroup_chain</span> <span class="n">G</span><span class="o">)</span>
<span class="o">(</span><span class="n">prop₁</span> <span class="o">:</span> <span class="n">f</span> <span class="mi">0</span> <span class="bp">=</span> <span class="n">subgroup_chain</span><span class="bp">.</span><span class="n">group</span> <span class="n">G</span><span class="o">)</span>
<span class="o">(</span><span class="n">prop₂</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">f</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">sc_init</span> <span class="o">(</span><span class="n">f</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)))</span>
</code></pre></div>



<a name="207765244"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subgroup%20of%20subgroup%20of.../near/207765244" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subgroup.20of.20subgroup.20of.2E.2E.2E.html#207765244">(Aug 23 2020 at 09:55)</a>:</h4>
<p>I think what I was attempting is to simulate a coinductive definition with inductive types.  Ideally this would be a stream of subgroups (a.k.a. an infinite list).</p>



<a name="207765250"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subgroup%20of%20subgroup%20of.../near/207765250" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subgroup.20of.20subgroup.20of.2E.2E.2E.html#207765250">(Aug 23 2020 at 09:55)</a>:</h4>
<p>Isn't it possible to just have a <code>chain</code> in the partial order of subgroups?</p>



<a name="207765301"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subgroup%20of%20subgroup%20of.../near/207765301" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subgroup.20of.20subgroup.20of.2E.2E.2E.html#207765301">(Aug 23 2020 at 09:56)</a>:</h4>
<p>or a monotone function, if you want an infinite sequence</p>



<a name="207765378"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subgroup%20of%20subgroup%20of.../near/207765378" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subgroup.20of.20subgroup.20of.2E.2E.2E.html#207765378">(Aug 23 2020 at 09:58)</a>:</h4>
<p>In the other context, I found some type that everything could be a <code>set</code> in, solving the problem like you suggest, but I'm still wondering how to set up this kind of recursive definition.</p>



<a name="207765675"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subgroup%20of%20subgroup%20of.../near/207765675" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subgroup.20of.20subgroup.20of.2E.2E.2E.html#207765675">(Aug 23 2020 at 10:05)</a>:</h4>
<p>In the coq odd order paper some technicalities were solved by making all groups subgroups of an ambient big group. But this trick cannot be used for eg rings</p>



<a name="207766368"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subgroup%20of%20subgroup%20of.../near/207766368" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subgroup.20of.20subgroup.20of.2E.2E.2E.html#207766368">(Aug 23 2020 at 10:24)</a>:</h4>
<p>I won't say this is the best implementation, but it fixes all the errors and avoids the universe bump:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">group_theory</span><span class="bp">.</span><span class="n">subgroup</span>

<span class="kn">universe</span> <span class="n">u</span>
<span class="c">/-</span><span class="cm">-</span>
<span class="cm">A list of groups, where each is a subgroup of the previous</span>
<span class="cm">-/</span>
<span class="n">def</span> <span class="n">subgroup_chain&#39;</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">],</span> <span class="kt">Type</span> <span class="n">u</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="n">G</span> <span class="bp">_</span> <span class="o">:=</span> <span class="n">punit</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">G</span> <span class="bp">_</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">exactI</span> <span class="err">Σ</span> <span class="o">(</span><span class="n">G&#39;</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">G</span><span class="o">),</span> <span class="n">subgroup_chain&#39;</span> <span class="n">n</span> <span class="n">G&#39;</span>

<span class="n">def</span> <span class="n">subgroup_chain</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="o">:=</span> <span class="err">Σ</span> <span class="n">n</span><span class="o">,</span> <span class="n">subgroup_chain&#39;</span> <span class="n">n</span> <span class="n">G</span>

<span class="n">def</span> <span class="n">subgroup_chain</span><span class="bp">.</span><span class="n">nil</span> <span class="o">{</span><span class="n">G</span><span class="o">}</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span> <span class="o">:</span> <span class="n">subgroup_chain</span> <span class="n">G</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="mi">0</span><span class="o">,</span> <span class="bp">⟨⟩⟩</span>
<span class="n">def</span> <span class="n">subgroup_chain</span><span class="bp">.</span><span class="n">cons</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span>
  <span class="o">(</span><span class="n">G&#39;</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">G</span><span class="o">)</span> <span class="o">:</span> <span class="n">subgroup_chain</span> <span class="n">G&#39;</span> <span class="bp">→</span> <span class="n">subgroup_chain</span> <span class="n">G</span>
<span class="bp">|</span> <span class="bp">⟨</span><span class="n">n</span><span class="o">,</span> <span class="n">C</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">G&#39;</span><span class="o">,</span> <span class="n">C</span><span class="bp">⟩</span>

<span class="n">def</span> <span class="n">subgroup_chain</span><span class="bp">.</span><span class="n">init&#39;</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">],</span> <span class="k">by</span> <span class="n">exactI</span> <span class="n">subgroup_chain&#39;</span> <span class="n">n</span> <span class="n">G</span> <span class="bp">→</span> <span class="n">subgroup_chain</span> <span class="n">G</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">2</span><span class="o">)</span> <span class="n">G</span> <span class="bp">_</span> <span class="bp">⟨</span><span class="n">G&#39;</span><span class="o">,</span> <span class="n">C</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">exactI</span> <span class="n">subgroup_chain</span><span class="bp">.</span><span class="n">cons</span> <span class="n">G&#39;</span> <span class="o">(</span><span class="n">subgroup_chain</span><span class="bp">.</span><span class="n">init&#39;</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">C</span><span class="o">)</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">exactI</span> <span class="n">subgroup_chain</span><span class="bp">.</span><span class="n">nil</span>

<span class="c">/-</span><span class="cm">-</span>
<span class="cm">Drop last subgroup off the `subgroup_chain`.  FAILS: &quot;dependent pattern matching result is not a constructor application&quot;</span>
<span class="cm">-/</span>
<span class="n">def</span> <span class="n">subgroup_chain</span><span class="bp">.</span><span class="n">init</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span> <span class="o">:</span> <span class="n">subgroup_chain</span> <span class="n">G</span> <span class="bp">→</span> <span class="n">subgroup_chain</span> <span class="n">G</span>
<span class="bp">|</span> <span class="bp">⟨</span><span class="n">n</span><span class="o">,</span> <span class="n">G&#39;</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">subgroup_chain</span><span class="bp">.</span><span class="n">init&#39;</span> <span class="n">n</span> <span class="n">G&#39;</span>

<span class="kn">structure</span> <span class="n">subgroup_sequence</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">subgroup_chain</span> <span class="n">G</span><span class="o">)</span>
<span class="o">(</span><span class="n">prop₁</span> <span class="o">:</span> <span class="n">f</span> <span class="mi">0</span> <span class="bp">=</span> <span class="n">subgroup_chain</span><span class="bp">.</span><span class="n">nil</span><span class="o">)</span>
<span class="o">(</span><span class="n">prop₂</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">f</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">subgroup_chain</span><span class="bp">.</span><span class="n">init</span> <span class="o">(</span><span class="n">f</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)))</span>
</code></pre></div>



<a name="207795856"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subgroup%20of%20subgroup%20of.../near/207795856" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subgroup.20of.20subgroup.20of.2E.2E.2E.html#207795856">(Aug 23 2020 at 23:13)</a>:</h4>
<p>I tried abstracting out the pattern, which is that these are lists whose elements have types that are constructed from the previous element in some way.  There is a type <code>α</code>, a function <code>tcons</code> of that takes terms of <code>α</code> to types that index allowable next terms in the list, and a function <code>mk</code> that takes these index terms back to terms of  <code>α</code>.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">group_theory</span><span class="bp">.</span><span class="n">subgroup</span>
<span class="kn">import</span> <span class="n">tactic</span>

<span class="n">universes</span> <span class="n">u</span> <span class="n">v</span>

<span class="kn">section</span> <span class="n">chains</span>

<span class="n">def</span> <span class="n">chain_tcons</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">u</span><span class="bp">+</span><span class="mi">1</span><span class="o">))</span> <span class="o">:=</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">u</span>
<span class="n">def</span> <span class="n">chain_mk</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">u</span><span class="bp">+</span><span class="mi">1</span><span class="o">)}</span> <span class="o">(</span><span class="n">cons</span> <span class="o">:</span> <span class="n">chain_tcons</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">Π</span> <span class="o">⦃</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">⦄,</span> <span class="n">cons</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">α</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">u</span><span class="bp">+</span><span class="mi">1</span><span class="o">)}</span> <span class="o">(</span><span class="n">tcons</span> <span class="o">:</span> <span class="n">chain_tcons</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">mk</span> <span class="o">:</span> <span class="n">chain_mk</span> <span class="n">tcons</span><span class="o">)</span>

<span class="n">def</span> <span class="n">chain&#39;</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="kt">Type</span> <span class="n">u</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">punit</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">x</span> <span class="o">:=</span> <span class="err">Σ</span> <span class="o">(</span><span class="n">x&#39;</span> <span class="o">:</span> <span class="n">tcons</span> <span class="n">x</span><span class="o">),</span> <span class="n">chain&#39;</span> <span class="n">n</span> <span class="o">(</span><span class="n">mk</span> <span class="n">x&#39;</span><span class="o">)</span>

<span class="n">def</span> <span class="n">chain</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="o">:=</span> <span class="err">Σ</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="n">chain&#39;</span> <span class="n">tcons</span> <span class="n">mk</span> <span class="n">n</span> <span class="n">x</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">tcons</span><span class="o">}</span> <span class="o">{</span><span class="n">mk</span><span class="o">}</span>
<span class="n">def</span> <span class="n">chain</span><span class="bp">.</span><span class="n">nil</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="n">chain</span> <span class="n">tcons</span> <span class="n">mk</span> <span class="n">x</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="mi">0</span><span class="o">,</span> <span class="n">punit</span><span class="bp">.</span><span class="n">star</span><span class="bp">⟩</span>
<span class="n">def</span> <span class="n">chain</span><span class="bp">.</span><span class="n">cons</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">x&#39;</span> <span class="o">:</span> <span class="n">tcons</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span> <span class="n">chain</span> <span class="n">tcons</span> <span class="n">mk</span> <span class="o">(</span><span class="n">mk</span> <span class="n">x&#39;</span><span class="o">)</span> <span class="bp">→</span> <span class="n">chain</span> <span class="n">tcons</span> <span class="n">mk</span> <span class="n">x</span>
<span class="bp">|</span> <span class="bp">⟨</span><span class="n">n</span><span class="o">,</span> <span class="n">C</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">x&#39;</span><span class="o">,</span> <span class="n">C</span><span class="bp">⟩</span>
<span class="n">def</span> <span class="n">chain</span><span class="bp">.</span><span class="n">init&#39;</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">},</span> <span class="n">chain&#39;</span> <span class="n">tcons</span> <span class="n">mk</span> <span class="n">n</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">chain</span> <span class="n">tcons</span> <span class="n">mk</span> <span class="n">x</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">2</span><span class="o">)</span> <span class="n">x</span> <span class="bp">⟨</span><span class="n">x&#39;</span><span class="o">,</span> <span class="n">C</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">chain</span><span class="bp">.</span><span class="n">cons</span> <span class="n">x&#39;</span> <span class="o">(</span><span class="n">chain</span><span class="bp">.</span><span class="n">init&#39;</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">C</span><span class="o">)</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="o">:=</span> <span class="n">chain</span><span class="bp">.</span><span class="n">nil</span>
<span class="n">def</span> <span class="n">chain</span><span class="bp">.</span><span class="n">init</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="n">chain</span> <span class="n">tcons</span> <span class="n">mk</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">chain</span> <span class="n">tcons</span> <span class="n">mk</span> <span class="n">x</span>
<span class="bp">|</span> <span class="bp">⟨</span><span class="n">n</span><span class="o">,</span> <span class="n">C</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">chain</span><span class="bp">.</span><span class="n">init&#39;</span> <span class="n">n</span> <span class="n">C</span>

<span class="kn">variables</span> <span class="o">(</span><span class="n">tcons</span><span class="o">)</span> <span class="o">(</span><span class="n">mk</span><span class="o">)</span>
<span class="kn">structure</span> <span class="n">chain_seq</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">chain</span> <span class="n">tcons</span> <span class="n">mk</span> <span class="n">x</span><span class="o">)</span>
<span class="o">(</span><span class="n">prop₁</span> <span class="o">:</span> <span class="n">f</span> <span class="mi">0</span> <span class="bp">=</span> <span class="n">chain</span><span class="bp">.</span><span class="n">nil</span><span class="o">)</span>
<span class="o">(</span><span class="n">prop₂</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="n">f</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">chain</span><span class="bp">.</span><span class="n">init</span> <span class="o">(</span><span class="n">f</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)))</span>

<span class="kn">end</span> <span class="n">chains</span>

<span class="kn">structure</span> <span class="n">Group</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span>
<span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">group</span> <span class="n">G</span><span class="o">)</span>

<span class="bp">@</span><span class="o">[</span><span class="kn">reducible</span><span class="o">]</span>
<span class="n">def</span> <span class="n">subgroup_tcons</span> <span class="o">:</span> <span class="n">chain_tcons</span> <span class="n">Group</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">G</span><span class="o">,</span> <span class="bp">@</span><span class="n">subgroup</span> <span class="n">G</span><span class="bp">.</span><span class="n">G</span> <span class="n">G</span><span class="bp">.</span><span class="n">s</span>
<span class="n">def</span> <span class="n">subgroup_mk</span> <span class="o">:</span> <span class="n">chain_mk</span> <span class="n">subgroup_tcons</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">G&#39;</span><span class="o">,</span> <span class="o">{</span><span class="n">G</span> <span class="o">:=</span> <span class="n">G&#39;</span><span class="o">,</span> <span class="n">s</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">apply_instance</span><span class="o">}</span>
</code></pre></div>



<a name="207795921"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subgroup%20of%20subgroup%20of.../near/207795921" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subgroup.20of.20subgroup.20of.2E.2E.2E.html#207795921">(Aug 23 2020 at 23:14)</a>:</h4>
<p>I don't feel like I fully understand the pattern yet, but the code certainly type checks <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span></p>



<a name="207796021"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subgroup%20of%20subgroup%20of.../near/207796021" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subgroup.20of.20subgroup.20of.2E.2E.2E.html#207796021">(Aug 23 2020 at 23:17)</a>:</h4>
<p>By the way, the general technique for avoiding universe bumps in inductives is to realize that not all types can be used in the recursion, only those "derived" from the input by some "small" (i.e. in Type u) indexed family</p>



<a name="207796022"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subgroup%20of%20subgroup%20of.../near/207796022" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subgroup.20of.20subgroup.20of.2E.2E.2E.html#207796022">(Aug 23 2020 at 23:17)</a>:</h4>
<p>in this case the family is indexed by <code>nat</code></p>



<a name="207796411"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subgroup%20of%20subgroup%20of.../near/207796411" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subgroup.20of.20subgroup.20of.2E.2E.2E.html#207796411">(Aug 23 2020 at 23:26)</a>:</h4>
<p>here's another example:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">universe</span> <span class="n">u</span>

<span class="kn">inductive</span> <span class="n">rose_tree</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">u</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="c1">-- bad</span>
<span class="bp">|</span> <span class="n">leaf</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">rose_tree</span> <span class="n">α</span>
<span class="bp">|</span> <span class="n">node</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="n">rose_tree</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">α</span><span class="o">)</span> <span class="bp">→</span> <span class="n">rose_tree</span> <span class="n">α</span>

<span class="n">def</span> <span class="n">rose_type</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">u</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">u</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">α</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">rose_type</span> <span class="n">n</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">α</span><span class="o">)</span>

<span class="n">def</span> <span class="n">rose_tree&#39;</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="o">:=</span> <span class="c1">-- good</span>
<span class="err">Σ</span> <span class="n">n</span><span class="o">,</span> <span class="n">rose_type</span> <span class="n">n</span> <span class="n">α</span>

<span class="n">def</span> <span class="n">rose_tree&#39;</span><span class="bp">.</span><span class="n">leaf</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">rose_tree&#39;</span> <span class="n">α</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="mi">0</span><span class="o">,</span> <span class="n">a</span><span class="bp">⟩</span>
<span class="n">def</span> <span class="n">rose_tree&#39;</span><span class="bp">.</span><span class="n">node</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">rose_tree&#39;</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">α</span><span class="o">)</span> <span class="bp">→</span> <span class="n">rose_tree&#39;</span> <span class="n">α</span>
<span class="bp">|</span> <span class="bp">⟨</span><span class="n">n</span><span class="o">,</span> <span class="n">a</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">a</span><span class="bp">⟩</span>
</code></pre></div>



<a name="207796444"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subgroup%20of%20subgroup%20of.../near/207796444" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subgroup.20of.20subgroup.20of.2E.2E.2E.html#207796444">(Aug 23 2020 at 23:27)</a>:</h4>
<p>the fact that it is a def after the transformation isn't the important part, it is the fact that <code>rose_tree'</code> only quantifies over <code>nat</code> instead of <code>Type u</code></p>



<a name="207796570"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subgroup%20of%20subgroup%20of.../near/207796570" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subgroup.20of.20subgroup.20of.2E.2E.2E.html#207796570">(Aug 23 2020 at 23:30)</a>:</h4>
<p>The only time this isn't possible is when you really take advantage of that type quantifier, as in <a href="https://leanprover-community.github.io/mathlib_docs/find/pSet/src">src#pSet</a>, and that's when you get the really big inductives that properly require a universe bump</p>



<a name="207796660"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subgroup%20of%20subgroup%20of.../near/207796660" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subgroup.20of.20subgroup.20of.2E.2E.2E.html#207796660">(Aug 23 2020 at 23:33)</a>:</h4>
<p>Thanks, I was wondering if the <code>nat</code> you introduced was the key here.</p>
<p>The other setup I was looking at was defining a sequence of graphs, each having a vertex set derived from the previous, something like</p>
<div class="codehilite"><pre><span></span><code><span class="kn">inductive</span> <span class="n">deriv_verts</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">simple_graphs</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
<span class="bp">|</span> <span class="n">incl</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">V</span> <span class="n">G</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">join</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="o">(</span><span class="n">sym2</span> <span class="o">(</span><span class="n">V</span> <span class="n">G</span><span class="o">))</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">¬∃</span> <span class="o">(</span><span class="n">w</span> <span class="o">:</span> <span class="n">V</span> <span class="n">G</span><span class="o">),</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">v</span> <span class="err">∈</span> <span class="n">e</span><span class="o">),</span> <span class="n">v</span> <span class="bp">~</span> <span class="n">w</span><span class="o">)</span>

<span class="n">def</span> <span class="n">deriv</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">simple_graphs</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">simple_graph_on</span> <span class="o">(</span><span class="n">deriv_verts</span> <span class="n">G</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">sorry</span>

<span class="c1">-- then define a function f : ℕ → graphs somehow where f (n + 1) = deriv (f n)</span>
</code></pre></div>


<p>It turns out all the graphs can be thought of as being subgraphs of a complete graph on some other type, so it doesn't really matter, but I thought it was interesting how it wasn't clear how to reign in the universes.</p>



<a name="207798042"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subgroup%20of%20subgroup%20of.../near/207798042" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subgroup.20of.20subgroup.20of.2E.2E.2E.html#207798042">(Aug 24 2020 at 00:12)</a>:</h4>
<p>I guess this is another way to set it up:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">structure</span> <span class="n">Group</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span>
<span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">group</span> <span class="n">G</span><span class="o">)</span>

<span class="n">def</span> <span class="n">subgroups</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">Group</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Group</span> <span class="o">:=</span> <span class="o">{</span><span class="n">G&#39;</span> <span class="o">:</span> <span class="n">Group</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">g&#39;</span> <span class="o">:</span> <span class="bp">@</span><span class="n">subgroup</span> <span class="n">G</span><span class="bp">.</span><span class="n">G</span> <span class="n">G</span><span class="bp">.</span><span class="n">s</span><span class="o">),</span> <span class="n">G&#39;</span> <span class="bp">=</span> <span class="bp">⟨</span><span class="n">g&#39;</span><span class="o">,</span> <span class="k">by</span> <span class="n">apply_instance</span><span class="bp">⟩</span><span class="o">}</span>

<span class="kn">structure</span> <span class="n">subgroup_chain</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">Group</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">Group</span><span class="o">)</span>
<span class="o">(</span><span class="n">prop₁</span> <span class="o">:</span> <span class="n">f</span> <span class="mi">0</span> <span class="bp">=</span> <span class="n">G</span><span class="o">)</span>
<span class="o">(</span><span class="n">prop₂</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="err">∈</span> <span class="n">subgroups</span> <span class="o">(</span><span class="n">f</span> <span class="n">n</span><span class="o">))</span>
</code></pre></div>


<p>This simplifies things in that it doesn't need to represent the infinite chain as a limit of finite chains.</p>



<a name="207798278"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subgroup%20of%20subgroup%20of.../near/207798278" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subgroup.20of.20subgroup.20of.2E.2E.2E.html#207798278">(Aug 24 2020 at 00:18)</a>:</h4>
<p>you might have some type equalities to wrangle with that definition</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/Status.20of.20algebraic.20geometry.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html">Status of algebraic geometry</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="253718572"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/253718572" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#253718572">(Sep 17 2021 at 10:04)</a>:</h4>
<p>I'm a newcomer to lean, and a student studying in maths with interests towards algebraic geometry. <br>
As the current mathlib is quite short on algebraic geometry, I am wondering what the current status is, and if there are TODOs that i can contribute to so that i can practice lean hands-on at the same time.</p>



<a name="253718834"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/253718834" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#253718834">(Sep 17 2021 at 10:06)</a>:</h4>
<p><span class="user-mention" data-user-id="384542">@Justus Springer</span> currently has the most active plans for developing AG.</p>



<a name="253727937"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/253727937" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Justus Springer <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#253727937">(Sep 17 2021 at 11:33)</a>:</h4>
<p><span class="user-mention" data-user-id="439483">@Andrew Yang</span> that's basically how I started out as well :)<br>
A significant part of my contributions so far have been to solve TODOs in algebraic geometry. Currently I'm trying to formalize the adjunction between <code>Spec</code> and the global sections functor (from locally ringed spaces). I'm following <a href="https://stacks.math.columbia.edu/tag/01I1">stacks</a>.  I hope I can finish this in September, after that, I probably won't have as much time for Lean as I do now. <br>
When that's done, there are some obvious follow-ups: Defining the category of affine schemes, showing it to be contravariantly equivalent to <code>CommRing</code> and showing that it has products and fibre products. Then there is some gluing construction to show that schemes have fibre products as well.<br>
Besides that, maybe it would be time to define and play around with basic properties of schemes (integral, reduced, normal, notherian,...) and morphisms (flat, smooth, affine,...). But I don't know how accessible that is. See also <a href="#narrow/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL/near/235331481">this discussion</a>.</p>



<a name="253730815"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/253730815" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#253730815">(Sep 17 2021 at 12:00)</a>:</h4>
<p>One thing I'd like to see is the definition of <code>Proj R</code> for <code>R</code> a graded ring (or, as we say here, an internally graded commutative ring). If you're more variety-y than schemey then there's always the possibility of setting up a theory of algebraic varieties too, although I'm still not really sure how it would look. Perhaps restrict to a separably closed field and define quasi-projective algebraic varieties as subspaces of projective n-space? Morphisms of quasi-projective varieties probably need to be handled via sheaves though, otherwise things get quite nasty.</p>



<a name="253731059"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/253731059" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#253731059">(Sep 17 2021 at 12:02)</a>:</h4>
<p>A completely different idea would be to develop the concept of finite locally free group schemes over a base scheme (otherwise known as finite flat group schemes, if the base is Noetherian). This is a globalisation of group theory and there are lots of surprises, e.g. in characteristic p there is more than one group of order p, even if your base is a point. We'll need these for the proof of Fermat's Last Theorem ;-)</p>



<a name="253737344"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/253737344" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#253737344">(Sep 17 2021 at 12:56)</a>:</h4>
<p>I could start trying to define <code>Proj R</code> by probably copying <code>Spec.lean</code> and modifying it.<br>
After that, porting the definitions and the basic properties in Hartshorne II.3 also seems like an interesting<br>
task that I could try. Though gluing schemes seems like quite a challenge to formalise.</p>



<a name="253737685"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/253737685" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#253737685">(Sep 17 2021 at 12:59)</a>:</h4>
<p>Oh and may I have the write access to the mathlib repo? My username is <code>erdOne</code>.</p>



<a name="253737697"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/253737697" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#253737697">(Sep 17 2021 at 12:59)</a>:</h4>
<p>Hmm, <code>Proj R</code> depends on a theory of graded rings, which I wouldn't recommend to a beginner.</p>



<a name="253738051"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/253738051" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#253738051">(Sep 17 2021 at 13:01)</a>:</h4>
<p>Justus was talking about fibre products, which is a nice target, I think. So, for starters, we'll need to know that <code>CommRing</code> has fibred coproducts. Tensor products are defined, but I don't think this category is aware yet that is has these coproducts.</p>



<a name="253738068"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/253738068" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#253738068">(Sep 17 2021 at 13:01)</a>:</h4>
<p>So that might be a nice place to start.</p>



<a name="253738102"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/253738102" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#253738102">(Sep 17 2021 at 13:01)</a>:</h4>
<p>After that, define the subcategory of affine schemes, and deduce that it has fibre products.</p>



<a name="253738291"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/253738291" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#253738291">(Sep 17 2021 at 13:03)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/CommRing.colimits.has_colimits_CommRing">docs#CommRing.colimits.has_colimits_CommRing</a></p>



<a name="253738371"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/253738371" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#253738371">(Sep 17 2021 at 13:03)</a>:</h4>
<p>ooh, of course <span aria-label="smiley" class="emoji emoji-1f603" role="img" title="smiley">:smiley:</span></p>



<a name="253738409"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/253738409" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#253738409">(Sep 17 2021 at 13:03)</a>:</h4>
<p>But of course it would be nice to have an explicit cocone for the fibered coproducts which is defeq to the tensor product</p>



<a name="253739096"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/253739096" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#253739096">(Sep 17 2021 at 13:08)</a>:</h4>
<p>In my opinion, a good place to start is in constructing a gluing construction for topological spaces, which will then be useful for a gluing constrution for schemes.</p>



<a name="253739170"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/253739170" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#253739170">(Sep 17 2021 at 13:09)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/Top">docs#Top</a> is the category of topological spaces, which we know has colimits (so we can glue in some sense), but we probably need an explicit construction of gluing spaces along open subsets which will be useful for gluing schemes.</p>



<a name="253740638"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/253740638" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#253740638">(Sep 17 2021 at 13:20)</a>:</h4>
<p>Sure, I will start there then.<br>
I am thinking of implementing the underlying set as the quotient set of the disjoint union,  and then specifying the open sets.<br>
Is this a good idea?</p>



<a name="253741263"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/253741263" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#253741263">(Sep 17 2021 at 13:25)</a>:</h4>
<p>Yes, I think that's reasonable. But one should think carefully how to set this up. My inclination is to use the general formalism of descent data, and to use open immersions instead of open subsets. This is probably worth further discussion (maybe in the #maths stream)</p>



<a name="253742284"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/253742284" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#253742284">(Sep 17 2021 at 13:33)</a>:</h4>
<p>So again, I'm not sure if this is a good "first project"</p>



<a name="253742325"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/253742325" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#253742325">(Sep 17 2021 at 13:33)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/113488-general/topic/Status.20of.20algebraic.20geometry/near/253742284">said</a>:</p>
<blockquote>
<p>So again, I'm not sure if this is a good "first project"</p>
</blockquote>
<p>You're right.</p>



<a name="253742331"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/253742331" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#253742331">(Sep 17 2021 at 13:33)</a>:</h4>
<p>Defining the category of affine schemes is probably a lot easier to get started with.</p>



<a name="253743114"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/253743114" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#253743114">(Sep 17 2021 at 13:39)</a>:</h4>
<p>We have the following ingredients for this: <br>
<a href="https://leanprover-community.github.io/mathlib_docs/find/algebraic_geometry.Scheme.Spec">docs#algebraic_geometry.Scheme.Spec</a> and <a href="https://leanprover-community.github.io/mathlib_docs/find/category_theory.functor.ess_image">docs#category_theory.functor.ess_image</a></p>



<a name="253744518"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/253744518" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#253744518">(Sep 17 2021 at 13:48)</a>:</h4>
<p>I will start working on the category of affine schemes then.<br>
Should I assume the adjointness of Spec, or prove independently that Spec is  fully faithful?</p>



<a name="253744662"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/253744662" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#253744662">(Sep 17 2021 at 13:49)</a>:</h4>
<p>It would be best to coordinate with <span class="user-mention" data-user-id="384542">@Justus Springer</span>, but I imagine that for affine schemes you don't need the Gamma-Spec adjunction, right?</p>



<a name="253744833"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/253744833" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#253744833">(Sep 17 2021 at 13:50)</a>:</h4>
<p>Or do you mean that you want to know that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">S</mi><mi mathvariant="normal">p</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">c</mi></mrow><mi>A</mi><mo stretchy="false">)</mo><mo>≅</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">\mathcal O(\mathrm{Spec} A) \cong A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathrm">Spec</span></span><span class="mord mathnormal">A</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≅</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span>?</p>



<a name="253744858"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/253744858" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#253744858">(Sep 17 2021 at 13:50)</a>:</h4>
<p>I think Justus proved that a while ago.</p>



<a name="253745356"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/253745356" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#253745356">(Sep 17 2021 at 13:54)</a>:</h4>
<p>I think that need <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>A</mi><mo separator="true">,</mo><mi>B</mi><mo stretchy="false">)</mo><mo>≃</mo><mi mathvariant="normal">Hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi mathvariant="normal">Spec</mi><mo>⁡</mo><mi>B</mi><mo separator="true">,</mo><mi mathvariant="normal">Spec</mi><mo>⁡</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\operatorname{Hom}(A, B) \simeq \operatorname{Hom}(\operatorname{Spec} B, \operatorname{Spec} A)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mord mathrm">Hom</span></span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≃</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mord mathrm">Hom</span></span><span class="mopen">(</span><span class="mop"><span class="mord mathrm">Spec</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mord mathrm">Spec</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">A</span><span class="mclose">)</span></span></span></span> in order to say that the category of affine schemes is equivalent to <code>CommRing^op</code>.<br>
The equivalence is a direct consequence of the adjunction, but there may be a more elementary proof to it.</p>



<a name="253745633"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/253745633" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#253745633">(Sep 17 2021 at 13:55)</a>:</h4>
<p>I thought we had that Spec is fully faithful in mathlib. <span class="user-mention" data-user-id="384542">@Justus Springer</span>?</p>



<a name="253747443"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/253747443" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#253747443">(Sep 17 2021 at 14:07)</a>:</h4>
<p><span class="user-mention silent" data-user-id="439483">Andrew Yang</span> <a href="#narrow/stream/113488-general/topic/Status.20of.20algebraic.20geometry/near/253737685">said</a>:</p>
<blockquote>
<p>Oh and may I have the write access to the mathlib repo? My username is <code>erdOne</code>.</p>
</blockquote>
<p>I've sent you an invite: <a href="https://github.com/leanprover-community/mathlib/invitations">https://github.com/leanprover-community/mathlib/invitations</a></p>



<a name="253748570"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/253748570" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Justus Springer <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#253748570">(Sep 17 2021 at 14:15)</a>:</h4>
<p>Affine schemes can definitely be defined without the Gamma-spec adjunction. It should be pretty straightforward with <a href="https://leanprover-community.github.io/mathlib_docs/find/category_theory.functor.ess_image">docs#category_theory.functor.ess_image</a>. Still, we would need some infrastructure, like defining <code>Spec.to_AffineScheme</code> and also <code>AffineScheme.Γ</code>.</p>



<a name="253748943"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/253748943" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Justus Springer <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#253748943">(Sep 17 2021 at 14:17)</a>:</h4>
<p><span class="user-mention silent" data-user-id="243562">Adam Topaz</span> <a href="#narrow/stream/113488-general/topic/Status.20of.20algebraic.20geometry/near/253745633">said</a>:</p>
<blockquote>
<p>I thought we had that Spec is fully faithful in mathlib. <span class="user-mention silent" data-user-id="384542">Justus Springer</span>?</p>
</blockquote>
<p>Unfortunately not. But since this follows immediately from the adjunction, I think we should wait for that.</p>



<a name="253749023"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/253749023" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#253749023">(Sep 17 2021 at 14:18)</a>:</h4>
<p><span class="user-mention silent" data-user-id="123965">Bryan Gin-ge Chen</span> <a href="#narrow/stream/113488-general/topic/Status.20of.20algebraic.20geometry/near/253747443">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="439483">Andrew Yang</span> <a href="#narrow/stream/113488-general/topic/Status.20of.20algebraic.20geometry/near/253737685">said</a>:</p>
<blockquote>
<p>Oh and may I have the write access to the mathlib repo? My username is <code>erdOne</code>.</p>
</blockquote>
<p>I've sent you an invite: <a href="https://github.com/leanprover-community/mathlib/invitations">https://github.com/leanprover-community/mathlib/invitations</a></p>
</blockquote>
<p>Thanks!</p>



<a name="253749187"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/253749187" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#253749187">(Sep 17 2021 at 14:18)</a>:</h4>
<p><span class="user-mention silent" data-user-id="384542">Justus Springer</span> <a href="#narrow/stream/113488-general/topic/Status.20of.20algebraic.20geometry/near/253748943">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="243562">Adam Topaz</span> <a href="#narrow/stream/113488-general/topic/Status.20of.20algebraic.20geometry/near/253745633">said</a>:</p>
<blockquote>
<p>I thought we had that Spec is fully faithful in mathlib. <span class="user-mention silent" data-user-id="384542">Justus Springer</span>?</p>
</blockquote>
<p>Unfortunately not. But since this follows immediately from the adjunction, I think we should wait for that.</p>
</blockquote>
<p>Wouldn't proving that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mi>S</mi><mi>p</mi><mi>e</mi><mi>c</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">\mathcal{O}(Spec(A)) = A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">Sp</span><span class="mord mathnormal">ec</span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mclose">))</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span> be one of the steps in proving the adjunction? Full-faithfulness would follow easily from that.</p>



<a name="253749361"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/253749361" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#253749361">(Sep 17 2021 at 14:20)</a>:</h4>
<p><span class="user-mention silent" data-user-id="384542">Justus Springer</span> <a href="#narrow/stream/113488-general/topic/Status.20of.20algebraic.20geometry/near/253748943">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="243562">Adam Topaz</span> <a href="#narrow/stream/113488-general/topic/Status.20of.20algebraic.20geometry/near/253745633">said</a>:</p>
<blockquote>
<p>I thought we had that Spec is fully faithful in mathlib. <span class="user-mention silent" data-user-id="384542">Justus Springer</span>?</p>
</blockquote>
<p>Unfortunately not. But since this follows immediately from the adjunction, I think we should wait for that.</p>
</blockquote>
<p>Sure! I will start the definitions and the infrastructures then. The equivalence to <code>CommRing</code> can wait.</p>



<a name="253750174"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/253750174" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Justus Springer <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#253750174">(Sep 17 2021 at 14:25)</a>:</h4>
<p><span class="user-mention silent" data-user-id="243562">Adam Topaz</span> <a href="#narrow/stream/113488-general/topic/Status.20of.20algebraic.20geometry/near/253749187">said</a>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">Wouldn't</span> <span class="n">proving</span> <span class="n">that</span> <span class="bp">$$\</span><span class="n">mathcal</span><span class="o">{</span><span class="n">O</span><span class="o">}(</span><span class="n">Spec</span><span class="o">(</span><span class="n">A</span><span class="o">))</span> <span class="bp">=</span> <span class="n">A</span><span class="bp">$$</span> <span class="n">be</span> <span class="n">one</span> <span class="n">of</span> <span class="n">the</span> <span class="n">steps</span> <span class="k">in</span> <span class="n">proving</span> <span class="n">the</span> <span class="n">adjunction</span><span class="bp">?</span> <span class="n">Full</span><span class="bp">-</span><span class="n">faithfulness</span> <span class="n">would</span> <span class="n">follow</span> <span class="n">easily</span> <span class="k">from</span> <span class="n">that.</span>
</code></pre></div>
<p>Yes. That part is more or less done, I proved the more general statement <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="script">O</mi><mi>X</mi></msub><mo stretchy="false">(</mo><mi>D</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>≅</mo><msub><mi>A</mi><mi>f</mi></msub></mrow><annotation encoding="application/x-tex">\mathcal{O}_X(D(f))\cong A_f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07847em;">X</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">))</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≅</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> a while ago (where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>=</mo><mi>S</mi><mi>p</mi><mi>e</mi><mi>c</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X=Spec(A)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">Sp</span><span class="mord mathnormal">ec</span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mclose">)</span></span></span></span>). See <a href="https://leanprover-community.github.io/mathlib_docs/find/algebraic_geometry.structure_sheaf.basic_open_iso">docs#algebraic_geometry.structure_sheaf.basic_open_iso</a>. I never got around to specializing this to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="script">O</mi><mi>X</mi></msub><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo>≅</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">\mathcal{O}_X(X)\cong A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07847em;">X</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≅</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span> though. This seems trivial, but involves knowing that localizing a ring at units doesn't change it. This could be a nice project too <span class="user-mention" data-user-id="439483">@Andrew Yang</span> .</p>



<a name="253751299"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/253751299" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Justus Springer <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#253751299">(Sep 17 2021 at 14:32)</a>:</h4>
<p>The reason the adjunction is taking so long by the way is that I want to do the more general version for locally ringed spaces: I.e. <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">H</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">m</mi></mrow><mo stretchy="false">(</mo><mi>X</mi><mo separator="true">,</mo><mi>S</mi><mi>p</mi><mi>e</mi><mi>c</mi><mi>R</mi><mo stretchy="false">)</mo><mo>≅</mo><mrow><mi mathvariant="normal">H</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">m</mi></mrow><mo stretchy="false">(</mo><mi>R</mi><mo separator="true">,</mo><mi mathvariant="normal">Γ</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">{\rm Hom}(X,Spec R)\cong{\rm Hom}(R,\Gamma(X))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">Hom</span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">Sp</span><span class="mord mathnormal">ec</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≅</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">Hom</span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">Γ</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">))</span></span></span></span> for any locally ringed space <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span>, not just (affine) schemes. For this, I need <a href="https://stacks.math.columbia.edu/tag/01HZ">this lemma</a>, which requires some generalizations to the sheaves library. Also, I had to prove that the forgetful functor <code>CommRing ⥤ Type</code> preserves filtered colimits (<a href="https://github.com/leanprover-community/mathlib/issues/9191">#9191</a>). So that's the state of affairs as of now. I hope the road is clear now for the Gamma-Spec adjunction.</p>



<a name="253751729"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/253751729" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Justus Springer <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#253751729">(Sep 17 2021 at 14:35)</a>:</h4>
<p><span class="user-mention" data-user-id="439483">@Andrew Yang</span>  If you want you could play around with proving <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">H</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">m</mi></mrow><mo stretchy="false">(</mo><mi>A</mi><mo separator="true">,</mo><mi>B</mi><mo stretchy="false">)</mo><mo>≅</mo><mrow><mi mathvariant="normal">H</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">m</mi></mrow><mo stretchy="false">(</mo><mi>S</mi><mi>p</mi><mi>e</mi><mi>c</mi><mi>B</mi><mo separator="true">,</mo><mi>S</mi><mi>p</mi><mi>e</mi><mi>c</mi><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">{\rm Hom}(A,B)\cong{\rm Hom}(Spec B, Spec A)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">Hom</span></span></span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≅</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">Hom</span></span></span><span class="mopen">(</span><span class="mord mathnormal">Sp</span><span class="mord mathnormal">ec</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">Sp</span><span class="mord mathnormal">ec</span><span class="mord mathnormal">A</span><span class="mclose">)</span></span></span></span> as you suggested. Then you can use the things you've learned to help me with the general version <span aria-label="sweat smile" class="emoji emoji-1f605" role="img" title="sweat smile">:sweat_smile:</span></p>



<a name="253751844"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/253751844" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Justus Springer <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#253751844">(Sep 17 2021 at 14:36)</a>:</h4>
<p>So there is definitely enough work to do...</p>



<a name="253752823"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/253752823" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#253752823">(Sep 17 2021 at 14:42)</a>:</h4>
<p>Just for fun:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">group_theory.monoid_localization</span>
<span class="kn">import</span> <span class="n">ring_theory.localization</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">M</span><span class="o">]</span>

<span class="kd">def</span> <span class="n">foo</span> <span class="o">(</span><span class="n">u</span> <span class="o">:</span> <span class="n">M</span><span class="o">)</span> <span class="o">(</span><span class="n">hu</span> <span class="o">:</span> <span class="n">is_unit</span> <span class="n">u</span><span class="o">)</span> <span class="o">:</span> <span class="n">is_localization.away</span> <span class="n">u</span> <span class="n">M</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">map_units</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="n">rintro</span> <span class="o">⟨</span><span class="n">v</span><span class="o">,</span><span class="n">n</span><span class="o">,</span><span class="n">rfl</span><span class="o">⟩,</span>
    <span class="n">erw</span> <span class="o">(</span><span class="n">algebra_map</span> <span class="n">M</span> <span class="n">M</span><span class="o">)</span><span class="bp">.</span><span class="n">map_pow</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">is_unit.pow</span> <span class="n">_</span> <span class="n">hu</span><span class="o">,</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="n">surj</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="n">intros</span> <span class="n">m</span><span class="o">,</span>
    <span class="n">use</span> <span class="o">⟨</span><span class="n">m</span><span class="o">,</span><span class="mi">1</span><span class="o">⟩,</span>
    <span class="n">simp</span><span class="o">,</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="n">eq_iff_exists</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="n">intros</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span>
    <span class="n">refine</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="o">⟨</span><span class="mi">1</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simpa</span><span class="o">⟩,</span> <span class="n">_</span><span class="o">⟩,</span>
    <span class="n">rintro</span> <span class="o">⟨⟨</span><span class="n">c</span><span class="o">,</span><span class="n">n</span><span class="o">,</span><span class="n">rfl</span><span class="o">⟩,</span><span class="n">hc</span><span class="o">⟩,</span>
    <span class="n">simp</span> <span class="n">at</span> <span class="n">hc</span><span class="o">,</span>
    <span class="k">have</span> <span class="o">:</span> <span class="n">is_unit</span> <span class="o">(</span><span class="n">u</span><span class="bp">^</span><span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="n">is_unit.pow</span> <span class="n">_</span> <span class="n">hu</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">this.mul_left_inj</span> <span class="n">at</span> <span class="n">hc</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">hc</span><span class="o">,</span>
  <span class="kd">end</span> <span class="o">}</span>

<span class="kd">noncomputable</span>
<span class="kd">example</span> <span class="o">(</span><span class="n">u</span> <span class="o">:</span> <span class="n">M</span><span class="o">)</span> <span class="o">(</span><span class="n">hu</span> <span class="o">:</span> <span class="n">is_unit</span> <span class="n">u</span><span class="o">)</span> <span class="o">:</span> <span class="n">localization.away</span> <span class="n">u</span> <span class="bp">≃ₐ</span><span class="o">[</span><span class="n">M</span><span class="o">]</span> <span class="n">M</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">haveI</span> <span class="o">:=</span> <span class="n">foo</span> <span class="n">_</span> <span class="n">u</span> <span class="n">hu</span><span class="bp">;</span> <span class="n">exact</span> <span class="n">is_localization.alg_equiv</span> <span class="o">(</span><span class="n">submonoid.powers</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">localization.away</span> <span class="n">u</span><span class="o">)</span> <span class="n">M</span>
</code></pre></div>



<a name="253753134"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/253753134" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#253753134">(Sep 17 2021 at 14:44)</a>:</h4>
<p>I'm a little surprised we don't have this in mathlib somewhere...</p>



<a name="253753608"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/253753608" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#253753608">(Sep 17 2021 at 14:46)</a>:</h4>
<p>Also, it looks like <code>is_localization.away</code> is only defined for commutative rings while <code>localization.away</code> for any monoid. Why is that?</p>



<a name="253754607"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/253754607" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Justus Springer <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#253754607">(Sep 17 2021 at 14:52)</a>:</h4>
<p>I asked about this before <a href="#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Localization.20at.20units">here</a>, but then never PR'd it. Now things have changed again since the localization map refactor.</p>



<a name="253754640"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/253754640" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Justus Springer <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#253754640">(Sep 17 2021 at 14:52)</a>:</h4>
<p><span class="user-mention silent" data-user-id="243562">Adam Topaz</span> <a href="#narrow/stream/113488-general/topic/Status.20of.20algebraic.20geometry/near/253753608">said</a>:</p>
<blockquote>
<p>Also, it looks like <code>is_localization.away</code> is only defined for commutative rings while <code>localization.away</code> for any monoid. Why is that?</p>
</blockquote>
<p>Maybe <span class="user-mention" data-user-id="238446">@Anne Baanen</span> ?</p>



<a name="253756558"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/253756558" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#253756558">(Sep 17 2021 at 15:05)</a>:</h4>
<p>(<a href="https://leanprover-community.github.io/mathlib_docs/find/is_localization.away">docs#is_localization.away</a> vs <a href="https://leanprover-community.github.io/mathlib_docs/find/localization.away">docs#localization.away</a> for reference)</p>



<a name="253756780"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/253756780" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#253756780">(Sep 17 2021 at 15:06)</a>:</h4>
<p>I think this is because in turn <a href="https://leanprover-community.github.io/mathlib_docs/find/is_localization">docs#is_localization</a> requires a full algebra structure while <a href="https://leanprover-community.github.io/mathlib_docs/find/localization">docs#localization</a> does not</p>



<a name="253759706"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/253759706" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#253759706">(Sep 17 2021 at 15:27)</a>:</h4>
<p>The monoid version of <code>is_localization.away</code> is called something like <a href="https://leanprover-community.github.io/mathlib_docs/find/submonoid.localization_map.away_map">docs#submonoid.localization_map.away_map</a></p>



<a name="253777819"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/253777819" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#253777819">(Sep 17 2021 at 17:29)</a>:</h4>
<p>Since <code>Scheme</code>s and consequently <code>AffineScheme</code>s have hidden universe variables, I cannot simply coerce <code>X : AffineScheme</code> into <code>Scheme</code> without explicitly stating the universe levels.<br>
Is the paradigm to tuck <code>.{u}</code>'s everywhere, or to not use coerces, or there is some other solution to this?</p>



<a name="253785999"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/253785999" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Justus Springer <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#253785999">(Sep 17 2021 at 18:24)</a>:</h4>
<p>I don't think providing universe levels explicitly is considered a bad thing. But I'm not sure we would even want a coercion, maybe it would suffice to have <code>AffineScheme.to_Scheme</code>?</p>



<a name="253786257"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/253786257" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#253786257">(Sep 17 2021 at 18:26)</a>:</h4>
<p>The <code>AffineScheme.to_Scheme</code> would presumably just be an alias for <a href="https://leanprover-community.github.io/mathlib_docs/find/category_theory.functor.ess_image_inclusion">docs#category_theory.functor.ess_image_inclusion</a></p>



<a name="253921254"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/253921254" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#253921254">(Sep 19 2021 at 06:04)</a>:</h4>
<p>I've finished the 'faithful' part of the fully-faithful-ness, but the 'full' part seems to need some more definition unfolding to make it work.<br>
<a href="https://github.com/leanprover-community/mathlib/blob/affine_schemes/src/algebraic_geometry/Spec_fully_faithful.lean">The file</a>.<br>
I'm wondering if there are any advices about the code or such before I continue.</p>



<a name="253925279"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/253925279" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Justus Springer <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#253925279">(Sep 19 2021 at 07:22)</a>:</h4>
<p>Thanks for working on this! I think it looks very good. I have a few comments:</p>
<ul>
<li>I don't think we even need the extra definition <code>to_Spec_Γ</code>. Maybe we can just use <code>structure_sheaf.to_open R ⊤</code>? As a second step, we could have the actual isomorphism <code>R ≅ (structure_sheaf R).presheaf.obj (op ⊤)</code> as an extra definition, making use of <code>as_iso</code>. This should also help with defining <code>Spec_Γ_identity</code>, making use of <code>nat_iso.of_components</code>.</li>
<li><code>Spec_Γ_identity</code> should be a def, not a lemma (you can also see this warning yourself by typing <code>#lint</code> at the end of the file).</li>
<li>Everything leading up to <code>R ≅ (structure_sheaf R).presheaf.obj (op ⊤)</code> should probably go into <code>structure_sheaf.lean</code> I would say. Maybe right below <code>basic_open_iso</code>? </li>
<li>About <code>op_iso</code>: I remember I needed the same thing when playing around with something else. I have it on the old branch <a href="https://github.com/leanprover-community/mathlib/tree/is_iso_op">branch#is_iso_op</a>, but never PR'd it. Should I PR it, so that that's out of the way?</li>
</ul>
<p>You could probably PR the isomorphism <code>R ≅ (structure_sheaf R).presheaf.obj (op ⊤)</code> very soon (as soon as the localization-at-units thing jas been done)</p>



<a name="254151995"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/254151995" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#254151995">(Sep 21 2021 at 03:50)</a>:</h4>
<p>(deleted)</p>



<a name="254152799"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/254152799" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#254152799">(Sep 21 2021 at 04:05)</a>:</h4>
<p>I've finished the fully faithful ness of <code>Spec</code>. Though it is just a draft and the proof is quite ugly. <br>
<a href="https://github.com/leanprover-community/mathlib/blob/affine_schemes/src/algebraic_geometry/global_section_of_spec.lean">This file</a> contains <code>R ≅ (structure_sheaf R).presheaf.obj (op ⊤)</code> and <code>Spec ⋙ Γ ≅ 𝟭</code>.<br>
<a href="https://github.com/leanprover-community/mathlib/blob/affine_schemes/src/algebraic_geometry/morphism_into_affine.lean">This file</a> proves the fact that two morphisms into affine schemes are equal if their underlying topological map and the map at the global sections are both equal.<br>
<a href="https://github.com/leanprover-community/mathlib/blob/affine_schemes/src/algebraic_geometry/Spec_fully_faithful.lean">This file</a>  contains the fully-faithful ness of Spec.</p>
<ul>
<li>I've tried to remove <code>to_Spec_Γ</code>, but lean complains about <code>R</code> not equal to <code>CommRing.of ↥R</code>. I moved it out from the part that should go into <code>structure_sheaf.lean</code> though. I'm not sure what the better solution is.</li>
<li>I need the fact that two maps of sheaves (of CommRing) coincide iff they coincide on stalks, and that elements of stalks are all germs. These are proved in <code>Top.presheaves</code> for Type-valued sheaves, but not for CommRing valued sheaves. I could just mirror the proof, but maybe there is a better way to prove that these all hold in good enough concrete categories.</li>
<li>The <code>eq_to_hom</code> is quite annoying and the proof seems unnecessarily long because of it. Is there a better general approach to it?</li>
<li>About <code>op_iso</code>: Yeah, please do PR it. Also it would be great if there is also <code>(inv f).op = inv f.op</code>.</li>
<li>For the localization-at-units thing, is anyone currently working on it? Or should I finish that up.</li>
</ul>



<a name="254152868"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/254152868" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#254152868">(Sep 21 2021 at 04:06)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/tree/affine_schemes">branch#affine_schemes</a> for those looking for a branch name (-;</p>



<a name="254152957"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/254152957" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#254152957">(Sep 21 2021 at 04:08)</a>:</h4>
<p><span class="user-mention" data-user-id="439483">@Andrew Yang</span> great job! Seems like you managed to do a lot in a few days.</p>



<a name="254158587"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/254158587" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#254158587">(Sep 21 2021 at 05:47)</a>:</h4>
<p>These are all steps in the right direction. Many thanks Andrew!</p>



<a name="254172384"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/254172384" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Justus Springer <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#254172384">(Sep 21 2021 at 08:31)</a>:</h4>
<p>Great! Maybe we should make a new directory <code>algebraic_geometry/Spec</code>? Then we could have one file for fully faithfulness and one file for the adjunction.</p>



<a name="254172595"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/254172595" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Justus Springer <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#254172595">(Sep 21 2021 at 08:33)</a>:</h4>
<p><span class="user-mention silent" data-user-id="439483">Andrew Yang</span> <a href="#narrow/stream/113488-general/topic/Status.20of.20algebraic.20geometry/near/254152799">said</a>:</p>
<blockquote>
<ul>
<li>About <code>op_iso</code>: Yeah, please do PR it. Also it would be great if there is also <code>(inv f).op = inv f.op</code>.</li>
</ul>
</blockquote>
<p>Done: <a href="https://github.com/leanprover-community/mathlib/issues/9319">#9319</a>. I'm afraid we can't prove <code>(inv f).op = inv f.op</code>, as <a href="https://leanprover-community.github.io/mathlib_docs/find/category_theory.inv">docs#category_theory.inv</a> is defined using choice. But we do have <a href="https://leanprover-community.github.io/mathlib_docs/find/category_theory.iso.op_inv">docs#category_theory.iso.op_inv</a>.</p>



<a name="254175541"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/254175541" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#254175541">(Sep 21 2021 at 09:02)</a>:</h4>
<p>A new directory is a good idea.</p>



<a name="254187822"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/254187822" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#254187822">(Sep 21 2021 at 10:58)</a>:</h4>
<p><span class="user-mention silent" data-user-id="384542">Justus Springer</span> <a href="#narrow/stream/113488-general/topic/Status.20of.20algebraic.20geometry/near/254172595">said</a>:</p>
<blockquote>
<p>Done: <a href="https://github.com/leanprover-community/mathlib/issues/9319">#9319</a>. I'm afraid we can't prove <code>(inv f).op = inv f.op</code>, as <a href="https://leanprover-community.github.io/mathlib_docs/find/category_theory.inv">docs#category_theory.inv</a> is defined using choice. But we do have <a href="https://leanprover-community.github.io/mathlib_docs/find/category_theory.iso.op_inv">docs#category_theory.iso.op_inv</a>.</p>
</blockquote>
<p>Hmm, is there a place for non-computable lemmas about category theory to go then? <br>
And also things like <code>instance [e : is_equivalence F] : is_equivalence F.op</code>.</p>



<a name="254188676"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/254188676" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#254188676">(Sep 21 2021 at 11:05)</a>:</h4>
<p>It can be proved, it just won't be a definitional equality.</p>



<a name="254188859"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/254188859" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#254188859">(Sep 21 2021 at 11:06)</a>:</h4>
<p><span class="user-mention silent" data-user-id="439483">Andrew Yang</span> <a href="#narrow/stream/113488-general/topic/Status.20of.20algebraic.20geometry/near/254152799">said</a>:</p>
<blockquote>
<ul>
<li>The <code>eq_to_hom</code> is quite annoying and the proof seems unnecessarily long because of it. Is there a better general approach to it?</li>
</ul>
</blockquote>
<p>You're talking about this one, right?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">top_map_of</span> <span class="o">:</span> <span class="n">Top_obj</span> <span class="n">R</span> <span class="bp">⟶</span> <span class="n">Top_obj</span> <span class="n">S</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span>
  <span class="n">refine</span> <span class="o">(</span><span class="n">eq_to_hom</span> <span class="n">_</span><span class="o">)</span> <span class="bp">≫</span> <span class="n">f.val.base</span> <span class="bp">≫</span> <span class="o">(</span><span class="n">eq_to_hom</span> <span class="n">_</span><span class="o">)</span><span class="bp">;</span>
  <span class="n">dsimp</span> <span class="n">only</span> <span class="o">[</span><span class="n">to_LocallyRingedSpace</span><span class="o">,</span> <span class="n">LocallyRingedSpace_obj</span><span class="o">,</span> <span class="n">opposite.unop_op</span><span class="o">]</span><span class="bp">;</span>
  <span class="n">refl</span>
<span class="o">}</span>
</code></pre></div>



<a name="254189046"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/254189046" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#254189046">(Sep 21 2021 at 11:08)</a>:</h4>
<p>Just looking at it, I'm not sure why the <code>eq_to_hom</code>s should be necessary at all since the equalities involved are definitional. What happens if you leave them out? Does Lean just take a long time?</p>



<a name="254193985"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/254193985" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Justus Springer <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#254193985">(Sep 21 2021 at 11:54)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/113488-general/topic/Status.20of.20algebraic.20geometry/near/254188676">said</a>:</p>
<blockquote>
<p>It can be proved, it just won't be a definitional equality.</p>
</blockquote>
<p>Oh of course, inverses are unique!</p>



<a name="254194220"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/254194220" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Justus Springer <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#254194220">(Sep 21 2021 at 11:56)</a>:</h4>
<p><span class="user-mention silent" data-user-id="439483">Andrew Yang</span> <a href="#narrow/stream/113488-general/topic/Status.20of.20algebraic.20geometry/near/254187822">said</a>:</p>
<blockquote>
<p>And also things like <code>instance [e : is_equivalence F] : is_equivalence F.op</code>.</p>
</blockquote>
<p>We only have the bundled version: <a href="https://leanprover-community.github.io/mathlib_docs/find/category_theory.equivalence.op">docs#category_theory.equivalence.op</a>.</p>



<a name="254196637"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/254196637" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Justus Springer <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#254196637">(Sep 21 2021 at 12:14)</a>:</h4>
<p><span class="user-mention silent" data-user-id="439483">Andrew Yang</span> <a href="#narrow/stream/113488-general/topic/Status.20of.20algebraic.20geometry/near/254152799">said</a>:</p>
<blockquote>
<ul>
<li>I need the fact that two maps of sheaves (of CommRing) coincide iff they coincide on stalks, and that elements of stalks are all germs. These are proved in <code>Top.presheaves</code> for Type-valued sheaves, but not for CommRing valued sheaves. I could just mirror the proof, but maybe there is a better way to prove that these all hold in good enough concrete categories.</li>
</ul>
</blockquote>
<p>Indeed, I've just generalized this (and other stuff in <code>topology/sheaves/stalks</code>) on <a href="https://github.com/leanprover-community/mathlib/tree/spec_gamma_adjunction">branch#spec_gamma_adjunction</a>. It should now be applicable to any concrete category, whose forgetful functor reflects isomorphisms, preserves limits and filtered colimits. This is exactly why I needed this whole filtered colimits stuff.</p>



<a name="254197508"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/254197508" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Justus Springer <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#254197508">(Sep 21 2021 at 12:22)</a>:</h4>
<p><span class="user-mention" data-user-id="439483">@Andrew Yang</span> I think it's promising that we are discovering the same sorts of issues here. We should probably coordinate our efforts closely :)</p>



<a name="254197628"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/254197628" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Justus Springer <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#254197628">(Sep 21 2021 at 12:23)</a>:</h4>
<p>May I use this occasion to mention that I am still waiting for reviews on <a href="https://github.com/leanprover-community/mathlib/issues/9101">#9101</a>. I know it's a big one, but it seems like this is crucial for further development :)</p>



<a name="254197921"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/254197921" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#254197921">(Sep 21 2021 at 12:25)</a>:</h4>
<p><span class="user-mention" data-user-id="384542">@Justus Springer</span> you should have pinged earlier! I'll try to take a look today!</p>



<a name="254198195"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/254198195" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Justus Springer <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#254198195">(Sep 21 2021 at 12:27)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span> Thanks! I just noticed yesterday that some tests were getting canceled for some reason, which is why it didn't show up on <a href="https://bit.ly/3kaztxO">#queue</a>. I merged master again, now it succeeds.</p>



<a name="254199714"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/254199714" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#254199714">(Sep 21 2021 at 12:38)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/113488-general/topic/Status.20of.20algebraic.20geometry/near/254188676">said</a>:</p>
<blockquote>
<p>It can be proved, it just won't be a definitional equality.</p>
</blockquote>
<p>Oh I thought there were some constructivist concerns or such. I'll add it somewhere.</p>



<a name="254201098"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/254201098" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#254201098">(Sep 21 2021 at 12:49)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/113488-general/topic/Status.20of.20algebraic.20geometry/near/254189046">said</a>:</p>
<blockquote>
<p>Just looking at it, I'm not sure why the <code>eq_to_hom</code>s should be necessary at all since the equalities involved are definitional. What happens if you leave them out? Does Lean just take a long time?</p>
</blockquote>
<p>Lean complains that the types don't match. If I don't write out the <code>eq_to_hom</code> explicitly, they be come <code>_.mpr</code>'s, which are also a pain to work with.</p>
<p>The more tricky one is the <code>coerce</code> from <code>f _* O(X)</code> to <code>g _*O(X)</code>. I can understand that it is needed, but my goal becomes a mess, and I needed stuff like </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">let</span> <span class="n">F</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">U</span><span class="o">),</span> <span class="o">(</span><span class="n">structure_sheaf</span> <span class="n">R</span><span class="o">)</span><span class="bp">.</span><span class="n">presheaf.germ</span> <span class="n">x</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span><span class="o">),</span> <span class="n">F</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">F</span> <span class="n">b</span> <span class="bp">≫</span> <span class="n">eq_to_hom</span> <span class="o">(</span><span class="kd">by</span> <span class="n">rw</span> <span class="n">H</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span> <span class="n">H</span><span class="o">,</span> <span class="kd">by</span> <span class="n">subst</span> <span class="n">H</span><span class="bp">;</span> <span class="n">simp</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">this</span><span class="o">,</span>
</code></pre></div>
<p>to solve it, since simply <code>rw H</code> says that the motive is not type correct. I am wondering if there is a better way to do this.</p>



<a name="254739968"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/254739968" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Justus Springer <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#254739968">(Sep 24 2021 at 17:17)</a>:</h4>
<p>I just PR'd <a href="https://github.com/leanprover-community/mathlib/issues/9357">#9357</a>, generalizing things like <code>germ_exist</code> and other stalk-related lemmas from sheaves valued in <code>Type</code> to any "nice enough" concrete category.</p>



<a name="256930540"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/256930540" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#256930540">(Oct 10 2021 at 06:37)</a>:</h4>
<p>I have proven that a "morphism on a basis" from a presheaf to a sheaf (with values in an arbitrary category) on a topological space can be extended to an actual morphism (on all open sets): <a href="https://github.com/alreadydone/mathlib/commit/121a3444131fc1180ca021552b47b7563aebcaa5#diff-d7cc616887430b2cb5792e3d691f45c1bbc3eaa32c3abf1c4e735ab8b9a904d9R152">https://github.com/alreadydone/mathlib/commit/121a3444131fc1180ca021552b47b7563aebcaa5#diff-d7cc616887430b2cb5792e3d691f45c1bbc3eaa32c3abf1c4e735ab8b9a904d9R152</a><br>
This appears necessary to construct the sheaf morphism in the Spec-Gamma adjunction; it should be equivalent to <a href="https://stacks.math.columbia.edu/tag/009V">https://stacks.math.columbia.edu/tag/009V</a> (except that the source need not be a sheaf) which is used in the Stacks Project proof. My proof doesn't involve colimits like in <a href="https://stacks.math.columbia.edu/tag/009Q">https://stacks.math.columbia.edu/tag/009Q</a> and only involves limits that are guaranteed to exist by the sheaf condition, so it works with any category of values (provided that the opens_le_cover formulation of the sheaf condition is used (which I think is the one that should be used in the definition of a sheaf)). Such a construction of extension is mentioned in the comment <a href="https://stacks.math.columbia.edu/tag/009H#comment-2589">https://stacks.math.columbia.edu/tag/009H#comment-2589</a> and a reference for it is The Geometry of Schemes (GTM 197), p.17 (Stacks Project and the comment actually only talk about extension of a sheaf on a basis to all open sets and not a morphism, but in the case of the Spec-Gamma adjunction we already have the sheaves, so we only need to extend the morphism).</p>
<p>Comments are welcome! The proofs are clumsy and I feel I'm missing some tricks; the style/naming may not yet conform to the mathlib norm; the implicit arguments may not be optimal; and I'm not sure if the is_basis and sheaf condition assumptions should be instances.</p>
<p>Together with the nice preliminary work like <a href="https://github.com/leanprover-community/mathlib/issues/9101">#9101</a> I imagine it's now relatively easy to prove the adjunction, and will work towards that goal given that <span class="user-mention" data-user-id="384542">@Justus Springer</span> is less active now (as he said, he has less time in October).</p>



<a name="256932938"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/256932938" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#256932938">(Oct 10 2021 at 07:18)</a>:</h4>
<p>I wonder how everyone would feel about rearranging things so <code>opens_le_cover</code> becomes the official definition?</p>



<a name="256940477"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/256940477" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Justus Springer <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#256940477">(Oct 10 2021 at 09:24)</a>:</h4>
<p>Thanks <span class="user-mention" data-user-id="224323">@Junyan Xu</span> , it's great to see that more people are working on this! Note that development on this adjunction is still ongoing. I will have less time for Lean in October, but I will try to help finish the adjunction. <span class="user-mention" data-user-id="439483">@Andrew Yang</span> and I have also been working on doing sheaves on topological bases. Our goal is to get the equivalence of categories between sheaves on a bases and sheaves on all open sets. But because defining "sheaf on a basis" directly would be too much of a duplication of the original sheaf definition, we are trying to embed it into the general theory of sheaves on sites. In particular, Andrew has shown recently (<a href="https://github.com/leanprover-community/mathlib/issues/9431">#9431</a>) that a cover-lifting functors between sites <code>G : C ⥤ D</code> extends to a functor between sheaves on <code>C</code> to sheaves on <code>D</code>. The way it's done has to do with the right Kan extension of a functor and it's a vast generalization of how you use limits to define the extension of a sheaf on a basis. But Andrew can tell you more about this than me. The abstract statement we are going for will be something like this: A cover-lifting fully faithful functor <code>G : C ⥤ D</code> between sites induces an equivalence of categories between sheaves on <code>C</code> and sheaves on <code>D</code>. This then gets applied to the inclusion functor <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">B</mi><mo>→</mo><mi>O</mi><mi>p</mi><mi>e</mi><mi>n</mi><mi>s</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{B}\to Opens(X)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathcal" style="margin-right:0.03041em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">Op</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">s</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span></span> from a topological bases to all open sets, which is easily seen to be cover-lifting and fully faithful.</p>



<a name="256940610"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/256940610" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Justus Springer <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#256940610">(Oct 10 2021 at 09:26)</a>:</h4>
<p>Another part of the puzzle is to finally connect the theory of sheaves on spaces to sheaves on sites, which is something I worked on and PR'd a few days ago: <a href="https://github.com/leanprover-community/mathlib/issues/9609">#9609</a></p>



<a name="256940874"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/256940874" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Justus Springer <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#256940874">(Oct 10 2021 at 09:31)</a>:</h4>
<p>Admitted, for the Gamma-Spec adjunction, it is not necessary to know about the full equivalence between sheaves on bases and sheaves on the whole space. You don't even need to define sheaves on bases. You just need to know how to extend morphisms. So what you have done <span class="user-mention" data-user-id="224323">@Junyan Xu</span>  would be the more direct route. I don't know what would be the best route to continue, but I think developing a bit of abstract API about sheaves on sites would be worth the detour.</p>



<a name="256941051"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/256941051" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Justus Springer <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#256941051">(Oct 10 2021 at 09:34)</a>:</h4>
<p>Also note that I have a tiny bit of code lying around on <a href="https://github.com/leanprover-community/mathlib/tree/spec_gamma_adjunction">branch#spec_gamma_adjunction</a>. For some reason I decided a long time ago that it would be best to do the adjunction via defining unit and counit: The unit would be the isomorphism <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>≅</mo><msub><mi mathvariant="script">O</mi><mrow><mi>S</mi><mi>p</mi><mi>e</mi><mi>c</mi><mo stretchy="false">(</mo><mi>R</mi><mo stretchy="false">)</mo></mrow></msub><mo stretchy="false">(</mo><mi>S</mi><mi>p</mi><mi>e</mi><mi>c</mi><mo stretchy="false">(</mo><mi>R</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">R \cong \mathcal{O}_{Spec(R)}(Spec(R))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≅</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1052em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">Sp</span><span class="mord mathnormal mtight">ec</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">Sp</span><span class="mord mathnormal">ec</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mclose">))</span></span></span></span> (which already exists) and for the counit, you'd need to define a morphism <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>S</mi><mi>p</mi><mi>e</mi><mi>c</mi><mo stretchy="false">(</mo><msub><mi mathvariant="script">O</mi><mi>X</mi></msub><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X \to Spec(\mathcal{O}_X(X))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">Sp</span><span class="mord mathnormal">ec</span><span class="mopen">(</span><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07847em;">X</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">))</span></span></span></span> for all locally ringed spaces. I have defined this morphism already as a continuous map, all that's missing is the corresponding sheaf homomorphism, seeing that it's local on stalks, and the triangle identities.</p>



<a name="256988460"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/256988460" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#256988460">(Oct 10 2021 at 22:04)</a>:</h4>
<p>Thanks <span class="user-mention" data-user-id="384542">@Justus Springer</span> for the updates on recent progress and roadmap; great to see that you're still actively contributing! I searched and saw you haven't posted on Zulip since the end of September, and didn't find recent PRs by you on Github, so I assumed you're not active; now I realize I should add <code>author:</code> when searching for PRs.</p>
<p>I've only heard the name "Kan extension" before but never saw its definition or what it's used for, and my knowledge on Grothendieck topologies is rusty, but more generality and categorical foundations are definitely nice (especially as we work towards etale cohomology)! For example, I was trying to find an easy way to express the restriction of a presheaf morphism to a subcategory of the opens when I saw the definition of horizontal composition in mathlib documentation, and then realized that the restriction is a special case. I'm also glad to see PR <a href="https://github.com/leanprover-community/mathlib/issues/9609">#9609</a> connecting a general definition to a special one.</p>
<p>As for the adjunction, I was thinking of using <code>mk_of_hom_equiv</code>, but will now also consider the unit-counit route to see if it's easier. I see that <span class="user-mention" data-user-id="439483">@Andrew Yang</span> has defined the unit in <a href="https://github.com/leanprover-community/mathlib/blob/affine_schemes/src/algebraic_geometry/global_section_of_spec.lean#L67">global_section_of_spec.lean</a> except for a <code>sorry</code> for localization at units. I've also seen your nice work in <a href="https://github.com/leanprover-community/mathlib/tree/spec_gamma_adjunction">branch#spec_gamma_adjunction</a>, but unfortunately after merging master it becomes quite hard to find the relevant commits.</p>



<a name="256988498"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/256988498" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#256988498">(Oct 10 2021 at 22:05)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110087">Scott Morrison</span> <a href="#narrow/stream/113488-general/topic/Status.20of.20algebraic.20geometry/near/256932938">said</a>:</p>
<blockquote>
<p>I wonder how everyone would feel about rearranging things so <code>opens_le_cover</code> becomes the official definition?</p>
</blockquote>
<p>Oh sorry, I actually meant to propose to promote the <code>pairwise_intersections</code> definition to the official one. It's a natural generalization of the standard definition (<code>unique_gluing</code>, which is like <code>pairwise_intersections</code> applied to cones with cone point the free object on one element), and works for arbitrary category of values (doesn't require <code>has_products</code>) that only makes sense with concrete categories. Although <code>opens_le_cover</code> may be more convenient, we can go between both easily without <code>has_products</code>.</p>



<a name="256989637"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/256989637" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#256989637">(Oct 10 2021 at 22:21)</a>:</h4>
<p>About the sheaves on basis stuff, the current plan is to formalize <a href="/user_uploads/3121/i_7aZlNiTkru8oTq-XHRKDiD/image.png">Theorem C2.2.3</a> in the elephant. Currently the functors on two sided are both constructed (in <a href="https://github.com/leanprover-community/mathlib/issues/9431">#9431</a> and <a href="https://github.com/leanprover-community/mathlib/issues/9650">#9650</a>), and it remains to show that the two functors are indeed inverses to each other. One side follows straight from existing lemmas in the mathlib, but the other side probably needs more work. That said, this construction still requires some existence of limits since Kan extension needs them. It would be great if these conditions can be inferred straight from the sheaf conditions and removed.</p>
<div class="message_inline_image"><a href="/user_uploads/3121/i_7aZlNiTkru8oTq-XHRKDiD/image.png" title="Theorem C2.2.3"><img src="/user_uploads/3121/i_7aZlNiTkru8oTq-XHRKDiD/image.png"></a></div><p>As for the counit, it is already tidied up and merged into master as <a href="https://leanprover-community.github.io/mathlib_docs/algebraic_geometry/Spec.html#algebraic_geometry.Spec_Γ_identity">docs#algebraic_geometry.Spec_Γ_identity</a>.</p>



<a name="256993412"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/256993412" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#256993412">(Oct 10 2021 at 23:27)</a>:</h4>
<p>Yeah I just saw <a href="https://github.com/leanprover-community/mathlib/issues/9416">#9416</a> a few minutes before you posted. Very nice! I think (at least in the topological space case) you'll need the existence of appropriate limits to extend a sheaf on a basis to all open sets (to define the objects at open sets not in the basis), but you probably don't need it to extend morphisms, as in the topological space case.</p>



<a name="256995275"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/256995275" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#256995275">(Oct 11 2021 at 00:01)</a>:</h4>
<p>btw, it seems I and <span class="user-mention" data-user-id="384542">@Justus Springer</span> agree that what you constructed is the unit (at least if we're proving the adjunction between Spec.right_op and Gamma, and not between Gamma.right_op and Spec), but you call it the counit ...</p>



<a name="257008546"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/257008546" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#257008546">(Oct 11 2021 at 03:55)</a>:</h4>
<p>Hmmm, isn't <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Γ</mi><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">S</mi><mi mathvariant="normal">p</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">c</mi></mrow><mo stretchy="false">(</mo><mi>R</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>→</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">\Gamma(\mathrm{Spec}(R)) \to R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Γ</span><span class="mopen">(</span><span class="mord"><span class="mord mathrm">Spec</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mclose">))</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> the counit and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mrow><mi mathvariant="normal">S</mi><mi mathvariant="normal">p</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">c</mi></mrow><mo stretchy="false">(</mo><mi mathvariant="normal">Γ</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X \to \mathrm{Spec}(\Gamma(X))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">Spec</span></span><span class="mopen">(</span><span class="mord">Γ</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">))</span></span></span></span> the unit of the adjunction?<br>
If I'm wrong, the docs in mathlib about the iso probably needs fixing as well..</p>



<a name="257009727"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/257009727" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#257009727">(Oct 11 2021 at 04:12)</a>:</h4>
<p>The unit is the inverse map <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>→</mo><mi mathvariant="normal">Γ</mi><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">S</mi><mi mathvariant="normal">p</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">c</mi></mrow><mo stretchy="false">(</mo><mi>R</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">R\to\Gamma(\mathrm{Spec}(R))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Γ</span><span class="mopen">(</span><span class="mord"><span class="mord mathrm">Spec</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mclose">))</span></span></span></span> in CommRing<br>
The counit is indeed <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mrow><mi mathvariant="normal">S</mi><mi mathvariant="normal">p</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">c</mi></mrow><mo stretchy="false">(</mo><mi mathvariant="normal">Γ</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X \to \mathrm{Spec}(\Gamma(X))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">Spec</span></span><span class="mopen">(</span><span class="mord">Γ</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">))</span></span></span></span> but in the opposite category of LocallyRingedSpace so the arrow is reversed.</p>



<a name="257011262"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/257011262" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#257011262">(Oct 11 2021 at 04:37)</a>:</h4>
<p>Oh I forgot the opposites <span aria-label="sweat" class="emoji emoji-1f613" role="img" title="sweat">:sweat:</span> <br>
Will probably fix the docs when the adjunction is actually done then...</p>



<a name="257013296"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/257013296" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#257013296">(Oct 11 2021 at 05:08)</a>:</h4>
<p>Another related problem is that you wrote Γ ⊣ Spec: if Γ is the left adjoint then the adjunction should be between Γ.right_op and Spec (between categories LocallyRingedSpace and CommRing^op), but since you have been working with Spec.right_op and Gamma, we'd probably like to change it to Spec ⊣ Γ.</p>



<a name="257027686"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/257027686" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Justus Springer <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#257027686">(Oct 11 2021 at 08:05)</a>:</h4>
<p>I also always confuse unit/counit and left/right in this adjunction. <span class="user-mention" data-user-id="224323">@Junyan Xu</span> I also didn't know much about grothendieck topologies a few weeks ago, I'm learning as I'm going.</p>



<a name="257028151"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/257028151" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Justus Springer <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#257028151">(Oct 11 2021 at 08:09)</a>:</h4>
<p>Regarding the sheaf definition, yeah since the <code>pairwise_intersections</code> definition doesn't require products, it should probably become the official definition. The general definition of a sheaf on a site also doesn't require products. However, my proof that the definition on sites is equivalent to the definition on spaces works with the equalizer definition, so the proof would have to be redone. Maybe we can do this later, I doubt that this extra bit of generality will be needed soon.</p>



<a name="257028539"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/257028539" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#257028539">(Oct 11 2021 at 08:13)</a>:</h4>
<p>Concerning fibre products of schemes (which have also been discussed in this thread), I stumbled upon <a href="http://math.stanford.edu/~vakil/d/FOAG/BOfiber-prods.pdf">http://math.stanford.edu/~vakil/d/FOAG/BOfiber-prods.pdf</a> which is a nice way to organize things, I think.</p>



<a name="257028612"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/257028612" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#257028612">(Oct 11 2021 at 08:14)</a>:</h4>
<p>Also, getting the definition of a Zariski sheaf in mathlib would be a nice side effect (-;</p>



<a name="257355556"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/257355556" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Justus Springer <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#257355556">(Oct 13 2021 at 12:22)</a>:</h4>
<p>I think I will have to come to terms with the fact that I won’t have as much time for Lean now than I had in September. I will shift focus now and concentrate on my MSc thesis, so will probably no longer contribute to mathlib for a while. I was not able to finish the Gamma-Spec adjunction, which is a project I’ve been working on for the last month or two, and indirectly even longer. But I think it’s in reach now and it will be an important milestone. I thought I’d post here some of my thoughts on the adjunction in general, where I left off and how I think one can proceed. Maybe someone will find it useful.</p>
<div class="spoiler-block"><div class="spoiler-header">
</div><div class="spoiler-content" aria-hidden="true">
<p>I left some code on <a href="https://github.com/leanprover-community/mathlib/tree/spec_gamma_adjunction">branch#spec_gamma_adjunction</a>, outlining the way I imagine the construction would go. I don’t claim ownership to this branch anymore, anyone can feel free to adopt it. The construction roughly follows <a href="https://stacks.math.columbia.edu/tag/01I1">stacks#01I1</a>. However, when I was working through the stacks proof, I somehow got the feeling that it might be easier to do the adjunction via providing unit and counit instead of the hom-equivalence. But this is not set in stone and the construction is very similar. </p>
<p>The unit already exists, it’s the isomorphism <a href="https://leanprover-community.github.io/mathlib_docs/algebraic_geometry/Spec.html#algebraic_geometry.Spec_%CE%93_identity">docs#algebraic_geometry.Spec_Γ_identity</a>. For the counit, the task is to construct a morphism of locally ringed spaces <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ψ</mi><mspace></mspace><mspace width="0.1111111111111111em"/><mo lspace="0em" rspace="0.17em"></mo><mtext> ⁣</mtext><mo lspace="0em" rspace="0em">:</mo><mspace width="0.3333333333333333em"/><mi>X</mi><mo>→</mo><mrow><mi mathvariant="normal">S</mi><mi mathvariant="normal">p</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">c</mi></mrow><mo stretchy="false">(</mo><mi mathvariant="normal">Γ</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\psi\colon X\to{\rm Spec}(\Gamma(X))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">ψ</span><span class="mspace nobreak"></span><span class="mspace" style="margin-right:0.1111111111111111em;"></span><span class="mpunct"></span><span class="mspace" style="margin-right:-0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mrel">:</span></span><span class="mspace" style="margin-right:0.3333333333333333em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">Spec</span></span></span><span class="mopen">(</span><span class="mord">Γ</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">))</span></span></span></span> for every locally ringed space <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span>. As a map, this sends a point <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∈</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">x\in X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> to the prime ideal of all <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>∈</mo><mi mathvariant="normal">Γ</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f\in\Gamma(X)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Γ</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span></span> that <em>vanish</em> in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span>, i.e. such that the germ of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> at <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span> is a non-unit. I proved this to be continuous already on <a href="https://github.com/leanprover-community/mathlib/tree/spec_gamma_adjunction">branch#spec_gamma_adjunction</a>. For the sheaf morphism, one has to construct a map <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="script">O</mi><mrow><mrow><mi mathvariant="normal">S</mi><mi mathvariant="normal">p</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">c</mi></mrow><mo stretchy="false">(</mo><mi mathvariant="normal">Γ</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow></msub><mo stretchy="false">(</mo><mi>U</mi><mo stretchy="false">)</mo><mo>→</mo><msub><mi mathvariant="script">O</mi><mi>X</mi></msub><mo stretchy="false">(</mo><msup><mi>ψ</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mi>U</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}_{{\rm Spec}(\Gamma(X))}(U)\to\mathcal{O}_X(\psi^{-1}(U))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1052em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathrm mtight">Spec</span></span></span><span class="mopen mtight">(</span><span class="mord mtight">Γ</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.07847em;">X</span><span class="mclose mtight">))</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07847em;">X</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">ψ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mclose">))</span></span></span></span> for all <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi><mo>⊂</mo><mrow><mi mathvariant="normal">S</mi><mi mathvariant="normal">p</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">c</mi></mrow><mi mathvariant="normal">Γ</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">U\subset {\rm Spec}\Gamma(X)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊂</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">Spec</span></span></span><span class="mord">Γ</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span></span>. It is at this point that we need to know how to extend a morphism of sheaves on a basis, as this morphism can only directly be defined on basic opens <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi><mo>=</mo><mi>D</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">U=D(f)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span></span></span></span>. This is the biggest hole in the construction right now, as soon as this has been settled (either by proving the comparison theorem of topos theory as <span class="user-mention" data-user-id="439483">@Andrew Yang</span>  is doing, or by a more direct approach a la <span class="user-mention" data-user-id="224323">@Junyan Xu</span> ), the rest of the construction should be pretty lean-able I believe.</p>
<p>To get the morphism <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="script">O</mi><mrow><mrow><mi mathvariant="normal">S</mi><mi mathvariant="normal">p</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">c</mi></mrow><mo stretchy="false">(</mo><mi mathvariant="normal">Γ</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow></msub><mo stretchy="false">(</mo><mi>D</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>→</mo><msub><mi mathvariant="script">O</mi><mi>X</mi></msub><mo stretchy="false">(</mo><msup><mi>ψ</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mi>D</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}_{{\rm Spec}(\Gamma(X))}(D(f))\to\mathcal{O}_X(\psi^{-1}(D(f)))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1052em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathrm mtight">Spec</span></span></span><span class="mopen mtight">(</span><span class="mord mtight">Γ</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.07847em;">X</span><span class="mclose mtight">))</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">))</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07847em;">X</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">ψ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)))</span></span></span></span>, note that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>ψ</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mi>D</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><msub><mi>D</mi><mi>X</mi></msub><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\psi^{-1}(D(f))=D_X(f)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">ψ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">))</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07847em;">X</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span></span></span></span> where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mi>X</mi></msub><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo>⊂</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">D_X(f)\subset X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07847em;">X</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊂</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> is the basic open on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span>, as defined in <a href="https://leanprover-community.github.io/mathlib_docs/find/algebraic_geometry.RingedSpace.basic_open">docs#algebraic_geometry.RingedSpace.basic_open</a>. By <a href="https://leanprover-community.github.io/mathlib_docs/find/algebraic_geometry.RingedSpace.is_unit_res_basic_open">docs#algebraic_geometry.RingedSpace.is_unit_res_basic_open</a>, the restriction <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Γ</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo>→</mo><msub><mi mathvariant="script">O</mi><mi>X</mi></msub><mo stretchy="false">(</mo><msub><mi>D</mi><mi>X</mi></msub><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Gamma(X)\to\mathcal{O}_X(D_X(f))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Γ</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07847em;">X</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07847em;">X</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">))</span></span></span></span> sends <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> to a unit, hence lifts to a map <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Γ</mi><mo stretchy="false">(</mo><mi>X</mi><msub><mo stretchy="false">)</mo><mi>f</mi></msub><mo>→</mo><msub><mi mathvariant="script">O</mi><mi>X</mi></msub><mo stretchy="false">(</mo><msub><mi>D</mi><mi>X</mi></msub><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Gamma(X)_f\to\mathcal{O}_X(D_X(f))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord">Γ</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07847em;">X</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07847em;">X</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">))</span></span></span></span>. Composing this with <a href="https://leanprover-community.github.io/mathlib_docs/find/algebraic_geometry.structure_sheaf.basic_open_iso">docs#algebraic_geometry.structure_sheaf.basic_open_iso</a> gives you the desired map.</p>
<p>Excluding the issue of extending from a basis, the sorries left on <a href="https://github.com/leanprover-community/mathlib/tree/spec_gamma_adjunction">branch#spec_gamma_adjunction</a> are as follows:</p>
<ol>
<li>Show naturality of the sheaf homomorphism on basic opens. </li>
<li>Show that the stalk maps of the sheaf homomorphism are local. </li>
<li>Show naturality of the counit <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mrow><mi mathvariant="normal">S</mi><mi mathvariant="normal">p</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">c</mi></mrow><mo stretchy="false">(</mo><mi mathvariant="normal">Γ</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X\to{\rm Spec}(\Gamma(X))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">Spec</span></span></span><span class="mopen">(</span><span class="mord">Γ</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">))</span></span></span></span> in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span>. </li>
<li>Show the left triangle identity. </li>
<li>Show the right triangle identity.</li>
</ol>
<p>I am fairly confident that all of these should be pretty doable, but I haven’t tried in detail. Maybe someone else has already done some of them. For (2), I’d imagine we want to show that that the germ map <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Γ</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo>→</mo><msub><mi mathvariant="script">O</mi><mrow><mi>X</mi><mo separator="true">,</mo><mi>x</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\Gamma(X)\to\mathcal{O}_{X,x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Γ</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.328331em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.07847em;">X</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> is a localisation map for the prime ideal <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ψ</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\psi(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">ψ</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>, hence gives an isomorphism <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Γ</mi><mo stretchy="false">(</mo><mi>X</mi><msub><mo stretchy="false">)</mo><mrow><mi>ψ</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></msub><mo>≅</mo><msub><mi mathvariant="script">O</mi><mrow><mi>X</mi><mo separator="true">,</mo><mi>x</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\Gamma(X)_{\psi(x)}\cong \mathcal{O}_{X,x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1052em;vertical-align:-0.3551999999999999em;"></span><span class="mord">Γ</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">ψ</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">x</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≅</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.328331em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.07847em;">X</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>. Then we should show (by some uniqueness argument) that the stalk map <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ψ</mi><mi>x</mi></msub><mspace></mspace><mspace width="0.1111111111111111em"/><mo lspace="0em" rspace="0.17em"></mo><mtext> ⁣</mtext><mo lspace="0em" rspace="0em">:</mo><mspace width="0.3333333333333333em"/><msub><mi mathvariant="script">O</mi><mrow><mrow><mi mathvariant="normal">S</mi><mi mathvariant="normal">p</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">c</mi></mrow><mo stretchy="false">(</mo><mi mathvariant="normal">Γ</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>ψ</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></msub><mo>→</mo><msub><mi mathvariant="script">O</mi><mrow><mi>X</mi><mo separator="true">,</mo><mi>x</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\psi_x\colon\mathcal{O}_{{\rm Spec}(\Gamma(X)), \psi(x)}\to\mathcal{O}_{X,x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04964em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">ψ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace nobreak"></span><span class="mspace" style="margin-right:0.1111111111111111em;"></span><span class="mpunct"></span><span class="mspace" style="margin-right:-0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mrel">:</span></span><span class="mspace" style="margin-right:0.3333333333333333em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathrm mtight">Spec</span></span></span><span class="mopen mtight">(</span><span class="mord mtight">Γ</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.07847em;">X</span><span class="mclose mtight">))</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">ψ</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">x</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.328331em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.07847em;">X</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> is equal to the composition of isomorphisms <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="script">O</mi><mrow><mrow><mi mathvariant="normal">S</mi><mi mathvariant="normal">p</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">c</mi></mrow><mo stretchy="false">(</mo><mi mathvariant="normal">Γ</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>ψ</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></msub><mo>→</mo><mi mathvariant="normal">Γ</mi><mo stretchy="false">(</mo><mi>X</mi><msub><mo stretchy="false">)</mo><mrow><mi>ψ</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></msub><mo>→</mo><msub><mi mathvariant="script">O</mi><mrow><mi>X</mi><mo separator="true">,</mo><mi>x</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\mathcal{O}_{{\rm Spec}(\Gamma(X)), \psi(x)}\to\Gamma(X)_{\psi(x)}\to\mathcal{O}_{X,x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.03853em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathrm mtight">Spec</span></span></span><span class="mopen mtight">(</span><span class="mord mtight">Γ</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.07847em;">X</span><span class="mclose mtight">))</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">ψ</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">x</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1052em;vertical-align:-0.3551999999999999em;"></span><span class="mord">Γ</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">ψ</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">x</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.328331em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.07847em;">X</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>, hence is local. Here, the first isomorphism is <a href="https://leanprover-community.github.io/mathlib_docs/find/algebraic_geometry.structure_sheaf.stalk_iso">docs#algebraic_geometry.structure_sheaf.stalk_iso</a>.</p>
<p>I don’t know how difficult it is to prove the triangle identities. Ultimately, that will probably decide whether it’s better to do the adjunction via unit/counit or the hom-equivalence. </p>
</div></div>



<a name="257356114"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/257356114" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#257356114">(Oct 13 2021 at 12:26)</a>:</h4>
<p><span class="user-mention" data-user-id="384542">@Justus Springer</span> Thanks a lot for your contributions so far! What's your MSc project about?</p>



<a name="257356996"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/257356996" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Justus Springer <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#257356996">(Oct 13 2021 at 12:33)</a>:</h4>
<p>It was very fun! About my MSc project, I don't know for sure, I'm just starting out. But it will involve Cox Rings and some classification of Fano varieties with a torus action of complexity one :)</p>



<a name="259812182"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/259812182" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#259812182">(Oct 31 2021 at 22:37)</a>:</h4>
<p>Didn't expect it to take so long, but I finally finished the job before November! The Gamma-Spec adjunction is now defined and mathlib build succeeded on the cloud, even though some proofs are slow (to be improved, but I guess you can start reviewing the PR <a href="https://github.com/leanprover-community/mathlib/issues/9802">#9802</a>!). And I chose to establish Gamma —| Spec instead of Spec —| Gamma, so no change in earlier documentation is needed.</p>



<a name="259822893"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/259822893" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#259822893">(Nov 01 2021 at 03:18)</a>:</h4>
<p>TIL the categories of ringed spaces and of locally ringed spaces have arbitrary limits, from this note by Martin Brandenburg: <a href="https://www.dropbox.com/s/y5t58kugrcaqbx8/fiber-products-of-locally-ringed-spaces-and-schemes.pdf?dl=0">https://www.dropbox.com/s/y5t58kugrcaqbx8/fiber-products-of-locally-ringed-spaces-and-schemes.pdf?dl=0</a><br>
And he then derives that the category of schemes has finite limits (4.3), because a finite intersection of opens is open and such open affines cover the whole space.<br>
Seems a totally different construction than what I've learned and no gluing is involved! Maybe this is what we should aim for.</p>
<p>I found the pdf from <a href="https://mathoverflow.net/questions/13616/a-book-on-locally-ringed-spaces">https://mathoverflow.net/questions/13616/a-book-on-locally-ringed-spaces</a> in turn from <a href="https://math.stackexchange.com/questions/1033675/does-the-category-of-locally-ringed-spaces-have-products">https://math.stackexchange.com/questions/1033675/does-the-category-of-locally-ringed-spaces-have-products</a><br>
because after defining the adjunction between LRS and CommRing I was curious whether LRS also has fibred products: turns out it has much more.</p>
<div class="message_inline_ref"><a href="https://www.dropbox.com/s/y5t58kugrcaqbx8/fiber-products-of-locally-ringed-spaces-and-schemes.pdf?dl=0" title="fiber-products-of-locally-ringed-spaces-and-schemes.pdf"><img src="https://uploads.zulipusercontent.net/1a192ecf0bd2f7327bba38dc788812e1cf04327a/68747470733a2f2f7777772e64726f70626f782e636f6d2f7374617469632f696d616765732f737065637472756d2d69636f6e732f67656e6572617465642f636f6e74656e742f636f6e74656e742d7064662d6c617267652e706e67"></a><div><div class="message_inline_image_title">fiber-products-of-locally-ringed-spaces-and-schemes.pdf</div><desc class="message_inline_image_desc"></desc></div></div>



<a name="259829972"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/259829972" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#259829972">(Nov 01 2021 at 06:03)</a>:</h4>
<p>Ooh, I'll have to read that when I have a bit more time! That seems like a interesting approach!</p>



<a name="259829996"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/259829996" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#259829996">(Nov 01 2021 at 06:03)</a>:</h4>
<p>I would have expected that you need separatedness for the "intersection of opens is opens and such open affines cover" bit of the argument. But like I said: I should read that pdf first.</p>



<a name="259982777"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/259982777" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#259982777">(Nov 02 2021 at 11:33)</a>:</h4>
<p>Here is an outline of a proof that <code>Scheme</code> has (binary) fiber products from the assumption that LRS has them. The fiber product in LRS is also the fiber product in <code>Scheme</code> provided the object lies in <code>Scheme</code>, so we only need to show that if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>X</mi><mn>2</mn></msub><mo separator="true">,</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">X_1, X_2, S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span> are schemes, the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mn>1</mn></msub><msub><mo>×</mo><mi>S</mi></msub><msub><mi>X</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">X_1\times_S X_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin"><span class="mbin">×</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> is also covered by open affines (by mathlib definition, means that every point has an open neighborhood such that the <code>restrict</code> along the inclusion of the neighborhood is isomorphic to the Spec of a ring).</p>
<p>Given a point x of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>=</mo><msub><mi>X</mi><mn>1</mn></msub><msub><mo>×</mo><mi>S</mi></msub><msub><mi>X</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">X=X_1\times_S X_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin"><span class="mbin">×</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, consider its projection p(x) into S, and take an open neighborhood V of p(x) in S that is affine. Similarly take affine neighborhoods <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>U</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>U</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">U_1, U_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><msub><mi>p</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p_1(x), p_2(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span> in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>X</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">X_1, X_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> respectively, then take basic opens within <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>U</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>U</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">U_1, U_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> that projects into V. We then need that the restriction of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">S</mi><mi mathvariant="normal">p</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">c</mi></mrow><mo stretchy="false">(</mo><mi>R</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathrm{Spec}(R)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">Spec</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mclose">)</span></span></span></span> to a basic open <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">D(f)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span></span></span></span> is isomorphic to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">S</mi><mi mathvariant="normal">p</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">c</mi></mrow><mo stretchy="false">(</mo><msub><mi>R</mi><mi>f</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathrm{Spec}(R_f)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathrm">Spec</span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>, and that <code>restrict</code> commutes with composition of open embeddings.</p>
<p>Now replace <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>U</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>U</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">U_1, U_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> by the basic opens, and use the <a href="#narrow/stream/144837-PR-reviews/topic/.2310069.20Open.20immersions.20of.20presheafed.20spaces/near/259803751">universal property of <code>restrict</code></a> (notice that the statement is only <code>lift</code> without the <code>fac</code> and <code>uniq</code> parts of the universal property) to obtain morphisms <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>p</mi><mn>1</mn><mrow><mo>−</mo><mn>1</mn></mrow></msubsup><mo stretchy="false">(</mo><msub><mi>U</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo>∩</mo><msubsup><mi>p</mi><mn>2</mn><mrow><mo>−</mo><mn>1</mn></mrow></msubsup><mo stretchy="false">(</mo><msub><mi>U</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo>→</mo><msub><mi>U</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">p_1^{-1}(U_1)\cap p_2^{-1}(U_2) \to U_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.120547em;vertical-align:-0.266308em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.854239em;"><span style="top:-2.433692em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.1031310000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.266308em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.120547em;vertical-align:-0.266308em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.854239em;"><span style="top:-2.433692em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.1031310000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.266308em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>U</mi><mi>i</mi></msub><mo>→</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">U_i\to V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span> with all open sets endowed with the <code>restrict</code> LRS structure (here we use that the intersection of two opens is open). Then use the universal property to show that their compositions with <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>U</mi><mi>i</mi></msub><mo>→</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">U_i\to V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span> agree, and these three morphisms to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>U</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>U</mi><mn>2</mn></msub><mo separator="true">,</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">U_1,U_2,V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span> realizes <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>p</mi><mn>1</mn><mrow><mo>−</mo><mn>1</mn></mrow></msubsup><mo stretchy="false">(</mo><msub><mi>U</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo>∩</mo><msubsup><mi>p</mi><mn>2</mn><mrow><mo>−</mo><mn>1</mn></mrow></msubsup><mo stretchy="false">(</mo><msub><mi>U</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p_1^{-1}(U_1)\cap p_2^{-1}(U_2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.120547em;vertical-align:-0.266308em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.854239em;"><span style="top:-2.433692em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.1031310000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.266308em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.120547em;vertical-align:-0.266308em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.854239em;"><span style="top:-2.433692em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.1031310000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.266308em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> as the fiber product <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>U</mi><mn>1</mn></msub><msub><mo>×</mo><mi>V</mi></msub><msub><mi>U</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">U_1\times_V U_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin"><span class="mbin">×</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.22222em;">V</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> in LRS. Finally, use Gamma-Spec adjunction to show the fiber product isomorphic the Spec of a coproduct (tensor) of rings (here we need that Spec is a full functor which Andrew proved; is it now in mathlib?).</p>
<p>A side comment is that instead of directly proving universal property of <code>restrict</code> (actually should be of <code>of_restrict</code>) we should probably first define open immersion, show that <code>of_restrict</code> is an open immersion, then show that all open immersions satisfy the universal property.</p>
<p>Although all these are relatively straightforward to formalize, I'm posting here to find out which lemmas have already been done, as I know at least <span class="user-mention" data-user-id="439483">@Andrew Yang</span> has been working in this direction.</p>



<a name="259984940"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/259984940" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#259984940">(Nov 02 2021 at 11:56)</a>:</h4>
<p>The fact that Spec is fully faithful should follow straight from the counit(?) isomorphism, so I did not work to make that into mathlib.<br>
I agree that we should provide the universal property in terms of open immersions. <br>
I assume the biggest obstacle in leanifying that paper is in the part that LRS has fibre products. That definition seems quite ugly, and I don't really know or have time lately to think about how to formalize them properly (my midterms are coming...) <br>
That said, after seeing that note that you posted, I tried to look for similar results and stumbled upon <a href="https://arxiv.org/pdf/1103.2139.pdf">https://arxiv.org/pdf/1103.2139.pdf</a>.<br>
This seems quite similar to the note above but wrapped everything in some categorical jargon, which may or may not make it easier to formalize, but I suppose it is an alternative.</p>



<a name="259996822"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/259996822" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#259996822">(Nov 02 2021 at 13:46)</a>:</h4>
<p><span class="user-mention silent" data-user-id="439483">Andrew Yang</span> <a href="#narrow/stream/113488-general/topic/Status.20of.20algebraic.20geometry/near/259984940">said</a>:</p>
<blockquote>
<p>The fact that Spec is fully faithful should follow straight from the counit(?) isomorphism</p>
</blockquote>
<p>Indeed, faithfulness only needs the counit iso, though fullness also needs the unit and the right triangle identity (the harder one of the two asserting a LRS morphism is id): defining the preimage only needs the counit iso, but verifying it's a preimage needs right triangle.</p>



<a name="260053079"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/260053079" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#260053079">(Nov 02 2021 at 20:24)</a>:</h4>
<p>Hopefully the results of <a href="https://leanprover-community.github.io/mathlib_docs/find/category_theory.adjunction.fully_faithful/src">src#category_theory.adjunction.fully_faithful</a> are helpful here?</p>



<a name="260071789"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/260071789" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#260071789">(Nov 02 2021 at 23:29)</a>:</h4>
<p>Nice, I've found the perserve_limits theorem but haven't looked into fully faithfulness yet. But the linkifier seems broken (the link points to a 404 page <a href="https://leanprover-community.github.io/mathlib_docs/find/category_theory.adjunction.fully_faithful/src">https://leanprover-community.github.io/mathlib_docs/find/category_theory.adjunction.fully_faithful/src</a> )  <a href="https://leanprover-community.github.io/mathlib_docs/find/category_theory.adjunction.fully_faithful">docs#category_theory.adjunction.fully_faithful</a> doesn't append src at the end but also isn't converting dots to slashes.</p>



<a name="261095823"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/261095823" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#261095823">(Nov 11 2021 at 05:40)</a>:</h4>
<p>So I’ve skimmed through Gillam’s paper and plan to adopt his approach, while Andrew keeps pursuing the gluing approach. Although fiber products of schemes require just one approach to build, I believe the two approaches will eventually be good for different purposes in the future, no matter which one is adopted for the current purpose.</p>
<p>It’s now clear to me that Gillam’s localization functor from PRS (primed ringed spaces) to LRS is just a generalized version of Spec (to LRS) on CommRing: the constructions are very similar, and indeed it’s used to construct Spec in Lemma 3 (bottom of p.9), and it’s part of a general adjunction (Theorem 2) that subsumes the Gamma-Spec adjunction <a href="https://github.com/leanprover-community/mathlib/issues/9802">#9802</a>. We would need to prove everything in structure_sheaf.lean in the more general form, so to avoid duplicate code, it would be a good idea to refactor to define Spec in terms of the localization functor. The Spec constructed this way will not have the underlying set equal to the prime spectrum, so an extra step seems necessary to transfer the LRS structure to the prime spectrum.</p>
<p>Gillam first shows that PRS has all limits, and uses Theorem 2 (which says the localization functor PRS -&gt; LRS is a right adjoint with unit an iso) to deduce that LRS has all limits (I’m unable to find this implication in mathlib). PRS is easily shown to have all limits given that RS has all limits, which is just three sentences in [Gillam], unlike the lengthy argument in [Brandenburg] (Theorem 2.1). I think it’s indeed easy: PresheafedSpace can be shown to have all limits easily given that the value category has all colimits, now that we have pullback of presheaves in mathlib, similar to how it was shown that it has all colimits; then sheafification on the limit presheafed space would yield the limit in SheafedSpace. (Gillam only talks about inverse limits, but I believe the arguments apply for all (small) limits.) The sites version of sheafification recently completed by Adam Topaz would suffice but it’s yet to be merged into mathlib.</p>



<a name="261097910"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/261097910" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#261097910">(Nov 11 2021 at 06:23)</a>:</h4>
<p>Sounds good. But if these changes go through, it will be important to have a good API for the connection to <code>prime_spectrum</code>, I guess.</p>



<a name="261107385"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/261107385" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#261107385">(Nov 11 2021 at 08:53)</a>:</h4>
<p>There's now a <a href="https://github.com/leanprover-community/mathlib/projects/13">project page</a> dedicated to AG<br>
if someone wants to track the current PRs and progress.</p>



<a name="261107505"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/261107505" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#261107505">(Nov 11 2021 at 08:55)</a>:</h4>
<p>Thanks a lot for creating this overview!</p>



<a name="261107539"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/261107539" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#261107539">(Nov 11 2021 at 08:55)</a>:</h4>
<p>Seems like the maintainers have some homework!</p>



<a name="261213042"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/261213042" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#261213042">(Nov 12 2021 at 05:09)</a>:</h4>
<p>I added a bunch of "small subprojects" to <a href="https://github.com/leanprover-community/mathlib/projects/13">the project page</a> as a new column that I've thought about but haven't found time to code up, some essential to the main project (fibred product). Everyone is welcome to help! As I'm focusing on the main project, I'll probably only do the minimum required when the time comes if no one takes them up. You're welcome to add your ideas to the list, though for Andrew it's probably fastest to do everything himself. ;) I also renamed "to do" to "main project" and <span class="user-mention" data-user-id="439483">@Andrew Yang</span> probably want to add (references to) the gluing approach to that column as well?</p>



<a name="261213137"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/261213137" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#261213137">(Nov 12 2021 at 05:12)</a>:</h4>
<p><span class="user-mention silent" data-user-id="224323">Junyan Xu</span> <a href="#narrow/stream/113488-general/topic/Status.20of.20algebraic.20geometry/near/261095823">said</a>:</p>
<blockquote>
<p>uses Theorem 2 (which says the localization functor PRS -&gt; LRS is a right adjoint with unit an iso) to deduce that LRS has all limits (I’m unable to find this implication in mathlib). </p>
</blockquote>
<p>and I actually found the dual form of this result in monad/limits (the left adjoint is a coreflective functor), mentioned in <a href="https://github.com/leanprover-community/mathlib/projects/13#card-72734619">this card</a>.</p>



<a name="262684610"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/262684610" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#262684610">(Nov 25 2021 at 09:42)</a>:</h4>
<p>Just popping up to say that we can now glue schemes in <a href="https://github.com/leanprover-community/mathlib/tree/presheafed_spaces_glue">branch#presheafed_spaces_glue</a>. </p>
<p>This will probably come after a sea of PR spams <span aria-label="grinning" class="emoji emoji-1f600" role="img" title="grinning">:grinning:</span>.</p>



<a name="262684840"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/262684840" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#262684840">(Nov 25 2021 at 09:45)</a>:</h4>
<p>Thank you so much for pushing the algebraic geometry dream forwards! Many of us have been distracted by the Scholze project. In the distant past we'd been experimenting with doing algebraic geometry without using the category theory library, but Scott convinced me that we should use categories, so we defined schemes using the category theory library, went off to celebrate that mathlib had schemes, and then LTE came along and we never came back to it. In some sense this is the first big experiment to see if we can actually get category theory to do something in Lean other than more category theory, and for me this is a really important question but for a long time nobody was working on it. I'm really grateful that this new group of people have appeared (you and Junyan) who are pushing this forward, I think it's a really important experiment.</p>



<a name="262686517"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/262686517" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#262686517">(Nov 25 2021 at 10:03)</a>:</h4>
<p>I don't really like this formulation: "can we actually get category theory to do something in lean other than more category theory". I mean, of course we know that category theory does something in <em>mathematics</em> other than more category theory, e.g. essentially all of modern algebraic geometry. Whether one can do modern algebraic geometry in Lean is a great and interesting question (surely the answer is "yes"), so why not just ask that?</p>



<a name="262686567"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/262686567" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#262686567">(Nov 25 2021 at 10:03)</a>:</h4>
<p>But whatever --- this is great progress, and exciting to see, <span class="user-mention" data-user-id="439483">@Andrew Yang</span>!</p>



<a name="262693162"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/262693162" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#262693162">(Nov 25 2021 at 11:12)</a>:</h4>
<p>Yes sorry Scott -- just to be clear I absolutely meant "can category theory be used <em>in Lean</em> to do anything other than more category theory". I use cohomology theories all over the place in my non-Lean work and of course category theory powers this stuff via homological algebra. I meant to stress the point that until algebraic geometry, Lean's category theory library was being developed essentially independently of the rest of mathlib; it would sometimes use the rest of mathlib (e.g. when making the category of rings or the category of R-modules) but the rest of mathlib would never use it. It was Scott who argued strongly to use the category theory library when defining schemes (i.e. we didn't define <code>scheme X</code> like we have <code>ring R</code>, we defined <code>Scheme</code> directly) and this is what we did. This provided a link from category theory to another branch of mathlib (namely algebraic geometry) and then the question became "does it actually work? Can we now do stuff?". For a while the answer was "we don't actually know because nobody is doing stuff", but now people are doing stuff and it's working. It's also definitely worth pointing out that in a previous incarnation of schemes which didn't use the category theory library (and was never pushed to mathlib, it was Ramon Fernandez Mir's schemes repo) we did try to do gluing and it was really messy. </p>
<p>The other big application I see of Lean category theory right now in an area of maths which isn't just more category theory is in the LTE repo. The ultimate goal is to show that an Ext group is zero and we have defined the Ext group using the category theory language, even though in applications I guess we want it to represent the assertion that there are no non-trivial extensions of a thing by another thing. We are getting to this stuff right now in LTE so this will represent another proof that Lean 3 categories can be used for things other than Lean 3 categories.</p>
<p>Sorry for the confusion Scott! Hopefully you're less upset by this clarification. Let me know if you're still upset.</p>



<a name="262694059"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/262694059" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#262694059">(Nov 25 2021 at 11:22)</a>:</h4>
<blockquote>
<p>Lean's category theory library was being developed essentially independently of the rest of mathlib; it would sometimes use the rest of mathlib (e.g. when making the category of rings or the category of R-modules) but the rest of mathlib would never use it.</p>
</blockquote>
<p>To provide some visual emphasis on that point:</p>
<p><a href="/user_uploads/3121/Chs1KeLC3yag3sI2RXSOC90T/image.png">image.png</a> </p>
<div class="message_inline_image"><a href="/user_uploads/3121/Chs1KeLC3yag3sI2RXSOC90T/image.png" title="image.png"><img src="/user_uploads/3121/Chs1KeLC3yag3sI2RXSOC90T/image.png"></a></div><p>The highlighted notes are in the <code>category_theory</code>, and node groupings are based on imports</p>



<a name="262694644"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/262694644" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#262694644">(Nov 25 2021 at 11:28)</a>:</h4>
<p>what's the blue bit on the right? <code>tactic</code>?</p>



<a name="262695264"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/262695264" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#262695264">(Nov 25 2021 at 11:34)</a>:</h4>
<p><code>core:init</code>. You can investigate yourself at <a href="https://eric-wieser.github.io/mathlib-import-graph/">https://eric-wieser.github.io/mathlib-import-graph/</a>. <code>tactic</code> is more entangled</p>



<a name="262696614"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/262696614" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#262696614">(Nov 25 2021 at 11:51)</a>:</h4>
<p>huh. TIL that mathlib has a <code>prelude</code> file: <a href="https://github.com/leanprover-community/mathlib/blob/master/src/tactic/transfer.lean"><code>tactic.transfer</code></a></p>



<a name="262696628"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/262696628" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#262696628">(Nov 25 2021 at 11:51)</a>:</h4>
<p>I guess this was imported from core and never changed</p>



<a name="262697096"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/262697096" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#262697096">(Nov 25 2021 at 11:57)</a>:</h4>
<p>But now we have homological algebra, category theory will start to find applications in commutative algebra -- that will be the next area that it invades after alg geom. The reason it's taken so long is that basically it has been only Scott (and then later on Scott and Bhavik and Adam) and it has taken a long time to get to abelian categories. But now we're there! Adam proved that condensed abelian groups were an abelian category the other day, so that works too :D</p>



<a name="262701018"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/262701018" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#262701018">(Nov 25 2021 at 12:43)</a>:</h4>
<p>The mathlib prelude file is one of the many interesting things in mathlib that make writing the import minimizer way more tricky in practice than it was in theory, I would be happy to see it gone!</p>



<a name="262764463"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/262764463" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#262764463">(Nov 26 2021 at 06:36)</a>:</h4>
<p>Hi Kevin, thanks for the posts and the advertisement on Twitter. Most of the work was actually done by Andrew, as you can see from the number of merged PRs (I have only two). In my experience, the category library has been very useful and very often when I want a result it’s already in it.</p>
<p>I haven’t had an active PR for a while but in the meantime I created two branches: <code>Gillam</code> for showing LRS has limits following Gillam’s paper, and <code>adjunction_mates</code> for defining lax/pseudofunctors and transferring them across adjunctions, because I found these necessary to work with presheaf pullback, e.g. when showing <code>PresheafedSpace</code> has limits. However, a recent realization has changed my development plan and moved focus towards a more abstract, general, categorical direction. The realization is that the construction of the categories <code>Top</code> from <code>Type</code>, <code>PresheafedSpace</code> from <code>Top</code>, and <code>SheafedSpace</code> from <code>PresheafedSpace</code>, are all examples of <a href="https://leanprover-community.github.io/mathlib_docs/category_theory/grothendieck.html">the Grothendieck construction</a>, resulting from the functor F : C ⥤ Cat which gives a functor between fiber categories for each morphism in the base category. In the first case, the fiber categories are partial orders (the type of topologies on a type ordered by inclusion), in the second case the type of presheaves on a space, and in the last case subsingletons (the is_sheaf Prop; the functor here “is” the implication that a pushforward of a sheaf is a sheaf). However, <code>LocallyRingedSpace</code> from <code>RingedSpace</code> isn’t such an example, but <code>PrimedRingedSpace</code> from <code>RingedSpace</code> is (with fiber categories the partial orders of “prime systems”, actually an example of "category of elements").</p>
<p>I haven’t checked all details, but it appears that the existence of colimits in the Grothendieck construction follows from the existence in the base category and in the fiber categories, plus some minor conditions (e.g. the functor preserves colimits), similar to the proof that PresheafedSpace has colimits, which seems mostly rely on the functors <code>pushforward_over</code>, <code>pushforward_under</code> and <code>pushforward_forget_adjunction</code> in my <a href="https://github.com/leanprover-community/mathlib/compare/Gillam?expand=1#diff-252fb30c3a3221e6472db5ba794344dfb423898696e70299653d95f635de06adR236-R277">Gillam branch</a>, which can be generalized to any Grothendieck construction; moreover the forgetful functor to the base category would preserve colimits. For example, for Top, the functor “is” the coinduced(“quotient”) topology, and it’s adjoint to the functor of induced(“subspace”) topology, and adjoint functors give rise to <em>contravariantly isomorphic</em> Grothendieck constructions, so together with the fact that the topologies on a space form a complete lattice (fiber categories have both limits and colimits), we can show that Top has both limits and colimits. However, my goal is not to refactor the facts about Top, but to deal with limits in PresheafedSpace, where I need to deal with presheafed pullback, which is no longer a strict functor, but has a pseudofunctor structure <a href="https://github.com/leanprover-community/mathlib/compare/adjunction_mates#diff-834abea6600f7b555f0b1a8095fc5495aa2f3fed4f3521e0f72ed9109c64cd59R323-R332">transferred from pushforward across adjunction</a> (the proofs should probably be replaced with a more conceptual and probably shorter/faster one using yoneda faithfulness + adjunction hom_equiv). So here I need to generalize the Grothendieck construction to allow pseudofunctors, or more generally lax functors, which is what I plan to do when I hopefully have some time in the weekend. Would like to hear what categorical people think about it! References are also welcome.</p>



<a name="262765457"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/262765457" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#262765457">(Nov 26 2021 at 06:58)</a>:</h4>
<p><span class="user-mention" data-user-id="224323">@Junyan Xu</span> Wow, that sounds like a cool plan!</p>



<a name="262776690"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/262776690" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#262776690">(Nov 26 2021 at 09:40)</a>:</h4>
<p>You might be interested in <a href="https://arxiv.org/pdf/1705.04296.pdf">displayed categories</a>. You could say it's a generalization of the Grothendieck construction which allows lax functors to the category of categories and profunctors. As a result you get not only Grothendieck fibrations but <em>all</em> functors (up to isomorphism), but really the point is that the general notion of displayed category is fairly easy to work with in type theory (although you need to use pathovers / <code>==</code> to state associativity etc).</p>
<p>I don't know that using displayed categories for this formalisation would make things easier overall, but in case you're interested I wrote the basic definitions in Lean <a href="https://github.com/dwarn/nielsen-schreier-2/blob/04baa9f3c505efea29e141eaaf12caa4f2ac42c2/src/displayed.lean">here</a>.</p>



<a name="263381403"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/263381403" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#263381403">(Dec 02 2021 at 01:15)</a>:</h4>
<p>Another status update:</p>
<p>we now have this</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="n">Z</span> <span class="o">:</span> <span class="n">Scheme</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">⟶</span> <span class="n">Z</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">Y</span> <span class="bp">⟶</span> <span class="n">Z</span><span class="o">)</span> <span class="o">:</span> <span class="n">has_pullback</span> <span class="n">f</span> <span class="n">g</span> <span class="o">:=</span>
<span class="n">has_pullback_of_cover</span> <span class="o">(</span><span class="n">Z.affine_cover.pullback_cover</span> <span class="n">f</span><span class="o">)</span> <span class="n">f</span> <span class="n">g</span>
</code></pre></div>
<p>It is essentially sorry-free, where the only sorries involved are proved in the currently abandoned <a href="https://github.com/leanprover-community/mathlib/issues/9802">#9802</a></p>
<p>It is over at <a href="https://github.com/leanprover-community/mathlib/tree/open_subfunctor">branch#open_subfunctor</a> and in the file <a href="https://github.com/leanprover-community/mathlib/blob/2eeb86d9e2c0867281b96806995ead6976c33d6b/src/algebraic_geometry/open_subfunctor.lean#L1203-L1204">open_subfunctor.lean</a>.</p>
<p>Although the file name, it is constructed via gluing naively, without the Zariski sheaf and the open subfunctor stuff.</p>



<a name="263382700"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/263382700" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#263382700">(Dec 02 2021 at 01:31)</a>:</h4>
<p>Wow! That's quite a milestone!</p>



<a name="263387430"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/263387430" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#263387430">(Dec 02 2021 at 02:53)</a>:</h4>
<p>Just a tiny bit of progress over <a href="https://github.com/leanprover-community/mathlib/compare/lax_grothendieck">branch lax_grothendieck</a> from me last weekend; and I did find the result about limits <a href="https://ncatlab.org/nlab/show/Grothendieck+construction#limits_and_colimits">in nLab</a> from a TCS paper ...</p>



<a name="263432025"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/263432025" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#263432025">(Dec 02 2021 at 12:55)</a>:</h4>
<p><span class="user-mention" data-user-id="224323">@Junyan Xu</span> have you seen the old-ish thread about 2-categories? What do you think about defining 2-categories and pseudofunctors in general?</p>



<a name="263432244"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/263432244" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#263432244">(Dec 02 2021 at 12:57)</a>:</h4>
<p><a href="#narrow/stream/116395-maths/topic/2-categories/near/231851198">https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/2-categories/near/231851198</a></p>



<a name="263447813"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/263447813" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#263447813">(Dec 02 2021 at 14:50)</a>:</h4>
<p><span class="user-mention" data-user-id="243562">@Adam Topaz</span> I think I've seen that thread once. The definition of 2-categories is quite long as can be seen in <a href="https://github.com/leanprover-community/mathlib/blob/two-cat/src/category_theory/category/2-category.lean">Bhavik Mehta's work</a>, and I don't have sufficient motivation to work in that generality when all I need in the current application are pseudofunctors from 1-categories to Cat. I also don't have experience working with 2-categories and can't suggest which approach is better. <span class="user-mention" data-user-id="110087">@Scott Morrison</span> expressed concerns about strict 2-categories gonna be infected with <code>eq.rec</code>and I think displayed categories are an attempt to address the issue, but in my practice <code>eq_to_hom</code> makes equality of objects reasonably pleasant to work with.</p>



<a name="267302260"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/267302260" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#267302260">(Jan 08 2022 at 15:56)</a>:</h4>
<p>@mathlib: Brace yourself. Incoming <code>Γ ⊣ Spec</code></p>
<p>Big kudos to <span class="user-mention" data-user-id="224323">@Junyan Xu</span> and <span class="user-mention" data-user-id="439483">@Andrew Yang</span></p>



<a name="267302321"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/267302321" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#267302321">(Jan 08 2022 at 15:58)</a>:</h4>
<p>And also to <span class="user-mention" data-user-id="384542">@Justus Springer</span> who laid most of the foundational works!</p>



<a name="267304666"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/267304666" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#267304666">(Jan 08 2022 at 16:54)</a>:</h4>
<p>Next job: fibre products!</p>



<a name="267348972"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/267348972" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Justus Springer <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#267348972">(Jan 09 2022 at 09:35)</a>:</h4>
<p>Amazing work! Thanks <span class="user-mention" data-user-id="439483">@Andrew Yang</span> and <span class="user-mention" data-user-id="224323">@Junyan Xu</span> for putting so much work into finishing this project. I hope I can return to become an active contributor in the not-too-distant future. This adjunction should really open the door to the interplay between algebra and geometry. I'm guessing an easy consequence now would be the equivalence of categories between <code>CommRingᵒᵖ</code> and <code>AffineScheme</code>? Is this already formalized?</p>



<a name="267354769"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/267354769" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#267354769">(Jan 09 2022 at 12:04)</a>:</h4>
<p>The equivalence was done way back when I first got my hand on Lean. I've just tidied it up into a PR <a href="https://github.com/leanprover-community/mathlib/pull/11326">#11326</a>.<br>
Looking forward to having you back on board! Hopefully mathlib will know that fibre products exist by then (two-thirds of <a href="https://github.com/leanprover-community/mathlib/pull/10605">#10605</a> is in mathlib now), and together with the adjunction, these will definitely open a lot of doors for us to play with.</p>



<a name="269754284"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/269754284" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#269754284">(Jan 28 2022 at 15:35)</a>:</h4>
<p>Congrats to <span class="user-mention" data-user-id="439483">@Andrew Yang</span> on the merging of fibered products (<a href="https://github.com/leanprover-community/mathlib/pull/11450">#11450</a> and <a href="https://github.com/leanprover-community/mathlib/pull/10605">#10605</a>)! I didn't follow closely lately but it seems you abandoned the open subfunctor approach at some point and adopted the proof on Hartshorne instead (despite the latter PR is still from a branch named <code>open_subfunctor</code>)? Searching for subfunctor or open_subfunctor turns up nothing relevant in the mathlib repo.</p>



<a name="269757740"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/269757740" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#269757740">(Jan 28 2022 at 15:58)</a>:</h4>
<p>Next step: sheaf cohomology! Or proof that projective morphisms are proper? <span class="user-mention" data-user-id="252627">@Jujian Zhang</span> how far are we from projective morphisms?</p>



<a name="269761526"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/269761526" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#269761526">(Jan 28 2022 at 16:24)</a>:</h4>
<p>Congratulations! </p>
<p>Now for some additional low hanging fruit: we can use <a href="https://leanprover-community.github.io/mathlib_docs/find/category_theory.limits.has_equalizers_of_pullbacks_and_binary_products">docs#category_theory.limits.has_equalizers_of_pullbacks_and_binary_products</a> <br>
together with the fact that <code>Scheme</code> has a terminal object (do we know this yet?) and <a href="https://leanprover-community.github.io/mathlib_docs/find/category_theory.limits.finite_limits_from_equalizers_and_finite_products">docs#category_theory.limits.finite_limits_from_equalizers_and_finite_products</a> to get all finite limits.</p>



<a name="269761807"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/269761807" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#269761807">(Jan 28 2022 at 16:26)</a>:</h4>
<p>We may be missing some general construction to obtain binary products from pullbacks and a terminal object</p>



<a name="269762059"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/269762059" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#269762059">(Jan 28 2022 at 16:28)</a>:</h4>
<p>Ah, we have it <a href="https://leanprover-community.github.io/mathlib_docs/find/has_binary_products_of_terminal_and_pullbacks">docs#has_binary_products_of_terminal_and_pullbacks</a> (in the wrong namespace...)</p>



<a name="269763062"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/269763062" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jujian Zhang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#269763062">(Jan 28 2022 at 16:35)</a>:</h4>
<p>On another branch we have a grading on multi aria level polynomial rings. So we could have projective n space by combining Proj construction and that branch. So we must not be far from projective morphisms but sheaf cohomology is further away I think.</p>



<a name="269763317"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/269763317" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#269763317">(Jan 28 2022 at 16:37)</a>:</h4>
<p>We don't have anything about right derived functors in terms of <em>injective</em> resolutions at the moment. Do we even have <a href="https://leanprover-community.github.io/mathlib_docs/find/category_theory.injective">docs#category_theory.injective</a> ?</p>



<a name="269766170"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/269766170" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#269766170">(Jan 28 2022 at 16:57)</a>:</h4>
<p><span class="user-mention silent" data-user-id="243562">Adam Topaz</span> <a href="#narrow/stream/113488-general/topic/Status.20of.20algebraic.20geometry/near/269762059">said</a>:</p>
<blockquote>
<p>Ah, we have it <a href="https://leanprover-community.github.io/mathlib_docs/find/has_binary_products_of_terminal_and_pullbacks">docs#has_binary_products_of_terminal_and_pullbacks</a> (in the wrong namespace...)</p>
</blockquote>
<p>Sorry! I wrote that before I figured out how the category namespaces should work!</p>



<a name="269768596"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/269768596" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#269768596">(Jan 28 2022 at 17:13)</a>:</h4>
<p>As for the next step, I'm trying to develop a framework to describe morphisms between schemes whose conditions are imposed locally. (quasi-compact, quasi-separated, affine, closed immersion, (locally) of finite type, finitely presented, finite, integral, etc.)<br>
If anyone want to get on this AG wagon that is in its full speed, a nice and useful result to have is the "qcqs-lemma" as called in the rising sea, i.e. these exercises in Hartshorne. Another good thing to have is to define dominant morphisms and proof <a href="https://stacks.math.columbia.edu/tag/0CC1">stacks#0CC1</a>. <br>
<a href="/user_uploads/3121/vUcGz08ByAVpiw4Kqf_b3svh/image.png">image.png</a></p>
<div class="message_inline_image"><a href="/user_uploads/3121/vUcGz08ByAVpiw4Kqf_b3svh/image.png" title="image.png"><img src="/user_uploads/3121/vUcGz08ByAVpiw4Kqf_b3svh/image.png"></a></div>



<a name="269769161"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/269769161" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#269769161">(Jan 28 2022 at 17:16)</a>:</h4>
<p>Someone really need to snatch some AG work from me so that I can do more LTE stuff :(</p>



<a name="269769589"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/269769589" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#269769589">(Jan 28 2022 at 17:19)</a>:</h4>
<p>Another good thing to have is <a href="https://github.com/leanprover-community/mathlib/pull/4013">#4013</a>. <br>
<span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> Is someone working on it now?</p>



<a name="269769706"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/269769706" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#269769706">(Jan 28 2022 at 17:20)</a>:</h4>
<p><span class="user-mention silent" data-user-id="439483">Andrew Yang</span> <a href="#narrow/stream/113488-general/topic/Status.20of.20algebraic.20geometry/near/269769589">said</a>:</p>
<blockquote>
<p>Another good thing to have is <a href="https://github.com/leanprover-community/issue/pull/4013">issue#4013</a>. <br>
<span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> Is someone working on it now?</p>
</blockquote>
<p><a href="https://github.com/leanprover-community/mathlib/pull/4013">#4013</a>, issue#x assumes that it's a repo named <code>issue</code></p>



<a name="269769820"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/269769820" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#269769820">(Jan 28 2022 at 17:20)</a>:</h4>
<p>Oh. Thanks!</p>



<a name="269770185"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/269770185" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#269770185">(Jan 28 2022 at 17:22)</a>:</h4>
<p>Btw if you need more boilerplate around ring homs (or any other hom, really!), I'm currently writing several hundred lines a day of it, so just tell me and I'll do it.</p>



<a name="269772736"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/269772736" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#269772736">(Jan 28 2022 at 17:38)</a>:</h4>
<p>Also <span class="user-mention" data-user-id="252627">@Jujian Zhang</span>  what's the current status on sheaves of modules? I think I saw that you have been working on this too. Are you planning to return after the Proj construction?</p>



<a name="269773664"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/269773664" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#269773664">(Jan 28 2022 at 17:44)</a>:</h4>
<p><span class="user-mention" data-user-id="224323">@Junyan Xu</span> Yeah. I did mention somewhere above that I abandoned the open subfunctor approach. On one hand gluing directly only takes about 500 lines, and I didn't really want to spend much more time on this so that I can do more interesting stuff. On the other hand this also gives a good enough open cover of the fibred product.<br>
Although we should eventually need all the open subfunctor stuff later for things like the Grassmanian.</p>



<a name="269783122"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/269783122" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#269783122">(Jan 28 2022 at 18:44)</a>:</h4>
<p><span class="user-mention" data-user-id="464700">@David Ang</span> did anyone express an interest in the properties of ring homs listed in <a href="https://github.com/leanprover-community/mathlib/pull/4013">#4013</a> ? Maybe you can tell the LSGNT students where we're up to now? Probably this is just the kind of algebraic geometry that some of them are learning.</p>



<a name="269795595"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/269795595" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jujian Zhang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#269795595">(Jan 28 2022 at 20:14)</a>:</h4>
<p>In some branch, category of bundled module is defined (restriction and extension of scalars). So sheaves of modules can be defined as functor into category of bundled module using restriction of scalar.</p>



<a name="269797766"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/269797766" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#269797766">(Jan 28 2022 at 20:28)</a>:</h4>
<p>Oh I see. Are you planning to do more stuff about them? Such as defining the associated sheaf of a module, defining coherence, API about submodules (ideals), etc?</p>



<a name="269798173"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/269798173" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#269798173">(Jan 28 2022 at 20:31)</a>:</h4>
<p>Btw is that category concrete? Do we have a good description about what the sheaf condition looks like in that category?</p>



<a name="269815494"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/269815494" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#269815494">(Jan 28 2022 at 23:02)</a>:</h4>
<p>For bundled modules using restriction, I think the forgetful functor to the underlying type of the module (and to the module part of the bundled morphism, noticing that restriction doesn't change the underlying type) is faithful, so it's concrete, no problem.</p>
<p>(Note: I'm talking about <code>bundledMap</code> in <a href="#narrow/stream/113488-general/topic/timeout.20fixed.20by.20changing.20def.20to.20lemma/near/264705272">this post</a>. I haven't seen the definition using extension instead of restriction, but I guess both resulting BundledModule categories will be isomorphic through extend-restrict adjunction? Notice that the category defined using restriction is an example of the <a href="https://leanprover-community.github.io/mathlib_docs/category_theory/grothendieck.html">Grothendieck construction</a>, but for extension we'd need Grothendieck construction <a href="https://github.com/leanprover-community/mathlib/compare/lax_grothendieck?expand=1#diff-779e8ece193ac9cfb8b3ab087590457d8f57c59a774bd663d70eaa8e6a160ecdR135">generalized to lax functors</a> (I haven't decided whether to refactor my work using the <a href="https://leanprover-community.github.io/mathlib_docs/category_theory/bicategory/functor.html#category_theory.oplax_functor">bicategory formalism</a> recently developed by Yuma Mizuno).)</p>
<p>I guess a weird thing when using sheaves of bundled modules is that we won't be able to say <code>M: module O_X</code> but have to say that the image of <code>M</code> under the projection functor from sheaves of bundled modules to sheaves of rings is equal to <code>O_X</code>. This might make it complicated to define operations between two <code>O_X</code> modules. Say you want to define the direct sum of two <code>O_X</code> modules, don't you need to transfer the module structure on each open across the equality of the rings on that open? (or maybe equality is evil, and we should use isomorphism instead.)</p>



<a name="269816044"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/269816044" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#269816044">(Jan 28 2022 at 23:08)</a>:</h4>
<p>It isn’t full though. I’m not sure the results still hold in this case?</p>



<a name="269816674"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/269816674" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#269816674">(Jan 28 2022 at 23:15)</a>:</h4>
<p>Yes. Equality is evil and we should use an iso. Still this is unpleasant to work with :(</p>
<p>Would a typeclass [module Ox F] and some API converting this to and from a Sheaf BundledModule work?<br>
I’ve never thought deep about these though. The problems elsewhere are already enough to take away all my attention.</p>



<a name="269816844"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/269816844" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#269816844">(Jan 28 2022 at 23:17)</a>:</h4>
<p><span class="user-mention silent" data-user-id="224323">Junyan Xu</span> <a href="#narrow/stream/113488-general/topic/Status.20of.20algebraic.20geometry/near/269815494">said</a>:</p>
<blockquote>
<p>For bundled modules using restriction, I think the forgetful functor to the underlying type of the module (and to the module part of the bundled morphism, noticing that restriction doesn't change the underlying type) is faithful, so it's concrete, no problem.</p>
</blockquote>
<p>I don't think this is faithful. Take <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">Z</mi></mrow><annotation encoding="application/x-tex">\mathbb{Z}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">Z</span></span></span></span> as a <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">Z</mi><mo stretchy="false">[</mo><mi>G</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\mathbb{Z}[G]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathbb">Z</span><span class="mopen">[</span><span class="mord mathnormal">G</span><span class="mclose">]</span></span></span></span>-module with the trivial <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span>-action where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span> is abelian and has nontrivial automorphisms. You can have nonidentity morphisms on the ring level which are identity on the module in this case, so those would all map to the same morphism of the underlying module.</p>



<a name="269817022"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/269817022" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#269817022">(Jan 28 2022 at 23:19)</a>:</h4>
<p>But you can just take the functor sending a bundled module to the product of the ring and the module, and that should be okay.</p>



<a name="269817515"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/269817515" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#269817515">(Jan 28 2022 at 23:24)</a>:</h4>
<p>If you want a more geometric example, take <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>=</mo><mi>k</mi><mo stretchy="false">[</mo><mi>X</mi><mo separator="true">,</mo><mi>Y</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">A = k[X,Y]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mclose">]</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>=</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">M = k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> with the obvious <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>-module structure obtained by identifying <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mi>A</mi><mi mathvariant="normal">/</mi><mo stretchy="false">(</mo><mi>X</mi><mo separator="true">,</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">k = A/(X,Y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mord">/</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span></span></span></span>. Take <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span></span></span></span> the automorphism of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> which interchanges <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span>. Then for all <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>∈</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">a \in k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>X</mi><mo separator="true">,</mo><mi>Y</mi><mo stretchy="false">)</mo><mo>∈</mo><mi>k</mi><mo stretchy="false">[</mo><mi>X</mi><mo separator="true">,</mo><mi>Y</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">f(X,Y) \in k[X,Y]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mclose">]</span></span></span></span> you have <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>X</mi><mo separator="true">,</mo><mi>Y</mi><mo stretchy="false">)</mo><mo>⋅</mo><mi>a</mi><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>Y</mi><mo separator="true">,</mo><mi>X</mi><mo stretchy="false">)</mo><mo>⋅</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">f(X,Y) \cdot a = f(Y,X) \cdot a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span> so that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>σ</mi><mo separator="true">,</mo><mn mathvariant="bold">1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\sigma,\mathbf{1})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathbf">1</span><span class="mclose">)</span></span></span></span> is a morphism in this category, which is not the identity, but restricts to the identity on the module.</p>



<a name="269818197"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/269818197" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#269818197">(Jan 28 2022 at 23:32)</a>:</h4>
<p>Once you have the projection functor from sheaves of bundled modules to sheaves of commutative rings, you could "curry" this "uncurried functor" (in the sense of Grothendieck constructions) and obtain a pseudofunctor from sheaves on rings to the fiber categories of this projection. You could then define a <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="script">O</mi><mi>X</mi></msub></mrow><annotation encoding="application/x-tex">\mathcal{O}_X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07847em;">X</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>-module as an object in the image of this pseudofunctor under <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="script">O</mi><mi>X</mi></msub></mrow><annotation encoding="application/x-tex">\mathcal{O}_X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07847em;">X</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>.</p>



<a name="269820225"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/269820225" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#269820225">(Jan 28 2022 at 23:54)</a>:</h4>
<p>I'm sure there is some general nonsense result out there saying that you can get concreteness for algebras over any (multisorted) Lawvere theory.</p>



<a name="269820259"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/269820259" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#269820259">(Jan 28 2022 at 23:54)</a>:</h4>
<blockquote>
<p>You can have nonidentity morphisms on the ring level which are identity on the module</p>
</blockquote>
<p>Oh yes indeed, I take that back. I shouldn't forget about the morphism on rings. Or just take any two morphisms between two rings and the zero modules over them...</p>



<a name="269867263"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Status%20of%20algebraic%20geometry/near/269867263" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Status.20of.20algebraic.20geometry.html#269867263">(Jan 29 2022 at 14:26)</a>:</h4>
<p>Also tagging <span class="user-mention" data-user-id="385895">@Jon Eugster</span> since you seemed to have expressed interest in working on the AG library somewhere else.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/interesting.20tactics.3F.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/interesting.20tactics.3F.html">interesting tactics?</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="238408462"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/interesting%20tactics%3F/near/238408462" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/interesting.20tactics.3F.html#238408462">(May 12 2021 at 01:44)</a>:</h4>
<p>Hello general. I am giving a talk next week about algorithmic problem solving to an audience of mathematicians. I would like to highlight some of the interesting uses of tactics within mathlib. Suggestions?</p>



<a name="238411511"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/interesting%20tactics%3F/near/238411511" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/interesting.20tactics.3F.html#238411511">(May 12 2021 at 02:25)</a>:</h4>
<p>The <code>continuity</code> tactic might be worth a mention, as well as the use of <code>simp</code>  to prove integrals</p>



<a name="238411613"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/interesting%20tactics%3F/near/238411613" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/interesting.20tactics.3F.html#238411613">(May 12 2021 at 02:26)</a>:</h4>
<p><code>tidy</code> to clean up side conditions in category theory</p>



<a name="238411760"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/interesting%20tactics%3F/near/238411760" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/interesting.20tactics.3F.html#238411760">(May 12 2021 at 02:29)</a>:</h4>
<p>A <code>grobner</code> tactic doesn't exist, but it is mathematically interesting and could exist. <code>ring</code>, of course, although I don't know how impressive it is</p>



<a name="238411888"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/interesting%20tactics%3F/near/238411888" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/interesting.20tactics.3F.html#238411888">(May 12 2021 at 02:31)</a>:</h4>
<p>The Risch algorithm is a good talking point, although to my knowledge it's never been implemented in full anywhere</p>



<a name="238412061"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/interesting%20tactics%3F/near/238412061" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/interesting.20tactics.3F.html#238412061">(May 12 2021 at 02:33)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113488-general/topic/interesting.20tactics.3F/near/238411511">said</a>:</p>
<blockquote>
<p>The <code>continuity</code> tactic might be worth a mention, as well as the use of <code>simp</code>  to prove integrals</p>
</blockquote>
<p>Thanks, great suggestion. There are over 80 <code>@[continuity]</code> tags.</p>



<a name="238412134"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/interesting%20tactics%3F/near/238412134" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/interesting.20tactics.3F.html#238412134">(May 12 2021 at 02:34)</a>:</h4>
<p>Oh, <code>norm_num</code> looks like a boring tactic but I think it is more interesting when used to prove e to ten decimals</p>



<a name="238412293"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/interesting%20tactics%3F/near/238412293" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/interesting.20tactics.3F.html#238412293">(May 12 2021 at 02:36)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113488-general/topic/interesting.20tactics.3F/near/238411613">said</a>:</p>
<blockquote>
<p><code>tidy</code> to clean up side conditions in category theory</p>
</blockquote>
<p>This is a great one.</p>



<a name="238412336"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/interesting%20tactics%3F/near/238412336" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/interesting.20tactics.3F.html#238412336">(May 12 2021 at 02:37)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113488-general/topic/interesting.20tactics.3F/near/238412134">said</a>:</p>
<blockquote>
<p>Oh, <code>norm_num</code> looks like a boring tactic but I think it is more interesting when used to prove e to ten decimals</p>
</blockquote>
<p>Indeed :)</p>



<a name="238412364"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/interesting%20tactics%3F/near/238412364" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/interesting.20tactics.3F.html#238412364">(May 12 2021 at 02:37)</a>:</h4>
<p><code>linarith</code> is great for just not having to worry about an entire class of problems that mathematicians are ill suited to solve directly</p>



<a name="238412600"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/interesting%20tactics%3F/near/238412600" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/interesting.20tactics.3F.html#238412600">(May 12 2021 at 02:40)</a>:</h4>
<p>Is there a diagram chaser? Or does tidy handle this?</p>



<a name="238412662"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/interesting%20tactics%3F/near/238412662" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/interesting.20tactics.3F.html#238412662">(May 12 2021 at 02:41)</a>:</h4>
<p>There is <code>rewrite_search</code>, although it got stuck in PR limbo for a while and I'm not sure if it landed</p>



<a name="238412711"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/interesting%20tactics%3F/near/238412711" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/interesting.20tactics.3F.html#238412711">(May 12 2021 at 02:42)</a>:</h4>
<p>I know its a bit silly but I always liked <a href="https://leanprover-community.github.io/mathlib_docs/tactics.html#dec_trivial">tactic#dec_trivial</a>, the fact that lean automatically determines that certain propositions are decidable based on some simple rules via typeclass search, and then executes the code to decide the proposition always seemed quite magic to me. I'm thinking of proofs like <a href="#narrow/stream/116395-maths/topic/quickest.20way.20to.20kill.20.22trivial.20mod.20N.22.3F/near/194219197">https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/quickest.20way.20to.20kill.20.22trivial.20mod.20N.22.3F/near/194219197</a> or more complex variations on the same idea (i.e. which numbers are sums of 3 cubes mod 9, where writing an actual argument takes longer than just instructing lean to case-bash) where this is a very transparent way of saying just check all the cases.</p>



<a name="238412917"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/interesting%20tactics%3F/near/238412917" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/interesting.20tactics.3F.html#238412917">(May 12 2021 at 02:45)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113488-general/topic/interesting.20tactics.3F/near/238412662">said</a>:</p>
<blockquote>
<p>There is <code>rewrite_search</code>, although it got stuck in PR limbo for a while and I'm not sure if it landed</p>
</blockquote>
<p>A version of <code>rewrite_search</code> was merged in <a href="https://github.com/leanprover-community/mathlib/issues/4841">#4841</a>.</p>



<a name="238413299"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/interesting%20tactics%3F/near/238413299" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/interesting.20tactics.3F.html#238413299">(May 12 2021 at 02:50)</a>:</h4>
<p>Based on a quick skim, <code>rewrite_search</code> seems similar to SMT-style E-graph + heuristic instantiation, but without the E-graph and with more focus on the heuristic.</p>



<a name="238413417"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/interesting%20tactics%3F/near/238413417" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/interesting.20tactics.3F.html#238413417">(May 12 2021 at 02:52)</a>:</h4>
<p>I guess it is literally heuristic bidirectional search in rewrite space.</p>



<a name="238413479"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/interesting%20tactics%3F/near/238413479" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/interesting.20tactics.3F.html#238413479">(May 12 2021 at 02:53)</a>:</h4>
<p>It would be nice if we had a tactic for that that was written by someone who is familar with the theory. I think we've been bumbling about in the space</p>



<a name="238413599"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/interesting%20tactics%3F/near/238413599" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/interesting.20tactics.3F.html#238413599">(May 12 2021 at 02:55)</a>:</h4>
<p>At some point lean3 had a reasonable E-matching tactic, written by Leo on top of the SMT infrastructure. But E-matching might not be a good heuristic for most mathlib domains.</p>



<a name="238413744"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/interesting%20tactics%3F/near/238413744" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/interesting.20tactics.3F.html#238413744">(May 12 2021 at 02:57)</a>:</h4>
<p>That does ring a bell. I never really learned how to use the <code>@[ematch]</code> attributes correctly. I think we dropped it because there was a bug and no one knew the code well enough to fix it</p>



<a name="238414151"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/interesting%20tactics%3F/near/238414151" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/interesting.20tactics.3F.html#238414151">(May 12 2021 at 03:02)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113488-general/topic/interesting.20tactics.3F/near/238413744">said</a>:</p>
<blockquote>
<p>I never really learned how to use the <code>@[ematch]</code> attributes correctly.</p>
</blockquote>
<p>This is somewhat of a dark art.</p>



<a name="238421114"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/interesting%20tactics%3F/near/238421114" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/interesting.20tactics.3F.html#238421114">(May 12 2021 at 04:53)</a>:</h4>
<p><span class="user-mention" data-user-id="230999">@Daniel Selsam</span> If the audience is mathematicians, I think even <code>simp</code> and <code>rw</code> deserve quite some attention. They are certainly the most used "real" tactics. (In some sense <code>apply</code> and <code>exact</code> or not "real" tactics.)<br>
But especially <code>simp</code> breaks the <code>A = B</code> symmetry that mathematicians have fundamentally ingrained. So explaining what makes a good <code>simp</code>-lemma might be useful/interesting.</p>



<a name="238421589"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/interesting%20tactics%3F/near/238421589" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/interesting.20tactics.3F.html#238421589">(May 12 2021 at 05:00)</a>:</h4>
<p><code>simp</code> is an especially interesting example because it has almost unbounded scope, it is as powerful as the simp lemmas that go into it</p>



<a name="238421675"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/interesting%20tactics%3F/near/238421675" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/interesting.20tactics.3F.html#238421675">(May 12 2021 at 05:02)</a>:</h4>
<p>like the example with solving integrals, it does things people would not have originally expected - the user basically gets to "program" it using simp lemmas</p>



<a name="238421847"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/interesting%20tactics%3F/near/238421847" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/interesting.20tactics.3F.html#238421847">(May 12 2021 at 05:05)</a>:</h4>
<p>I'm thinking of this: <a href="#narrow/stream/116395-maths/topic/What's.20new.20in.20Lean.20maths.3F/near/228351477">https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/What's.20new.20in.20Lean.20maths.3F/near/228351477</a></p>



<a name="238423959"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/interesting%20tactics%3F/near/238423959" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/interesting.20tactics.3F.html#238423959">(May 12 2021 at 05:41)</a>:</h4>
<p>Another, which isn't a tactic: <em>typeclass inference</em>. The fact that Lean automatically figures out that <code>polynomial B</code> is a commutative ring, and a module and an algebra over <code>B</code> is just very very nice.<br>
In LTE we also (ab)use it with <code>fact</code>s to prove all sorts of annoying trivial inequalities about real numbers.</p>



<a name="238432586"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/interesting%20tactics%3F/near/238432586" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/interesting.20tactics.3F.html#238432586">(May 12 2021 at 07:26)</a>:</h4>
<p>The ematch bug was pretty simple: any lemma that required two different copies of the same typeclass (but for different types) killed it. This made it useless in category theory as soon any functor was involved, because there would be both the source and target <code>category</code> instance.</p>



<a name="238433578"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/interesting%20tactics%3F/near/238433578" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/interesting.20tactics.3F.html#238433578">(May 12 2021 at 07:37)</a>:</h4>
<p>Did nobody mention <code>nlinarith</code> yet? A potted and probably slightly inaccurate version of its history: <code>linarith</code> is a powerful tool for 1st year undergraduate analysis, because it turns out that many times in analysis you say stuff like "well <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>a</mi><mo>−</mo><mi>b</mi><mi mathvariant="normal">∣</mi><mo>&lt;</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">|a-b|&lt;x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">b</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>b</mi><mo>−</mo><mi>c</mi><mi mathvariant="normal">∣</mi><mo>&lt;</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">|b-c|&lt;y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">c</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>c</mi><mo>−</mo><mi>d</mi><mi mathvariant="normal">∣</mi><mo>&lt;</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">|c-d|&lt;z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span></span> so clearly <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>a</mi><mo>−</mo><mi>d</mi><mi mathvariant="normal">∣</mi><mo>&lt;</mo><mi>x</mi><mo>+</mo><mi>y</mi><mo>+</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">|a-d|&lt;x+y+z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span></span>" and doing this manually is a real drag, but if you invoke <code>abs_lt</code> then <code>linarith</code> does it all for you. However it didn't know <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>x</mi><mn>2</mn></msup><mo>≥</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">x^2\geq0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.950078em;vertical-align:-0.13597em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> because this wasn't linear, so <span class="user-mention" data-user-id="110596">@Rob Lewis</span> added what seemed to me at least to be a "minor" extension to <code>linarith</code> which knew this and a couple of other nonlinear facts like <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo>≥</mo><mn>0</mn><mtext>  </mtext><mo>⟹</mo><mtext>  </mtext><mi>a</mi><mi>b</mi><mo>≥</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">a,b\geq0\implies ab\geq0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66844em;vertical-align:-0.024em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⟹</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">ab</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> and called it <code>nlinarith</code>, and the result was a tool which, for me, was surprisingly powerful. <a href="#narrow/stream/116395-maths/topic/linarith.20power/near/231508238">Here's Heather</a> using it with manifolds, and if you define the integers as a mathematician would, as a quotient of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="double-struck">N</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">\mathbb{N}^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>, then there's a <a href="#narrow/stream/116395-maths/topic/integer.20multiplication.20and.20nlinarith/near/215105486">really annoying goal to prove when checking that multiplication is well-defined</a>, and <code>nlinarith</code> solves it immediately (the argument is circular but this doesn't matter for pedagogical purposes).</p>



<a name="238440308"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/interesting%20tactics%3F/near/238440308" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/interesting.20tactics.3F.html#238440308">(May 12 2021 at 08:37)</a>:</h4>
<p>Kind of off-topic, but I think the quotient of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="double-struck">N</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">\mathbb N^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span> becomes easier to deal with if you make it a <code>quot</code> instead of a <code>quotient</code>. Namely it's the <code>quot</code> by the inductive family of props relating <code>(a, b)</code> and <code>(a + k, b + k)</code>. Then defining multiplication using <a href="https://leanprover-community.github.io/mathlib_docs/find/quot.lift₂">docs#quot.lift₂</a> should leave you with a simpler goal.</p>



<a name="238483534"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/interesting%20tactics%3F/near/238483534" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/interesting.20tactics.3F.html#238483534">(May 12 2021 at 14:32)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113488-general/topic/interesting.20tactics.3F/near/238421675">said</a>:</p>
<blockquote>
<p>the user basically gets to "program" it using simp lemmas</p>
</blockquote>
<p>Similar with <code>tidy</code>. Is there an analogue of Coq's <code>auto</code> in lean3? i.e. a programmable tree search?</p>



<a name="238483947"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/interesting%20tactics%3F/near/238483947" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/interesting.20tactics.3F.html#238483947">(May 12 2021 at 14:34)</a>:</h4>
<p>I see the extensible <code>back_chaining</code>tactic is still there, but I can't find a single use in mathlib</p>



<a name="238484717"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/interesting%20tactics%3F/near/238484717" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jannis Limperg <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/interesting.20tactics.3F.html#238484717">(May 12 2021 at 14:39)</a>:</h4>
<p>We don't currently have a reasonably fully-featured proof search procedure except possibly gptf. I'm working on an auto-like tactic, but it'll be a while until that's ready for use.</p>



<a name="238485644"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/interesting%20tactics%3F/near/238485644" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/interesting.20tactics.3F.html#238485644">(May 12 2021 at 14:44)</a>:</h4>
<p>Interesting. FYI <code>auto</code> gets a lot of mileage in Coq. A few months back I cloned a dozen top Coq libraries and grepped for tactic occurrences, and <code>auto</code> was used 40,000 times. In contrast, <code>ring</code> appeared 4,000 times and <code>field</code> 400 times.</p>



<a name="238485950"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/interesting%20tactics%3F/near/238485950" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/interesting.20tactics.3F.html#238485950">(May 12 2021 at 14:45)</a>:</h4>
<p><span class="user-mention" data-user-id="256311">@Jannis Limperg</span> programmable tree-search (in lean4) is on my critical path as well</p>



<a name="238487348"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/interesting%20tactics%3F/near/238487348" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jannis Limperg <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/interesting.20tactics.3F.html#238487348">(May 12 2021 at 14:54)</a>:</h4>
<p>Yeah, these tactics tend to be big workhorses (in Isabelle and ACL2 as well, even compared to Sledgehammer). It'll be interesting to see to what extent they apply to mathlib since the proofs here are less computer sciency. I'm planning to port to Lean 4 as well; I just started in Lean 3 so that I would have a staple API and a big library on which to test the thing.</p>



<a name="238490667"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/interesting%20tactics%3F/near/238490667" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/interesting.20tactics.3F.html#238490667">(May 12 2021 at 15:13)</a>:</h4>
<p>FWIW I wouldn't recommend porting this kind of tactic. There are many new opportunities that could be exploited by a clean-slate design in lean4, thanks to e.g. built-in discrimination trees, better support for environment caching, etc.</p>



<a name="238492600"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/interesting%20tactics%3F/near/238492600" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jannis Limperg <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/interesting.20tactics.3F.html#238492600">(May 12 2021 at 15:24)</a>:</h4>
<p>Interesting. I'll message you privately to avoid derailing the thread further.</p>



<a name="238493970"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/interesting%20tactics%3F/near/238493970" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/interesting.20tactics.3F.html#238493970">(May 12 2021 at 15:32)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113488-general/topic/interesting.20tactics.3F/near/238433578">said</a>:</p>
<blockquote>
<p>nlinarith</p>
</blockquote>
<p>The original <code>nlinarith</code> was from <span class="user-mention" data-user-id="110049">@Mario Carneiro</span> , a light wrapper around <code>linarith</code> that did what the Coq <code>nlinarith</code> docs claimed to do. I updated it a bit to do what (I think) Coq's <code>nlinarith</code> actually does. Then had to speed up <code>linarith</code> because some reasonable goals were too slow.</p>



<a name="238556452"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/interesting%20tactics%3F/near/238556452" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/interesting.20tactics.3F.html#238556452">(May 12 2021 at 22:58)</a>:</h4>
<p>Anothern interesting tactic that I think hasn't been mentioned (and is perhaps underused) is <a href="https://leanprover-community.github.io/mathlib_docs/tactics.html#solve_by_elim">tactic#solve_by_elim</a></p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
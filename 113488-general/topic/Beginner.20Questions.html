---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/Beginner.20Questions.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html">Beginner Questions</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="128751244"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/128751244" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Clyde Watson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#128751244">(Jun 28 2018 at 02:54)</a>:</h4>
<p>I'm really new to LEAN (and anything like it), and I've had some problems that might be considered a little too simple.</p>



<a name="128751249"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/128751249" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Clyde Watson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#128751249">(Jun 28 2018 at 02:54)</a>:</h4>
<p>Questions answered so far:</p>
<p>Let's say that I declared a variable a of type int. How do I attribute a value to it (let's say, 3)?</p>
<p>How would I define a function that searches for a given object in a list?</p>
<p>How do I know that I've reached the end of a list? I want to know this in order to compare if two strings have the same characters at the same positions.</p>
<p>Is there a document where I can check all the avaliable commands for Lean?</p>
<p>How would I declare a local variable inside a function?</p>
<p>New Questions:</p>
<p>Do string and list char represent the same type?</p>
<p>That's it, for now. Thank you all for your time and patience :)</p>



<a name="128751446"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/128751446" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#128751446">(Jun 28 2018 at 03:00)</a>:</h4>
<p>First question: you want a definition. You do it with <code>def my_def : int := 7</code></p>



<a name="128751738"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/128751738" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Clyde Watson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#128751738">(Jun 28 2018 at 03:10)</a>:</h4>
<p>Thank you for that, Simon!</p>



<a name="128751894"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/128751894" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#128751894">(Jun 28 2018 at 03:16)</a>:</h4>
<p>Second question: </p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">find</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">list</span> <span class="n">nat</span> <span class="bp">-&gt;</span> <span class="n">option</span> <span class="n">nat</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="o">:=</span> <span class="n">none</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">y</span> <span class="bp">::</span> <span class="n">ys</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">if</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="k">then</span> <span class="n">some</span> <span class="mi">0</span>
         <span class="k">else</span> <span class="n">do</span> <span class="n">r</span> <span class="bp">&lt;-</span> <span class="n">find</span> <span class="n">ys</span>
                 <span class="n">return</span> <span class="o">(</span><span class="n">r</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>
</pre></div>



<a name="128752529"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/128752529" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Clyde Watson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#128752529">(Jun 28 2018 at 03:36)</a>:</h4>
<p>Thanks again! <span class="emoji emoji-1f642" title="simple smile">:simple_smile:</span> I will try to understand the code.</p>



<a name="128752644"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/128752644" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#128752644">(Jun 28 2018 at 03:40)</a>:</h4>
<p>Don't hesitate to ask more questions. I tried to put as little mysterious stuff as possible but I think if you're not a Haskell adept, <code>do</code>, <code>&lt;-</code>  and <code>return</code> are not obvious.</p>



<a name="128754968"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/128754968" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#128754968">(Jun 28 2018 at 05:04)</a>:</h4>
<blockquote>
<p>First one: Let's say that I declared a variable a of type int. How do I attribute a value to it (let's say, 3)?</p>
</blockquote>
<p>The first thing to understand about lean is that it is a <em>functional programming language</em>. If you are used to a more traditional imperative programming language, like C, Java, Python, etc, then there is a bit of culture shock to be had. The big thing to know is that there are no "variables* in lean in the sense meant by this word in imperative languages. (My professor always said this was a bad name for them and preferred the term "assignable" for C/Java style mutable memory locations.) In lean, variables are things that you can substitute values for, but their values never change from the time they are declared. In an imperative language you would call these immutable variables, but there are no mutable variables in lean.</p>
<p>To declare a variable and give it a value, you can use <code>let</code>:</p>
<div class="codehilite"><pre><span></span>def f (x : nat) : nat :=
let y := 3 in ...
</pre></div>


<p>Here <code>f</code> is a function with an input variable of type <code>nat</code>, and inside the body of the function I've declared a variable <code>y</code> (also of type <code>nat</code>) with value <code>3</code>.</p>



<a name="128755050"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/128755050" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#128755050">(Jun 28 2018 at 05:07)</a>:</h4>
<blockquote>
<p>Second one: How would I define a function that searches for a given object in a list?</p>
<p>Third, that's related to the second one: How do I know that I've reached the end of a list? I want to know this in order to compare if two strings have the same characters at the same positions.</p>
</blockquote>
<p>Usually, a function which is defined on lists will be done by pattern matching, as in Simon's code. This is done in the first two lines, with <code>| [] :=</code> and <code>| (y :: ys) :=</code>. This says what to do if the list is empty, and what to do if it is nonempty with head <code>y</code> and tail <code>ys</code>. Defining the function this way automatically takes care of "knowing when I've reached the end of a list", because you can't even get the value from a list unless you are already in the nonempty case - the nonempty check and value retrieval happen at the same time.</p>



<a name="128755147"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/128755147" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#128755147">(Jun 28 2018 at 05:10)</a>:</h4>
<p>Here's a function that compares two strings and returns true iff they are equal:</p>
<div class="codehilite"><pre><span></span>def is_equal : list char → list char → bool
| []        []        := tt
| (x :: xs) []        := ff
| []        (y :: ys) := ff
| (x :: xs) (y :: ys) := (x = y) &amp;&amp; is_equal xs ys
</pre></div>



<a name="128755265"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/128755265" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#128755265">(Jun 28 2018 at 05:14)</a>:</h4>
<blockquote>
<p>Fourth: Is there a document where I can check all the avaliable commands for Lean?</p>
</blockquote>
<p>This depends on what you mean by "command". There are relatively few actual keywords recognized by the lean language, and you can find a relatively complete list in chapters 4 and 5 of the <a href="https://leanprover.github.io/reference/" target="_blank" title="https://leanprover.github.io/reference/">lean reference manual</a>.</p>



<a name="128755374"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/128755374" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#128755374">(Jun 28 2018 at 05:19)</a>:</h4>
<blockquote>
<p>Fifth: How would I declare a local variable inside a function? I tried doing the following:</p>
</blockquote>
<div class="codehilite"><pre><span></span>def example_def (a : int) : int :=
variable k : int
</pre></div>


<blockquote>
<p>I have a feeling that I might have to use let k := int in ..., but I'm not really sure.</p>
</blockquote>
<p>Since as mentioned there is no such thing as a local assignable in lean, the best you can do is to have a <code>let</code> declaration, which also requires that you provide the local variable with a value. This is because unlike most pointer based languages, there is no "universal null" value in all types - the values of a type are all explicitly determined by the type. So if you define a variable of type <code>int</code>, then it must contain an integer value, maybe <code>0</code> or <code>42</code> or something but "unassigned" is not an option. <code>let k := int</code> actually declares <code>k</code> to be a variable of type <code>Type</code> with value <code>int</code>, which is probably not what you want.</p>



<a name="128804676"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/128804676" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Clyde Watson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#128804676">(Jun 29 2018 at 01:22)</a>:</h4>
<blockquote>
<p>Don't hesitate to ask more questions. I tried to put as little mysterious stuff as possible but I think if you're not a Haskell adept, <code>do</code>, <code>&lt;-</code>  and <code>return</code> are not obvious.</p>
</blockquote>
<p>You are right, it isn't that obvious. What does "some 0" mean?<br>
I'm having some trouble understand the "do r &lt;- find ys return (r +1)" part.  Isn't find missing one argument, that is, the x that it's searching? Also, for some reason, Lean considers ys to have the type "option nat".</p>



<a name="128804735"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/128804735" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Clyde Watson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#128804735">(Jun 29 2018 at 01:24)</a>:</h4>
<p>Thanks a lot for all the explanations, Mario! It really is a shock. It's the first time I'm seeing a functional programming language.</p>



<a name="128804790"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/128804790" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Clyde Watson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#128804790">(Jun 29 2018 at 01:26)</a>:</h4>
<blockquote>
<p>Here's a function that compares two strings and returns true iff they are equal:</p>
</blockquote>
<p>def is_equal : list char → list char → bool<br>
| []        []        := tt<br>
| (x :: xs) []        := ff<br>
| []        (y :: ys) := ff<br>
| (x :: xs) (y :: ys) := (x = y) &amp;&amp; is_equal xs ys</p>
<div class="codehilite"><pre><span></span>
</pre></div>


<p>So, according to the piece of code you sent, whenever I want to compare two kinds of lists, I only have to "place them" side by side?</p>



<a name="128805114"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/128805114" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Clyde Watson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#128805114">(Jun 29 2018 at 01:37)</a>:</h4>
<p>One new quesion: In Lean, are there any differences between string and list char?</p>



<a name="128805586"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/128805586" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#128805586">(Jun 29 2018 at 01:52)</a>:</h4>
<blockquote>
<p>You are right, it isn't that obvious. What does "some 0" mean?</p>
</blockquote>
<p><code>some 0</code> could also be written <code>return 0</code>. Both are expressions of type <code>option nat</code>. <code>option nat</code> has two kinds of values <code>none</code> or <code>some n</code> where <code>n</code> is a natural number. That means <code>option nat</code> either contains a single natural number or nothing. <code>return 0</code> comes in handy when you think of <code>option nat</code> as a sequential program that may fail or return a natural number. This leads us to your second question:</p>
<blockquote>
<p>I'm having some trouble understand the "do r &lt;- find ys return (r +1)" part. Isn't find missing one argument, that is, the x that it's searching? Also, for some reason, Lean considers ys to have the type "option nat".</p>
</blockquote>
<p>I apologize, the expression has a syntax error in it. It should be <code>do r &lt;- find ys, return (r +1)</code> (notice the comma in the middle). You can read it as "call <code>find ys</code> then, if it doesn't fail (i.e. produce the value <code>none</code>) take the result (a natural number), call it <code>r</code> and return from the sequence of two instructions with the value of <code>r+1</code>"</p>



<a name="128813110"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/128813110" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sean Leather <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#128813110">(Jun 29 2018 at 06:01)</a>:</h4>
<blockquote>
<p>One new quesion: In Lean, are there any differences between string and list char?</p>
</blockquote>
<p>This is extracted from the core library (<a href="https://github.com/leanprover/lean/blob/master/library/init/data/string/basic.lean#L10-L18" target="_blank" title="https://github.com/leanprover/lean/blob/master/library/init/data/string/basic.lean#L10-L18"><code>init/data/string/basic.lean</code></a>):</p>
<div class="codehilite"><pre><span></span><span class="c">/-</span><span class="cm"> In the VM, strings are implemented using a dynamic array and UTF-8 encoding. -/</span>
<span class="kn">structure</span> <span class="n">string_imp</span> <span class="o">:=</span> <span class="o">(</span><span class="n">data</span> <span class="o">:</span> <span class="n">list</span> <span class="n">char</span><span class="o">)</span>
<span class="n">def</span> <span class="n">string</span> <span class="o">:=</span> <span class="n">string_imp</span>
</pre></div>



<a name="128814743"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/128814743" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#128814743">(Jun 29 2018 at 06:56)</a>:</h4>
<blockquote>
<p>So, according to the piece of code you sent, whenever I want to compare two kinds of lists, I only have to "place them" side by side?</p>
</blockquote>
<p>That's the way pattern match syntax works. In this case, since the type of the function is <code>is_equal : list char → list char → bool</code>, there are two arguments, both lists of chars, and so each case should include two variables, possibly broken into cases. In my code snippet I broke into all four cases, but you can combine some of them with wildcards <code>_</code>, depending on the function you are defining. You should read the second case <code>| (x :: xs) [] := ff</code> as being shorthand for the partial specification <code>is_equal (x :: xs) [] = ff</code> of the function <code>is_equal</code>.</p>



<a name="128814833"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/128814833" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#128814833">(Jun 29 2018 at 06:59)</a>:</h4>
<blockquote>
<p>One new quesion: In Lean, are there any differences between string and list char?</p>
</blockquote>
<p>Just to unpack Sean's answer a bit: In lean, a string is a wrapper around a <code>list char</code>. The wrapper is there because there is a change of underlying data representation - I believe <code>string</code> is stored as an array of bytes, while <code>list char</code> is a linked list, like all <code>list</code> structures.</p>
<p>In fact, the whole function <code>is_equal</code> already exists in lean so you don't need to define it - it's just <code>a = b</code> where <code>a b : string</code>. Pretty much all data types defined in lean have an equality test implemented, and you can write equality tests for your own data structures easily as well.</p>



<a name="128815011"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/128815011" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#128815011">(Jun 29 2018 at 07:05)</a>:</h4>
<p>Here's another way to write Simon's <code>find</code> function using pattern matching instead of monad notation:</p>
<div class="codehilite"><pre><span></span>def find (x : nat) : list nat -&gt; option nat
| [] := none
| (y :: ys) :=
  if x = y then some 0 else
  match find ys with
  | none := none
  | some r := some (r + 1)
  end
</pre></div>


<p>The <code>match</code> acts just like the top level pattern match - it takes the result of <code>find ys</code>, which is an <code>option nat</code>, and breaks into cases depending on if it is <code>none</code> or <code>some r</code> for some <code>r</code>. I mentioned before that lean has no "universal null" value, but when you explicitly want to indicate a "null" value, you do it with the <code>option</code> type. Essentially, this function either returns a result, wrapped in <code>some</code>, or it returns failure to find the value, encoded as <code>none</code> here (you might use "null" for this in other languages).</p>



<a name="128816419"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/128816419" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#128816419">(Jun 29 2018 at 07:54)</a>:</h4>
<p><span class="user-mention" data-user-id="120239">@Clyde Watson</span> I started with Lean after very little functional programming experience (I knew some python / java but only as a hobbyist; I am a professional mathematician). I found <a href="http://learnyouahaskell.com/" target="_blank" title="http://learnyouahaskell.com/">http://learnyouahaskell.com/</a> extremely helpful. Your questions about basic pattern matching seem to indicate that you might be able to learn a lot from this resource (or from some other Haskell learning resources, if the informality of this one is not to your taste). Basically the rule is that if you're defining functions on, or proving things about, so-called "inductive types" like the natural numbers or lists, then you use induction (or recursion), and a syntax which is a completely basic part of functional programming with these "|"s.</p>



<a name="128816592"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/128816592" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#128816592">(Jun 29 2018 at 08:00)</a>:</h4>
<p>terminology note: In Haskell, what we call "inductive types" are called (generalized) algebraic data types or GADTs</p>



<a name="128823178"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/128823178" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sean Leather <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#128823178">(Jun 29 2018 at 11:20)</a>:</h4>
<blockquote>
<p>I started with Lean after very little functional programming experience (I knew some python / java but only as a hobbyist; I am a professional mathematician). I found <a href="http://learnyouahaskell.com/" target="_blank" title="http://learnyouahaskell.com/">http://learnyouahaskell.com/</a> extremely helpful.</p>
</blockquote>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> That's pretty cool that you used Learn You a Haskell for Great Good. Did you learn Haskell first and then move to Lean or use it as a tutorial about the related concepts in Lean?</p>



<a name="128823396"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/128823396" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#128823396">(Jun 29 2018 at 11:27)</a>:</h4>
<p>I am not sure I have learnt Haskell in any real sense. The reason I mentioned it was that the website I mentioned showed me how to define functions on lists by recursion using exactly the notation that the OP was originally asking about. Basically my history was: hobbyist programmer (written simple Android apps in java etc), then in 2016 I attempted to read learnyouahaskell just because (a) I knew the people on our joint maths and computing degree had to learn it in their first term and (b) I'd had an undergraduate doing a maths project with me on elliptic curves and they'd used Haskell to write their code, and then later in 2016 I tried reading it again, and then in 2017 I started trying to code in Lean and then I went back to it for a third time and this time it all made sense. But the concept of defining a function on lists by defining it on the constructors was something which dawned on me on the first reading.</p>



<a name="128845444"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/128845444" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#128845444">(Jun 29 2018 at 19:17)</a>:</h4>
<blockquote>
<p>Isn't find missing one argument</p>
</blockquote>
<p>This is a syntactic oddity of lean--when referring to the thing currently being defined (here <code>find</code>) inside its own definition, parameters to the left of the colon (here <code>(x : nat)</code>) are fixed, and you don't even write them.</p>



<a name="128845733"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/128845733" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#128845733">(Jun 29 2018 at 19:22)</a>:</h4>
<p>So <code>find ys</code> inside the definition of <code>find</code> means the same as <code>find x ys</code> outside it</p>



<a name="128853494"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/128853494" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#128853494">(Jun 29 2018 at 22:29)</a>:</h4>
<blockquote>
<p>What does "some 0" mean?</p>
</blockquote>
<p>I'll show you how to figure this out yourself!</p>
<p>One really important thing to learn in Lean is that every question of this form is a question which you can begin to investigate yourself, and the sooner you learn how to do this the sooner you can figure out what you need to learn next; you can ask really targetted questions which in general receive better answers. </p>
<p>Here's how you can use Lean to answer your own question, in VS Code. First open a completely new file called scratch.lean and let's see if we can isolate your question. Make this as the only line:</p>
<p><code>definition X := some 0</code></p>
<p>It works! </p>
<p>[technical note: This isn't always the case -- sometimes the thing you're trying to understand might rely on some file being imported or some namespace being open and you'll have to resort to right-clicking -- see later.]</p>
<p>Now we have <code>X</code> we can see what this <code>some</code> command really is -- it's defined in the root namespace and is in core lean, so it's probably important. </p>
<p>Now we can write stuff like</p>
<p><code>#check X</code></p>
<p>to see that <code>X</code> is a term of type <code>option ℕ</code>. So it looks like <code>option</code> is a function which eats <code>ℕ</code>. What is the type of <code>ℕ</code>? We just check with</p>
<p><code>#check ℕ</code></p>
<p>and we see that <code>ℕ</code> has type <code>Type</code>. So <code>option</code> is a function which eats something of type <code>Type</code>. We can look at what <code>option</code> is with</p>
<p><code>#check option </code></p>
<p>and we see it's a function from <code>Type</code> to <code>Type</code> (just ignore the universes, you can worry about these later). So <code>some 0</code> is a term of type <code>option ℕ</code>which has type <code>Type</code>. So that's where <code>some 0</code> lives in the tree of terms, types and universes.</p>
<p>[Pro tip: always be checking there are no red underlines in your code. Sometimes random typos which you don't bother to fix can have weird consequences later on. Learn how to use <code>sorry</code> to fix red errors in half-written code]</p>
<p>We didn't look at any definitions yet, we just looked at the types of everything in sight. Everything has a type, and <code>#check x</code> tells you the type of <code>x</code>. Here is a simple picture of the entire type theory of Lean. There are six kinds of things. There are two universes, <code>Type</code> and <code>Prop</code>. A type is something of type <code>Type</code>, and a term is something of type <code>α</code> for <code>α</code> a type. A proposition is something of type <code>Prop</code>, and a proof is something of type <code>H</code> for <code>H</code> a proposition. That's it. The <code>Type</code> stuff is where computer programs live. <code>Prop</code> is where theorems and proofs live. So <code>some 0</code> is a computable thing, it's a term of type <code>option ℕ : Type</code>. </p>
<p>Next let's actually unravel the definitions. Right-click on <code>some</code> in VS Code and select <code>Go to definition</code> (or left-click and press F12). A new file will open called <code>core.lean</code> and you'll be taken to about line 279 where you'll see that <code>option α</code> is an inductive type with two constructors: <code>none</code> and <code>some val</code> with <code>val : α</code>. So in abstracta your question is answered -- <code>some</code> is a constructor which takes <code>n : ℕ</code> and returns <code>some n : option ℕ</code>. We can just check that with </p>
<p><code>#check some</code></p>
<p>and the answer...looks a bit messy. It's clearly some kind of function, but there are question marks. If you don't like those <code>?M_1</code> things, you could use the following trick:</p>
<p><code>#check @some</code></p>
<p>which works with functions and which might produce nicer output. Now we see that <code>some</code> is actually a Pi type.</p>
<p>Here's a gist with all those commands in. One of the fiddly little VS Code options on the right is "show the output of all the <code>#check</code>s at once"; that might be the one you want here.</p>
<p><a href="https://gist.github.com/kbuzzard/455709bfd5d8fed57f5e4321481adf5b" target="_blank" title="https://gist.github.com/kbuzzard/455709bfd5d8fed57f5e4321481adf5b">https://gist.github.com/kbuzzard/455709bfd5d8fed57f5e4321481adf5b</a></p>
<p>If you get stuck at some point, send the entire file as a gist (just google for how to do it) or, if it's got quite big, just a minimal working example of your question. It's much easier for experts to answer questions with the full file in front of them. Even experts make silly mistakes sometimes, which others can spot instantly. Actually, sometimes I find my own silly mistakes when I am making the minimal working example. And did I mention to make sure there are no errors in your file?</p>
<p>So that's <code>option</code>, and how to ask if you get stuck along the way. But if you want some more insight as to what the point of this type is, or perhaps want to know more about what an inductive type is or a Pi type, or what the different kinds of brackets all mean (round, squiggly, square), now is the time to go to the docs -- Theorem Proving In Lean is a really good place to look for basic stuff. It's here:</p>
<p><a href="https://leanprover.github.io/theorem_proving_in_lean/" target="_blank" title="https://leanprover.github.io/theorem_proving_in_lean/">https://leanprover.github.io/theorem_proving_in_lean/</a></p>
<p>I find the web search functionality really hard to use though; there's a pdf download and I usually search with my pdf viewer and then maybe switch to the html manual later because it looks nicer, if I want to know more. If you want to know more about <code>option</code> then the fourth occurrence of " option " in the pdf is the one you want; it's on p101. There you can see a brief description of the point of <code>option</code> and examples of other inductive types which have similar structures. I wish I had learnt this method earlier -- it took a while to dawn on me that you could just work everything out by right clicking and figuring out if you were a term or a type, a proof or a proposition.</p>
<p>You also need to learn a kind of filter -- stuff you can just ignore for the time being.  Stuff like typeclasses, <code>opt_param</code>/<code>out_param</code>, <code>[stuff in brackets]</code> and universes, you can start to worry about them later. Universes are to do with subtle set-theoretic issues like avoiding Russell's Paradox, and the other stuff is technical computer science stuff which you can just treat as magic for the time being. [Typeclasses are some crazy computer science generalisation of notation overloading]</p>



<a name="128879959"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/128879959" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Amin Bandali <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#128879959">(Jun 30 2018 at 13:08)</a>:</h4>
<p>Another beginner question here: Is it possible to "overload" an instance?</p>
<p><code>format</code> has an instance for <code>list α</code>:<br>
<a href="https://github.com/leanprover/lean/blob/e53f8021ec3bd8b6c7c2eb998932ec79cb941b18/library/init/meta/format.lean#L87-L92" target="_blank" title="https://github.com/leanprover/lean/blob/e53f8021ec3bd8b6c7c2eb998932ec79cb941b18/library/init/meta/format.lean#L87-L92">https://github.com/leanprover/lean/blob/e53f8021ec3bd8b6c7c2eb998932ec79cb941b18/library/init/meta/format.lean#L87-L92</a><br>
And I'd like to customize that in various places. For instance, say, I'd want to drop the outer square brackets, or another time make the items semicolon-separated rather than comma-separated</p>



<a name="128884679"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/128884679" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#128884679">(Jun 30 2018 at 15:38)</a>:</h4>
<p>It is possible but I wouldn't advise using it that way. Instead, you should explicitly invoke the formatting code that you're interested in. Just to be sure, can you show an example where that would be handy?</p>



<a name="128884895"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/128884895" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Amin Bandali <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#128884895">(Jun 30 2018 at 15:45)</a>:</h4>
<p>I see. The example I was aiming to use that for was a <code>structure</code> with a <code>(exts : list string)</code> field, which I wanted format using <code>format!"EXTENDS {my_struct.exts}"</code></p>



<a name="128885052"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/128885052" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#128885052">(Jun 30 2018 at 15:50)</a>:</h4>
<p>Yes, that's what I thought. If you replace <code>format!"EXTENDS {my_struct.exts}"</code> with `format!"EXTENDS {my_to_fmt my_struct.exts}" you should get the same result. Unlike in Haskell, Lean doesn't guarantee global uniqueness of instances so you have to be vigilant not to make the instance search more difficult</p>



<a name="128885421"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/128885421" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Amin Bandali <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#128885421">(Jun 30 2018 at 16:03)</a>:</h4>
<p>Thanks for the explanations <span class="emoji emoji-1f642" title="simple smile">:simple_smile:</span>  makes sense</p>



<a name="129013476"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/129013476" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Guy Leroy <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#129013476">(Jul 03 2018 at 09:58)</a>:</h4>
<p>Hi, I'm following a simple tutorial for Lean and an exercice is to define a curry function and an uncurry function.<br>
Could anyone help me with this please?</p>
<p>def curry (α β γ : Type) (f : α × β → γ) : α → β → γ := sorry<br>
def uncurry (α β γ : Type) (f : α → β → γ) : α × β → γ := sorry</p>



<a name="129013840"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/129013840" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#129013840">(Jul 03 2018 at 10:10)</a>:</h4>
<p>If you have <code>a : α</code> and <code>b : β</code> then I can make an element of type <code>α × β</code> by writing <code>⟨a, b⟩</code>. The pointy bracket is written with <code>\&lt;</code>. If I have <code>x : α × β</code>, then <code>x.1</code> is the first element of the pair and <code>x.2</code> is the second element.</p>



<a name="129014538"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/129014538" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Guy Leroy <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#129014538">(Jul 03 2018 at 10:25)</a>:</h4>
<p>Oh thank you. I am still struggling though, the best I came up with is:</p>
<p>def curry (α β γ : Type) (f : α × β → γ) : α → β → γ := λ f x, f x.1 x.2 <br>
def uncurry (α β γ : Type) (f : α → β → γ) : α × β → γ := λ f a b, f ⟨a, b⟩  </p>
<p>which is obvisouly wrong  as the types don't match but I can't figure out how to make it work</p>



<a name="129014608"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/129014608" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Guy Leroy <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#129014608">(Jul 03 2018 at 10:26)</a>:</h4>
<p>Any other hint?</p>



<a name="129014636"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/129014636" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#129014636">(Jul 03 2018 at 10:27)</a>:</h4>
<p>Your answers are perfect, except they are swapped</p>



<a name="129014639"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/129014639" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sean Leather <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#129014639">(Jul 03 2018 at 10:27)</a>:</h4>
<p>To add to Chris's answer, there are a couple of things you can do to learn what you need to do.</p>
<ul>
<li><code>×</code> is notation for <code>prod</code>. How would you know this? You can do <code>#print ×</code> in a file and see <code>_ </code>×<code>:35 _:34 := prod #1 #0</code>.</li>
<li>Want to find out more about <code>prod</code>, use <code>#print prod</code>.</li>
</ul>
<div class="codehilite"><pre><span></span><span class="bp">@</span><span class="o">[</span><span class="n">derive</span> <span class="n">list</span><span class="bp">.</span><span class="n">cons</span><span class="bp">.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pexpr</span> <span class="bp">``</span><span class="o">(</span><span class="n">has_reflect</span><span class="o">)</span> <span class="o">(</span><span class="n">list</span><span class="bp">.</span><span class="n">nil</span><span class="bp">.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pexpr</span><span class="o">)]</span>
<span class="kn">structure</span> <span class="n">prod</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">v</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span>
<span class="n">fields</span><span class="o">:</span>
<span class="n">prod</span><span class="bp">.</span><span class="n">fst</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">},</span> <span class="n">α</span> <span class="bp">×</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">α</span>
<span class="n">prod</span><span class="bp">.</span><span class="n">snd</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">},</span> <span class="n">α</span> <span class="bp">×</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">β</span>
</pre></div>


<ul>
<li><code>structure</code>s have a default constructor <code>mk</code>. Try <code>#print prod.mk</code>.</li>
<li>Lastly, <code>⟨a, ..., z⟩</code> is the anonymous constructor that works for many structures and types.</li>
</ul>



<a name="129014717"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/129014717" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#129014717">(Jul 03 2018 at 10:29)</a>:</h4>
<p>They're not quite perfect. You need to get rid of the <code>f</code>s in the lambdas. In lean syntax anything before the colon doesn't need to be introduced with a lambda.</p>



<a name="129014776"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/129014776" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#129014776">(Jul 03 2018 at 10:30)</a>:</h4>
<p>This is correct.</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">curry</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span> <span class="n">γ</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">×</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">γ</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">γ</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">f</span> <span class="bp">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="bp">⟩</span>
<span class="n">def</span> <span class="n">uncurry</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span> <span class="n">γ</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">γ</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">×</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">γ</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span><span class="bp">.</span><span class="mi">1</span> <span class="n">x</span><span class="bp">.</span><span class="mi">2</span>
</pre></div>



<a name="129014805"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/129014805" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sean Leather <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#129014805">(Jul 03 2018 at 10:31)</a>:</h4>
<p>Just to help you see, these are also possible:</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">curry</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span> <span class="n">γ</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">γ</span><span class="o">)</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">γ</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">f</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">f</span> <span class="bp">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="bp">⟩</span>
<span class="n">def</span> <span class="n">uncurry</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span> <span class="n">γ</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">α</span> <span class="bp">→</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">γ</span><span class="o">)</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">×</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">γ</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">f</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span><span class="bp">.</span><span class="mi">1</span> <span class="n">x</span><span class="bp">.</span><span class="mi">2</span>
</pre></div>



<a name="129014848"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/129014848" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Guy Leroy <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#129014848">(Jul 03 2018 at 10:32)</a>:</h4>
<p>Thank you all for the detailed answers! Greatly appreciate it</p>



<a name="129015912"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/129015912" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#129015912">(Jul 03 2018 at 11:00)</a>:</h4>
<p><span class="user-mention" data-user-id="111947">@Guy Leroy</span> Everything is completely logical and you have a logical brain; I remember being confused about all of this a year ago. You came to my talk yesterday, right? <code>alpha -&gt; beta -&gt; gamma</code> is a type, and you make terms of that type using <code>lambda</code>. After the <code>lambda</code> you'd better take a term of type alpha and then a term of type beta, and then you need to return a term of type gamma. So now hopefully you can get your terms sorted out. For products however, you need to learn the notation. The type is <code>\alpha \times \beta</code> so now you need to know the constructor and the eliminators, which is a fancy way of saying that you need to know how to get something of type <code>alpha x beta</code> from <code>a : alpha</code> and <code>b : beta</code> (that's the constructor for the product) and then you also need to know how to get the things of type alpha and beta from the thing of type <code>alpha x beta</code> -- those are the eliminators. So that's three different pieces of notation -- one for making the product type (that's \times), one for the constructor (that's pointy brackets) and one for the elminators (that's the <code>.1</code> and <code>.2</code> notation). A year ago all of these were floating around in my head and I'd just try any of them until something worked. But now I realise that if you keep everything straight then it all starts fitting into place. The pointy brackets are often used for constructors, the dots are often used for eliminators (I hope they are called eliminators, I'm no expert) and the notation for the types depends on the type but is something you pick up as you go along.</p>



<a name="129015940"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/129015940" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#129015940">(Jul 03 2018 at 11:02)</a>:</h4>
<p>As for the stuff before or after the colon, I've realised that this trips mathematicians up. I need to write something about functions. There's so much functiony stuff which CS people do which is very cool but which we don't see in maths at all! Even using functions as maps from props to props is new to mathematicians.</p>



<a name="129016068"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/129016068" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#129016068">(Jul 03 2018 at 11:05)</a>:</h4>
<p>Actually <code>.1</code> is called a projection</p>



<a name="129016073"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/129016073" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#129016073">(Jul 03 2018 at 11:05)</a>:</h4>
<p>an eliminator is <code>prod.rec</code> for example</p>



<a name="129016118"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/129016118" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Guy Leroy <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#129016118">(Jul 03 2018 at 11:06)</a>:</h4>
<p>Thank you for the explanation. Yes I came yesterday. The syntax is slowly starting to make sense, I'm a bit confused at first as we were taught Haskell in first year and it has some similar features.</p>



<a name="129016126"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/129016126" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Guy Leroy <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#129016126">(Jul 03 2018 at 11:06)</a>:</h4>
<p>But I understand the curry/uncurry functions and their syntax now I think</p>



<a name="129016361"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/129016361" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#129016361">(Jul 03 2018 at 11:12)</a>:</h4>
<blockquote>
<p>an eliminator is <code>prod.rec</code> for example</p>
</blockquote>
<p>Technical interlude: are the projections defined using <code>prod.rec</code> or are they inbuilt and appear like axioms when the product type is defined? I don't know how to figure this out. I guess they would be easy to define using <code>prod.rec</code>.</p>



<a name="129016391"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/129016391" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#129016391">(Jul 03 2018 at 11:13)</a>:</h4>
<blockquote>
<p>But I understand the curry/uncurry functions and their syntax now I think</p>
</blockquote>
<p>When I did that exercise last year, the first thing I wanted to prove was that if you curried and then uncurried, you got back to where you started! But at that point in TPIL you don't have enough tools to do that.</p>



<a name="129016497"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/129016497" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#129016497">(Jul 03 2018 at 11:16)</a>:</h4>
<p>"The dot operator is how you access the members of an object" I think I once read in a book on Java. Is this not the appropriate language in Lean? It feels like the same sort of thing.</p>



<a name="129016598"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/129016598" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#129016598">(Jul 03 2018 at 11:19)</a>:</h4>
<p>It's a bit hard to tell just by looking at the definition, but projections are defined using the recursor/eliminator</p>



<a name="129016607"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/129016607" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sean Leather <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#129016607">(Jul 03 2018 at 11:20)</a>:</h4>
<p><a href="https://www.quora.com/In-type-theory-what-is-an-eliminator-and-what-is-its-opposite" target="_blank" title="https://www.quora.com/In-type-theory-what-is-an-eliminator-and-what-is-its-opposite">In type theory, what is an eliminator, and what is its opposite?</a></p>



<a name="129016667"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/129016667" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sean Leather <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#129016667">(Jul 03 2018 at 11:21)</a>:</h4>
<p>Conclusion: a projection is an eliminator.</p>



<a name="129016806"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/129016806" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#129016806">(Jul 03 2018 at 11:25)</a>:</h4>
<p>In lean, projections are a limited version of the <code>cases_on</code> eliminator</p>



<a name="129016815"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/129016815" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#129016815">(Jul 03 2018 at 11:25)</a>:</h4>
<p>They only work when the inductive only has one constructor (which is why they are only generated for <code>structure</code>s)</p>



<a name="129016862"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/129016862" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#129016862">(Jul 03 2018 at 11:26)</a>:</h4>
<p>and they are obviously nonrecursive (in programming languages with a fixpoint operator this is not as important as it is in lean)</p>



<a name="129017129"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/129017129" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#129017129">(Jul 03 2018 at 11:34)</a>:</h4>
<p>The projections are even harder to unfold than I remember... Even <code>#reduce</code> doesn't unfold them, I have to unfold first to the underlying projection macro (printed as <code>[prod.fst c]</code>), and then force that to expand through a <code>change</code>:</p>
<div class="codehilite"><pre><span></span>#print prod.fst
-- @[reducible]
-- def prod.fst : Π {α : Type u} {β : Type v}, prod α β → α :=
-- λ (α : Type u) (β : Type v) (c : prod α β), [prod.fst c]
example {α β} (a : α × β) : prod.fst.{0 0} a = sorry :=
begin
  delta prod.fst,
  change @prod.cases_on _ _ _ _ _ = _,
  -- prod.cases_on a (λ (fst : α) (snd : β), fst) = sorry
end
</pre></div>



<a name="129017389"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/129017389" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sean Leather <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#129017389">(Jul 03 2018 at 11:40)</a>:</h4>
<p>I tend to do <code>cases a, dsimp</code> while writing a proof, though I can usually remove the <code>dsimp</code> before I'm done.</p>



<a name="129033519"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/129033519" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#129033519">(Jul 03 2018 at 16:30)</a>:</h4>
<p>Rohan Mitta has just asked me how to formalise an exercise on the topological spaces example sheet: prove that if T1 and T2 are topologies on X (i.e. T1 and T2 are sets of subsets of X) then their intersection is a topology.</p>



<a name="129033547"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/129033547" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#129033547">(Jul 03 2018 at 16:31)</a>:</h4>
<p>this is in lean already</p>



<a name="129033550"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/129033550" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#129033550">(Jul 03 2018 at 16:31)</a>:</h4>
<p>That sounds like a question to me, but somehow when you formalise it in Lean it becomes more like a construction. I figured that he needed some predicate <code>is_open_sets</code> and I just glanced through the topological space lean file and didn't spot it</p>



<a name="129033562"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/129033562" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#129033562">(Jul 03 2018 at 16:31)</a>:</h4>
<p>I'm sure it's in Lean already, they form some complete semilattice or whatever</p>



<a name="129033572"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/129033572" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#129033572">(Jul 03 2018 at 16:31)</a>:</h4>
<p>it's part of the construction of the complete lattice</p>



<a name="129033578"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/129033578" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#129033578">(Jul 03 2018 at 16:31)</a>:</h4>
<p>I just saw that. But Rohan is trying to learn how to use Lean so I am happy to encourage him to figure this exercise out himself!</p>



<a name="129033592"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/129033592" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#129033592">(Jul 03 2018 at 16:32)</a>:</h4>
<p>It's in Lean but it doesn't look like a proposition, it looks like a construction</p>



<a name="129033642"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/129033642" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#129033642">(Jul 03 2018 at 16:32)</a>:</h4>
<p>Is <code>is_open_sets</code> in Lean? I couldn't find it</p>



<a name="129033644"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/129033644" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#129033644">(Jul 03 2018 at 16:32)</a>:</h4>
<p>it is a construction</p>



<a name="129033659"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/129033659" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#129033659">(Jul 03 2018 at 16:32)</a>:</h4>
<p>It looks like an exercise</p>



<a name="129033665"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/129033665" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#129033665">(Jul 03 2018 at 16:32)</a>:</h4>
<p>what does <code>is_open_sets</code> mean?</p>



<a name="129033700"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/129033700" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#129033700">(Jul 03 2018 at 16:33)</a>:</h4>
<p><code>is_open_sets</code> is a map from set (set X) to Prop and it's the conjunction of the axioms saying that the sets are the opens in a topology. Am I not thinking straight?</p>



<a name="129033765"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/129033765" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#129033765">(Jul 03 2018 at 16:34)</a>:</h4>
<p>And he wants to prove is_open_sets A and is_open_sets B implies is_open_sets (A intersect B)</p>



<a name="129033773"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/129033773" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#129033773">(Jul 03 2018 at 16:34)</a>:</h4>
<p>Am I making sense?</p>



<a name="129033890"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/129033890" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#129033890">(Jul 03 2018 at 16:36)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">definition</span> <span class="n">is_open_sets</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">is_open</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:=</span>
  <span class="n">is_open</span> <span class="n">univ</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">∀</span><span class="n">s</span> <span class="n">t</span><span class="o">,</span> <span class="n">is_open</span> <span class="n">s</span> <span class="bp">→</span> <span class="n">is_open</span> <span class="n">t</span> <span class="bp">→</span> <span class="n">is_open</span> <span class="o">(</span><span class="n">s</span> <span class="err">∩</span> <span class="n">t</span><span class="o">))</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">∀</span><span class="n">s</span><span class="o">,</span> <span class="o">(</span><span class="bp">∀</span><span class="n">t</span><span class="err">∈</span><span class="n">s</span><span class="o">,</span> <span class="n">is_open</span> <span class="n">t</span><span class="o">)</span> <span class="bp">→</span> <span class="n">is_open</span> <span class="o">(</span><span class="err">⋃₀</span> <span class="n">s</span><span class="o">))</span>
</pre></div>



<a name="129033894"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/129033894" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#129033894">(Jul 03 2018 at 16:36)</a>:</h4>
<p>I think it's that</p>



<a name="129034040"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/129034040" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#129034040">(Jul 03 2018 at 16:39)</a>:</h4>
<p>Now I can make the example sheet question into a proposition.</p>



<a name="129034141"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/129034141" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#129034141">(Jul 03 2018 at 16:40)</a>:</h4>
<p>Is this some equivalent way of formalising the notion of a topological space? Why did we choose the other way?</p>



<a name="129034388"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/129034388" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#129034388">(Jul 03 2018 at 16:45)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">definition</span> <span class="n">is_to_top</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">is_open</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">is_open_sets</span> <span class="o">(</span><span class="n">is_open</span><span class="o">))</span> <span class="o">:</span> <span class="n">topological_space</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">is_open</span> <span class="o">:=</span> <span class="n">is_open</span><span class="o">,</span>
  <span class="n">is_open_univ</span> <span class="o">:=</span> <span class="n">H</span><span class="bp">.</span><span class="n">left</span><span class="o">,</span>
  <span class="n">is_open_inter</span> <span class="o">:=</span> <span class="n">H</span><span class="bp">.</span><span class="n">right</span><span class="bp">.</span><span class="n">left</span><span class="o">,</span>
  <span class="n">is_open_sUnion</span> <span class="o">:=</span> <span class="n">H</span><span class="bp">.</span><span class="n">right</span><span class="bp">.</span><span class="n">right</span>
<span class="o">}</span>

<span class="kn">definition</span> <span class="n">top_to_is</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">T</span> <span class="o">:</span> <span class="n">topological_space</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">is_open_sets</span> <span class="o">(</span><span class="n">T</span><span class="bp">.</span><span class="n">is_open</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">⟨</span><span class="n">T</span><span class="bp">.</span><span class="n">is_open_univ</span><span class="o">,</span><span class="n">T</span><span class="bp">.</span><span class="n">is_open_inter</span><span class="o">,</span><span class="n">T</span><span class="bp">.</span><span class="n">is_open_sUnion</span><span class="bp">⟩</span>
</pre></div>



<a name="129034394"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/129034394" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#129034394">(Jul 03 2018 at 16:45)</a>:</h4>
<p>They're kind of the same</p>



<a name="129034413"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/129034413" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#129034413">(Jul 03 2018 at 16:45)</a>:</h4>
<p>yes, it is equivalent to unbundling the set (set A) part of topological_space</p>



<a name="129034414"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/129034414" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#129034414">(Jul 03 2018 at 16:45)</a>:</h4>
<p>The difference is just that the mathlib definition does not have the properties split off together into a separate structure/definition</p>



<a name="129035139"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/129035139" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#129035139">(Jul 03 2018 at 16:59)</a>:</h4>
<p>So what I find myself wondering again and again is what the best way is. A year ago there were plenty of things I could formalise in 0 ways; now I find there are plenty of things I can formalise in two ways, and I really struggle to know the right way. What I have now understood is that in some sense it doesn't matter, because if I write a good enough API then probably any one of my choices will be fine. But I am beginning to realise that there's more at stake than this.</p>



<a name="129035491"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/129035491" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#129035491">(Jul 03 2018 at 17:05)</a>:</h4>
<p>particularly in view of the complete lattice structure, the intersection theorem is only one part of bigger structure, and using it as such makes  sense of the whole finer/coarser thing in a more disciplined way</p>



<a name="129076394"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/129076394" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sjoerd de Vries <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#129076394">(Jul 04 2018 at 10:14)</a>:</h4>
<p>I really am a beginner, so forgive me if I sound incredibly stupid.<br>
I'm trying to define a function which can add vectors with entries in <code>ℕ</code>.<br>
I tried something like this:<br>
<code>namespace vectest
    universe u
    constant vec : Type u → ℕ → Type u
    def vec_add (n : ℕ) : vec (list ℕ) n → vec (list ℕ) n → vec (list ℕ) n := sorry
end vectest </code><br>
I don't see how I could specify the desired function like this - of course I intend my input to be a vector of length <code>n</code> with entries in <code>ℕ</code>, but Lean just sees (as far as I can tell) something of Type <code>list ℕ</code> which happens to depend on <code>n</code>. I can't really expect to be able to extract values from the list and add them, then put them back into a new list of length <code>n</code>, if Lean doesn't know that's what I'm talking about, right?</p>



<a name="129076676"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/129076676" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#129076676">(Jul 04 2018 at 10:21)</a>:</h4>
<p>Hi Sjoerd. I would generally discourage the use of <code>constant</code>. Is the idea that you want to model vectors of length <code>n</code> with entries in <code>nat</code>?</p>



<a name="129076678"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/129076678" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sjoerd de Vries <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#129076678">(Jul 04 2018 at 10:21)</a>:</h4>
<p>Yes, that's the idea.</p>



<a name="129076726"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/129076726" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#129076726">(Jul 04 2018 at 10:22)</a>:</h4>
<p>The best way to do that is a function <code>fin n → nat</code>. <code>fin n</code> is a type with <code>n</code> elements.</p>



<a name="129076959"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/129076959" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sjoerd de Vries <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#129076959">(Jul 04 2018 at 10:28)</a>:</h4>
<p>So I can think of <code>fin n</code> as being a discrete set with <code>n</code> elements and of vectors as functions. Is there a pre-defined way of adding functions that I can then use to add vectors? And how would I find out if this thing exists without asking any of you?</p>



<a name="129077522"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/129077522" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#129077522">(Jul 04 2018 at 10:45)</a>:</h4>
<p>I think it's not so hard to write these functions yourself and it would probably be a good exercise.</p>



<a name="129077578"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/129077578" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#129077578">(Jul 04 2018 at 10:46)</a>:</h4>
<p><code>algebra/pi_instances</code> contains all of these for <code>add</code>, <code>mul</code> etc</p>



<a name="129077664"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/129077664" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#129077664">(Jul 04 2018 at 10:48)</a>:</h4>
<p>Sjoerd -- feel free to send me a private message if you don't want to spam the chat. <code>fin n</code> is a type which has exactly <code>n</code> terms, which you can think of as 0,1,...,n-1.</p>



<a name="129077943"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/129077943" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#129077943">(Jul 04 2018 at 10:55)</a>:</h4>
<p>Defining <code>vector</code> as a function is quite unusual because of the resulting runtime complexity (which you may not be interested in). The common definitions are as an inductive type (<a href="https://github.com/leanprover/lean/blob/a4aae537fe771ee92d746d4a2be1e73c543e48b9/tests/lean/run/smt_ematch3.lean#L5-L7" target="_blank" title="https://github.com/leanprover/lean/blob/a4aae537fe771ee92d746d4a2be1e73c543e48b9/tests/lean/run/smt_ematch3.lean#L5-L7">e.g.</a>) or as a subtype of <code>list</code> (<a href="https://github.com/leanprover/lean/blob/master/library/data/vector.lean" target="_blank" title="https://github.com/leanprover/lean/blob/master/library/data/vector.lean"><code>data.vector</code></a>).</p>



<a name="129318433"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/129318433" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Zak <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#129318433">(Jul 08 2018 at 23:57)</a>:</h4>
<p>Hey, would anyone mind explaining how to prove <code>A ∨ B</code> given two propositions <code>A</code> and <code>B</code> and a proof of A?</p>



<a name="129318435"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/129318435" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Zak <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#129318435">(Jul 08 2018 at 23:57)</a>:</h4>
<p>I think the question looks a bit like this; </p>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">prove_or</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">proof_A</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">∨</span> <span class="n">B</span>
</pre></div>



<a name="129318792"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/129318792" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#129318792">(Jul 09 2018 at 00:10)</a>:</h4>
<p>You can prove it as:</p>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">prove_or</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">proof_A</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">∨</span> <span class="n">B</span> <span class="o">:=</span>
<span class="n">or</span><span class="bp">.</span><span class="n">inl</span> <span class="n">proof_A</span>
</pre></div>


<p>or </p>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">prove_or</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">proof_A</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">∨</span> <span class="n">B</span> <span class="o">:=</span>
<span class="k">by</span> <span class="o">{</span> <span class="n">left</span><span class="o">,</span> <span class="n">exact</span> <span class="n">proof_A</span> <span class="o">}</span>
</pre></div>



<a name="129318803"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/129318803" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Zak <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#129318803">(Jul 09 2018 at 00:11)</a>:</h4>
<p>Thank you :D <code>left</code> will be very useful</p>



<a name="129320318"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/129320318" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#129320318">(Jul 09 2018 at 01:11)</a>:</h4>
<p>Fun fact: <code>left</code> works with any inductive type. It applies the first constructor while <code>right</code> applies the second constructor.</p>



<a name="129329261"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/129329261" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#129329261">(Jul 09 2018 at 05:44)</a>:</h4>
<p><a href="https://leanprover.github.io/theorem_proving_in_lean/tactics.html#more-tactics" target="_blank" title="https://leanprover.github.io/theorem_proving_in_lean/tactics.html#more-tactics">https://leanprover.github.io/theorem_proving_in_lean/tactics.html#more-tactics</a></p>



<a name="129334456"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/129334456" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#129334456">(Jul 09 2018 at 08:06)</a>:</h4>
<p>I was mulling over <code>∨</code> as a result of this question, thinking how one could explain to a beginner how to work this out, and as a result I ran into something which I myself didn't understand. Is <code>∨</code> left associative or right associative? If you can't remember then I figured that one way of finding out was just checking for yourself:</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">P</span> <span class="n">Q</span> <span class="n">R</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="n">P</span> <span class="bp">∨</span> <span class="n">Q</span> <span class="bp">∨</span> <span class="n">R</span> <span class="bp">=</span> <span class="n">P</span> <span class="bp">∨</span> <span class="o">(</span><span class="n">Q</span> <span class="bp">∨</span> <span class="n">R</span><span class="o">)</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="kn">example</span> <span class="o">(</span><span class="n">P</span> <span class="n">Q</span> <span class="n">R</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="n">P</span> <span class="bp">∨</span> <span class="n">Q</span> <span class="bp">∨</span> <span class="n">R</span> <span class="bp">=</span> <span class="o">(</span><span class="n">P</span> <span class="bp">∨</span> <span class="n">Q</span><span class="o">)</span> <span class="bp">∨</span> <span class="n">R</span> <span class="o">:=</span> <span class="n">rfl</span>
</pre></div>


<p>I was expecting precisely one of these to work. But neither does! The first one (which is the right answer) gives the error</p>
<div class="codehilite"><pre><span></span>type mismatch, term
  rfl
has type
  ?m_2 = ?m_2
but is expected to have type
  P ∨ Q ∨ R = P ∨ Q ∨ R
</pre></div>



<a name="129334461"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/129334461" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#129334461">(Jul 09 2018 at 08:06)</a>:</h4>
<p>Why does <code>rfl</code> not prove that?</p>



<a name="129334482"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/129334482" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#129334482">(Jul 09 2018 at 08:07)</a>:</h4>
<p>because <code>=</code> is less important than <code>∨</code></p>



<a name="129334521"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/129334521" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#129334521">(Jul 09 2018 at 08:08)</a>:</h4>
<p>think about what a = b or c = d means</p>



<a name="129334533"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/129334533" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#129334533">(Jul 09 2018 at 08:09)</a>:</h4>
<p>(pp.all would have shown you the problem)</p>



<a name="129334550"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/129334550" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#129334550">(Jul 09 2018 at 08:10)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">P</span> <span class="n">Q</span> <span class="n">R</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">P</span> <span class="bp">∨</span> <span class="n">Q</span> <span class="bp">∨</span> <span class="n">R</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">P</span> <span class="bp">∨</span> <span class="o">(</span><span class="n">Q</span> <span class="bp">∨</span> <span class="n">R</span><span class="o">))</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="kn">example</span> <span class="o">(</span><span class="n">P</span> <span class="n">Q</span> <span class="n">R</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">P</span> <span class="bp">∨</span> <span class="n">Q</span> <span class="bp">∨</span> <span class="n">R</span><span class="o">)</span> <span class="bp">=</span> <span class="o">((</span><span class="n">P</span> <span class="bp">∨</span> <span class="n">Q</span><span class="o">)</span> <span class="bp">∨</span> <span class="n">R</span><span class="o">)</span> <span class="o">:=</span> <span class="n">rfl</span>
</pre></div>



<a name="129334753"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/129334753" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#129334753">(Jul 09 2018 at 08:14)</a>:</h4>
<p>Another beginner question: I would like to understand why <code>apply</code> is failing in the following example:</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">analysis</span><span class="bp">.</span><span class="n">real</span> <span class="n">order</span><span class="bp">.</span><span class="n">filter</span>
<span class="kn">open</span> <span class="n">filter</span>

<span class="kn">lemma</span> <span class="n">test</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">real</span><span class="o">)</span> <span class="o">:</span> <span class="n">tendsto</span> <span class="o">(</span><span class="bp">λ</span><span class="n">x</span><span class="o">,</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">nhds</span> <span class="n">c</span><span class="o">)</span> <span class="o">(</span><span class="n">nhds</span> <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="n">c</span><span class="o">))</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">apply</span> <span class="n">tendsto_mul</span><span class="o">,</span>   <span class="c1">-- this line fails</span>
  <span class="n">apply_instance</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">tendsto_const_nhds</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">tendsto_id</span>
<span class="kn">end</span>
</pre></div>


<p>I know how to work it out with <code>apply tendsto_mul _ _</code> or <code>refine tendsto_mul _ _</code> or a direct term proof, but with the above it fails with the error message</p>
<div class="codehilite"><pre><span></span>invalid apply tactic, failed to unify
  tendsto (λ (x : ℝ), a * x) (nhds c) (nhds (a * c))
with
  tendsto ?m_3 ?m_4 (nhds ?m_6) → tendsto ?m_7 ?m_4 (nhds ?m_8) → tendsto (λ (x : ?m_1), ?m_3 x * ?m_7 x) ?m_4 (nhds (?m_6 * ?m_8))
</pre></div>


<p>What I don't get is why this unification problem is hard. Any hint?</p>



<a name="129334812"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/129334812" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#129334812">(Jul 09 2018 at 08:16)</a>:</h4>
<p>This is higher order unification</p>



<a name="129334820"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/129334820" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#129334820">(Jul 09 2018 at 08:16)</a>:</h4>
<p>You want Lean to recognize a product of functions</p>



<a name="129334825"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/129334825" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#129334825">(Jul 09 2018 at 08:17)</a>:</h4>
<p>no that isn't it</p>



<a name="129334826"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/129334826" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#129334826">(Jul 09 2018 at 08:17)</a>:</h4>
<p>But it could be a product in many ways, in principle</p>



<a name="129334884"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/129334884" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#129334884">(Jul 09 2018 at 08:18)</a>:</h4>
<p>I suspect it's <code>apply</code> not knowing which term is the last thing</p>



<a name="129334905"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/129334905" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#129334905">(Jul 09 2018 at 08:19)</a>:</h4>
<p>Hum, it's weird that <code>apply tendsto_mul _ _</code> works</p>



<a name="129334982"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/129334982" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#129334982">(Jul 09 2018 at 08:20)</a>:</h4>
<p>note that <code>tendsto</code> is itself defined as a pi</p>



<a name="129334989"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/129334989" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#129334989">(Jul 09 2018 at 08:21)</a>:</h4>
<p>this has been known to confuse <code>apply</code> in the past</p>



<a name="129335071"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/129335071" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#129335071">(Jul 09 2018 at 08:23)</a>:</h4>
<blockquote>
<p>because <code>=</code> is less important than <code>∨</code></p>
</blockquote>
<p>How ironic that the reason the question came up was that the output of <code>#print notation ∨</code> was what inspired me to ask the question, so I already knew that <code>∨</code> was unimportant. Thanks Kenny. It's not the first time I've been done over by binding powers -- I get caught out by <code>∃</code> occasionally too.</p>



<a name="129335914"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/129335914" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#129335914">(Jul 09 2018 at 08:45)</a>:</h4>
<blockquote>
<p>note that <code>tendsto</code> is itself defined as a pi</p>
</blockquote>
<p>You mean <code>apply</code> unfolds the definition of <code>tendsto</code> all the way up to the filter inclusion, which is indeed a pi? And then I am not surprised it is confused. Is there a way to tell lean that is should never unfold by itself the definition of <code>tendsto</code>, to avoid the problem?</p>



<a name="129336027"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/129336027" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#129336027">(Jul 09 2018 at 08:48)</a>:</h4>
<p>these instructions are already in place</p>



<a name="129336028"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/129336028" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#129336028">(Jul 09 2018 at 08:48)</a>:</h4>
<p><code>apply</code> is not supposed to look that deep, but it does</p>



<a name="129336037"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/129336037" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#129336037">(Jul 09 2018 at 08:49)</a>:</h4>
<p>it will even look through <code>@[irreducible]</code> definitions, unlike almost anything else</p>



<a name="129336172"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/129336172" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#129336172">(Jul 09 2018 at 08:53)</a>:</h4>
<p>Yes, I can see that the definition of subset is protected... Do you know if this behavior of <code>apply</code>is by design, and for what reason? This is a real pain for what I would like to do.</p>



<a name="129336641"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/129336641" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#129336641">(Jul 09 2018 at 09:07)</a>:</h4>
<p>It's certainly a bug, but we've got to live with it until lean 4 comes around. It only concerns the calculation of how many underscores to insert, and only then in limited circumstances (I'm not sure Patrick was that far off the mark with the note about higher order unification)</p>



<a name="129336770"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/129336770" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#129336770">(Jul 09 2018 at 09:10)</a>:</h4>
<p>I think, after you unfold EVERYTHING, the tendsto becomes a bunch of pis applied to a metavariable (the unknown target topology set), which may unfold to still more pis but lean can't be sure</p>



<a name="129338353"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/129338353" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#129338353">(Jul 09 2018 at 09:49)</a>:</h4>
<p>Thanks for your explanations. Indeed, for proofs written by hand, adding some underscores is not a problem. </p>
<p>I wanted to try my hand at automation, adding <code>@[tendsto_rules]</code> before <code>tendsto</code> lemmas. With the aim that writing <code>applys [tendsto_rules]</code> would try to <code>apply</code>successively all the tagged rules, to prove convergence statements. Since <code>apply</code> does not work well in this context, I will have to find another exercise to learn tactics.</p>
<p>For fun, an even "better" example: in my example above, if you try to replace the line <code>exact tendsto_const_nhds</code> with <code>apply tendsto_const_nhds</code> it fails (while the unification looks even easier as there are no premises in <code>tendsto_const_nhds</code>), but it works with <code>apply @tendsto_const_nhds _ _ _ _ _</code> (I agree, it is only a matter of getting the right number of underscores :)</p>



<a name="129339844"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/129339844" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#129339844">(Jul 09 2018 at 10:20)</a>:</h4>
<p>You could write a tactic which is <code>apply</code> but which works the way you want it to ;-) I have no idea how hard that would be!</p>



<a name="129342154"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/129342154" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#129342154">(Jul 09 2018 at 11:09)</a>:</h4>
<p>It looks like <code>apply</code> is written in C, not Lean</p>



<a name="129343466"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/129343466" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#129343466">(Jul 09 2018 at 11:40)</a>:</h4>
<p>I probably speak C++ better than lean, but still I will rather find another exercise, this one is not for me!</p>



<a name="318018898"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/318018898" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomáš Jakl <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#318018898">(Dec 27 2022 at 00:25)</a>:</h4>
<p>I'm sure there's a simple way to use combine values of Prop and if-then-else statements. But I can't find it. What would you put in the place of <code>sorry</code> below? Thanks!</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">k</span> <span class="o">:</span> <span class="n">Nat</span> <span class="o">:=</span> <span class="mi">5</span>
<span class="kd">def</span> <span class="n">uni</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="n">Fin</span> <span class="n">k</span>

<span class="kd">def</span> <span class="n">em</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">→</span>  <span class="n">uni</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">n</span> <span class="bp">=&gt;</span>
  <span class="k">if</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="n">k</span> <span class="k">then</span> <span class="o">⟨</span> <span class="n">n</span> <span class="o">,</span> <span class="gr">sorry</span> <span class="o">⟩</span>
           <span class="k">else</span> <span class="o">⟨</span> <span class="n">k</span><span class="bp">-</span><span class="mi">1</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">⟩</span>
</code></pre></div>



<a name="318019215"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/318019215" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#318019215">(Dec 27 2022 at 00:30)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">em</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">→</span>  <span class="n">uni</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">n</span> <span class="bp">=&gt;</span>
  <span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="n">k</span> <span class="k">then</span> <span class="o">⟨</span> <span class="n">n</span> <span class="o">,</span> <span class="n">h</span> <span class="o">⟩</span>
           <span class="k">else</span> <span class="o">⟨</span> <span class="n">k</span><span class="bp">-</span><span class="mi">1</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">⟩</span>
</code></pre></div>



<a name="318135779"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/318135779" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#318135779">(Dec 27 2022 at 17:49)</a>:</h4>
<p>Krásný večer přeji!</p>



<a name="318578801"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/318578801" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomáš Jakl <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#318578801">(Dec 30 2022 at 12:47)</a>:</h4>
<p>Continuing with shockingly trivial questions. I'm trying to define the type of all (directed) graphs. From what I know from type theory, the type should be defined as <code>\sum a : Type, Graph a</code> where <code>Graph a</code> could be defined as follows:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">Graph</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">edge</span> <span class="o">:</span> <span class="n">a</span> <span class="n">x</span> <span class="n">a</span> <span class="bp">-&gt;</span> <span class="kt">Prop</span>
</code></pre></div>
<p>why is it that then</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">Graphs</span> <span class="o">:</span> <span class="kt">Type</span> <span class="mi">1</span> <span class="o">:=</span> <span class="bp">\</span><span class="n">sum</span> <span class="n">a</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">,</span> <span class="n">Graph</span> <span class="n">a</span>
</code></pre></div>
<p>gives me an error "expected token"?</p>
<p>Am I doing something fundamentally wrong or what am I not understanding? Thanks a lot for any pointers!</p>



<a name="318580258"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/318580258" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#318580258">(Dec 30 2022 at 12:55)</a>:</h4>
<p>Because you either have to use the pure ASCII identifier of the Sigma type or the actual unicode:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">Graph</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">edge</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">×</span> <span class="n">a</span> <span class="bp">-&gt;</span> <span class="kt">Prop</span>

<span class="kd">def</span> <span class="n">Graphs</span> <span class="o">:</span> <span class="kt">Type</span> <span class="mi">1</span> <span class="o">:=</span> <span class="bp">Σ</span> <span class="n">a</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">,</span> <span class="n">Graph</span> <span class="n">a</span>
</code></pre></div>
<p>or</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">Graphs</span> <span class="o">:</span> <span class="kt">Type</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">Sigma</span> <span class="k">fun</span> <span class="n">a</span> <span class="bp">=&gt;</span> <span class="n">Graph</span> <span class="n">a</span>
</code></pre></div>
<p>also note that there is no need to dive into type theory or anything here, you can also define it as a structure if you wish:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">Graphs</span> <span class="n">where</span>
  <span class="n">a</span> <span class="o">:</span> <span class="kt">Type</span>
  <span class="n">g</span> <span class="o">:</span> <span class="n">Graph</span> <span class="n">a</span>
</code></pre></div>



<a name="318589886"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/318589886" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomáš Jakl <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#318589886">(Dec 30 2022 at 13:48)</a>:</h4>
<p>Thanks for answering. Sorry for being sloppy, I did use unicode in the editor but not here. It turns out that I was using ∑ (i.e. <code>\sum</code>) instead of Σ (i.e. <code>\Sigma</code>) <span aria-label="man facepalming" class="emoji emoji-1f926-200d-2642" role="img" title="man facepalming">:man_facepalming:</span> No idea how come I missed that there's a distinction between the two in Lean...</p>
<p>(Although, it is a bit weird that <strong>sum</strong> types are not typeset with <code>\sum</code>...)</p>



<a name="318606451"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/318606451" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#318606451">(Dec 30 2022 at 15:18)</a>:</h4>
<p>As a mathematician I would say the converse -- it would have been a bit weird if mathematical <strong>sum</strong>s of real numbers were not typeset with <code>\sum</code>.</p>



<a name="318612995"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/318612995" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sabrina Jewson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#318612995">(Dec 30 2022 at 15:58)</a>:</h4>
<p>Is it possible to prove that <code>ℕ ≠ ℤ</code>?</p>



<a name="318613092"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/318613092" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#318613092">(Dec 30 2022 at 15:58)</a>:</h4>
<p>What do you mean by that?</p>



<a name="318613195"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/318613195" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sabrina Jewson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#318613195">(Dec 30 2022 at 15:59)</a>:</h4>
<p>Is it possible to fill in the <code>sorry</code> in this code?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">≠</span> <span class="n">ℤ</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>



<a name="318613404"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/318613404" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sabrina Jewson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#318613404">(Dec 30 2022 at 16:00)</a>:</h4>
<p>This question isn’t for any particular purpose, I just wondered if that’s a thing that can be done in Lean</p>



<a name="318613522"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/318613522" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#318613522">(Dec 30 2022 at 16:01)</a>:</h4>
<p><span class="user-mention silent" data-user-id="574896">Sabrina Jewson</span> <a href="#narrow/stream/113488-general/topic/Beginner.20Questions/near/318613195">said</a>:</p>
<blockquote>
<p>Is it possible to fill in the <code>sorry</code> in this code?</p>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">≠</span> <span class="n">ℤ</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div><br>
</p>
</blockquote>
<p>This is a good question that I, unfortunately, cannot answer.</p>



<a name="318613695"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/318613695" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#318613695">(Dec 30 2022 at 16:02)</a>:</h4>
<p>No, it's not possible.</p>



<a name="318613767"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/318613767" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#318613767">(Dec 30 2022 at 16:03)</a>:</h4>
<p>I was thinking about something different. You somehow identify <code>(1 : ℕ)</code> with <code>(1 : ℤ)</code> and <code>(2 : ℕ)</code> with <code>(2 : ℤ)</code> and so on and you want to show that there are elements of <code>ℤ</code> with no corresponding thing on the <code>ℕ</code> side.</p>



<a name="318613872"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/318613872" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#318613872">(Dec 30 2022 at 16:03)</a>:</h4>
<p>Which is not a claim about the sizes of the sets, but it speaks about a concrete embedding of natural numbers into integers.</p>



<a name="318614423"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/318614423" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#318614423">(Dec 30 2022 at 16:07)</a>:</h4>
<p>I was thinking about taking <code>N : set ℕ := λ n, true</code> and <code>Z : set ℤ := λ z, true</code> and then wanting to reason about <code>N</code> coerced to act like <code>set ℤ</code> instance.</p>



<a name="318614673"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/318614673" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sabrina Jewson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#318614673">(Dec 30 2022 at 16:08)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/113488-general/topic/Beginner.20Questions/near/318613695">said</a>:</p>
<blockquote>
<p>No, it's not possible.</p>
</blockquote>
<p>Interesting — more generally, for which types <code>T</code> and <code>U</code> is it impossible to prove that <code>T ≠ U</code>? I discovered that I can easily do it for <code>empty ≠ ℕ</code> using <code>not_nonempty_iff</code>, so is it just possible for the empty/nonempty distinction or are they more ways?</p>



<a name="318614939"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/318614939" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#318614939">(Dec 30 2022 at 16:10)</a>:</h4>
<p>I'd be first interested for which types <code>T</code> and <code>U</code> we can prove <code>T = U</code>. The identity relation is defined for all <code>Sort</code> levels, so it should a syntactically valid proposition.</p>



<a name="318615180"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/318615180" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#318615180">(Dec 30 2022 at 16:11)</a>:</h4>
<p><span class="user-mention silent" data-user-id="574896">Sabrina Jewson</span> <a href="#narrow/stream/113488-general/topic/Beginner.20Questions/near/318614673">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/113488-general/topic/Beginner.20Questions/near/318613695">said</a>:</p>
<blockquote>
<p>No, it's not possible.</p>
</blockquote>
<p>Interesting — more generally, for which types <code>T</code> and <code>U</code> is it impossible to prove that <code>T ≠ U</code>?</p>
</blockquote>
<p>The only way is to prove that T and U have different cardinalities</p>



<a name="318615306"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/318615306" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sabrina Jewson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#318615306">(Dec 30 2022 at 16:12)</a>:</h4>
<p>oh okay, that makes sense, let me try it</p>



<a name="318616455"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/318616455" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sabrina Jewson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#318616455">(Dec 30 2022 at 16:19)</a>:</h4>
<p>Okay got it working :D</p>



<a name="318616473"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/318616473" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sabrina Jewson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#318616473">(Dec 30 2022 at 16:19)</a>:</h4>
<p>Thanks for the advice, that’s very interesting</p>



<a name="318616602"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/318616602" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#318616602">(Dec 30 2022 at 16:20)</a>:</h4>
<p>Can you please show us what you proved?</p>



<a name="318616625"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/318616625" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#318616625">(Dec 30 2022 at 16:20)</a>:</h4>
<p>I want to learn what can be done with types.</p>



<a name="318616857"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/318616857" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sabrina Jewson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#318616857">(Dec 30 2022 at 16:21)</a>:</h4>
<p>I didn’t put effort into making my proof nice though, be warned :V</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">a</span>
<span class="bp">|</span> <span class="n">c1</span>
<span class="bp">|</span> <span class="n">c2</span>

<span class="kd">inductive</span> <span class="n">b</span>
<span class="bp">|</span> <span class="n">c1</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≠</span> <span class="n">b</span> <span class="o">:=</span> <span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">ha</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">a</span><span class="o">,</span> <span class="n">x</span> <span class="bp">≠</span> <span class="n">y</span><span class="o">,</span>
  <span class="k">from</span> <span class="o">⟨</span><span class="n">a.c1</span><span class="o">,</span> <span class="n">a.c2</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">e</span><span class="o">,</span> <span class="kd">begin</span> <span class="n">simp</span> <span class="n">at</span> <span class="n">e</span><span class="o">,</span> <span class="n">contradiction</span> <span class="kd">end</span><span class="o">⟩,</span>
  <span class="n">rw</span> <span class="n">h</span> <span class="n">at</span> <span class="n">ha</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">ha</span> <span class="k">with</span> <span class="n">x</span> <span class="n">ha</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">ha</span> <span class="k">with</span> <span class="n">y</span> <span class="n">ha</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">eq</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">y</span><span class="o">,</span>
  <span class="n">refl</span><span class="o">,</span>
  <span class="n">contradiction</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="318617029"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/318617029" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sabrina Jewson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#318617029">(Dec 30 2022 at 16:22)</a>:</h4>
<p>I prove first that <code>∃ x y : a, x ≠ y</code>, then substitute in <code>a</code> for <code>b</code>, then show that this is a contradiction (as all <code>b</code> values are equal)</p>



<a name="318617496"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/318617496" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#318617496">(Dec 30 2022 at 16:24)</a>:</h4>
<p>You could also prove this by showing that the cardinality of a is 2 and the cardinality of b is 1. In general this is the only technique to prove that types are unequal in lean because the cardinality model of Lean's type theory would have all types of a given cardinality being type synonyms for a fixed type; in that model Nat does equal Int, which is why it's not possible to prove that they're unequal in lean</p>



<a name="318617601"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/318617601" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#318617601">(Dec 30 2022 at 16:25)</a>:</h4>
<p>So <code>ℕ = ℤ</code> can be proved?</p>



<a name="318617629"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/318617629" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#318617629">(Dec 30 2022 at 16:25)</a>:</h4>
<p>No. It just can't be disproved.</p>



<a name="318617640"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/318617640" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#318617640">(Dec 30 2022 at 16:25)</a>:</h4>
<p>Good.</p>



<a name="318617673"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/318617673" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#318617673">(Dec 30 2022 at 16:26)</a>:</h4>
<p><span class="user-mention silent" data-user-id="417654">Martin Dvořák</span> <a href="#narrow/stream/113488-general/topic/Beginner.20Questions/near/318614939">said</a>:</p>
<blockquote>
<p>I'd be first interested for which types <code>T</code> and <code>U</code> we can prove <code>T = U</code>. The identity relation is defined for all <code>Sort</code> levels, so it should a syntactically valid proposition.</p>
</blockquote>
<p>..</p>



<a name="318617819"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/318617819" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#318617819">(Dec 30 2022 at 16:26)</a>:</h4>
<p>Trying to prove equality of types is "evil" in a precise sense. It's not the right question in Lean's type theory.</p>



<a name="318618612"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/318618612" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#318618612">(Dec 30 2022 at 16:31)</a>:</h4>
<p><span class="user-mention silent" data-user-id="574896">Sabrina Jewson</span> <a href="#narrow/stream/113488-general/topic/Beginner.20Questions/near/318616857">said</a>:</p>
<blockquote>
<p>I didn’t put effort into making my proof nice though, be warned :V</p>
</blockquote>
<p>I know that nobody asked and nobody cares, but this is my refactor of your proof:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≠</span> <span class="n">b</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">ha</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">a</span><span class="o">,</span> <span class="n">x</span> <span class="bp">≠</span> <span class="n">y</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">use</span> <span class="n">a.c1</span><span class="o">,</span> <span class="n">use</span> <span class="n">a.c2</span><span class="o">,</span> <span class="o">},</span>
  <span class="n">rw</span> <span class="n">h</span> <span class="n">at</span> <span class="n">ha</span><span class="o">,</span>
  <span class="n">rcases</span> <span class="n">ha</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="n">neq</span><span class="o">⟩,</span>
  <span class="n">cases</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">y</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">neq</span> <span class="n">rfl</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="318618811"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/318618811" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#318618811">(Dec 30 2022 at 16:32)</a>:</h4>
<p>You taught me a new thing — equality between types can be used in <code>rw</code>.</p>



<a name="318618931"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/318618931" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#318618931">(Dec 30 2022 at 16:33)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113488-general/topic/Beginner.20Questions/near/318617819">said</a>:</p>
<blockquote>
<p>Trying to prove equality of types is "evil" in a precise sense. It's not the right question in Lean's type theory.</p>
</blockquote>
<p>Can someone tell us more than "don't do it" please?</p>



<a name="318619410"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/318619410" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#318619410">(Dec 30 2022 at 16:36)</a>:</h4>
<p>You can prove equalities of types in roughly three scenarios:</p>
<ul>
<li>The types are definitionally equal, i.e. if <code>def foo := nat</code> then <code>foo</code> and <code>nat</code> are provably equal.</li>
<li>The types are built from the same inductive families applied to equal arguments, for example <code>fin (a + b)</code>  and <code>fin (b + a)</code> are equal because <code>a + b = b + a</code> and <code>fin</code> is a function (a type function, but a function nonetheless)</li>
<li>There is a coincidence of different indices of an inductive family being equal because of cardinality considerations (roughly: cantor's theorem). That is, if you have an inductive family <code>inductive foo : set Type -&gt; Type</code> then it can't be injective because no such function can be.</li>
</ul>



<a name="318637989"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/318637989" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#318637989">(Dec 30 2022 at 18:42)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">@[derive fintype]</span>
<span class="kd">inductive</span> <span class="n">a</span>
<span class="bp">|</span> <span class="n">c1</span>
<span class="bp">|</span> <span class="n">c2</span>

<span class="kd">@[derive fintype]</span>
<span class="kd">inductive</span> <span class="n">b</span>
<span class="bp">|</span> <span class="n">c1</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≠</span> <span class="n">b</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span>
  <span class="kd">by</span> <span class="n">obtain</span> <span class="o">⟨⟩</span> <span class="o">:</span> <span class="n">fintype.card</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">fintype.card</span> <span class="n">b</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">h</span><span class="o">]</span>
</code></pre></div>



<a name="318638107"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/318638107" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#318638107">(Dec 30 2022 at 18:43)</a>:</h4>
<p>I think this can be golfed, but I can't get rid of the <code>simp only</code> because the rewrite isn't type-correct.</p>



<a name="318643000"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/318643000" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#318643000">(Dec 30 2022 at 19:20)</a>:</h4>
<p>Golfing your proof using mathlib <code>rcases</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">inductive</span> <span class="n">a</span>
<span class="bp">|</span> <span class="n">c1</span>
<span class="bp">|</span> <span class="n">c2</span>

<span class="kd">inductive</span> <span class="n">b</span>
<span class="bp">|</span> <span class="n">c1</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≠</span> <span class="n">b</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">hab</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">h</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">a</span><span class="o">,</span> <span class="n">x</span> <span class="bp">≠</span> <span class="n">y</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">a.c1</span><span class="o">,</span> <span class="n">a.c2</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">m</span><span class="o">,</span> <span class="n">a.no_confusion</span> <span class="n">m</span><span class="o">⟩,</span>
  <span class="n">rw</span> <span class="n">hab</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">rcases</span> <span class="n">h</span> <span class="k">with</span> <span class="o">⟨⟨⟩,</span> <span class="o">⟨⟩,</span> <span class="n">h</span><span class="o">⟩,</span>
  <span class="n">exact</span> <span class="n">h</span> <span class="n">rfl</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="318643565"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/318643565" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#318643565">(Dec 30 2022 at 19:24)</a>:</h4>
<p>Lean 4 has <code>rcases</code> in <code>Std</code> so you don't need to use mathlib to have access to it:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">Std.Tactic.RCases</span>

<span class="kd">inductive</span> <span class="n">a</span>
<span class="bp">|</span> <span class="n">c1</span>
<span class="bp">|</span> <span class="n">c2</span>

<span class="kd">inductive</span> <span class="n">b</span>
<span class="bp">|</span> <span class="n">c1</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≠</span> <span class="n">b</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">intro</span> <span class="n">hab</span>
  <span class="k">have</span> <span class="n">h</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">a</span><span class="o">,</span> <span class="n">x</span> <span class="bp">≠</span> <span class="n">y</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">a.c1</span><span class="o">,</span> <span class="n">a.c2</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">m</span> <span class="bp">=&gt;</span> <span class="n">a.noConfusion</span> <span class="n">m</span><span class="o">⟩</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">hab</span><span class="o">]</span> <span class="n">at</span> <span class="n">h</span>
  <span class="n">rcases</span> <span class="n">h</span> <span class="k">with</span> <span class="o">⟨⟨⟩,</span> <span class="o">⟨⟩,</span> <span class="n">h</span><span class="o">⟩</span>
  <span class="n">exact</span> <span class="n">h</span> <span class="n">rfl</span>
</code></pre></div>



<a name="318668585"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/318668585" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#318668585">(Dec 30 2022 at 23:40)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113488-general/topic/Beginner.20Questions/near/318617819">said</a>:</p>
<blockquote>
<p>Trying to prove equality of types is "evil" in a precise sense. It's not the right question in Lean's type theory.</p>
</blockquote>
<p>Note that it can be interesting to prove equality of types (or lemmas that let you rewrite one type into the other) When writing functions though. For example when we are operating on length indexed lists and there is two different arithmetic expression in the length index of two lists and we would like to say zip it with a function of type <code>List a n -&gt; List b n -&gt; List (Prod a b) n</code> it can be interesting to prove that the types of the two lists are in fact equal by showing that the two arithmetic expressions in their indices match up.</p>



<a name="318676372"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/318676372" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#318676372">(Dec 31 2022 at 01:26)</a>:</h4>
<p>Precisely this sort of problem, when the two <code>n</code>s aren't definitionally equal, was a genuine issue with category theory in LTE. We have had to develop tools such as <code>eq_to_hom</code> and <code>eq_to_iso</code> to manage the stuck <code>eq.rec</code> terms.</p>



<a name="318676389"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/318676389" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#318676389">(Dec 31 2022 at 01:26)</a>:</h4>
<p>I proved they weren't equal in term mode in Lean 4:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">a</span>
<span class="bp">|</span> <span class="n">c1</span>
<span class="bp">|</span> <span class="n">c2</span>

<span class="kd">inductive</span> <span class="n">b</span>
<span class="bp">|</span> <span class="n">c1</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≠</span> <span class="n">b</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="o">(</span><span class="n">hab</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span><span class="o">)</span> <span class="bp">=&gt;</span>
  <span class="k">have</span> <span class="n">h</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">xₐ</span> <span class="n">yₐ</span> <span class="o">:</span> <span class="n">a</span><span class="o">,</span> <span class="n">xₐ</span> <span class="bp">≠</span> <span class="n">yₐ</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">a.c1</span><span class="o">,</span> <span class="n">a.c2</span><span class="o">,</span> <span class="n">a.noConfusion</span><span class="o">⟩</span>
  <span class="k">have</span> <span class="n">hb</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">x'</span> <span class="n">y'</span> <span class="o">:</span> <span class="n">b</span><span class="o">,</span> <span class="n">x'</span> <span class="bp">≠</span> <span class="n">y'</span> <span class="o">:=</span> <span class="n">hab</span> <span class="bp">▸</span> <span class="n">h</span>
  <span class="n">hb.casesOn</span> <span class="bp">λ</span> <span class="o">⟨⟩</span> <span class="o">⟨⟨⟩,</span> <span class="n">hxy</span><span class="o">⟩</span> <span class="bp">=&gt;</span> <span class="n">hxy</span> <span class="n">rfl</span>
</code></pre></div>



<a name="318681080"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/318681080" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Trebor Huang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#318681080">(Dec 31 2022 at 02:46)</a>:</h4>
<p>The equality in Lean is "underspecified", i.e. we don't determine everything with the current rules and axioms. A few ways to specify that are</p>
<ul>
<li>Add the ability to pattern match on types, which gives us a no-confusion thing. This sort of makes the universe an inductive type.</li>
<li>Univalence.</li>
<li>Something in the style of observational type theory. This sort of makes the universe a coinductive type.</li>
</ul>



<a name="318681324"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/318681324" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Trebor Huang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#318681324">(Dec 31 2022 at 02:50)</a>:</h4>
<p>A quick way to see if something cannot be proved in Lean, is to look at these three possibilities. If they disagree then the proposition can't be proved or disproved. (For the N=Z thing, the result is "false, true, depends", so you know you can't prove or disprove it)</p>



<a name="318755617"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/318755617" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sabrina Jewson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#318755617">(Dec 31 2022 at 15:51)</a>:</h4>
<p>I would like function of this form:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">finmap.map_keys</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span> <span class="n">γ</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">β</span><span class="o">]</span>
  <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">finmap</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">γ</span><span class="o">))</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">f_inj</span> <span class="o">:</span> <span class="n">function.injective</span> <span class="n">f</span><span class="o">)</span>
  <span class="o">:</span> <span class="n">finmap</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span> <span class="o">:</span> <span class="n">β</span><span class="o">,</span> <span class="n">γ</span><span class="o">)</span>
</code></pre></div>
<p>I spent a while trying to implement it myself and ended up with around 50 lines of code:</p>
<div class="spoiler-block"><div class="spoiler-header">
<p>Lots of code…</p>
</div><div class="spoiler-content" aria-hidden="true">
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="n">γ</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>

<span class="kd">def</span> <span class="n">list.map_keys</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="bp">Σ</span> <span class="n">_</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">γ</span><span class="o">)</span> <span class="bp">→</span> <span class="n">list</span> <span class="o">(</span><span class="bp">Σ</span> <span class="n">_</span> <span class="o">:</span> <span class="n">β</span><span class="o">,</span> <span class="n">γ</span><span class="o">)</span>
  <span class="o">:=</span> <span class="bp">@</span><span class="n">list.map</span> <span class="o">(</span><span class="bp">Σ</span> <span class="n">_</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">γ</span><span class="o">)</span> <span class="o">(</span><span class="bp">Σ</span> <span class="n">_</span> <span class="o">:</span> <span class="n">β</span><span class="o">,</span> <span class="n">γ</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">pair</span><span class="o">,</span> <span class="n">sigma.mk</span> <span class="o">(</span><span class="n">f</span> <span class="n">pair.fst</span><span class="o">)</span> <span class="n">pair.snd</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">list.map_keys_cons</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">}</span> <span class="o">{</span><span class="n">hd</span> <span class="o">:</span> <span class="bp">Σ</span> <span class="n">_</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">γ</span><span class="o">}</span> <span class="o">{</span><span class="n">tl</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="bp">Σ</span> <span class="n">_</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">γ</span><span class="o">)}</span>
  <span class="o">:</span> <span class="n">list.map_keys</span> <span class="n">f</span> <span class="o">(</span><span class="n">hd</span> <span class="o">::</span> <span class="n">tl</span><span class="o">)</span> <span class="bp">=</span> <span class="n">sigma.mk</span> <span class="o">(</span><span class="n">f</span> <span class="n">hd.fst</span><span class="o">)</span> <span class="n">hd.snd</span> <span class="o">::</span> <span class="n">list.map_keys</span> <span class="n">f</span> <span class="n">tl</span>
<span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">def</span> <span class="n">finmap.map_keys</span>
  <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">β</span><span class="o">]</span>
  <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">finmap</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">γ</span><span class="o">))</span>
  <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span>
  <span class="o">(</span><span class="n">f_inj</span> <span class="o">:</span> <span class="n">function.injective</span> <span class="n">f</span><span class="o">)</span>
  <span class="o">:</span> <span class="n">finmap</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span> <span class="o">:</span> <span class="n">β</span><span class="o">,</span> <span class="n">γ</span><span class="o">)</span>
<span class="o">:=</span> <span class="n">m.lift_on</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">m</span><span class="o">,</span> <span class="o">(</span><span class="n">m.entries.map_keys</span> <span class="n">f</span><span class="o">)</span><span class="bp">.</span><span class="n">to_finmap</span><span class="o">)</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">perm</span><span class="o">,</span> <span class="kd">begin</span>
    <span class="n">cases</span> <span class="n">a</span> <span class="k">with</span> <span class="n">a_entries</span> <span class="n">a_nodupkeys</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">b</span> <span class="k">with</span> <span class="n">b_entries</span> <span class="n">b_nodupkeys</span><span class="o">,</span>
    <span class="n">dsimp</span><span class="o">,</span>
    <span class="n">dsimp</span> <span class="n">at</span> <span class="n">perm</span><span class="o">,</span>
    <span class="n">induction</span> <span class="n">perm</span> <span class="k">with</span>
        <span class="n">head</span> <span class="n">l₁</span> <span class="n">l₂</span> <span class="n">l₁_perm_l₂</span> <span class="n">perm_ih</span>
        <span class="n">x</span> <span class="n">y</span> <span class="n">tail</span>
        <span class="n">l₁</span> <span class="n">l₂</span> <span class="n">l₃</span> <span class="n">l₁_perm_l₂</span> <span class="n">l₂_perm_l₃</span> <span class="n">perm_ih₁</span> <span class="n">perm_ih₂</span>
    <span class="o">,</span>
    <span class="o">{</span> <span class="n">refl</span><span class="o">,</span> <span class="o">},</span>
    <span class="o">{</span>
      <span class="n">rw</span> <span class="o">[</span><span class="n">list.map_keys_cons</span><span class="o">,</span> <span class="n">list.map_keys_cons</span><span class="o">,</span> <span class="n">finmap.to_finmap_cons</span><span class="o">,</span> <span class="n">finmap.to_finmap_cons</span><span class="o">],</span>
      <span class="n">rw</span> <span class="n">perm_ih</span> <span class="o">(</span><span class="n">list.nodupkeys_cons.mp</span> <span class="n">a_nodupkeys</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span> <span class="o">(</span><span class="n">list.nodupkeys_cons.mp</span> <span class="n">b_nodupkeys</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span><span class="o">,</span>
    <span class="o">},</span>
    <span class="o">{</span>
      <span class="n">repeat</span> <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">list.map_keys_cons</span><span class="o">,</span> <span class="n">finmap.to_finmap_cons</span><span class="o">],</span> <span class="o">},</span>
      <span class="n">apply</span> <span class="n">finmap.insert_insert_of_ne</span><span class="o">,</span>
      <span class="n">simp</span> <span class="n">at</span> <span class="n">a_nodupkeys</span><span class="o">,</span>
      <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">a_nodupkeys.left</span> <span class="o">(</span><span class="n">or.inl</span> <span class="o">(</span><span class="n">f_inj</span> <span class="n">h</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="o">),</span>
    <span class="o">},</span>
    <span class="o">{</span>
      <span class="k">have</span> <span class="n">l₂_nodupkeys</span><span class="o">,</span> <span class="k">from</span> <span class="o">(</span><span class="n">list.perm_nodupkeys</span> <span class="n">l₁_perm_l₂</span><span class="o">)</span><span class="bp">.</span><span class="n">mp</span> <span class="n">a_nodupkeys</span><span class="o">,</span>
      <span class="n">rw</span> <span class="o">[</span><span class="n">perm_ih₁</span> <span class="n">a_nodupkeys</span> <span class="n">l₂_nodupkeys</span><span class="o">,</span> <span class="n">perm_ih₂</span> <span class="n">l₂_nodupkeys</span> <span class="n">b_nodupkeys</span><span class="o">],</span>
    <span class="o">}</span>
  <span class="kd">end</span><span class="o">)</span>
</code></pre></div>
</div></div>
<p>It’s unfortunately quite a lot — is there any way to shorten this? Is there a really useful method in mathlib that I’m missing?</p>



<a name="318756874"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/318756874" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#318756874">(Dec 31 2022 at 15:59)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113488-general/topic/Beginner.20Questions/near/318676372">said</a>:</p>
<blockquote>
<p>Precisely this sort of problem, when the two <code>n</code>s aren't definitionally equal, was a genuine issue with category theory in LTE. We have had to develop tools such as <code>eq_to_hom</code> and <code>eq_to_iso</code> to manage the stuck <code>eq.rec</code> terms.</p>
</blockquote>
<p>In graph theory, we don't have the luxury of identity morphisms, so we instead had to develop tools like <a href="https://leanprover-community.github.io/mathlib_docs/find/simple_graph.walk.copy">docs#simple_graph.walk.copy</a></p>
<p>This was recently added to category theory as <a href="https://leanprover-community.github.io/mathlib_docs/find/quiver.hom.cast">docs#quiver.hom.cast</a> for work on quivers, which can't in general just use <a href="https://leanprover-community.github.io/mathlib_docs/find/category_theory.eq_to_hom">docs#category_theory.eq_to_hom</a></p>



<a name="318757220"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/318757220" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#318757220">(Dec 31 2022 at 16:02)</a>:</h4>
<p>It seems to be a good dependent types design pattern to write a custom <code>eq.rec</code> that's specifically for rewriting indices in type constructors, to "cast" terms of the type to terms of an equal type in a more controlled way. For example, having a <code>cast</code> function to rewrite the length of a length-indexed list types.</p>



<a name="318783649"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/318783649" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tyler Josephson ⚛️ <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#318783649">(Dec 31 2022 at 21:26)</a>:</h4>
<p>Informally, I might try to prove that <code>ℕ ≠ ℤ</code> by observing that <code>-1 ∈ ℤ</code> and that <code>-1 ∉ ℕ</code>. Is this not a correct proof / is this not possible in Lean?</p>



<a name="318786525"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/318786525" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#318786525">(Dec 31 2022 at 22:09)</a>:</h4>
<p>That's just a syntax error in lean: for <code>a \mem b</code> to typecjeck b must be a term of type <code>set something</code></p>



<a name="318787529"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/318787529" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#318787529">(Dec 31 2022 at 22:23)</a>:</h4>
<p>You could interpret this as showing <code>set.Ici (0 : ℤ) ≠ set.univ</code>, but that certainly isn't showing <code>ℕ ≠ ℤ</code>.</p>



<a name="318912066"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/318912066" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Niels Voss <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#318912066">(Jan 01 2023 at 22:30)</a>:</h4>
<p>I spent an embarrassingly long time trying to prove that <code>ℕ ≠ ℤ</code> and I now think that it is unlikely that such a proof is possible in Lean. Here's why I think that:<br>
Natural numbers and integers have the same cardinality, so there is some bijection <code>nat_to_int</code> between them. We choose such a bijection (preferably one where <code>nat_to_int (0 : ℕ) = (0 : ℤ)</code>). We can now define the <code>ℤ</code> equivalent of <code>nat.succ</code> by converting from int to nat, adding 1, then converting back. I call this new function <code>new_succ</code>. It has type <code>ℤ -&gt; ℤ</code>.<br>
An important fact about natural numbers is that every natural number is expressible as <code>nat.succ</code> applied some amount of times to <code>nat.zero</code>. Now with our new function, every integer is expressible as <code>new_succ</code> applied some amount of times to <code>(0 : ℤ)</code>. I can prove this by showing that the recursor for natural numbers also holds true for integers:</p>
<div class="spoiler-block"><div class="spoiler-header">
<p>Lots of code</p>
</div><div class="spoiler-content" aria-hidden="true">
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">set_theory.cardinal.basic</span>

<span class="kd">universe</span> <span class="n">u</span>

<span class="kd">def</span> <span class="n">cardinality_equal</span> <span class="o">:</span> <span class="n">cardinal.mk</span> <span class="n">ℕ</span> <span class="bp">=</span> <span class="n">cardinal.mk</span> <span class="n">ℤ</span> <span class="o">:=</span>
<span class="n">eq.trans</span> <span class="n">cardinal.mk_nat</span> <span class="n">cardinal.mk_int.symm</span>
<span class="kd">def</span> <span class="n">nat_to_int_conversion_exists</span> <span class="o">:</span> <span class="n">nonempty</span> <span class="o">(</span><span class="n">ℕ</span> <span class="bp">≃</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">:=</span> <span class="n">quotient.exact</span> <span class="n">cardinality_equal</span>
<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">nat_to_int_conversion</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">≃</span> <span class="n">ℤ</span> <span class="o">:=</span> <span class="n">classical.choice</span> <span class="n">nat_to_int_conversion_exists</span>

<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">nat_to_int</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℤ</span> <span class="o">:=</span> <span class="n">nat_to_int_conversion.to_fun</span>
<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">int_to_nat</span> <span class="o">:</span> <span class="n">ℤ</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="n">nat_to_int_conversion.inv_fun</span>
<span class="kd">theorem</span> <span class="n">nat_to_int_left_inv</span> <span class="o">:</span> <span class="n">function.left_inverse</span> <span class="n">int_to_nat</span> <span class="n">nat_to_int</span> <span class="o">:=</span>
<span class="n">nat_to_int_conversion.left_inv</span>
<span class="kd">theorem</span> <span class="n">nat_to_int_right_inv</span> <span class="o">:</span> <span class="n">function.right_inverse</span> <span class="n">int_to_nat</span> <span class="n">nat_to_int</span> <span class="o">:=</span>
<span class="n">nat_to_int_conversion.right_inv</span>

<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">new_succ</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">:=</span> <span class="n">nat_to_int</span> <span class="o">((</span><span class="n">int_to_nat</span> <span class="n">n</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>

<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">int.new_rec</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">motive</span> <span class="o">:</span> <span class="n">ℤ</span> <span class="bp">→</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">},</span> <span class="n">motive</span> <span class="o">(</span><span class="n">nat_to_int</span> <span class="mi">0</span><span class="o">)</span> <span class="bp">→</span>
  <span class="o">(</span><span class="bp">Π</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">),</span> <span class="n">motive</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">motive</span> <span class="o">(</span><span class="n">new_succ</span> <span class="n">n</span><span class="o">))</span> <span class="bp">→</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">),</span> <span class="n">motive</span> <span class="n">n</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intros</span> <span class="n">motive</span> <span class="n">base_case</span> <span class="n">ind_case</span> <span class="n">n</span><span class="o">,</span>
  <span class="n">set</span> <span class="n">motive'</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Sort</span> <span class="n">u</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span> <span class="n">motive</span> <span class="o">(</span><span class="n">nat_to_int</span> <span class="n">x</span><span class="o">)</span> <span class="k">with</span> <span class="n">hmot</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">base_case'</span> <span class="o">:</span> <span class="n">motive'</span> <span class="mi">0</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">rw</span> <span class="n">hmot</span><span class="o">,</span> <span class="n">exact</span> <span class="n">base_case</span> <span class="o">},</span>
  <span class="k">have</span> <span class="n">ind_case'</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">motive'</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">motive'</span> <span class="n">n.succ</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="n">intros</span> <span class="n">k</span> <span class="n">prev_step</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">hmot</span> <span class="n">at</span> <span class="bp">⊢</span> <span class="n">prev_step</span><span class="o">,</span>
    <span class="n">specialize</span> <span class="n">ind_case</span> <span class="o">(</span><span class="n">nat_to_int</span> <span class="n">k</span><span class="o">)</span> <span class="n">prev_step</span><span class="o">,</span>
    <span class="n">unfold</span> <span class="n">new_succ</span> <span class="n">at</span> <span class="n">ind_case</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">nat_to_int_left_inv</span> <span class="n">k</span> <span class="n">at</span> <span class="n">ind_case</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">ind_case</span><span class="o">,</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">nat.rec</span> <span class="n">motive'</span> <span class="n">base_case'</span> <span class="n">ind_case'</span> <span class="o">(</span><span class="n">int_to_nat</span> <span class="n">n</span><span class="o">),</span>
  <span class="n">rw</span> <span class="n">hmot</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">nat_to_int_right_inv</span> <span class="n">n</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">this</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
</div></div>
<p>Note how <code>int.new_rec</code> basically has the same type as <code>nat.rec</code>, except we have <code>int</code> instead of <code>nat</code> and <code>new_succ</code> instead of <code>nat.succ</code>. We also have <code>nat_to_int 0</code> instead of <code>0</code> but it would be <code>(0 : ℤ)</code> if I chose a more convenient bijection. Since every proof about natural numbers essentially boils down to a bunch of <code>nat.zero</code>, <code>nat.succ</code>, and <code>nat.rec</code> calls, any proof about the natural numbers can be translated to a proof about the integers simply by replacing all instances of <code>nat.succ</code> with <code>new_succ</code>, etc. (well, at least I think it can, I don't know if it has the same definitional equalities).</p>
<p>Since every proof about natural numbers can be translated to an equivalent proof about integers, there's no way to prove <code>ℕ ≠ ℤ</code> because then that proof could be translated to <code>ℤ ≠ ℤ</code> by doing the substitution described above.</p>
<p>I'm not entirely sure if my argument is sound, but it made sense in my head at least.</p>



<a name="318913817"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/318913817" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ruben Van de Velde <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#318913817">(Jan 01 2023 at 22:56)</a>:</h4>
<p>You could have believed Reid :)</p>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/113488-general/topic/Beginner.20Questions/near/318613695">said</a>:</p>
<blockquote>
<p>No, it's not possible.</p>
</blockquote>



<a name="318913888"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/318913888" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Niels Voss <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#318913888">(Jan 01 2023 at 22:57)</a>:</h4>
<p>I figured as much, I just wanted to see if I could justify why to myself</p>



<a name="318915981"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/318915981" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Stevens <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#318915981">(Jan 01 2023 at 23:35)</a>:</h4>
<p>I'm not sure your argument is sound. If your argument is correct, wouldn't it <em>prove</em> that $\mathbb{Z} = \mathbb{N}$, by translating one side of the true statement $\mathbb{N} = \mathbb{N}$?</p>



<a name="318917095"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Beginner%20Questions/near/318917095" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Niels Voss <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Beginner.20Questions.html#318917095">(Jan 01 2023 at 23:57)</a>:</h4>
<p>No, because there's no way in Lean to make a function that takes some arbitrary proof and substitutes all instances of <code>nat.succ</code> with <code>new_succ</code>, etc. The rules of Lean don't really allow it, and the closest would could get is a tactic. My argument is necessarily meta-theoretic. Assuming I didn't make a mistake in my reasoning, it would only prove that equality of types is independent of the axioms, and neither prove nor disprove it.<br>
On the other hand, I'm not entirely sure my argument is watertight either because I don't really have a great understanding of type theory and there might be some detail I missed that would make it impossible to translate all proofs (something like the computation rule not getting translated).</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
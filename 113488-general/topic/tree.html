---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/tree.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/tree.html">tree</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="312969534"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tree/near/312969534" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kind Bubble <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/tree.html#312969534">(Nov 30 2022 at 01:12)</a>:</h4>
<p>Where can I find the Lean 4 documentation for trees?</p>



<a name="312980608"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tree/near/312980608" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/tree.html#312980608">(Nov 30 2022 at 03:44)</a>:</h4>
<p>There are so many ways to define a tree both in math and in code.  You need to provide more information about what you are looking for.  First, is this for programming or theorem proving?  If programming, what kind of trees and why do you think there would be a standard library for trees.  Most languages don’t have trees or graphs in their std library.  If for theorem proving, most of that hasn’t been ported yet to lean 4, but the same questions remain: what kind of trees and for what use case?  I bet there is some work in various types of trees in mathlib for lean 3 which you can browse.</p>



<a name="312980916"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tree/near/312980916" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/tree.html#312980916">(Nov 30 2022 at 03:48)</a>:</h4>
<p>(deleted)</p>



<a name="312980917"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tree/near/312980917" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/tree.html#312980917">(Nov 30 2022 at 03:48)</a>:</h4>
<p>Well, we have <a href="https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.RBTree#doc">docs4#Lean.RBTree</a></p>



<a name="312981472"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tree/near/312981472" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/tree.html#312981472">(Nov 30 2022 at 03:55)</a>:</h4>
<p>In lean 3, I found <a href="https://leanprover-community.github.io/mathlib_docs/find/tree">docs#tree</a> and <a href="https://leanprover-community.github.io/mathlib_docs/find/bin_tree">docs#bin_tree</a> which are both definitions of binary trees.</p>



<a name="312982009"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tree/near/312982009" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/tree.html#312982009">(Nov 30 2022 at 04:00)</a>:</h4>
<p>(To be clear, when I said most stand libraries don’t have trees, I meant a general purpose one-size fits all “tree”.  They often have specific tree based data structures like heaps, red-black trees, tries, etc.)</p>



<a name="312984731"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tree/near/312984731" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/tree.html#312984731">(Nov 30 2022 at 04:31)</a>:</h4>
<p>Also, the <a href="https://leanprover.github.io/theorem_proving_in_lean4/inductive_types.html">Inductive Types section of Theorem proving in Lean 4</a> has examples of both binary trees and trees with an arbitrary number of children (including finitely and countably infinite branching trees).  Those would probably help you get started for your particular use case.</p>



<a name="313060911"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tree/near/313060911" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/tree.html#313060911">(Nov 30 2022 at 13:34)</a>:</h4>
<p><span class="user-mention" data-user-id="559197">@Kind Bubble</span>  One more comment on trees.  Many inductive structures in functional programming naturally form trees.  For example, a basic expression made of variables, a unary operator, and a binary operator forms a syntax tree.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">MyExpr</span> <span class="n">where</span>
  <span class="bp">|</span> <span class="kd">variable</span> <span class="o">(</span><span class="n">varname</span> <span class="o">:</span> <span class="n">String</span><span class="o">)</span> <span class="o">:</span> <span class="n">MyExpr</span>
  <span class="bp">|</span> <span class="n">plus</span> <span class="o">(</span><span class="n">leftExpr</span> <span class="o">:</span> <span class="n">MyExpr</span><span class="o">)</span> <span class="o">(</span><span class="n">rightExpr</span> <span class="o">:</span> <span class="n">MyExpr</span><span class="o">)</span> <span class="o">:</span> <span class="n">MyExpr</span>
  <span class="bp">|</span> <span class="n">negative</span> <span class="o">(</span><span class="n">expr</span> <span class="o">:</span> <span class="n">MyExpr</span><span class="o">)</span> <span class="o">:</span> <span class="n">MyExpr</span>
</code></pre></div>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
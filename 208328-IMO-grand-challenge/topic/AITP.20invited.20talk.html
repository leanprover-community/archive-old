---
layout: archive
title: Zulip Chat Archive
permalink: /stream/208328-IMO-grand-challenge/topic/AITP.20invited.20talk.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/208328-IMO-grand-challenge/index.html">IMO-grand-challenge</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/208328-IMO-grand-challenge/topic/AITP.20invited.20talk.html">AITP invited talk</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="210070867"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/208328-IMO-grand-challenge/topic/AITP%20invited%20talk/near/210070867" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/208328-IMO-grand-challenge/topic/AITP.20invited.20talk.html#210070867">(Sep 14 2020 at 22:33)</a>:</h4>
<p>@channel FYI I will be giving an invited talk tomorrow at AITP 2020 on the IMO Grand Challenge. Among other things, I will be presenting a very preliminary but perhaps plausible technical roadmap. It will be live on Zoom at 3:00pm GMT (5:00pm Paris time) and there will be time for questions. They asked us not to post the Zoom link publicly, but if you are interested, message me and I can share it with you.</p>



<a name="210099970"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/208328-IMO-grand-challenge/topic/AITP%20invited%20talk/near/210099970" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/208328-IMO-grand-challenge/topic/AITP.20invited.20talk.html#210099970">(Sep 15 2020 at 07:52)</a>:</h4>
<p>Cool! Will it be recorded and subsequently publicly available?</p>



<a name="210258438"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/208328-IMO-grand-challenge/topic/AITP%20invited%20talk/near/210258438" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/208328-IMO-grand-challenge/topic/AITP.20invited.20talk.html#210258438">(Sep 16 2020 at 13:09)</a>:</h4>
<p>In the past the slides and/or videos have been posted on the AITP website.  Here is where they would be: <a href="http://aitp-conference.org/2020/">http://aitp-conference.org/2020/</a></p>



<a name="210264977"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/208328-IMO-grand-challenge/topic/AITP%20invited%20talk/near/210264977" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/208328-IMO-grand-challenge/topic/AITP.20invited.20talk.html#210264977">(Sep 16 2020 at 13:57)</a>:</h4>
<p><span class="user-mention silent" data-user-id="116045">Jesse Michael Han</span> <a href="#narrow/stream/219941-Machine-Learning.20for.20Theorem.20Proving/topic/AITP.202020/near/210260390">said</a>:</p>
<blockquote>
<p>For those of you who saw Dan's talk on the IMO Grand Challenge yesterday and would like to learn more, I have a blog post where I discuss the <code>SearchT</code> monad transformer, ARC, and our work on building an IMO geometry solver: <a href="https://jesse-michael-han.github.io/blog/imo-gc-geo/">https://jesse-michael-han.github.io/blog/imo-gc-geo/</a></p>
</blockquote>
<p>Cross posting so this doesn't get lost.</p>



<a name="210875554"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/208328-IMO-grand-challenge/topic/AITP%20invited%20talk/near/210875554" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/208328-IMO-grand-challenge/topic/AITP.20invited.20talk.html#210875554">(Sep 22 2020 at 14:14)</a>:</h4>
<p>The talk is now available here: <a href="https://youtu.be/GtAo8wqWHHg">https://youtu.be/GtAo8wqWHHg</a></p>
<div class="youtube-video message_inline_image"><a data-id="GtAo8wqWHHg" href="https://youtu.be/GtAo8wqWHHg"><img src="https://i.ytimg.com/vi/GtAo8wqWHHg/default.jpg"></a></div>



<a name="210896225"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/208328-IMO-grand-challenge/topic/AITP%20invited%20talk/near/210896225" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/208328-IMO-grand-challenge/topic/AITP.20invited.20talk.html#210896225">(Sep 22 2020 at 16:30)</a>:</h4>
<p>you mention ~ 32 minutes in, if we can solve the IMO we could also have, start with some inefficient code, and do lots of optimizations to have code that does the same thing but with better performance. that's kind of what a modern compiler does, right? unrolling loops and so on. but this hopefully could be a lot more advanced, using weird data structures etc. very interesting talk...</p>



<a name="210897374"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/208328-IMO-grand-challenge/topic/AITP%20invited%20talk/near/210897374" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Miroslav Olšák <a href="https://leanprover-community.github.io/archive/stream/208328-IMO-grand-challenge/topic/AITP.20invited.20talk.html#210897374">(Sep 22 2020 at 16:38)</a>:</h4>
<p>This is all on the "dream level" but how I understand it, especially IMO combinatorics requires some algorithmic thinking. So if we could solve IMO, we are not so far away from solving analogous programming competitions as IOI, or ACM ICPC (by the way, I have attended both IMO and ACM ICPC).<br>
So computer could just find the right efficient (verified) code given a mathematical problem description.<br>
And one of such descriptions could simply be an unefficient code.</p>



<a name="210898900"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/208328-IMO-grand-challenge/topic/AITP%20invited%20talk/near/210898900" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/208328-IMO-grand-challenge/topic/AITP.20invited.20talk.html#210898900">(Sep 22 2020 at 16:50)</a>:</h4>
<p>it might be similar and more economically useful to say, here's some running code, is there any input it would crash on. or, here's a stack trace from a crash, please autowrite a pull request that fixes it. but yeah kind of "dream level"\</p>



<a name="211086409"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/208328-IMO-grand-challenge/topic/AITP%20invited%20talk/near/211086409" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/208328-IMO-grand-challenge/topic/AITP.20invited.20talk.html#211086409">(Sep 24 2020 at 03:21)</a>:</h4>
<p><span class="user-mention" data-user-id="238605">@Kevin Lacker</span> To clarify, I don't foresee a push-button <code>makeReal :: HighLevelCode -&gt; RealSystem</code> function that takes some high-level code and produces a competitive web-scale production system automatically.  I foresee an (extensible, programmable) interactive assistant---basically just an improved Lean---that can automate many subproblems arising in this process but that is nonetheless still driven by humans.</p>
<p>Here is a high-level sketch:</p>
<ul>
<li>
<p>In addition to factoring out choice points as in nondeterministic programming, also factor out every step that has a simple declarative representation, producing a program that is not only nondeterministic but also noncomputable.  For example, instead of hardcoding a specific search algorithm, write in math that you want to sort the array.  Instead of designing a fancy custom datastructure, write the API (with specs) you want the datastructure to satisfy.  Instead of devising a clever algorithm that computes X in one pass, write a naive one that does it in three, or better yet, describe declaratively the thing you want to compute.  In general, write the most abstract, declarative, simple version of the program you can that precisely captures your intent.</p>
</li>
<li>
<p>Expose a high-level tactic language for refining the noncomputable program into the desired implementation.  The tactics can encompass many kinds of tasks.  Subproblems might be immediately formal ("synthesize a datastructure for this API" or "search for a concrete way to compute this value"). Or, they could be formalizable with respect to a mathematical cost model ("...with all operations quasilinear" or "...only visiting each element of some array once"). They could also involve optimization over learned cost models ("select a sorting algorithm here based on this learned cost model and this historical input data") or even define ongoing policies ("for this ADT, search for 3 candidate implementations with good asymptotics and train a classifier online to map inputs to the most appropriate candidate").</p>
</li>
<li>
<p>Have standard tactics/strategies that can do pretty well in push-button mode.</p>
</li>
</ul>
<p>Most of this could be done in current Lean with enough effort, it is just nowhere near cost effective yet for most use-cases.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
[
    {
        "content": "<p>Is there a variant of <code>expr.mfold</code> that allows me to stop recursing into a particular subexpression?</p>",
        "id": 228195652,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1614587539
    },
    {
        "content": "<p>I guess I'm asking for this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">expr.pruned_mfold</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">monad</span> <span class=\"n\">m</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">expr</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">m</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">bool</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">init</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">expr</span><span class=\"o\">),</span> <span class=\"n\">m</span> <span class=\"n\">α</span>\n<span class=\"bp\">|</span> <span class=\"n\">init</span> <span class=\"n\">e</span><span class=\"bp\">@</span><span class=\"o\">(</span><span class=\"n\">expr.var</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">prod.fst</span> <span class=\"bp\">&lt;$&gt;</span> <span class=\"n\">f</span> <span class=\"n\">e</span> <span class=\"n\">init</span>\n<span class=\"bp\">|</span> <span class=\"n\">init</span> <span class=\"n\">e</span><span class=\"bp\">@</span><span class=\"o\">(</span><span class=\"n\">expr.sort</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">prod.fst</span> <span class=\"bp\">&lt;$&gt;</span> <span class=\"n\">f</span> <span class=\"n\">e</span> <span class=\"n\">init</span>\n<span class=\"bp\">|</span> <span class=\"n\">init</span> <span class=\"n\">e</span><span class=\"bp\">@</span><span class=\"o\">(</span><span class=\"n\">expr.const</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">prod.fst</span> <span class=\"bp\">&lt;$&gt;</span> <span class=\"n\">f</span> <span class=\"n\">e</span> <span class=\"n\">init</span>\n<span class=\"bp\">|</span> <span class=\"n\">init</span> <span class=\"n\">e</span><span class=\"bp\">@</span><span class=\"o\">(</span><span class=\"n\">expr.mvar</span> <span class=\"n\">unique</span> <span class=\"n\">pretty</span> <span class=\"n\">type</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n    <span class=\"o\">(</span><span class=\"n\">val</span><span class=\"o\">,</span> <span class=\"n\">prune</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">f</span> <span class=\"n\">e</span> <span class=\"n\">init</span><span class=\"o\">,</span>\n    <span class=\"k\">if</span> <span class=\"n\">prune</span> <span class=\"k\">then</span> <span class=\"n\">return</span> <span class=\"n\">val</span>\n    <span class=\"k\">else</span> <span class=\"n\">expr.pruned_mfold</span> <span class=\"n\">val</span> <span class=\"n\">type</span>\n<span class=\"bp\">|</span> <span class=\"n\">init</span> <span class=\"n\">e</span><span class=\"bp\">@</span><span class=\"o\">(</span><span class=\"n\">expr.local_const</span> <span class=\"n\">unique</span> <span class=\"n\">pretty</span> <span class=\"n\">bi</span> <span class=\"n\">type</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n    <span class=\"o\">(</span><span class=\"n\">val</span><span class=\"o\">,</span> <span class=\"n\">prune</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">f</span> <span class=\"n\">e</span> <span class=\"n\">init</span><span class=\"o\">,</span>\n    <span class=\"k\">if</span> <span class=\"n\">prune</span> <span class=\"k\">then</span> <span class=\"n\">return</span> <span class=\"n\">val</span>\n    <span class=\"k\">else</span> <span class=\"n\">expr.pruned_mfold</span> <span class=\"n\">val</span> <span class=\"n\">type</span>\n<span class=\"bp\">|</span> <span class=\"n\">init</span> <span class=\"n\">e</span><span class=\"bp\">@</span><span class=\"o\">(</span><span class=\"n\">expr.app</span> <span class=\"n\">fn</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n    <span class=\"o\">(</span><span class=\"n\">val</span><span class=\"o\">,</span> <span class=\"n\">prune</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">f</span> <span class=\"n\">e</span> <span class=\"n\">init</span><span class=\"o\">,</span>\n    <span class=\"k\">if</span> <span class=\"n\">prune</span> <span class=\"k\">then</span> <span class=\"n\">return</span> <span class=\"n\">val</span>\n    <span class=\"k\">else</span> <span class=\"k\">do</span>\n      <span class=\"n\">val</span> <span class=\"bp\">←</span> <span class=\"n\">expr.pruned_mfold</span> <span class=\"n\">val</span> <span class=\"n\">fn</span><span class=\"o\">,</span>\n      <span class=\"n\">expr.pruned_mfold</span> <span class=\"n\">val</span> <span class=\"n\">x</span>\n<span class=\"bp\">|</span> <span class=\"n\">init</span> <span class=\"n\">e</span><span class=\"bp\">@</span><span class=\"o\">(</span><span class=\"n\">expr.lam</span> <span class=\"n\">var_name</span> <span class=\"n\">bi</span> <span class=\"n\">var_type</span> <span class=\"n\">body</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n    <span class=\"o\">(</span><span class=\"n\">val</span><span class=\"o\">,</span> <span class=\"n\">prune</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">f</span> <span class=\"n\">e</span> <span class=\"n\">init</span><span class=\"o\">,</span>\n    <span class=\"k\">if</span> <span class=\"n\">prune</span> <span class=\"k\">then</span> <span class=\"n\">return</span> <span class=\"n\">val</span>\n    <span class=\"k\">else</span> <span class=\"k\">do</span>\n      <span class=\"n\">val</span> <span class=\"bp\">←</span> <span class=\"n\">expr.pruned_mfold</span> <span class=\"n\">val</span> <span class=\"n\">var_type</span><span class=\"o\">,</span>\n      <span class=\"n\">expr.pruned_mfold</span> <span class=\"n\">val</span> <span class=\"n\">body</span>\n<span class=\"bp\">|</span> <span class=\"n\">init</span> <span class=\"n\">e</span><span class=\"bp\">@</span><span class=\"o\">(</span><span class=\"n\">expr.pi</span> <span class=\"n\">var_name</span> <span class=\"n\">bi</span> <span class=\"n\">var_type</span> <span class=\"n\">body</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n    <span class=\"o\">(</span><span class=\"n\">val</span><span class=\"o\">,</span> <span class=\"n\">prune</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">f</span> <span class=\"n\">e</span> <span class=\"n\">init</span><span class=\"o\">,</span>\n    <span class=\"k\">if</span> <span class=\"n\">prune</span> <span class=\"k\">then</span> <span class=\"n\">return</span> <span class=\"n\">val</span>\n    <span class=\"k\">else</span> <span class=\"k\">do</span>\n      <span class=\"n\">val</span> <span class=\"bp\">←</span> <span class=\"n\">expr.pruned_mfold</span> <span class=\"n\">val</span> <span class=\"n\">var_type</span><span class=\"o\">,</span>\n      <span class=\"n\">expr.pruned_mfold</span> <span class=\"n\">val</span> <span class=\"n\">body</span>\n<span class=\"bp\">|</span> <span class=\"n\">init</span> <span class=\"n\">e</span><span class=\"bp\">@</span><span class=\"o\">(</span><span class=\"n\">expr.elet</span> <span class=\"n\">var_name</span> <span class=\"n\">type</span> <span class=\"n\">assignment</span> <span class=\"n\">body</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n    <span class=\"o\">(</span><span class=\"n\">val</span><span class=\"o\">,</span> <span class=\"n\">prune</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">f</span> <span class=\"n\">e</span> <span class=\"n\">init</span><span class=\"o\">,</span>\n    <span class=\"k\">if</span> <span class=\"n\">prune</span> <span class=\"k\">then</span> <span class=\"n\">return</span> <span class=\"n\">val</span>\n    <span class=\"k\">else</span> <span class=\"k\">do</span>\n      <span class=\"n\">val</span> <span class=\"bp\">←</span> <span class=\"n\">expr.pruned_mfold</span> <span class=\"n\">val</span> <span class=\"n\">type</span><span class=\"o\">,</span>\n      <span class=\"n\">val</span> <span class=\"bp\">←</span> <span class=\"n\">expr.pruned_mfold</span> <span class=\"n\">val</span> <span class=\"n\">assignment</span><span class=\"o\">,</span>\n      <span class=\"n\">expr.pruned_mfold</span> <span class=\"n\">val</span> <span class=\"n\">body</span>\n<span class=\"bp\">|</span> <span class=\"n\">init</span> <span class=\"n\">e</span><span class=\"bp\">@</span><span class=\"o\">(</span><span class=\"n\">expr.macro</span> <span class=\"n\">_</span> <span class=\"n\">ls</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n    <span class=\"o\">(</span><span class=\"n\">val</span><span class=\"o\">,</span> <span class=\"n\">prune</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">f</span> <span class=\"n\">e</span> <span class=\"n\">init</span><span class=\"o\">,</span>\n    <span class=\"k\">if</span> <span class=\"n\">prune</span> <span class=\"k\">then</span> <span class=\"n\">return</span> <span class=\"n\">val</span>\n    <span class=\"k\">else</span> <span class=\"k\">do</span>\n      <span class=\"n\">ls.mfoldl</span> <span class=\"n\">expr.pruned_mfold</span> <span class=\"n\">val</span>\n</code></pre></div>",
        "id": 228198337,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1614589231
    },
    {
        "content": "<p>I'm not aware of an existing implementation of this. I think you can implement it in terms of regular <code>mfold</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">expr.pruned_mfold</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">monad</span> <span class=\"n\">m</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">expr</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">m</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">bool</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">init</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">expr</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"o\">(</span><span class=\"n\">acc</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">e.mfold</span> <span class=\"o\">(</span><span class=\"n\">init</span><span class=\"o\">,</span> <span class=\"n\">ff</span><span class=\"o\">)</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">e'</span> <span class=\"n\">_</span> <span class=\"o\">⟨</span><span class=\"n\">acc</span><span class=\"o\">,</span> <span class=\"n\">prune</span><span class=\"o\">⟩,</span>\n    <span class=\"k\">if</span> <span class=\"n\">prune</span>\n      <span class=\"k\">then</span> <span class=\"n\">pure</span> <span class=\"o\">(</span><span class=\"n\">acc</span><span class=\"o\">,</span> <span class=\"n\">tt</span><span class=\"o\">)</span>\n      <span class=\"k\">else</span> <span class=\"n\">f</span> <span class=\"n\">e'</span> <span class=\"n\">acc</span><span class=\"o\">,</span>\n  <span class=\"n\">pure</span> <span class=\"n\">acc</span>\n</code></pre></div>\n<p>However, I don't think this short-circuits properly, so it'll continue to recurse after you've set <code>prune</code> to <code>tt</code>. However, it'll only do a trivial amount of work for each subexpression.</p>",
        "id": 228231483,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1614606311
    },
    {
        "content": "<p>That doesn't prune branches though, that prunes the entire recursion</p>",
        "id": 228231842,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1614606437
    },
    {
        "content": "<p>I want folding over <code>g (f (f a)) (h (f b))</code> to run on <code>g ...</code>, <code>f (f a)</code>, <code>h (f b)</code> and <code>f b</code>, but not visit <code>b</code> or <code>(f a)</code> as those are children of a subexpression that has been \"pruned\"</p>",
        "id": 228232016,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1614606498
    },
    {
        "content": "<p>Note that the big advantage of <code>expr.fold</code> (which is used to implement <code>expr.mfold</code>) is that it doesn't visit identical subexpressions twice.</p>",
        "id": 228232681,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1614606735
    },
    {
        "content": "<p>This tastes a bit of <a href=\"https://en.wikipedia.org/wiki/XY_problem\">#xy</a>, what are you actually trying to do?</p>",
        "id": 228232847,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1614606807
    },
    {
        "content": "<p>This looks like a shorter implementation of <code>pruned_mfold</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- get all child expressions of an expression -/</span>\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">expr.nested_exprs</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">expr</span><span class=\"o\">),</span> <span class=\"n\">list</span> <span class=\"n\">expr</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">expr.var</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">[]</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">expr.sort</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">[]</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">expr.const</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">[]</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">expr.mvar</span> <span class=\"n\">unique</span> <span class=\"n\">pretty</span> <span class=\"n\">type</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">[</span><span class=\"n\">type</span><span class=\"o\">]</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">expr.local_const</span> <span class=\"n\">unique</span> <span class=\"n\">pretty</span> <span class=\"n\">bi</span> <span class=\"n\">type</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">[</span><span class=\"n\">type</span><span class=\"o\">]</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">expr.app</span> <span class=\"n\">fn</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">[</span><span class=\"n\">fn</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"o\">]</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">expr.lam</span> <span class=\"n\">var_name</span> <span class=\"n\">bi</span> <span class=\"n\">var_type</span> <span class=\"n\">body</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">[</span><span class=\"n\">var_type</span><span class=\"o\">,</span> <span class=\"n\">body</span><span class=\"o\">]</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">expr.pi</span> <span class=\"n\">var_name</span> <span class=\"n\">bi</span> <span class=\"n\">var_type</span> <span class=\"n\">body</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">[</span><span class=\"n\">var_type</span><span class=\"o\">,</span> <span class=\"n\">body</span><span class=\"o\">]</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">expr.elet</span> <span class=\"n\">var_name</span> <span class=\"n\">type</span> <span class=\"n\">assignment</span> <span class=\"n\">body</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">[</span><span class=\"n\">type</span><span class=\"o\">,</span> <span class=\"n\">assignment</span><span class=\"o\">,</span> <span class=\"n\">body</span><span class=\"o\">]</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">expr.macro</span> <span class=\"n\">_</span> <span class=\"n\">ls</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">ls</span>\n\n<span class=\"sd\">/-- mfold over an expression tree, without visiting branches for which `(f e val).snd` is true -/</span>\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">expr.pruned_mfold</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">monad</span> <span class=\"n\">m</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">expr</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">m</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">bool</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">init</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">expr</span><span class=\"o\">),</span> <span class=\"n\">m</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">init</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"k\">do</span>\n  <span class=\"o\">(</span><span class=\"n\">val</span><span class=\"o\">,</span> <span class=\"n\">prune</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">f</span> <span class=\"n\">e</span> <span class=\"n\">init</span><span class=\"o\">,</span>\n  <span class=\"n\">ff</span> <span class=\"bp\">←</span> <span class=\"n\">pure</span> <span class=\"n\">prune</span> <span class=\"bp\">|</span> <span class=\"n\">return</span> <span class=\"n\">val</span><span class=\"o\">,</span>\n  <span class=\"n\">list.mfoldl</span> <span class=\"n\">expr.pruned_mfold</span> <span class=\"n\">val</span> <span class=\"n\">e.nested_exprs</span>\n</code></pre></div>",
        "id": 228233453,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1614607046
    },
    {
        "content": "<blockquote>\n<p>what are you actually trying to do?</p>\n</blockquote>\n<p>Find decidable terms, without recursing into the decidable terms that they might be produced by</p>",
        "id": 228233515,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1614607081
    },
    {
        "content": "<p>I don't know whether I actually need to do that pruning yet - CI seems stuck on <a href=\"https://github.com/leanprover-community/mathlib/issues/6485\">#6485</a>, and probably I just need to wait for the queue to clear</p>",
        "id": 228233811,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1614607202
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/239415-metaprogramming-.2F.20tactics/topic/expr.2Emfold.20with.20branch.20pruning/near/228231842\">said</a>:</p>\n<blockquote>\n<p>That doesn't prune branches though, that prunes the entire recursion</p>\n</blockquote>\n<p>I see. I'm not sure whether there's an <code>mfold</code>/<code>fold</code> incantation that doesn't have this problem, so you might indeed have to roll your own fold.</p>",
        "id": 228234380,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1614607386
    },
    {
        "content": "<p>I don't think expr.mfold is a good idea here.  When traversing lambdas/pis/lets, you probably want to instantiate the de Bruijn variables with local constants.  Otherwise <code>infer_type</code>, <code>mk_instance</code>, etc. won't work.</p>",
        "id": 228237956,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1614608619
    },
    {
        "content": "<p>Is it safe if I've done <code>open_pis</code> first?</p>",
        "id": 228238283,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1614608716
    },
    {
        "content": "<p><code>open_pis</code> will only do the outermost layer.  E.g. in <code>Π a b c, foo (λ x, irrational.decidable (x+1))</code>, the <code>x+1</code> will actually be <code>#0+1</code> if you traverse it via <code>expr.fold</code>.</p>",
        "id": 228239131,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1614608984
    },
    {
        "content": "<p>Ah, got it</p>",
        "id": 228239440,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1614609082
    },
    {
        "content": "<p>That explains why <code>infer_type</code> failed on me sometimes</p>",
        "id": 228239624,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1614609134
    },
    {
        "content": "<p>But probably my linter is not well thought out for expressions inside binders anyway</p>",
        "id": 228239672,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1614609150
    },
    {
        "content": "<p>So best to ignore those for now</p>",
        "id": 228239691,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1614609158
    },
    {
        "content": "<p>i use something like this to extract data from proof terms in <code>lean-step-public</code></p>",
        "id": 228499861,
        "sender_full_name": "Jesse Michael Han",
        "timestamp": 1614724769
    }
]
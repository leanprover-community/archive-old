[
    {
        "content": "<p>For meta-programmers looking for ideas: a really nice command would tell us where to put lemmas. When I work on some small new piece, I start a new file where I write everything I need. And then most of the work (much longer than writing statements and proving them) is to find in which file each lemma needs to go. Ideally I'd like to type <code>#find_home my_lemma</code> and Lean would answer: \"This lemma could go in <code>this_file.lean</code>, line 500\".  The basic algorithm is to traverse all declarations used in <code>my_lemma</code> (in its type or value) and figure out whether there is a declaration after which everything is available.</p>",
        "id": 212223259,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1601817908
    },
    {
        "content": "<p>The first epsilon, perhaps:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">tactic</span>\n\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">referenced_decls</span> <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">declaration</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">name_set</span> <span class=\"o\">:=</span>\n<span class=\"n\">d.type.list_constant.fold</span> <span class=\"n\">d.value.list_constant</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">n</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">s.insert</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">required_imports</span> <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">declaration</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"n\">string</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">do</span>\n  <span class=\"n\">env</span> <span class=\"bp\">←</span> <span class=\"n\">get_env</span><span class=\"o\">,</span>\n  <span class=\"n\">return</span> <span class=\"bp\">$</span> <span class=\"o\">((</span><span class=\"n\">referenced_decls</span> <span class=\"n\">d</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">fold</span> <span class=\"o\">[]</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">n</span> <span class=\"n\">L</span><span class=\"o\">,</span> <span class=\"n\">L</span> <span class=\"bp\">++</span> <span class=\"o\">(</span><span class=\"n\">env.decl_olean</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_list</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">erase_dup</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">true</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n   <span class=\"o\">(</span><span class=\"k\">do</span> <span class=\"n\">e</span> <span class=\"bp\">←</span> <span class=\"n\">get_env</span><span class=\"o\">,</span>\n    <span class=\"n\">d</span> <span class=\"bp\">←</span> <span class=\"n\">get_decl</span> <span class=\"bp\">`</span><span class=\"n\">referenced_decls</span><span class=\"o\">,</span>\n    <span class=\"n\">trace</span> <span class=\"o\">(</span><span class=\"n\">referenced_decls</span> <span class=\"n\">d</span><span class=\"o\">),</span>\n    <span class=\"n\">trace</span> <span class=\"o\">(</span><span class=\"n\">required_imports</span> <span class=\"n\">d</span><span class=\"o\">),</span>\n    <span class=\"n\">skip</span><span class=\"o\">),</span>\n  <span class=\"n\">trivial</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 212255144,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1601868611
    },
    {
        "content": "<p>It would be <em>really</em> nice to have a function that returns the list of imports of a given lean file.</p>",
        "id": 212255153,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1601868632
    },
    {
        "content": "<p>However it doesn't seem like this information is even tracked at the C++ level, as far as I can see.</p>",
        "id": 212255162,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1601868658
    },
    {
        "content": "<p>Perhaps Lean calling <code>grep</code> is the right solution. :-)</p>",
        "id": 212255176,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1601868682
    },
    {
        "content": "<p>I'm imagining that the algorithm is: </p>\n<ol>\n<li>find all \"required imports\" for a given declaration (done, above)</li>\n<li>for each of those imported files, find the files it transitively imports</li>\n<li>take the complement</li>\n</ol>\n<p>If the complement is a singleton, you win --- that's where you want to put the lemma, and a second stage can work out the appropriate line number using <code>get_decl_pos</code>. If the complement is more than a singleton, there'll have to be some sort of advice/consolation message.</p>",
        "id": 212255452,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1601869136
    },
    {
        "content": "<p>If we can't get access to the list of files a given file imports, we <em>could</em> hack it, by traversing the list of every declaration, filtering those that a defined in the given file, and then called <code>required_imports</code> on those. This would only report the imports that are actually needed!</p>",
        "id": 212255493,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1601869204
    },
    {
        "content": "<p>The list of imports of a given file is certainly tracked, it is in a prominent position in the generated <code>olean</code> files and <code>olean-rs</code> can pick it up without too much trouble</p>",
        "id": 212256687,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601871583
    },
    {
        "content": "<p>I think the proper way to do this is with the <a href=\"https://leanprover-community.github.io/mathlib_docs/find/environment.for_decl_of_imported_module\">docs#environment.for_decl_of_imported_module</a> API. This API comes with a big bold warning but I think it's safe here. Maybe <code>--old</code> would cause trouble? In any case, the code below is more than epsilon progress, but needs polishing for declarations that belong in the current file.</p>",
        "id": 212269963,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1601885698
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.real.basic</span>\n\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">expr.get_constants</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">expr</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">name_set</span> <span class=\"o\">:=</span>\n<span class=\"n\">e.fold</span> <span class=\"n\">mk_name_set</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">e'</span> <span class=\"n\">_</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"k\">match</span> <span class=\"n\">e'</span> <span class=\"k\">with</span>\n<span class=\"bp\">|</span> <span class=\"n\">expr.const</span> <span class=\"n\">nm</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">s.insert</span> <span class=\"n\">nm</span>\n<span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">s</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">declaration.get_constants</span> <span class=\"o\">:</span> <span class=\"n\">declaration</span> <span class=\"bp\">→</span> <span class=\"n\">name_set</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">declaration.ax</span> <span class=\"n\">nm</span> <span class=\"n\">_</span> <span class=\"n\">tp</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">tp.get_constants</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">declaration.cnst</span> <span class=\"n\">nm</span> <span class=\"n\">_</span> <span class=\"n\">tp</span> <span class=\"n\">is_meta</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">tp.get_constants</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">declaration.thm</span> <span class=\"n\">nm</span> <span class=\"n\">_</span> <span class=\"n\">tp</span> <span class=\"n\">bd</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">tp.get_constants.union</span> <span class=\"n\">bd.get.get_constants</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">declaration.defn</span> <span class=\"n\">nm</span> <span class=\"n\">_</span> <span class=\"n\">tp</span> <span class=\"n\">bd</span> <span class=\"n\">_</span> <span class=\"n\">is_meta</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">tp.get_constants.union</span> <span class=\"n\">bd.get_constants</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">tactic</span>\n\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">module_info_of_decl</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">name</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">module_info</span> <span class=\"o\">:=</span>\n<span class=\"k\">do</span> <span class=\"n\">e</span> <span class=\"bp\">←</span> <span class=\"n\">get_env</span><span class=\"o\">,</span>\n<span class=\"k\">match</span> <span class=\"n\">e.decl_olean</span> <span class=\"n\">n</span> <span class=\"k\">with</span>\n<span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"n\">return</span> <span class=\"bp\">$</span> <span class=\"n\">module_info.of_module_id</span> <span class=\"n\">s</span>\n<span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"o\">:=</span> <span class=\"n\">failed</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">get_env_of</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">name</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">environment</span> <span class=\"o\">:=</span>\n<span class=\"k\">do</span> <span class=\"n\">e</span> <span class=\"bp\">←</span> <span class=\"n\">get_env</span><span class=\"o\">,</span>\n<span class=\"k\">match</span> <span class=\"n\">e.decl_olean</span> <span class=\"n\">n</span> <span class=\"k\">with</span>\n<span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"n\">return</span> <span class=\"bp\">$</span> <span class=\"n\">environment.for_decl_of_imported_module</span> <span class=\"n\">s</span> <span class=\"n\">n</span>\n<span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"o\">:=</span> <span class=\"n\">fail</span><span class=\"bp\">!</span><span class=\"s2\">\"couldn't find {n}\"</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">test_names_at</span> <span class=\"o\">(</span><span class=\"n\">ns</span> <span class=\"o\">:</span> <span class=\"n\">name_set</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">tgt</span> <span class=\"o\">:</span> <span class=\"n\">name</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">bool</span> <span class=\"o\">:=</span>\n<span class=\"k\">do</span> <span class=\"n\">e</span> <span class=\"bp\">←</span> <span class=\"n\">get_env_of</span> <span class=\"n\">tgt</span><span class=\"o\">,</span>\n   <span class=\"n\">return</span> <span class=\"bp\">$</span> <span class=\"n\">ns.fold</span> <span class=\"n\">tt</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">nm</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">b</span> <span class=\"bp\">&amp;&amp;</span> <span class=\"n\">e.contains</span> <span class=\"n\">nm</span>\n\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">find_highest</span> <span class=\"o\">(</span><span class=\"n\">tgt</span> <span class=\"o\">:</span> <span class=\"n\">name</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">name</span> <span class=\"o\">:=</span>\n<span class=\"k\">do</span> <span class=\"n\">d</span> <span class=\"bp\">←</span> <span class=\"n\">get_decl</span> <span class=\"n\">tgt</span><span class=\"o\">,</span>\n<span class=\"k\">let</span> <span class=\"n\">cnsts</span> <span class=\"o\">:=</span> <span class=\"n\">d.get_constants</span><span class=\"o\">,</span>\n<span class=\"n\">cnsts.to_list.mfirst</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">nm</span><span class=\"o\">,</span>\n  <span class=\"n\">test_names_at</span> <span class=\"o\">(</span><span class=\"n\">cnsts.erase</span> <span class=\"n\">nm</span><span class=\"o\">)</span> <span class=\"n\">nm</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"n\">guardb</span> <span class=\"bp\">&gt;&gt;</span> <span class=\"n\">return</span> <span class=\"n\">nm</span><span class=\"o\">)</span> <span class=\"bp\">&lt;|&gt;</span>\n<span class=\"n\">fail</span> <span class=\"s2\">\"didn't find any highest decl\"</span>\n\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">locate_decl</span> <span class=\"o\">(</span><span class=\"n\">tgt</span> <span class=\"o\">:</span> <span class=\"n\">name</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">unit</span> <span class=\"o\">:=</span>\n<span class=\"k\">do</span> <span class=\"n\">highest</span> <span class=\"bp\">←</span> <span class=\"n\">find_highest</span> <span class=\"n\">tgt</span><span class=\"o\">,</span>\n   <span class=\"n\">e</span> <span class=\"bp\">←</span> <span class=\"n\">get_env</span><span class=\"o\">,</span>\n   <span class=\"k\">let</span> <span class=\"n\">file</span> <span class=\"o\">:=</span> <span class=\"k\">match</span> <span class=\"n\">e.decl_olean</span> <span class=\"n\">highest</span> <span class=\"k\">with</span>\n   <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"o\">:=</span> <span class=\"s2\">\"the current file\"</span>\n   <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">module_info.of_module_id</span> <span class=\"n\">s</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">id</span>\n   <span class=\"kd\">end</span><span class=\"o\">,</span>\n   <span class=\"n\">trace</span><span class=\"bp\">!</span><span class=\"s2\">\"{tgt} belongs in {file} after {highest}\"</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">tactic</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">real_big</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">3000</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">50</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">norm_num</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">recfn</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">n</span>\n\n<span class=\"kd\">run_cmd</span> <span class=\"n\">tactic.locate_decl</span> <span class=\"bp\">``</span><span class=\"n\">real_big</span>\n<span class=\"c1\">-- real_big belongs in /Storage/lean/mathlib/src/data/real/basic.lean after real.has_add</span>\n\n<span class=\"kd\">run_cmd</span> <span class=\"n\">tactic.locate_decl</span> <span class=\"bp\">``</span><span class=\"n\">recfn</span>\n</code></pre></div>",
        "id": 212269975,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1601885707
    },
    {
        "content": "<p>This doesn't do any fancy graph stuff, it checks every constant at every other one, so it's potentially very slow.</p>",
        "id": 212270095,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1601885789
    },
    {
        "content": "<p>And it doesn't work as expected on things like <code>recfn</code>, which generates a <code>_main</code> aux def.</p>",
        "id": 212270135,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1601885836
    }
]
[
    {
        "content": "<p>In Providence last week, <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> helped me write my first mathlib tactic, and it was merged this morning.  <a href=\"https://leanprover-community.github.io/mathlib_docs/find/tactic.interactive.positivity\">docs#tactic.interactive.positivity</a> solves goals of the form <code>0 &lt; x</code> and <code>0 ≤ x</code> when the proof is \"clear from the syntax of <code>x</code>\": that is, a sequence of applications of lemmas like <code>add_pos</code> and<code> mul_nonneg</code> and <code>abs_nonneg</code>.  So, e.g., from the test file,</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"mi\">3</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hb</span> <span class=\"o\">:</span> <span class=\"mi\">4</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">3</span> <span class=\"bp\">+</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">/</span> <span class=\"mi\">7</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"mi\">7</span> <span class=\"bp\">+</span> <span class=\"mi\">14</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">positivity</span>\n</code></pre></div>\n<p>or from my follow-up golfing PR <a href=\"https://github.com/leanprover-community/mathlib/pull/15701\">#15701</a>,</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span>  <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">linear_ordered_field</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"bp\">|</span><span class=\"n\">x</span><span class=\"bp\">|</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">positivity</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hy</span> <span class=\"o\">:</span> <span class=\"n\">y</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hz</span> <span class=\"o\">:</span> <span class=\"n\">z</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">((</span><span class=\"n\">x</span><span class=\"bp\">^</span><span class=\"mi\">3</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">x</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"bp\">^</span><span class=\"mi\">2</span> <span class=\"bp\">+</span> <span class=\"n\">z</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"o\">))</span><span class=\"bp\">/</span><span class=\"o\">((</span><span class=\"n\">x</span><span class=\"bp\">^</span><span class=\"mi\">5</span><span class=\"bp\">+</span><span class=\"n\">y</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"bp\">+</span><span class=\"n\">z</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"bp\">*</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">^</span><span class=\"mi\">3</span><span class=\"bp\">*</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"bp\">+</span><span class=\"n\">y</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"bp\">+</span><span class=\"n\">z</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"o\">)))</span> <span class=\"bp\">≥</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">positivity</span>\n</code></pre></div>",
        "id": 290960929,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1658872423
    },
    {
        "content": "<p>I hope this tactic will be useful in bigger inequality calculations, where annoying positivity side goals turn up over and over again.  Please test it!  Looking forward to feedback!</p>",
        "id": 290961021,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1658872479
    },
    {
        "content": "<p>can it handle goals of the type <code>x &lt; 0</code>, where <code>0 &lt; -x</code> (modulo <code>neg_neg</code>) would be solved by <code>positivity</code>? that would be a really neat addition to a really neat tactic :)</p>",
        "id": 290961880,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1658872997
    },
    {
        "content": "<p>that's... not positivity?</p>",
        "id": 290962296,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1658873225
    },
    {
        "content": "<p>sure but it's not too far of an extension. if you want to call it <code>negativity</code> that's fair</p>",
        "id": 290962727,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1658873529
    },
    {
        "content": "<p>Aah, the desire by users for mission creep has begun early on this one!</p>",
        "id": 290965397,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1658875461
    },
    {
        "content": "<p><code>neg_neg_iff.mp (by positivity)</code> doesn't have the same slickness to it, and it should be like 3 lines. (plus, is it even <a href=\"https://leanprover-community.github.io/mathlib_docs/find/neg_neg_iff\">docs#neg_neg_iff</a>? it definitely isn't <code>neg_neg</code>, anyways)</p>",
        "id": 290966714,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1658876446
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"284160\">@Eric Rodriguez</span> Dealing with negativity is a reasonable idea, but in my opinion what makes it impracticable here is that you might prove (say) <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>x</mi><mn>3</mn></msup><mi>y</mi><mi>z</mi><mo>&lt;</mo></mrow><annotation encoding=\"application/x-tex\">x^3yz&lt;</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0085em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">3</span></span></span></span></span></span></span></span><span class=\"mord mathnormal\" style=\"margin-right:0.04398em;\">yz</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&lt;</span></span></span></span> by showing that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi><mo>&lt;</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">x&lt;0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>y</mi><mo separator=\"true\">,</mo><mi>z</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">y,z&gt;0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7335em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.04398em;\">z</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&gt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span>, or by any other permutation.  So there's branching.  Whereas for positivity, the naive greedy algorithm works surprisingly often.</p>\n<p>I would even claim that mathematicians are trained to reorganize paper proofs to favour getting positivity (rather than negativity) side goals, for this same reason.</p>",
        "id": 290981424,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1658890109
    },
    {
        "content": "<p>Is there an easy way to tweak <code>positivity</code> so that it also solves the following goal:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hb</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">positivity</span>\n</code></pre></div>\n<p>(which doesn't work currently)?<br>\nOr maybe it's too bad from a computational point of view as it could lead to too much branching?</p>",
        "id": 291304750,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1659090162
    },
    {
        "content": "<p>A few ideas:</p>\n<ol>\n<li>Maybe you could limit the branching by passing an integer which limits the depth of the transitivity goals (e.g.,  syntax could be<code>with 2</code>), and the default is no transitivity.</li>\n<li>I guess the other problem might be: how do you know which intermediate value (in the example, <code>a</code>) to compare? Perhaps the user could supply the intermediate term, this would also limit branching. In this case, the user might even be able to pass a list of intermediate values.</li>\n</ol>\n<p>Yes, there is significant mission creep!</p>",
        "id": 291330441,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1659103314
    },
    {
        "content": "<p>My idea was rather to cycle through the context. Suppose you want to check positivity of <code>b</code>. Then you cycle through the context, looking for inequalities <code>foo &lt; b</code> or <code>foo ≤ b</code>. And when you find one, apply recursively <code>positivity</code> to check if <code>foo</code> is positive or nonnegative. I agree that the depth should be limited to 1 or 2 (for instance to avoid cycles when you have both <code>a ≤ b</code> and <code>b ≤ a</code> in the context, and also to keep reasonable complexity).</p>",
        "id": 291332867,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1659104582
    },
    {
        "content": "<p>Indeed, this is the obvious limitation of the tactic in its current form.  I discussed it with <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> last week and he seemed to think that building a full digraph of the information in the order hypotheses was not completely intractable.  <span class=\"user-mention\" data-user-id=\"110865\">@Jeremy Avigad</span> also mentioned <a href=\"https://arxiv.org/abs/1404.4410\">Polya</a> (cc <span class=\"user-mention\" data-user-id=\"110596\">@Rob Lewis</span>) for this kind of problem, although I don't completely understand its scope.</p>",
        "id": 291333370,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1659104819
    },
    {
        "content": "<p>Another possibility (but slow) is to run <code>linarith</code> as the \"base case\" of the tactic.</p>",
        "id": 291333399,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1659104841
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"260507\">Heather Macbeth</span> <a href=\"#narrow/stream/239415-metaprogramming-.2F-tactics/topic/New.20tactic.3A.20.60positivity.60/near/291333399\">said</a>:</p>\n<blockquote>\n<p>Another possibility (but slow) is to run <code>linarith</code> as the \"base case\" of the tactic.</p>\n</blockquote>\n<p>For me, one of the main interests of <code>positivity</code> is that it is pretty quick, so calling <code>linarith</code> doesn't look like a good idea here.</p>",
        "id": 291341274,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1659108638
    },
    {
        "content": "<p>Polya (<a href=\"https://link.springer.com/article/10.1007/s10817-015-9356-y\">https://link.springer.com/article/10.1007/s10817-015-9356-y</a>) was a much more complicated (and hence slower) thing. The idea was to reason forward and iteratively derive more and more facts about expressions of interest. Here \"expressions of interest\" meant more or less all subterms of expressions in the hypotheses and conclusion. </p>\n<p>In the case of a positivity tactic, one could make a list of all expressions of interest and iteratively derive new comparisons with 0 with rules like \"if a is positive and b is nonnegative, then a + b is positive,\" \"if a is positive and a &lt;= b, then b is positive,\" \"if a is negative then -a is positive\", \"if a is positive and b is nonpositive then a - b is  positive,\" \"abs a\" is nonnegative, \"a^2 is nonnegative\", etc. You keep going until you reach your goal or you run out of rules to apply. </p>\n<p>Polya was actually designed to handle arbitrary real inequalities, so more generally it would look for comparisons between any pair of expressions of interest. Linear arithmetic was called repeatedly as a subroutine. Rob and I had a Python implementation that worked pretty well and Rob wrote a proof-producing version in Lean 3 as part of his dissertation, but I think it was too hard to make the latter efficient.</p>",
        "id": 291372298,
        "sender_full_name": "Jeremy Avigad",
        "timestamp": 1659124103
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110865\">Jeremy Avigad</span> <a href=\"#narrow/stream/239415-metaprogramming-.2F-tactics/topic/New.20tactic.3A.20.60positivity.60/near/291372298\">said</a>:</p>\n<blockquote>\n<p>Linear arithmetic was called repeatedly as a subroutine.</p>\n</blockquote>\n<p>I guess, as Sébastien commented, this rules out using an exact analogue of the Polya idea for the purposes of <code>positivity</code>.  (The dream is that <code>positivity</code> be a default discharger for <code>field_simp</code>, <code>mono</code>, <code>apply_rules</code>, etc -- so it has to be fast.). But this idea about \"expressions of interest\" is interesting and perhaps reusable.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"110865\">Jeremy Avigad</span> <a href=\"#narrow/stream/239415-metaprogramming-.2F-tactics/topic/New.20tactic.3A.20.60positivity.60/near/291372298\">said</a>:</p>\n<blockquote>\n<p>The idea was to reason forward and iteratively derive more and more facts about expressions of interest. Here \"expressions of interest\" meant more or less all subterms of expressions in the hypotheses and conclusion. </p>\n</blockquote>",
        "id": 291393711,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1659138103
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> Could you refresh my memory about what you were saying in Providence, about what is feasible in terms of the web of transitivity implications among hypotheses?</p>",
        "id": 291393794,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1659138192
    },
    {
        "content": "<p>The idea is to populate the context with <code>0 &lt;= x</code> or <code>0 &lt; x</code> for all applicable <code>x</code> which appear in inequalities in the hypotheses. So it's doing forward reasoning: if you know <code>0 &lt;= a</code> and you find <code>h : a &lt; b</code> then add <code>0 &lt; b</code>, then continue until saturation. Then do the rest of the proof as normal</p>",
        "id": 291396078,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659140985
    },
    {
        "content": "<p>this doesn't get stuck in loops because if you already know a positivity fact about <code>x</code> then you only deduce a new one if it's better than what you already have</p>",
        "id": 291396151,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659141059
    },
    {
        "content": "<p>It seems that <code>positivity</code> does not try to use <code>finset.prod_nonneg</code>, i.e., this fails:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.big_operators.order</span>\n<span class=\"kn\">import</span> <span class=\"n\">tactic.positivity</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">ordered_comm_semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">R</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">ι</span><span class=\"o\">}</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">h0</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">),</span> <span class=\"n\">i</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"n\">s.prod</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">positivity</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>But I want to say that <code>positivity</code> is a huge quality of life improvement: I am working on the Schwartz space and it would be so annoying finding all the proofs for nonnegativity myself (they are usually not hard, but it is just distracting).</p>",
        "id": 291755417,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1659467645
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"412682\">@Moritz Doll</span> Thanks for the idea!  <code>finset.prod_nonneg</code> should be an easy addition, similar to <a href=\"https://leanprover-community.github.io/mathlib_docs/find/tactic.positivity_sqrt\">docs#tactic.positivity_sqrt</a> or or <a href=\"https://leanprover-community.github.io/mathlib_docs/find/tactic.positivity_mul\">docs#tactic.positivity_mul</a>, do you want me to add it or would you like to try yourself?</p>",
        "id": 291757634,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1659468812
    },
    {
        "content": "<p>Actually, maybe it's not so easy, because it doesn't reduce to another goal doable by <code>positivity</code> (i.e. <code>∀ (i : ι), i ∈ s → 0 ≤ f i</code> is not itself a goal doable by positivity).</p>",
        "id": 291758002,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1659468975
    },
    {
        "content": "<p>Maybe it's possible if we throw in a <code>fin_cases</code> on <code>i ∈ s</code>.</p>",
        "id": 291758130,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1659469041
    },
    {
        "content": "<p>my work-around was <code>(finset.prod_nonneg (λ _ _, by positivity))</code>, I have no idea whether this is easy to do in tactics</p>",
        "id": 291758145,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1659469053
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"412682\">Moritz Doll</span> <a href=\"#narrow/stream/239415-metaprogramming-.2F-tactics/topic/New.20tactic.3A.20.60positivity.60/near/291758145\">said</a>:</p>\n<blockquote>\n<p>my work-around was <code>(finset.prod_nonneg (λ _ _, by positivity))</code>, I have no idea whether this is easy to do in tactics</p>\n</blockquote>\n<p>I'm surprised this works!  What about a situation when <code>by positivity</code> works for all the goals but for a different reason each time?</p>\n<p>E.g., say <code>s</code> is <code>range n</code>, i.e. <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">{</mo><mn>0</mn><mo separator=\"true\">,</mo><mn>1</mn><mo separator=\"true\">,</mo><mn>2</mn><mo separator=\"true\">,</mo><mo>…</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">\\{0,1,2,\\ldots n-1\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">2</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">}</span></span></span></span>, and <code>f 0 =  0</code>, <code>f 1 = x</code>, <code>f 2 = x + x</code>, <code>f 3 = x + x + x</code>, ... ?  Say we have <code>hx : 0 ≤ x</code> as a hypothesis. Then <code>by positivity</code> works to show that each <code>f i</code> is positive, but the term proof is always different (<code>hx</code> for <code>f 1</code>, <code>add_nonneg hx hx</code> for <code>f 2</code>, <code>add_nonneg (add_nonneg hx hx) hx</code> for <code>f 3</code>, etc.)</p>",
        "id": 291758535,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1659469264
    },
    {
        "content": "<p>But it seems plausible that this would for any numeric <code>n</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">finset.prod_nonneg</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">i</span> <span class=\"n\">hi</span><span class=\"o\">,</span> <span class=\"n\">fin_cases</span> <span class=\"n\">i</span><span class=\"bp\">;</span> <span class=\"kd\">by</span> <span class=\"n\">positivity</span><span class=\"o\">))</span>\n</code></pre></div>",
        "id": 291758687,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1659469330
    },
    {
        "content": "<p>it does not work in the example above, but in my real-world problem</p>",
        "id": 291758791,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1659469384
    },
    {
        "content": "<p>It'd be interesting to have that real-world problem simplified to a test case, if you get the time.</p>",
        "id": 291758870,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1659469433
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.big_operators.order</span>\n<span class=\"kn\">import</span> <span class=\"n\">tactic.positivity</span>\n<span class=\"kn\">import</span> <span class=\"n\">analysis.normed_space.basic</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">normed_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">R</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">ι</span><span class=\"o\">}</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"n\">s.prod</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">),</span> <span class=\"bp\">∥</span><span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"bp\">∥</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">positivity</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"n\">s.prod</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">),</span> <span class=\"bp\">∥</span><span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"bp\">∥</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">refine</span> <span class=\"o\">(</span><span class=\"n\">finset.prod_nonneg</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">positivity</span><span class=\"o\">)),</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>positivity does not do anything fancy here of course</p>",
        "id": 291759157,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1659469590
    },
    {
        "content": "<p>but it is so tedious in actual proofs to golf it to</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"n\">s.prod</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">),</span> <span class=\"bp\">∥</span><span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"bp\">∥</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">finset.prod_nonneg</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">norm_nonneg</span> <span class=\"n\">_</span><span class=\"o\">))</span>\n</code></pre></div>",
        "id": 291759279,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1659469676
    },
    {
        "content": "<p>I think maybe the naively-implemented <code>finset.prod_nonneg</code> tactic extension would work here.  I can try it, or if you're interested in trying it I can help you :)</p>",
        "id": 291759610,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1659469847
    },
    {
        "content": "<p>I think that Moritz's solution is the correct one for preserving the concept of \"syntactically obvious nonnegativity\" <span class=\"user-mention\" data-user-id=\"260507\">@Heather Macbeth</span> ; you wouldn't expect such a proof to go by cases on all the values in the set. The only exception to this would be if the new hypothesis <code>i \\in s</code> implies a nonnegativity assumption like <code>0 &lt;= i</code> that is then used to prove the goal is nonnegative; although <code>positivity</code> does pick up hypotheses it doesn't do any fancy reduction on them besides that norm_num stuff for 3 &lt;= i</p>",
        "id": 291772675,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659476542
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/239415-metaprogramming-.2F-tactics/topic/New.20tactic.3A.20.60positivity.60/near/291772675\">said</a>:</p>\n<blockquote>\n<p>The only exception to this would be if the new hypothesis <code>i \\in s</code> implies a nonnegativity assumption like <code>0 &lt;= i</code> that is then used to prove the goal is nonnegative; although <code>positivity</code> does pick up hypotheses it doesn't do any fancy reduction on them besides that norm_num stuff for 3 &lt;= i</p>\n</blockquote>\n<p>I've already seen cases where <code>positivity</code> fails because one has a goal or hypothesis which is defeq to something relevant to <code>positivity</code>, but not syntactically equal:<br>\n<a href=\"https://github.com/leanprover-community/mathlib/pull/15701#discussion_r935073747\">https://github.com/leanprover-community/mathlib/pull/15701#discussion_r935073747</a><br>\nThe hypothetical situation where <code>i \\in s</code> dsimps to e.g. <code>7 ≤ i</code> would be another such.  But I agree this is not in scope for <code>positivity</code>.</p>",
        "id": 291776026,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1659478522
    },
    {
        "content": "<p>One option would be to give <code>positivity</code> a <code>discharger</code> config option which would let people put some <code>simp</code> call there</p>",
        "id": 291776925,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659479143
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/239415-metaprogramming-.2F-tactics/topic/New.20tactic.3A.20.60positivity.60/near/291776925\">said</a>:</p>\n<blockquote>\n<p>One option would be to give <code>positivity</code> a <code>discharger</code> config option which would let people put some <code>simp</code> call there</p>\n</blockquote>\n<p>Following on from our previous discussion, probably <code>linarith</code> would be a popular discharger, if the option were available.</p>",
        "id": 291777051,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1659479211
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/239415-metaprogramming-.2F-tactics/topic/New.20tactic.3A.20.60positivity.60/near/291776925\">said</a>:</p>\n<blockquote>\n<p>One option would be to give <code>positivity</code> a <code>discharger</code> config option which would let people put some <code>simp</code> call there</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> I'm not sure this one is a classic \"discharger\".  The simp call would happen in the middle of the tactic, not at the end.</p>",
        "id": 291783204,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1659483403
    },
    {
        "content": "<p>yes, that's what dischargers are usually for</p>",
        "id": 291783248,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659483439
    },
    {
        "content": "<p>if you can do it before calling the tactic, you wouldn't need the discharger</p>",
        "id": 291783267,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659483456
    },
    {
        "content": "<p>Here are a couple of examples of what it would need to do: one adapted from the discussion on <a href=\"https://github.com/leanprover-community/mathlib/pull/15701\">#15701</a> I referenced, one adapted from Moritz' situation.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.group_with_zero.power</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.big_operators.order</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.fin.interval</span>\n<span class=\"kn\">import</span> <span class=\"n\">tactic.positivity</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">big_operators</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"bp\">∏</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"mi\">10</span><span class=\"o\">)</span> <span class=\"k\">in</span> <span class=\"n\">finset.Ioi</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"mi\">3</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">apply</span> <span class=\"n\">finset.prod_pos</span><span class=\"o\">,</span>\n  <span class=\"n\">intros</span> <span class=\"n\">i</span> <span class=\"n\">hi</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">finset.mem_range</span><span class=\"o\">,</span> <span class=\"n\">fin.lt_iff_coe_lt_coe</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hi</span><span class=\"o\">,</span>\n  <span class=\"n\">positivity</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">linear_ordered_field</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">ε</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"bp\">|</span><span class=\"n\">x</span><span class=\"bp\">|</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">ε_pos</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">ε</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">ε</span><span class=\"o\">)</span> <span class=\"n\">ε</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">ε</span> <span class=\"bp\">/</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"bp\">|</span><span class=\"n\">x</span><span class=\"bp\">|</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">ε_pos</span><span class=\"o\">,</span>\n  <span class=\"n\">positivity</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 291783286,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1659483474
    },
    {
        "content": "<p>but this finsum example requires doing the simplification on a hypothesis that hasn't been introduced yet before calling <code>positivity</code></p>",
        "id": 291783342,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659483501
    },
    {
        "content": "<p>I'm imagining that you would use <code>simp [finset.mem_range, fin.lt_iff_coe_lt_coe] at *</code> as the discharger here</p>",
        "id": 291783412,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659483555
    },
    {
        "content": "<p>and it would be called whenever something new is added to the context (so once at the start and once after the finsum theorem application)</p>",
        "id": 291783545,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659483653
    },
    {
        "content": "<p>That's different, then, from what I was imagining with having linarith as a \"discharger\": for that one (which I think is more commonly useful?) you would add a <code>linarith</code> call at this line:<br>\n<a href=\"https://github.com/leanprover-community/mathlib/blob/777082da584ee55c55d6f2da1ec428004d9e0999/src/tactic/positivity.lean#L145\">https://github.com/leanprover-community/mathlib/blob/777082da584ee55c55d6f2da1ec428004d9e0999/src/tactic/positivity.lean#L145</a></p>",
        "id": 291783994,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1659484041
    },
    {
        "content": "<p>yeah I noticed that as well. <code>linarith</code> wants to operate on the goal, so it would make sense to run that on every subterm</p>",
        "id": 291784989,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659484842
    },
    {
        "content": "<p>but gosh that sounds expensive</p>",
        "id": 291785032,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659484877
    },
    {
        "content": "<p>What might make sense is to have a self-replacing tactic, <code>positivity!</code>, which tries running <code>linarith</code> on every subterm where it gets stuck, and then reports \"Try this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"bp\">***</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">linarith</span><span class=\"o\">,</span>\n<span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"bp\">***</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">linarith</span><span class=\"o\">,</span>\n<span class=\"n\">positivity</span><span class=\"o\">,</span>\n</code></pre></div>",
        "id": 291785172,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1659485017
    },
    {
        "content": "<p>also, you could do like linarith itself and have <code>positivity [a, b, c]</code> be shorthand for <code>have := a, have := b, have := c, positivity</code></p>",
        "id": 291785252,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659485079
    },
    {
        "content": "<p>eh actually that's awkward since it would have to be <code>positivity [show ***, by linarith, ...]</code></p>",
        "id": 291785284,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659485122
    },
    {
        "content": "<p><code>mono</code> actually uses the same syntax for a different purpose:  you use it to ask for things and they then are left later as goals.</p>",
        "id": 291785430,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1659485261
    },
    {
        "content": "<p>So the mono-inspired syntax for</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">linarith</span><span class=\"o\">,</span>\n<span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">c</span> <span class=\"bp\">&lt;</span> <span class=\"n\">d</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">linarith</span><span class=\"o\">,</span>\n<span class=\"n\">positivity</span>\n</code></pre></div>\n<p>would be</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">positivity</span> <span class=\"k\">with</span> <span class=\"o\">[</span><span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">c</span> <span class=\"bp\">&lt;</span> <span class=\"n\">d</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">linarith</span>\n</code></pre></div>\n<p>where <code>linarith</code> is proving <code>a &lt; b</code> and <code>c &lt; d</code>.</p>",
        "id": 291785491,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1659485324
    },
    {
        "content": "<p>(Although I'm not sure I like this <code>mono</code> syntax, precisely because it conflicts with the <code>linarith</code> syntax!)</p>",
        "id": 291785508,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1659485353
    },
    {
        "content": "<p>yeah, I would write that as <code>positivity [(_ : a &lt; b), (_ : c &lt; d)]</code> instead</p>",
        "id": 291785833,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659485678
    },
    {
        "content": "<p>At that point, not so much less less wordy than</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">c</span> <span class=\"bp\">&lt;</span> <span class=\"n\">d</span> <span class=\"o\">:=</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">positivity</span>\n</code></pre></div>",
        "id": 291786010,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1659485821
    },
    {
        "content": "<p>Which is to say: I rarely use <code>linarith [***]</code>, in practice I just do <code>have := ***, linarith</code> which lets me check that the term I'm constructing is well-formed.  I expect that in the same way I would rarely use the syntax <code>positivity [***]</code> if it were implemented.</p>",
        "id": 291786252,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1659486016
    },
    {
        "content": "<p>But, other people's workflow might be different from mine!</p>",
        "id": 291786263,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1659486027
    },
    {
        "content": "<p>does that actually work? The goals probably come out in the wrong order that way</p>",
        "id": 291787535,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659487210
    },
    {
        "content": "<p>To make this more concrete:  We're talking about more ergonomic syntax for</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic.positivity</span>\n<span class=\"kn\">import</span> <span class=\"n\">tactic.linarith</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h3</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">&lt;</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">c</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">linarith</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">c</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">linarith</span><span class=\"o\">,</span>\n  <span class=\"n\">positivity</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>Right?</p>",
        "id": 291787679,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1659487399
    },
    {
        "content": "<p>I mean with the underscores</p>",
        "id": 291787849,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659487571
    },
    {
        "content": "<p>This does work (although I don't necessarily think it's an improvement):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n<span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">c</span> <span class=\"o\">:=</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n<span class=\"n\">positivity</span><span class=\"o\">,</span>\n<span class=\"n\">all_goals</span> <span class=\"o\">{</span> <span class=\"n\">linarith</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 291787877,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1659487598
    },
    {
        "content": "<p>I would expect that <code>positivity [(_ : a &lt; b), (_ : c &lt; d)]</code> would close the main goal and yield the subgoals <code>a &lt; b</code> and <code>c &lt; d</code> in that order</p>",
        "id": 291787884,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659487611
    },
    {
        "content": "<p>This seems like a reasonable behaviour to me, but maybe we should wait to hear from people who expect they would use that syntax variant if it were implemented.</p>",
        "id": 291788109,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1659487839
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"260507\">Heather Macbeth</span> <a href=\"#narrow/stream/239415-metaprogramming-.2F-tactics/topic/New.20tactic.3A.20.60positivity.60/near/291757634\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"412682\">Moritz Doll</span> Thanks for the idea!  <code>finset.prod_nonneg</code> should be an easy addition, similar to <a href=\"https://leanprover-community.github.io/mathlib_docs/find/tactic.positivity_sqrt\">docs#tactic.positivity_sqrt</a> or or <a href=\"https://leanprover-community.github.io/mathlib_docs/find/tactic.positivity_mul\">docs#tactic.positivity_mul</a>, do you want me to add it or would you like to try yourself?</p>\n</blockquote>\n<p>I am very tempted to look into tactic-writing more seriously, but I think I have to be responsible and not overload myself with Lean projects. If you don't get around doing it, then I might look into it in a few weeks.</p>",
        "id": 291902455,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1659551970
    },
    {
        "content": "<p>What is the reason that <code>positivity</code> implements these meta definitions and not use flags similar to <code>continuity</code> or <code>ext</code>?</p>",
        "id": 292228430,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1659754269
    },
    {
        "content": "<p>because it's not just throwing a list of lemmas at the goal, it has custom methods for how to combine &lt; or &lt;= subgoals</p>",
        "id": 292228521,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659754389
    },
    {
        "content": "<p>in that respect it's a bit more architecturally similar to <code>norm_num</code>, which also uses custom tactics in its extension point</p>",
        "id": 292228598,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659754476
    },
    {
        "content": "<p>Note that every new tactic or extension of tactics written in Lean 3 makes the port to lean 4 harder.</p>",
        "id": 292244263,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1659777911
    },
    {
        "content": "<p>To be honest, I think there should be a deadline for new meta-programming in mathlib and it should have probably been over a few week ago.</p>",
        "id": 292245485,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1659779628
    },
    {
        "content": "<p>That's silly. We can port tactics 20 times faster than we can come up with interesting new ones</p>",
        "id": 292245542,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659779671
    },
    {
        "content": "<p>I'd rather not stand in the way of people with good ideas</p>",
        "id": 292245562,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659779708
    },
    {
        "content": "<p>What happened to all the tactics that were ported in Providence?</p>",
        "id": 292245579,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1659779738
    },
    {
        "content": "<p>about 70% of them got merged and the other 30% still need review or have outstanding issues</p>",
        "id": 292245649,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659779801
    },
    {
        "content": "<p>as always, reviews are great</p>",
        "id": 292245660,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659779817
    },
    {
        "content": "<p>there haven't been too many submitted since then, though</p>",
        "id": 292245680,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659779870
    },
    {
        "content": "<p>Maybe it would be nice to update the list of targets. I guess there is no remaining easy ones, but you flag the easiest medium ones.</p>",
        "id": 292245735,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1659779919
    },
    {
        "content": "<p>Maybe medium is the new easy? You can rebrand!</p>",
        "id": 292246683,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1659781315
    },
    {
        "content": "<p>Re: porting tactics. I definitely trust Mario's judgement on this over my own so am happy to retract my original claim (I guess it's literally true but he's suggesting it's not true enough to be relevant)</p>",
        "id": 292246766,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1659781415
    },
    {
        "content": "<p>Some more extensions of positivity that I would like to see:<br>\n(a) <code>has.abs</code>: should be very similar to the norm, I don't have any applications for that at the moment, so I would leave that for someone else<br>\n(b) <code>rpow</code>: this I might actually try to do myself, but if someone else wants to do it I would be really happy, too</p>",
        "id": 298202218,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1662871023
    },
    {
        "content": "<p>(a) <a href=\"https://leanprover-community.github.io/mathlib_docs/find/tactic.positivity_abs\">docs#tactic.positivity_abs</a><br>\n(b) I had already started an extension for the missing exponentiations, so I will finish it</p>",
        "id": 298234304,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1662893265
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/239415-metaprogramming-.2F-tactics/topic/New.20tactic.3A.20.60positivity.60/near/292228521\">said</a>:</p>\n<blockquote>\n<p>because it's not just throwing a list of lemmas at the goal, it has custom methods for how to combine &lt; or &lt;= subgoals</p>\n</blockquote>\n<p>Is the custom method ever more than \"pick between tagged lemmas that have arguments of the right type\" could achieve?</p>",
        "id": 298244025,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1662898978
    },
    {
        "content": "<p>That sure would make it much more user-friendly. The core tactic does very much look like <code>norm_num</code>, but the extensions are no more than lemma tagging in essence.</p>",
        "id": 298246390,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1662900285
    },
    {
        "content": "<p>The only advantage I can see with this custom approach is that we get to decide in what order lemmas are tried and when to weaken <code>0 &lt; a</code> to <code>0 ≤ a</code> (this to avoid branching). Not sure whether that noticeably improves performance.</p>",
        "id": 298246561,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1662900373
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/pull/16462\">#16462</a> for real powers</p>",
        "id": 298247222,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1662900794
    },
    {
        "content": "<p>note: some things don't work for strict positivity on ℝ≥0 because we don't have a <code>linear_ordered_semifield</code> instance, so this should be added to some generic TODO list.</p>",
        "id": 298253583,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1662904487
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/nnreal.canonically_linear_ordered_semifield\">docs#nnreal.canonically_linear_ordered_semifield</a> <span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span></p>",
        "id": 298253721,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1662904577
    },
    {
        "content": "<p>I did some homework over the holidays.</p>",
        "id": 298253737,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1662904610
    },
    {
        "content": "<p>Nice, I had just checked this a week or so ago and filed it away in the back of my head as something to do! Is this a new feature akin to Yaël search? Yaël mindread?</p>",
        "id": 298254858,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1662905339
    },
    {
        "content": "<p>That actually dates from <a href=\"https://github.com/leanprover-community/mathlib/pull/16307\">#16307</a>, 10 days ago.</p>",
        "id": 298254995,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1662905421
    },
    {
        "content": "<p>Yaël comes with many functions and capabilities, but most importantly can be extended using a comprehensive metaprogramming framework.</p>",
        "id": 298255108,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1662905491
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/239415-metaprogramming-.2F-tactics/topic/New.20tactic.3A.20.60positivity.60/near/298244025\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/239415-metaprogramming-.2F-tactics/topic/New.20tactic.3A.20.60positivity.60/near/292228521\">said</a>:</p>\n<blockquote>\n<p>because it's not just throwing a list of lemmas at the goal, it has custom methods for how to combine &lt; or &lt;= subgoals</p>\n</blockquote>\n<p>Is the custom method ever more than \"pick between tagged lemmas that have arguments of the right type\" could achieve?</p>\n</blockquote>\n<p>Yes, in particular they will generally encode a particular order of evaluation which minimizes the need to search for proofs that are either useless or will be subsumed by a stronger result. Maybe more important than the performance is that it allows the user to predict when the tactic will fail and what to do if it does fail, which I consider a very important property of tactics which is lost in the more kitchen-sink style tactics.</p>",
        "id": 298303429,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1662946427
    },
    {
        "content": "<p>Here's a PR that aims at slightly improving the capabilities of <code>positivity</code>: <a href=\"https://github.com/leanprover-community/mathlib/pull/16483\">#16483</a></p>",
        "id": 298408461,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1662997509
    },
    {
        "content": "<p>On its own, it is a light postprocessing to handle goals of the form <code>a ≠ 0</code> and <code>0 ≠ a</code> by first trying to prove <code>0 &lt; a</code>. But my greater hope is to fully handle nonzeroness assumptions because</p>\n<ul>\n<li>They are often side goals of order lemmas</li>\n<li>They fit in the same framework as nonnegativity and positivity assumptions</li>\n</ul>",
        "id": 298409003,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1662997702
    },
    {
        "content": "<p>And here's the full PR: <a href=\"https://github.com/leanprover-community/mathlib/pull/16529\">#16529</a> (+431, -149)</p>",
        "id": 299170621,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1663338046
    },
    {
        "content": "<p>Now, <a href=\"https://github.com/leanprover-community/mathlib/blob/positivity_nonzero/test/positivity.lean#L60-L96\">all those tests</a> work out of the box.</p>",
        "id": 299170632,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1663338049
    },
    {
        "content": "<p>Thanks again for this tactic. Now that my <code>positivity</code> extensions went through, <a href=\"https://github.com/leanprover-community/mathlib/commit/80f2aaed8fda63eb7a96b66b683e5fecb3e1d511\">I could update SRL to use it</a> and it makes proofs much more readable.</p>",
        "id": 300565922,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1664041288
    },
    {
        "content": "<p>Nice!  These are exactly the kinds of use cases I had in mind.</p>",
        "id": 300575304,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1664047208
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> Would you be interested in trying out my work-in-progress tactic <a href=\"https://github.com/hrmacbeth/math2001/blob/edc8fed22e6a8f600974c081fc858d585399ff2e/src/tactics/inequalities.lean#L119\"><code>ineq_congr</code></a> on parts of this argument?  It should deal with some of the <code>mul_le_mul_of_nonneg_left</code> and similar.</p>",
        "id": 300576208,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1664047834
    },
    {
        "content": "<p>This is supposed to be a tactic which turns a goal state</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span>\n<span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"mi\">3</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">c</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">c</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">y</span>\n</code></pre></div>\n<p>to the goal state</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span>\n<span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"mi\">3</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">y</span>\n</code></pre></div>\n<p>(so it's kind of a cousin of <a href=\"https://leanprover-community.github.io/mathlib_docs/tactics.html#mono\">tactic#mono</a>)</p>",
        "id": 300576833,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1664048328
    },
    {
        "content": "<p>Absolutely! I could feel that my uses of <code>positivity</code> were what you expected so I was hoping your fancy new tactic would help further.</p>",
        "id": 300579221,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1664050144
    },
    {
        "content": "<p>Great.  Looking forward to your experiments!</p>",
        "id": 300579361,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1664050251
    },
    {
        "content": "<p>My hope a year ago was to get SRL merged rather quickly (what a dream...). Now I see it's a perfect test case for automation, especially those two ugly files that pile up calculations.</p>",
        "id": 300579418,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1664050285
    },
    {
        "content": "<p>So I am now seeking to shorten the proof significantly by writing more automation (hence the many <code>positivity</code> extensions I PRed recently).</p>",
        "id": 300579531,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1664050354
    },
    {
        "content": "<p>What does the Isabelle version look like? Do they have some of this automation already?</p>",
        "id": 300579533,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1664050355
    },
    {
        "content": "<p>It's an unfair comparison because the version of SRL they formalised only needs a watered down version of those calculations.</p>",
        "id": 300583166,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1664053654
    },
    {
        "content": "<p><a href=\"https://www.isa-afp.org/theories/szemeredi_regularity/#Szemeredi.html#Szemeredi.exists_refinement|fact\">This Isabelle lemma</a> roughly corresponds to our two files <a href=\"https://github.com/leanprover-community/mathlib/tree/szemeredi/src/combinatorics/szemeredi/chunk.lean\"><code>chunk</code></a> and <a href=\"https://github.com/leanprover-community/mathlib/tree/szemeredi/src/combinatorics/szemeredi/increment.lean\"><code>increment</code></a></p>",
        "id": 300583841,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1664054265
    },
    {
        "content": "<p>By the way, is <code>ineq_congr</code> meant to be \"fancy\"? That is, will it leave a possibly changing goal and thus should only be followed by other \"fancy\" tactics like <code>simp</code> and <code>linarith</code>?</p>",
        "id": 300584816,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1664054914
    },
    {
        "content": "<p>I don't follow, sorry, what do you mean by \"a possibly changing goal\"?</p>",
        "id": 300585707,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1664055405
    },
    {
        "content": "<p>I think Yaël means that \"fancy\" tactics have output which might change with different versions of mathlib (like <code>simp</code> with a changing <code>simp</code> set), and we generally recommend that such tactics should only be followed by other fancy tactics. Whereas <code>refine</code> would be a \"simple\" tactic, and a tactic sequence like <code>simp, refine</code> would be prone to breakage.</p>",
        "id": 300595123,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1664065232
    },
    {
        "content": "<p>I don't know what instantiating mvars is, sorry!</p>",
        "id": 300662577,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1664119408
    },
    {
        "content": "<p>Yes, that's almost certainly an instantiated metavariable issue.</p>\n<p>Metavariables are the <code>?m_1</code> terms that show up inside expressions. They represent parts of the proof that have not been completed yet. When you do something to determine the value of the metavariable, it is \"assigned\", but this doesn't go looking everywhere for occurrences of that metavariable to replace them with the resulting value, both because it would be too expensive and because it's not even possible in a functional language like lean, the <code>expr</code> you have is immutable even in the face of changes to the assignments. Instead, these assignments are just stored in some state on the side (it's in the <code>tactic_state</code>), and the pretty printer will print the value of an assigned metavariable instead of <code>?m_1</code> if it sees one, so it provides the appearance of having replaced the value everywhere.</p>\n<p>There is a function <code>instantiate_mvars</code> which given an expression will replace all assigned metavars with their assignments. The recurring bug that you find in tactics that forget to call this function is that if you pattern match on an expression hoping that it is of the form <code>x = y</code>, but it is actually of the form <code>?m_1</code> where <code>?m_1 := x = y</code>, then the match will fail and the user will get a confusing error message saying it's not an equality when it clearly is. The solution is to call <code>instantiate_mvars</code> before the match.</p>\n<p>You might think we can try to preserve the property that all goals have instantiated mvars, but it's too computationally expensive to do so all the time (it requires a traversal of the expression), so instead we just do it at <code>whnf</code> and when matching expressions.</p>",
        "id": 300663951,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1664120361
    },
    {
        "content": "<p>Mario's answer clarified some doubts that I had.  If you want to see how Floris's suggestions fixed a similar bug that I had, see <a href=\"#narrow/stream/113488-general/topic/debugging.20.60compute_degree_le.60\">here</a>.  In particular, if you match on a <code>target</code>, you probably want to <code>instantiate_mvars</code> first (or, if I understand correctly what Mario says, maybe simply <code>whnf</code> it first).</p>",
        "id": 300664401,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1664120644
    },
    {
        "content": "<p>If I were to guess, the issue is</p>\n<p><a href=\"https://github.com/leanprover-community/mathlib/blob/fb2a4c77c1361a433386cec60c0d593a9ca57f94/src/tactic/positivity.lean#L207-L208\">https://github.com/leanprover-community/mathlib/blob/fb2a4c77c1361a433386cec60c0d593a9ca57f94/src/tactic/positivity.lean#L207-L208</a></p>\n<p>Try adding <code>t ← instantiate_mvars t,</code> in-between those two lines.  <em>Maybe</em> this fixes your issue.</p>",
        "id": 300665532,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1664121339
    },
    {
        "content": "<p>Yes, that looks like the right place. (or the golfing version <code>t &lt;- target &gt;&gt;= instantiate_mvars,</code>)</p>",
        "id": 300665688,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1664121428
    },
    {
        "content": "<p>Edit: this is incorrect, see Mario's comment below.<br>\n(You might get away with simply <code>t ← whnf t</code>, if I understood correctly what Mario said.)</p>",
        "id": 300665711,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1664121444
    },
    {
        "content": "<p>no, <code>whnf</code> wouldn't be the right thing to do here since it would unfold things like <code>0 &lt;= t</code> to <code>nat.le 0 t</code> which would make the match fail</p>",
        "id": 300665745,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1664121481
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> Is the word \"possible\" missing from <a href=\"https://github.com/leanprover-community/mathlib/blob/fb2a4c77c1361a433386cec60c0d593a9ca57f94/src/tactic/positivity.lean#L234\">this line</a>?</p>",
        "id": 300667660,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1664122593
    },
    {
        "content": "<p>That's , indeed! <span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span></p>",
        "id": 300667691,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1664122625
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/239415-metaprogramming-.2F-tactics/topic/New.20tactic.3A.20.60positivity.60/near/300665688\">said</a>:</p>\n<blockquote>\n<p>Yes, that looks like the right place. (or the golfing version <code>t &lt;- target &gt;&gt;= instantiate_mvars,</code>)</p>\n</blockquote>\n<p>Does that mean that we basically never use <code>target</code> but rather always <code>target &gt;&gt;= instantiate_mvars</code>? Does this exist as a def then?</p>",
        "id": 300667931,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1664122783
    },
    {
        "content": "<p>no, it's only if you want to do matching on the target that you would do this</p>",
        "id": 300668003,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1664122810
    },
    {
        "content": "<p>and it's not just the target that you might want to match, the same issue can happen with the types of hypotheses in the local context</p>",
        "id": 300668046,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1664122841
    },
    {
        "content": "<p>Hmm, that happens quite a lot in the core <code>positivity</code> tactics, right?</p>",
        "id": 300668096,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1664122883
    },
    {
        "content": "<p>yes, but you only have to do it once since <code>instantiate_mvars</code> recursively traverses the term</p>",
        "id": 300668135,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1664122917
    },
    {
        "content": "<p>If you call on the target it doesn't traverse the hypotheses, though?</p>",
        "id": 300668210,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1664122949
    },
    {
        "content": "<p><code>instantiate_mvars</code> just works on an expr</p>",
        "id": 300668257,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1664122989
    },
    {
        "content": "<p>it doesn't change the goal state</p>",
        "id": 300668276,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1664123002
    },
    {
        "content": "<p>I thought as much</p>",
        "id": 300668474,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1664123109
    },
    {
        "content": "<p>I opened a PR to fix this issue: <a href=\"https://github.com/leanprover-community/mathlib/pull/16647\">#16647</a>.</p>",
        "id": 300728093,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1664175297
    },
    {
        "content": "<p>With the current <code>master</code> version of <code>positivity</code>, this happens:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic.positivity</span>\n\n<span class=\"c1\">--  works</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">refine</span> <span class=\"n\">le_trans</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">positivity</span><span class=\"o\">)</span> <span class=\"n\">le_rfl</span>\n\n<span class=\"c1\">--  fails</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">apply</span> <span class=\"n\">le_trans</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">positivity</span><span class=\"o\">)</span> <span class=\"n\">le_rfl</span>\n</code></pre></div>\n<p><del>Both work after the PR.</del>  EDIT: Actually, in this compacted form, the <code>apply</code> still does not work.</p>\n<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span>: I hope that this fixes your case as well!  Let me know if it does not.</p>",
        "id": 300728200,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1664175355
    },
    {
        "content": "<p>Ok, this is what actually happens after the current PR:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">--  works after the PR, does not work before the PR</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">apply</span> <span class=\"n\">le_trans</span> <span class=\"n\">_</span> <span class=\"n\">le_rfl</span><span class=\"o\">,</span>\n  <span class=\"n\">positivity</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"c1\">--  fails, before and after the PR</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">apply</span> <span class=\"n\">le_trans</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">positivity</span><span class=\"o\">)</span> <span class=\"n\">le_rfl</span>\n</code></pre></div>",
        "id": 300729382,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1664175944
    },
    {
        "content": "<p>Is there a way to make the last example work, or is this precisely a place where the difference between <code>apply</code> and <code>refine</code> should show up?</p>",
        "id": 300729814,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1664176181
    },
    {
        "content": "<p>Can you try whether <code>rw</code> does any better?</p>",
        "id": 300733721,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1664178019
    },
    {
        "content": "<p>Do you mean <code>rw (by &lt;something involving positivity&gt;)</code>?</p>",
        "id": 300734019,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1664178151
    },
    {
        "content": "<p>In fact, if you have an example of something that currently does not work, I am happy to try it with the fix in the PR.</p>",
        "id": 300734445,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1664178356
    },
    {
        "content": "<p>No I mean use <code>rw</code> instead of <code>positivity</code> in the example that still fails to see whether this is an inherent limitation due to <code>apply</code> or whether <code>positivity</code> is still botched.</p>",
        "id": 300736257,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1664179243
    },
    {
        "content": "<p>Or any other tactic that we know to not have problems with metavariables</p>",
        "id": 300736343,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1664179282
    },
    {
        "content": "<p>Ok, I understand now what you had in mind.</p>\n<p>This is the response:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">--  fails</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">apply</span> <span class=\"n\">le_trans</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">add_zero</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"n\">le_rfl</span>\n\n<span class=\"c1\">--  works</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">apply</span> <span class=\"n\">le_trans</span> <span class=\"n\">_</span> <span class=\"n\">le_rfl</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">add_zero</span> <span class=\"mi\">0</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>So I am guessing that the inlined version with <code>apply ... (by positivity) ...</code> is not meant to work.</p>",
        "id": 300736836,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1664179488
    },
    {
        "content": "<p>Just a heads up that <code>positivity</code> now reasons on assumptions of type <code>a ≠ 0</code> as well thanks to <a href=\"https://github.com/leanprover-community/mathlib/pull/16529\">#16529</a>. This is very useful when a function is positive on both positive and negative inputs, like <code>abs</code>.</p>",
        "id": 302489895,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1664985592
    }
]
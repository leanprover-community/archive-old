[
    {
        "content": "<p>I've stubbed out <code>soft_truncation'</code> in <code>src/system_of_complexes/soft_truncation.lean</code>.</p>",
        "id": 228652353,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614799742
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130384\">@Riccardo Brasca</span> once you have the universal property for the quotient, we should also bundle the quotient into a <code>NormedGroup</code> and then most of the sorrys in that file should be \"easy\" to fill in.</p>",
        "id": 228652499,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614799800
    },
    {
        "content": "<p>Good! I hope this will not take too much</p>",
        "id": 228654634,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1614800538
    },
    {
        "content": "<p>Is this <code>(S : add_subgroup M) [is_closed (↑S : set M)]</code> the correct way of stating that <code>S</code> is closed in <code>M</code>?</p>",
        "id": 228655448,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1614800868
    },
    {
        "content": "<p>I don't think that <code>is_closed</code> is a class, so it should be <code>(hS : ...)</code> instead of <code>[]</code></p>",
        "id": 228655574,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614800907
    },
    {
        "content": "<p>Do we know that the closure of a subgroup of a normed group is again a <del>subgroup</del> sub<code>NormedGroup</code>?</p>",
        "id": 228659892,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614802427
    },
    {
        "content": "<p>This must be in mathlib right?</p>",
        "id": 228660226,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614802539
    },
    {
        "content": "<p>For the submodule version, <a href=\"https://leanprover-community.github.io/mathlib_docs/find/submodule.topological_closure\">docs#submodule.topological_closure</a></p>",
        "id": 228661508,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1614803014
    },
    {
        "content": "<p>There is less API for subgroups than submodules, but it shouldn't be hard to adapt the proof.</p>",
        "id": 228661605,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1614803047
    },
    {
        "content": "<p>Note that you just need that it's a subgroup -- the normed structure follows <a href=\"https://leanprover-community.github.io/mathlib_docs/find/add_subgroup.normed_group\">docs#add_subgroup.normed_group</a></p>",
        "id": 228661829,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1614803125
    },
    {
        "content": "<p>But for the \"universal property\" you need the kernel to be closed, right?</p>",
        "id": 228662572,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614803409
    },
    {
        "content": "<p>Sorry, what I mean is that the quotient is a normed group only when the subgroup is closed.</p>",
        "id": 228662714,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614803462
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/267928-condensed-mathematics/topic/soft_truncation'/near/228659892\">said</a>:</p>\n<blockquote>\n<p>Do we know that the closure of a subgroup of a normed group is again a <del>subgroup</del> sub<code>NormedGroup</code>?</p>\n</blockquote>\n<p>I was responding to this part -- subgroup implies sub<code>NormedGroup</code>.</p>",
        "id": 228662824,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1614803504
    },
    {
        "content": "<p>Oh right, okay.</p>",
        "id": 228662854,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614803516
    },
    {
        "content": "<p>I modified the proof, and now we have a norm on the quotient by any closed subspace (in particular by the kernel), it the first lemma below.  If <code>is_closed</code> is not an instance, what I am supposed to write in <code>normed_group.mk</code> to let Lean know that  <code>(quotient S)</code> is a normed group?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- If `(m : M)` has norm equal to `0` in `quotient S` for a closed subgroup `S` of `M`, then</span>\n<span class=\"sd\">`m ∈ S`. -/</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">norm_zero_eq_zero</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">add_subgroup</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hS</span> <span class=\"o\">:</span> <span class=\"n\">is_closed</span> <span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">M</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∥</span><span class=\"o\">(</span><span class=\"n\">quotient_add_group.mk'</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"n\">m</span><span class=\"bp\">∥</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"bp\">∈</span> <span class=\"n\">S</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"sd\">/-- The norm on `quotient S` is actually a norm if `S` is a complete subgroup of `M`. -/</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">quotient.is_normed_group.core</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">add_subgroup</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hS</span> <span class=\"o\">:</span> <span class=\"n\">is_closed</span> <span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">M</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n  <span class=\"n\">normed_group.core</span> <span class=\"o\">(</span><span class=\"n\">quotient</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"sd\">/-- An instance of `normed_group` on the quotient by a subgroup. -/</span>\n<span class=\"kd\">noncomputable</span>\n<span class=\"kd\">instance</span> <span class=\"n\">quotient_normed_group</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">add_subgroup</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hS</span> <span class=\"o\">:</span> <span class=\"n\">is_closed</span> <span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">M</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n  <span class=\"n\">normed_group</span> <span class=\"o\">(</span><span class=\"n\">quotient</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">normed_group.of_core</span> <span class=\"o\">(</span><span class=\"n\">quotient</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">quotient.is_normed_group.core</span> <span class=\"n\">S</span> <span class=\"n\">hS</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- The canonical morphism `M → (quotient S)` as morphism of normed groups. -/</span>\n<span class=\"kd\">noncomputable</span>\n<span class=\"kd\">def</span> <span class=\"n\">normed_group.mk</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">add_subgroup</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hS</span> <span class=\"o\">:</span> <span class=\"n\">is_closed</span> <span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">M</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n  <span class=\"n\">normed_group_hom</span> <span class=\"n\">M</span> <span class=\"o\">(</span><span class=\"n\">quotient</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">bound'</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"n\">one_mul</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">norm_mk_le</span> <span class=\"n\">_</span> <span class=\"n\">m</span><span class=\"o\">⟩,</span>\n  <span class=\"bp\">..</span><span class=\"n\">quotient_add_group.mk'</span> <span class=\"n\">S</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 228665519,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1614804561
    },
    {
        "content": "<p>I added the <code>has_shift</code> instance that was mentioned as a <code>TODO</code> in this file..</p>",
        "id": 228669312,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614805953
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130384\">@Riccardo Brasca</span> what I envisioned in my ccomments above was to define <code>add_subgroup.closure</code>as a subgroup again, and take the quotient by that.</p>",
        "id": 228669921,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614806185
    },
    {
        "content": "<p>Maybe we should introduce <code>closed_add_subgroup</code> extending <code>add_subgroup</code>?</p>",
        "id": 228670922,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614806622
    },
    {
        "content": "<p>Ah you're right, it's probably the best thing to do!</p>",
        "id": 228671235,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1614806730
    },
    {
        "content": "<p>I have the impression that, categorically, the quotient exist by any subgroup, and it is the quotient by the closure</p>",
        "id": 228671440,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1614806808
    },
    {
        "content": "<p>Yes that's right</p>",
        "id": 228671462,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614806819
    },
    {
        "content": "<p>The quotient by the closure is the largest quotient which is a normed group</p>",
        "id": 228671515,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614806835
    },
    {
        "content": "<p>In any case, making <code>closed_add_subgroup</code> should be straightforward enough, even with a small API. We can then define the <code>closure</code> function as a function from <code>add_subgroup</code> to <code>closed_add_subgroup</code>, etc.</p>",
        "id": 228671700,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614806903
    },
    {
        "content": "<p>There is even a Galois insertion between the two!</p>",
        "id": 228671716,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614806911
    },
    {
        "content": "<p>I think I will stop for today, but if you want to continue feel free to use my proof</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- If `(m : M)` has norm equal to `0` in `quotient S` for a closed subgroup `S` of `M`, then</span>\n<span class=\"sd\">`m ∈ S`. -/</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">norm_zero_eq_zero</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">add_subgroup</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hS</span> <span class=\"o\">:</span> <span class=\"n\">is_closed</span> <span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">M</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∥</span><span class=\"o\">(</span><span class=\"n\">quotient_add_group.mk'</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"n\">m</span><span class=\"bp\">∥</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"bp\">∈</span> <span class=\"n\">S</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">choose</span> <span class=\"n\">g</span> <span class=\"n\">hg</span> <span class=\"n\">using</span> <span class=\"bp\">λ</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">norm_mk_lt'</span> <span class=\"n\">S</span> <span class=\"n\">m</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">nat.one_div_pos_of_nat</span> <span class=\"n\">ℝ</span> <span class=\"n\">_</span> <span class=\"n\">n</span><span class=\"o\">)),</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">one_div</span><span class=\"o\">,</span> <span class=\"n\">zero_add</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hg</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">hconv</span> <span class=\"o\">:</span> <span class=\"n\">filter.tendsto</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"n\">g</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">filter.at_top</span> <span class=\"o\">(</span><span class=\"n\">nhds</span> <span class=\"mi\">0</span><span class=\"o\">),</span>\n  <span class=\"o\">{</span> <span class=\"n\">refine</span> <span class=\"n\">metric.tendsto_at_top.2</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">ε</span> <span class=\"n\">hε</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n    <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">N</span><span class=\"o\">,</span> <span class=\"n\">hN</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">exists_nat_ge</span> <span class=\"n\">ε</span><span class=\"bp\">⁻¹</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"n\">Npos</span> <span class=\"o\">:=</span> <span class=\"n\">lt_of_lt_of_le</span> <span class=\"o\">(</span><span class=\"n\">inv_pos.mpr</span> <span class=\"n\">hε</span><span class=\"o\">)</span> <span class=\"n\">hN</span><span class=\"o\">,</span>\n    <span class=\"n\">replace</span> <span class=\"n\">hN</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">inv_le_inv</span> <span class=\"n\">Npos</span> <span class=\"o\">(</span><span class=\"n\">inv_pos.mpr</span> <span class=\"n\">hε</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"n\">hN</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">inv_inv'</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hN</span><span class=\"o\">,</span>\n    <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">N</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">n</span> <span class=\"n\">hn</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">dist_eq_norm</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">sub_zero</span><span class=\"o\">],</span>\n    <span class=\"k\">have</span> <span class=\"n\">npos</span> <span class=\"o\">:=</span> <span class=\"n\">lt_trans</span> <span class=\"o\">(</span><span class=\"n\">lt_of_lt_of_le</span> <span class=\"n\">Npos</span> <span class=\"o\">(</span><span class=\"n\">nat.cast_le.2</span> <span class=\"o\">(</span><span class=\"n\">ge.le</span> <span class=\"n\">hn</span><span class=\"o\">)))</span> <span class=\"o\">(</span><span class=\"n\">lt_add_one</span> <span class=\"n\">n</span><span class=\"o\">),</span>\n    <span class=\"n\">replace</span> <span class=\"n\">hn</span> <span class=\"o\">:=</span> <span class=\"n\">lt_of_le_of_lt</span> <span class=\"o\">(</span><span class=\"n\">ge.le</span> <span class=\"n\">hn</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">lt_add_one</span> <span class=\"n\">n</span><span class=\"o\">),</span>\n    <span class=\"k\">have</span> <span class=\"n\">hnε</span> <span class=\"o\">:=</span> <span class=\"n\">lt_of_lt_of_le</span> <span class=\"o\">((</span><span class=\"n\">inv_lt_inv</span> <span class=\"n\">npos</span> <span class=\"n\">Npos</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"o\">(</span><span class=\"n\">nat.cast_lt.2</span> <span class=\"n\">hn</span><span class=\"o\">))</span> <span class=\"n\">hN</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">lt_trans</span> <span class=\"o\">(</span><span class=\"n\">hg</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"n\">hnε</span> <span class=\"o\">},</span>\n  <span class=\"n\">replace</span> <span class=\"n\">hconv</span> <span class=\"o\">:=</span> <span class=\"n\">tendsto.add_const</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"n\">hconv</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">zero_add</span><span class=\"o\">,</span> <span class=\"n\">add_neg_cancel_comm</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hconv</span><span class=\"o\">,</span>\n  <span class=\"n\">replace</span> <span class=\"n\">hS</span> <span class=\"o\">:=</span> <span class=\"n\">mem_of_is_seq_closed</span> <span class=\"o\">(</span><span class=\"n\">is_seq_closed_iff_is_closed.2</span> <span class=\"n\">hS</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">hg</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">hconv</span><span class=\"o\">,</span>\n  <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">hS</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 228672493,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1614807237
    },
    {
        "content": "<p>Which branch is this in?</p>",
        "id": 228672607,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614807262
    },
    {
        "content": "<p>I didn't pushed it, since it breaks the rest of the (small) API for quotients</p>",
        "id": 228672658,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1614807286
    },
    {
        "content": "<p>Oh, why don't you push it into a new branch, and I'll try to play around with it</p>",
        "id": 228672702,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614807309
    },
    {
        "content": "<p>That is now written with <code>[complete_space S]</code></p>",
        "id": 228672718,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1614807313
    },
    {
        "content": "<p>OK, I pushed to quotient_closed</p>",
        "id": 228672841,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1614807364
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130384\">@Riccardo Brasca</span> did you commit before pushing? the last commit in this branch was made by Johan.</p>",
        "id": 228673238,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614807529
    },
    {
        "content": "<p>Done</p>",
        "id": 228673373,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1614807600
    },
    {
        "content": "<p>Got it! Thanks :)</p>",
        "id": 228673506,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614807640
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/267928-condensed-mathematics/topic/soft_truncation'/near/228670922\">said</a>:</p>\n<blockquote>\n<p>Maybe we should introduce <code>closed_add_subgroup</code> extending <code>add_subgroup</code>?</p>\n</blockquote>\n<p>I wonder if you should instead make <code>is_closed</code> a class, it might be useful more generally, and then it could be used as a mixin rather than defining <code>closed_add_subgroup</code> directly, which might avoid diamonds at some later point.</p>",
        "id": 228674319,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1614807972
    },
    {
        "content": "<p>We can always use <code>fact (is_closed _)</code></p>",
        "id": 228674965,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614808244
    },
    {
        "content": "<p>Okay, <code>fact (is_closed ...)</code> seems to work well enough.</p>",
        "id": 228675588,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614808557
    },
    {
        "content": "<p>Alright! I added the definition of the closure of a subgroup, and added some <code>fact</code>s in the branch <code>topaz_quotient_closed</code></p>",
        "id": 228678393,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614809720
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130384\">@Riccardo Brasca</span> <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> feel free to merge this to whereever you want, if you're happy with the code.</p>",
        "id": 228680067,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614810411
    },
    {
        "content": "<p>It seems now really easy to do everything in the correct (?) generality: given a normed group <code>M</code> and any subgroup <code>A</code>, define <code>A.normed_group_quotient</code>, that is the quotient of <code>M</code> by the closure of <code>A</code> with the various <code>mk</code> lemmas. Given another normed group <code>N</code> and <code>f : normed_group_hom M N</code> such that <code>f a = 0</code> for all <code>a ∈ A</code>, then we have <code>f a = 0</code> <code>a ∈ topological_closure A</code> and so we have <code>lift f : A.normed_group_quotient N</code> (the proof of boundedness is immediate).</p>",
        "id": 228683510,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1614812060
    },
    {
        "content": "<p>Yes, this all sounds very reasonable.</p>",
        "id": 228683553,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614812086
    },
    {
        "content": "<p>I guess we're also missing the fact that <code>NormedGroup</code> has images of morphisms?</p>",
        "id": 228684284,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614812415
    },
    {
        "content": "<p>There is <code>range</code>, in <code>normed_group_hom.lean</code>. But it is only a subgroup</p>",
        "id": 228684746,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1614812635
    },
    {
        "content": "<p>Okay, I'll sketch some code for the image too...</p>",
        "id": 228685111,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614812785
    },
    {
        "content": "<p>Are you asking that the range of a bounded homomorphism be closed?  I believe this is not true in general, consider the map from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>c</mi><mn>0</mn></msub></mrow><annotation encoding=\"application/x-tex\">c_0</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">c</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> to itself sending <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(x_i)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><msup><mi>i</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><msub><mi>x</mi><mi>i</mi></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(i^{-1}x_i)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">i</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>.</p>",
        "id": 228686014,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1614813174
    },
    {
        "content": "<p>No that's not what I'm asking for.</p>",
        "id": 228686180,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614813246
    },
    {
        "content": "<p>I just want the image as a normed group</p>",
        "id": 228686197,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614813254
    },
    {
        "content": "<p>no closedness assumptions for now.</p>",
        "id": 228686220,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614813261
    },
    {
        "content": "<p>Oh, I see.  But a subgroup is a normed group, <a href=\"https://leanprover-community.github.io/mathlib_docs/find/add_subgroup.normed_group\">docs#add_subgroup.normed_group</a></p>",
        "id": 228686255,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1614813287
    },
    {
        "content": "<p>I know, I'm just bundling so that it becomes a <code>NormedGroup</code> where we can do categorical stuff :)</p>",
        "id": 228686466,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614813373
    },
    {
        "content": "<p>Oh, <code>normed_group</code> vs <code>NormedGroup</code> :)</p>",
        "id": 228686496,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1614813390
    },
    {
        "content": "<p>And I want an actual <code>has_images</code> instance for NormedGroup as well</p>",
        "id": 228686526,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614813413
    },
    {
        "content": "<p>Note that the correct notion of image seems to be the closure of the group theoretic image (I mean, the kernel of the cokernel), but this is probably not very important</p>",
        "id": 228687609,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1614813987
    },
    {
        "content": "<p>Well, NormedGroup is not an abelian category is it? So we don't necessarily have that the image of a morphism is the kernel of the map to its cokernel.</p>",
        "id": 228687831,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614814126
    },
    {
        "content": "<p>Right, but I should think that it's the category-theoretic image nonetheless.</p>",
        "id": 228688007,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614814223
    },
    {
        "content": "<p>What  is? The closure of the set-theoretic image?</p>",
        "id": 228688100,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614814269
    },
    {
        "content": "<p>I think the category-theoretic image is the usual group-theoretic image with the induced structure of a normed_group.</p>",
        "id": 228688281,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614814347
    },
    {
        "content": "<p>Oh sorry, you're right, I was thinking of cokernels</p>",
        "id": 228688430,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614814425
    },
    {
        "content": "<p>You have to think carefully about whether the norm is the one coming from the source or the target I guess</p>",
        "id": 228688628,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614814499
    },
    {
        "content": "<p>According to the stack project, in any preadditive category, we call image of a morphism the kernel of the cokernel (is these exist)</p>",
        "id": 228688676,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1614814524
    },
    {
        "content": "<p>I have the impression that the kernel and cokernel always exist</p>",
        "id": 228688766,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1614814565
    },
    {
        "content": "<p>Well, in any case, here's a preliminary defn:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- Note: the next sorry needs a `NormedGroup`, so we need to bundle.</span>\n<span class=\"kd\">def</span> <span class=\"n\">X</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">cochain_complex</span> <span class=\"n\">NormedGroup</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span> <span class=\"bp\">→</span> <span class=\"n\">NormedGroup</span>\n<span class=\"bp\">|</span> <span class=\"bp\">-</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"bp\">+</span><span class=\"n\">n</span><span class=\"o\">]</span>  <span class=\"o\">:=</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span>       <span class=\"o\">:=</span> <span class=\"n\">NormedGroup.of</span> <span class=\"bp\">$</span> <span class=\"n\">quotient</span> <span class=\"o\">(</span><span class=\"n\">C.d</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">range.topological_closure</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">:</span><span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">C.X</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 228688793,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614814580
    },
    {
        "content": "<p>Which should be correct.</p>",
        "id": 228688809,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614814590
    },
    {
        "content": "<p>This is the more general defn of images:<br>\n<a href=\"https://ncatlab.org/nlab/show/image\">https://ncatlab.org/nlab/show/image</a></p>",
        "id": 228688887,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614814637
    },
    {
        "content": "<p>(which agrees with <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.limits.has_images\">docs#category_theory.limits.has_images</a> )</p>",
        "id": 228688920,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614814669
    },
    {
        "content": "<p>normedgroup is probably {pre,semi}abelian, or something like that</p>",
        "id": 228688945,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1614814683
    },
    {
        "content": "<p>In any case, I don't have any more time to work on this today. I pushed the defn above to <code>topaz_quotient_closed</code> here<br>\n<a href=\"https://github.com/leanprover-community/lean-liquid/blob/564878d91e8b0864294bd06be16de17ab982c38f/src/system_of_complexes/soft_truncation.lean#L31\">https://github.com/leanprover-community/lean-liquid/blob/564878d91e8b0864294bd06be16de17ab982c38f/src/system_of_complexes/soft_truncation.lean#L31</a><br>\nIn case anyone wants to build on top of it</p>",
        "id": 228689086,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614814788
    },
    {
        "content": "<p>What I mean is that the closure of the group theoretic image controls the epimorphisms, and similar the closure of the (already closed) kernel controls the monomorphisms, so for the image we should really take the closure. What is missing to be abelian is that mono + epi = iso (for example the inclusion of a dense subspace)</p>",
        "id": 228689633,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1614815088
    },
    {
        "content": "<p>Yes, I completely agree with that :)</p>",
        "id": 228689720,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614815146
    },
    {
        "content": "<p>I'm thinking about the universal property of quotients of morphisms of <code>NormedGroup</code>s. Is it really true that the quotient by the closure of the image provides a \"correct\" cokernel?</p>\n<p>I don't see how to prove the first sorry in the following:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">NormedGroup.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}}</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">noncomputable</span>\n<span class=\"kd\">def</span> <span class=\"n\">coker</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">⟶</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">NormedGroup</span> <span class=\"o\">:=</span> <span class=\"n\">NormedGroup.of</span> <span class=\"bp\">$</span>\n  <span class=\"n\">quotient_add_group.quotient</span> <span class=\"n\">f.range.topological_closure</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">noncomputable</span>\n<span class=\"kd\">def</span> <span class=\"n\">coker.π</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">⟶</span> <span class=\"n\">B</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"bp\">⟶</span> <span class=\"n\">coker</span> <span class=\"n\">f</span> <span class=\"o\">:=</span>\n  <span class=\"n\">normed_group_hom.normed_group.mk</span> <span class=\"n\">_</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">coker.π_surjective</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">⟶</span> <span class=\"n\">B</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">function.surjective</span> <span class=\"o\">(</span><span class=\"n\">coker.π</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"bp\">⟶</span> <span class=\"n\">coker</span> <span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_add_monoid_hom</span> <span class=\"o\">:=</span>\n  <span class=\"n\">surjective_quot_mk</span> <span class=\"n\">_</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">normed_group_hom</span>\n\n<span class=\"kd\">noncomputable</span>\n<span class=\"kd\">def</span> <span class=\"n\">lift</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">⟶</span> <span class=\"n\">B</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"bp\">⟶</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">cond</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">≫</span> <span class=\"n\">g</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">coker</span> <span class=\"n\">f</span> <span class=\"bp\">⟶</span> <span class=\"n\">C</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">bound'</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"c1\">-- Is this actually true!?</span>\n    <span class=\"gr\">sorry</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"bp\">..</span><span class=\"o\">(</span><span class=\"n\">quotient_add_group.lift</span> <span class=\"n\">_</span> <span class=\"n\">g.to_add_monoid_hom</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">intros</span> <span class=\"n\">b</span> <span class=\"n\">hb</span><span class=\"o\">,</span>\n    <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"kd\">end</span> <span class=\"o\">)</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>The code is found here, in case anyone wants to play with it:<br>\n<a href=\"https://github.com/leanprover-community/lean-liquid/blob/9090c7846b8fe32f601a69fbef38960696063963/src/normed_group/NormedGroup.lean#L126\">https://github.com/leanprover-community/lean-liquid/blob/9090c7846b8fe32f601a69fbef38960696063963/src/normed_group/NormedGroup.lean#L126</a></p>\n<p>I'm a little suspicious as to whether this is actually true. It seems like some completeness is necessary.</p>",
        "id": 228718409,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614834521
    },
    {
        "content": "<p>Thanks for all the work!</p>",
        "id": 228719108,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614835077
    },
    {
        "content": "<p>Okay,  I think it's actually true.</p>\n<p>I added a sketch of proof, but now I should go to sleep... <br>\n<a href=\"https://github.com/leanprover-community/lean-liquid/blob/50b8c497108fae8752b87a9ff57f6a8e0ac8e877/src/normed_group/NormedGroup.lean#L126\">https://github.com/leanprover-community/lean-liquid/blob/50b8c497108fae8752b87a9ff57f6a8e0ac8e877/src/normed_group/NormedGroup.lean#L126</a></p>\n<p>A few sorry's there are just me being lazy and not wanting to look through api docs, and some of these sorry's should be very easy.</p>",
        "id": 228722954,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614838243
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130384\">@Riccardo Brasca</span> <span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> would you mind merging your progress into master as soon as you think it is a sensible approach?</p>",
        "id": 228749817,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614854435
    },
    {
        "content": "<p>There are ~38 sorrys on master now, and it doesn't matter if that number grows a bit (-;</p>",
        "id": 228749850,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614854453
    },
    {
        "content": "<p>I think we are pretty close to a reasonable situation for quotients, if you can wait a little bit we can then merge into master.</p>",
        "id": 228751894,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1614855603
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> I have the impression you are making things more complicated than they are</p>",
        "id": 228752111,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1614855680
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130384\">@Riccardo Brasca</span> sure! It just would be unfortunate if your two branches diverge</p>",
        "id": 228752257,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614855737
    },
    {
        "content": "<p>Contrary to mathlib, I'm perfectly happy with pushing half-fleshed out ideas to master in LTE. The only \"rule\" is that everything should compile.</p>",
        "id": 228752393,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614855812
    },
    {
        "content": "<p>In <a href=\"https://github.com/leanprover-community/lean-liquid/blob/quotient_closed/src/for_mathlib/normed_group_quotient.lean\">https://github.com/leanprover-community/lean-liquid/blob/quotient_closed/src/for_mathlib/normed_group_quotient.lean</a> I put an instance of a normed group on <code>quotient S.topological_closure</code>, for any subgroup <code>S</code> (the structure of instances is bad, but the idea is the correct one I think). I have to teach soon, but using <code>norm_mk_le</code> proving that the lifting is bounded is immediate</p>",
        "id": 228752532,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1614855881
    },
    {
        "content": "<p>We only need to prove that if <code>f</code> is <code>0</code> on <code>S</code> then it is <code>0</code> on <code>S.topological_closure</code>and we got the lifting</p>",
        "id": 228752615,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1614855934
    },
    {
        "content": "<p>What is the correct way of doing the following (if it is a reasonable strategy at all...)? I want something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- The quotient in the category of normed groups. -/</span>\n<span class=\"kd\">noncomputable</span>\n<span class=\"kd\">def</span> <span class=\"n\">normed_group_quotient</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">add_subgroup</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">normed_group</span> <span class=\"o\">(</span><span class=\"n\">quotient</span> <span class=\"n\">S.topological_closure</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">normed_group.of_core</span> <span class=\"o\">(</span><span class=\"n\">quotient</span> <span class=\"n\">S.topological_closure</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">quotient.is_normed_group.core</span> <span class=\"n\">S</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>But now <code>normed_group_quotient S</code> is of type <code>normed_group (quotient S.topological_closure)</code> and I guess that what I really want is to be of type <code>Type*</code> with an instance of normed group. Should I do this by hand? In particular I am worried to lose all the API for quotient groups...</p>",
        "id": 228762383,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1614860574
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130384\">@Riccardo Brasca</span> I think that <code>(quotient S.topological_closure)</code> is automatically coerced to <code>Type*</code></p>",
        "id": 228763553,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614861148
    },
    {
        "content": "<p>So you could afterwards define something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">NormedGroup.quotient</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"n\">NormedGroup</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">add_subgroup</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">NormedGroup</span> <span class=\"o\">:=</span>\n<span class=\"n\">NormedGroup.of</span> <span class=\"o\">(</span><span class=\"n\">quotient</span> <span class=\"n\">S.topological_closure</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 228763703,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614861224
    },
    {
        "content": "<p>This will work if your <code>def</code> above is an instance, so that <code>NormedGroup.of</code> can pick up that instance and bundle it.</p>",
        "id": 228763791,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614861245
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130384\">@Riccardo Brasca</span> The way this currently works in my branch is that you have a normed group instance on the quotient by a closed subgroup, where the <code>is_closed</code> assumption is under a <code>fact</code>. Then I have an instance of <code>fact (is_closed ...)</code> for the topological closure of a subgroup, hence the typeclass system automatically gives you the normed group instance for the quotient by the topological closure of a subgroup.</p>",
        "id": 228773472,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614865349
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> sorry, <code>norm_mk_le</code> is the wrong inequality... I am writing the good one</p>",
        "id": 228773504,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1614865363
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/stream/267928-condensed-mathematics/topic/soft_truncation'/near/228752615\">said</a>:</p>\n<blockquote>\n<p>We only need to prove that if <code>f</code> is <code>0</code> on <code>S</code> then it is <code>0</code> on <code>S.topological_closure</code>and we got the lifting</p>\n</blockquote>\n<p><span aria-label=\"up\" class=\"emoji emoji-2b06\" role=\"img\" title=\"up\">:up:</span> yes, this is exactly the key point in the proofs involved in <code>coker.lift</code>.</p>",
        "id": 228773599,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614865409
    },
    {
        "content": "<p>I think it's a bit silly to do </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">quotient.is_normed_group.core</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">add_subgroup</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">normed_group.core</span> <span class=\"o\">(</span><span class=\"n\">quotient</span> <span class=\"n\">S.topological_closure</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n</code></pre></div>\n<p>since then it will be a pain to get an instance of a normed group on a quotient when you happen to know that your subgroup is alreaedy closed.</p>",
        "id": 228773849,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614865505
    },
    {
        "content": "<p>For example we may want to take the quotient by the kernel of a morphism, without having to manually prove that the kernel of a morphism equals its own topological closure</p>",
        "id": 228773946,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614865540
    },
    {
        "content": "<p>Here's the skeleton of the argument for lift I had last night:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">lift</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">⟶</span> <span class=\"n\">B</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"bp\">⟶</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">cond</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">≫</span> <span class=\"n\">g</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">coker</span> <span class=\"n\">f</span> <span class=\"bp\">⟶</span> <span class=\"n\">C</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">bound'</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">rcases</span> <span class=\"n\">g.bound</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">c</span><span class=\"o\">,</span><span class=\"n\">hcpos</span><span class=\"o\">,</span><span class=\"n\">hc</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">use</span> <span class=\"n\">c</span><span class=\"o\">,</span>\n    <span class=\"n\">intros</span> <span class=\"n\">v</span><span class=\"o\">,</span>\n    <span class=\"n\">rcases</span> <span class=\"n\">coker.π_surjective</span> <span class=\"n\">v</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">v</span><span class=\"o\">,</span><span class=\"n\">rfl</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">change</span> <span class=\"bp\">∥</span> <span class=\"n\">g</span> <span class=\"n\">v</span> <span class=\"bp\">∥</span> <span class=\"bp\">≤</span> <span class=\"n\">c</span> <span class=\"bp\">*</span> <span class=\"n\">Inf</span> <span class=\"o\">{</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"bp\">|</span> <span class=\"bp\">∃</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">B</span><span class=\"o\">,</span> <span class=\"n\">coker.π</span> <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"n\">coker.π</span> <span class=\"n\">_</span> <span class=\"bp\">∧</span> <span class=\"n\">_</span> <span class=\"o\">},</span>\n    <span class=\"c1\">-- Should be in mathlib in some form?</span>\n    <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">Inf</span> <span class=\"o\">{</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"bp\">|</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">B</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">coker.π</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">coker</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">coker.π</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">coker</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"n\">r</span> <span class=\"bp\">=</span> <span class=\"bp\">∥</span><span class=\"n\">y</span><span class=\"bp\">∥</span><span class=\"o\">}</span> <span class=\"bp\">=</span>\n      <span class=\"n\">Inf</span> <span class=\"o\">{</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"bp\">|</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">B</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">coker.π</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">coker</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">coker.π</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">coker</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"n\">r</span> <span class=\"bp\">=</span> <span class=\"n\">c</span> <span class=\"bp\">*</span> <span class=\"bp\">∥</span> <span class=\"n\">y</span> <span class=\"bp\">∥</span> <span class=\"o\">},</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">real.le_Inf</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">rintros</span> <span class=\"n\">x</span> <span class=\"o\">⟨</span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"n\">hx</span><span class=\"o\">,</span><span class=\"n\">rfl</span><span class=\"o\">⟩,</span>\n      <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">g</span> <span class=\"n\">v</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"n\">b</span><span class=\"o\">,</span>\n      <span class=\"o\">{</span> <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">-</span> <span class=\"n\">v</span> <span class=\"bp\">∈</span> <span class=\"n\">f.range.topological_closure</span><span class=\"o\">,</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span> <span class=\"c1\">-- from hx</span>\n        <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">range</span> <span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">topological_closure</span> <span class=\"bp\">≤</span> <span class=\"n\">g.ker</span><span class=\"o\">,</span>\n        <span class=\"o\">{</span> <span class=\"n\">change</span> <span class=\"o\">(</span><span class=\"n\">closure</span> <span class=\"o\">(</span><span class=\"n\">f.range</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">B</span><span class=\"o\">))</span> <span class=\"bp\">⊆</span> <span class=\"o\">(</span><span class=\"n\">ker</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">B</span><span class=\"o\">),</span>\n          <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">is_closed</span> <span class=\"o\">(</span><span class=\"n\">g.ker</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">B</span><span class=\"o\">),</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span> <span class=\"c1\">-- should be separate lemma.</span>\n          <span class=\"c1\">-- there should now be a lemma saying that, given `is_closed Y`,</span>\n          <span class=\"c1\">-- closure X ⊆ Y ↔ X ⊆ Y</span>\n          <span class=\"c1\">-- Then conclude using `cond`.</span>\n          <span class=\"gr\">sorry</span> <span class=\"o\">},</span>\n        <span class=\"k\">suffices</span> <span class=\"o\">:</span> <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">-</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span> <span class=\"c1\">-- This must be in mathlib somewhere...</span>\n        <span class=\"n\">apply</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n        <span class=\"n\">assumption</span><span class=\"o\">,</span>\n      <span class=\"o\">},</span>\n      <span class=\"n\">rw</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n      <span class=\"n\">apply</span> <span class=\"n\">hc</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">c</span> <span class=\"bp\">*</span> <span class=\"bp\">∥</span> <span class=\"n\">v</span> <span class=\"bp\">∥</span><span class=\"o\">,</span><span class=\"n\">v</span><span class=\"o\">,</span><span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">use</span> <span class=\"mi\">0</span><span class=\"o\">,</span>\n      <span class=\"n\">intros</span> <span class=\"n\">y</span> <span class=\"n\">hy</span><span class=\"o\">,</span>\n      <span class=\"n\">rcases</span> <span class=\"n\">hy</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">y</span><span class=\"o\">,</span><span class=\"n\">hy</span><span class=\"o\">,</span><span class=\"n\">rfl</span><span class=\"o\">⟩,</span>\n      <span class=\"n\">apply</span> <span class=\"n\">mul_nonneg</span> <span class=\"o\">(</span><span class=\"n\">le_of_lt</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">norm_nonneg</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n      <span class=\"n\">simpa</span> <span class=\"o\">},</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"bp\">..</span><span class=\"o\">(</span><span class=\"n\">quotient_add_group.lift</span> <span class=\"n\">_</span> <span class=\"n\">g.to_add_monoid_hom</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">intros</span> <span class=\"n\">b</span> <span class=\"n\">hb</span><span class=\"o\">,</span>\n    <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"kd\">end</span> <span class=\"o\">)</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 228774149,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614865604
    },
    {
        "content": "<p>I think I will have proof in one hour max (not literally of this statement, but something that is mathematically the same), and then I will think about the Lean design of things</p>",
        "id": 228774471,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1614865706
    },
    {
        "content": "<p>I've added <code>lift</code> here</p>",
        "id": 228779134,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1614867465
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/lean-liquid/blob/quotient_closed/src/for_mathlib/normed_group_quotient.lean\">https://github.com/leanprover-community/lean-liquid/blob/quotient_closed/src/for_mathlib/normed_group_quotient.lean</a></p>",
        "id": 228779139,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1614867468
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">zero_of_closure</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">normed_group</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">normed_group</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">add_subgroup</span> <span class=\"n\">M</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">normed_group_hom</span> <span class=\"n\">M</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">m</span> <span class=\"bp\">∈</span> <span class=\"n\">A.topological_closure</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n</code></pre></div>\n<p>is still <code>sorry</code>, but it shouldn't be hard</p>",
        "id": 228779243,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1614867496
    },
    {
        "content": "<p>Oh I have a proof of that already. Ill fill in the sorry</p>",
        "id": 228779583,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614867612
    },
    {
        "content": "<p>give me a few mins</p>",
        "id": 228779592,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614867616
    },
    {
        "content": "<p>Bah, I filled in the sorry, but my git tree is f-ed up</p>",
        "id": 228782037,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614868451
    },
    {
        "content": "<p>I'm inclined to say: <code>git</code> gud <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>",
        "id": 228783062,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614868801
    },
    {
        "content": "<p>4sho</p>",
        "id": 228783175,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614868820
    },
    {
        "content": "<p>Oh, I pushed it.</p>",
        "id": 228783243,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614868845
    },
    {
        "content": "<p>Again, I have to reiterate that I think ddefining </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">normed_group_quotient</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">add_subgroup</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">normed_group</span> <span class=\"o\">(</span><span class=\"n\">quotient</span> <span class=\"n\">S.topological_closure</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n</code></pre></div>\n<p>is not the right approach</p>",
        "id": 228783462,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614868927
    },
    {
        "content": "<p>Because then the typeclass system wont get the normed_group instance on things like <code>quotient (f.ker)</code></p>",
        "id": 228783656,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614869004
    },
    {
        "content": "<p>Thank you! Now the mathematics is there, the quotient by <code>S.topological_closure</code> has the required universal property. I don't have any strong opinion about the right approach to this kind of problems</p>",
        "id": 228783681,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1614869013
    },
    {
        "content": "<p>We're still missing the uniqueness of lift, but that's not too bad</p>",
        "id": 228784025,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614869159
    },
    {
        "content": "<p>Ah, sure, <code>lift</code> is not a lift  of anything written like that :D</p>",
        "id": 228784212,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1614869227
    },
    {
        "content": "<p>Did you get rid of the instance that I wrote yesterday for quotients by closed subgroups?</p>",
        "id": 228784323,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614869263
    },
    {
        "content": "<p>I can't find it in the branch</p>",
        "id": 228784339,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614869270
    },
    {
        "content": "<p>Well, you wrote it, but I fudged around with <code>fact</code> in the hypotheses to make it work with the typeclass system</p>",
        "id": 228784516,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614869334
    },
    {
        "content": "<p>I've added <code>lift_mk</code></p>",
        "id": 228784861,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1614869472
    },
    {
        "content": "<p>I didn't touch your branch, but I erased the <code>fact</code> in the branch quotient_closed</p>",
        "id": 228784915,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1614869495
    },
    {
        "content": "<p>Ok, I'll add <code>lift_unique</code></p>",
        "id": 228785016,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614869525
    },
    {
        "content": "<p>I think I like the <code>fact</code> approach, at least until there is enough evidence that we need 400 lines of API around <code>closed_(add)_subgroup</code></p>",
        "id": 228785192,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614869595
    },
    {
        "content": "<p>I'll add this last lemma, then I'll change back to <code>fact</code>'s</p>",
        "id": 228785243,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614869616
    },
    {
        "content": "<p>BTW I agree that we should now think about how setting up all the instances and so on. Changing everything now should be quite easy, but the sooner we do it the better</p>",
        "id": 228785255,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1614869619
    },
    {
        "content": "<p>Note that we can't have global instances for <code>fact</code> in mathlib. (But in LTE it's fine, yolo, living on the edge)</p>",
        "id": 228785287,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614869635
    },
    {
        "content": "<p>So</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">fact</span> <span class=\"o\">(</span><span class=\"n\">is_closed</span> <span class=\"n\">f.ker</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>is mathlib-evil.<br>\nBut of course it can be made an instance locally in some files.</p>",
        "id": 228785417,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614869667
    },
    {
        "content": "<p>The change back is going to be a bit annoying since now we have a bunch of <code>S.topological_closure</code>s which will need to be changed back to <code>S</code>.</p>",
        "id": 228785802,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614869792
    },
    {
        "content": "<p>I have no problem in doing annoying stuff, I just prefer to not take any decision about what is a <code>def</code> what is an <code>instance</code>...</p>",
        "id": 228785954,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1614869857
    },
    {
        "content": "<p>Allright, I added lift_unque</p>",
        "id": 228786336,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614869974
    },
    {
        "content": "<p>If you have doubts, just go with <code>def</code>. It's usually not too hard to change things to <code>instance</code> later on.</p>",
        "id": 228786357,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614869983
    },
    {
        "content": "<p>So now we have cokernels</p>",
        "id": 228786520,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614870026
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> <span class=\"user-mention\" data-user-id=\"130384\">@Riccardo Brasca</span> Are you both okay with me changing back to <code>fact (is_closed ...)</code>?</p>",
        "id": 228787194,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614870241
    },
    {
        "content": "<p>No problem for me</p>",
        "id": 228787331,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1614870270
    },
    {
        "content": "<p>I'm inclined to just delete my branch with this stuff, it doesn't make sense to have two branches on the same topic</p>",
        "id": 228787346,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614870280
    },
    {
        "content": "<p>If we don't want to use <code>fact</code>s then we can always go back to the idea of defining <code>closed_add_subgroup</code></p>",
        "id": 228787491,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614870342
    },
    {
        "content": "<p>This may be a good option anyway since we will never work with non-closed subgroups.</p>",
        "id": 228787661,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614870393
    },
    {
        "content": "<p>What is the policy in mathlib for the quotient by a (not necessarily normal) subgroup? I mean the quotient group (by the normal closure), not the quotient set by the relation, that is not a group. It seems a very similar situation, the quotient exist, but it does not commute with the forgetful functor</p>",
        "id": 228788244,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1614870590
    },
    {
        "content": "<p>I think you need the assumption that it's normal</p>",
        "id": 228788447,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614870637
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/quotient_group.quotient.group\">docs#quotient_group.quotient.group</a></p>",
        "id": 228788590,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614870688
    },
    {
        "content": "<p>And <code>normal</code> is a class in this case, so you need the instance. That's what I was trying to simulate with <code>fact</code></p>",
        "id": 228788657,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614870712
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> If you want to set up the API for <code>closed_add_subgroup</code> that's fine with me. But I think <code>fact</code> is also fine.</p>",
        "id": 228788783,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614870743
    },
    {
        "content": "<p>And probably less work from now.</p>",
        "id": 228788797,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614870750
    },
    {
        "content": "<p>My guess is that moving from <code>fact</code> to <code>closed_subgroup</code> later on shouldn't create a lot of trouble.</p>",
        "id": 228788867,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614870772
    },
    {
        "content": "<p>Yeah, I'll go with fact for now. It will be easy to change to <code>closed_add_subgroup</code> later if we want</p>",
        "id": 228788872,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614870773
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130384\">@Riccardo Brasca</span> are you okay with me pushing to your branch? with this fact stuff, I  mean?</p>",
        "id": 228788987,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614870800
    },
    {
        "content": "<p>Sure!</p>",
        "id": 228789056,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1614870824
    },
    {
        "content": "<p>Okay, that's done. I'll now add a small wrapper to get cokernels in the category <code>NormedGroup</code></p>",
        "id": 228791430,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614871530
    },
    {
        "content": "<p>Do we want to PR this quotient stuff to mathlib at some point? In that case I can improve the API a little bit (for example adding that the norm of the projection to the quotient is <code>1</code>)</p>",
        "id": 228793651,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1614872185
    },
    {
        "content": "<p>I think the appropriate thing for mathlib is the <code>closed_add_subgroup</code> approach (and it should be done in general for an arbitrary topological group presumably)</p>",
        "id": 228793957,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614872287
    },
    {
        "content": "<p>E.g. we will want quotients by closed subgroups of profinite groups eventuially.</p>",
        "id": 228794090,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614872337
    },
    {
        "content": "<p>I think this is natural stuff to move to mathlib at some point</p>",
        "id": 228794112,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614872346
    },
    {
        "content": "<p>But I imagine that <span class=\"user-mention\" data-user-id=\"260507\">@Heather Macbeth</span> <span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span> will have better ideas about how exactly it should be designed</p>",
        "id": 228794177,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614872369
    },
    {
        "content": "<p>I do agree that <code>closed_subgroup</code> will be a good thing for mathlib. Think infinite Galois theory, and such.</p>",
        "id": 228794322,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614872412
    },
    {
        "content": "<p>As I was saying yesterday, my first idea was that it would be better for <code>is_closed</code> to be a mixin -- are there reasons not to in this case?</p>",
        "id": 228794577,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1614872499
    },
    {
        "content": "<p>For infinite Galois theory, I imagine we want a Galois correspondence between <code>intermediate_subfield</code> and <code>closed_subgroup</code></p>",
        "id": 228795467,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614872789
    },
    {
        "content": "<p>So then it's actually valuable to have a dedicated type, on which we consider an order structure, etc...</p>",
        "id": 228795530,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614872813
    },
    {
        "content": "<p>Plus in general we will want a galois_insertion between <code>subgroup</code> and <code>closed_subgroup</code></p>",
        "id": 228796083,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614872987
    },
    {
        "content": "<p>It would be nice if the solution simultaneously applies to normed spaces and subspaces.  For example in <code>normed_space.inner_product</code> we have</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">submodule.is_closed_orthogonal</span> <span class=\"o\">[</span><span class=\"n\">inner_product_space</span> <span class=\"bp\">𝕜</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"n\">submodule</span> <span class=\"bp\">𝕜</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">is_closed</span> <span class=\"bp\">↑</span><span class=\"n\">K</span><span class=\"bp\">ᗮ</span>\n</code></pre></div>",
        "id": 228797215,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1614873342
    },
    {
        "content": "<p>I fear that we'll need both <code>closed_(add_)subgroup</code> and <code>closed_sub{module/space?}</code>.</p>",
        "id": 228797902,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614873548
    },
    {
        "content": "<p>In any case I will improve a little the API for <code>normed_group_hom</code>. Putting a <code>normed_group</code> instance seems not that far</p>",
        "id": 228799296,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1614873942
    },
    {
        "content": "<p>Merci!</p>",
        "id": 228800179,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614874211
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> I'm playing with the soft_truncation stuff, and we still seem to have DTT hell issues :(</p>",
        "id": 228801063,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614874474
    },
    {
        "content": "<p>I'll have dinner first</p>",
        "id": 228801294,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614874545
    },
    {
        "content": "<p>Want to meet on video later?</p>",
        "id": 228801466,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614874586
    },
    {
        "content": "<p>If you see a situation where the set of closed subspaces is in canonically in bijection with something else, then we should go for the bundling. (Personnally, I don't have such a situation in mind for now). Otherwise, the mixin approach seems more lightweight and as efficient. I'd probably avoid <code>fact</code>, though, and turn <code>is_closed</code> into a class instead. Most uses of <code>is_closed</code> would remain as usual assumptions, but one would additionally register just a few instances to make sure that you get instances on the things you need (namely <code>f.ker</code> when <code>f</code> is continuous, and so on)</p>",
        "id": 228806550,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1614876086
    },
    {
        "content": "<p>The big advantage of the mixin is that you don't need to define two quotients, one by an <code>add_subgroup</code> and the other one by a <code>closed_add_subgroup</code> and repeat all the API. So I'd probably go for the mixin approach for now, and refactor later if/when needed.</p>",
        "id": 228806837,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1614876181
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/267928-condensed-mathematics/topic/soft_truncation'/near/228801466\">said</a>:</p>\n<blockquote>\n<p>Want to meet on video later?</p>\n</blockquote>\n<p>I can probably meet around <time datetime=\"2021-03-04T18:15:00Z\">2021-03-04T19:15:00+01:00</time></p>",
        "id": 228808218,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614876625
    },
    {
        "content": "<p>What time zone is that?</p>",
        "id": 228808269,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614876646
    },
    {
        "content": "<p>I'm using <code>&lt;time</code></p>",
        "id": 228808317,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614876662
    },
    {
        "content": "<p>So Zulip turns it into your timezone</p>",
        "id": 228808349,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614876671
    },
    {
        "content": "<p>Fancy!</p>",
        "id": 228808375,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614876676
    },
    {
        "content": "<p>That works :)</p>",
        "id": 228808384,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614876678
    },
    {
        "content": "<p>I see <code>Thu, Mar 4 2021, 19:15</code> which is CET</p>",
        "id": 228808407,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614876686
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span> just to clarify, we only have <code>fact (is_closed ...)</code> in LTE, and we don't expect anything like that to be put in mathlib.</p>",
        "id": 228812591,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614878074
    },
    {
        "content": "<p>By the way, you can also mouse over the time to see the time in the poster's time zone (i.e. I see 1:15 PM but it says 19:15+0100 in the hover)</p>",
        "id": 228814199,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1614878651
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> I'm ready half an hour early</p>",
        "id": 228817653,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614879821
    },
    {
        "content": "<p>You want to meet now? <a href=\"http://meet.jit.si/soft-trunction-dtt\">meet.jit.si/soft-trunction-dtt</a></p>",
        "id": 228817793,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614879863
    },
    {
        "content": "<p>Adam convinced me that we need to fix complexes and <code>d</code> before filling in the sorrys in the <code>soft_truncation.lean</code> file</p>",
        "id": 228832486,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614885189
    },
    {
        "content": "<p>I still like the idea of <code>d {i} {j} (h : j = i + 1) : C i -&gt; C j</code>. Do we have any arguments against this? I'd like to think it solves a lot of problems</p>",
        "id": 228862694,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614897036
    },
    {
        "content": "<p>Johan and I were discussing the idea of using functors <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi><mo>→</mo><mrow><mi mathvariant=\"normal\">N</mi><mi mathvariant=\"normal\">o</mi><mi mathvariant=\"normal\">r</mi><mi mathvariant=\"normal\">m</mi><mi mathvariant=\"normal\">e</mi><mi mathvariant=\"normal\">d</mi><mi mathvariant=\"normal\">G</mi><mi mathvariant=\"normal\">r</mi><mi mathvariant=\"normal\">o</mi><mi mathvariant=\"normal\">u</mi><mi mathvariant=\"normal\">p</mi></mrow></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Z} \\to \\mathrm{NormedGroup}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Z</span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">N</span><span class=\"mord mathrm\">o</span><span class=\"mord mathrm\">r</span><span class=\"mord mathrm\">m</span><span class=\"mord mathrm\">e</span><span class=\"mord mathrm\">d</span><span class=\"mord mathrm\">G</span><span class=\"mord mathrm\">r</span><span class=\"mord mathrm\">o</span><span class=\"mord mathrm\">u</span><span class=\"mord mathrm\">p</span></span></span></span></span> and so far it seems to work fairly well</p>",
        "id": 228862816,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614897116
    },
    {
        "content": "<p>(here <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Z}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Z</span></span></span></span></span> is given the category obtained from the ordered structure)</p>",
        "id": 228862903,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614897143
    },
    {
        "content": "<p>regarding the mixin / bundled question, can't one have both? start with the mixin, use that as much as possible, and if there are special cases where the bundled thing is helpful, you just use the mixin as a structure field.</p>",
        "id": 228867596,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1614899619
    },
    {
        "content": "<p>So this begs the obvious question: should <code>is_closed</code> (for a general subset of a topological space) be made a class in mathlib? What about <code>is_open</code>?</p>",
        "id": 228867959,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614899820
    },
    {
        "content": "<p>BTW, can we merge quotient_closed into master now? If it compiles it is probably better to do it...</p>",
        "id": 228870744,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1614901325
    },
    {
        "content": "<p>Fine with me!</p>",
        "id": 228870787,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614901350
    },
    {
        "content": "<p>Pushed to master</p>",
        "id": 228871237,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1614901617
    },
    {
        "content": "<p>Lean says</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">/</span><span class=\"n\">github</span><span class=\"bp\">/</span><span class=\"n\">workspace</span><span class=\"bp\">/</span><span class=\"n\">src</span><span class=\"bp\">/</span><span class=\"n\">normed_group</span><span class=\"bp\">/</span><span class=\"n\">NormedGroup.lean</span><span class=\"o\">:</span><span class=\"mi\">147</span><span class=\"o\">:</span><span class=\"mi\">24</span><span class=\"o\">:</span> <span class=\"n\">error</span><span class=\"o\">:</span> <span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">synthesize</span> <span class=\"n\">type</span> <span class=\"kd\">class</span> <span class=\"kd\">instance</span> <span class=\"n\">for</span>\n<span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">NormedGroup</span><span class=\"o\">,</span>\n<span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">⟶</span> <span class=\"n\">B</span><span class=\"o\">,</span>\n<span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"bp\">⟶</span> <span class=\"n\">C</span><span class=\"o\">,</span>\n<span class=\"n\">cond</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">≫</span> <span class=\"n\">g</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">,</span>\n<span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">coker</span> <span class=\"n\">f</span> <span class=\"bp\">⟶</span> <span class=\"n\">C</span><span class=\"o\">,</span>\n<span class=\"n\">ᾰ</span> <span class=\"o\">:</span> <span class=\"n\">coker.π</span> <span class=\"bp\">≫</span> <span class=\"n\">h</span> <span class=\"bp\">=</span> <span class=\"n\">g</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">has_lift</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">≫</span> <span class=\"n\">g</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">coker</span> <span class=\"n\">f</span> <span class=\"bp\">⟶</span> <span class=\"n\">C</span><span class=\"o\">)</span>\n</code></pre></div>\n<p><span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> Can you have a look at it? Time to sleep for me...</p>",
        "id": 228872234,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1614902162
    },
    {
        "content": "<p>I'll try, but I'm a bit busy now.</p>",
        "id": 228872326,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614902202
    },
    {
        "content": "<p>Okay, I'm fixing it.</p>",
        "id": 228873412,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614902741
    },
    {
        "content": "<p>And adding some docstrings to make the linter happy</p>",
        "id": 228873437,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614902755
    },
    {
        "content": "<p>Shhould be okay now</p>",
        "id": 228873707,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614902897
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/267928-condensed-mathematics/topic/soft_truncation'/near/228867959\">said</a>:</p>\n<blockquote>\n<p>So this begs the obvious question: should <code>is_closed</code> (for a general subset of a topological space) be made a class in mathlib? What about <code>is_open</code>?</p>\n</blockquote>\n<p>I'm working on this, in the branch <code>is_closed_class</code>.</p>",
        "id": 228917867,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1614934402
    },
    {
        "content": "<p>of mathlib, or LTE?</p>",
        "id": 228918269,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614934453
    },
    {
        "content": "<p>I just pushed a couple more coker lemmas to master in <code>normed_group.NormedGroup</code>. They should be enough to show that (coker C-1 -&gt; C0) -&gt; C2 is zero.</p>",
        "id": 228960727,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614953992
    },
    {
        "content": "<p>We now have the following sorry-free definition:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">shift_and_trunctate</span> <span class=\"o\">:</span> <span class=\"n\">system_of_complexes</span> <span class=\"bp\">⥤</span> <span class=\"n\">system_of_complexes</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">shift</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">functor</span> <span class=\"bp\">⋙</span> <span class=\"n\">soft_truncation'</span>\n</code></pre></div>\n<p>and we need to extend this to</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">shift_and_truncate</span> <span class=\"o\">:</span> <span class=\"n\">system_of_double_complexes</span> <span class=\"bp\">⥤</span> <span class=\"n\">system_of_double_complexes</span> <span class=\"o\">:=</span>\n<span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>by applying <code>system_of_complexes.shift_and_truncate</code> to all the rows.</p>",
        "id": 229431954,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1615273825
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> you did a similar thing for completions, using old-skool complexes. How hard do you think it would be to port this to the new complexes?</p>",
        "id": 229431989,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1615273864
    },
    {
        "content": "<p>Are we shifting left, up, or up-and-left? (using the orientation conventions in analytic.pdf)</p>",
        "id": 229432125,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1615273944
    },
    {
        "content": "<p>we are only shifting left</p>",
        "id": 229432148,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1615273977
    },
    {
        "content": "<p>and then truncating whatever got moved into negative degrees</p>",
        "id": 229432177,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1615273991
    },
    {
        "content": "<p>This shouldn't be too bad... Just make a functional version of truncation, and prove an additive functor instance for it. So then you can push forward a complex with respect to that functor, then apply the shift. As long as everything is functorial, you can just compose some functors and get the definition you want. I don't know if the order really matters, but you can alternatively do something similar by proving that shifting is additive.</p>",
        "id": 229440907,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1615279291
    },
    {
        "content": "<p>We need both to be additive, right?</p>",
        "id": 229441218,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1615279456
    },
    {
        "content": "<p>Oh I guess all this requires a preadditive instanc for the category of complexes itself</p>",
        "id": 229441235,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1615279469
    },
    {
        "content": "<p>Hmm, makes sense</p>",
        "id": 229441290,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1615279509
    },
    {
        "content": "<p>So there is still a little bit of work to do.</p>",
        "id": 229441311,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1615279521
    },
    {
        "content": "<p>Yeah.</p>",
        "id": 229441331,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1615279535
    },
    {
        "content": "<p>And I guess it's better to do that work than to brute force our way through the definition.</p>",
        "id": 229441354,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1615279549
    },
    {
        "content": "<p>I can take a look tomorrow (well, today, it's 1:45 am here, and I can't sleep )</p>",
        "id": 229441494,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1615279603
    },
    {
        "content": "<p>But I'm also attending a workshop \"at MFO\" this week, so I don't know if I'll have much time for coding</p>",
        "id": 229441631,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1615279651
    },
    {
        "content": "<p>I'm adding the preadditive instance now.</p>",
        "id": 229491304,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1615302510
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> one sec!</p>",
        "id": 229492647,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1615303015
    },
    {
        "content": "<p>I already did that</p>",
        "id": 229492653,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1615303019
    },
    {
        "content": "<p>Oh :)</p>",
        "id": 229492657,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1615303023
    },
    {
        "content": "<p>let me push what I have</p>",
        "id": 229492682,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1615303031
    },
    {
        "content": "<p>I'm getting stuck at <code>zero_add</code> for some reason anyway! <span aria-label=\"rofl\" class=\"emoji emoji-1f923\" role=\"img\" title=\"rofl\">:rofl:</span></p>",
        "id": 229492717,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1615303046
    },
    {
        "content": "<p>See <code>jmc-refactor-complex</code> branch</p>",
        "id": 229492763,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1615303066
    },
    {
        "content": "<p>I cant get the <code>ext</code> lemma to behave for some reason.</p>",
        "id": 229492771,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1615303069
    },
    {
        "content": "<p>Thinks work a lot smoother now. Even less <code>eq_to_hom</code>s</p>",
        "id": 229492798,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1615303081
    },
    {
        "content": "<p>But the branch doesn't build yet. I'm in the final stages of fixing the build</p>",
        "id": 229492892,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1615303099
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> ok, it builds locally</p>",
        "id": 229493211,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1615303226
    },
    {
        "content": "<p>I'm really quite happy with the shape that this is now getting in</p>",
        "id": 229493398,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1615303293
    },
    {
        "content": "<p>There are dedicated constructors for <code>(co)chain_complex</code> which will introduce some <code>eq_to_hom</code>s under the hood. But otherwise you don't see them anywhere.</p>",
        "id": 229493539,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1615303346
    },
    {
        "content": "<p>One thing I didn't do yet, is lifting <code>has_shift</code> from <code>differential_object</code> to <code>cochain_complex</code>.</p>",
        "id": 229493692,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1615303433
    },
    {
        "content": "<p>So the code about shifts of cochain complexes is currently commented out</p>",
        "id": 229493764,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1615303448
    },
    {
        "content": "<p>We might want to build a generic constructor for functors to <code>complex_like</code> by taking a functor to <code>differential_object</code>, + a proof that all objects in the image are <code>is_complex_like</code>.</p>",
        "id": 229493931,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1615303525
    },
    {
        "content": "<p>I think that the API for <code>soft_truncation'</code> is almost done</p>",
        "id": 229878699,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1615479832
    },
    {
        "content": "<p>To prove that it is well-behaved wrt weak bounded exactness, there is 1 sorry left.</p>",
        "id": 229878794,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1615479854
    },
    {
        "content": "<p>We need to do a computation with a cokernel, and it's a bit nasty because the range of <code>d</code> is maybe not closed, so we have to work with norm estimates.</p>",
        "id": 229878920,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1615479902
    },
    {
        "content": "<p>If someone wants to take a look, please feel free to fix that <code>sorry</code></p>",
        "id": 229878994,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1615479923
    },
    {
        "content": "<p>I changed the <code>sorry</code> into something that I'm convinced is provable.</p>",
        "id": 229888151,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1615482904
    }
]
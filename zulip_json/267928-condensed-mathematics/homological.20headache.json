[
    {
        "content": "<p>Hmm, I can't replicate the solution that worked in the <a href=\"#narrow/stream/267928-condensed-mathematics/topic/bounded.20exactness/near/225605844\">previous example</a>.<br>\nHere are two rather minimal examples that explain the problem.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.homology.chain_complex</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.category.Group</span>\n<span class=\"kn\">import</span> <span class=\"n\">tactic.ring</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">cochain_complex</span> <span class=\"n\">AddCommGroup</span><span class=\"o\">)</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">category_theory</span>\n\n<span class=\"kn\">section</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">tactic</span>\n\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">int_magic</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">unit</span> <span class=\"o\">:=</span>\n<span class=\"k\">do</span> <span class=\"o\">(</span><span class=\"n\">assumption</span> <span class=\"bp\">&lt;|&gt;</span> <span class=\"n\">tactic.interactive.ring1</span> <span class=\"n\">none</span> <span class=\"bp\">&lt;|&gt;</span> <span class=\"n\">tactic.interactive.refl</span><span class=\"o\">)</span> <span class=\"bp\">&lt;|&gt;</span>\n   <span class=\"n\">target</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"n\">trace</span>\n\n<span class=\"kd\">end</span>\n\n<span class=\"sd\">/-- Convenience definition:</span>\n<span class=\"sd\">The identity morphism of an object in the system of complexes</span>\n<span class=\"sd\">when it is given by different indices that are not</span>\n<span class=\"sd\">definitionally equal. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">congr_hom</span> <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">C.X</span> <span class=\"n\">i</span> <span class=\"bp\">⟶</span> <span class=\"n\">C.X</span> <span class=\"n\">j</span> <span class=\"o\">:=</span>\n<span class=\"n\">eq_to_hom</span> <span class=\"bp\">$</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">subst</span> <span class=\"n\">h</span> <span class=\"o\">}</span>\n\n<span class=\"sd\">/-- `C.d` is the differential `C i ⟶ C (i+1)` for a cochain complex `C`. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">differential</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hij</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">C.X</span> <span class=\"n\">i</span> <span class=\"bp\">⟶</span> <span class=\"n\">C.X</span> <span class=\"n\">j</span> <span class=\"o\">:=</span>\n<span class=\"n\">C.d</span> <span class=\"n\">i</span> <span class=\"bp\">≫</span> <span class=\"n\">congr_hom</span> <span class=\"n\">C</span> <span class=\"n\">hij</span>\n\n<span class=\"kn\">local</span> <span class=\"kd\">notation</span> <span class=\"bp\">`</span><span class=\"n\">d</span><span class=\"bp\">`</span> <span class=\"o\">:=</span> <span class=\"n\">differential</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">int_magic</span><span class=\"o\">)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">differential_rfl</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">differential</span> <span class=\"n\">C</span> <span class=\"n\">i</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">rfl</span> <span class=\"bp\">=</span> <span class=\"n\">C.d</span> <span class=\"n\">i</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"n\">refl</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">d_comp_d</span> <span class=\"o\">{</span><span class=\"n\">i₁</span> <span class=\"n\">i₂</span> <span class=\"n\">i₃</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">i₁</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">i₂</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h'</span> <span class=\"o\">:</span> <span class=\"n\">i₂</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">i₃</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">C.X</span> <span class=\"n\">i₁</span> <span class=\"bp\">⟶</span> <span class=\"n\">C.X</span> <span class=\"n\">i₂</span><span class=\"o\">)</span> <span class=\"bp\">≫</span> <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">C.X</span> <span class=\"n\">i₂</span> <span class=\"bp\">⟶</span> <span class=\"n\">C.X</span> <span class=\"n\">i₃</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">subst</span> <span class=\"n\">i₂</span><span class=\"o\">,</span> <span class=\"n\">subst</span> <span class=\"n\">i₃</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">differential_rfl</span><span class=\"o\">],</span>\n  <span class=\"n\">exact</span> <span class=\"n\">homological_complex.d_squared</span> <span class=\"n\">_</span> <span class=\"n\">_</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">d_d</span> <span class=\"o\">{</span><span class=\"n\">i₁</span> <span class=\"n\">i₂</span> <span class=\"n\">i₃</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">i₁</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">i₂</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h'</span> <span class=\"o\">:</span> <span class=\"n\">i₂</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">i₃</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">C.X</span> <span class=\"n\">i₁</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">differential</span> <span class=\"n\">C</span> <span class=\"n\">i₂</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">int_magic</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">C.X</span> <span class=\"n\">i₂</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">C.X</span> <span class=\"n\">i₃</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"k\">show</span> <span class=\"o\">((</span><span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">C.X</span> <span class=\"n\">i₁</span> <span class=\"bp\">⟶</span> <span class=\"n\">C.X</span> <span class=\"n\">i₂</span><span class=\"o\">)</span> <span class=\"bp\">≫</span> <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">C.X</span> <span class=\"n\">i₂</span> <span class=\"bp\">⟶</span> <span class=\"n\">C.X</span> <span class=\"n\">i₃</span><span class=\"o\">))</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">,</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">d_comp_d</span><span class=\"o\">,</span> <span class=\"n\">refl</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">C.X</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">),</span> <span class=\"n\">d</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">→</span> <span class=\"bp\">∃</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">d</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">C.X</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">d</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">C.X</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">),</span> <span class=\"n\">d</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">specialize</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">),</span>\n  <span class=\"c1\">-- rw sub_add_cancel at h,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">C.X</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">d</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">→</span> <span class=\"bp\">∃</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">C.X</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">),</span> <span class=\"n\">d</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">C.X</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">d</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">d</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">specialize</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">),</span>\n  <span class=\"c1\">-- rw add_sub_cancel at h,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 226393769,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1613401280
    },
    {
        "content": "<p>I don't care so much about how we invoke automation, as long as it works <span aria-label=\"stuck out tongue wink\" class=\"emoji emoji-1f61c\" role=\"img\" title=\"stuck out tongue wink\">:stuck_out_tongue_wink:</span> </p>\n<ol>\n<li>The above approach hides an automatic tactic call behind <code>notation `d` </code>. Downside: the notation will not be used in the goal view.</li>\n<li>Use <code>auto_param</code>. But this doesn't work with bundled morphisms.</li>\n<li>Use <code>fact (i + 1 = j)</code>. I fear that this might not scale when it comes to chaining equalities together using transitivity.</li>\n</ol>",
        "id": 226394200,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1613401479
    },
    {
        "content": "<p>But the problem outlined above is orthogonal to these 3 approaches.</p>",
        "id": 226394237,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1613401502
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> Have you thought about trying tricks similar to the following?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[simp]</span> <span class=\"kd\">def</span> <span class=\"n\">test</span> <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">C.X</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">C.X</span> <span class=\"n\">i</span> <span class=\"o\">:=</span> <span class=\"n\">congr_hom</span> <span class=\"n\">C</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">int_magic</span><span class=\"o\">)</span> <span class=\"n\">x</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">cond</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">C.X</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">),</span> <span class=\"n\">true</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">C.X</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">true</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">cases</span> <span class=\"n\">cond</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">cond_w</span><span class=\"o\">,</span>\n  <span class=\"n\">finish</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 226395548,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1613402167
    },
    {
        "content": "<p>I don't know if this would be helpful at all.</p>",
        "id": 226395584,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1613402190
    },
    {
        "content": "<p>I would like to hide <code>congr_hom</code> as much as possible behind a basic API. Otherwise we'll end up with many silly proof steps, saying that the norm of <code>congr_hom x</code> is the same as the norm of <code>x</code>, etc... etc...</p>",
        "id": 226395808,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1613402308
    },
    {
        "content": "<p>I imagine we can solve these issues with some carefully chosen simp lemmas</p>",
        "id": 226395893,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1613402352
    },
    {
        "content": "<p>You can take a look at <code>system_of_complexes.lean</code> on the <code>wip_dtt</code> branch... it didn't look pleasant to me.</p>",
        "id": 226396239,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1613402508
    },
    {
        "content": "<p>There was the other proposal to use a massive direct sum, and define <code>d</code> on that. But I don't see how that will play nicely with either categorical language, where you don't have elements (so how do you define a complex in the first place? as something isomorphic to a massive direct sum?) or with elements (how do you move from <code>x : C i</code> to the massive direct sum? will we have canonical inclusion maps before every other element?).<br>\nStill, if someone wants to try a test of this, and it works well, then I'll shut up <span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span> <span aria-label=\"speak no evil\" class=\"emoji emoji-1f64a\" role=\"img\" title=\"speak no evil\">:speak_no_evil:</span></p>",
        "id": 226399165,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1613404024
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">C.X</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">),</span> <span class=\"n\">d</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">→</span> <span class=\"bp\">∃</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">d</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">C.X</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">d</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">C.X</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">),</span> <span class=\"n\">d</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">suffices</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">C.X</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hij</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">d</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">),</span>\n    <span class=\"bp\">∃</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">C.X</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">d</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">this</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">hx</span> <span class=\"o\">},</span> <span class=\"n\">clear</span> <span class=\"n\">hx</span> <span class=\"n\">x</span> <span class=\"n\">i</span><span class=\"o\">,</span>\n  <span class=\"n\">rintros</span> <span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"n\">x</span> <span class=\"n\">rfl</span> <span class=\"n\">hx</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">h</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">hx</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 226407344,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613407932
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">C.X</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">d</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">→</span> <span class=\"bp\">∃</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">C.X</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">),</span> <span class=\"n\">d</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">C.X</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">d</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">d</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">suffices</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">C.X</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hij</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">d</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">),</span>\n    <span class=\"bp\">∃</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">C.X</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">d</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">this</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">hx</span> <span class=\"o\">},</span> <span class=\"n\">clear</span> <span class=\"n\">hx</span> <span class=\"n\">x</span> <span class=\"n\">i</span><span class=\"o\">,</span>\n  <span class=\"n\">rintros</span> <span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"n\">x</span> <span class=\"n\">hij</span> <span class=\"n\">hx</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">hij'</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">j</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"n\">eq_sub_of_add_eq</span> <span class=\"n\">hij</span><span class=\"o\">,</span>\n  <span class=\"n\">subst</span> <span class=\"n\">hij'</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">h</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">hx</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 226407466,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613408041
    },
    {
        "content": "<p>Everything is easy if the hypothesis is stated in the type-theoretically correct way -- there are no fancy tricks here.</p>",
        "id": 226407538,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613408069
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"k\">suffices</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">C.X</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hij</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">d</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">),</span>\n    <span class=\"bp\">∃</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">C.X</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">d</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n</code></pre></div>\n<p>This is great because we're quantifying over <code>i</code> and <code>j</code>, and all our dependent types (<code>C.X i</code> and <code>C.X j</code>) can be specialised to the case in hand.</p>",
        "id": 226407628,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613408135
    },
    {
        "content": "<p>On the other hand, it means that we'll always be writing <code>(hij : i + 1 = j)</code> all over the place. It would be great if some tactic could remove that need.</p>",
        "id": 226410237,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1613409689
    },
    {
        "content": "<p>I like this solution, it puts the <code>i+1=j</code> proof into a subgoal where it can be proved by any means necessary</p>",
        "id": 226410517,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613409864
    },
    {
        "content": "<p>Writing nontrivial terms in rigid positions in a dependent type seems to be a recurring source of problems</p>",
        "id": 226410747,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613409992
    },
    {
        "content": "<p>Crazy idea: </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">open</span> <span class=\"n\">category_theory</span>\n<span class=\"kd\">def</span> <span class=\"n\">complex</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span> <span class=\"bp\">⥤</span> <span class=\"n\">AddCommGroup</span> <span class=\"bp\">//</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"bp\">≤</span> <span class=\"n\">j</span><span class=\"o\">),</span> <span class=\"n\">C.map</span> <span class=\"o\">(</span><span class=\"n\">hom_of_le</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 226410777,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1613410005
    },
    {
        "content": "<p>It'll be fun explaining that to the normal people</p>",
        "id": 226410837,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613410044
    },
    {
        "content": "<p>I guess that is of no relevance -- my students don't yet know what the actual definition of <code>is_compact</code> is and yet they can still prove things by finding finite subcovers of open covers</p>",
        "id": 226410960,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613410110
    },
    {
        "content": "<p>What's it supposed to look like? That seems like a pretty normal definition</p>",
        "id": 226410968,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613410115
    },
    {
        "content": "<p>d^2=0</p>",
        "id": 226410999,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613410132
    },
    {
        "content": "<p>I mean, like that exact string of characters. It's like a set phrase.</p>",
        "id": 226411058,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613410169
    },
    {
        "content": "<p>aha, I see now, I like this crazy idea</p>",
        "id": 226411102,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613410192
    },
    {
        "content": "<p>I have no idea how to search for d^2=0 on mathoverflow but I am convinced it will be everywhere.</p>",
        "id": 226411315,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613410274
    },
    {
        "content": "<p>I wonder how common it is to have this whole functor available instead of d</p>",
        "id": 226411341,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613410292
    },
    {
        "content": "<p>It's the fact that mathematicians constantly abuse this d notation to mean \"all the maps\" which makes me open to the idea of the direct sum approach, where one really does have one map d, from the direct sum (or disjoint union, depending on which category you're taking the coproduct in).</p>",
        "id": 226411511,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613410369
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/267928-condensed-mathematics/topic/homological.20headache/near/226411315\">said</a>:</p>\n<blockquote>\n<p>I have no idea how to search for d^2=0 on mathoverflow but I am convinced it will be everywhere.</p>\n</blockquote>\n<p>Not MO but <a href=\"https://approach0.xyz/search/?q=%24d%5E2%3D0%24&amp;p=1\">https://approach0.xyz/search/?q=%24d%5E2%3D0%24&amp;p=1</a></p>",
        "id": 226414266,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1613411881
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/267928-condensed-mathematics/topic/homological.20headache/near/226411511\">said</a>:</p>\n<blockquote>\n<p>It's the fact that mathematicians constantly abuse this d notation to mean \"all the maps\" which makes me open to the idea of the direct sum approach, where one really does have one map d, from the direct sum (or disjoint union, depending on which category you're taking the coproduct in).</p>\n</blockquote>\n<p>But I don't see how to write this down in lean, in such a way that you can do complexes of objects in an arbitrary (abelian) category, and at the same time make is useful when trying to apply <code>d</code> to elements of a module in some concrete complex.</p>",
        "id": 226416217,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1613413092
    },
    {
        "content": "<p>How do you express that the big complex-object is the direct sum of the constituent objects?</p>",
        "id": 226416252,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1613413122
    },
    {
        "content": "<p>Given any suitable definition of the <code>d</code> function, it's possible to construct a functor like <span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> 's version, and as long as you don't need to reduce it you can just work from that</p>",
        "id": 226416289,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613413180
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/267928-condensed-mathematics/topic/homological.20headache/near/226410777\">said</a>:</p>\n<blockquote>\n<p>Crazy idea: </p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">open</span> <span class=\"n\">category_theory</span>\n<span class=\"kd\">def</span> <span class=\"n\">complex</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span> <span class=\"bp\">⥤</span> <span class=\"n\">AddCommGroup</span> <span class=\"bp\">//</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"bp\">≤</span> <span class=\"n\">j</span><span class=\"o\">),</span> <span class=\"n\">C.map</span> <span class=\"o\">(</span><span class=\"n\">hom_of_le</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">}</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Would this solve the issue that we have in the example from the first post? Of does this just mean that we should never ever talk about <code>d</code>, and always use <code>hom_of_le</code> instead? Doesn't sound like it will be very readable... <span aria-label=\"sad\" class=\"emoji emoji-2639\" role=\"img\" title=\"sad\">:sad:</span></p>",
        "id": 226416367,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1613413220
    },
    {
        "content": "<p>I think you can wrap that behind a definition of type <code>\\all i j : int, C i -&gt; C j</code></p>",
        "id": 226416422,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613413298
    },
    {
        "content": "<p>Such a map only exists for i&lt;=j, right? The situation is C i -&gt; C (i + 1) -&gt; C (i + 2) -&gt; ...</p>",
        "id": 226416529,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613413356
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> I'm playing with this idea now. And the answer seems to be no, still getting the same issue :-/</p>",
        "id": 226416532,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1613413358
    },
    {
        "content": "<p>ah yeah, it would be <code>\\all i j, i &lt;= j -&gt; C i -&gt; C j</code></p>",
        "id": 226416556,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613413378
    },
    {
        "content": "<p>and I guess the last arrow is a hom of some kind</p>",
        "id": 226416601,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613413413
    },
    {
        "content": "<p>I guess the category of finite abelian groups is a perfectly good abelian category which doesn't have infinite direct sums.</p>",
        "id": 226416616,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613413426
    },
    {
        "content": "<p>Is it possible / desirable to totalize here? C j is an abelian group so you've got the zero morphism</p>",
        "id": 226416688,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613413460
    },
    {
        "content": "<p>yeah, there are zero morphisms in an arbitrary abelian category too</p>",
        "id": 226416713,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613413491
    },
    {
        "content": "<p>leading to the less well known identity <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>d</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo>=</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">d^{-1}=0</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span></p>",
        "id": 226416930,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613413680
    },
    {
        "content": "<p>But even if you totalize... does this mean we should just put type ascriptions every where? And give up on the idea that <code>d</code> is a degree 1 map?</p>",
        "id": 226417340,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1613413935
    },
    {
        "content": "<p>So you have <code>d : C i -&gt; C j</code> for all <code>i</code> and <code>j</code>. And</p>\n<ol>\n<li>if <code>j = i</code>, then <code>d = id</code></li>\n<li>if <code>j = i</code>, then <code>d = </code> \"the <em>actual</em> <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>d</mi></mrow><annotation encoding=\"application/x-tex\">d</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">d</span></span></span></span>\"</li>\n<li>otherwise, <code>d = 0</code></li>\n</ol>",
        "id": 226417420,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1613414016
    },
    {
        "content": "<p><del>And so there will be a simp lemma that says that <code>d</code> composed with <code>d</code> is <code>d</code></del> (This is false, the right hand side could be <code>id</code> while the left hand side is <code>d &gt;&gt; 0</code>). And</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">d_eq_zero</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"bp\">\\</span><span class=\"n\">le</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"n\">i</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">C</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 226417552,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1613414107
    },
    {
        "content": "<p>I was just hoping that lean would be able to infer the type of <code>d x</code> from the type of <code>x</code>... but I guess that's asking for lots of pain, at least in lean3.</p>",
        "id": 226417649,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1613414168
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.homology.chain_complex</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.category.Group</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">category_theory</span> <span class=\"n\">AddCommGroup.colimits</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">mk_graded</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span> <span class=\"bp\">→</span> <span class=\"n\">AddCommGroup</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">AddCommGroup</span> <span class=\"o\">:=</span> <span class=\"n\">AddCommGroup.colimits.colimit</span> <span class=\"o\">(</span><span class=\"n\">discrete.functor</span> <span class=\"n\">F</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">ι</span> <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span> <span class=\"bp\">→</span> <span class=\"n\">AddCommGroup</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">F</span> <span class=\"n\">i</span> <span class=\"bp\">⟶</span> <span class=\"n\">mk_graded</span> <span class=\"n\">F</span> <span class=\"o\">:=</span> <span class=\"n\">cocone_morphism</span> <span class=\"o\">(</span><span class=\"n\">discrete.functor</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"n\">i</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">complex</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span> <span class=\"bp\">→</span> <span class=\"n\">AddCommGroup</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">mk_graded</span> <span class=\"n\">F</span> <span class=\"bp\">⟶</span> <span class=\"n\">mk_graded</span> <span class=\"n\">F</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">d_graded</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">F</span> <span class=\"n\">i</span> <span class=\"bp\">⟶</span> <span class=\"n\">F</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">),</span> <span class=\"n\">ι</span> <span class=\"bp\">≫</span> <span class=\"n\">d</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"bp\">≫</span> <span class=\"n\">ι</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">d_squared</span> <span class=\"o\">:</span> <span class=\"n\">d</span> <span class=\"bp\">≫</span> <span class=\"n\">d</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 226417688,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1613414205
    },
    {
        "content": "<p>In case anyone wants to play with a totalized version</p>",
        "id": 226417730,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1613414241
    },
    {
        "content": "<p>But there are two downsides, afaik (sorry for being critical, without having a better solution):</p>\n<ol>\n<li><code>mk_graded</code> might not fit into your category (e.g. complexes of findim vector spaces)</li>\n<li>if I have a concrete example of a complex, then I will have some <code>x : F i</code>, and if I want to do a bit of homological algebra, then those <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ι</mi></mrow><annotation encoding=\"application/x-tex\">\\iota</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">ι</span></span></span></span> maps will be all over the place</li>\n</ol>",
        "id": 226417947,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1613414395
    },
    {
        "content": "<p>Yeah, I agree. But I still think it's worth some experimentation</p>",
        "id": 226418044,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1613414462
    },
    {
        "content": "<blockquote>\n<p>those <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ι</mi></mrow><annotation encoding=\"application/x-tex\">\\iota</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">ι</span></span></span></span> maps will be all over the place</p>\n</blockquote>\n<p>I don't think this is a major problem; it's kind of like working with integer expressions involving nats with <code>\\u a + \\u b - 1 = \\u c</code></p>",
        "id": 226418144,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613414529
    },
    {
        "content": "<p>Regarding 1, is it possible to take a synthetic colimit here, putting you in a completion of the original category? Like a sigma</p>",
        "id": 226418277,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613414634
    },
    {
        "content": "<p>Yeah, that's what I'm thinking too.</p>",
        "id": 226418339,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1613414657
    },
    {
        "content": "<p>Maybe <span class=\"user-mention\" data-user-id=\"246273\">@Bhavik Mehta</span> 's work on ind completions would help here.</p>",
        "id": 226418352,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1613414666
    },
    {
        "content": "<p>Yeah you can take the synthetic colimit if it's a filtered colimit, but there's already the free cocompletion in mathlib</p>",
        "id": 226418732,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1613415000
    },
    {
        "content": "<p>But this comes with the caveat that the new category will be (potentially) a lot bigger than the original one - even in non-Lean maths if you take the cocompletion of a small category you end up with a large one</p>",
        "id": 226418825,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1613415058
    },
    {
        "content": "<p>Plus the differential in the complex would become some morphism of presheaves, which might confuse even more people :)</p>",
        "id": 226418880,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1613415115
    },
    {
        "content": "<p>In this case you only need the completion wrt colimits of length <code>int</code></p>",
        "id": 226418992,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613415174
    },
    {
        "content": "<p>I still kind of think that d : C_i -&gt; C_j = 0 for i &gt; j is kind of insane. It would then not be true that for all i,j,k, d o d = d, for example. Chains seem to have been implemented as a functor from the integers (so again there are no d's if i &gt; j) and the \"d = 0 if i+2&lt;=j\" condition does sound like a cool way of setting it up.</p>",
        "id": 226419064,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613415236
    },
    {
        "content": "<blockquote>\n<p>It would then not be true that for all i,j,k, d o d = d, for example.</p>\n</blockquote>\n<p>That was never true, because d o d = d doesn't typecheck for a lot of values of i,j,k</p>",
        "id": 226419165,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613415291
    },
    {
        "content": "<p>chain complexes have an \"ad hoc\" definition. They aren't implemented as functors. Just a collection of <code>int</code>-indexed objects with a <code>d</code> (of degree 1) between them.</p>",
        "id": 226419198,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1613415311
    },
    {
        "content": "<p>the only difference now is that those assumptions are moving from type correctness assumptions to regular assumptions</p>",
        "id": 226419221,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613415323
    },
    {
        "content": "<p>it also means that you get less type inference. so statements will become a lot clunkier</p>",
        "id": 226419437,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1613415464
    },
    {
        "content": "<p>I'm not sure the hypotheses that were being supplied are actually the ones you want though</p>",
        "id": 226419540,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613415517
    },
    {
        "content": "<p>for example a type correctness hypothesis might be needlessly obtuse like <code>i+1+1 &lt;= j+1</code> while a regular hypothesis can be stated as <code>i+1 &lt;= j</code></p>",
        "id": 226419572,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613415554
    },
    {
        "content": "<p>I've adapted the example to a totalized <code>d</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.category.Group</span>\n<span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">category_theory</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">cochain_complex</span> <span class=\"kd\">extends</span> <span class=\"n\">ℤ</span> <span class=\"bp\">⥤</span> <span class=\"n\">AddCommGroup</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">is_complex</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"bp\">≤</span> <span class=\"n\">j</span><span class=\"o\">),</span> <span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">hom_of_le</span> <span class=\"o\">(</span><span class=\"k\">show</span> <span class=\"n\">i</span> <span class=\"bp\">≤</span> <span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">linarith</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">cochain_complex</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">}</span>\n\n<span class=\"sd\">/-- `C.d` is the differential `C i ⟶ C (i+1)` for a cochain complex `C`. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">C.obj</span> <span class=\"n\">i</span> <span class=\"bp\">⟶</span> <span class=\"n\">C.obj</span> <span class=\"n\">j</span> <span class=\"o\">:=</span>\n<span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">≤</span> <span class=\"n\">j</span> <span class=\"k\">then</span> <span class=\"n\">C.map</span> <span class=\"o\">(</span><span class=\"n\">hom_of_le</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"k\">else</span> <span class=\"mi\">0</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">d_comp_d</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"bp\">≤</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">C.obj</span> <span class=\"n\">i</span> <span class=\"bp\">⟶</span> <span class=\"n\">C.obj</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"bp\">≫</span> <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">C.obj</span> <span class=\"n\">j</span> <span class=\"bp\">⟶</span> <span class=\"n\">C.obj</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">delta</span> <span class=\"n\">d</span><span class=\"o\">,</span>\n  <span class=\"n\">by_cases</span> <span class=\"n\">h12</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">≤</span> <span class=\"n\">j</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">by_cases</span> <span class=\"n\">h23</span> <span class=\"o\">:</span> <span class=\"n\">j</span> <span class=\"bp\">≤</span> <span class=\"n\">k</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">dif_pos</span> <span class=\"n\">h12</span><span class=\"o\">,</span> <span class=\"n\">dif_pos</span> <span class=\"n\">h23</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">functor.map_comp</span><span class=\"o\">],</span>\n      <span class=\"n\">exact</span> <span class=\"n\">C.is_complex</span> <span class=\"n\">i</span> <span class=\"n\">k</span> <span class=\"n\">h</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">dif_neg</span> <span class=\"n\">h23</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"n\">limits.comp_zero</span> <span class=\"o\">}</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">dif_neg</span> <span class=\"n\">h12</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"n\">limits.zero_comp</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">d_d</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"bp\">≤</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">C.obj</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">C.obj</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">C.obj</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"k\">show</span> <span class=\"o\">((</span><span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">C.obj</span> <span class=\"n\">i</span> <span class=\"bp\">⟶</span> <span class=\"n\">C.obj</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"bp\">≫</span> <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">C.obj</span> <span class=\"n\">j</span> <span class=\"bp\">⟶</span> <span class=\"n\">C.obj</span> <span class=\"n\">k</span><span class=\"o\">))</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">,</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">d_comp_d</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">refl</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">C.obj</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">C.obj</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">+</span><span class=\"mi\">2</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">→</span> <span class=\"bp\">∃</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">C.obj</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">d</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">C.obj</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">C.obj</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">C.obj</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">),</span> <span class=\"n\">d</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">specialize</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">),</span>\n  <span class=\"c1\">-- rw sub_add_cancel at h,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">C.obj</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">C.obj</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">→</span> <span class=\"bp\">∃</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">C.obj</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">),</span> <span class=\"n\">d</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">C.obj</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">C.obj</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">C.obj</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">d</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">specialize</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">),</span>\n  <span class=\"c1\">-- rw add_sub_cancel at h,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 226420892,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1613416416
    },
    {
        "content": "<p>But these statements are still problematic... Should they be written differently now? I don't see how.</p>",
        "id": 226420987,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1613416466
    },
    {
        "content": "<p>Unless we use Kevin's approach again... but that also worked with the untotal <code>d</code>.</p>",
        "id": 226421024,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1613416500
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/267928-condensed-mathematics/topic/homological.20headache/near/226419198\">said</a>:</p>\n<blockquote>\n<p>chain complexes have an \"ad hoc\" definition. They aren't implemented as functors. Just a collection of <code>int</code>-indexed objects with a <code>d</code> (of degree 1) between them.</p>\n</blockquote>\n<p>Oh sorry, I was looking at Adam's definition! I had assumed it was official in some way :-) I think that it definitely has its merits!</p>",
        "id": 226421277,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613416647
    },
    {
        "content": "<p>What's problematic? The <code>rw add_sub_cancel</code> lines work now</p>",
        "id": 226421495,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613416765
    },
    {
        "content": "<p>Sure, but we would definitely want a constructor that only needs a degree 1 map. E.g., when building a complex from a simplicial module by taking alternating sums of the degeneracy maps... you don't want to worry about arbitrary compositions at that point.</p>",
        "id": 226421500,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1613416769
    },
    {
        "content": "<p>and you can use <code>i+2</code> instead of <code>i+1+1</code></p>",
        "id": 226421526,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613416791
    },
    {
        "content": "<p>aah, so why is <code>rw</code> working and <code>simp</code> failing?</p>",
        "id": 226421587,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1613416806
    },
    {
        "content": "<p>Yeah:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">C.obj</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">C.obj</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">+</span><span class=\"mi\">2</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">→</span> <span class=\"bp\">∃</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">C.obj</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">d</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">C.obj</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">C.obj</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">C.obj</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">),</span> <span class=\"n\">d</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">specialize</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">),</span>\n  <span class=\"n\">rw</span> <span class=\"n\">sub_add_cancel</span> <span class=\"n\">i</span> <span class=\"mi\">1</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">assumption</span><span class=\"o\">,</span> <span class=\"c1\">-- fails :(</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 226421618,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1613416822
    },
    {
        "content": "<p>The <code>d x = 0</code> assumption doesn't match with the <code>d x = 0</code> goal.</p>",
        "id": 226421636,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1613416839
    },
    {
        "content": "<p>I think this would be a lot clearer (and shorter than the type ascriptions) if <code>j</code> was an explicit arg to <code>d</code></p>",
        "id": 226421712,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613416911
    },
    {
        "content": "<p>We might need to do that</p>",
        "id": 226421794,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1613416963
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/267928-condensed-mathematics/topic/homological.20headache/near/226421526\">said</a>:</p>\n<blockquote>\n<p>and you can use <code>i+2</code> instead of <code>i+1+1</code></p>\n</blockquote>\n<p>this causes the fail that Adam noticed</p>",
        "id": 226421811,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1613416976
    },
    {
        "content": "<p>I think d should take a proof that i &lt;= j. That proof which split up into cases -- nobody is going to need the j &lt; i situation ever, right?</p>",
        "id": 226421840,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613417003
    },
    {
        "content": "<p>that's what causes all the <code>simp</code> sadness though</p>",
        "id": 226421872,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613417031
    },
    {
        "content": "<p>Because it's a proof, we don't care if we have a proof of i &lt;= j + 1 - 1 or whatever</p>",
        "id": 226421877,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613417035
    },
    {
        "content": "<p>but if it's an arg to <code>d</code> then it ends up in statements which is why nothing rewrites properly</p>",
        "id": 226421952,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613417097
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> why can't <code>angry_simp</code> just blast through those annoying badly-typed motives?</p>",
        "id": 226421975,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1613417109
    },
    {
        "content": "<p>It will have to fix up those proof arguments... but isn't that just some <code>trans</code> or <code>subst</code>?</p>",
        "id": 226422017,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1613417135
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.category.Group</span>\n<span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">category_theory</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">cochain_complex</span> <span class=\"kd\">extends</span> <span class=\"n\">ℤ</span> <span class=\"bp\">⥤</span> <span class=\"n\">AddCommGroup</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">is_complex</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"bp\">≤</span> <span class=\"n\">j</span><span class=\"o\">),</span> <span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">hom_of_le</span> <span class=\"o\">(</span><span class=\"k\">show</span> <span class=\"n\">i</span> <span class=\"bp\">≤</span> <span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">linarith</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">cochain_complex</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">}</span>\n\n<span class=\"sd\">/-- `C.d` is the differential `C i ⟶ C (i+1)` for a cochain complex `C`. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">C.obj</span> <span class=\"n\">i</span> <span class=\"bp\">⟶</span> <span class=\"n\">C.obj</span> <span class=\"n\">j</span> <span class=\"o\">:=</span>\n<span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">≤</span> <span class=\"n\">j</span> <span class=\"k\">then</span> <span class=\"n\">C.map</span> <span class=\"o\">(</span><span class=\"n\">hom_of_le</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"k\">else</span> <span class=\"mi\">0</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">d'</span> <span class=\"o\">(</span><span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">C.obj</span> <span class=\"n\">i</span> <span class=\"bp\">⟶</span> <span class=\"n\">C.obj</span> <span class=\"n\">j</span> <span class=\"o\">:=</span> <span class=\"n\">d</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">d_comp_d</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"bp\">≤</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">C.obj</span> <span class=\"n\">i</span> <span class=\"bp\">⟶</span> <span class=\"n\">C.obj</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"bp\">≫</span> <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">C.obj</span> <span class=\"n\">j</span> <span class=\"bp\">⟶</span> <span class=\"n\">C.obj</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">delta</span> <span class=\"n\">d</span><span class=\"o\">,</span>\n  <span class=\"n\">by_cases</span> <span class=\"n\">h12</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">≤</span> <span class=\"n\">j</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">by_cases</span> <span class=\"n\">h23</span> <span class=\"o\">:</span> <span class=\"n\">j</span> <span class=\"bp\">≤</span> <span class=\"n\">k</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">dif_pos</span> <span class=\"n\">h12</span><span class=\"o\">,</span> <span class=\"n\">dif_pos</span> <span class=\"n\">h23</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">functor.map_comp</span><span class=\"o\">],</span>\n      <span class=\"n\">exact</span> <span class=\"n\">C.is_complex</span> <span class=\"n\">i</span> <span class=\"n\">k</span> <span class=\"n\">h</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">dif_neg</span> <span class=\"n\">h23</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"n\">limits.comp_zero</span> <span class=\"o\">}</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">dif_neg</span> <span class=\"n\">h12</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"n\">limits.zero_comp</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">d_d</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"bp\">≤</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">C.obj</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">C.obj</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">C.obj</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"k\">show</span> <span class=\"o\">((</span><span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">C.obj</span> <span class=\"n\">i</span> <span class=\"bp\">⟶</span> <span class=\"n\">C.obj</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"bp\">≫</span> <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">C.obj</span> <span class=\"n\">j</span> <span class=\"bp\">⟶</span> <span class=\"n\">C.obj</span> <span class=\"n\">k</span><span class=\"o\">))</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">,</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">d_comp_d</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">refl</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">C.obj</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">d'</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">+</span><span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">→</span> <span class=\"bp\">∃</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">C.obj</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">d</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">C.obj</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">d'</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">C.obj</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">),</span> <span class=\"n\">d</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">specialize</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">),</span>\n  <span class=\"n\">rw</span> <span class=\"o\">(</span><span class=\"k\">show</span> <span class=\"n\">i</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"bp\">+</span><span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">ring</span><span class=\"o\">)</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">(</span><span class=\"k\">show</span> <span class=\"n\">i</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"bp\">+</span><span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"n\">i</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">ring</span><span class=\"o\">)</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">h</span> <span class=\"n\">_</span> <span class=\"n\">hx</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">C.obj</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">C.obj</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">→</span> <span class=\"bp\">∃</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">C.obj</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">),</span> <span class=\"n\">d</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">C.obj</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">C.obj</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">C.obj</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">d</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">specialize</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">),</span>\n  <span class=\"n\">rw</span> <span class=\"o\">(</span><span class=\"k\">show</span> <span class=\"n\">i</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"bp\">-</span><span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">ring</span><span class=\"o\">)</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">h</span> <span class=\"n\">_</span> <span class=\"n\">hx</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 226422161,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1613417235
    },
    {
        "content": "<p>simp's instead of rewrites still don't seem to work</p>",
        "id": 226422180,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1613417253
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- `C.d` is the differential `C i ⟶ C (i+1)` for a cochain complex `C`. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">d</span> <span class=\"o\">(</span><span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">C.obj</span> <span class=\"n\">i</span> <span class=\"bp\">⟶</span> <span class=\"n\">C.obj</span> <span class=\"n\">j</span> <span class=\"o\">:=</span>\n<span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">≤</span> <span class=\"n\">j</span> <span class=\"k\">then</span> <span class=\"n\">C.map</span> <span class=\"o\">(</span><span class=\"n\">hom_of_le</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"k\">else</span> <span class=\"mi\">0</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">d_comp_d</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"bp\">≤</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">C.obj</span> <span class=\"n\">i</span> <span class=\"bp\">⟶</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">≫</span> <span class=\"n\">d</span> <span class=\"n\">k</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">delta</span> <span class=\"n\">d</span><span class=\"o\">,</span>\n  <span class=\"n\">by_cases</span> <span class=\"n\">h12</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">≤</span> <span class=\"n\">j</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">by_cases</span> <span class=\"n\">h23</span> <span class=\"o\">:</span> <span class=\"n\">j</span> <span class=\"bp\">≤</span> <span class=\"n\">k</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">dif_pos</span> <span class=\"n\">h12</span><span class=\"o\">,</span> <span class=\"n\">dif_pos</span> <span class=\"n\">h23</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">functor.map_comp</span><span class=\"o\">],</span>\n      <span class=\"n\">exact</span> <span class=\"n\">C.is_complex</span> <span class=\"n\">i</span> <span class=\"n\">k</span> <span class=\"n\">h</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">dif_neg</span> <span class=\"n\">h23</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"n\">limits.comp_zero</span> <span class=\"o\">}</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">dif_neg</span> <span class=\"n\">h12</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"n\">limits.zero_comp</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">d_d</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"bp\">≤</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">C.obj</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">d</span> <span class=\"n\">k</span> <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"n\">j</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"k\">show</span> <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"n\">j</span> <span class=\"bp\">≫</span> <span class=\"n\">d</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">d_comp_d</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">refl</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">C.obj</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">),</span> <span class=\"n\">d</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">+</span><span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">→</span> <span class=\"bp\">∃</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">C.obj</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">d</span> <span class=\"n\">_</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">C.obj</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">d</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">C.obj</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">),</span> <span class=\"n\">d</span> <span class=\"n\">_</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">specialize</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">),</span>\n  <span class=\"n\">rw</span> <span class=\"n\">sub_add_cancel</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">rwa</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">linarith</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"n\">i</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">),</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 226422208,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613417280
    },
    {
        "content": "<p>The statements are indeed a lot shorter, and <code>simp</code> doesn't work because it involves uniformly rewriting in places where <code>simp</code> can't reach because of dependencies (the <code>rwa</code> is actually changing the type of the equality)</p>",
        "id": 226422432,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613417416
    },
    {
        "content": "<p><code>rw</code> is too stupid to question whether the rewrite is going to work, it just yolo's and reports <code>motive is not type correct</code> if it turns out not to work</p>",
        "id": 226422488,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613417468
    },
    {
        "content": "<p>I want <code>yolo_simp</code></p>",
        "id": 226422520,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1613417496
    },
    {
        "content": "<p>Are there theoretical obstructions to its existence? Or could a carefully crafted <code>dtt_simp</code> make life easier, without resigning to a bunch of ad hoc hacks?</p>",
        "id": 226422616,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1613417539
    },
    {
        "content": "<p>well the disadvantage of the yolo approach is that you can end up getting tripped up by occurrences of the pattern where it would be best not to touch, like inside proof arguments in the statement</p>",
        "id": 226422691,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613417598
    },
    {
        "content": "<p>A usable but kind of ugly solution would be to specify exactly which occurrences you want to replace</p>",
        "id": 226422778,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613417652
    },
    {
        "content": "<p>and that still might not work with situations like the rewrite you sent me</p>\n<blockquote>\n<p>Is the issue that <code>(is_weak_bounded_exact._proof_2 (i + 1))</code> is only a proof of <code>i + 1 - 1 + 1 = i + 1</code> and not a proof of <code>i + 1 = i + 1</code>?</p>\n</blockquote>",
        "id": 226422881,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613417748
    },
    {
        "content": "<p>As for dtt_simp, things get pretty hairy once you have heterogeneous equality. I think there is a way to do this but it requires pathovers, which we don't have in mathlib</p>",
        "id": 226423039,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613417868
    },
    {
        "content": "<p>But those kind of proofs should be fixable, right? By doing some transitivity of equality.</p>",
        "id": 226423059,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1613417882
    },
    {
        "content": "<p>Yes, the solution is to replace the proof <code>is_weak_bounded_exact._proof_2 (i + 1)</code> with <code>congr_arg (+1) h</code> where <code>h : i + 1 - 1 = 1</code> is the lemma you are rewriting with</p>",
        "id": 226423159,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613417927
    },
    {
        "content": "<p>and then replace <code>h</code> with <code>rfl</code> along with everything else</p>",
        "id": 226423177,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613417942
    },
    {
        "content": "<p>but doing that in a <code>rw</code> line with no hairy middle steps is a challenge</p>",
        "id": 226423204,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613417970
    },
    {
        "content": "<p>Here's the \"generalize\" approach:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">C.obj</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">C.obj</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">+</span><span class=\"mi\">2</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">→</span> <span class=\"bp\">∃</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">C.obj</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">d</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">C.obj</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">C.obj</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">C.obj</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">),</span> <span class=\"n\">d</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">suffices</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">,</span> <span class=\"n\">j</span> <span class=\"bp\">=</span> <span class=\"n\">i</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">→</span> <span class=\"n\">k</span> <span class=\"bp\">=</span> <span class=\"n\">i</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"bp\">→</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">C.obj</span> <span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">C.obj</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">→</span> <span class=\"bp\">∃</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">C.obj</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">d</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"n\">this</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">hx</span><span class=\"bp\">;</span> <span class=\"n\">ring</span> <span class=\"o\">},</span> <span class=\"n\">clear</span> <span class=\"n\">hx</span> <span class=\"n\">x</span> <span class=\"n\">i</span><span class=\"o\">,</span>\n  <span class=\"n\">rintros</span> <span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"n\">k</span> <span class=\"n\">rfl</span> <span class=\"n\">rfl</span> <span class=\"n\">x</span> <span class=\"n\">hx</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">h</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">hx</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 226423296,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613418007
    },
    {
        "content": "<p>The <code>generalize_proofs</code> tactic may come in useful here, it will hoist these lemmas into the context where you can replace them in a more targeted way</p>",
        "id": 226423309,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613418019
    },
    {
        "content": "<p>The suffices line is morally equivalent to the motive that <code>rw</code> is cooking up - the trick is to generalize the right things in the context and it's easy but verbose for a human and hard for a tactic that doesn't know what you are trying to do</p>",
        "id": 226423554,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613418147
    },
    {
        "content": "<p>Sorry for a (very likely) useless suggestion, but is <a href=\"https://www.cl.cam.ac.uk/~jdy22/papers/frex-indexing-modulo-equations-with-free-extensions.pdf\">https://www.cl.cam.ac.uk/~jdy22/papers/frex-indexing-modulo-equations-with-free-extensions.pdf</a> useful for the index computations? I guess it at least provides funny terms such as \"slime avoidance\" and \"fording\"</p>",
        "id": 226424363,
        "sender_full_name": "Mauricio Collares",
        "timestamp": 1613418711
    },
    {
        "content": "<p>It certainly looks relevant... but I don't know enough type theory lingo to see how to apply it in the context at hand</p>",
        "id": 226425603,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1613419695
    },
    {
        "content": "<p>Looks like I missed some fun. :-) I've played with this <code>ℤ ⥤ V</code> with <code>C.map (hom_of_le _) = 0</code> a few times previously. It's a fun definition, and if it actually helped I'm sure we could persuade people that it wasn't insane...</p>",
        "id": 226460167,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1613436834
    },
    {
        "content": "<p>But I'm not sure that you get anything from this definition that you don't get just by being careful to insert lots of <code>eq_to_hom</code>s.</p>",
        "id": 226460247,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1613436921
    },
    {
        "content": "<p>I think the statements are generally shorter, and you don't have proofs in the statements which causes most of the problem in proofs</p>",
        "id": 226461360,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613438346
    },
    {
        "content": "<p>I guess what I meant was that you still frequently need to move between <code>C.X i</code> and <code>C.X j</code> when you know <code>i = j</code>, you just have an extra way to do this: <code>C.map (hom_of_le (le_of_eq h))</code>, in addition to the general purpose <code>eq_to_hom (congr_arg C.X h)</code>.</p>",
        "id": 226463949,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1613441499
    },
    {
        "content": "<p>I experimented with yet another definition of a complex, that seems to specialise reasonably to <code>int</code> indexed (co)chain complexes, and to <code>nat</code> indexed chain complexes.</p>\n<p>It is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">hc</span> <span class=\"o\">{</span><span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">N</span> <span class=\"bp\">→</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">N</span><span class=\"o\">,</span> <span class=\"n\">X</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">⟶</span> <span class=\"n\">X</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">b</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">d_squared'</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"n\">a</span><span class=\"o\">),</span> <span class=\"n\">d</span> <span class=\"n\">n</span> <span class=\"bp\">≫</span> <span class=\"n\">tra</span> <span class=\"n\">X</span> <span class=\"n\">h</span> <span class=\"bp\">≫</span> <span class=\"n\">d</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">.</span> <span class=\"n\">d_squared_tac</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Here:</p>\n<ul>\n<li>there are _two_ parameters <code>a b</code> in the definition, which controls where the differential goes. <ul>\n<li>for <code>int</code> indexed chain complexes you want <code>a=0, b=-1</code>.</li>\n<li>for <code>int</code> indexed cochain complexes you want <code>a=0, b=1</code>.</li>\n<li>for <code>nat</code> indexed chain complexes you want <code>a=1, b=0</code>.</li>\n</ul>\n</li>\n<li><code>tra X h</code> is just defined as <code>eq_to_hom (congr_arg X h)</code>, i.e. it's transport through a type family, as a morphism in the category</li>\n<li><code>d_squared_tac</code> is <code>`[{ intros n m h, simp at h, try { subst h }, obviously }]</code>.</li>\n</ul>\n<p>You can see in <code>https://github.com/leanprover-community/mathlib/blob/hexp/src/algebra/homology/chain_complex_2.lean</code> that at least building the equivalence of categories to cochain complexes, or the equivalence to <code>nat</code>-indexed chain complexes as proposed in <a href=\"https://github.com/leanprover-community/mathlib/issues/6260\">#6260</a>, is _relatively_ painless -- <code>d_squared_tac</code> works when you want it to, and <code>tidy</code> manages all the proofs.</p>\n<p>Of course, just proving equivalences between definitions is far from enough evidence that this is usable.</p>",
        "id": 226950877,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1613734108
    },
    {
        "content": "<p>I was pretty happy in in <a href=\"https://github.com/leanprover-community/mathlib/issues/6308\">#6308</a> that the <code>nat</code> indexed chain complexes of <a href=\"https://github.com/leanprover-community/mathlib/issues/6260\">#6260</a> worked smoothly for defining the Moore complex. So that is some evidence that that definition is usable. I may try redoing the Moore complex using this definition, to see how it goes.</p>",
        "id": 226950966,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1613734200
    },
    {
        "content": "<p>The other obvious tests are:</p>\n<ul>\n<li>adapt the existing <code>algebra/homology/homology.lean</code></li>\n<li>write some other equivalences (e.g. coming from an additive automorphism of the indexing monoid <code>N</code>)</li>\n<li>show that given an inclusion of monoids, the chain complexes on the small monoid are equivalent to chain complexes indexed by the big monoid, supported on the small monoid</li>\n</ul>",
        "id": 226951109,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1613734322
    },
    {
        "content": "<p>These aren't the most exciting tests to carry out... So I'm happy to hear feedback or take directions. :-)</p>",
        "id": 226951194,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1613734360
    },
    {
        "content": "<p>I'd also like to test out the <code>ℕ ⥤ V</code> approach, of course.</p>",
        "id": 226951254,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1613734390
    },
    {
        "content": "<p>Another test is to switch (a branch of) <code>lean-liquid</code> over to your mathlib branch, and rewrite the homological algebra that we've done so far, in terms of this new definition.</p>",
        "id": 226951574,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1613734619
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"111080\">@Floris van Doorn</span> did some homological algebra in Lean 2 using a <code>succ_structure</code> for a base.</p>",
        "id": 226951970,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613734871
    },
    {
        "content": "<p>Yeah, in Lean 2 I defined <a href=\"https://github.com/leanprover/lean2/blob/master/hott/homotopy/chain_complex.hlean#L8-L12\">chain complexes</a> indexed by a \"successor structure\" which is just any type equipped with an endofunction, called the successor. It worked nicely, especially when dealing with chain complexes that have some vague periodicity. For example, the long exact sequence of homotopy groups was indexed by <code>nat x fin 3</code>, since every three indices you go up one dimension.</p>\n<p>Scott's <code>add_comm_monoid</code> also works for this, and has the advantage that it works well with cochain complexes defined over <code>nat</code> (in my definition this didn't work great, since it would contain one extra map: <code>... &lt;- X 2 &lt;- X 1 &lt;- X 0 &lt;- X (pred 0)</code>)</p>\n<p>I also defined <a href=\"https://github.com/cmu-phil/Spectral/blob/master/algebra/graded.hlean#L17-L34\">graded objects</a>. The linked comment describes two design decisions that are worth considering, though I'm not sure if they would be right for mathlib ((1) looks strange, and (2) might not be a problem if tidy can deal with all the transports.</p>",
        "id": 227107359,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1613844169
    },
    {
        "content": "<p>So far, we've been running headfirst into the wall that (2) describes <span aria-label=\"head bandage\" class=\"emoji emoji-1f915\" role=\"img\" title=\"head bandage\">:head_bandage:</span></p>",
        "id": 227108053,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1613844849
    },
    {
        "content": "<p>So I'm inclined to define <code>d</code> as something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">d</span> <span class=\"o\">{</span><span class=\"n\">i</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"n\">i</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">X</span> <span class=\"n\">j</span> <span class=\"o\">:=</span>\n<span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">j</span> <span class=\"k\">then</span> <span class=\"o\">(</span><span class=\"n\">actual</span> <span class=\"kd\">def</span><span class=\"o\">)</span> <span class=\"k\">else</span> <span class=\"mi\">0</span>\n</code></pre></div>",
        "id": 227108086,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1613844907
    },
    {
        "content": "<p>Note that <code>d &gt;&gt; d = 0</code> will then hold without proof obligations. For other lemmas/facts we might want to have an auto param that automatically discharges the <code>i + 1 = j</code>-type goals</p>",
        "id": 227108184,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1613844980
    },
    {
        "content": "<p>probably a combi of <code>ring</code> and maybe <code>linarith</code></p>",
        "id": 227108189,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1613844995
    }
]
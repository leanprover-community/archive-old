[
    {
        "content": "<p>What do you think about changing our definition of <code>Condensed.{u} Ab.{u+1}</code> to <code>Condensed.{u} (Module.{u+1} \\Z)</code>. </p>\n<p>The benefit is that mathlib has the monoidal structure for <code>Module</code> but not for <code>Ab</code>, and I don't feel like copying a bunch of code and being annoyed due to going back and forth between <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Z}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">Z</span></span></span></span>-linear maps and <code>add_monoid_hom</code>s.</p>\n<p>The drawback is that it will require generalizing some universe parameters in mathlib, since the monoidal structure right now is only defined for <code>Module.{u} R</code> where <code>R : Type u</code> is a ring, and similarly for colimits of modules.</p>\n<p>I'll at least start by trying to generalize these universe parameters (it shouldn't be too difficult, I hope...).</p>",
        "id": 270502165,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1643865491
    },
    {
        "content": "<p>Ah, okay, the first snag is the monoidal unit would have to involve ulifts.</p>",
        "id": 270502412,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1643865775
    },
    {
        "content": "<p>Okay, I'm starting to think that it would be less painful to just stick with <code>Ab</code>, and copy some code from mathlib about the fact that <code>Module R</code> is monoidal.</p>",
        "id": 270503156,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1643866537
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/267928-condensed-mathematics/topic/Potential.20Refactor/near/270502412\">said</a>:</p>\n<blockquote>\n<p>Ah, okay, the first snag is the monoidal unit would have to involve ulifts.</p>\n</blockquote>\n<p>I'm now convinced that we should just stick with <code>Ab</code>. The required universe changes in mathlib would take up more work than it's worth right now IMO. </p>\n<p>It's unfortunate that we can't just easily go back and forth between <code>Ab.{u}</code> and <code>Module.{u} \\Z</code>. Is there something we can do about that?</p>",
        "id": 270503584,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1643866934
    },
    {
        "content": "<p>I guess we would need a universe polymorphic <code>ℤ</code> (ahhrgg <span aria-label=\"scream cat\" class=\"emoji emoji-1f640\" role=\"img\" title=\"scream cat\">:scream_cat:</span>)</p>",
        "id": 270504615,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1643868014
    },
    {
        "content": "<p>My intuition says the we should indeed stick with <code>Ab</code> for now.</p>",
        "id": 270505125,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1643868577
    },
    {
        "content": "<p>We will need \"condensed ℤ[T⁻¹]-modules\". But once again, I'm not sure if <code>Condensed (Module (polynomial ℤ))</code> is the best way to implement that. Another option would be <code>Condensed (endomorphism Ab)</code>, where <code>endomorphism C</code> is the category of pairs <code>(X, f)</code> with <code>X : C</code> and <code>f : X ⟶ X</code>.</p>",
        "id": 270505250,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1643868683
    },
    {
        "content": "<p>One question that comes to my mind is that if we should not keep track that on \"most\" objects of interest to us (although not all test-objects), <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>T</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding=\"application/x-tex\">T^{-1}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span></span></span></span> is an isomorphism.</p>",
        "id": 270505858,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1643869270
    },
    {
        "content": "<p>If we work in <code>Condensed (endomorpmism Ab)</code> this means that some arrows actually land in a subcategory and many lemmas (for instance Prop 6.8 saying that the \"basic\" condensed sets are profinite, which is crucial) use that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span></span> is invertible.</p>",
        "id": 270505956,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1643869374
    },
    {
        "content": "<p>We have <code>normed_with_aut</code> which kept track of that in the first half of the project</p>",
        "id": 270505963,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1643869377
    },
    {
        "content": "<p>Sure, I was thinking on how to set-up this categorically.</p>",
        "id": 270506032,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1643869401
    },
    {
        "content": "<p>But for <code>Mbar</code>, it is not an isomorphism. Same with <code>ℤ[T⁻¹]</code> itself. And those two objects will also play an important role.</p>",
        "id": 270506074,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1643869433
    },
    {
        "content": "<p>Yes, I agree. Indeed, I don't suggest we work with <code>Condensed (isomorphism Ab)</code>, I simply wonder if there is a way to keep track on the category side of the subcategory where this is invertible, in a way that is not too painful.</p>",
        "id": 270506158,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1643869496
    },
    {
        "content": "<p>It could also not be necessary, of course.</p>",
        "id": 270506178,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1643869514
    },
    {
        "content": "<p>I will think about it, at any rate.</p>",
        "id": 270506483,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1643869853
    },
    {
        "content": "<p>Of course we could just drop universes ;-)</p>\n<p>Amelia and Maria both wanted these in projects they've been doing (Amelia for group cohomology and Z[G]-modules, Maria for valuations into with_zero (multiplicative int)) so in my opinion this is an issue which we need to start thinking about. The issue is that int has some huge API and the moment you ulift it to pint you lose a chunk of it. Maybe automation can save us here? </p>\n<p>But presumably independent of that we want the monoidal structure on Ab anyway. Can we get it from an equivalence to module Z or again is this something which is asking too much right now?</p>",
        "id": 270512949,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1643876069
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> No, we can't drop universes. See the top post, where Adam writes</p>\n<blockquote>\n<p>What do you think about changing our definition of <code>Condensed.{u} Ab.{u+1}</code> to <code>Condensed.{u} (Module.{u+1} \\Z)</code>. </p>\n</blockquote>\n<p>That <code>.{u+1}</code> is causing the trouble. Because <code>ℤ</code> is not an object of <code>Module.{0+1} ℤ</code>. Only <code>ulift ℤ</code> is.</p>",
        "id": 270513370,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1643876408
    },
    {
        "content": "<p>You always said this day would happen</p>",
        "id": 270513866,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1643876738
    },
    {
        "content": "<p>I'm a bit surprised though. Surely the type of Z-modules is Type 1?</p>",
        "id": 270514044,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1643876869
    },
    {
        "content": "<p>Which <code>ℤ</code>-modules?</p>",
        "id": 270514509,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1643877163
    },
    {
        "content": "<p>You can have <code>ℤ</code>-modules with carriers in <code>Type</code>. But there's another category with carriers in <code>Type 1</code>, etc...</p>",
        "id": 270514530,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1643877188
    },
    {
        "content": "<p>In this \"pyknotic\" setup, you choose an inaccessible cardinal <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>κ</mi></mrow><annotation encoding=\"application/x-tex\">\\kappa</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">κ</span></span></span></span> as the \"cutoff\" for the size of the profinite spaces you want to allow. You want <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>κ</mi></mrow><annotation encoding=\"application/x-tex\">\\kappa</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">κ</span></span></span></span> to be an ordinary small cardinal relative to the values of the sheaves you consider so that you can do ordinary topos theory, so you need sheaves valued in a universe of sets that itself contains a smaller universe.<br>\nIn Lean, you take <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>κ</mi></mrow><annotation encoding=\"application/x-tex\">\\kappa</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">κ</span></span></span></span> to be given by the cardinal <code>Type</code> (so that the profinite spaces you allow are those whose underlying set is a <code>Type</code>) and then you consider sheaves valued in <code>Type 1</code>. But <code>ℤ</code> itself is not a <code>Type 1</code> and here is the problem.</p>",
        "id": 270514566,
        "sender_full_name": "Reid Barton",
        "timestamp": 1643877220
    },
    {
        "content": "<p>Or you take <code>Type u</code> for the profinite spaces and <code>Type (u+1)</code> for the values of the sheaves, but it doesn't help.</p>",
        "id": 270514673,
        "sender_full_name": "Reid Barton",
        "timestamp": 1643877271
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/267928-condensed-mathematics/topic/Potential.20Refactor/near/270514530\">said</a>:</p>\n<blockquote>\n<p>You can have <code>ℤ</code>-modules with carriers in <code>Type</code>. But there's another category with carriers in <code>Type 1</code>, etc...</p>\n</blockquote>\n<p>Of course, if you are only interested in suitably finitely generated modules, then these categories are equivalent. But for arbitrary modules, they aren't.</p>",
        "id": 270514788,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1643877358
    },
    {
        "content": "<p>I pushed a stub on <code>endomorphism C</code> to <code>for_mathlib/endomorphisms.lean</code>. The big sorry is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">abelian</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">abelian</span> <span class=\"o\">(</span><span class=\"n\">endomorphism</span> <span class=\"n\">C</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 270555556,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1643897963
    },
    {
        "content": "<p>Hmmm, one annoying thing about <code>endomorphism</code> is that we have to develop lots of stuff for it again. That it's <code>abelian</code> is only the beginning. We would need the monoidal structure, Hom-tensor adjunction, free objects, etc... And all of that also for the condensed version.</p>",
        "id": 270556791,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1643898448
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> Do I understand correctly that this is almost all done for <code>Condensed (Module R)</code> already?</p>\n<ul>\n<li>It is abelian</li>\n<li>The free-forget adjunction is done (right?)</li>\n<li>monoidal structure is there in the uncondensed case, but needs to be sheafified.</li>\n<li>Hom-tensor adjunction is done in the uncondensed case, I think.</li>\n</ul>",
        "id": 270557038,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1643898545
    },
    {
        "content": "<p>So maybe I should reconsider my intuition about <code>Ab</code> and <code>endomorphism Ab</code>.</p>",
        "id": 270557096,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1643898570
    },
    {
        "content": "<p>Writing a constructor for <code>Condensed (Module (polynomial ℤ))</code> given a <code>Condensed (Module ℤ)</code> + endomorphism shouldn't be hard.</p>",
        "id": 270557365,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1643898686
    },
    {
        "content": "<p>Same for a <code>Condensed Ab</code> + endomorphism</p>",
        "id": 270557394,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1643898697
    },
    {
        "content": "<p>The answers are yes, yes, yes, and almost <a href=\"https://leanprover-community.github.io/mathlib_docs/find/tensor_product.lift.equiv\">docs#tensor_product.lift.equiv</a></p>",
        "id": 270561047,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1643900003
    },
    {
        "content": "<p>Hmmz, mathlib doesn't yet know that <code>Module R</code> has colimits.</p>",
        "id": 270561068,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1643900012
    },
    {
        "content": "<p>Or wait, maybe I just have the wrong imports</p>",
        "id": 270561114,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1643900031
    },
    {
        "content": "<p>It does, but there are universe issues there as well</p>",
        "id": 270561362,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1643900100
    },
    {
        "content": "<p>Those should be easier to fix</p>",
        "id": 270561416,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1643900117
    },
    {
        "content": "<p>If we decide to go for this change, we should fix mathlib first, I think.</p>",
        "id": 270561606,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1643900178
    },
    {
        "content": "<p>I hope the free forget adjunction for modules is sufficiently universe polymorphic.</p>",
        "id": 270561794,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1643900252
    },
    {
        "content": "<p>Yeah, I'm now thinking that it will make sense to attempt this refactor.</p>",
        "id": 270561919,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1643900286
    },
    {
        "content": "<p>It is the morally correct thing to do. And probably also the economically correct thing to do.</p>",
        "id": 270561969,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1643900306
    },
    {
        "content": "<p>I think I agree... I didn't consider the Z[X] issue yesterday, and that pushes it over the edge.</p>",
        "id": 270562120,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1643900366
    },
    {
        "content": "<p>PS... I added <code>for_mathlib/internal_hom.lean</code> yesterday. I was surprised we didn't have something like that in mathlib yet.</p>",
        "id": 270562636,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1643900544
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/pull/11802\">#11802</a> generalizes universes for colimits in <code>Module R</code> -- let's see if CI likes it.</p>",
        "id": 270562734,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1643900588
    },
    {
        "content": "<p>This might be dumb and/or already considered, but have you thought about instead of <code>polynomial ℤ</code>, using <code>mv_polynomial punit ℤ</code>?</p>",
        "id": 270563221,
        "sender_full_name": "Reid Barton",
        "timestamp": 1643900763
    },
    {
        "content": "<p>We could also use <code>mv_polynomial pempty Z</code></p>",
        "id": 270563338,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1643900806
    },
    {
        "content": "<p>Hah, that would be a nifty hack!</p>",
        "id": 270563503,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1643900874
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/blob/7f3590b4184c03b0ddccc7b5ff7d0a8c88d9f2ac/src/algebra/category/Module/adjunctions.lean#L47\">https://github.com/leanprover-community/mathlib/blob/7f3590b4184c03b0ddccc7b5ff7d0a8c88d9f2ac/src/algebra/category/Module/adjunctions.lean#L47</a></p>\n<p><span aria-label=\"sad\" class=\"emoji emoji-2639\" role=\"img\" title=\"sad\">:sad:</span></p>",
        "id": 270564344,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1643901235
    },
    {
        "content": "<p>The universes there need to be fixed as well.</p>",
        "id": 270564422,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1643901259
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/267928-condensed-mathematics/topic/Potential.20Refactor/near/270564422\">said</a>:</p>\n<blockquote>\n<p>The universes there need to be fixed as well.</p>\n</blockquote>\n<p>It looks like this file depends on the monoidal structure, so we should fix <code>algebra/Module/monoidal</code> first</p>",
        "id": 270565319,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1643901605
    },
    {
        "content": "<p>I pushed some WIP for the universe generalization of the monoidal structure in <a href=\"https://github.com/leanprover-community/mathlib/tree/universe_monoidal_module\">branch#universe_monoidal_module</a><br>\nPlease feel free to push to this branch!</p>",
        "id": 270570145,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1643903396
    },
    {
        "content": "<p>(I have to teach soon, so I can't work on this more right now.)</p>",
        "id": 270570252,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1643903422
    },
    {
        "content": "<p>(oops! I wrote punit instead of pempty, let me fix)</p>",
        "id": 270573060,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1643904375
    },
    {
        "content": "<p>FWIW I think <code>mv_polynomial punit</code> is, to some extent, not even really a hack if you think about this <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>T</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding=\"application/x-tex\">T^{-1}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span></span></span></span> as a specific thing which is nominally different from other generators of polynomial rings. You could define</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">cond_gen</span>\n<span class=\"bp\">|</span> <span class=\"n\">Tinv</span>\n</code></pre></div>\n<p>And then at that point you could put <code>cond_gen</code> in universe <code>u+1</code> on the general principle that we only care about one universe at a time.</p>",
        "id": 270573854,
        "sender_full_name": "Reid Barton",
        "timestamp": 1643904686
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/267928-condensed-mathematics/topic/Potential.20Refactor/near/270570145\">said</a>:</p>\n<blockquote>\n<p>I pushed some WIP for the universe generalization of the monoidal structure in <a href=\"https://github.com/leanprover-community/mathlib/tree/universe_monoidal_module\">branch#universe_monoidal_module</a><br>\nPlease feel free to push to this branch!</p>\n</blockquote>\n<p>What's the statement you're going for? An adjunction between <code>Type (max u v)</code> and <code>Module.{max (u v)} R</code>?</p>",
        "id": 270574281,
        "sender_full_name": "Reid Barton",
        "timestamp": 1643904844
    },
    {
        "content": "<p>True. But <code>mv_polynomial pempty ℤ</code> is very much a hack to place <code>ℤ</code> in <code>Type u</code>.</p>",
        "id": 270574322,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1643904864
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/267928-condensed-mathematics/topic/Potential.20Refactor/near/270574281\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/267928-condensed-mathematics/topic/Potential.20Refactor/near/270570145\">said</a>:</p>\n<blockquote>\n<p>I pushed some WIP for the universe generalization of the monoidal structure in <a href=\"https://github.com/leanprover-community/mathlib/tree/universe_monoidal_module\">branch#universe_monoidal_module</a><br>\nPlease feel free to push to this branch!</p>\n</blockquote>\n<p>What's the statement you're going for? An adjunction between <code>Type (max u v)</code> and <code>Module.{max (u v)} R</code>?</p>\n</blockquote>\n<p>In that branch, just the monoidal structure on <code>Module.{max v u} R</code> where <code>R : Type u</code> is a <code>comm_ring R</code>..</p>",
        "id": 270575381,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1643905283
    },
    {
        "content": "<p>Once that's done, we can fix the universes similarly in <code>algebra/category/Module/adjunctions</code>.</p>",
        "id": 270575419,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1643905309
    },
    {
        "content": "<p>The current monoidal structure on <code>Module R</code> only works for <code>Module.{u} R</code> with <code>R : Type u</code> because the tensor unit is defined to be <code>Module.of R R</code>.</p>",
        "id": 270575591,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1643905374
    },
    {
        "content": "<p>Feel free to replace <code>tensor_unit</code> with <code>Module.of R (ulift R)</code>, if you think that would be better!</p>",
        "id": 270575699,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1643905427
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/267928-condensed-mathematics/topic/Potential.20Refactor/near/270562734\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://github.com/leanprover-community/mathlib/pull/11802\">#11802</a> generalizes universes for colimits in <code>Module R</code> -- let's see if CI likes it.</p>\n</blockquote>\n<p>The build passed. Linter raised a universe issue, which I fixed. So this should be good now.</p>",
        "id": 270575713,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1643905431
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/267928-condensed-mathematics/topic/Potential.20Refactor/near/270575699\">said</a>:</p>\n<blockquote>\n<p>Feel free to replace <code>tensor_unit</code> with <code>Module.of R (ulift R)</code>, if you think that would be better!</p>\n</blockquote>\n<p>You would have to register a module instance for <code>ulift R</code> in this case.</p>",
        "id": 270575936,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1643905520
    },
    {
        "content": "<p>Alright, I really do have to go teach now (class starts in 3 mins)</p>",
        "id": 270576122,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1643905587
    },
    {
        "content": "<p>And they say they aren't addicted</p>",
        "id": 270576331,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1643905665
    },
    {
        "content": "<p>I can't seem to find the universal property of <code>mv_polynomial</code> (as the free commutative algebra on a type). Am I just blind?</p>",
        "id": 270595628,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1643912995
    },
    {
        "content": "<p>I suppose we are meant to use <a href=\"https://leanprover-community.github.io/mathlib_docs/find/mv_polynomial.aeval\">docs#mv_polynomial.aeval</a> and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/mv_polynomial.aeval_unique\">docs#mv_polynomial.aeval_unique</a> ?</p>",
        "id": 270596363,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1643913291
    },
    {
        "content": "<p>Yes, I think so</p>",
        "id": 270596429,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1643913315
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/pull/11807\">#11807</a></p>",
        "id": 270604316,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1643916595
    },
    {
        "content": "<p>The only drawback I see is that now things have become noncomputable, due to the use of <code>mv_polynomial</code></p>",
        "id": 270604442,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1643916639
    },
    {
        "content": "<p>So I would also expect that these definitions would become hard to use because one of the universe parameters (I guess <code>v</code>) only appears in <code>Module.{max v u} R</code> in the arguments</p>",
        "id": 270605165,
        "sender_full_name": "Reid Barton",
        "timestamp": 1643916961
    },
    {
        "content": "<p>I hope that in practice we either have <code>u = v</code> or <code>u = 0</code>, so maybe it will be okay? But yeah, if we want something for the most general universe parameters it may require manually adding universes.</p>",
        "id": 270605595,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1643917113
    },
    {
        "content": "<p>does LTE use these? does it build against your PR?</p>",
        "id": 270605909,
        "sender_full_name": "Reid Barton",
        "timestamp": 1643917262
    },
    {
        "content": "<p>I haven't tried.</p>",
        "id": 270605944,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1643917279
    },
    {
        "content": "<p>But we don't really use <code>Module</code> at all yet, so I think it's fine (for LTE at least)</p>",
        "id": 270606017,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1643917313
    },
    {
        "content": "<p>I think there is some linter which tries to guess whether this will be an issue, so we can see what it says.</p>",
        "id": 270606377,
        "sender_full_name": "Reid Barton",
        "timestamp": 1643917456
    },
    {
        "content": "<p>Yeah, that's the same  linter that caught Johan's PR at first</p>",
        "id": 270606442,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1643917484
    },
    {
        "content": "<p>If there are no users yet, then a priori it's hard to know whether you're actually making things better than if you just had to use <code>Module (ulift R)</code> (and maybe you are making things worse in the happy case of rings and modules in the same universe).</p>",
        "id": 270606587,
        "sender_full_name": "Reid Barton",
        "timestamp": 1643917538
    },
    {
        "content": "<p>My gut feeling is that working with things like <code>Module.{v u} R</code> is not worth it in the long run</p>",
        "id": 270607150,
        "sender_full_name": "Reid Barton",
        "timestamp": 1643917763
    },
    {
        "content": "<p>The ideal situation would be if it were possible to write <code>R : Type u</code> <code>[comm_ring R]</code>, <code>u \\leq v</code> and <code>Module.{v} R</code>.</p>",
        "id": 270607422,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1643917872
    },
    {
        "content": "<p>I mean once the tensor unit is not <code>R</code> anyways, seems like you might as well work with modules over it instead</p>",
        "id": 270607425,
        "sender_full_name": "Reid Barton",
        "timestamp": 1643917875
    },
    {
        "content": "<p>Yeah, it would be nice if we could have a coherent story about how we'd like universes to work.</p>",
        "id": 270607451,
        "sender_full_name": "Reid Barton",
        "timestamp": 1643917886
    },
    {
        "content": "<p>Though in this case, the tensor unit would still not be <code>R</code> if <code>u &lt; v</code> (it would fix some other things though).</p>",
        "id": 270607536,
        "sender_full_name": "Reid Barton",
        "timestamp": 1643917923
    },
    {
        "content": "<p>I guess cumulative universes would fix that.</p>",
        "id": 270607652,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1643917958
    },
    {
        "content": "<p>Does <code>ulift \\Z</code> have a ring instance registered in mathlib?</p>",
        "id": 270607892,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1643918043
    },
    {
        "content": "<p>Ah, it does in <code>algebra.ring.ulift</code>. Maybe we should go with that approach? <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> what do you think?</p>",
        "id": 270608037,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1643918116
    },
    {
        "content": "<p>PS. <a href=\"https://github.com/leanprover-community/mathlib/pull/11807\">#11807</a> already broke -- it looks like the monoidal structure of <code>Module.{u} R</code> with <code>R : Type u</code> was not found.</p>",
        "id": 270608381,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1643918245
    },
    {
        "content": "<p>Well... the colimits thing is also not ideal. With the new change:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.category.Module.colimits</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">category_theory.limits</span>\n<span class=\"kd\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">has_colimits</span> <span class=\"o\">(</span><span class=\"n\">Module.</span><span class=\"o\">{</span><span class=\"mi\">37</span><span class=\"o\">}</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">infer_instance</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">has_colimits</span> <span class=\"o\">(</span><span class=\"n\">Module.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">infer_instance</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">has_colimits</span> <span class=\"o\">(</span><span class=\"n\">Module.</span><span class=\"o\">{</span><span class=\"n\">max</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">infer_instance</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">has_colimits</span> <span class=\"o\">(</span><span class=\"n\">Module.</span><span class=\"o\">{</span><span class=\"n\">max</span> <span class=\"n\">v</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">infer_instance</span> <span class=\"c1\">-- fails</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">has_colimits</span> <span class=\"o\">(</span><span class=\"n\">Module.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">infer_instance</span> <span class=\"c1\">-- fails</span>\n</code></pre></div>",
        "id": 270610297,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1643919055
    },
    {
        "content": "<p>What about</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">has_colimits</span> <span class=\"o\">(</span><span class=\"n\">Module.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">infer_instance</span>\n</code></pre></div>",
        "id": 270611682,
        "sender_full_name": "Reid Barton",
        "timestamp": 1643919692
    },
    {
        "content": "<p>That would require changing the construction altogether.</p>",
        "id": 270611815,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1643919749
    },
    {
        "content": "<p>aha!</p>",
        "id": 270611829,
        "sender_full_name": "Reid Barton",
        "timestamp": 1643919757
    },
    {
        "content": "<p>The current construction is an inductive-quotient construction</p>",
        "id": 270611835,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1643919759
    },
    {
        "content": "<p>But it is actu... gotcha.</p>",
        "id": 270611854,
        "sender_full_name": "Reid Barton",
        "timestamp": 1643919767
    },
    {
        "content": "<p>It <em>is</em> actually true though right?</p>",
        "id": 270611885,
        "sender_full_name": "Reid Barton",
        "timestamp": 1643919781
    },
    {
        "content": "<p>I think so, yes.</p>",
        "id": 270611897,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1643919788
    },
    {
        "content": "<p>Well, with the correctly sized index category.</p>",
        "id": 270611944,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1643919810
    },
    {
        "content": "<p>I think a marginally better-known example of this phenomenon is the \"topos\" of G-sets for G a large group</p>",
        "id": 270611966,
        "sender_full_name": "Reid Barton",
        "timestamp": 1643919821
    },
    {
        "content": "<p>Any small collection of such sets could be viewed as having an action by some small quotient of G</p>",
        "id": 270612482,
        "sender_full_name": "Reid Barton",
        "timestamp": 1643920039
    },
    {
        "content": "<p>But the whole category is not generated by a set of objects (if G has a proper class of set-sized quotients). Quite similar to condensed sets really.</p>",
        "id": 270612526,
        "sender_full_name": "Reid Barton",
        "timestamp": 1643920062
    },
    {
        "content": "<p>So I think <code>Module.{v u} R</code> is cocomplete, but (generally) not locally presentable</p>",
        "id": 270612554,
        "sender_full_name": "Reid Barton",
        "timestamp": 1643920074
    },
    {
        "content": "<p>Anyways, assuming you don't want to do the other construction...</p>",
        "id": 270613814,
        "sender_full_name": "Reid Barton",
        "timestamp": 1643920564
    },
    {
        "content": "<p>Since <code>has_colimits</code> is a Prop, it might be okay to have both the old and new instances?</p>",
        "id": 270613874,
        "sender_full_name": "Reid Barton",
        "timestamp": 1643920591
    },
    {
        "content": "<p>But in general, this kind of thing is why I think <code>Module.{v u}</code> is a bad idea--more precisely, it would be better to invest the time into making it easier to deal with <code>ulift</code></p>",
        "id": 270613996,
        "sender_full_name": "Reid Barton",
        "timestamp": 1643920645
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/267928-condensed-mathematics/topic/Potential.20Refactor/near/270613874\">said</a>:</p>\n<blockquote>\n<p>Since <code>has_colimits</code> is a Prop, it might be okay to have both the old and new instances?</p>\n</blockquote>\n<p>I think we can just add these instances manually.</p>",
        "id": 270619034,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1643923052
    },
    {
        "content": "<p>This works</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.category.Module.colimits</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">category_theory.limits</span>\n<span class=\"kd\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">foo1</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">has_colimits</span> <span class=\"o\">(</span><span class=\"n\">Module.</span><span class=\"o\">{</span><span class=\"n\">max</span> <span class=\"n\">v</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">Module.colimits.has_colimits_Module.</span><span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"n\">u</span><span class=\"o\">}</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">foo2</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">has_colimits</span> <span class=\"o\">(</span><span class=\"n\">Module.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">Module.colimits.has_colimits_Module.</span><span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"n\">v</span><span class=\"o\">}</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">has_colimits</span> <span class=\"o\">(</span><span class=\"n\">Module.</span><span class=\"o\">{</span><span class=\"mi\">37</span><span class=\"o\">}</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">infer_instance</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">has_colimits</span> <span class=\"o\">(</span><span class=\"n\">Module.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">infer_instance</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">has_colimits</span> <span class=\"o\">(</span><span class=\"n\">Module.</span><span class=\"o\">{</span><span class=\"n\">max</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">infer_instance</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">has_colimits</span> <span class=\"o\">(</span><span class=\"n\">Module.</span><span class=\"o\">{</span><span class=\"n\">max</span> <span class=\"n\">v</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">infer_instance</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">has_colimits</span> <span class=\"o\">(</span><span class=\"n\">Module.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">infer_instance</span>\n</code></pre></div>",
        "id": 270619210,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1643923132
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/pull/11812\">#11812</a></p>",
        "id": 270624344,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1643925523
    },
    {
        "content": "<p>I hope this will pass the strict background check by the typeclass police.</p>",
        "id": 270624428,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1643925569
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span>  Which PRs should I be reviewing now?</p>",
        "id": 270659738,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1643941637
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/pull/11807\">#11807</a> is broken -- ignore it (I tagged as <code>maybe later</code>)</p>\n<p><a href=\"https://github.com/leanprover-community/mathlib/pull/11812\">#11812</a> should be good to go</p>",
        "id": 270659764,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1643941669
    },
    {
        "content": "<p>I think Reid convinced me to go with <code>Module (ulift \\Z)</code>. What do you think?</p>",
        "id": 270659831,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1643941715
    },
    {
        "content": "<p><img alt=\":merge:\" class=\"emoji\" src=\"https://zulip-avatars.s3.amazonaws.com/3121/emoji/images/18527.png\" title=\"merge\"> <a href=\"https://github.com/leanprover-community/mathlib/pull/11812\">#11812</a></p>",
        "id": 270659878,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1643941776
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/267928-condensed-mathematics/topic/Potential.20Refactor/near/270659831\">said</a>:</p>\n<blockquote>\n<p>I think Reid convinced me to go with <code>Module (ulift \\Z)</code>. What do you think?</p>\n</blockquote>\n<p>So that <code>u = v</code> everywhere in sight? I guess that makes sense. I don't have a preference between <code>ulift ℤ</code> and <code>mv_polynomial pempty ℤ</code>. Since we need to go back and forth between modules over <code>ℤ</code> and <code>ℤ[T⁻¹]</code>, maybe the <code>mv_polynomial</code> version is a bit smoother than <code>ulift</code>?</p>",
        "id": 270659997,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1643941880
    },
    {
        "content": "<p>I think over the next few days, I'll try to just change the stuff we have for <code>Condensed Ab</code> to <code>Condensed (Module A)</code></p>",
        "id": 270660092,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1643941960
    },
    {
        "content": "<p>We can decide on the <code>ulift</code> vs <code>polynomial</code> issue later.</p>",
        "id": 270660111,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1643941983
    },
    {
        "content": "<p>Yeah, that makes sense</p>",
        "id": 270660152,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1643942031
    },
    {
        "content": "<p>If we go with <code>ulift Z</code>, we could just use <code>polynomial (ulift Z)</code> and call it good</p>",
        "id": 270660211,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1643942067
    },
    {
        "content": "<p>But in that refactor, you can assume <code>A</code> to be in the correct universe, which is a relief.</p>",
        "id": 270660212,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1643942067
    },
    {
        "content": "<p>Fortunately, the stuff I did for the <code>ExtrSheaf</code> equivalence uses arbitrary categories which have finite biproducts, so that should be effortless to generalize.</p>",
        "id": 270660330,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1643942213
    },
    {
        "content": "<p>Big shoutout to abstraction and generalization!</p>",
        "id": 270660752,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1643942736
    },
    {
        "content": "<p>oops! <a href=\"https://github.com/leanprover-community/mathlib/pull/11837\">#11837</a></p>\n<p>Also the following is done (for any <code>R : Type (u+1)</code> with <code>[ring R]</code>, where <code>CondensedMod R := Condensed.{u} (Module.{u+1} R)</code>)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">CondensedMod_has_enough_projective</span> <span class=\"o\">:</span> <span class=\"n\">enough_projectives</span> <span class=\"o\">(</span><span class=\"n\">CondensedMod</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n</code></pre></div>",
        "id": 270747875,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1643996490
    },
    {
        "content": "<p>I also introduced the notation <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi><mo stretchy=\"false\">[</mo><mi>S</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">R[S]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mclose\">]</span></span></span></span> for a ring <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> and <code>S : Profinite</code>, see e.g. <a href=\"https://github.com/leanprover-community/lean-liquid/blob/3725961d6024d9bb5f7ee81e62197574b7d8ab47/src/condensed/projective_resolution_module.lean#L134\">https://github.com/leanprover-community/lean-liquid/blob/3725961d6024d9bb5f7ee81e62197574b7d8ab47/src/condensed/projective_resolution_module.lean#L134</a></p>",
        "id": 270748275,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1643996660
    },
    {
        "content": "<p>Just for the record: with the new roadmap it's clear that we can continue using <code>Condensed Ab</code>. There's no more need to work with modules over <code>ulift</code>ed rings, etc...</p>",
        "id": 271329126,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1644432786
    }
]
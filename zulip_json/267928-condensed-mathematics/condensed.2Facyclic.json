[
    {
        "content": "<p>Apart of exactness of a certain complex, this file now contains only two <code>SELFCONTAINED</code> sorries.<br>\nOne is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- SELFCONTAINED</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">cochain_complex.mono_of_is_zero_homology_0</span>\n  <span class=\"o\">{</span><span class=\"bp\">ùìê</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">category</span> <span class=\"bp\">ùìê</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">abelian</span> <span class=\"bp\">ùìê</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">cochain_complex</span> <span class=\"bp\">ùìê</span> <span class=\"n\">‚Ñï</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">is_zero</span> <span class=\"bp\">$</span> <span class=\"n\">C.homology</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">mono</span> <span class=\"o\">(</span><span class=\"n\">C.d</span> <span class=\"mi\">0</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"gr\">sorry</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>The other is about applying an additive functor to the alternating face map complex of a simplicial object.</p>",
        "id": 284321947,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1653883627
    },
    {
        "content": "<p>I have 100 copies to correct on my desk and some stuff to do on the blueprint, so most probably others will be faster than me. If not, I will be happy to take this one if needed, or anything that will be left once I will emerge from my marking adventure.</p>",
        "id": 284338422,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1653899737
    },
    {
        "content": "<p>Good luck with grading!</p>",
        "id": 284338454,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1653899757
    },
    {
        "content": "<p>I've finishing my grading so I can to it :D</p>",
        "id": 284356013,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1653910635
    },
    {
        "content": "<p>It's done.</p>",
        "id": 284357718,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1653911853
    },
    {
        "content": "<p>I assume no one is working on the following?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">free_Cech_exact</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">arrow</span> <span class=\"n\">Profinite.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">})</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñ§</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">is_zero</span> <span class=\"bp\">$</span> <span class=\"o\">(</span><span class=\"n\">free_Cech</span> <span class=\"n\">F</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">homology</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n<span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>I'll try to get that sorry done in the next couple of days.</p>",
        "id": 284363872,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1653915380
    },
    {
        "content": "<p>I'm not working on that atm</p>",
        "id": 284366014,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1653916469
    },
    {
        "content": "<p>Btw, see</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">acyclic_of_exact.induction_step_ex‚ÇÉ</span>\n</code></pre></div>\n<p>for (roughly) how to reduce it exactness of <code>free_Cech'</code>.</p>",
        "id": 284366221,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1653916598
    },
    {
        "content": "<p>I added various self-contained sorries in <code>for_mathlib/chain_complex_exact</code>.</p>",
        "id": 284375769,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1653921722
    },
    {
        "content": "<p>A few additional selfcontained sorries can now be found in <code>condensed/adjunctions</code>. They are just some lemmas about additivity of certain functors.</p>",
        "id": 284496466,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1654012171
    },
    {
        "content": "<p>OK I am finally getting to this stuff!</p>",
        "id": 284540541,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1654033117
    },
    {
        "content": "<p>I'll take a look at <code>condensed/adjunctions</code>.</p>",
        "id": 284540579,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1654033147
    },
    {
        "content": "<p>There's only one <code>sorry</code> -- some statement that a functor is preadditive. I'll try that now</p>",
        "id": 284541004,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1654033413
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> that sorry is a special case of one in <code>for_mathlib/abelian_sheaves/exact</code></p>",
        "id": 284541876,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1654033951
    },
    {
        "content": "<p>(sheafification is additive)</p>",
        "id": 284541898,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1654033968
    },
    {
        "content": "<p>But for silly universe reasons it's possible that TC search won't find the one in <code>condensed/adjunctions</code> automatically :(</p>",
        "id": 284542041,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1654034039
    },
    {
        "content": "<p>Thanks!</p>",
        "id": 284543713,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1654035087
    },
    {
        "content": "<p>Oh I got nothing done, I got distracted by other things :-/</p>",
        "id": 284557056,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1654046756
    },
    {
        "content": "<p>The main argument for </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">free_Cech_exact</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">arrow</span> <span class=\"n\">Profinite.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">})</span> <span class=\"o\">(</span><span class=\"n\">hF</span> <span class=\"o\">:</span> <span class=\"n\">function.surjective</span> <span class=\"n\">F.hom</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñ§</span><span class=\"o\">),</span>\n  <span class=\"n\">is_zero</span> <span class=\"bp\">$</span> <span class=\"o\">(</span><span class=\"n\">free_Cech</span> <span class=\"n\">F</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">homology</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n</code></pre></div>\n<p>is now done, moodulo various sorries that should be more self-contained.</p>",
        "id": 284624630,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1654095872
    },
    {
        "content": "<p>Note that the assumption <code>(hF : function.surjective F.hom)</code> was added, so some stuff may break, but this is a necessary assumption.</p>",
        "id": 284624912,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1654095998
    },
    {
        "content": "<p>Ooh thanks for catching that missing assumption. It's certainly satisfied when we use this lemma.</p>",
        "id": 284653960,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1654109449
    },
    {
        "content": "<p>Unfortunately...... we seem to be missing the comparbility of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.cover_dense.Sheaf_equiv_of_cover_preserving_cover_lifting\">docs#category_theory.cover_dense.Sheaf_equiv_of_cover_preserving_cover_lifting</a> with <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.presheaf_to_Sheaf\">docs#category_theory.presheaf_to_Sheaf</a></p>",
        "id": 284656036,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1654110462
    },
    {
        "content": "<p>We need that for these sorries<br>\n<a href=\"https://github.com/leanprover-community/lean-liquid/blob/47a989b746f9e3d0e56dd3c65101c53f9b944004/src/condensed/acyclic.lean#L93\">https://github.com/leanprover-community/lean-liquid/blob/47a989b746f9e3d0e56dd3c65101c53f9b944004/src/condensed/acyclic.lean#L93</a></p>",
        "id": 284656117,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1654110495
    },
    {
        "content": "<p>What does it take to add that? Is this a sizable gap?</p>",
        "id": 284659519,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1654112249
    },
    {
        "content": "<p>Okay, I think there may be a slick way to do with by playing around with some right Kan extensions.</p>",
        "id": 284661813,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1654113536
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">ExtrDisc_sheafification_iso</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">whiskering_left</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">obj</span> <span class=\"n\">ExtrDisc_to_Profinite.op</span> <span class=\"bp\">‚ãô</span>\n  <span class=\"n\">presheaf_to_Sheaf</span> <span class=\"n\">ExtrDisc.proetale_topology</span> <span class=\"n\">Ab.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">}</span> <span class=\"bp\">‚âÖ</span>\n  <span class=\"n\">presheaf_to_Sheaf</span> <span class=\"n\">proetale_topology</span> <span class=\"n\">_</span> <span class=\"bp\">‚ãô</span> <span class=\"o\">(</span><span class=\"n\">Condensed_ExtrSheaf_equiv</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">inverse</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">let</span> <span class=\"n\">A1</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">whiskering_left</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">Ab.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">})</span><span class=\"bp\">.</span><span class=\"n\">obj</span> <span class=\"n\">ExtrDisc_to_Profinite.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"bp\">.</span><span class=\"n\">op</span> <span class=\"bp\">‚ä£</span> <span class=\"n\">_</span> <span class=\"o\">:=</span>\n    <span class=\"n\">Ran.adjunction</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"k\">let</span> <span class=\"n\">A2</span> <span class=\"o\">:</span> <span class=\"n\">presheaf_to_Sheaf</span> <span class=\"n\">ExtrDisc.proetale_topology</span> <span class=\"n\">Ab.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">}</span> <span class=\"bp\">‚ä£</span> <span class=\"n\">_</span> <span class=\"o\">:=</span>\n    <span class=\"n\">sheafification_adjunction</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"k\">let</span> <span class=\"n\">B1</span> <span class=\"o\">:</span> <span class=\"n\">presheaf_to_Sheaf</span> <span class=\"n\">proetale_topology</span> <span class=\"n\">Ab.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">}</span> <span class=\"bp\">‚ä£</span> <span class=\"n\">_</span> <span class=\"o\">:=</span>\n    <span class=\"n\">sheafification_adjunction</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"k\">let</span> <span class=\"n\">B2</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Condensed_ExtrSheaf_equiv</span> <span class=\"n\">Ab.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">})</span><span class=\"bp\">.</span><span class=\"n\">inverse</span> <span class=\"bp\">‚ä£</span> <span class=\"n\">_</span> <span class=\"o\">:=</span>\n    <span class=\"n\">equivalence.to_adjunction</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"k\">let</span> <span class=\"n\">A</span> <span class=\"o\">:=</span> <span class=\"n\">A1.comp</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">A2</span><span class=\"o\">,</span>\n  <span class=\"k\">let</span> <span class=\"n\">B</span> <span class=\"o\">:=</span> <span class=\"n\">B1.comp</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">B2</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">A.nat_iso_of_right_adjoint_nat_iso</span> <span class=\"n\">B</span> <span class=\"n\">ExtrDisc_sheafification_iso_aux</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>I'm a little surprised at how easy that was.</p>",
        "id": 284663620,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1654114605
    },
    {
        "content": "<p>I think I'll go ahead and open a mathlib PR for this one.</p>",
        "id": 284666344,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1654115919
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/pull/14512\">#14512</a></p>",
        "id": 284762134,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1654183929
    },
    {
        "content": "<p>I  know we probably won't bump mathlib in LTE any time soon, so I'll add these changes to the LTE repo directly as well.</p>",
        "id": 284762177,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1654183954
    },
    {
        "content": "<p>In particular, the lemma <code>pullback_sheafification_compatibility_hom_apply_val</code> wiill probably be needed for the followiing sorry:<br>\n<a href=\"https://github.com/leanprover-community/lean-liquid/blob/c0531fb0e89511ecfa9b5feda9c873a951f74f12/src/condensed/acyclic.lean#L93\">https://github.com/leanprover-community/lean-liquid/blob/c0531fb0e89511ecfa9b5feda9c873a951f74f12/src/condensed/acyclic.lean#L93</a></p>",
        "id": 284762480,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1654184078
    },
    {
        "content": "<p>Not bumping mathlib: Is that right? I can't get to mathlib right now because I'm on a train in a foreign country and my internet is being throttled. But I just noticed that <code>category_theory.limits.kernel_comparison_comp_Œπ</code> is not as universe polymorphic as I might have expected: there's a functor between two categories and these two categories have morphisms in the same universe. I use this to prove <code>homology_zero_iff_map_homology_zero</code> which then inherits the universe restriction. </p>\n<p>Is the plan now to not bump mathlib until we're at the end? Is the idea that it's now too hard to bump mathlib because of changes in category theory?</p>",
        "id": 284762907,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1654184278
    },
    {
        "content": "<p>This was probably because not too long ago limits in a category <code>C : Type u</code> with <code>[category.{v} C]</code> had to be indexed by a small category <code>J : Type v</code> (so <code>category.{v} J</code>). That means that in order to phrase that a functor preserves liimits, we had to ensure that the source and target category of the functor had morphisms in the same universe level.</p>",
        "id": 284763538,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1654184591
    },
    {
        "content": "<p>Do you think this particular case of a kernel will cause issues in LTE?</p>",
        "id": 284763597,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1654184627
    },
    {
        "content": "<p>I think your <code>exact_iff_map_exact</code> could probably be done without a universe restriction.<br>\nI'm about to go into a meeting, but I'll try too generalize soon.</p>",
        "id": 284764286,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1654184908
    },
    {
        "content": "<p>(and it seems that II also need to clean out my keeeeyyyyyyboard)</p>",
        "id": 284764924,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1654185187
    },
    {
        "content": "<p>I'm just filling in the selfcontained sorries, I don't know if the restriction will cause problems.</p>",
        "id": 284769131,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1654186949
    },
    {
        "content": "<p>This lemma is used to pass between homomology in abellian  sheaves on <code>Profinite</code> to homology in abelian sheaves on <code>ExtrDisc</code>, and both categories of sheaves should have the same universe levels. I think it's okay to leave things as is for  now.</p>",
        "id": 284771348,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1654188011
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/267928-condensed-mathematics/topic/condensed.2Facyclic/near/284762907\">said</a>:</p>\n<blockquote>\n<p>Is the plan now to not bump mathlib until we're at the end? Is the idea that it's now too hard to bump mathlib because of changes in category theory?</p>\n</blockquote>\n<p>Yes, that's my hunch. But I think it should be fine. Once we reach <span aria-label=\"checkered flag\" class=\"emoji emoji-1f3c1\" role=\"img\" title=\"checkered flag\">:checkered_flag:</span> we can start thinking about reorganizing things, cleaning up, bumping mathlib, PRing things, etc...</p>",
        "id": 284790937,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1654197092
    },
    {
        "content": "<p>I'm quite certain we'll make it to the finish line without a bump. I can see the end in sight.</p>",
        "id": 284794717,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1654199020
    },
    {
        "content": "<p>Is PRing to mathlib still on the radar?</p>",
        "id": 284796799,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1654200031
    },
    {
        "content": "<p>Feel free to PR stuff in <code>for_mathlib</code>!</p>",
        "id": 284796887,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1654200072
    },
    {
        "content": "<p>I think once LTE is done, we'll have a lot of \"fun\" clearing out the <code>for_mathlib</code> folder.</p>",
        "id": 284797089,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1654200146
    },
    {
        "content": "<p>If perfectoid is anything to go by, nobody will clear it out and it will rot.</p>",
        "id": 284802287,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1654202773
    },
    {
        "content": "<p>One more sorry left in this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">--TODO: This relates the above construction to AddcommGroup.homology_map</span>\n<span class=\"c1\">-- the above def has more convenient defeq properties for some of the proofs below, but</span>\n<span class=\"c1\">-- the `AddCommGroup.homology_map` is better suited for `aux‚ÇÇ_naturality`.</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">map_explicit_homology_eq</span>\n  <span class=\"o\">{</span><span class=\"n\">P‚ÇÅ</span> <span class=\"n\">P‚ÇÇ</span> <span class=\"o\">:</span> <span class=\"n\">bounded_homotopy_category</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">P‚ÇÅ</span> <span class=\"bp\">‚ü∂</span> <span class=\"n\">P‚ÇÇ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñ§</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">map_explicit_homology</span> <span class=\"n\">f</span> <span class=\"n\">B</span> <span class=\"n\">i</span> <span class=\"bp\">=</span>\n  <span class=\"n\">AddCommGroup.homology_map</span>\n    <span class=\"o\">((</span><span class=\"n\">hom_complex</span> <span class=\"n\">P‚ÇÇ</span> <span class=\"n\">B</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">d_comp_d</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n    <span class=\"o\">((</span><span class=\"n\">hom_complex</span> <span class=\"n\">P‚ÇÅ</span> <span class=\"n\">B</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">d_comp_d</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">commsq.of_eq</span> <span class=\"bp\">$</span> <span class=\"o\">((</span><span class=\"n\">map_hom_complex</span> <span class=\"n\">f</span> <span class=\"n\">B</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">comm</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">commsq.of_eq</span> <span class=\"bp\">$</span> <span class=\"o\">((</span><span class=\"n\">map_hom_complex</span> <span class=\"n\">f</span> <span class=\"n\">B</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">comm</span> <span class=\"n\">i</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>This relates the somewhat nonexplicit <code>AddCommGroup.homology_map</code> to a more explicit one defined in terms of actual elements.</p>",
        "id": 285303489,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1654630616
    },
    {
        "content": "<p>Hey you know all the cool kids are using <code>has_homology.map</code> now? Maybe it helps here?</p>",
        "id": 285304028,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1654630907
    },
    {
        "content": "<p>did you see my <code>homology_map_eq</code>?</p>",
        "id": 285304209,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1654630999
    },
    {
        "content": "<p>no not yet -- where?</p>",
        "id": 285304220,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1654631010
    },
    {
        "content": "<p>the <code>has_homology</code> file</p>",
        "id": 285304232,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1654631017
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/lean-liquid/blob/aed9785900dd54c8a1432c73f62cdeaae0e997a7/src/for_mathlib/has_homology.lean#L258\">https://github.com/leanprover-community/lean-liquid/blob/aed9785900dd54c8a1432c73f62cdeaae0e997a7/src/for_mathlib/has_homology.lean#L258</a></p>",
        "id": 285304323,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1654631061
    },
    {
        "content": "<p>I saw you added something similar as well.</p>",
        "id": 285304331,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1654631071
    },
    {
        "content": "<p>The whole point of that sorry above is to relate a <code>has_homology.map</code> construction to something explicit.</p>",
        "id": 285304367,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1654631094
    },
    {
        "content": "<p>I think we've now got two different ways of solving the problem that working with <a href=\"http://homology.map\">homology.map</a> was difficult.</p>",
        "id": 285304713,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1654631286
    },
    {
        "content": "<p>You've related it to <code>has_homology.map</code> between the <code>homology</code> objects and I've related it to a more general <code>has_homology.map</code> coming from the isomorphism you can cook up between <code>homology f g</code> and any other object <code>H</code> satisfying <code>has_homology f g H</code></p>",
        "id": 285304836,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1654631374
    },
    {
        "content": "<p>I think the proof of your lemma would could be roughly <code>by simp [homology_map_eq]</code>.</p>",
        "id": 285306643,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1654632354
    },
    {
        "content": "<p>Well, not quite, but close</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">has_homology.map_iso_homology_map</span> <span class=\"o\">:</span>\n<span class=\"n\">has_homology.map</span> <span class=\"n\">h‚ÇÅ</span> <span class=\"n\">h‚ÇÇ</span> <span class=\"n\">sq1</span> <span class=\"n\">sq2</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">has_homology.iso</span> <span class=\"n\">h‚ÇÅ</span> <span class=\"o\">(</span><span class=\"n\">homology.has</span> <span class=\"n\">f‚ÇÅ</span> <span class=\"n\">g‚ÇÅ</span> <span class=\"n\">h‚ÇÅ.w</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">hom</span> <span class=\"bp\">‚â´</span>\n  <span class=\"o\">(</span><span class=\"n\">homology.map</span> <span class=\"n\">h‚ÇÅ.w</span> <span class=\"n\">h‚ÇÇ.w</span> <span class=\"o\">‚ü®</span><span class=\"n\">Œ±</span><span class=\"o\">,</span> <span class=\"n\">Œ≤</span><span class=\"o\">,</span> <span class=\"n\">sq1.w.symm</span><span class=\"o\">‚ü©</span> <span class=\"o\">‚ü®</span><span class=\"n\">Œ≤</span><span class=\"o\">,</span> <span class=\"n\">Œ≥</span><span class=\"o\">,</span> <span class=\"n\">sq2.w.symm</span><span class=\"o\">‚ü©</span> <span class=\"n\">rfl</span><span class=\"o\">)</span> <span class=\"bp\">‚â´</span>\n  <span class=\"o\">(</span><span class=\"n\">has_homology.iso</span> <span class=\"n\">h‚ÇÇ</span> <span class=\"o\">(</span><span class=\"n\">homology.has</span> <span class=\"n\">f‚ÇÇ</span> <span class=\"n\">g‚ÇÇ</span> <span class=\"n\">h‚ÇÇ.w</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">inv</span><span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">erw</span> <span class=\"n\">homology_map_eq</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">h‚ÇÅ.ext_œÄ</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">h‚ÇÇ.ext_Œπ</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>There should be a variant of <code>homology_map_eq</code> which uses an actual hom in <code>arrow</code> like you had it set up as opposed to <code>arrow.hom_mk</code>, but otherwise this proof is the usual thing we do in the category theory library, i.e. start with <code>ext</code> or some variant, then simplify.</p>",
        "id": 285307473,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1654632816
    },
    {
        "content": "<p>Overall I think the <code>has_homology</code> api is pretty smooth. My only complaint is that I would like the structure not to rely on <code>epi_desc</code> and <code>mono_lift</code> and <code>kernel</code>/<code>cokernel</code>, and instead allow for some arbitrary (co)limit (co)cones for the associated diagrams so that we can have nice defeq properties in explicit variants of homology (such as the one for <code>AddCommGroup</code>).</p>",
        "id": 285307708,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1654632949
    },
    {
        "content": "<p>Alright, <code>condensed/acyclic</code> should be sorry-free now</p>",
        "id": 285311286,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1654634745
    },
    {
        "content": "<p>Hopefully imker will be sorry-free tomorrow (I think i know how to prove it given what we have)</p>",
        "id": 285318717,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1654638620
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/267928-condensed-mathematics/topic/condensed.2Facyclic/near/285311286\">said</a>:</p>\n<blockquote>\n<p>Alright, <code>condensed/acyclic</code> should be sorry-free now</p>\n</blockquote>\n<p>Wow!! That was quite a battle in the end, all those naturality proofs. Thank you so much! I'm going to update the dependency graph.</p>",
        "id": 285354157,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1654673201
    },
    {
        "content": "<p>The graph has been updated. Four items left!</p>",
        "id": 285357040,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1654675264
    }
]
[
    {
        "content": "<p>I'm taking a break from marking and so I pulled LTE. The most noticeable thing was a new 1000 line file from Johan called <code>for_mathlib/salamander</code> which does a lot of diagram-chasology but is not quite sorry-free. I drew the diagram for the first sorry and it seems to me that the missing ingredient is that if A B C : \\C^op and f: A-&gt; B and g:B-&gt;C with gf=0 then you can make a commuting square from this picture with ker(g) being the fourth vertex, the map from A to ker(g) is called something like kernel.lift and the map from ker(g) to C is 0. Now you can take the unop of this entire diagram and get a commuting square in the original abelian category C but you can also make it by hand using coker(g^unop) and cokernel.desc. What we need is that \"these diagrams are the same\". How is one expected to prove this? I'm reminded of what we did in version 1 of schemes where we had to prove a ton of diagrams commuted and we just bashed it all out. But is there some sort of more sophisticated approach? I'm assuming (ker g)^unop isn't <em>equal</em> to coker(g^unop) in general. In schemes we introduced an \"is_localisation\" predicate. Do we have an \"is_cokernel\" predicate here because that would be one way to proceed. Or do people have completely different ideas about how to go about this?</p>",
        "id": 278707349,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1649776368
    },
    {
        "content": "<p>Yeah, there are 5 annoying sorries left in that file. But once we have those filled in, we'll have a very nice atomic building block for diagram chases in double complexes.</p>",
        "id": 278707624,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1649776483
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> <code>is_cokernel</code> is essentially <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.limits.is_colimit\">docs#category_theory.limits.is_colimit</a> applied to a <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.limits.cokernel_cofork\">docs#category_theory.limits.cokernel_cofork</a></p>",
        "id": 278708019,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1649776632
    },
    {
        "content": "<p>BTW, we should have <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.cokernel_unop_op\">docs#category_theory.cokernel_unop_op</a></p>",
        "id": 278708165,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1649776693
    },
    {
        "content": "<p>A little while ago I contemplated whether we should have (co)limits as a class, see<br>\n<a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/limits.20as.20a.20class.3F/near/247014056\">https://leanprover.zulipchat.com/#narrow/stream/217875-Is-there-code-for-X.3F/topic/limits.20as.20a.20class.3F/near/247014056</a></p>\n<p>As you can see, Bhavik wasn't a fan.</p>",
        "id": 278709096,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1649777085
    },
    {
        "content": "<p>nonono</p>",
        "id": 278710126,
        "sender_full_name": "Reid Barton",
        "timestamp": 1649777574
    },
    {
        "content": "<p>I guess Reid is not a fan either ;)</p>",
        "id": 278710177,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1649777600
    },
    {
        "content": "<p>The argument against is that it carries data but surely you can somehow bundle everything together and have a prop-valued predicate. Oh I guess the point is then that it can't be a class</p>",
        "id": 278727625,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1649785635
    },
    {
        "content": "<p>I don't think it's a problem for it to contain data. Yes, if we start throwing a bunch of instances of such classes in mathlib, that would be bad, but if we are conservative about what instances are declared as such, I don't think it would be a problem. </p>\n<p>This <code>is_zero</code> that I suggested in the link above is a special case that was added to LTE and it works very nicely.<br>\nWe could add <code>is_cokernel</code> and <code>is_kernel</code> as well, and I would guess they would be just as nice to work with in practice.</p>",
        "id": 278728283,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1649785885
    },
    {
        "content": "<p>But as Bhavik pointed out, is_zero doesn't have any data. Somehow you have to remember the map as well as the object with is_cokernel</p>",
        "id": 278728484,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1649785941
    },
    {
        "content": "<p>Yeah, but that map is unique given the properties it satisfies.</p>",
        "id": 278728719,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1649786020
    },
    {
        "content": "<p>Here's some code for the special case of cokernels.</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">category_theory.abelian.basic</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">category_theory</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">category</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">abelian</span> <span class=\"n\">C</span><span class=\"o\">]</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">is_cokernel</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">out_param</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">Z</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">π'</span> <span class=\"o\">:</span> <span class=\"n\">Y</span> <span class=\"bp\">⟶</span> <span class=\"n\">Z</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">≫</span> <span class=\"n\">π'</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"n\">nonempty</span> <span class=\"o\">(</span><span class=\"n\">limits.is_colimit</span> <span class=\"o\">(</span><span class=\"n\">limits.cokernel_cofork.of_π</span> <span class=\"n\">_</span> <span class=\"n\">h1</span><span class=\"o\">)))</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Z</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">is_cokernel</span> <span class=\"n\">f</span> <span class=\"n\">Z</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">is_cokernel.π</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Z</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">is_cokernel</span> <span class=\"n\">f</span> <span class=\"n\">Z</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Y</span> <span class=\"bp\">⟶</span> <span class=\"n\">Z</span> <span class=\"o\">:=</span>\n<span class=\"n\">is_cokernel.π'</span> <span class=\"n\">X</span>\n\n<span class=\"kd\">@[simp, reassoc]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">is_cokernel.condition</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">≫</span> <span class=\"n\">is_cokernel.π</span> <span class=\"n\">f</span> <span class=\"n\">Z</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"n\">is_cokernel.h1</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">is_cokernel.cofork</span> <span class=\"o\">:</span> <span class=\"n\">limits.cokernel_cofork</span> <span class=\"n\">f</span> <span class=\"o\">:=</span>\n<span class=\"n\">limits.cokernel_cofork.of_π</span> <span class=\"o\">(</span><span class=\"n\">is_cokernel.π</span> <span class=\"n\">f</span> <span class=\"n\">Z</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">is_cokernel.condition</span> <span class=\"n\">f</span> <span class=\"n\">Z</span><span class=\"o\">)</span>\n\n<span class=\"kd\">noncomputable</span>\n<span class=\"kd\">def</span> <span class=\"n\">is_cokernel.is_colimit</span> <span class=\"o\">:</span> <span class=\"n\">limits.is_colimit</span> <span class=\"o\">(</span><span class=\"n\">is_cokernel.cofork</span> <span class=\"n\">f</span> <span class=\"n\">Z</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">is_cokernel.h2.some</span>\n\n<span class=\"kd\">noncomputable</span>\n<span class=\"kd\">def</span> <span class=\"n\">is_cokernel.desc</span> <span class=\"o\">{</span><span class=\"n\">W</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">Y</span> <span class=\"bp\">⟶</span> <span class=\"n\">W</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">≫</span> <span class=\"n\">g</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Z</span> <span class=\"bp\">⟶</span> <span class=\"n\">W</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">is_cokernel.is_colimit</span> <span class=\"n\">f</span> <span class=\"n\">Z</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">desc</span> <span class=\"bp\">$</span> <span class=\"n\">limits.cokernel_cofork.of_π</span> <span class=\"n\">g</span> <span class=\"n\">w</span>\n\n<span class=\"kd\">@[simp, reassoc]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">is_cokernel.fac</span> <span class=\"o\">{</span><span class=\"n\">W</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">Y</span> <span class=\"bp\">⟶</span> <span class=\"n\">W</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">≫</span> <span class=\"n\">g</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">is_cokernel.π</span> <span class=\"n\">f</span> <span class=\"n\">Z</span> <span class=\"bp\">≫</span> <span class=\"n\">is_cokernel.desc</span> <span class=\"n\">f</span> <span class=\"n\">Z</span> <span class=\"n\">g</span> <span class=\"n\">w</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">is_cokernel.is_colimit</span> <span class=\"n\">f</span> <span class=\"n\">Z</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">fac</span> <span class=\"o\">(</span><span class=\"n\">limits.cokernel_cofork.of_π</span> <span class=\"n\">g</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">limits.walking_parallel_pair.one</span><span class=\"o\">)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">is_cokernel.uniq</span> <span class=\"o\">{</span><span class=\"n\">W</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">Y</span> <span class=\"bp\">⟶</span> <span class=\"n\">W</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">≫</span> <span class=\"n\">g</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">Z</span> <span class=\"bp\">⟶</span> <span class=\"n\">W</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">hm</span> <span class=\"o\">:</span> <span class=\"n\">is_cokernel.π</span> <span class=\"n\">f</span> <span class=\"n\">Z</span> <span class=\"bp\">≫</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">is_cokernel.desc</span> <span class=\"n\">f</span> <span class=\"n\">Z</span> <span class=\"n\">g</span> <span class=\"n\">w</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">apply</span> <span class=\"o\">(</span><span class=\"n\">is_cokernel.is_colimit</span> <span class=\"n\">f</span> <span class=\"n\">Z</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">uniq</span> <span class=\"o\">(</span><span class=\"n\">limits.cokernel_cofork.of_π</span> <span class=\"n\">g</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"n\">m</span><span class=\"o\">,</span>\n  <span class=\"n\">rintros</span> <span class=\"o\">(</span><span class=\"n\">_</span><span class=\"bp\">|</span><span class=\"n\">_</span><span class=\"o\">),</span> <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">},</span> <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">hm</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">@[ext]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">is_cokernel.hom_ext</span> <span class=\"o\">{</span><span class=\"n\">W</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">m₁</span> <span class=\"n\">m₂</span> <span class=\"o\">:</span> <span class=\"n\">Z</span> <span class=\"bp\">⟶</span> <span class=\"n\">W</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">is_cokernel.π</span> <span class=\"n\">f</span> <span class=\"n\">Z</span> <span class=\"bp\">≫</span> <span class=\"n\">m₁</span> <span class=\"bp\">=</span> <span class=\"n\">is_cokernel.π</span> <span class=\"n\">f</span> <span class=\"n\">Z</span> <span class=\"bp\">≫</span> <span class=\"n\">m₂</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">m₁</span> <span class=\"bp\">=</span> <span class=\"n\">m₂</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">apply</span> <span class=\"o\">(</span><span class=\"n\">is_cokernel.is_colimit</span> <span class=\"n\">f</span> <span class=\"n\">Z</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">hom_ext</span><span class=\"o\">,</span>\n  <span class=\"n\">rintros</span> <span class=\"o\">(</span><span class=\"n\">_</span><span class=\"bp\">|</span><span class=\"n\">_</span><span class=\"o\">),</span> <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">},</span> <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">h</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">noncomputable</span>\n<span class=\"kd\">def</span> <span class=\"n\">is_cokernel.iso</span> <span class=\"o\">(</span><span class=\"n\">Z'</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">is_cokernel</span> <span class=\"n\">f</span> <span class=\"n\">Z'</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Z</span> <span class=\"bp\">≅</span> <span class=\"n\">Z'</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">is_cokernel.is_colimit</span> <span class=\"n\">f</span> <span class=\"n\">Z</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">cocone_point_unique_up_to_iso</span> <span class=\"o\">(</span><span class=\"n\">is_cokernel.is_colimit</span> <span class=\"n\">f</span> <span class=\"n\">Z'</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">is_cokernel.iso_hom</span> <span class=\"o\">(</span><span class=\"n\">Z'</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">is_cokernel</span> <span class=\"n\">f</span> <span class=\"n\">Z'</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">is_cokernel.iso</span> <span class=\"n\">f</span> <span class=\"n\">Z</span> <span class=\"n\">Z'</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">hom</span> <span class=\"bp\">=</span> <span class=\"n\">is_cokernel.desc</span> <span class=\"n\">f</span> <span class=\"n\">Z</span> <span class=\"o\">(</span><span class=\"n\">is_cokernel.π</span> <span class=\"n\">f</span> <span class=\"n\">Z'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">is_cokernel.condition</span> <span class=\"n\">f</span> <span class=\"n\">Z'</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">is_cokernel.iso_inv</span> <span class=\"o\">(</span><span class=\"n\">Z'</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">is_cokernel</span> <span class=\"n\">f</span> <span class=\"n\">Z'</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">is_cokernel.iso</span> <span class=\"n\">f</span> <span class=\"n\">Z</span> <span class=\"n\">Z'</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">inv</span> <span class=\"bp\">=</span> <span class=\"n\">is_cokernel.desc</span> <span class=\"n\">f</span> <span class=\"n\">Z'</span> <span class=\"o\">(</span><span class=\"n\">is_cokernel.π</span> <span class=\"n\">f</span> <span class=\"n\">Z</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">is_cokernel.condition</span> <span class=\"n\">f</span> <span class=\"n\">Z</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">category_theory</span>\n</code></pre></div>\n</div></div>",
        "id": 278732178,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1649787531
    },
    {
        "content": "<p>Oh, and of course we can't forget</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">noncomputable</span>\n<span class=\"kd\">instance</span> <span class=\"n\">cokernel_is_cokernel</span> <span class=\"o\">:</span> <span class=\"n\">is_cokernel</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">limits.cokernel</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">π'</span> <span class=\"o\">:=</span> <span class=\"n\">limits.cokernel.π</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">h1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">h2</span> <span class=\"o\">:=</span> <span class=\"n\">nonempty.intro</span> <span class=\"bp\">$</span>\n  <span class=\"o\">{</span> <span class=\"n\">desc</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">limits.cokernel_cofork</span> <span class=\"n\">_</span><span class=\"o\">),</span> <span class=\"n\">limits.cokernel.desc</span> <span class=\"n\">_</span> <span class=\"n\">S.π</span> <span class=\"bp\">$</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">,</span>\n    <span class=\"n\">fac'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">limits.cokernel_cofork</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">_</span><span class=\"bp\">|</span><span class=\"n\">_</span><span class=\"o\">),</span> <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">},</span> <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">}</span> <span class=\"o\">},</span>\n    <span class=\"n\">uniq'</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n      <span class=\"n\">rintro</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">limits.cokernel_cofork</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">m</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n      <span class=\"n\">apply</span> <span class=\"n\">limits.coequalizer.hom_ext</span><span class=\"o\">,</span>\n      <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">h</span> <span class=\"n\">limits.walking_parallel_pair.one</span><span class=\"o\">,</span>\n    <span class=\"kd\">end</span> <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div>",
        "id": 278733462,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1649788091
    },
    {
        "content": "<p>Does this make the sorry easier? Does it really need to be a class rather than just a structure?</p>",
        "id": 278760760,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1649801578
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_localization\">docs#is_localization</a></p>",
        "id": 278760775,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1649801595
    },
    {
        "content": "<p>That's a class but also a Prop. Can you make pi' be an input rather than a field? Could it be a predicate on the morphism rather than the object?</p>",
        "id": 278760900,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1649801678
    },
    {
        "content": "<p>It doesn't need to be a class. If you're happy with a structure, then you can carry around a term of type <code>limits.is_colimit (limits.cokernel_cofork.of_π _ _)</code> (that what we currently have).</p>",
        "id": 278761596,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1649802142
    },
    {
        "content": "<p>From a purely philosophical point of view, what do you think of when you think of a limit? Say just a product <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi><mo>×</mo><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">X \\times Y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span></span></span></span>.<br>\nFrom my perspective, it's an object, say <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi></mrow><annotation encoding=\"application/x-tex\">P</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span></span></span></span>, which is endowed with the data of two projections <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi><mo>→</mo><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">P \\to X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">P \\to Y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span></span></span></span> which satisfy some axioms. Yes, the two projections <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi><mo>→</mo><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">P \\to X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">P \\to Y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span></span></span></span> are additional data, and the additional axioms are propositions.</p>\n<p>I think it would be nice to be able to write <code>[is_product X Y P]</code> and get <code>pi_1 : P \\to X</code> and <code>pi_2 : P \\to Y</code> (as well as the axioms) as part of the class..</p>",
        "id": 278762230,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1649802606
    },
    {
        "content": "<p>For me the salient example is a square being a pullback (or pushout), which has a pasting/cancellation property that seems more or less impossible to express in this language.</p>",
        "id": 278768031,
        "sender_full_name": "Reid Barton",
        "timestamp": 1649807489
    },
    {
        "content": "<p>But the same kind of issue arises even for products, e.g. a model of a Lawvere theory is a functor that preserves products and this also seems not to fit well with the <code>[is_product X Y P]</code> class</p>",
        "id": 278768196,
        "sender_full_name": "Reid Barton",
        "timestamp": 1649807639
    },
    {
        "content": "<p>We can probably avoid using the salamander lemma file. So there's no hurry to work on the remaining <code>sorry</code>s in <code>salamander.lean</code>.</p>",
        "id": 281748235,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1652131620
    }
]
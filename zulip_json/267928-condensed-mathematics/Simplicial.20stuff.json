[
    {
        "content": "<p>Hi all, I'm working on developing some of the basic simplicial constructions necessary for the project -- especially toward hypercovers.<br>\nFor now I would like to define the coskeleton functors (and prove that they're adjoint to the skeleton functors). <br>\nI made a mathlib PR with the skeleton functors earlier today: <a href=\"https://github.com/leanprover-community/mathlib/issues/6711\">#6711</a></p>\n<p>The coskeleton functors will be a bit more of a challenge :)</p>",
        "id": 230548292,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1615912995
    },
    {
        "content": "<p>... So I'm still running into a LOT of annoying universe-related issues. To define the coskeleton functors, one takes a limit over some finite diagram indexed by a category constructed out of <code>simplex_category</code>. The issue is that to take a limit of a diagram indexes by <code>J</code> in a category <code>C</code> with universe parameters <code>category.{v u} C</code>, we must have <code>J : Type v</code> with <code>J</code> a small category. </p>\n<p>So, I defined the following gadget<br>\n<a href=\"https://github.com/leanprover-community/mathlib/blob/296104b7f3295aa40c68efd17b310f33e13f318b/src/category_theory/category/ulift.lean#L73\">https://github.com/leanprover-community/mathlib/blob/296104b7f3295aa40c68efd17b310f33e13f318b/src/category_theory/category/ulift.lean#L73</a><br>\nthat lets you lift a small category to another small category in another universe.</p>\n<p>But now I find myself having to use things like <code>ulift'.equivalence.congr_left.functor.obj</code> all over the place and I'm ready to give up...</p>\n<p>What's the best way forward?</p>",
        "id": 230767432,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616015498
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> do you have a good idea?</p>",
        "id": 230768331,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616015758
    },
    {
        "content": "<p>I feel like this whole enterprise would be a lot easier if we had a universe polymorphic <code>simplex_category</code> to begin with</p>",
        "id": 230768424,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616015784
    },
    {
        "content": "<p>And define <code>simplicial_object C</code> in the case <code>category.{v u} C</code> as <code>simplex_category.{v}\\op \\func C</code>.</p>",
        "id": 230768499,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616015825
    },
    {
        "content": "<p>hmm, because even if you say that <code>C</code> has objects in <code>Type</code>, then you are stuck when <code>C</code> is large.</p>",
        "id": 230768515,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616015830
    },
    {
        "content": "<p>Not even just for large <code>C</code>, but any time the morphisms of <code>C</code> are not in <code>Type</code></p>",
        "id": 230768560,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616015855
    },
    {
        "content": "<p>Right, so also for <em>laaaarge</em> categories (-;</p>",
        "id": 230768596,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616015876
    },
    {
        "content": "<p>Oh yeah, you're right, if <code>C : Type</code> then that's the same as <code>C</code>being large :)</p>",
        "id": 230768649,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616015885
    },
    {
        "content": "<p>or <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"fraktur\">L</mi><mi mathvariant=\"fraktur\">A</mi><mi mathvariant=\"fraktur\">R</mi><mi mathvariant=\"fraktur\">G</mi><mi mathvariant=\"fraktur\">E</mi></mrow><annotation encoding=\"application/x-tex\">\\mathfrak{LARGE}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69141em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathfrak\">L</span><span class=\"mord mathfrak\">A</span><span class=\"mord mathfrak\">R</span><span class=\"mord mathfrak\">G</span><span class=\"mord mathfrak\">E</span></span></span></span></span></p>",
        "id": 230768699,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616015912
    },
    {
        "content": "<p>But for <code>NormedGroup.{0}</code> and <code>Profinite.{0}</code> etc... we are fine.</p>",
        "id": 230768716,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616015921
    },
    {
        "content": "<p>So, if we just want to flesh out the theory modulo universe issues, you could assume <code>v = 0</code> everywhere, for now.</p>",
        "id": 230768760,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616015944
    },
    {
        "content": "<p>Yeah, I think so. But it feels silly to construct these things without making it mathlib compatible</p>",
        "id": 230768796,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616015954
    },
    {
        "content": "<p>The downside of <code>simplex_category := NonEmptyFinLinOrd</code> is that now the simplex category is suddenly large.</p>",
        "id": 230768988,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616016032
    },
    {
        "content": "<p>Well, I already wrote a bunch of code proving all the associated categories were finite, which relies on the fact that <code>fin a -&gt; fin b</code> and <code>fin c</code> are all finite types, and using <code>NonEmptyFinLinOrd</code> would make that part a lot harder...</p>",
        "id": 230769022,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616016053
    },
    {
        "content": "<p>This is all in <a href=\"https://github.com/leanprover-community/mathlib/tree/simplicial_cosk\">branch#simplicial_cosk</a></p>",
        "id": 230769055,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616016069
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> How evil is it to have universe constraints of the form <code>u1 \\le u2</code> in your type theory.</p>",
        "id": 230769220,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616016135
    },
    {
        "content": "<p>I think the simplex category should be a \"concrete\" category, i.e. have objects <em>equal</em> to the nonnegative integers (does that even make sense? In some sense it shouldn't...)</p>",
        "id": 230769241,
        "sender_full_name": "Peter Scholze",
        "timestamp": 1616016143
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"369530\">@Peter Scholze</span> Yeah, that's how it's constructed right now</p>",
        "id": 230769267,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616016158
    },
    {
        "content": "<p>OK, great</p>",
        "id": 230769277,
        "sender_full_name": "Peter Scholze",
        "timestamp": 1616016164
    },
    {
        "content": "<p>But in Lean universes are not cumulative.</p>",
        "id": 230769303,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616016178
    },
    {
        "content": "<p>But we also have some API for skeletons of categories, which is supposed to make this easier (in theory <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span> )</p>",
        "id": 230769314,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616016184
    },
    {
        "content": "<p>So <code>simplex_category : Type</code> and hence not <code>: Type v</code> for larger <code>v</code>.</p>",
        "id": 230769346,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616016201
    },
    {
        "content": "<p>I'd guess so</p>",
        "id": 230769362,
        "sender_full_name": "Peter Scholze",
        "timestamp": 1616016212
    },
    {
        "content": "<p>And when you set up an API for categorical limits, you have to decide where the index categories of your limits live.</p>",
        "id": 230769380,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616016226
    },
    {
        "content": "<p>Ideally, they just live in any \"small\" universe. But you can't quantify over universes...</p>",
        "id": 230769455,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616016253
    },
    {
        "content": "<p>Surely they are small limits, so they probably live one universe level down from the ambient one</p>",
        "id": 230769493,
        "sender_full_name": "Peter Scholze",
        "timestamp": 1616016268
    },
    {
        "content": "<p>Aha, OK...</p>",
        "id": 230769509,
        "sender_full_name": "Peter Scholze",
        "timestamp": 1616016277
    },
    {
        "content": "<p>So, we currently have <code>category.{v u} C</code> which means <code>C : Type u</code> are the objects, and <code>Hom X Y : Type v</code> for the morphisms</p>",
        "id": 230769598,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616016317
    },
    {
        "content": "<p>And index categories for limits must live in <code>Type v</code>.</p>",
        "id": 230769620,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616016330
    },
    {
        "content": "<p>But when you have a limit that is naturally indexed by something in <code>Type w</code> for <code>w &lt; v</code>, Lean just says \"nope\"</p>",
        "id": 230769673,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616016361
    },
    {
        "content": "<p>And that's annoying.</p>",
        "id": 230769711,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616016365
    },
    {
        "content": "<p>Oh, that's annoying indeed.</p>",
        "id": 230769732,
        "sender_full_name": "Peter Scholze",
        "timestamp": 1616016380
    },
    {
        "content": "<p>so there's no \"universe coercion\" or something like that?</p>",
        "id": 230769761,
        "sender_full_name": "Peter Scholze",
        "timestamp": 1616016391
    },
    {
        "content": "<p>So you can build constructions that lift things to a higher universe... yes</p>",
        "id": 230769766,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616016396
    },
    {
        "content": "<p>But you don't want to have those all over the place, if you can avoid it</p>",
        "id": 230769789,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616016407
    },
    {
        "content": "<p>We have this <code>ulift</code> thing</p>",
        "id": 230769791,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616016409
    },
    {
        "content": "<p>So I can write this, for example</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">simplex_category'</span> <span class=\"o\">:=</span> <span class=\"n\">ulift.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">ℕ</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">small_category.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">simplex_category'</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">hom</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">ulift</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"o\">(</span><span class=\"n\">a.down</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">→ₘ</span> <span class=\"n\">fin</span> <span class=\"o\">(</span><span class=\"n\">b.down</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)),</span>\n  <span class=\"n\">id</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">ulift.up</span> <span class=\"n\">preorder_hom.id</span><span class=\"o\">,</span>\n  <span class=\"n\">comp</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">ulift.up</span> <span class=\"bp\">$</span> <span class=\"n\">preorder_hom.comp</span> <span class=\"n\">g.down</span> <span class=\"n\">f.down</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 230769805,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616016419
    },
    {
        "content": "<p>I don't know enough about foundations of maths/type theory to know what can of worms is opened by allowing to quantify over universes.</p>",
        "id": 230770004,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616016505
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"369530\">@Peter Scholze</span> Do you know of a construction in mathematics that iterates \"universe bumps\"?</p>",
        "id": 230770060,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616016534
    },
    {
        "content": "<p>A universe bump, is for example the topos-theoretic approach to cohomology. If you take the abstract approach to etale cohomology, then for <code>X : Scheme.{0}</code> the etale cohomology will live in <code>Type 1</code></p>",
        "id": 230770170,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616016590
    },
    {
        "content": "<p>So now you can imagine that you look at <code>Spec (some_cohomology_ring)</code> or so...</p>",
        "id": 230770313,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616016636
    },
    {
        "content": "<p>But I don't really know of a natural example where you would want to iterate this process arbitrarily often.</p>",
        "id": 230770358,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616016662
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/267928-condensed-mathematics/topic/Simplicial.20stuff/near/230769220\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> How evil is it to have universe constraints of the form <code>u1 \\le u2</code> in your type theory.</p>\n</blockquote>\n<p>They already exist, you just can't write them. But they aren't usually needed, since you get an equivalent effect by replacing all instances of <code>u2</code> with <code>max u1 u2</code></p>",
        "id": 230770390,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616016676
    },
    {
        "content": "<p>Or even better, if you construct say the etale \\pi_1 in the categorical way it would be a group in <code>Type 1</code>, and then you take group cohomology of that constructed in some categorical way and you get something in <code>Type 2</code>, etc.</p>",
        "id": 230770452,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616016715
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> But that doesn't allow quantifying over all <code>u1</code> such that <code>max u1 u2 = u2</code></p>",
        "id": 230770667,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616016791
    },
    {
        "content": "<p>I somehow want to write</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">foobar</span> <span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"bp\">\\</span><span class=\"n\">le</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"bp\">...</span>\n</code></pre></div>",
        "id": 230770723,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616016824
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> you say etc etc but I can't see this naturally leading to a situation where we might want to universe-bump infinitely often.</p>",
        "id": 230770865,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616016872
    },
    {
        "content": "<p>Oh I see. yes of course.</p>",
        "id": 230770890,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616016891
    },
    {
        "content": "<p>Well, then you can iterate the classifying space construction of an abelian group</p>",
        "id": 230770969,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616016935
    },
    {
        "content": "<p>(which is involved in the second step of my example)</p>",
        "id": 230770989,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616016944
    },
    {
        "content": "<p>I did my entire course just using Prop and Type, I knew it would all fit into ZFC and I think universes are just one more thing that makes lean look intimidating</p>",
        "id": 230771070,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616016965
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> Instead of</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">foobar</span> <span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"bp\">\\</span><span class=\"n\">le</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"bp\">...</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span>\n</code></pre></div>\n<p>you write</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">foobar</span> <span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"bp\">...</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 230771443,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616017176
    },
    {
        "content": "<p>But what if <code>v</code> changes in another definition later on, while <code>u</code> stays the same?</p>",
        "id": 230771763,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616017319
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> What do you suggest that this should be changed to:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">universes</span> <span class=\"n\">v</span> <span class=\"n\">u</span> <span class=\"n\">u'</span> <span class=\"n\">u''</span> <span class=\"n\">w</span> <span class=\"c1\">-- declare the `v`'s first; see `category_theory.category` for an explanation</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">J</span> <span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">small_category</span> <span class=\"n\">J</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">small_category</span> <span class=\"n\">K</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">category.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">C</span><span class=\"o\">]</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">J</span> <span class=\"bp\">⥤</span> <span class=\"n\">C</span><span class=\"o\">}</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">A cone `t` on `F` is a limit cone if each cone on `F` admits a unique</span>\n<span class=\"sd\">cone morphism to `t`.</span>\n\n<span class=\"sd\">See https://stacks.math.columbia.edu/tag/002E.</span>\n<span class=\"sd\">  -/</span>\n<span class=\"kd\">@[nolint has_inhabited_instance]</span>\n<span class=\"kd\">structure</span> <span class=\"n\">is_limit</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">cone</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">lift</span>  <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">cone</span> <span class=\"n\">F</span><span class=\"o\">),</span> <span class=\"n\">s.X</span> <span class=\"bp\">⟶</span> <span class=\"n\">t.X</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">fac'</span>  <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">cone</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">J</span><span class=\"o\">),</span> <span class=\"n\">lift</span> <span class=\"n\">s</span> <span class=\"bp\">≫</span> <span class=\"n\">t.π.app</span> <span class=\"n\">j</span> <span class=\"bp\">=</span> <span class=\"n\">s.π.app</span> <span class=\"n\">j</span> <span class=\"bp\">.</span> <span class=\"n\">obviously</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">uniq'</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">cone</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">s.X</span> <span class=\"bp\">⟶</span> <span class=\"n\">t.X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">J</span><span class=\"o\">,</span> <span class=\"n\">m</span> <span class=\"bp\">≫</span> <span class=\"n\">t.π.app</span> <span class=\"n\">j</span> <span class=\"bp\">=</span> <span class=\"n\">s.π.app</span> <span class=\"n\">j</span><span class=\"o\">),</span>\n  <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">lift</span> <span class=\"n\">s</span> <span class=\"bp\">.</span> <span class=\"n\">obviously</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 230771838,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616017343
    },
    {
        "content": "<p>Currently <code>J : Type v</code> and <code>[category.{v} C]</code></p>",
        "id": 230771878,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616017372
    },
    {
        "content": "<p>Somehow, <code>J</code> should be small, relative to <code>C</code></p>",
        "id": 230771931,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616017403
    },
    {
        "content": "<p>where does the inequality come up?</p>",
        "id": 230771933,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616017403
    },
    {
        "content": "<p><code>[category.{v (max v u)} C]</code></p>",
        "id": 230771966,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616017422
    },
    {
        "content": "<p>Well, we would like to be able to consider both <code>J : Type v</code> and <code>J : Type 0</code></p>",
        "id": 230771972,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616017425
    },
    {
        "content": "<p>And if <code>v</code> happens to be <code>2</code>, then <code>J : Type 1</code> should also work</p>",
        "id": 230772040,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616017447
    },
    {
        "content": "<p>or actually just <code>variables {C : Type (max v u)} [category.{v} C]</code></p>",
        "id": 230772042,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616017448
    },
    {
        "content": "<p>I mean, why does the inequality need to exist? Why can't you use a small <code>u</code></p>",
        "id": 230772116,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616017494
    },
    {
        "content": "<p>I think <code>u</code> is unrelated to what we are doing.</p>",
        "id": 230772163,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616017518
    },
    {
        "content": "<p>You said you need <code>v &lt;= u</code></p>",
        "id": 230772198,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616017531
    },
    {
        "content": "<p>so apparently <code>u</code> needs to be large</p>",
        "id": 230772241,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616017550
    },
    {
        "content": "<p>I want <code>J : Type v1</code> and <code>[category.{v2} C]</code> and <code>v1 &lt;= v2</code></p>",
        "id": 230772257,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616017557
    },
    {
        "content": "<p>what happens if the inequality fails?</p>",
        "id": 230772312,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616017570
    },
    {
        "content": "<p>And <code>C : Type u</code>, but that doesn't matter.</p>",
        "id": 230772332,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616017576
    },
    {
        "content": "<p>Oh there are two v's?</p>",
        "id": 230772358,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616017590
    },
    {
        "content": "<p>There aren't in that snippet</p>",
        "id": 230772369,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616017598
    },
    {
        "content": "<p>Currently <code>v1 = v2</code></p>",
        "id": 230772373,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616017601
    },
    {
        "content": "<p>But that causes trouble, because now we can take limits over <code>simplex_category : Type 0</code></p>",
        "id": 230772450,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616017633
    },
    {
        "content": "<p>Concretely, we want the following example to work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">category_theory.limits.limits</span>\n\n<span class=\"kd\">universes</span> <span class=\"n\">v</span> <span class=\"n\">u</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">category_theory</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">category.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">limits.has_limits</span> <span class=\"n\">C</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">J</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">small_category</span> <span class=\"n\">J</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">J</span> <span class=\"bp\">⥤</span> <span class=\"n\">C</span><span class=\"o\">)</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"o\">:=</span> <span class=\"n\">limits.limit</span> <span class=\"n\">F</span>\n</code></pre></div>",
        "id": 230772506,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616017665
    },
    {
        "content": "<p>And we want to show that <code>Type 2</code> has all products indexed by <code>J : Type v</code> for <code>v = 0</code>, <code>v = 1</code> and <code>v = 2</code>. If that is possible, it would be great.</p>",
        "id": 230772713,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616017754
    },
    {
        "content": "<p>Without addressing the harder issue of increasing the universe polymorphicity of <code>limits.limit</code>, I think <span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span>'s suggestion above</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">simplex_category'</span> <span class=\"o\">:=</span> <span class=\"n\">ulift.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">ℕ</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">small_category.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">simplex_category'</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">hom</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">ulift</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"o\">(</span><span class=\"n\">a.down</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">→ₘ</span> <span class=\"n\">fin</span> <span class=\"o\">(</span><span class=\"n\">b.down</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)),</span>\n  <span class=\"n\">id</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">ulift.up</span> <span class=\"n\">preorder_hom.id</span><span class=\"o\">,</span>\n  <span class=\"n\">comp</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">ulift.up</span> <span class=\"bp\">$</span> <span class=\"n\">preorder_hom.comp</span> <span class=\"n\">g.down</span> <span class=\"n\">f.down</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>is going to be pretty good.</p>",
        "id": 230772740,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1616017773
    },
    {
        "content": "<p>After a very small amount of API for converting <code>nat</code> to <code>simplex_category'</code>, it should be smooth sailing, no?</p>",
        "id": 230772796,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1616017797
    },
    {
        "content": "<p>So that should just become the new definition of <code>simplex_category</code>?</p>",
        "id": 230772798,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616017800
    },
    {
        "content": "<p>Yes.</p>",
        "id": 230772842,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1616017805
    },
    {
        "content": "<p>That sounds good to me.</p>",
        "id": 230772863,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616017814
    },
    {
        "content": "<p>We want some API indeed:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- `X.obj (op $ (0:ℕ))` is quite a mouthful to talk about `X_0` :sad:</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">category</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">simplicial_object</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X.obj</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"bp\">$</span> <span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">:</span><span class=\"n\">ℕ</span><span class=\"o\">))</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 230772921,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616017843
    },
    {
        "content": "<p>But while we're at it, we should record somewhere Adam's other code snippet, ending at <code>example : C := limits.limit F</code>, perhaps as a github issue, because this is exactly what we really want.</p>",
        "id": 230772947,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1616017861
    },
    {
        "content": "<p>There's already some notation:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">local</span> <span class=\"kd\">notation</span> <span class=\"bp\">`</span><span class=\"o\">[</span><span class=\"bp\">`</span><span class=\"n\">n</span><span class=\"bp\">`</span><span class=\"o\">]</span><span class=\"bp\">`</span> <span class=\"o\">:=</span> <span class=\"n\">mk</span> <span class=\"n\">n</span>\n</code></pre></div>",
        "id": 230773227,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1616017980
    },
    {
        "content": "<p>Can we have <code>open_locale simplicial</code> enable that?</p>",
        "id": 230773293,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616018013
    },
    {
        "content": "<p>where we can hide the <code>ulift</code>, and also put it under <code>open_locale simplicial</code>.</p>",
        "id": 230773308,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1616018020
    },
    {
        "content": "<p>there's already localized notation in <code>sSet</code></p>",
        "id": 230773345,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1616018038
    },
    {
        "content": "<p>perhaps we could combine those into one locale</p>",
        "id": 230773398,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1616018046
    },
    {
        "content": "<p>I'm not sure how much Lean time I will have today, but I can try to insert this ulift into what is already in mathlib sometime.</p>",
        "id": 230773505,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1616018092
    },
    {
        "content": "<p>I'm starting the refactor now <span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span>.</p>",
        "id": 230773739,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616018183
    },
    {
        "content": "<p>Probably won't finish today, but feel free to push to my branch (I'll push it to github once something is working)</p>",
        "id": 230773785,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616018208
    },
    {
        "content": "<p>(I wish we could rename the emojis. You have to type <code>:working on it:</code> to get that one, but we all seem to use it as the much better <code>:you are working on it and that is awesome:</code>.)</p>",
        "id": 230773892,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1616018269
    },
    {
        "content": "<p>Well, in this proetale business one wants to often construct things that admit no further etale covers, for which one takes a product of \"all\" etale maps, and sometimes needs to iterate this process countably many times. If one is not careful, one would enlarge the universe infinitely often</p>",
        "id": 230773897,
        "sender_full_name": "Peter Scholze",
        "timestamp": 1616018270
    },
    {
        "content": "<p>That is something we can not do around here. :-)</p>",
        "id": 230773996,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1616018310
    },
    {
        "content": "<p>Well, I'm not doing it either, I stay in one universe throughout</p>",
        "id": 230774067,
        "sender_full_name": "Peter Scholze",
        "timestamp": 1616018347
    },
    {
        "content": "<p>But I put some nasty cardinal bounds in to justify this</p>",
        "id": 230774101,
        "sender_full_name": "Peter Scholze",
        "timestamp": 1616018358
    },
    {
        "content": "<p>Anyways, I'm off for tonight! I'm really excited about the progress!</p>",
        "id": 230774429,
        "sender_full_name": "Peter Scholze",
        "timestamp": 1616018437
    },
    {
        "content": "<p>Thanks for the example</p>",
        "id": 230774684,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616018488
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> I pushed a sketchy refactor to this branch: <a href=\"https://github.com/leanprover-community/mathlib/tree/simplex_refactor\">branch#simplex_refactor</a></p>\n<p>It still needs a bit of cleaning up, but at least there are no errors. </p>\n<p>Also the <code>has_(co)limit</code> instances are now MUCH easier :)</p>",
        "id": 230782490,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616021443
    },
    {
        "content": "<p>In any case, I'm done for today, but please feel free to push to this branch as you see fit</p>",
        "id": 230782567,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616021499
    },
    {
        "content": "<p>I pushed a commit making <code>simplex_category</code> irreducible.</p>",
        "id": 230786806,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1616024183
    },
    {
        "content": "<p>I was aspiring to make <code>mk</code> irreducible as well, but that one has me stumped at the moment.</p>",
        "id": 230787830,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1616024882
    },
    {
        "content": "<p>I started a refactor to mathlib generalising the universe variables for limits a few weeks ago, basically allowing us to talk about non-small limits as well - it mostly went pretty smoothly and I'm hoping to PR it soon</p>",
        "id": 230850255,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1616068582
    },
    {
        "content": "<p>Looking forward to it!</p>",
        "id": 230852016,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1616069494
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"246273\">@Bhavik Mehta</span>Eager to know what you come up with!</p>",
        "id": 230854704,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616070875
    },
    {
        "content": "<p>I refactors a bit more around <code>simplex_category</code> in the following branch, building on Scott's latest commits:<br>\n<a href=\"https://github.com/leanprover-community/mathlib/compare/simplex_refactor_hom_irred\">https://github.com/leanprover-community/mathlib/compare/simplex_refactor_hom_irred</a></p>",
        "id": 230879450,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616080126
    },
    {
        "content": "<p>The main thing is that I introduced an (irreduccible) <code>simplex_category.hom</code> with a little API with <code>mk</code> and <code>to_preorder_hom</code>.</p>",
        "id": 230879587,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616080160
    },
    {
        "content": "<p>Adding some careful simp lemmas actually simplifies the file quite a bit with a lot of simp lemmas being redundant.</p>",
        "id": 230879672,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616080198
    },
    {
        "content": "<p>The only strange thing is that I now have to use <code>simpa [fin.pred_above]</code> in a few places whereas previously it was just <code>simpa</code>. I don't really know why, but it works.</p>",
        "id": 230879841,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616080239
    },
    {
        "content": "<p>The skeletal functor for simplex_category is now completely universe polymorphic -- simplex_category and NonemptyFinLinOrd can be in completely unrelated universes.</p>",
        "id": 230879972,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616080291
    },
    {
        "content": "<p>I would also like to introduce the following (localized) notation. What's a sensible value for 1000 in the following code?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- TODO: find a sensible value for `1000`.</span>\n<span class=\"n\">localized</span>\n  <span class=\"s2\">\"notation X `_[`:1000 n `]` := (X : simplicial_object _).obj (op (simplex_category.mk n))\"</span>\n  <span class=\"k\">in</span> <span class=\"n\">simplicial</span>\n</code></pre></div>",
        "id": 230893720,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616084072
    },
    {
        "content": "<p>(see <a href=\"https://github.com/leanprover-community/mathlib/blob/d2e2236a441cc95572885406a06ee482e1a8c632/src/algebraic_topology/simplicial_object.lean#L35\">https://github.com/leanprover-community/mathlib/blob/d2e2236a441cc95572885406a06ee482e1a8c632/src/algebraic_topology/simplicial_object.lean#L35</a> )</p>",
        "id": 230893805,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616084107
    },
    {
        "content": "<p>This way the face maps look nice: </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">δ</span> <span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">2</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"n\">_</span><span class=\"o\">[</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">]</span> <span class=\"bp\">⟶</span> <span class=\"n\">X</span> <span class=\"n\">_</span><span class=\"o\">[</span><span class=\"n\">n</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n</code></pre></div>",
        "id": 230893913,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616084153
    },
    {
        "content": "<p>Of course, if someone has another suggestion for a better approximation of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>X</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>→</mo><msub><mi>X</mi><mi>n</mi></msub></mrow><annotation encoding=\"application/x-tex\">X_{n+1} \\to X_n</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.891661em;vertical-align:-0.208331em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.301108em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.208331em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>, please let me know :)</p>",
        "id": 230894112,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616084204
    },
    {
        "content": "<p>I have no idea what's happening here. What is the 1000 supposed to be doing?</p>",
        "id": 230894181,
        "sender_full_name": "Peter Scholze",
        "timestamp": 1616084233
    },
    {
        "content": "<p>Oh, it's a silly lean thing... it just tells lean how much priority to give to this notation</p>",
        "id": 230894276,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616084276
    },
    {
        "content": "<p>Ah!</p>",
        "id": 230894347,
        "sender_full_name": "Peter Scholze",
        "timestamp": 1616084289
    },
    {
        "content": "<p>Without the 1000, I would have to write <code>X _[n+1] ⟶ (X _[n])</code> or else lean would get confused</p>",
        "id": 230894386,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616084307
    },
    {
        "content": "<p>Peter, these numbers govern whether <code>a + b * c</code> is <code>(a + b) * c</code> or <code>a + (b * c)</code>. Luckily, they work out to mean the latter (-;</p>",
        "id": 230894516,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616084372
    },
    {
        "content": "<p>In what range do they live, typically?</p>",
        "id": 230894544,
        "sender_full_name": "Peter Scholze",
        "timestamp": 1616084389
    },
    {
        "content": "<p><code>0 -- 1024</code></p>",
        "id": 230894559,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616084397
    },
    {
        "content": "<p>not sure exactly, but 1000 is high</p>",
        "id": 230894564,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616084399
    },
    {
        "content": "<p>Ooh, I guess <code>0</code> or <code>1024</code> doesn't belong to the range... but I'm not sure</p>",
        "id": 230894662,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616084425
    },
    {
        "content": "<p><code>=</code> is <code>_ </code>=<code>:50 _:50 := eq #1 #0</code></p>",
        "id": 230894748,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616084464
    },
    {
        "content": "<p>(so 50 is meant to be very low)</p>",
        "id": 230894842,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616084502
    },
    {
        "content": "<p><code>$</code> mentions zero: <code>_ `$`:1 _:0 := #1 #0</code></p>",
        "id": 230896243,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616085147
    },
    {
        "content": "<p>There's also <code>:max</code> and one more than that, <code>:std.prec.max_plus</code>, that \"turns it up to 11\", which means bind in the strongest way possible, currently only used for </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">src</span><span class=\"bp\">/</span><span class=\"n\">data</span><span class=\"bp\">/</span><span class=\"n\">opposite.lean</span><span class=\"o\">:</span><span class=\"kd\">notation</span> <span class=\"n\">α</span> <span class=\"bp\">`ᵒᵖ`</span><span class=\"o\">:</span><span class=\"n\">std.prec.max_plus</span> <span class=\"o\">:=</span> <span class=\"n\">opposite</span> <span class=\"n\">α</span>\n<span class=\"n\">src</span><span class=\"bp\">/</span><span class=\"n\">field_theory</span><span class=\"bp\">/</span><span class=\"n\">adjoin.lean</span><span class=\"o\">:</span><span class=\"kd\">notation</span> <span class=\"n\">K</span><span class=\"bp\">`⟮`</span><span class=\"o\">:</span><span class=\"n\">std.prec.max_plus</span> <span class=\"n\">l</span><span class=\"o\">:(</span><span class=\"n\">foldr</span> <span class=\"bp\">`</span><span class=\"o\">,</span> <span class=\"bp\">`</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">insert.insert</span> <span class=\"n\">t</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"bp\">∅</span><span class=\"o\">)</span> <span class=\"bp\">`⟯`</span> <span class=\"o\">:=</span> <span class=\"n\">adjoin</span> <span class=\"n\">K</span> <span class=\"n\">l</span>\n</code></pre></div>",
        "id": 230896372,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1616085214
    },
    {
        "content": "<p>but </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">infixr</span> <span class=\"bp\">`⋆`</span><span class=\"o\">:</span><span class=\"mi\">1000000</span> <span class=\"o\">:=</span> <span class=\"n\">has_mul.mul</span>\n\n<span class=\"k\">#print</span> <span class=\"kd\">notation</span> <span class=\"bp\">⋆</span> <span class=\"c1\">-- _ `⋆`:1000000 _:999999 := has_mul.mul #1 #0</span>\n</code></pre></div>",
        "id": 230896628,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616085304
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"308899\">@Yakov Pechersky</span> I don't really understand the notation syntax. Does the above <code>X _[n]</code> notation look reasonable to you?</p>",
        "id": 230896946,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616085419
    },
    {
        "content": "<p>Should the <code>X</code> and/or the <code>]</code> have some number next to them as well?</p>",
        "id": 230897241,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616085525
    },
    {
        "content": "<p>I think it will work. Here's my test:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">open_locale</span> <span class=\"n\">big_operators</span>\n\n<span class=\"kd\">notation</span>  <span class=\"bp\">`</span><span class=\"n\">_</span><span class=\"o\">[</span><span class=\"bp\">`</span><span class=\"o\">:</span><span class=\"mi\">1000</span> <span class=\"n\">n</span> <span class=\"bp\">`</span><span class=\"o\">]</span><span class=\"bp\">`</span> <span class=\"o\">:=</span> <span class=\"n\">fin</span> <span class=\"n\">n</span>\n\n<span class=\"k\">#print</span> <span class=\"kd\">notation</span> <span class=\"n\">_</span><span class=\"o\">[</span>\n\n<span class=\"k\">#check</span> <span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">_</span> <span class=\"bp\">×</span> <span class=\"n\">fin</span> <span class=\"n\">_</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">)),</span> <span class=\"bp\">∑</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">_</span><span class=\"o\">[</span> <span class=\"mi\">2</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"o\">]</span> <span class=\"bp\">×</span> <span class=\"n\">_</span><span class=\"o\">[</span> <span class=\"mi\">3</span> <span class=\"bp\">*</span> <span class=\"mi\">3</span> <span class=\"o\">],</span> <span class=\"n\">f</span> <span class=\"n\">i</span>\n</code></pre></div>",
        "id": 230897658,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1616085682
    },
    {
        "content": "<p>Without a number, <code>]</code> will be <code>:0</code> which I don't think will make a difference whether it is 0 or 999</p>",
        "id": 230897699,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1616085702
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/267928-condensed-mathematics/topic/Simplicial.20stuff/near/230879450\">said</a>:</p>\n<blockquote>\n<p>I refactored a bit more around <code>simplex_category</code> in the following branch, building on Scott's latest commits:<br>\n<a href=\"https://github.com/leanprover-community/mathlib/compare/simplex_refactor_hom_irred\">https://github.com/leanprover-community/mathlib/compare/simplex_refactor_hom_irred</a></p>\n</blockquote>\n<p>Is this ready to PR?</p>",
        "id": 230944497,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1616104961
    },
    {
        "content": "<p>I think so... let me go through it quickly an open a PR.</p>",
        "id": 230944921,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616105159
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/issues/6761\">#6761</a></p>",
        "id": 230947723,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616106839
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> One thing to note: this PR deletes a handful of the simp lemmas that were in the file from before, in favor of some simp lemmas for this new (irreducible) <code>simplex_category.hom</code>. If there's a lemma that seems to be missing, I'd be happy to add it back.</p>",
        "id": 230948075,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616107066
    },
    {
        "content": "<p>aaah. I'm running into even more categorical headaches. This time I think it's because <code>opposite</code> is irreducible.</p>\n<p>Take a look at the following goal:<br>\n<a href=\"https://github.com/leanprover-community/mathlib/blob/ec1b65487b40942baa21bf2dc3dd0a337e4f8f83/src/algebraic_topology/simplicial_object.lean#L170\">https://github.com/leanprover-community/mathlib/blob/ec1b65487b40942baa21bf2dc3dd0a337e4f8f83/src/algebraic_topology/simplicial_object.lean#L170</a></p>\n<p>It feels really silly that tidy cant close this proof all by itself. I don't even want to think about the <code>map_comp'</code> field if <code>map_id'</code> is hard!<br>\nI think the issue boils down to the definition here:<br>\n<a href=\"https://github.com/leanprover-community/mathlib/blob/ec1b65487b40942baa21bf2dc3dd0a337e4f8f83/src/algebraic_topology/simplex_category.lean#L461\">https://github.com/leanprover-community/mathlib/blob/ec1b65487b40942baa21bf2dc3dd0a337e4f8f83/src/algebraic_topology/simplex_category.lean#L461</a></p>\n<p>along with the fact that tidy can't see past the definition of <code>unop</code>.</p>\n<p>Anyone have any thoughts on how to simplify this situation?</p>",
        "id": 231076523,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616181583
    },
    {
        "content": "<p>Sorry, I'm completely spent. I hope someone else can take a look. Otherwise, I'll see if I can help once I'm re-energized.</p>",
        "id": 231083846,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616185056
    },
    {
        "content": "<p>I'm trying but I'm not getting anywhere</p>",
        "id": 231084482,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616185333
    },
    {
        "content": "<p>Crazy idea: can we define <code>simplex_category</code> so that we NEVER use opposites?</p>",
        "id": 231084536,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616185359
    },
    {
        "content": "<p>I even tried going through this making <code>opposite</code> and friends semireducible, and it's not much better.</p>",
        "id": 231084634,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616185402
    },
    {
        "content": "<p>I tried making opposite reducible and the code just broke :-)</p>",
        "id": 231084772,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616185455
    },
    {
        "content": "<p>semireducible is better because you can still write things like <code>foo.unop</code></p>",
        "id": 231084820,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616185472
    },
    {
        "content": "<p>with things being semireducible I got down to </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">,</span>\n<span class=\"n\">_inst_1</span> <span class=\"o\">:</span> <span class=\"n\">category</span> <span class=\"n\">C</span><span class=\"o\">,</span>\n<span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span>\n<span class=\"n\">_inst_2</span> <span class=\"o\">:</span> <span class=\"n\">has_finite_limits</span> <span class=\"n\">C</span><span class=\"o\">,</span>\n<span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">simplex_category</span><span class=\"bp\">ᵒᵖ</span><span class=\"o\">,</span>\n<span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"n\">truncated</span> <span class=\"n\">C</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n<span class=\"n\">j_val</span> <span class=\"o\">:</span> <span class=\"n\">over</span> <span class=\"o\">(</span><span class=\"n\">unop</span> <span class=\"n\">X</span><span class=\"o\">),</span>\n<span class=\"n\">j_property</span> <span class=\"o\">:</span> <span class=\"n\">simplex_category.len</span> <span class=\"n\">j_val.left</span> <span class=\"bp\">≤</span> <span class=\"n\">n</span>\n<span class=\"bp\">⊢</span> <span class=\"o\">(</span><span class=\"n\">over.map</span> <span class=\"o\">(</span><span class=\"n\">simplex_category.hom.mk</span> <span class=\"n\">preorder_hom.id</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">obj</span> <span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">unop</span> <span class=\"o\">⟨</span><span class=\"n\">j_val</span><span class=\"o\">,</span> <span class=\"n\">j_property</span><span class=\"o\">⟩)</span> <span class=\"bp\">=</span> <span class=\"n\">j_val</span>\n</code></pre></div>",
        "id": 231085199,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616185649
    },
    {
        "content": "<p>but simp still gets stuck, i guess because of the various unops</p>",
        "id": 231085232,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616185673
    },
    {
        "content": "<p>is there a tactic that makes something reducible in the middle of a tactic block?</p>",
        "id": 231085443,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616185776
    },
    {
        "content": "<p>Right, this is as far as I can get too.</p>",
        "id": 231089459,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616187702
    },
    {
        "content": "<p>You can also do this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>      <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">simplex_category.hom.mk</span> <span class=\"n\">preorder_hom.id</span> <span class=\"bp\">=</span> <span class=\"n\">simplex_category.hom.id</span> <span class=\"o\">(</span><span class=\"n\">unop</span> <span class=\"n\">X</span><span class=\"o\">),</span>\n        <span class=\"n\">ext</span><span class=\"o\">,</span>\n        <span class=\"n\">refl</span><span class=\"o\">,</span>\n</code></pre></div>\n<p>but if you <code>rw h</code> it doesn't seem to help and then <code>simp</code> just unrewrites it again.</p>",
        "id": 231089606,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616187755
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> We are also using some cosimplicial objects in LTE... so defining <code>simplex_category</code> to <code>usual_simplex_category^op</code> will just shift the problems around, I fear.</p>",
        "id": 231120313,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616213866
    },
    {
        "content": "<p>Is this just a Kan extension? Taking a limit in this form looks familiar to me, I've come across a bunch of goals which look like this and I think they can all be unified nicely</p>",
        "id": 231121692,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1616215469
    },
    {
        "content": "<p>Yeah this is probably some sort of Kan extension.</p>",
        "id": 231122691,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616216544
    },
    {
        "content": "<p>And yeah good point about the cosimplicial objects.</p>",
        "id": 231122704,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616216565
    },
    {
        "content": "<p>I guess this is exactly the right(?) Kan extension along the inclusion of (truncated n)\\op into simplex_category\\op.</p>",
        "id": 231123674,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616217649
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"246273\">@Bhavik Mehta</span> I guess it could be useful to have Kan extensions in mathlib (everything is a Kan extension, after all...). The question is what assumptions should we add to ensure they exist? We could ask that the category has all limits, but this is too strong. In the coskeleton case, you only need finite limits because the categories in question all happen to be finite, but of course this won't be true for a general Kan extension.</p>",
        "id": 231147581,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616248186
    },
    {
        "content": "<p>I also realize now that this <code>trunc</code> gadget I defined is just some comma category associated to the inclusion of <code>truncated n</code> into <code>simplex_category</code>.</p>",
        "id": 231148441,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616249133
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/267928-condensed-mathematics/topic/Simplicial.20stuff/near/231147581\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"246273\">Bhavik Mehta</span> I guess it could be useful to have Kan extensions in mathlib (everything is a Kan extension, after all...). The question is what assumptions should we add to ensure they exist? We could ask that the category has all limits, but this is too strong. In the coskeleton case, you only need finite limits because the categories in question all happen to be finite, but of course this won't be true for a general Kan extension.</p>\n</blockquote>\n<p>I think the right thing to do is copy the is/has limit pattern, and have a class saying that certain Kan extensions do exist, but not all, so that we can talk about both local and global Kan extensions - and for the existence of global Kan extensions we should just be able to assume that the appropriate (co)limits over comma categories exist; so in your case you can show this by using equivalence to your finite index categories</p>",
        "id": 231149403,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1616250293
    },
    {
        "content": "<p>(In <a href=\"https://github.com/leanprover-community/mathlib/issues/5152\">#5152</a> I constructed the global left Kan extension given small colimits, but I certainly agree it's better to have additional restrictions)</p>",
        "id": 231149496,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1616250371
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> another reason to have Kan extensions is to \"define\" the big Witt vectors <span aria-label=\"rofl\" class=\"emoji emoji-1f923\" role=\"img\" title=\"rofl\">:rofl:</span> <br>\n<a href=\"https://ncatlab.org/nlab/show/Lambda-ring\">https://ncatlab.org/nlab/show/Lambda-ring</a></p>",
        "id": 231153362,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616254771
    },
    {
        "content": "<p>We already have examples of Lambda rings in mathlib! Just not <del>the</del> <em>a</em> definition of Lambda ring, so the examples aren't registered as such. But certain Dickson polynomials give an example.</p>",
        "id": 231154964,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616256572
    },
    {
        "content": "<p>By the way, (<span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span>) the alternating face map cochain complex attached to a cosimplicial object is now done. Just pointing this out, in case others had it on a todo list somewhere.</p>",
        "id": 231161216,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616263240
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> Is there still something that you want me to look at?</p>",
        "id": 231161518,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616263548
    },
    {
        "content": "<p>Or does the Kan machine solve your troubles?</p>",
        "id": 231161528,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616263559
    },
    {
        "content": "<p>I think building right Kan extensions is the way to go here. I'll try it out on Monday</p>",
        "id": 231161593,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616263605
    },
    {
        "content": "<p>Are we going full Dold-Kan? Or do we just need the construction of a complex from a cosimplicial object?</p>",
        "id": 231161646,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616263682
    },
    {
        "content": "<p>The latter. But it's already done.</p>",
        "id": 231161697,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616263710
    },
    {
        "content": "<p>Of course full Dold-Kan would be nice to have, independent from LTE.</p>",
        "id": 231161713,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616263726
    },
    {
        "content": "<p>And what sort of API do we need from hypercovers by profinite sets?</p>",
        "id": 231161831,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616263853
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/liquid/sect0005.html#prop:normedcompletion\">https://leanprover-community.github.io/liquid/sect0005.html#prop:normedcompletion</a></p>",
        "id": 231161950,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616263994
    },
    {
        "content": "<p>This is the \"end goal\" of the simplicial stuff</p>",
        "id": 231161955,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616264004
    },
    {
        "content": "<p>Patrick is working on the dependency <a href=\"https://leanprover-community.github.io/liquid/sect0005.html#prop:completeexact\">https://leanprover-community.github.io/liquid/sect0005.html#prop:completeexact</a> that is used in the proof.</p>",
        "id": 231162021,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616264047
    },
    {
        "content": "<p>Sounds good.</p>",
        "id": 231162057,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616264099
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> From that \"end goal\" we only need the second half</p>",
        "id": 231162062,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616264101
    },
    {
        "content": "<p>So this will use the <code>Vhat.lean</code> that you are already familiar with, I think</p>",
        "id": 231162092,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616264124
    },
    {
        "content": "<p>I'll make a mental todo, to split that lemma into two pieces in the blueprint</p>",
        "id": 231162115,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616264158
    },
    {
        "content": "<p>actually, let me just do it right now</p>",
        "id": 231162163,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616264171
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> due to the split, the \"end goal\" is now <a href=\"https://leanprover-community.github.io/liquid/sect0005.html#hypercover-exact\">https://leanprover-community.github.io/liquid/sect0005.html#hypercover-exact</a></p>",
        "id": 231163384,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616265433
    },
    {
        "content": "<p>Ok so the key point is to write a hypercovers of profinite sets as a cofiltered limit of finite sets. I think the key point for that is the equivalence between <code>Pro(Fintype)</code> and <code>Profinite</code>. What's the status of that <span class=\"user-mention\" data-user-id=\"246273\">@Bhavik Mehta</span> <span class=\"user-mention\" data-user-id=\"132603\">@Calle Sönne</span> ?</p>",
        "id": 231163591,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616265679
    },
    {
        "content": "<p>Do you need the full equivalence of categories or is the expression of a profinite set as a cofiltered limit of finite sets enough?</p>",
        "id": 231163668,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1616265767
    },
    {
        "content": "<p>I think you need a categorical equivalence (maybe a bit less, but still something close to that), since we're looking at simplicial profinite sets, meaning we certainly need some compatibility with morphisms</p>",
        "id": 231163768,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616265871
    },
    {
        "content": "<p>Oh, and I guess we will also need <code>alt_face_map_complex</code> to be functorial</p>",
        "id": 231163981,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616266075
    },
    {
        "content": "<p>hah! good point. Currently it isn't set up that way.</p>",
        "id": 231164057,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616266140
    },
    {
        "content": "<p>Well... there's nothing for simplicial objects anyway.</p>",
        "id": 231164078,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616266161
    },
    {
        "content": "<p>I grabbed stuff from <a href=\"https://github.com/leanprover-community/mathlib/tree/sset\">branch#sset</a>, and dualized it to make it work for cosimplicial stuff</p>",
        "id": 231164090,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616266183
    },
    {
        "content": "<p>Yep! this is good enough. I'm trying to add the last few bits from your code <span class=\"user-mention\" data-user-id=\"246273\">@Bhavik Mehta</span> regarding the adjunctions being (co)reflective when <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ι</mi></mrow><annotation encoding=\"application/x-tex\">\\iota</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">ι</span></span></span></span> is fully faithful</p>",
        "id": 231343267,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616431143
    },
    {
        "content": "<p>I think it would be ready to PR once that's done.</p>",
        "id": 231343296,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616431156
    },
    {
        "content": "<p>Cool! Let me know if there's anything I can do :)</p>",
        "id": 231343323,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1616431163
    },
    {
        "content": "<p>To be honest I think it's ready to PR without that extra stuff, and those bits can be another PR</p>",
        "id": 231343503,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1616431220
    },
    {
        "content": "<p>I'll try for a few mins, and if I get bogged down (which I probably will), I'll leave those for later.</p>",
        "id": 231343582,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616431249
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"246273\">@Bhavik Mehta</span> is there a lemma of the following form in mathlib?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">is_iso_π_initial</span> <span class=\"o\">{</span><span class=\"n\">J</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">small_category</span> <span class=\"n\">J</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₁</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">category.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">J</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"n\">is_initial</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">has_limits_of_shape</span> <span class=\"n\">J</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">J</span> <span class=\"bp\">⥤</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">is_iso</span> <span class=\"o\">(</span><span class=\"n\">limit.π</span> <span class=\"n\">F</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 231346653,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616432385
    },
    {
        "content": "<p>Nope and there absolutely should be</p>",
        "id": 231346707,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1616432402
    },
    {
        "content": "<p>It's similar to your <code>thingy2</code> :)</p>",
        "id": 231346752,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616432409
    },
    {
        "content": "<p>There's some related things in limits/shapes/initial</p>",
        "id": 231346789,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1616432422
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/issues/6820\">#6820</a><br>\nI compromised by only providing the initial/terminal defs, leaving the actual proof of (co)reflectivity to when we have lemmas  such as <code>is_iso_π_initial</code> as above (and a similar one for colimits)</p>",
        "id": 231351502,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616434135
    },
    {
        "content": "<p>An idea for a nice project: Prove that the ultrafilter monad is isomorphic to the right Kan extension of the inclusion <code>Fintype -&gt; Type</code> (over itself)</p>",
        "id": 231355306,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616435569
    },
    {
        "content": "<p>Once <a href=\"https://github.com/leanprover-community/mathlib/issues/6820\">#6820</a> goes through, here's the coskeleton functor (and the adjunction with the skeleton functor) <br>\n<a href=\"https://github.com/leanprover-community/mathlib/blob/6b69979cc2f4b136212e4f3196138e17bb735b1f/src/algebraic_topology/simplicial_object.lean#L153\">https://github.com/leanprover-community/mathlib/blob/6b69979cc2f4b136212e4f3196138e17bb735b1f/src/algebraic_topology/simplicial_object.lean#L153</a></p>",
        "id": 231377827,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616444244
    },
    {
        "content": "<p>Yeah codensity monads would be cool to have</p>",
        "id": 231406471,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1616460024
    },
    {
        "content": "<p>By the way, for the proof of 9.5, one only needs the version of 8.19 for Cech nerves of covers <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>S</mi><mn>0</mn></msub><mo>→</mo><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S_0\\to S</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span>, i.e. <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>S</mi><mn>1</mn></msub><mo>=</mo><msub><mi>S</mi><mn>0</mn></msub><msub><mo>×</mo><mi>S</mi></msub><msub><mi>S</mi><mn>0</mn></msub></mrow><annotation encoding=\"application/x-tex\">S_1=S_0\\times_S S_0</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\"><span class=\"mbin\">×</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05764em;\">S</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>S</mi><mn>2</mn></msub><mo>=</mo><msub><mi>S</mi><mn>0</mn></msub><msub><mo>×</mo><mi>S</mi></msub><msub><mi>S</mi><mn>0</mn></msub><msub><mo>×</mo><mi>S</mi></msub><msub><mi>S</mi><mn>0</mn></msub></mrow><annotation encoding=\"application/x-tex\">S_2=S_0\\times_S S_0\\times_S S_0</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\"><span class=\"mbin\">×</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05764em;\">S</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\"><span class=\"mbin\">×</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05764em;\">S</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> etc. Hypercovers would be great to have anyways, but they are not strictly necessary for the proof.</p>",
        "id": 231768625,
        "sender_full_name": "Peter Scholze",
        "timestamp": 1616664142
    },
    {
        "content": "<p>I haven't thought hard about how much this would simplify 8.19.</p>",
        "id": 231768798,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616664247
    },
    {
        "content": "<p>One reason I didn't think this through, is that I'm worried we'll end up with a hypercover that is canonically isomorphic to the Cech nerve</p>",
        "id": 231768839,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616664273
    },
    {
        "content": "<p>I think quite a bit: The statement is easier, and the reduction to finite sets is a lot easier</p>",
        "id": 231768856,
        "sender_full_name": "Peter Scholze",
        "timestamp": 1616664280
    },
    {
        "content": "<p>Ok, so it might be easier to transport stuff to the actual Cech nerve, instead of proving that our almost-Cech nerve is a hypercover</p>",
        "id": 231768919,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616664316
    },
    {
        "content": "<p>Well, as usual one can probably formalize \"is a Cech cover\"</p>",
        "id": 231769028,
        "sender_full_name": "Peter Scholze",
        "timestamp": 1616664367
    },
    {
        "content": "<p>and state 8.19 in that form (so the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>=</mo></mrow><annotation encoding=\"application/x-tex\">=</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.36687em;vertical-align:0em;\"></span><span class=\"mrel\">=</span></span></span></span>'s above are just statements that natural maps are isomorphisms)</p>",
        "id": 231769078,
        "sender_full_name": "Peter Scholze",
        "timestamp": 1616664406
    },
    {
        "content": "<p>Yep, I think \"is a Cech cover\" is a good suggestion</p>",
        "id": 231769115,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616664434
    },
    {
        "content": "<p>Oh, if we only need Cech nerves that indeed simplifies a lot!</p>",
        "id": 231803404,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616680312
    },
    {
        "content": "<p>Do we actually need this \"is Cech nerve\" prop for 8.19, or can we just state 8.19 as \"for any cover, the complex built out of its Cech nerve is exact...\"?</p>",
        "id": 231804293,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616680613
    },
    {
        "content": "<p>Johan knows better, but my sense is that the \"is Cech nerve\" version would be much easier to use</p>",
        "id": 231804450,
        "sender_full_name": "Peter Scholze",
        "timestamp": 1616680669
    },
    {
        "content": "<p>Basically, the simplicial diagram one writes down is not tautologically a Cech nerve</p>",
        "id": 231804574,
        "sender_full_name": "Peter Scholze",
        "timestamp": 1616680701
    },
    {
        "content": "<p>Ah ok</p>",
        "id": 231804633,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616680726
    },
    {
        "content": "<p>Then yes I agree with the \"is Cech nerve\" approach</p>",
        "id": 231804682,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616680746
    },
    {
        "content": "<p>Okay, I added a little gadget that will help with constructing the Cech nerve. It's the construction that freely adds a terminal object to a category.<br>\nSee the <code>with_term</code> branch of lean-liquid.</p>\n<p>The idea is that we can now take <code>fin n</code>as a discrete category, add a terminal object freely, then take a limit over <code>with_term (discrete (fin n))</code> to get the iterated fibered product needed for the construction.<br>\nThe universal property of <code>with_term</code> (which is also in this file) shows that this with_term cconstruction is functorial in the category, so it should be straaightforward to obtain the simplicial structure we need by mapping w.r.t. morphisms in <code>simplex_category</code>.</p>",
        "id": 231838429,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616691716
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/lean-liquid/blob/with_term/src/for_mathlib/with_term.lean\">https://github.com/leanprover-community/lean-liquid/blob/with_term/src/for_mathlib/with_term.lean</a></p>",
        "id": 231838530,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616691737
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> thanks! So far, I've been modeling the augmented cosimplicial complex as a functor from the simplex category + a separate augmentation map</p>",
        "id": 231844963,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616694095
    },
    {
        "content": "<p>Right, so I'm envisioning constructing the Cech nerve of an arbitrary morphism in a category with finite limits</p>",
        "id": 231845142,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616694156
    },
    {
        "content": "<p>For the cosimplicial lattice, I constructed it by hand, because I don't think that <code>PolyhedralLattice</code> has finite colimits.</p>",
        "id": 231845483,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616694294
    },
    {
        "content": "<p>It's just that for special morphisms you can make it work</p>",
        "id": 231845522,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616694309
    },
    {
        "content": "<p>Hmm ok</p>",
        "id": 231846213,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616694563
    },
    {
        "content": "<p>I can make it more explicit by saying only the diagrams involved have limits</p>",
        "id": 231846262,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616694592
    },
    {
        "content": "<p>Thats similar to what I did with <code>Ran</code> (as suggested by <span class=\"user-mention\" data-user-id=\"246273\">@Bhavik Mehta</span> )</p>",
        "id": 231846387,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616694628
    },
    {
        "content": "<p>But still, there are morphisms in <code>PolyhedralLattice</code> for which you can't form the Cech conerve</p>",
        "id": 231846507,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616694674
    },
    {
        "content": "<p>Hmm, actually maybe cokernels do exist... but something like multiplication by n&gt;0 on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\Z</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Z</span></span></span></span></span> will have trivial cokernel, because all the objects are free.</p>",
        "id": 231847630,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616695073
    },
    {
        "content": "<p>I can still make it work, by saying specific diagrams have (co)limits</p>",
        "id": 231847837,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616695147
    },
    {
        "content": "<p>ooh, I misunderstood. For a moment I thought that you meant specific \"shapes\", but you mean only the diagrams involved in the one specific Cech nerve?</p>",
        "id": 231848062,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616695218
    },
    {
        "content": "<p>Yeah, I guess that can work</p>",
        "id": 231848079,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616695224
    },
    {
        "content": "<p>I was thinking of shapes, but we can still talk about specific diagrams if shapes dont work :)</p>",
        "id": 231848175,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616695248
    },
    {
        "content": "<p>I'll sketch up some code now.</p>",
        "id": 231848195,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616695252
    },
    {
        "content": "<p>I tried starting on the Cech nerve construction in the <code>cech</code> branch of lean-liquid.<br>\nI'm running into the following error</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"mi\">22</span><span class=\"o\">:</span><span class=\"mi\">5</span><span class=\"o\">:</span> <span class=\"n\">kernel</span> <span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">type</span> <span class=\"n\">check</span> <span class=\"n\">declaration</span> <span class=\"bp\">'</span><span class=\"n\">Cech.map_cone'</span> <span class=\"n\">this</span> <span class=\"n\">is</span> <span class=\"n\">usually</span> <span class=\"n\">due</span> <span class=\"n\">to</span> <span class=\"n\">a</span> <span class=\"n\">buggy</span> <span class=\"n\">tactic</span> <span class=\"n\">or</span> <span class=\"n\">a</span> <span class=\"n\">bug</span> <span class=\"k\">in</span> <span class=\"n\">the</span> <span class=\"n\">builtin</span> <span class=\"n\">elaborator</span>\n<span class=\"n\">elaborated</span> <span class=\"n\">type</span><span class=\"o\">:</span>\n  <span class=\"bp\">Π</span> <span class=\"o\">[</span><span class=\"n\">_inst_1</span> <span class=\"o\">:</span> <span class=\"n\">category</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">C_1</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">simplex_category</span><span class=\"bp\">ᵒᵖ</span><span class=\"o\">},</span>\n    <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">⟶</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">limits.cone</span> <span class=\"o\">(</span><span class=\"n\">Cech_diagram</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">opposite.unop</span> <span class=\"n\">a</span><span class=\"o\">))</span> <span class=\"bp\">→</span> <span class=\"n\">limits.cone</span> <span class=\"o\">(</span><span class=\"n\">Cech_diagram</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">opposite.unop</span> <span class=\"n\">b</span><span class=\"o\">))</span>\n<span class=\"n\">elaborated</span> <span class=\"n\">value</span><span class=\"o\">:</span>\n  <span class=\"bp\">λ</span> <span class=\"o\">[</span><span class=\"n\">_inst_1</span> <span class=\"o\">:</span> <span class=\"n\">category</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">C_1</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">simplex_category</span><span class=\"bp\">ᵒᵖ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">⟶</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">C_1</span> <span class=\"o\">:</span> <span class=\"n\">limits.cone</span> <span class=\"o\">(</span><span class=\"n\">Cech_diagram</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">opposite.unop</span> <span class=\"n\">a</span><span class=\"o\">))),</span> <span class=\"gr\">sorry</span>\n<span class=\"n\">nested</span> <span class=\"n\">exception</span> <span class=\"n\">message</span><span class=\"o\">:</span>\n<span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">add</span> <span class=\"n\">declaration</span> <span class=\"n\">to</span> <span class=\"n\">environment</span><span class=\"o\">,</span> <span class=\"n\">it</span> <span class=\"n\">contains</span> <span class=\"kn\">local</span> <span class=\"kd\">constants</span>\n</code></pre></div>\n<p>on the following line:<br>\n<a href=\"https://github.com/leanprover-community/lean-liquid/blob/0590ca0c74e0cb60530da104ee75784c941d4fd4/src/for_mathlib/cech.lean#L22\">https://github.com/leanprover-community/lean-liquid/blob/0590ca0c74e0cb60530da104ee75784c941d4fd4/src/for_mathlib/cech.lean#L22</a></p>\n<p>I've tried diagnosing this issue with no luck. <br>\nIf I try to start building the definition of this cone anyway, I get errors like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"mi\">22</span><span class=\"o\">:</span><span class=\"mi\">5</span><span class=\"o\">:</span> <span class=\"n\">unknown</span> <span class=\"kn\">local</span> <span class=\"kd\">constant</span><span class=\"o\">:</span> <span class=\"n\">_ffresh.0</span>\n</code></pre></div>\n<p>I did a lot of pattern matching in the file <code>for_mathlib/fan.lean</code> in this branch. Could it be some side effect of this?</p>",
        "id": 231909561,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616729107
    },
    {
        "content": "<p>Is there some <em>data</em> higher up in the file that is <code>sorry</code>d?</p>",
        "id": 231916427,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616735656
    },
    {
        "content": "<p>I'm just guessing...</p>",
        "id": 231916431,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616735666
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> Nope, no sorry'd data, as far as I can tell.</p>",
        "id": 231959487,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616763656
    },
    {
        "content": "<p>Well, changing the type to </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Cech.map_cone</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">simplex_category.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"bp\">ᵒᵖ</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">⟶</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">limits.cone</span> <span class=\"o\">(</span><span class=\"n\">Cech_diagram</span> <span class=\"n\">f</span> <span class=\"n\">a.unop</span><span class=\"o\">)),</span> <span class=\"n\">limits.cone</span> <span class=\"o\">(</span><span class=\"n\">Cech_diagram</span> <span class=\"n\">f</span> <span class=\"n\">b.unop</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">h</span> <span class=\"n\">C</span><span class=\"o\">,</span> <span class=\"bp\">...</span>\n</code></pre></div>",
        "id": 231960409,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616764037
    },
    {
        "content": "<p>seems to fix it.... What?</p>",
        "id": 231960425,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616764045
    },
    {
        "content": "<p>I was just looking at this. I totally agree it's bizarre :-)</p>",
        "id": 231961387,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616764434
    },
    {
        "content": "<p>It doesn't seem to be a universe issue <em>shrug</em></p>",
        "id": 231961476,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616764456
    },
    {
        "content": "<p>Yeah, I fixed all the universes last night.</p>",
        "id": 231961496,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616764466
    },
    {
        "content": "<p>I think it could be an actual bug</p>",
        "id": 231961501,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616764472
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- bad</span>\n<span class=\"kd\">def</span> <span class=\"n\">Cech.map_cone</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">simplex_category.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"bp\">ᵒᵖ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">⟶</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">limits.cone</span> <span class=\"o\">(</span><span class=\"n\">Cech_diagram</span> <span class=\"n\">f</span> <span class=\"n\">a.unop</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">limits.cone</span> <span class=\"o\">(</span><span class=\"n\">Cech_diagram</span> <span class=\"n\">f</span> <span class=\"n\">b.unop</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"c1\">-- good</span>\n<span class=\"kd\">def</span> <span class=\"n\">Cech.map_cone</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">simplex_category.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"bp\">ᵒᵖ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">⟶</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">limits.cone</span> <span class=\"o\">(</span><span class=\"n\">Cech_diagram</span> <span class=\"n\">f</span> <span class=\"n\">a.unop</span><span class=\"o\">))</span> <span class=\"bp\">→</span> <span class=\"n\">limits.cone</span> <span class=\"o\">(</span><span class=\"n\">Cech_diagram</span> <span class=\"n\">f</span> <span class=\"n\">b.unop</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 231961898,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616764637
    },
    {
        "content": "<p>Well, here's the Cech nerve: <br>\n<a href=\"https://github.com/leanprover-community/lean-liquid/blob/44ab8925dc1d44c584204941e681dd8741267743/src/for_mathlib/cech.lean#L35\">https://github.com/leanprover-community/lean-liquid/blob/44ab8925dc1d44c584204941e681dd8741267743/src/for_mathlib/cech.lean#L35</a></p>",
        "id": 231963147,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616765120
    },
    {
        "content": "<p>Still more to do: functoriality in <code>f</code>,  relax the <code>has_limits</code> condition, etc.</p>",
        "id": 231963191,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616765137
    },
    {
        "content": "<p>Oh! I think it's just the repetition of the variable <code>C</code>!</p>",
        "id": 231963461,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616765230
    },
    {
        "content": "<p>AAH!</p>",
        "id": 231963526,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616765253
    },
    {
        "content": "<p>I've never seen variable name repetition result in that error though!</p>",
        "id": 231963641,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616765292
    },
    {
        "content": "<p>Fixed:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">abbreviation</span> <span class=\"n\">Cech.map_cone</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">simplex_category.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"bp\">ᵒᵖ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">⟶</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">CC</span> <span class=\"o\">:</span> <span class=\"n\">limits.cone</span> <span class=\"o\">(</span><span class=\"n\">Cech.diagram</span> <span class=\"n\">f</span> <span class=\"n\">a.unop</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">limits.cone</span> <span class=\"o\">(</span><span class=\"n\">Cech.diagram</span> <span class=\"n\">f</span> <span class=\"n\">b.unop</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">fan.map_cone</span> <span class=\"o\">(</span><span class=\"n\">ufin.map</span> <span class=\"n\">h.unop.to_preorder_hom</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">CC</span>\n</code></pre></div>",
        "id": 231963642,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616765292
    },
    {
        "content": "<p>Snarky bug!</p>",
        "id": 231963683,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616765308
    },
    {
        "content": "<p>Do we have the <del>type</del> category of augmented simplicial objects somewhere?</p>",
        "id": 231966171,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616766203
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> Nope, I don't think so</p>",
        "id": 231966415,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616766291
    },
    {
        "content": "<p>I would like to state the fact that the Cech nerve, considered as an augmented simplicial object, is right adjoint to the functor sending an augmented simplicial object <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>X</mi><mo>∙</mo></msub><mo>→</mo><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">X_\\bullet \\to B</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.16111499999999998em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∙</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span> to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>X</mi><mn>0</mn></msub><mo>→</mo><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">X_0 \\to B</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span>.</p>",
        "id": 231966501,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616766322
    },
    {
        "content": "<p>So the other category will be an arrow category, right?</p>",
        "id": 231966728,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616766394
    },
    {
        "content": "<p>Okay, I'll just define it then. Everyone cool with the following defn?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">augmented_simplicial_object</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">simplicial_object</span> <span class=\"n\">C</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"n\">_</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span> <span class=\"bp\">⟶</span> <span class=\"n\">B</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 231966737,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616766398
    },
    {
        "content": "<p>Are you using <code>comma</code> for that?</p>",
        "id": 231966739,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616766399
    },
    {
        "content": "<p>I'm using <code>over B</code></p>",
        "id": 231966751,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616766405
    },
    {
        "content": "<p>Oh, but I guess I should use <code>arrow</code> or something</p>",
        "id": 231966778,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616766420
    },
    {
        "content": "<p>So I guess you could also use <code>comma</code> to define <code>augemented_bla</code></p>",
        "id": 231966779,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616766421
    },
    {
        "content": "<p>Yeah true.</p>",
        "id": 231966812,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616766435
    },
    {
        "content": "<p>If you have the functor that sends <code>X : simplicial_object</code> to <code>X_[0]</code></p>",
        "id": 231966843,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616766451
    },
    {
        "content": "<p>Once <a href=\"https://github.com/leanprover-community/mathlib/issues/6830\">#6830</a> goes through, we could use structured arrows :)</p>",
        "id": 231966859,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616766457
    },
    {
        "content": "<p>I think this is reasonable:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">simplicial_object.over</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">simplicial_object</span> <span class=\"n\">C</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"n\">_</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span> <span class=\"bp\">⟶</span> <span class=\"n\">B</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 231967050,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616766511
    },
    {
        "content": "<p>But yes I should use a comma category for this.</p>",
        "id": 231967105,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616766537
    },
    {
        "content": "<p>Although I don't recall whether we have that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi><mo>↦</mo><msub><mi>X</mi><mn>0</mn></msub></mrow><annotation encoding=\"application/x-tex\">X \\mapsto X_0</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69433em;vertical-align:-0.011em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">↦</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> is a functor...</p>",
        "id": 231967144,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616766559
    },
    {
        "content": "<p>Shouldn't there be a condition that all induced maps <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>X</mi><mi>i</mi></msub><mo>→</mo><msub><mi>X</mi><mn>0</mn></msub><mo>→</mo><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">X_i\\to X_0\\to B</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span> agree?</p>",
        "id": 231967178,
        "sender_full_name": "Peter Scholze",
        "timestamp": 1616766575
    },
    {
        "content": "<p>Oh yeah that's right</p>",
        "id": 231967355,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616766624
    },
    {
        "content": "<p>It's really a morphism from X to the constant simplicial object</p>",
        "id": 231967387,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616766634
    },
    {
        "content": "<p>Right</p>",
        "id": 231967406,
        "sender_full_name": "Peter Scholze",
        "timestamp": 1616766643
    },
    {
        "content": "<p>There are many variants of this simplex category; for example, allowing possibly empty finite totally ordered sets, one gets augmented simplicial objects. There's a further variant relevant for split augmented simplicial objects</p>",
        "id": 231967609,
        "sender_full_name": "Peter Scholze",
        "timestamp": 1616766722
    },
    {
        "content": "<p>How much extra work would it be to set up such variants?</p>",
        "id": 231967658,
        "sender_full_name": "Peter Scholze",
        "timestamp": 1616766738
    },
    {
        "content": "<p>Even easier: </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[derive category]</span>\n<span class=\"kd\">def</span> <span class=\"n\">simplicial_object.over</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">over</span> <span class=\"o\">((</span><span class=\"n\">category_theory.functor.const</span> <span class=\"n\">simplex_category.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"bp\">ᵒᵖ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">obj</span> <span class=\"n\">B</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 231967723,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616766773
    },
    {
        "content": "<p>Yeah, I'm used to thinking of these as <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi><mo>=</mo><msub><mi>X</mi><mrow><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding=\"application/x-tex\">B = X_{-1}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.891661em;vertical-align:-0.208331em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.301108em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.208331em;\"><span></span></span></span></span></span></span></span></span></span></p>",
        "id": 231968145,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616766929
    },
    {
        "content": "<p>I guess if we could apply this <code>with_term</code> construction to <code>simplex_category\\op</code> and look at functors from that as well.</p>",
        "id": 231968277,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616766980
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"369530\">Peter Scholze</span> <a href=\"#narrow/stream/267928-condensed-mathematics/topic/Simplicial.20stuff/near/231967658\">said</a>:</p>\n<blockquote>\n<p>How much extra work would it be to set up such variants?</p>\n</blockquote>\n<p>It depends on whether there is a common abstraction</p>",
        "id": 231968339,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616767008
    },
    {
        "content": "<p>It's all diagram categories for certain simple combinatorial test categories</p>",
        "id": 231968395,
        "sender_full_name": "Peter Scholze",
        "timestamp": 1616767033
    },
    {
        "content": "<p>If there isn't then it's usually just \"copy-paste the file, make some adjustments, define a compatibility functor\"</p>",
        "id": 231968399,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616767034
    },
    {
        "content": "<p>For the <code>with_term</code>gadget, I just came up with it yesterday so it's not battle tested.</p>",
        "id": 231968407,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616767038
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"369530\">@Peter Scholze</span> I've heard of test categories a long time ago. But we certainly don't have them in mathlib</p>",
        "id": 231968450,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616767064
    },
    {
        "content": "<p>What is a test category?</p>",
        "id": 231968526,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616767087
    },
    {
        "content": "<p>Test category is just a name</p>",
        "id": 231968541,
        "sender_full_name": "Peter Scholze",
        "timestamp": 1616767091
    },
    {
        "content": "<p>Maybe I should have said index category</p>",
        "id": 231968588,
        "sender_full_name": "Peter Scholze",
        "timestamp": 1616767108
    },
    {
        "content": "<p>Ah ok.</p>",
        "id": 231968623,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616767123
    },
    {
        "content": "<p>e.g., the simplex category, the \"semisimplex category\", the augmented simplex category, etc.</p>",
        "id": 231968632,
        "sender_full_name": "Peter Scholze",
        "timestamp": 1616767126
    },
    {
        "content": "<p><a href=\"https://ncatlab.org/nlab/show/test+category\">https://ncatlab.org/nlab/show/test+category</a></p>",
        "id": 231968664,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616767144
    },
    {
        "content": "<p>I thought you meant actual test categories</p>",
        "id": 231968694,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616767155
    },
    {
        "content": "<p>they seem relevant</p>",
        "id": 231968699,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616767158
    },
    {
        "content": "<p>We're now discussing some stuff related to 2-categories and pseudofunctors. I guess working with such test categories would be easier if we could discuss pseudofunctors with values in CAT</p>",
        "id": 231968717,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616767166
    },
    {
        "content": "<p>generalizing simiplicial and cubical, etc...</p>",
        "id": 231968727,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616767170
    },
    {
        "content": "<p>yeah sorry I didn't mean it in that technical sense</p>",
        "id": 231968781,
        "sender_full_name": "Peter Scholze",
        "timestamp": 1616767193
    },
    {
        "content": "<p>There's nothing 2-categorical going on here, I think; we just have a couple of interesting combinatorial categories, and are interested in the functor categories from there</p>",
        "id": 231969003,
        "sender_full_name": "Peter Scholze",
        "timestamp": 1616767250
    },
    {
        "content": "<p>ok, it still seems related/relevant</p>",
        "id": 231969012,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616767252
    },
    {
        "content": "<p>like simplicial objects, semisimplicial objects, etc.</p>",
        "id": 231969035,
        "sender_full_name": "Peter Scholze",
        "timestamp": 1616767261
    },
    {
        "content": "<p>it is related, but points in a direction that's really relevant right now</p>",
        "id": 231969089,
        "sender_full_name": "Peter Scholze",
        "timestamp": 1616767274
    },
    {
        "content": "<p>Oh, what I mean is, for example, the construction <code>a \\mapsto (over a)</code> is really a pseudofunctor</p>",
        "id": 231969185,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616767313
    },
    {
        "content": "<p>So I just wondered whether one can set up the basics on say simplicial objects in such a way that setting up semisimplicial objects, augmented simplicial objects, split augmented simplicial objects, etc., can be done without copy-pasting everything</p>",
        "id": 231969275,
        "sender_full_name": "Peter Scholze",
        "timestamp": 1616767331
    },
    {
        "content": "<p>hmm OK, but I think that construction is not relevant for what I am trying to say</p>",
        "id": 231969315,
        "sender_full_name": "Peter Scholze",
        "timestamp": 1616767349
    },
    {
        "content": "<p>(I would formalize augmented simplicial objects differently)</p>",
        "id": 231969334,
        "sender_full_name": "Peter Scholze",
        "timestamp": 1616767357
    },
    {
        "content": "<p>How? Don't you want to add an initial object to simplex_category?</p>",
        "id": 231969404,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616767382
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"369530\">Peter Scholze</span> <a href=\"#narrow/stream/267928-condensed-mathematics/topic/Simplicial.20stuff/near/231969275\">said</a>:</p>\n<blockquote>\n<p>So I just wondered whether one can set up the basics on say simplicial objects in such a way that setting up semisimplicial objects, augmented simplicial objects, split augmented simplicial objects, etc., can be done without copy-pasting everything</p>\n</blockquote>\n<p>I think that avoiding copy-pasting would certainly be useful. But how do you characterize the index categories?</p>",
        "id": 231969601,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616767443
    },
    {
        "content": "<p>I guess I'm envisioning taking <code>simplex_category</code>, and considering something like <code>with_initial simplex_category</code></p>",
        "id": 231969752,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616767495
    },
    {
        "content": "<p>I don't know! In principle one could just allow all index categories for some basic stuff?</p>",
        "id": 231969765,
        "sender_full_name": "Peter Scholze",
        "timestamp": 1616767500
    },
    {
        "content": "<p>augmented simplicial objects are indexed by the category of possibly empty finite totally ordered sets</p>",
        "id": 231969850,
        "sender_full_name": "Peter Scholze",
        "timestamp": 1616767529
    },
    {
        "content": "<p>Right, so we could take e.g. the category of <code>fin n</code> with <code>n</code> possibly 0 and nonincreasing maps, but then we end up with more <code>n-1+1 = n</code> issues when we want to relate this to the usual simplex category <span aria-label=\"sad\" class=\"emoji emoji-2639\" role=\"img\" title=\"sad\">:sad:</span></p>",
        "id": 231970007,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616767577
    },
    {
        "content": "<p>I guess this is formally adding an initial object, yes; but I'd prefer a direct description over the one given by its relation to the simplex category (which I'd rather have as a proposition)</p>",
        "id": 231970016,
        "sender_full_name": "Peter Scholze",
        "timestamp": 1616767580
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> I agree that <code>with_initial</code> might not scale.</p>",
        "id": 231970084,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616767613
    },
    {
        "content": "<p>Just like we switched to <code>group_with_zero</code> instead of <code>with_zero G</code> for the target of valuations</p>",
        "id": 231970131,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616767632
    },
    {
        "content": "<p>If we can actually characterize useful properties of these index categories, then <code>simplex_category</code> can be swapped out for <code>semisimplex_category</code> or <code>NonemptyFinLinOrd</code> or <code>FinLinOrd</code> or whatever.</p>",
        "id": 231970279,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616767684
    },
    {
        "content": "<p>But <code>(with_term J) \\func C</code>is the category of augmented  <code>J \\func C</code> for arbitrary <code>J</code></p>",
        "id": 231970298,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616767689
    },
    {
        "content": "<p>Maybe you want <code>F : J \\functor J'</code> and <code>(hF : adds_term F)</code></p>",
        "id": 231970410,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616767732
    },
    {
        "content": "<p>Ah ok, maybe that's the way to go</p>",
        "id": 231970450,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616767752
    },
    {
        "content": "<p>Because certainly 3 months from now someone will come along with a functor from <code>FinLinOrd</code> and be very disappointed that it isn't an augmented simplicial set.</p>",
        "id": 231970498,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616767770
    },
    {
        "content": "<p>Hmm, true. Somehow \"augmented simplicial objects\" are for me slightly more primitive than \"augmented\" \"simplicial sets\", but it's a borderline case.</p>",
        "id": 231970507,
        "sender_full_name": "Peter Scholze",
        "timestamp": 1616767775
    },
    {
        "content": "<p>What would <code>adds_term</code> even look like?</p>",
        "id": 231970612,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616767816
    },
    {
        "content": "<p>Of course you could ask for an equivalence of categories with <code>with_term J</code>...</p>",
        "id": 231970659,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616767834
    },
    {
        "content": "<p>(<span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> going back to the issue of augemented simplicial objects: Is this correct? <br>\n<a href=\"https://github.com/leanprover-community/lean-liquid/blob/6f0f94d46027dac3e916180d483f893550af6096/src/simplicial/alternating_face_map.lean#L18\">https://github.com/leanprover-community/lean-liquid/blob/6f0f94d46027dac3e916180d483f893550af6096/src/simplicial/alternating_face_map.lean#L18</a></p>",
        "id": 231970805,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616767893
    },
    {
        "content": "<p>That's what I was trying to model with the above structure</p>",
        "id": 231970863,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616767916
    },
    {
        "content": "<p>Well, that was a very lame attempt at assuming an augmented cosimplicial gadget</p>",
        "id": 231971003,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616767953
    },
    {
        "content": "<p>But there shouldn't be a maths problem? Right?</p>",
        "id": 231971061,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616767979
    },
    {
        "content": "<p>Oh I see you have these <code>hf</code> conditions on lemmas everywhere.</p>",
        "id": 231971769,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616768245
    },
    {
        "content": "<p>Well, the <code>over</code> approach seems to be somewhat reasonable for now:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">open_locale</span> <span class=\"n\">simplicial</span>\n\n<span class=\"kd\">@[derive category, simp]</span>\n<span class=\"kn\">protected</span> <span class=\"kd\">def</span> <span class=\"n\">over</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">over</span> <span class=\"o\">((</span><span class=\"n\">category_theory.functor.const</span> <span class=\"n\">simplex_category.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"bp\">ᵒᵖ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">obj</span> <span class=\"n\">B</span><span class=\"o\">)</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">over</span>\n\n<span class=\"kd\">@[simps]</span>\n<span class=\"kd\">def</span> <span class=\"n\">forget</span> <span class=\"o\">:</span> <span class=\"n\">simplicial_object.over</span> <span class=\"n\">B</span> <span class=\"bp\">⥤</span> <span class=\"n\">simplicial_object</span> <span class=\"n\">C</span> <span class=\"o\">:=</span> <span class=\"n\">over.forget</span> <span class=\"n\">_</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">to_hom</span> <span class=\"o\">:</span> <span class=\"n\">simplicial_object.over</span> <span class=\"n\">B</span> <span class=\"bp\">⥤</span> <span class=\"n\">category_theory.over</span> <span class=\"n\">B</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">obj</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"n\">over.mk</span> <span class=\"o\">(</span><span class=\"n\">X.hom.app</span> <span class=\"o\">(</span><span class=\"n\">opposite.op</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">])),</span>\n  <span class=\"n\">map</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">over.hom_mk</span> <span class=\"o\">(</span><span class=\"n\">f.left.app</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">over</span>\n</code></pre></div>",
        "id": 231972937,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616768723
    },
    {
        "content": "<p>Okay, I added a lot more stuff to the cech file, but it still requires a LOT of cleanup and it still has a few sorries. Anyone who is interested should please feel free to push to this branch!</p>",
        "id": 231993188,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616775815
    },
    {
        "content": "<p>TBH, I'm not happy about this construction :-/ it feels clunky</p>",
        "id": 231997820,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616777454
    },
    {
        "content": "<p>I would like to try what Peter suggested and just defining the augmented simplex category (as the category structure on nat, where n now corresponds to (fin n)), but I'm again running into issues with <code>simplex_category</code> being irreducible, etc.</p>",
        "id": 231997925,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616777492
    },
    {
        "content": "<p>I mean, this works:</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>long</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebraic_topology.simplex_category</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">simplex_category</span>\n\n<span class=\"kn\">local</span> <span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">semireducible</span><span class=\"o\">]</span> <span class=\"n\">simplex_category</span> <span class=\"n\">simplex_category.hom</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">category_theory</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">augmented</span> <span class=\"o\">:=</span> <span class=\"n\">ulift</span> <span class=\"n\">ℕ</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">augmented</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">small_category</span> <span class=\"n\">augmented</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">hom</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">ulift</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">a.down</span> <span class=\"bp\">→ₘ</span> <span class=\"n\">fin</span> <span class=\"n\">b.down</span><span class=\"o\">),</span>\n  <span class=\"n\">id</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">ulift.up</span> <span class=\"n\">preorder_hom.id</span><span class=\"o\">,</span>\n  <span class=\"n\">comp</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">ulift.up</span> <span class=\"o\">(</span><span class=\"n\">g.down.comp</span> <span class=\"n\">f.down</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">incl</span> <span class=\"o\">:</span> <span class=\"n\">simplex_category</span> <span class=\"bp\">⥤</span> <span class=\"n\">augmented</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">obj</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n    <span class=\"k\">match</span> <span class=\"n\">x</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">ulift.up</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">ulift.up</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n    <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">map</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n    <span class=\"k\">match</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">ulift.up</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">ulift.up</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">ulift.up</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">ulift.up</span> <span class=\"n\">f</span>\n    <span class=\"kd\">end</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">augmented</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">simplex_category</span>\n</code></pre></div>\n</div></div>\n<p>But I'm not a fan of the line</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">local</span> <span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">semireducible</span><span class=\"o\">]</span> <span class=\"n\">simplex_category</span> <span class=\"n\">simplex_category.hom</span>\n</code></pre></div>",
        "id": 231999228,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616777997
    },
    {
        "content": "<p>There are other annoyances as well :-/<br>\nE.g. if we want to write <code>X _[-1]</code> for the target of the augmentation, we would need to deal with int (or maybe the subtype of integers which are at least -1), and its relationship with nat.</p>",
        "id": 232002608,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616779291
    },
    {
        "content": "<p>I guess the other option is to write <code>X _[0]</code> for the target of the automation.</p>",
        "id": 232002811,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616779377
    },
    {
        "content": "<p>We would still need to deal with things like <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>↦</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo>↦</mo><mo stretchy=\"false\">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">n \\mapsto n+1 \\mapsto (n+1)-1</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.522em;vertical-align:-0.011em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">↦</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.65544em;vertical-align:-0.011em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">↦</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span></p>",
        "id": 232002861,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616779402
    },
    {
        "content": "<p>And so there will be an <code>n -&gt; n+1</code> shift, when moving between augmented and non-augmented</p>",
        "id": 232002872,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616779410
    },
    {
        "content": "<p>Where will the <code>n-1</code> show up? Maybe we will just always do <code>cases n</code>, to split into <code>0</code> and <code>n+1</code>.</p>",
        "id": 232003081,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616779492
    },
    {
        "content": "<p>Yeah, here's what I had in mind: say that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span> is augmented, and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">Y</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span></span></span></span> is the nonaugmented thing constructed by forgetting the augmentation. We would have: <code>Y _[n] = X _[n+1]</code>. I guess this is ok.</p>",
        "id": 232003230,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616779546
    },
    {
        "content": "<p>But what if we have a simplicial object <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span>, an object <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span>, and a morphism froom <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span> to the constant simplicial object <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span>. If we want to turn that into an augmented simplicial object <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span>, we would have <code>A _[n-1] = X _[n]</code> for positive <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>.</p>",
        "id": 232003521,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616779641
    },
    {
        "content": "<p>Vice versa, if you have <code>Y _[0] -&gt; Z</code>, then you can make an augmented thing using the equation compiler.</p>",
        "id": 232003555,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616779652
    },
    {
        "content": "<p>Oh yeah that should be okay.</p>",
        "id": 232003632,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616779683
    },
    {
        "content": "<p>So you define <code>A _[0] := B</code> and <code>A _[n+1] := X _[n]</code></p>",
        "id": 232003724,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616779723
    },
    {
        "content": "<p>And, by the nature of the situation, whenever you want to move between the two, you will always need to know whether <code>n = 0</code> or <code>n = _ + 1</code></p>",
        "id": 232003831,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616779771
    },
    {
        "content": "<p>So you can always do <code>cases n</code></p>",
        "id": 232003849,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616779777
    },
    {
        "content": "<p>I'm optimistic that we can get away with it here</p>",
        "id": 232003882,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616779791
    },
    {
        "content": "<p>But I might be naive again <span aria-label=\"see no evil\" class=\"emoji emoji-1f648\" role=\"img\" title=\"see no evil\">:see_no_evil:</span></p>",
        "id": 232003957,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616779805
    },
    {
        "content": "<p>Now another issue: We have <code>truncated n</code> in the nonaugmented case as the subtype <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">{</mo><mi>i</mi><mi mathvariant=\"normal\">∣</mi><mi>i</mi><mo>≤</mo><mi>n</mi><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">\\{ i | i \\le n\\}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord mathnormal\">i</span><span class=\"mord\">∣</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">}</span></span></span></span></p>",
        "id": 232003974,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616779811
    },
    {
        "content": "<p>Now we would want to define an augmented truncated n as <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">{</mo><mi>i</mi><mi mathvariant=\"normal\">∣</mi><mi>i</mi><mo>≤</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">\\{i | i \\le n+1\\}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord mathnormal\">i</span><span class=\"mord\">∣</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">}</span></span></span></span>.</p>",
        "id": 232004059,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616779841
    },
    {
        "content": "<p>And how would we forget the augmentation?</p>",
        "id": 232004116,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616779864
    },
    {
        "content": "<p>I guess what I'm going for is this: If we take <code>Ran</code> with respect to the opposite of the inclusion <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">{</mo><mo>−</mo><mn>1</mn><mo separator=\"true\">,</mo><mn>0</mn><mo stretchy=\"false\">}</mo><mo>→</mo><mo stretchy=\"false\">{</mo><mo>−</mo><mn>1</mn><mo separator=\"true\">,</mo><mn>0</mn><mo separator=\"true\">,</mo><mn>1</mn><mo separator=\"true\">,</mo><mo>…</mo><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">\\{-1,0\\} \\to \\{-1,0,1,\\ldots\\}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">−</span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">0</span><span class=\"mclose\">}</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">−</span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\">…</span><span class=\"mclose\">}</span></span></span></span>, we get the Cech nerve \"for free\"</p>",
        "id": 232004233,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616779916
    },
    {
        "content": "<p>So I want to, in some sense, identify 0-truncated augmented simplicial objects with the arrow category</p>",
        "id": 232004371,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616779958
    },
    {
        "content": "<p>Can you do a characteristic predicate for the \"arrow category = 0-truncated = whatever\"?</p>",
        "id": 232004603,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616780035
    },
    {
        "content": "<p>I'm sorry, this sounds like a lot of new stuff <span aria-label=\"surprise\" class=\"emoji emoji-1f62e\" role=\"img\" title=\"surprise\">:surprise:</span></p>",
        "id": 232004734,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616780063
    },
    {
        "content": "<p>Yeah :-/</p>",
        "id": 232004758,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616780072
    },
    {
        "content": "<p>(and it's all definitions...)</p>",
        "id": 232005017,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616780170
    },
    {
        "content": "<p>On the other hand, if we use <code>with_trunc (simplex_category.truncated n)\\op</code>, and map with respect to <code>(simplex_category.truncated n)\\op \\func (simplex_category)\\op</code>, we get <code>with_trunc (simplex_category.truncated n)\\op \\func with_trunc (simplex_category)\\op</code>.</p>",
        "id": 232005322,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616780301
    },
    {
        "content": "<p>(sorry, replace <code>with_trunc</code> with <code>with_term</code> above :) )</p>",
        "id": 232005460,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616780377
    },
    {
        "content": "<p>E.g.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"bp\">.</span><span class=\"n\">with_term</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebraic_topology.simplicial_object</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">simplicial_object</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">category_theory</span>\n\n<span class=\"kd\">universes</span> <span class=\"n\">v</span> <span class=\"n\">u</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">category.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">C</span><span class=\"o\">]</span>\n\n<span class=\"kd\">@[derive category]</span>\n<span class=\"kd\">def</span> <span class=\"n\">augmented</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">with_term</span> <span class=\"n\">simplex_category</span><span class=\"bp\">ᵒᵖ</span><span class=\"o\">)</span> <span class=\"bp\">⥤</span> <span class=\"n\">C</span>\n\n<span class=\"kd\">@[derive category]</span>\n<span class=\"kd\">def</span> <span class=\"n\">augmented.truncated</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">with_term</span> <span class=\"o\">(</span><span class=\"n\">simplex_category.truncated</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">ᵒᵖ</span><span class=\"o\">)</span> <span class=\"bp\">⥤</span> <span class=\"n\">C</span>\n\n<span class=\"kd\">noncomputable</span>\n<span class=\"kd\">def</span> <span class=\"n\">augmented.truncated.trunc</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">augmented</span> <span class=\"n\">C</span> <span class=\"bp\">⥤</span> <span class=\"n\">augmented.truncated</span> <span class=\"n\">C</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">whiskering_left</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">obj</span> <span class=\"o\">(</span><span class=\"n\">with_term.map</span> <span class=\"n\">simplex_category.truncated.inclusion.op</span><span class=\"o\">)</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">simplicial_object</span>\n</code></pre></div>",
        "id": 232006412,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616780783
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/267928-condensed-mathematics/topic/Simplicial.20stuff/near/231346653\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"246273\">Bhavik Mehta</span> is there a lemma of the following form in mathlib?</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">is_iso_π_initial</span> <span class=\"o\">{</span><span class=\"n\">J</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">small_category</span> <span class=\"n\">J</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₁</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">category.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">J</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"n\">is_initial</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">has_limits_of_shape</span> <span class=\"n\">J</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">J</span> <span class=\"bp\">⥤</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">is_iso</span> <span class=\"o\">(</span><span class=\"n\">limit.π</span> <span class=\"n\">F</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p><a href=\"https://github.com/leanprover-community/mathlib/issues/6908\">#6908</a></p>",
        "id": 232064848,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1616821827
    }
]
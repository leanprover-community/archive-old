[
    {
        "content": "<p>An update from the <code>toric</code> branch.</p>\n<p>I just pushed the latest version of <code>toric</code>: it has several <code>sorries</code>, but compiles. It also contains a full proof that the dual set of a ℤ-basis in a ℤ-lattice is pointed (i.e. intersects a hyperplane in just the origin). There is also a lemma that says that dual sets are (anti-)monotone, so it should be easy to show that the dual set of any set that contains a basis is pointed.</p>\n<p>This is for ℤ-modules with a basis, which seem to work very well as a replacement to torsion free, finitely generated modules.  There is no finite generation assumption, but there is the requirement of having a basis.</p>\n<p>I would like this to work with fewer assumptions, but this is where I am at the moment. The good thing is that I think that this should work equally well over ℚ or ℝ, which should be the cases of interest for the applications to the liquid project!</p>",
        "id": 228149534,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1614538982
    },
    {
        "content": "<p>There is still work to do to prove that saturated submonoids are finitely generated, but I consider it progress!</p>",
        "id": 228149649,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1614539076
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span> did a massive amount of work here, and it has just been merged into <code>master</code></p>",
        "id": 229443460,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1615280585
    },
    {
        "content": "<p>Be sure to <code>git pull</code> before working on master</p>",
        "id": 229443505,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1615280605
    },
    {
        "content": "<p>I pushed a few more additions to the <code>toric</code> branch: it is not yet ready for unguided <code>sorry</code>-proving, but it is getting there!</p>",
        "id": 232486406,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1617133801
    },
    {
        "content": "<p>I work more on it this week and hopefully soon I will be able to have <code>sorry</code>s that can be proven with minimal insider knowledge.</p>",
        "id": 232486542,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1617133844
    },
    {
        "content": "<p>I would like to help with Gordan's lemma! Do you think  it's better to wait to have some more readable <code>sorry</code> or should I try to read the code now?</p>",
        "id": 232498344,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1617138452
    },
    {
        "content": "<p>I was thinking that the statement of Gordan's lemma should end up in some of the <code>toric</code> file, and that it gets simply quoted in <code>lem97</code>. I think this would make it easier to adapt the form you'll prove to the one that I'm using. Do you agree? And, if yes, where would you suggest that I insert it?</p>",
        "id": 232542162,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1617171772
    },
    {
        "content": "<p>Dear All,</p>\n<p>I am very happy about the interest in Gordan's lemma!  Part of the problem is that, while I write the steps in the proof, I confront myself with issues in the formalization and decide to change the approach.  If you are willing to write a proof and then having to adapt it to a (hopefully slightly) different context, then feel free to remove <code>sorry</code>s from the file <code>toric/towards_Gordan.lean</code> (this is the <code>toric</code> folder in the <code>toric</code> branch).</p>\n<p>However, I have had to change the setup a couple of times, since I was not able to make a few of the initial approaches work.  This is quite possibly due to my own inability to use Lean, though!</p>\n<p>I am trying to document <code>towards_Gordan.lean</code> in a systematic way, so that it should be easy to follow what the steps do, how they fit in the general proof and what are the important assumptions.  If you can prove a lemma \"close\" to one of the stated ones, that might also be very useful!</p>",
        "id": 232548042,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1617176105
    },
    {
        "content": "<p>And do you think <code>towards_Gordan</code> will eventually become <code>Gordan</code> (i.e. : I can insert the statement there and refer to it) or do you plan to have two files?</p>",
        "id": 232548304,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1617176274
    },
    {
        "content": "<p>Filippo, I am now upgrading my branch to the current <code>master</code>.  I will check the exact statement of Lemma 9.7 and will see how to fit it with what I have.</p>",
        "id": 232548310,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1617176280
    },
    {
        "content": "<p>Thanks, at any rate I find it most reasonable to put what I use in the <code>toric</code> directory, and that I quote it from there. If the statement you end up with is not exactly the one I am using, we can write the bridge between the two there more easily, I guess.</p>",
        "id": 232548416,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1617176352
    },
    {
        "content": "<p>Yes, at this stage, I am trying to get <em>some</em> Gordan-like statement proven.  Once that is done, I am hoping that merging the proven one with the one that you used should be a simple matter.</p>",
        "id": 232548529,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1617176424
    },
    {
        "content": "<p>The statement I am using is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">explicit_gordan</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"bp\">Λ</span> <span class=\"o\">:</span> <span class=\"n\">finite_free</span> <span class=\"bp\">Λ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">ι</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"bp\">Λ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">explicit_dual_set</span> <span class=\"n\">l</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">fg</span> <span class=\"o\">:=</span>\n<span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 232548579,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1617176456
    },
    {
        "content": "<p>where</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">explicit_dual_set</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"bp\">Λ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">submodule</span> <span class=\"n\">ℕ</span> <span class=\"o\">(</span><span class=\"bp\">Λ</span> <span class=\"bp\">→+</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">carrier</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"bp\">|</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"n\">i</span><span class=\"o\">)},</span>\n  <span class=\"n\">zero_mem'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">le_rfl</span><span class=\"o\">,</span>\n  <span class=\"n\">add_mem'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">hx</span> <span class=\"n\">hy</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">add_nonneg</span> <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hy</span> <span class=\"n\">i</span><span class=\"o\">),</span>\n  <span class=\"n\">smul_mem'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">n</span> <span class=\"n\">x</span> <span class=\"n\">hx</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">add_monoid_hom.nat_smul_apply</span><span class=\"o\">],</span> <span class=\"n\">exact</span> <span class=\"n\">nsmul_nonneg</span> <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"n\">n</span> <span class=\"o\">}</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 232548643,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1617176492
    },
    {
        "content": "<p>Also, it does make sense to have the statement of Gordan's lemma in the <code>toric</code> folder.</p>\n<p>I am building the <code>toric</code> branch now, with the <code>master</code> that I just merged.</p>",
        "id": 232548740,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1617176541
    },
    {
        "content": "<p>Ok, I have not yet fixed the <code>nat_submodule</code> issue, but, apart from that, I am getting close to having the function <code>l</code> appearing in <code>explicit_dual_set</code> defined.</p>",
        "id": 232548928,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1617176657
    },
    {
        "content": "<p>Ok, <code>master</code> merged with no issues into <code>toric</code>, <code>leanproject build</code> also only warned me about <code>sorry</code>s and I pushed again to the <code>toric</code> branch.  There are no changes from what I pushed yesterday, except that it is now up to date with <code>master</code>.</p>",
        "id": 232549075,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1617176764
    },
    {
        "content": "<p>... and CI is also happy with the branch!  I also noticed a sign error in a doc-string and pushed the fix.  This is just a change in a comment, so there should be no CI issues.</p>",
        "id": 232549836,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1617177211
    },
    {
        "content": "<p>I will try to read what you have done in the next days, so please don't hesitate to leave a lot of small <code>sorry</code> (even inside proofs!)... killing them is my favorite  way of getting used to new stuff <span aria-label=\"big smile\" class=\"emoji emoji-1f604\" role=\"img\" title=\"big smile\">:big_smile:</span></p>",
        "id": 232550272,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1617177471
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/267928-condensed-mathematics/topic/toric/near/232548740\">said</a>:</p>\n<blockquote>\n<p>Also, it does make sense to have the statement of Gordan's lemma in the <code>toric</code> folder.</p>\n<p>I am building the <code>toric</code> branch now, with the <code>master</code> that I just merged.</p>\n</blockquote>\n<p>Ok, are you going to put it somewhere and <code>push</code> to <code>master</code>? In that way, I can adapt my branch and when I'll <code>push</code> to <code>master</code> that part will be solid.</p>",
        "id": 232550720,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1617177677
    },
    {
        "content": "<p>Riccardo, If you stick to the file <code>towards_Gordan</code>, the <code>sorry</code>s there should be provable (at least, this is my intention!).  If you stray to a different file, you should also try to figure out if the statement is actually correct, since the <code>sorry</code>s outside of <code>towards_Gordan</code> are more of a playground, than actual steps in the formalization.</p>",
        "id": 232550766,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1617177715
    },
    {
        "content": "<p>I will have a look at <code>towards_Gordan</code>, thank you!</p>",
        "id": 232550970,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1617177813
    },
    {
        "content": "<p>Filippo, maybe the best thing would be to simply move the file <code>lem97.lean</code> into the <code>toric</code> folder, just to sort lemmas by \"semantic similarity\".  I still feel that I would like to have the option of tweaking the actual statement of Gordan's lemma to adapt it to what I feel is easier to formalize first, and worry about how to link it to what you have been using later.  I really think that the glue should be some simple juggling with finite sets and coercions.</p>",
        "id": 232551919,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1617178343
    },
    {
        "content": "<p>I agree, that it's best to formalize the statement that \"falls out of all the preliminary work\" and worry about the glue later.</p>",
        "id": 232552318,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1617178539
    },
    {
        "content": "<p>You want to keep the coe-juggling in a small place. It shouldn't infect the rest of the story (-;</p>",
        "id": 232552400,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1617178573
    },
    {
        "content": "<p>Oh I certainly agree it will be easy. OK, I will move<code>lem97 </code> in the <code>toric</code> folder leaving the <code>explicit_gordan</code> sorried. I'll be happy to come and help for the bridge once and if it will be needed. <span aria-label=\"bridge\" class=\"emoji emoji-1f309\" role=\"img\" title=\"bridge\">:bridge:</span></p>",
        "id": 232552696,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1617178802
    },
    {
        "content": "<p>What is the math proof of Gordan's lemma that you are trying to formalize? The wikipedia one is nice but leaves most of the work implicit in using duality of cones. Is there a good complete textbook account of duality of (rational) cones that you follow?</p>",
        "id": 232553712,
        "sender_full_name": "Peter Scholze",
        "timestamp": 1617179374
    },
    {
        "content": "<p>I have patched together a proof, following partly the outline in Wikipedia.</p>\n<p>Quickly, here is my strategy.</p>\n<p>I have already proved a bunch of infrastructure to work with cones and duals, so that should be (mostly) in place.</p>\n<ul>\n<li>Reduce to the case in which the dual is confined in an octant.  This is achieved by making sure that the set of which you are taking the dual contains a basis.</li>\n<li>Prove that the \"extremal rays\" are indexes by (some) subsets of the set of which you are taking the dual.  This is mostly a matter of making the definition of  \"extremal rays\" and \"1-dimensional subcone\" match up.</li>\n<li>Once you have finitely many extremal rays, what is left is a form of saturation.  This will be filled in by taking linear combinations of the extremal rays with rational coefficients in [0,1] and intersecting with the lattice.   Here, the main finiteness condition will follow from intersecting a (pre-)compact set with a discrete one.</li>\n</ul>",
        "id": 232555538,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1617180381
    },
    {
        "content": "<p>From a formalization point of view, I am trying to make the transitions between linear combinations with coefficients in ℕ, ℤ, ℚ or ℝ be as smooth as possible, since they all play some partial role in the argument.</p>",
        "id": 232555653,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1617180459
    },
    {
        "content": "<p>While this feels to be within my \"formalization grasp\", I also find it challenging!</p>",
        "id": 232555876,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1617180569
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span>  OK, sounds great!</p>",
        "id": 232559966,
        "sender_full_name": "Peter Scholze",
        "timestamp": 1617182529
    },
    {
        "content": "<p>I have proved <code>reduction_to_lattice</code> here<br>\n<a href=\"https://github.com/leanprover-community/lean-liquid/blob/riccardobrasca/src/toric/towards_Gordan.lean\">https://github.com/leanprover-community/lean-liquid/blob/riccardobrasca/src/toric/towards_Gordan.lean</a><br>\nThere is something I don't understand in the proof: I have the impression that the hypothesis I called <code>goal</code> is exactly what we want to prove, but <code>exact goal</code> doesn't work.  If you try to play with it it's very easy to get to a point where you need to prove <code>foo</code> and you have <code>foo</code> in the local context, but there should be some problem with possibly different <code>ℤ</code>-actions. If someone wants to play with it feel free to modify it... at the moment it is very ugly.</p>",
        "id": 232665829,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1617225116
    },
    {
        "content": "<p>Perhaps you've tried it already, but in that situation I often use <a href=\"https://leanprover-community.github.io/mathlib_docs/tactics.html#convert\">tactic#convert</a> to show what Lean is having trouble with.</p>",
        "id": 232666610,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1617225433
    },
    {
        "content": "<p>I did it, in line <code>80</code>. The goal becomes</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">),</span> <span class=\"n\">g</span> <span class=\"n\">i</span> <span class=\"bp\">•</span> <span class=\"n\">b</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">),</span> <span class=\"n\">g</span> <span class=\"n\">i</span> <span class=\"bp\">•</span> <span class=\"n\">b</span> <span class=\"n\">i</span>\n</code></pre></div>\n<p>After <code>ext i</code> the goal becomes</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">i</span> <span class=\"bp\">•</span> <span class=\"n\">b</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">i</span> <span class=\"bp\">•</span> <span class=\"n\">b</span> <span class=\"n\">i</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I proved this by induction on <code>g i</code>, that is an integer. The proof worked because essentially <code>zero_smul</code> <code>add_smul</code>,<code>sub_smul</code> and <code>one_smul</code> work for any <code>•</code>, but I don't know how to do it better.</p>",
        "id": 232667154,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1617225682
    },
    {
        "content": "<p>Ah, sorry, I hadn't looked at the proof yet!</p>",
        "id": 232667384,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1617225789
    },
    {
        "content": "<p>It must have something to to with coercion from <code>Λ₁</code> to submodules of <code>V</code>, or something like that.</p>",
        "id": 232667626,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1617225929
    },
    {
        "content": "<p>Hmm, is it something that <code>norm_cast</code> should be helping with?</p>",
        "id": 232667669,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1617225957
    },
    {
        "content": "<p>Let me see</p>",
        "id": 232667789,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1617226011
    },
    {
        "content": "<p>Hmm, it does something, but it doesn't really change the proof</p>",
        "id": 232669041,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1617226593
    },
    {
        "content": "<p>Ah! A combination of <code>norm_cast</code> and <code>congr</code> simplified the proof quite a lot</p>",
        "id": 232670232,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1617227175
    },
    {
        "content": "<p>The proof is now reasonably small, even if there still is something I don't understand completely. If  it's OK for <span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span> I will push it into <code>toric</code>.</p>",
        "id": 232676329,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1617230202
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130384\">@Riccardo Brasca</span> thank you very much for your help!</p>\n<p>Feel free to push your proof to <code>toric</code>!</p>\n<p>I have not looked at it, but I suspect that the issues that you mention have to do with Lean finding it tricky to convert between \\Z and \\Q.</p>\n<p>In any case, any proof is the same as any other proof in Lean!</p>",
        "id": 232697816,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1617247172
    },
    {
        "content": "<p>Ok, I took a look at this and I could golf it slightly, mostly by extracting a part of the proof to something more general:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- general fact, also asked in mathlib</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">algebra_map.injective.linear_independent</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">S</span> <span class=\"n\">M</span> <span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">S</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">R</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semimodule</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semimodule</span> <span class=\"n\">S</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">is_scalar_tower</span> <span class=\"n\">R</span> <span class=\"n\">S</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">hinj</span> <span class=\"o\">:</span> <span class=\"n\">function.injective</span> <span class=\"o\">(</span><span class=\"n\">algebra_map</span> <span class=\"n\">R</span> <span class=\"n\">S</span><span class=\"o\">))</span> <span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">M</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">li</span> <span class=\"o\">:</span> <span class=\"n\">linear_independent</span> <span class=\"n\">S</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">linear_independent</span> <span class=\"n\">R</span> <span class=\"n\">v</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">refine</span> <span class=\"n\">linear_independent_iff'.mpr</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">s</span> <span class=\"n\">g</span> <span class=\"n\">hg</span> <span class=\"n\">i</span> <span class=\"n\">hi</span><span class=\"o\">,</span> <span class=\"n\">hinj</span> <span class=\"o\">(</span><span class=\"n\">eq.trans</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">ring_hom.map_zero</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">)),</span>\n  <span class=\"n\">refine</span> <span class=\"o\">(((</span><span class=\"bp\">@</span><span class=\"n\">linear_independent_iff'</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">v</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"n\">li</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">i</span> <span class=\"n\">hi</span><span class=\"o\">,</span>\n  <span class=\"n\">simp_rw</span> <span class=\"n\">algebra_map_smul</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">hg</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"c1\">-- marginally shorter proof</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">reduction_to_lattice</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">submodule</span> <span class=\"n\">ℚ</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">bv</span> <span class=\"o\">:</span> <span class=\"n\">is_basis</span> <span class=\"n\">ℚ</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">vn</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">s.restrict_scalars</span> <span class=\"n\">ℤ</span> <span class=\"bp\">⊓</span> <span class=\"n\">submodule.span</span> <span class=\"n\">ℤ</span> <span class=\"o\">(</span><span class=\"n\">set.range</span> <span class=\"n\">v</span><span class=\"o\">)),</span>\n  <span class=\"n\">is_basis</span> <span class=\"n\">ℤ</span> <span class=\"n\">vn</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">hb</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span>\n    <span class=\"n\">submodule.exists_is_basis_of_le_span</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">linear_independent</span> <span class=\"n\">ℤ</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"n\">inf_le_right</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">convert</span> <span class=\"n\">hb.2</span><span class=\"o\">⟩⟩,</span>\n    <span class=\"n\">replace</span> <span class=\"n\">hb</span> <span class=\"o\">:=</span> <span class=\"n\">hb.1</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">linear_independent_iff'</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"bp\">⊢</span> <span class=\"n\">hb</span><span class=\"o\">,</span>\n    <span class=\"n\">intros</span> <span class=\"n\">t</span> <span class=\"n\">g</span> <span class=\"n\">hg</span> <span class=\"n\">i</span> <span class=\"n\">hi</span><span class=\"o\">,</span>\n    <span class=\"n\">refine</span> <span class=\"n\">hb</span> <span class=\"n\">t</span> <span class=\"n\">g</span> <span class=\"n\">_</span> <span class=\"n\">i</span> <span class=\"n\">hi</span><span class=\"o\">,</span>\n    <span class=\"n\">convert</span> <span class=\"n\">hg</span><span class=\"o\">,</span>\n    <span class=\"n\">ext</span> <span class=\"n\">i</span><span class=\"o\">,</span>\n    <span class=\"n\">erw</span> <span class=\"o\">[</span><span class=\"n\">submodule.coe_smul_of_tower</span><span class=\"o\">,</span> <span class=\"n\">submodule.coe_smul_of_tower</span><span class=\"o\">,</span> <span class=\"n\">algebra_map_smul</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">refine</span> <span class=\"n\">algebra_map.injective.linear_independent</span> <span class=\"n\">_</span> <span class=\"n\">bv.1</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">ab</span><span class=\"o\">,</span> <span class=\"n\">int.cast_inj.mp</span> <span class=\"n\">ab</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 232702284,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1617251226
    },
    {
        "content": "<p>It may be that the main weirdness in the proof is that <code>is_scalar_tower ℤ ℚ V</code> and the coercion from ℤ to ℚ do not recognize each other.... maybe.</p>",
        "id": 232702419,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1617251357
    },
    {
        "content": "<p>I think that sometimes you can <code>have aux : int.module \\Z = ring.to_module \\Z</code> (or something like that). The proof of that <code>have</code> will be <code>subsingleton.elim</code>. And after that, you can <code>rw aux</code> so that all the scalar multiplications are now really the same.</p>",
        "id": 232704801,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1617253454
    },
    {
        "content": "<p>But I agree that this is an annoying side effect of (conf)using abelian groups and Z-modules.</p>",
        "id": 232704829,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1617253483
    },
    {
        "content": "<p>Ok, analyzing this further, in the <code>erw</code> step there are two <code>submodule.coe_smul_of_tower</code>: the first one, changes</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">i</span> <span class=\"bp\">•</span> <span class=\"n\">b</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"c1\">--&gt; g i • ↑(b i)</span>\n</code></pre></div>\n<p>but the second one, changes</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">i</span> <span class=\"bp\">•</span> <span class=\"n\">b</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"c1\">--&gt; ⇑(algebra_map ℤ ℤ) (g i) • ↑(b i)</span>\n</code></pre></div>\n<p>maybe this is the issue?</p>",
        "id": 232705139,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1617253729
    },
    {
        "content": "<p>Can this boil down to the non-defeq diamond of the Z-module over itself:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.module.basic</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">add_comm_group.int_module.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"n\">int</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">ring.to_add_comm_group</span> <span class=\"n\">_</span> <span class=\"n\">int.ring</span><span class=\"o\">)</span> <span class=\"bp\">=</span>\n  <span class=\"bp\">@</span><span class=\"n\">semiring.to_semimodule.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"n\">int</span>\n    <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">comm_semiring.to_semiring.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"n\">int</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">comm_ring.to_comm_semiring.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"n\">int</span> <span class=\"n\">int.comm_ring</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span> <span class=\"c1\">-- unfortunately not rfl right now</span>\n</code></pre></div>",
        "id": 232705328,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1617253895
    },
    {
        "content": "<p>Johan, I am trying with your suggestion, but I might be missing an import, since Lean does recognize neither <code>int.module</code> nor <code>ring.to_module</code>!</p>",
        "id": 232705406,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1617253966
    },
    {
        "content": "<p>Yakov, it may be, but I am really not sure what is going on...  Even with the widgets, the pieces of the terms look identical quite a long way down.</p>",
        "id": 232705446,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1617254032
    },
    {
        "content": "<p>Can you try <code>int_module</code> and <code>semiring.to_semimodule</code> instead?</p>",
        "id": 232705492,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1617254054
    },
    {
        "content": "<p>with <code>int_module</code> I still get <code>unknown identifier 'int_module'</code>.</p>",
        "id": 232705531,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1617254095
    },
    {
        "content": "<p>(however, lean recognized <code>semiring.to_semimodule</code>)</p>",
        "id": 232705561,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1617254129
    },
    {
        "content": "<p><code>@add_comm_group.int_module \\Z (by apply_instance)</code></p>",
        "id": 232705658,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1617254196
    },
    {
        "content": "<p>Lean considers this a valid statement:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">have</span> <span class=\"n\">aux</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">add_comm_group.int_module</span> <span class=\"n\">ℤ</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">apply_instance</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">semiring.to_semimodule</span><span class=\"o\">,</span>\n<span class=\"gr\">sorry</span><span class=\"o\">,</span>\n</code></pre></div>",
        "id": 232705782,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1617254326
    },
    {
        "content": "<p><del>But I am not sure how to use it afterwards (nor how to prove it).</del></p>\n<p>Johan did say how to prove it:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">have</span> <span class=\"n\">aux</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">add_comm_group.int_module</span> <span class=\"n\">ℤ</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">apply_instance</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">semiring.to_semimodule</span> <span class=\"o\">:=</span>\n<span class=\"n\">subsingleton.elim</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n</code></pre></div>",
        "id": 232705810,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1617254367
    },
    {
        "content": "<p>When you get to your seemingly identical goal, <code>convert rfl</code> should work now, hopefully with <code>convert</code> pulling in this hypothesis. Or try <code>simp_rw aux</code> as Johan suggested above.</p>",
        "id": 232705976,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1617254500
    },
    {
        "content": "<p>In several files on polyhedral lattices, I disabled the <code>add_comm_group.int_module</code> instance at the top of the file, forcing Lean (and myself) to work explicitly with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\Z</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Z</span></span></span></span></span>-modules.</p>",
        "id": 232706063,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1617254600
    },
    {
        "content": "<p>I tried <code>simp_rw at *</code> at each line in the proof, followed by <code>assumption</code>, <code>solve_by_elim</code> or <code>exact ...</code> and it did not seem to work.  I will try with <code>convert rfl</code> now!</p>",
        "id": 232706146,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1617254701
    },
    {
        "content": "<p><code>convert rfl</code> either leaves the goal unchanged (at least in the infoview, I did not check if it changed some parts of the terms that is not \"just visible\"), or it introduces a <code>has_lift_t.lift</code>.</p>",
        "id": 232706282,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1617254870
    },
    {
        "content": "<p>I just read Johan's freestyle post: I guess that I am doing the exact opposite here... <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 232706453,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1617255022
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span>  do you have this on a branch? I'll take a look</p>",
        "id": 232706772,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1617255281
    },
    {
        "content": "<p>If I understand correctly, the issue is the error at this lemma and proof:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">reduction_to_lattice</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">submodule</span> <span class=\"n\">ℚ</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">vn</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">s.restrict_scalars</span> <span class=\"n\">ℤ</span> <span class=\"bp\">⊓</span> <span class=\"n\">submodule.span</span> <span class=\"n\">ℤ</span> <span class=\"o\">(</span><span class=\"n\">set.range</span> <span class=\"n\">v</span><span class=\"o\">)),</span>\n  <span class=\"n\">is_basis</span> <span class=\"n\">ℤ</span> <span class=\"n\">vn</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">have</span> <span class=\"n\">hind</span> <span class=\"o\">:</span> <span class=\"n\">linear_independent</span> <span class=\"n\">ℤ</span> <span class=\"n\">v</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">replace</span> <span class=\"n\">bv</span> <span class=\"o\">:=</span> <span class=\"n\">bv.1</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">linear_independent_iff'</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"bp\">⊢</span> <span class=\"n\">bv</span><span class=\"o\">,</span>\n    <span class=\"n\">intros</span> <span class=\"n\">s</span> <span class=\"n\">g</span> <span class=\"n\">hg</span> <span class=\"n\">i</span> <span class=\"n\">hi</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">),</span> <span class=\"o\">((</span><span class=\"n\">g</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"bp\">•</span> <span class=\"n\">v</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">•</span> <span class=\"n\">v</span> <span class=\"n\">i</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">intro</span> <span class=\"n\">i</span><span class=\"o\">,</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">gsmul_eq_smul</span><span class=\"o\">,</span> <span class=\"n\">gsmul_eq_smul_cast</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n    <span class=\"k\">have</span> <span class=\"n\">hg'</span> <span class=\"o\">:</span> <span class=\"n\">s.sum</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span><span class=\"o\">))</span> <span class=\"n\">i</span> <span class=\"bp\">•</span> <span class=\"n\">v</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">H</span><span class=\"o\">,</span> <span class=\"n\">hg</span><span class=\"o\">]},</span>\n    <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">bv</span> <span class=\"n\">s</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">g</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"n\">hg'</span> <span class=\"n\">i</span> <span class=\"n\">hi</span> <span class=\"o\">},</span>\n  <span class=\"c1\">--The RHS seems to be the statement we want, but some work is needed</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">hb</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">submodule.exists_is_basis_of_le_span</span> <span class=\"n\">hind</span> <span class=\"n\">inf_le_right</span><span class=\"o\">,</span>\n  <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">convert</span> <span class=\"n\">hb.2</span><span class=\"o\">⟩⟩,</span>\n  <span class=\"n\">replace</span> <span class=\"n\">hb</span> <span class=\"o\">:=</span> <span class=\"n\">hb.1</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">hb</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 232707466,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1617255997
    },
    {
        "content": "<p>Sorry, having breakfast!</p>\n<p>Yakov, that is the <del>alto</del> error [weird autocorrect], though!</p>",
        "id": 232707602,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1617256138
    },
    {
        "content": "<p>The issue isn't in the <code>int_module</code> but rather <code>int.semiring</code> vs </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>            <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">ring.to_semiring</span> <span class=\"n\">ℤ</span>\n               <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">domain.to_ring</span> <span class=\"n\">ℤ</span>\n                  <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">integral_domain.to_domain</span> <span class=\"n\">ℤ</span>\n                     <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">linear_ordered_comm_ring.to_integral_domain</span> <span class=\"n\">ℤ</span> <span class=\"n\">int.linear_ordered_comm_ring</span><span class=\"o\">))))</span>\n</code></pre></div>\n<p>and related</p>",
        "id": 232710892,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1617259058
    },
    {
        "content": "<p>Doing <code>local attribute [-instance] int.semiring int.ring int.comm_semiring</code> results in the following diamond as an issue:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>           <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">ring.to_semiring</span> <span class=\"n\">ℤ</span>\n              <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">domain.to_ring</span> <span class=\"n\">ℤ</span>\n                 <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">integral_domain.to_domain</span> <span class=\"n\">ℤ</span>\n                    <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">linear_ordered_comm_ring.to_integral_domain</span> <span class=\"n\">ℤ</span> <span class=\"n\">int.linear_ordered_comm_ring</span><span class=\"o\">))))</span>\n</code></pre></div>\n<p>vs</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>           <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">ring.to_semiring</span> <span class=\"n\">ℤ</span>\n              <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">ordered_ring.to_ring</span> <span class=\"n\">ℤ</span>\n                 <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">linear_ordered_ring.to_ordered_ring</span> <span class=\"n\">ℤ</span>\n                    <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">linear_ordered_comm_ring.to_linear_ordered_ring</span> <span class=\"n\">ℤ</span> <span class=\"n\">int.linear_ordered_comm_ring</span><span class=\"o\">))))</span>\n</code></pre></div>",
        "id": 232711164,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1617259314
    },
    {
        "content": "<p>Ok, this is now not so much about this special case, but in general, does it mean that there is a missing instance somewhere?  A missing proof?  What constitutes a \"good, structural way\" of fixing these issues?</p>",
        "id": 232711165,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1617259318
    },
    {
        "content": "<p>So, should Lean be forbidden to use that <code>int</code> is an integral domain?</p>",
        "id": 232711340,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1617259471
    },
    {
        "content": "<p>Although in a mathlib repo I have, it seems</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">ring.to_semiring</span> <span class=\"n\">ℤ</span>\n    <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">domain.to_ring</span> <span class=\"n\">ℤ</span>\n        <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">integral_domain.to_domain</span> <span class=\"n\">ℤ</span>\n          <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">linear_ordered_comm_ring.to_integral_domain</span> <span class=\"n\">ℤ</span> <span class=\"n\">int.linear_ordered_comm_ring</span><span class=\"o\">))))</span> <span class=\"bp\">=</span>\n  <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">ring.to_semiring</span> <span class=\"n\">ℤ</span>\n    <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">ordered_ring.to_ring</span> <span class=\"n\">ℤ</span>\n        <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">linear_ordered_ring.to_ordered_ring</span> <span class=\"n\">ℤ</span>\n          <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">linear_ordered_comm_ring.to_linear_ordered_ring</span> <span class=\"n\">ℤ</span> <span class=\"n\">int.linear_ordered_comm_ring</span><span class=\"o\">))))</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>works fine</p>",
        "id": 232711350,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1617259494
    },
    {
        "content": "<p>I copy pasted your <code>example</code> in the file that I have with the convoluted proof and Lean accepts it there as well.</p>",
        "id": 232711487,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1617259596
    },
    {
        "content": "<p>OK so one can see the issue earlier in the gordon lemma proof</p>",
        "id": 232711504,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1617259623
    },
    {
        "content": "<p>Consider this tactic step:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">convert</span> <span class=\"n\">hb.2</span><span class=\"o\">⟩⟩,</span>\n</code></pre></div>",
        "id": 232711518,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1617259639
    },
    {
        "content": "<p>Switching it to just</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n</code></pre></div>",
        "id": 232711537,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1617259650
    },
    {
        "content": "<p>We can see a difference between the hypothesis <code>hb</code> and the goal</p>",
        "id": 232711558,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1617259662
    },
    {
        "content": "<p><a href=\"/user_uploads/3121/CyPZVBVaJjs-c6jK-ttWOaq5/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/CyPZVBVaJjs-c6jK-ttWOaq5/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/CyPZVBVaJjs-c6jK-ttWOaq5/image.png\"></a></div>",
        "id": 232711562,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1617259678
    },
    {
        "content": "<p><a href=\"/user_uploads/3121/mTA0--7o4mxWRMkiy9YUI-Zc/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/mTA0--7o4mxWRMkiy9YUI-Zc/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/mTA0--7o4mxWRMkiy9YUI-Zc/image.png\"></a></div>",
        "id": 232711613,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1617259692
    },
    {
        "content": "<p>I see: <code>ordered_ring</code> vs <code>domain</code>.</p>",
        "id": 232711651,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1617259733
    },
    {
        "content": "<p>Right. So why is it unhappy? And, even though it is unhappy, is there a way to get the <code>exists_is_basis_of_le_span</code> to use the \"correct\" <code>ring</code> as a workaround?</p>",
        "id": 232711683,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1617259786
    },
    {
        "content": "<p>It is funny, but in the other stuff that I was doing in a similar vein, I had separate assumptions:</p>\n<ul>\n<li>one to work with <code>regular</code> elements (close to integrality conditions) and</li>\n<li>one with non-negative stuff (close to orders).</li>\n</ul>\n<p>I am impressed that Lean picks up on this also in this case!</p>",
        "id": 232711688,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1617259799
    },
    {
        "content": "<p>One issue with <code>exists_is_basis_of_le_span</code> as it is right now is there is a free metavariable</p>",
        "id": 232711769,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1617259840
    },
    {
        "content": "<p>So, are you suggesting that an <code>@</code> and underscore-fest might solve this?</p>",
        "id": 232711808,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1617259894
    },
    {
        "content": "<p>Specifically, which <code>submodule \\Z V</code> is on the left of the <code>\\inf</code>.</p>",
        "id": 232711815,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1617259908
    },
    {
        "content": "<p>Could be? I'm not sure yet.</p>",
        "id": 232711818,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1617259913
    },
    {
        "content": "<p>Let me try to work this out.</p>",
        "id": 232711906,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1617260003
    },
    {
        "content": "<p>(Just an observation -- you found the source of the integral_domain: it is the assumption coming from <code>exists_is_basis_of_le_span</code>!)</p>",
        "id": 232711964,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1617260044
    },
    {
        "content": "<p>I am tempted to say that it is this one:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">submodule.restrict_scalars</span> <span class=\"n\">ℤ</span> <span class=\"n\">s</span>\n</code></pre></div>",
        "id": 232712217,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1617260267
    },
    {
        "content": "<p>What about that submodule?</p>",
        "id": 232712272,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1617260295
    },
    {
        "content": "<p>I think that this is the submodule that is implicit, no?</p>",
        "id": 232712296,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1617260315
    },
    {
        "content": "<p>Yes, that's right. I'm just trying to slay little things that might get in the way, process of elimination</p>",
        "id": 232712317,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1617260349
    },
    {
        "content": "<p>There is indeed a hidden goal, after the <code>obtain</code> step: there are three goals after it, but only two need to be proven, since one disappears.  I think that it disappears when Lean realizes that the module is what I wrote above.  At least, this is my interpretation!</p>",
        "id": 232712536,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1617260480
    },
    {
        "content": "<p>Yes, agreed. I am still not sure why the <code>integral_domain &gt; domain &gt; ring &lt; comm_ring &lt; integral_domain</code> diamond seems to be getting in the way</p>",
        "id": 232712663,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1617260568
    },
    {
        "content": "<p>(that is, even after getting rid of the other ring instances)</p>",
        "id": 232712695,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1617260590
    },
    {
        "content": "<p>I see that you are playing with more or less what I did yesterday (with a far better understanding  :)<br>\nI don't know if this is relevant, but my first attempt to prove the proposition was to start like this (before realizing there is <code>submodule.exists_is_basis_of_le_span</code>)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">reduction_to_lattice</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">submodule</span> <span class=\"n\">ℚ</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">vn</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">s.restrict_scalars</span> <span class=\"n\">ℤ</span> <span class=\"bp\">⊓</span> <span class=\"n\">submodule.span</span> <span class=\"n\">ℤ</span> <span class=\"o\">(</span><span class=\"n\">set.range</span> <span class=\"n\">v</span><span class=\"o\">)),</span>\n  <span class=\"n\">is_basis</span> <span class=\"n\">ℤ</span> <span class=\"n\">vn</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">let</span> <span class=\"bp\">Λ</span> <span class=\"o\">:=</span> <span class=\"n\">submodule.span</span> <span class=\"n\">ℤ</span> <span class=\"o\">(</span><span class=\"n\">set.range</span> <span class=\"n\">v</span><span class=\"o\">),</span>\n  <span class=\"k\">let</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"bp\">Λ</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">v</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">submodule.subset_span</span> <span class=\"o\">(</span><span class=\"n\">set.mem_range_self</span> <span class=\"n\">_</span><span class=\"o\">)⟩,</span>\n  <span class=\"k\">have</span> <span class=\"n\">hind</span> <span class=\"o\">:</span> <span class=\"n\">linear_independent</span> <span class=\"n\">ℤ</span> <span class=\"n\">w</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span> <span class=\"c1\">--this is OK</span>\n  <span class=\"k\">have</span> <span class=\"n\">hbasis</span> <span class=\"o\">:</span> <span class=\"n\">is_basis</span> <span class=\"n\">ℤ</span> <span class=\"n\">w</span> <span class=\"o\">:=</span> <span class=\"n\">is_basis_span</span> <span class=\"n\">hind</span><span class=\"o\">,</span> <span class=\"c1\">--this is not OK</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 232714180,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1617261539
    },
    {
        "content": "<p>Actually, the proof feels like it could be simply:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">convert</span> <span class=\"n\">submodule.exists_is_basis_of_le_span</span>\n    <span class=\"o\">((</span><span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">refine</span> <span class=\"n\">algebra_map.injective.linear_independent</span> <span class=\"n\">_</span> <span class=\"n\">bv.1</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">ab</span><span class=\"o\">,</span> <span class=\"n\">int.cast_inj.mp</span> <span class=\"n\">ab</span> <span class=\"o\">}))</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">inf_le_right</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">submodule.restrict_scalars</span> <span class=\"n\">ℤ</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n</code></pre></div>",
        "id": 232714235,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1617261581
    },
    {
        "content": "<p>So my idea was to prove that <code>Λ</code> is free, the basis should of course be <code>w</code>. Now, proving that <code>w</code> is linear independent is easy... but I wasn't able to prove that it is a spanning set, and if you try you see immediately what goes wrong.</p>",
        "id": 232714344,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1617261639
    },
    {
        "content": "<p>since the resulting goal of this looks like the equality of two \"identical\" terms: the only apparent difference seems to be the choice of symbol for the <code>exists</code> variable.</p>",
        "id": 232714384,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1617261667
    },
    {
        "content": "<p>Ah there is another difference</p>",
        "id": 232714612,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1617261817
    },
    {
        "content": "<p>This is all very weird and I am getting the impression that the difficulty is generated by working with \"explicit\" types, like ℤ and ℚ.</p>",
        "id": 232714615,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1617261821
    },
    {
        "content": "<p>Not sure if it is a meaningful one</p>",
        "id": 232714617,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1617261824
    },
    {
        "content": "<p><code>submodule.has_inf</code> vs <code>semilattice_inf.to_has_inf (submodule ℤ V)</code></p>",
        "id": 232714683,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1617261845
    },
    {
        "content": "<p>Those are also <code>rfl</code> =/</p>",
        "id": 232715158,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1617262166
    },
    {
        "content": "<p>Hmm, I have a feeling that these \"just work\" since they are contained in the part that \"disappears\" in the proof.  I take this to mean that Lean correctly understand what we are saying and moves on, right?</p>",
        "id": 232715405,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1617262318
    },
    {
        "content": "<p>Do you have a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> of what goes wrong, hopefully just mathlib dependent but otherwise I'll clone LTE?</p>",
        "id": 232716190,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1617262746
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">linear_algebra.free_module</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">algebra_map.injective.linear_independent</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">S</span> <span class=\"n\">M</span> <span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">S</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">R</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semimodule</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semimodule</span> <span class=\"n\">S</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">is_scalar_tower</span> <span class=\"n\">R</span> <span class=\"n\">S</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">hinj</span> <span class=\"o\">:</span> <span class=\"n\">function.injective</span> <span class=\"o\">(</span><span class=\"n\">algebra_map</span> <span class=\"n\">R</span> <span class=\"n\">S</span><span class=\"o\">))</span> <span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">M</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">li</span> <span class=\"o\">:</span> <span class=\"n\">linear_independent</span> <span class=\"n\">S</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">linear_independent</span> <span class=\"n\">R</span> <span class=\"n\">v</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">refine</span> <span class=\"n\">linear_independent_iff'.mpr</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">s</span> <span class=\"n\">g</span> <span class=\"n\">hg</span> <span class=\"n\">i</span> <span class=\"n\">hi</span><span class=\"o\">,</span> <span class=\"n\">hinj</span> <span class=\"o\">(</span><span class=\"n\">eq.trans</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">ring_hom.map_zero</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">)),</span>\n  <span class=\"n\">refine</span> <span class=\"o\">(((</span><span class=\"bp\">@</span><span class=\"n\">linear_independent_iff'</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">v</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"n\">li</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">i</span> <span class=\"n\">hi</span><span class=\"o\">,</span>\n  <span class=\"n\">simp_rw</span> <span class=\"n\">algebra_map_smul</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">hg</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semimodule</span> <span class=\"n\">ℚ</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">ι</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">V</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">bv</span> <span class=\"o\">:</span> <span class=\"n\">is_basis</span> <span class=\"n\">ℚ</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n<span class=\"kn\">include</span> <span class=\"n\">bv</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">reduction_to_lattice</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">submodule</span> <span class=\"n\">ℚ</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">vn</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">s.restrict_scalars</span> <span class=\"n\">ℤ</span> <span class=\"bp\">⊓</span> <span class=\"n\">submodule.span</span> <span class=\"n\">ℤ</span> <span class=\"o\">(</span><span class=\"n\">set.range</span> <span class=\"n\">v</span><span class=\"o\">)),</span>\n  <span class=\"n\">is_basis</span> <span class=\"n\">ℤ</span> <span class=\"n\">vn</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">hb</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">submodule.exists_is_basis_of_le_span</span>\n    <span class=\"o\">((</span><span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">refine</span> <span class=\"n\">algebra_map.injective.linear_independent</span> <span class=\"n\">_</span> <span class=\"n\">bv.1</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">ab</span><span class=\"o\">,</span> <span class=\"n\">int.cast_inj.mp</span> <span class=\"n\">ab</span> <span class=\"o\">}))</span>\n    <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">inf_le_right</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">submodule.restrict_scalars</span> <span class=\"n\">ℤ</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n  <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">hb</span> <span class=\"c1\">-- :C</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 232716515,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1617262940
    },
    {
        "content": "<p>Alternatively, you could also hope to finish the proof earlier:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">reduction_to_lattice</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">submodule</span> <span class=\"n\">ℚ</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">bv</span> <span class=\"o\">:</span> <span class=\"n\">is_basis</span> <span class=\"n\">ℚ</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">vn</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">s.restrict_scalars</span> <span class=\"n\">ℤ</span> <span class=\"bp\">⊓</span> <span class=\"n\">submodule.span</span> <span class=\"n\">ℤ</span> <span class=\"o\">(</span><span class=\"n\">set.range</span> <span class=\"n\">v</span><span class=\"o\">)),</span>\n  <span class=\"n\">is_basis</span> <span class=\"n\">ℤ</span> <span class=\"n\">vn</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">convert</span> <span class=\"n\">submodule.exists_is_basis_of_le_span</span>\n    <span class=\"o\">((</span><span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">refine</span> <span class=\"n\">algebra_map.injective.linear_independent</span> <span class=\"n\">_</span> <span class=\"n\">bv.1</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">ab</span><span class=\"o\">,</span> <span class=\"n\">int.cast_inj.mp</span> <span class=\"n\">ab</span> <span class=\"o\">}))</span>\n    <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">inf_le_right</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">submodule.restrict_scalars</span> <span class=\"n\">ℤ</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n  <span class=\"n\">refl</span><span class=\"o\">,</span> <span class=\"c1\">-- does not work</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 232716614,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1617263033
    },
    {
        "content": "<p>Thanks!</p>",
        "id": 232716807,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1617263147
    },
    {
        "content": "<p>First comment: it's probably coming from <code>add_comm_group.int_module</code>, which is not defeq to other int actions. Indeed, if you disable it with</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">local</span> <span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"bp\">-</span><span class=\"kd\">instance</span><span class=\"o\">]</span> <span class=\"n\">add_comm_group.int_module</span>\n</code></pre></div>\n<p>at the start of your mwe, then Lean does not understand the statement of the second lemma any more. So it has to be used somewehere.</p>",
        "id": 232717218,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1617263398
    },
    {
        "content": "<p>Here is a working proof:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">linear_algebra.free_module</span>\n\n<span class=\"kn\">local</span> <span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"bp\">-</span><span class=\"kd\">instance</span><span class=\"o\">]</span> <span class=\"n\">add_comm_group.int_module</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">algebra_map.injective.linear_independent</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">S</span> <span class=\"n\">M</span> <span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">S</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">R</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semimodule</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semimodule</span> <span class=\"n\">S</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">is_scalar_tower</span> <span class=\"n\">R</span> <span class=\"n\">S</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">hinj</span> <span class=\"o\">:</span> <span class=\"n\">function.injective</span> <span class=\"o\">(</span><span class=\"n\">algebra_map</span> <span class=\"n\">R</span> <span class=\"n\">S</span><span class=\"o\">))</span> <span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">M</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">li</span> <span class=\"o\">:</span> <span class=\"n\">linear_independent</span> <span class=\"n\">S</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">linear_independent</span> <span class=\"n\">R</span> <span class=\"n\">v</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">refine</span> <span class=\"n\">linear_independent_iff'.mpr</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">s</span> <span class=\"n\">g</span> <span class=\"n\">hg</span> <span class=\"n\">i</span> <span class=\"n\">hi</span><span class=\"o\">,</span> <span class=\"n\">hinj</span> <span class=\"o\">(</span><span class=\"n\">eq.trans</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">ring_hom.map_zero</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">)),</span>\n  <span class=\"n\">refine</span> <span class=\"o\">(((</span><span class=\"bp\">@</span><span class=\"n\">linear_independent_iff'</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">v</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"n\">li</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">i</span> <span class=\"n\">hi</span><span class=\"o\">,</span>\n  <span class=\"n\">simp_rw</span> <span class=\"n\">algebra_map_smul</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">hg</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semimodule</span> <span class=\"n\">ℚ</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semimodule</span> <span class=\"n\">ℤ</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">is_scalar_tower</span> <span class=\"n\">ℤ</span> <span class=\"n\">ℚ</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">ι</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">V</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">bv</span> <span class=\"o\">:</span> <span class=\"n\">is_basis</span> <span class=\"n\">ℚ</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n<span class=\"kn\">include</span> <span class=\"n\">bv</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">profiler</span> <span class=\"n\">true</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">reduction_to_lattice</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">submodule</span> <span class=\"n\">ℚ</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">vn</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">s.restrict_scalars</span> <span class=\"n\">ℤ</span> <span class=\"bp\">⊓</span> <span class=\"n\">submodule.span</span> <span class=\"n\">ℤ</span> <span class=\"o\">(</span><span class=\"n\">set.range</span> <span class=\"n\">v</span><span class=\"o\">)),</span>\n  <span class=\"n\">is_basis</span> <span class=\"n\">ℤ</span> <span class=\"n\">vn</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">have</span> <span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">function.injective</span> <span class=\"o\">(</span><span class=\"n\">algebra_map</span> <span class=\"n\">ℤ</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">ab</span><span class=\"o\">,</span> <span class=\"n\">int.cast_inj.mp</span> <span class=\"n\">ab</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">B</span> <span class=\"o\">:=</span> <span class=\"n\">algebra_map.injective.linear_independent</span> <span class=\"n\">A</span> <span class=\"n\">bv.1</span><span class=\"o\">,</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">hb</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span>\n    <span class=\"n\">submodule.exists_is_basis_of_le_span</span> <span class=\"n\">B</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">inf_le_right</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">submodule.restrict_scalars</span> <span class=\"n\">ℤ</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n  <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">convert</span> <span class=\"n\">hb</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>I disabled <code>add_comm_group.int_module</code>, and instead assumed <code>[semimodule ℤ V] \n[is_scalar_tower ℤ ℚ V]</code> to make sure that we did not use the bad int module structure, and instead used a generic one.</p>\n<p><em>But</em>: the proof is way too slow (62s on my computer), so this is not acceptable.</p>",
        "id": 232720785,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1617265453
    },
    {
        "content": "<p>Thanks Sébastien!  This is looking much better (albeit slow) now!</p>\n<p>While we are at it, I wanted your <code>A</code> statement to be already in mathlib, but I could not find it: is it hiding in there somewhere?</p>\n<p>[Also, on my computer the proof is so slow that it times out...]</p>",
        "id": 232721106,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1617265653
    },
    {
        "content": "<p>Yes, the proof is clearly wrong now. I'm not able to find the culprit for now, sorry...</p>",
        "id": 232722152,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1617266271
    },
    {
        "content": "<p>Even <code>convert hb using 1</code> takes time (essentially the same amount of time as far as I can see).</p>",
        "id": 232722898,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1617266668
    },
    {
        "content": "<p>Minimal diamond:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">linear_algebra.free_module</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"n\">algebra.id</span> <span class=\"n\">ℤ</span> <span class=\"bp\">=</span> <span class=\"n\">algebra_int</span> <span class=\"n\">ℤ</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span> <span class=\"c1\">-- fails</span>\n</code></pre></div>\n<p>both instances are registered in mathlib.</p>",
        "id": 232723948,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1617267314
    },
    {
        "content": "<p>I tried turning <code>-instance algebra_int</code> off but that hadn't helped in my experiments.</p>",
        "id": 232724109,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1617267418
    },
    {
        "content": "<p>We need a better way to deal with these \"initial objects\"</p>",
        "id": 232724877,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1617267835
    },
    {
        "content": "<p>The thing is that these instances are used in other files when defining various objects, so it is already too late. Maybe changing <code>algebra.id</code> to something nicer would help (expanding the fields instead of relying on an abstract construction).</p>",
        "id": 232724878,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1617267835
    },
    {
        "content": "<p>I played a little bit more with this. My conclusion is that \"Yury's rule of thumb\" for decidable instances should also apply in this situation. We need to find a better name for this rule, but it amounts to: \"in a context where there is a subsingleton with data, and several natural instances of it which are not defeq, then mention the instance explicitly in theorems that use it\".</p>\n<p>As <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span>  has pointed out several times, we are exactly in this situation here. For instance, if <code>E</code> and <code>F</code> are two <code>add_comm_group</code>, then they are both <code>ℤ</code>-modules, and then you get two non-defeq <code>ℤ</code> module instances on <code>E x F</code>, the one coming from the <code>add_comm_group</code> instance and the one coming from the module product instance. And there is no way to make these defeq. </p>\n<p>A solution is to <em>not</em> register <code>add_comm_group.nat_semimodule</code> as a global instance, and only use it when needed in proofs, and use suitable typeclass assumptions in statements. (Or register it as a global instance, but only once we are sure that it's not used in statements, and only to make it available for proofs -- this could probably be enforced by a linter). I had a go at refactoring mathlib along these lines, to see how things go. The good news is that, with this refactor, the above problem in this thread completely disappears, i.e., no need for <code>convert</code> or whatever. And a few proofs that were painful because of instance mismatch become smoother. The bad news is that I'm not done fixing it, because there are many places where the previous instance is used. My work in progress is in the branch <a href=\"https://github.com/leanprover-community/mathlib/tree/gsmul_instance\">branch#gsmul_instance</a>, if anyone wants to have a look/fix a few proofs.</p>",
        "id": 232796868,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1617299232
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span> thanks a lot for all your debugging, and your efforts for refactoring!</p>",
        "id": 232799711,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1617300367
    },
    {
        "content": "<p>I'm coming around to these ideas of disabling these global instances</p>",
        "id": 232799796,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1617300400
    },
    {
        "content": "<p>Sébastien, thank you so much for looking into this!  I am only superficially following the discussion, but I find it interesting to see how much I am used to abuse notations and definitions and how Lean picks up on it!</p>",
        "id": 232800113,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1617300544
    },
    {
        "content": "<p>Another option would be to use <code>gsmul</code> and <code>nsmul</code> in lemma statements, and convert to smul and back inside the lemma</p>",
        "id": 232804481,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1617302326
    },
    {
        "content": "<p>The problem with <code>gsmul</code> and <code>nsmul</code> is that all the linear algebra lemmas do not apply (for instance, when you want to use the fact that a linear map satisfies <code>f (c • v) = c • f v</code>, this won't work out of the box for <code>gsmul</code>). So they are really a pain to use together with linear algebra.</p>",
        "id": 232804824,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1617302467
    },
    {
        "content": "<p>Somehow, in LTE we're in this weird limbo, where we use additive group homomorphisms, but also scalar multiplication.</p>",
        "id": 232808302,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1617303876
    },
    {
        "content": "<p>And one of my reasons is extremely mundane: the notation for scalar multiplication is just nicer than <code>gsmul/nsmul</code>. And at the same time the notation for group homs looks better than that for linear maps (especially if you are just working with <code>Z</code>-modules anyway).</p>",
        "id": 232808436,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1617303934
    },
    {
        "content": "<p>I've uploaded here<br>\n<a href=\"https://github.com/leanprover-community/lean-liquid/blob/riccardobrasca/src/toric/towards_Gordan.lean\">https://github.com/leanprover-community/lean-liquid/blob/riccardobrasca/src/toric/towards_Gordan.lean</a><br>\na proof of <code>pre_generators_finite</code>. I am little tired to golf it, but as usual if someone wants to play with it no problem.</p>\n<p>The idea of the proof is very simple: the function <code>i</code> takes a pre_generator <code>g</code> and sends it to the set <code>t</code> of the definition. Since <code>t ⊆ s</code> and <code>s</code> is finite, it is enough to prove that <code>i</code> is injective. The mathematical proof is between the lines <code>197</code> and <code>218</code>. The rest of the proof is me fighting against <code>classical.some</code> and the fact that to use <code>fintype.of_injective</code> the codomain of <code>i</code> must be <code>set s</code>, but morally the \"true\" codomain, where it's easier to work, is <code>set M</code>.</p>",
        "id": 232821738,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1617309665
    },
    {
        "content": "<p>Note that here the problem is my inexperience, Lean seems innocent.</p>",
        "id": 232822045,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1617309838
    },
    {
        "content": "<p>What I am still confused/surprised about is that surely all of these issues were experienced by people using Coq or Agda or UniMath or whatever?</p>",
        "id": 232827797,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1617312564
    },
    {
        "content": "<p>Do you have to say fintype? Or can you just prove set.finite pre_generators f s when set.finite s?</p>",
        "id": 232831639,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1617314694
    },
    {
        "content": "<p>Because you get noncomputable fintype from set.finite anyway</p>",
        "id": 232831674,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1617314715
    },
    {
        "content": "<p>And then you don't have to juggle sort coercions</p>",
        "id": 232831696,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1617314730
    },
    {
        "content": "<p>I don't know, <span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span> wrote the statement and I didn't want to modify it... my current goal is just to get familiar with convex geometry in Lean</p>",
        "id": 232832298,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1617315072
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"308899\">Yakov Pechersky</span> <a href=\"#narrow/stream/267928-condensed-mathematics/topic/toric/near/232831639\">said</a>:</p>\n<blockquote>\n<p>Do you have to say fintype? Or can you just prove set.finite pre_generators f s when set.finite s?</p>\n</blockquote>\n<p>That sounds like it might help. (But I haven't looked at the code yet.)</p>",
        "id": 232859264,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1617338121
    },
    {
        "content": "<p>I have not finished writing a full proof, so the stuff in <code>towards_Gordan</code> is still subject to change.  However, I try to give indications of what is important in each statement in the doc-strings above each lemma.  If a change in an assumption makes the proof simpler, and leaves the statement \"essentially the same\", feel free to go for it!</p>\n<p>Some of these statements might have to be changed anyways, since I decided to go for a full <code>sorry</code>-explosion, rather than figuring out what the best way of doing things is step-by-step.</p>",
        "id": 232862020,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1617340998
    },
    {
        "content": "<p>What I do try, though, is to make the statements \"true\": hopefully this also makes them provable!  <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 232862109,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1617341061
    },
    {
        "content": "<p>Also, the reason I used <code>fintype</code> is because I read somewhere that <code>fintype</code>s were easier than <code>finset</code>s.  If <code>set.finite</code> is even easier, then I would probably change finiteness assumptions everywhere to <code>set.finite</code>!</p>",
        "id": 232864238,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1617343367
    },
    {
        "content": "<p>My understanding is that the power of <code>finset</code> and <code>fintype</code> is their computability. If you're going to already mark it as <code>noncomputable</code>, then you can make your statements be about <code>set.finite</code> because of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/set.finite.fintype\">docs#set.finite.fintype</a>, which will give you a noncomputable fintype anyway</p>",
        "id": 232864792,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1617343897
    },
    {
        "content": "<p>Because <code>set.finite s</code> is just <code>nonempty (fintype s)</code></p>",
        "id": 232864857,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1617343941
    },
    {
        "content": "<p>Ok, from <code>nonempty (fintype s)</code> I would deduce that <code>s</code> is going to be <code>non-empty</code>?  I am not sure if I like this: I am usually careful about including the empty set in my statements, excluding it only when the statement is false for the empty set.  The possibility of having an empty set is often simplifying for proofs.</p>",
        "id": 232865213,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1617344305
    },
    {
        "content": "<p>Ah, maybe the <code>nonempty</code> is simply the assertion that there is a <code>fintype</code> structure on <code>s</code>, possibly with <code>s</code> being the empty <code>finset</code>?</p>",
        "id": 232865247,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1617344362
    },
    {
        "content": "<p>You don't have to unfold what <code>set.finite</code> is to prove things about it, which is what's nice. I don't know if the relevant lemmas get easier to prove in that API. But I'd think anything that can be proven about fintype implying fintype should be easier across set.finite, and if it isn't, then that's missing API.</p>",
        "id": 232865643,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1617344699
    },
    {
        "content": "<p>Ok, I will try to replace <code>fintype</code> with <code>set.finite</code>!</p>",
        "id": 232866132,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1617345198
    },
    {
        "content": "<p>So, the expectation is that this statement</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">fg_with_basis</span> <span class=\"o\">(</span><span class=\"n\">vm</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">is_full_on</span> <span class=\"n\">f</span> <span class=\"n\">v</span> <span class=\"n\">vm</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">M</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">set.range</span> <span class=\"n\">vm</span><span class=\"o\">)</span> <span class=\"bp\">⊆</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">N</span><span class=\"o\">,</span> <span class=\"n\">set.finite</span> <span class=\"n\">g</span> <span class=\"bp\">∧</span> <span class=\"n\">dual_set</span> <span class=\"n\">nat_submodule</span> <span class=\"n\">f</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"n\">submodule.span</span> <span class=\"n\">ℕ</span> <span class=\"n\">g</span> <span class=\"o\">:=</span>\n</code></pre></div>\n<p>should be easier than</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">fg_with_basis</span> <span class=\"o\">(</span><span class=\"n\">vm</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">is_full_on</span> <span class=\"n\">f</span> <span class=\"n\">v</span> <span class=\"n\">vm</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">M</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">set.range</span> <span class=\"n\">vm</span><span class=\"o\">)</span> <span class=\"bp\">⊆</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">N</span><span class=\"o\">,</span> <span class=\"n\">dual_set</span> <span class=\"n\">nat_submodule</span> <span class=\"n\">f</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"n\">submodule.span</span> <span class=\"n\">ℕ</span> <span class=\"n\">g</span> <span class=\"o\">:=</span>\n</code></pre></div>\n<p>right?  (The only intended difference is in the properties of the asserted existence of <code>g</code>.)</p>",
        "id": 232866472,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1617345499
    },
    {
        "content": "<p>Yeah, possibly</p>",
        "id": 232866508,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1617345574
    },
    {
        "content": "<p>Ok, I pushed the change.</p>\n<p>Thanks!</p>",
        "id": 232866533,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1617345600
    },
    {
        "content": "<p>As long as it is not likely harder, I am happy to go with whatever!</p>",
        "id": 232866605,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1617345628
    },
    {
        "content": "<p>And something like this (if one really wanted to refactor the lemma):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">pre_generators_finite</span> <span class=\"o\">(</span><span class=\"n\">bv</span> <span class=\"o\">:</span> <span class=\"n\">is_basis</span> <span class=\"n\">ℤ</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">s.finite</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">pre_generators</span> <span class=\"n\">f</span> <span class=\"n\">s</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">finite</span> <span class=\"o\">:=</span>\n</code></pre></div>",
        "id": 232866614,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1617345633
    },
    {
        "content": "<p>Ah, I used</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">pre_generators_finite</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fs</span> <span class=\"o\">:</span> <span class=\"n\">set.finite</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">set.finite</span> <span class=\"o\">(</span><span class=\"n\">pre_generators</span> <span class=\"n\">f</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n</code></pre></div>\n<p>which should simply be your version, without taking advantage of dot-notation, right? <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 232866664,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1617345708
    },
    {
        "content": "<p>(There is an <code>include bv</code> in the file that I am using.)</p>",
        "id": 232866723,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1617345737
    },
    {
        "content": "<p>Yeah. For example, this is the goal after these steps</p>",
        "id": 232866737,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1617345758
    },
    {
        "content": "<p>(However, I suspect that <code>bv</code> plays no role in the proof.)</p>",
        "id": 232866753,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1617345785
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">pre_generators_finite</span> <span class=\"o\">(</span><span class=\"n\">bv</span> <span class=\"o\">:</span> <span class=\"n\">is_basis</span> <span class=\"n\">ℤ</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">s.finite</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">pre_generators</span> <span class=\"n\">f</span> <span class=\"n\">s</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">finite</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">pre_generators</span><span class=\"o\">,</span>\n  <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"n\">submodule.ext'_iff</span><span class=\"o\">,</span> <span class=\"n\">set.ext_iff</span><span class=\"o\">,</span> <span class=\"n\">submodule.mem_coe</span><span class=\"o\">,</span> <span class=\"n\">mem_dual_set</span><span class=\"o\">],</span>\n  <span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">  {c : N |</span>\n<span class=\"cm\">    (∀ (m : M), m ∈ s → ⇑(⇑f m) c ∈ nat_submodule) ∧</span>\n<span class=\"cm\">    ∃ (t : set M) (H : t ⊆ s), ∀ (x : N),</span>\n<span class=\"cm\">      (∀ (m : M), m ∈ {1, -1} • t → ⇑(⇑f m) x ∈ nat_submodule) ↔ x ∈ submodule.span ℕ {c}}.finite</span>\n<span class=\"cm\">  -/</span>\n  <span class=\"gr\">sorry</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 232866779,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1617345821
    },
    {
        "content": "<p>In my version, the <code>simp_rw submodule.ext'_iff</code> does not work:</p>",
        "id": 232866864,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1617345891
    },
    {
        "content": "<p>Then you can use things like </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">refine</span> <span class=\"n\">set.finite.subset</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">set.inter_subset_right</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n</code></pre></div>\n<p>to prove finiteness solely on the right hand side of the condition, if that is sufficient</p>",
        "id": 232866870,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1617345901
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">invalid</span> <span class=\"n\">simplification</span> <span class=\"kd\">lemma</span> <span class=\"bp\">'</span><span class=\"n\">submodule.ext'_iff'</span> <span class=\"o\">(</span><span class=\"n\">use</span> <span class=\"n\">command</span> <span class=\"bp\">'</span><span class=\"kd\">set_option</span> <span class=\"n\">trace.simp_lemmas</span> <span class=\"n\">true'</span> <span class=\"n\">for</span> <span class=\"n\">more</span> <span class=\"n\">details</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 232866890,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1617345910
    },
    {
        "content": "<p>which branch are you on?</p>",
        "id": 232866926,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1617345949
    },
    {
        "content": "<p>I am on <code>toric</code>, the one that I just pushed.</p>",
        "id": 232866973,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1617345971
    },
    {
        "content": "<p>Ok, looking at the proof that Riccardo wrote, I think that it should make use of <code>is_cyclic</code>.  This probably means that I should change the definition of pre_generators.  This will probably make the coercion to type of a set simpler, by going via a subtype instead.</p>",
        "id": 232867343,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1617346318
    },
    {
        "content": "<p>However, I will not have time to do this before Monday: I have some non-Lean Easter plans!</p>",
        "id": 232867419,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1617346376
    },
    {
        "content": "<p>Thank you all for your feedback: I really have the impression that we are making good progress on Gordan's lemma!</p>",
        "id": 232867450,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1617346405
    },
    {
        "content": "<p>The <code>ext'_iff</code> lemma is now a part of <code>set_like</code> after a refactor</p>",
        "id": 232867684,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1617346666
    },
    {
        "content": "<p>Now it would be <code>  simp_rw [@set_like.ext_iff (submodule ℕ N) N]</code></p>",
        "id": 232867785,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1617346783
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span> If you happy with <code>set.finite</code> I can do it.</p>",
        "id": 232872035,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1617350297
    },
    {
        "content": "<p>BTW I use <code>bv</code> to prove that <code>M</code> is torsion free.</p>",
        "id": 232872088,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1617350368
    },
    {
        "content": "<p>I think that the version that I pushed to <code>toric</code> has <code>set.finite</code> and also your proof of the reduction to Z.</p>\n<p>I need to think about <code>bv</code>: I did not think that it was needed, but it is an important assumption for the final result anyway!</p>",
        "id": 232877508,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1617354427
    },
    {
        "content": "<p>My mathematical proof is the following: I have to prove that a pre_generator <code>g</code> is determined by the subset <code>t</code> of the definition. If <code>g₁</code> and <code>g₂</code> are associated to the same subset, then <code>submodule.span ℕ {g₁} = submodule.span ℕ {g₂}</code>, by definition. So there are <code>a b : ℕ</code> such that <code>g₁ = a • g₂</code> and <code>g₂ = b • g₁</code> so <code>g₁ = a • b • g₁ = (a * b) • g₁</code>.  Now I want <code>a * b = 1</code> (or <code>g₁ = 0</code>), and here is where I used torsion freeness.</p>",
        "id": 232878718,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1617355352
    },
    {
        "content": "<p>I pushed to <code>toric</code> the new proof of <code>pre_generators_finite</code>. It is indeed better then before. For some reason I am not able to define <code>i</code> using <code>if</code> <code>then</code> <code>else</code> and so I did it in tactic mode.</p>",
        "id": 232885298,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1617360210
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110050\">Sebastien Gouezel</span> <a href=\"#narrow/stream/267928-condensed-mathematics/topic/toric/near/232796868\">said</a>:</p>\n<blockquote>\n<p>A solution is to <em>not</em> register <code>add_comm_group.nat_semimodule</code> as a global instance, and only use it when needed in proofs, and use suitable typeclass assumptions in statements. (Or register it as a global instance, but only once we are sure that it's not used in statements, and only to make it available for proofs -- this could probably be enforced by a linter). I had a go at refactoring mathlib along these lines, to see how things go. The good news is that, with this refactor, the above problem in this thread completely disappears, i.e., no need for <code>convert</code> or whatever. And a few proofs that were painful because of instance mismatch become smoother. The bad news is that I'm not done fixing it, because there are many places where the previous instance is used. My work in progress is in the branch <a href=\"https://github.com/leanprover-community/mathlib/tree/gsmul_instance\">branch#gsmul_instance</a>, if anyone wants to have a look/fix a few proofs.</p>\n</blockquote>\n<p>I have worked a bit more on this. Now, I am stuck in Witt vectors, where there is a tactic to be adjusted and I don't know anything about tactics. Or maybe set a global instance for all these files. An expert look would be most welcome :-)</p>",
        "id": 232903782,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1617373085
    },
    {
        "content": "<p>Never mind, problem solved :-)</p>",
        "id": 232909098,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1617375846
    },
    {
        "content": "<p>Wow, I'm glad it is already solved! Otherwise, I would certainly have tried to help.</p>",
        "id": 232936857,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1617389196
    },
    {
        "content": "<p>I feel somewhat responsible for maintaining Witt vectors (-;</p>",
        "id": 232936884,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1617389210
    },
    {
        "content": "<p>Riccardo, this is also more or less what I had in mind and it is certain sufficient for the application to Gordan's lemma.  You could probably get away without <code>bv</code>, observing that a cyclic <code>nat</code> module has finitely many generators (1, if it is infinite and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ϕ</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\phi (n)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">ϕ</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span> if it has <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> elements).  However, it might be better to observe that there are finitely many subsets that produce a cyclic module and bypass the second issue altogether!</p>",
        "id": 232944375,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1617393447
    },
    {
        "content": "<p>Well, not everything is solved in the Witt vectors part yet, which is probably the most painful part for now :-) I wanted to see how much work it would be to make the change, and it is much more than I expected -- which is a sign that mathlib is now pretty big, in fact big enough that such refactors become nontrivial.</p>",
        "id": 232944412,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1617393472
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span> I think I figured out how to fix the tactic in Witt vectors</p>",
        "id": 232983465,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1617428676
    },
    {
        "content": "<p>You need an extra <code>intro</code> to take care of the <code>algebra</code> instance.</p>",
        "id": 232983476,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1617428694
    },
    {
        "content": "<p>I've pushed a bunch of fixes. We need to add an instance <code>algebra int (zmod n)</code>. I haven't done that yet, but it should fix the remaining problems (I hope!)</p>",
        "id": 232984204,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1617429704
    },
    {
        "content": "<p>Pushed that instance for <code>zmod</code>, let's see what CI thinks of it.</p>",
        "id": 232984519,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1617430083
    },
    {
        "content": "<p>OK I am trying to get on top of this Gordan's Lemma thing. As far as I can see, in <code>master</code> we have a file <code>toric/lem97.lean</code> which contains a complete proof of Lemma 9.7 of <code>analytic.pdf</code> modulo </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">explicit_gordan</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"bp\">Λ</span> <span class=\"o\">:</span> <span class=\"n\">finite_free</span> <span class=\"bp\">Λ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">ι</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"bp\">Λ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">explicit_dual_set</span> <span class=\"n\">l</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">fg</span> <span class=\"o\">:=</span>\n<span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Here <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Λ</mi></mrow><annotation encoding=\"application/x-tex\">\\Lambda</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\">Λ</span></span></span></span> is a finite free <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\Z</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Z</span></span></span></span></span>-module, and<code>explicit_dual_set l</code> is the sub-<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">N</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{N}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">N</span></span></span></span></span>-module of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi mathvariant=\"normal\">Λ</mi><mo>∗</mo></msup><mo>:</mo><mo>=</mo><mi>H</mi><mi>o</mi><mi>m</mi><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">Λ</mi><mo separator=\"true\">,</mo><mi mathvariant=\"double-struck\">Z</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\Lambda^*:=Hom(\\Lambda,\\Z)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.688696em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">Λ</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.688696em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.36687em;vertical-align:0em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">m</span><span class=\"mopen\">(</span><span class=\"mord\">Λ</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Z</span></span><span class=\"mclose\">)</span></span></span></span> consisting of things which pair to something non-negative with the image of <code>l</code>; the claim is that it's finitely-generated as an <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">N</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{N}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">N</span></span></span></span></span>-module. Clearly <code>explicit_gordan</code> is what we should be aiming for.</p>\n<p>I've been trying to make some sense of the <code>toric</code> branch, which right now contains quite a lot of what seems to me to be dead code and commented code. I've made a couple of recent commits to this branch adding some docstrings, although right now it seems to me like the branch is more like an experimental playground rather than something which will ultimately be merged into <code>master</code> -- which is fine, we have branches of mathlib which are like this, and when stuff is working then it gets migrated into new branches which get PR'ed. I'm kind of guessing that this is the plan here too.</p>\n<p>What I cannot extract from this branch right now is where we are going. I talked to Damiano yesterday and my understanding is that the formalisation of the proof of Gordan's Lemma is going on in the file <code>toric.towards_Gordan</code> on the <code>toric</code> branch. I note with a little concern that it's not actually proving the precise statement which we need in <code>lem97</code> though, and sometimes glue is harder than you think. But my main concern is that I cannot see the wood for the trees right now and if I don't know what we're formalising then it's hard to jump in.</p>\n<p>So I propose making a mini-blueprint to explain where we're going. There are a whole bunch of comments in <code>toric.towards_Gordan</code> which Damiano said might help but right now they're not enough for me (I don't know much at all about toric geometry though).</p>\n<p>I have uploaded a file <code>toric/gordan_blueprint.tex</code> to the <code>toric</code> branch, which right now is a bunch of questions about stuff on the <code>toric</code> branch and nowhere near a mathematical proof. If someone (<span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span> or <span class=\"user-mention\" data-user-id=\"130384\">@Riccardo Brasca</span> or <span class=\"user-mention\" data-user-id=\"300245\">@Filippo A. E. Nuccio</span>  -- you seem to be the active contributors to this branch) can perhaps turn this tex sketch into a mathematical proof -- forget the formalisation for now -- then we can perhaps decide how best to formalise it. Is there a proof you guys have in mind?</p>",
        "id": 233966679,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618070330
    },
    {
        "content": "<p>I've just googled around a bit. Is the idea that we're formalising the \"topological proof\" in <a href=\"https://en.wikipedia.org/wiki/Gordan%27s_lemma\">Wikipedia</a>?</p>",
        "id": 233967233,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618070814
    },
    {
        "content": "<p>I'm not entirely sure I understand the Wikipedia proof right now. Is it using some result of the form \"double dual of a fg cone (:= <code>nnreal</code>-submodule) in a real vector space is itself? Or maybe \"dual of an fg cone is fg\"? Are these things obvious?</p>",
        "id": 233969467,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618073041
    },
    {
        "content": "<p>Dear Kevin,</p>\n<p>thank you very much for your effort!  I am not sure that I will have time to work on this right now, but I will take a serious look next week.</p>\n<p>I have been making PRs to mathlib as I was going along, to move the more \"stable\" part.  For this reason, the stuff left in <code>toric</code> is less coherent.  I have started making the file <code>towards_Gordan</code> with the idea of making it a path towards a proof of Gordan's lemma, but I feel that it became \"public\"  a little too early.</p>\n<p>I have had conversations with Johan about the \"glue\" and he also agreed that what will come out of the <code>toric</code> branch should be easily converted to what is the explicit Gordan statement.  I was trying to prepare the <code>towards_Gordan</code> file to a level that was usable to someone who did not know the proof of Gordan's lemma, but, given Kevin's unsuccessful effort, I am not done doing it!</p>",
        "id": 233969559,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1618073115
    },
    {
        "content": "<p>Yes, the proof that I am formalising is close to the topological proof in wikipedia.  I gave a <em>very</em> rough outline of the main steps in a conversation with Peter, let me fetch it!</p>",
        "id": 233969661,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1618073189
    },
    {
        "content": "<p>This is an outline:</p>\n<p><a href=\"#narrow/stream/267928-condensed-mathematics/topic/toric/near/232555538\">https://leanprover.zulipchat.com/#narrow/stream/267928-condensed-mathematics/topic/toric/near/232555538</a></p>",
        "id": 233969715,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1618073230
    },
    {
        "content": "<p>What is an \"octant\" and what is an \"extremal ray\"?</p>",
        "id": 233970180,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618073640
    },
    {
        "content": "<p>\"Octant\" (in a vector space/Z-module) is the set of all vectors with non-negative coordinates, with respect to a basis.</p>",
        "id": 233970236,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1618073677
    },
    {
        "content": "<p>In the Lean formalization is what I would have called <code>pointed</code>, except that you noticed that the definition was not correct.  Luckily, I had not started using this.  The good thing about \"octants\" (or <code>nat</code>-submodules of octants), is that they have finitely many extremal rays. (Which I am now going to define.)</p>",
        "id": 233970315,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1618073763
    },
    {
        "content": "<p>An extremal ray is a one-dimensional subcone of a cone with the property that is <code>c d</code> are in the cone and <code>c + d</code> is in the extremal ray, then <code>c</code> and <code>d</code> are actually already in the extremal ray.</p>",
        "id": 233970390,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1618073814
    },
    {
        "content": "<p>In intuitive terms, extremal rays are the \"edges\" of the cone.</p>\n<p>What should be proved is that the elements of the cone are in the convex hull of the extremal rays... up to saturation.  Thus, we should prove that there are finitely many extremal rays <em>and</em> that the saturation only adds finitely many more elements.</p>",
        "id": 233970477,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1618073892
    },
    {
        "content": "<p>Finite generation of extremal rays follows from the fact that extremal rays are correspond to what is called, I think, pre_generators in <code>toric</code> (the relationship between extremal rays and pre_generators needs to be proven).</p>",
        "id": 233970530,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1618073961
    },
    {
        "content": "<p>(pre_generators being finite is \"easy\" and, if I remember correctly, already proven, in some form.)</p>",
        "id": 233970547,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1618073989
    },
    {
        "content": "<p>Finiteness of saturating elements is the \"topological part of the proof: once you have the finitely many generators extremal rays, you are missing the elements inside the cone that are convex combinations of the generators of the extremal rays with non-negative and bounded above real coefficients.</p>",
        "id": 233970709,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1618074080
    },
    {
        "content": "<p>Thus, these \"new\" elements are contained in a compact set (the real combinations) and in a discrete subset (they are in the integral subcone).  Hence there are only finitely many of them.</p>",
        "id": 233970798,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1618074126
    },
    {
        "content": "<p>I'm still trying to get all this stuff straight.</p>\n<p>It seems to me that sometimes people talk about real vector spaces and sometimes free Z-modules. As far as I can see we dont need real anything, we can stick to vector spaces over the rationals.</p>\n<p>You say that <code>pointed</code> is supposed to be an octant, but you proved that {0} was pointed and in your definition an octant in a real vector space will always be a manifold with dimension the same as that of the underlying space. </p>\n<p>Is your definition of extremal ray for Q-vector spaces or Z-modules? What is a \"cone\"? Are you using the word to mean both a f.g. Q_+-submodule of a Q-module and a f.g. N-submodule of a Z-module? I'm sorry for all the questions, I really think we need to be very precise about these things though. If sub-N-modules of Z-modules can be cones, are they all saturated or not?</p>\n<p>\"What should be proved is that the elements of the cone are in the convex hull of the extremal rays..\" -- I don't even know now whether you're over Q or over Z.</p>\n<p>Can you be more precise about all of this? I am still struggling to understand the precise definitions of everything.</p>",
        "id": 233971491,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618074799
    },
    {
        "content": "<p>Can we prefix everything with Q- or Z-? Are Z-cones by definition finitely generated? Are they saturated?</p>",
        "id": 233971581,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618074869
    },
    {
        "content": "<p>Ok, the reason I was being a little sloppy is that we definitely need to have these notions interacting nicely with <code>nat</code>- <code>int</code>- <code>rat</code>- and (to a <em>much</em> lesser extent) <code>real</code>.</p>",
        "id": 233971614,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1618074905
    },
    {
        "content": "<p>Let me answer more in detail your questions.</p>",
        "id": 233971635,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1618074920
    },
    {
        "content": "<p>First, \"octant\" is what I said before its Lean formalisation.  As you remark, is always \"of the top dimension\".  Cones inside an octant, though, need not have that dimension: as you say, <code>0</code> is a cone inside any octant and is therefore pointed.</p>",
        "id": 233971777,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1618075033
    },
    {
        "content": "<p>The Lean formalization of <code>pointed</code> is more general.  Since I want to be able to convert between various coefficients, let me give a few types, with their standard interpretation.</p>",
        "id": 233971866,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1618075107
    },
    {
        "content": "<p>There are three main \"coefficient\" types: <code>N</code>, <code>Z</code>, <code>Q</code>.  I will let you guess what they are in the standard application.</p>",
        "id": 233971908,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1618075154
    },
    {
        "content": "<p>The only tricky one is that, at one point, we will want to allow <code>Q</code> to be the reals, but for the most part (and, really, even in the last step) we can always get away with the rationals.</p>",
        "id": 233971934,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1618075197
    },
    {
        "content": "<p>The three types <code>N</code>, <code>Z</code> and <code>Q</code> are ordered semirings, they form a <code>scalar_tower</code> of <code>algebra</code>s, the elements of <code>N</code> are \"nonnegative\" in <code>Q</code> and you can also assume that <code>algebra_map R S</code> is injective (cf <code>is_inj_nonneg</code>).</p>",
        "id": 233972111,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1618075321
    },
    {
        "content": "<p>Cones, refers to a <code>submodule.span N s</code>, where <code>s</code> is a subset of a <code>Q</code>-module.</p>",
        "id": 233972181,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1618075364
    },
    {
        "content": "<p>Extremal rays are one-dimensional subcones of a <code>pointed</code> cone (not really sure whether we want the definition to also apply to non-pointed stuff).  Thus, we reduce from a general cone (which could be the <code>nat</code>-span of <code>1, -1</code> inside <code>rat</code>, i.e. <em>not</em> a <code>pointed</code> cone), to a <code>pointed</code> cone, by \"splitting in halfs and combining\".</p>",
        "id": 233972366,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1618075537
    },
    {
        "content": "<p>Before I describe this process more in detail, let me explain how you \"construct\" cones.</p>",
        "id": 233972432,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1618075579
    },
    {
        "content": "<p>This is via the <code>dual_set</code> process.</p>",
        "id": 233972447,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1618075590
    },
    {
        "content": "<p>For duals, the setup is that there are two <code>Q</code>-modules <code>M</code> and <code>N</code> and a bilinear <code>pairing</code>, typically denoted by <code>f</code>, mapping <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><mo>×</mo><mi>N</mi><mo>→</mo><mi>Q</mi></mrow><annotation encoding=\"application/x-tex\">M \\times N \\to Q</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8777699999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">Q</span></span></span></span>.</p>",
        "id": 233972575,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1618075715
    },
    {
        "content": "<p>A <code>dual_set</code> is \"essentially\" a cone: given a subset <code>s</code> of <code>M</code>, the corresponding <code>dual_set</code> is the set of all elements of <code>N</code> that have non-negative pairing with <code>s</code>.</p>",
        "id": 233972754,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1618075873
    },
    {
        "content": "<p>A <code>dual_set</code> is automatically an <code>N</code>-submodule and it is also automatically saturated.</p>",
        "id": 233972825,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1618075928
    },
    {
        "content": "<p>Thus, the statement of Gordan's lemma (if I have not missed anything) is as follows:</p>",
        "id": 233972853,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1618075962
    },
    {
        "content": "<p>(I noticed now the clash in notation <code>N</code> refers to the natural numbers look-alike as well as the <code>Q</code>-module: I will try to use latex font <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span> for the module.)</p>\n<p>Let <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span> be <code>Q</code>-modules, <em>with a fixed finite basis</em>.  The basis is important, since we are going to talk about \"integral\" (resp. \"non-negative\") elements of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span> and  and they are the <code>Z</code>- (resp. <code>N</code>-)linear combinations of the elements of the basis.</p>\n<p>Assume that the pairing <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mspace></mspace><mspace width=\"0.1111111111111111em\"></mspace><mo lspace=\"0em\" rspace=\"0.17em\"></mo><mtext> ⁣</mtext><mo lspace=\"0em\" rspace=\"0em\">:</mo><mspace width=\"0.3333333333333333em\"></mspace><mi>M</mi><mo>×</mo><mi>N</mi><mo>→</mo><mi mathvariant=\"double-struck\">Q</mi></mrow><annotation encoding=\"application/x-tex\">f \\colon M \\times N \\to \\mathbb{Q}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace nobreak\"></span><span class=\"mspace\" style=\"margin-right:0.1111111111111111em;\"></span><span class=\"mpunct\"></span><span class=\"mspace\" style=\"margin-right:-0.16666666666666666em;\"></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mrel\">:</span></span><span class=\"mspace\" style=\"margin-right:0.3333333333333333em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.85556em;vertical-align:-0.16667em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Q</span></span></span></span></span> is \"perfect\" (what we really want is that every element of the linear dual of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span> is represented by pairing with some element of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span>).</p>\n<p>Start with a finite set <code>s</code> of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span>.<br>\nThe <code>dual_set</code> of <code>s</code> is an <code>N</code>-submodule of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span>.  The \"integer\" elements of this submodule admit a finite generating set, of course as an <code>N</code>-module, which is the only thing that type-checks.</p>",
        "id": 233973358,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1618076424
    },
    {
        "content": "<p>I hope that this clarifies a bit more your doubts.  I might have missed some further confusion: please, ask again, if there are unclear points!!</p>",
        "id": 233973401,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1618076468
    },
    {
        "content": "<p>Ah, there was the issue of finite generation of cones: they need not be, and we are exactly trying to prove that <em>some</em> cones are finitely generated.</p>\n<p>Also, cones are <code>N</code>-spans of stuff: they might be <code>Z</code>-spans, for instance if you use a <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>±</mo></mrow><annotation encoding=\"application/x-tex\">\\pm</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord\">±</span></span></span></span>-symmetric generating set, but they need not be.</p>",
        "id": 233973602,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1618076654
    },
    {
        "content": "<p>Cones need not be saturated, but the ones that arise from <code>dual_set</code> automatically are.</p>",
        "id": 233973612,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1618076674
    },
    {
        "content": "<p>Also, cones with finitely many extremal rays <em>need not</em> be finitely generated: this is why the fact that the ones arising as <code>dual_set</code> are <em>automatically saturated</em> is important.</p>",
        "id": 233973674,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1618076738
    },
    {
        "content": "<p>Finally, a comment about the reals: the whole proof can take place with rational coefficients.  The only \"real\" input is in proving that the set of integral vectors inside the span of finitely many vectors with coefficients in <code>[0, 1]</code> is finite.  The \"easy\" way is to use real coefficients, the set of linear combinations is compact, the set of integer vectors is discrete, hence the intersection is finite.</p>",
        "id": 233973821,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1618076871
    },
    {
        "content": "<p>Of course, you do not \"need\" real combinations, but it is convenient to have them.  Thus, working with a more \"generic\" type of coefficients is probably a better idea.</p>",
        "id": 233973883,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1618076910
    },
    {
        "content": "<blockquote>\n<p>\"What should be proved is that the elements of the cone are in the convex hull of the extremal rays..\" -- I don't even know now whether you're over Q or over Z.</p>\n</blockquote>\n<p>In the \"maths world\" we should prove that the elements of the <code>dual_set</code> that happen to have integer coordinates are non-negative rational linear combinations of elements of the extremal rays.  Of course, such combinations will <em>not</em> all be integrals, but some will and all those that are rationals we want to take.  Once we have this \"non-negative rational generating set\" for our dual cone, we start worrying about generating over the naturals.  For that, we use the integral generators of the extremal rays as a first guess.  These are finitely many, by some result that is \"almost\" formalized.  Now the issue is just one of saturation: every integral element of the cone has a positive natural multiple that is a natural-linear combination of these generators of the extremal rays.  Thus, we want to \"divide\" by these multiples.</p>",
        "id": 233974146,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1618077233
    },
    {
        "content": "<p>An example to keep in mind is the cone generated by <code>(1,0), (1,2)</code>.  The background basis is the standard one <code>(1,0), (0,1)</code>: integral refers to integral linear combinations of these last two elements.</p>\n<p>The extremal rays are the non-negative (rational or natural, not especially important) multiples of the two given vectors <code>(1,0), (1,2)</code>.</p>\n<p>The non-negative rational linear combinations of the vectors <code>(1,0), (1,2)</code> contain the integer vector <code>(1,1)</code>.  However, all natural (or even integer) linear combinations of <code>(1,0), (1,2)</code> have <em>even</em> second coordinate and will therefore not equal <code>(1,1)</code>: there is a hole. </p>\n<p>However, <code>2(1, 1) = (1,0) + (1,2)</code> <em>is</em> a non-negative integral combination of <code>(1,0), (1,2)</code>.  We need to saturate.  In this case, it is enough to simply add this vector, to the set of generators of the extremal rays.</p>\n<p>In general, we need to show that there are only finitely many holes that we need to take care of, and, after we add them, every remaining integer vector in the cone is also a non-negative integer combination of our finite set.</p>",
        "id": 233974461,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1618077547
    },
    {
        "content": "<p>I have not really been working on anything related to Gordan's lemma, only the use of it to derive <code>Lemma 9.7</code>. I see Damiano jumped in, and he certainly has more to say.</p>",
        "id": 233974845,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1618077887
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 233974862,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1618077905
    },
    {
        "content": "<p>I still don't see the proof we're trying to formalise.  You say \"we should prove that the elements of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>S</mi><mo>∨</mo></msup></mrow><annotation encoding=\"application/x-tex\">S^\\vee</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.751892em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.751892em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∨</span></span></span></span></span></span></span></span></span></span></span> (in the notation of my TeX file) are nonnegative rational linear combinations of elements of the extremal rays\" -- but do you know or have a reference for the maths proof of this?</p>",
        "id": 233992737,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618092056
    },
    {
        "content": "<p>I know all about the example you mention, I already put it in the TeX file. I am hoping that the TeX file can become a document which a mathematician can read, ie which I can read. Right now i can't understand the topological proof in Wikipedia and i can't see a proof in this thread or in the TeX file.</p>",
        "id": 233992883,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618092198
    },
    {
        "content": "<p>My issue with the Wikipedia proof is that it seems to be assuming things about cones which i don't know.</p>",
        "id": 233992948,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618092249
    },
    {
        "content": "<p>I don't know where the u_i are coming from in the Wikipedia proof and i don't see where (or if) they're showing up in your proof</p>",
        "id": 233993154,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618092479
    },
    {
        "content": "<p>Dear Kevin,</p>\n<p>I am really sorry: I realise that I made the folder <code>toric</code> available too soon.  I did not formalise all the statements that I mentioned above: they have to be formalised, of course, but I have not done it yet.</p>\n<p>In particular, as you noticed, the statement that a pointed, closed convex cone is the convex hull of its extremal rays is still far from being formalised.  The \"pointer\" to this is in the now flawed file <code>dual_extremal_API</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/--  The rays of the dual of the set `s` are the duals of the subsets of `s` that happen to be</span>\n<span class=\"sd\">cyclic. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">dual_set_rays</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">submodule</span> <span class=\"n\">R</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">r</span> <span class=\"bp\">|</span> <span class=\"n\">r.is_cyclic</span> <span class=\"bp\">∧</span> <span class=\"bp\">∃</span> <span class=\"n\">s'</span> <span class=\"bp\">⊆</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"bp\">=</span> <span class=\"n\">f.dual_set</span> <span class=\"n\">P₀</span> <span class=\"n\">s'</span> <span class=\"o\">}</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">  We may need extra assumptions for this. -/</span>\n<span class=\"sd\">/--  The link between the rays of the dual and the extremal rays of the dual should be the</span>\n<span class=\"sd\">crucial finiteness step: if `s` is finite, there are only finitely many `dual_set_rays`, since</span>\n<span class=\"sd\">there are at most as many as there are subsets of `s`.  If the extremal rays generate</span>\n<span class=\"sd\">dual of `s`, then we are in a good position to prove Gordan's lemma! -/</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">dual_set_rays_eq_extremal_rays</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">f.dual_set_rays</span> <span class=\"n\">P₀</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">f.dual_set</span> <span class=\"n\">P₀</span> <span class=\"n\">s</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">extremal_rays</span> <span class=\"o\">:=</span>\n<span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 234015981,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1618117006
    },
    {
        "content": "<p>This lemma, or a provable version of it, gives the conversion between <code>extremal_rays</code> and <code>dual_set_rays</code>.</p>\n<p>I should also at least state that a cone is the span of its <code>extremal_rays</code>, but I have not done this.  Part of the reason is that I would have liked there to be more API available, to make sure that I had not made silly mistakes in the definitions before, and I only wanted to build these lemmas on more solid foundations.</p>\n<p>At the moment, I have actually proven too few lemmas about these definitions to be sure that I have not made a mistake.  And, as you pointed out, I <em>have</em> made mistakes!</p>",
        "id": 234016301,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1618117351
    },
    {
        "content": "<p>Note that I pushed Damiano a bit to merge <code>toric</code> into master. I think it makes it more visible. I'm sorry for the confusion it created.</p>",
        "id": 234033539,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1618136256
    },
    {
        "content": "<p>I am going to write a more complete mathematical version of the proof, which is what I think that Kevin wanted all along: hopefully this will clear out most of the doubts!</p>",
        "id": 234034307,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1618137039
    },
    {
        "content": "<p>We're talking privately, trying to put together a mathematical proof, so we can actually understand the magnitude of the task. It seems that the proof Damiano is suggesting right now needs stuff like the Hahn-Banach theorem, the Krein-Milman theorem etc. I am not yet convinced that this is the proof we should be formalising.</p>",
        "id": 234035056,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618137753
    },
    {
        "content": "<p>I think the next step is to establish full details of a mathematical proof, before we can even think about formalising anything.</p>",
        "id": 234035081,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618137804
    },
    {
        "content": "<p>I pushed a slightly more complete version of the Algebraic Wikipedia proof, expanding on what Kevin had written.</p>\n<p>I would be happy to hear any comments, try to answer any questions, and clarify any hazy points, if I can!</p>",
        "id": 234058299,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1618158377
    },
    {
        "content": "<p>You can find the \"algebraic blueprint\" in the <code>toric</code> branch, in <code>src/toric/gordan_algebraic_blueprint.tex</code>.</p>",
        "id": 234058337,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1618158434
    },
    {
        "content": "<p><del>Ah, I forgot to update the pdf file: is there a way of doing it remotely, or should I push a compiled pdf version of the tex file?</del><br>\nI also pushed a version with the pdf file.</p>",
        "id": 234058365,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1618158477
    },
    {
        "content": "<p>I am late to the party , I didn't had time this weekend. I didn't work a lot on this, I just killed two random sorry  that seemed doable, without any global strategy. In any case now that my refactoring project is done I can help. I will try to have a close look at the blueprint tomorrow.</p>",
        "id": 234069614,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1618169438
    },
    {
        "content": "<p>I pushed a newer version of the <code>algebraic</code> blueprint to the <code>toric</code> branch.  There are no substantial changes, I simply tried to streamline the proof a little bit, and, hopefully, clarified it!</p>",
        "id": 234102197,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1618202108
    },
    {
        "content": "<p>Comments are welcome!</p>",
        "id": 234102289,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1618202187
    },
    {
        "content": "<p>In the proof of Lemma 3, \"...dual  of  a finite subset of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ker</mi><mo>⁡</mo><mi>φ</mi></mrow><annotation encoding=\"application/x-tex\">\\ker \\varphi</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mop\">ker</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">φ</span></span></span></span>...\" should be \"...dual  of  a finite subset of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>ker</mi><mo>⁡</mo><mi>φ</mi><msup><mo stretchy=\"false\">)</mo><mo>∗</mo></msup></mrow><annotation encoding=\"application/x-tex\">(\\ker \\varphi)^\\ast</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mop\">ker</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">φ</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.688696em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span></span></span></span>...\", right?</p>",
        "id": 234170339,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1618238333
    },
    {
        "content": "<p>Also, is it clear that \"the dual of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ker</mi><mo>⁡</mo><mi>φ</mi></mrow><annotation encoding=\"application/x-tex\">\\ker \\varphi</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mop\">ker</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">φ</span></span></span></span> is the quotient of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi mathvariant=\"normal\">Λ</mi><mo>∗</mo></msup></mrow><annotation encoding=\"application/x-tex\">\\Lambda^\\ast</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.688696em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">Λ</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.688696em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span></span></span></span> by the saturation of the additive subgroup generated by <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>φ</mi></mrow><annotation encoding=\"application/x-tex\">\\varphi</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">φ</span></span></span></span>\"?</p>",
        "id": 234175446,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1618239881
    },
    {
        "content": "<p><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mrow><mi mathvariant=\"normal\">k</mi><mi mathvariant=\"normal\">e</mi><mi mathvariant=\"normal\">r</mi></mrow><mi>φ</mi></mrow><annotation encoding=\"application/x-tex\">\\mathrm{ker}\\varphi</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">k</span><span class=\"mord mathrm\">e</span><span class=\"mord mathrm\">r</span></span><span class=\"mord mathnormal\">φ</span></span></span></span> is a saturated submodule, and so a direct factor; hence dualization behaves well</p>",
        "id": 234176408,
        "sender_full_name": "Peter Scholze",
        "timestamp": 1618240152
    },
    {
        "content": "<p>Does mathlib have the classification of f.g. modules over PIDs? I guess this is what's eventually used here...</p>",
        "id": 234176985,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1618240361
    },
    {
        "content": "<p>Nope, not yet, unfortunately <span aria-label=\"sad\" class=\"emoji emoji-2639\" role=\"img\" title=\"sad\">:sad:</span></p>",
        "id": 234177127,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1618240425
    },
    {
        "content": "<p>Not quite, but we know f.g. + torsion-free =&gt; free (and hence f.g. implies free + f.g. torsion); what we don't have right now is classification of f.g. torsion modules. I think what we have should be enough.</p>",
        "id": 234177148,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618240437
    },
    {
        "content": "<p>Or at least that a f.g. torsion free is free</p>",
        "id": 234177174,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1618240443
    },
    {
        "content": "<p>I think Patrick finished this recently.</p>",
        "id": 234177233,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618240455
    },
    {
        "content": "<p>We have <a href=\"https://leanprover-community.github.io/mathlib_docs/find/submodule.exists_is_basis\">docs#submodule.exists_is_basis</a>. Everything here seems to be torsionfree, so it should be enough</p>",
        "id": 234178083,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1618240710
    },
    {
        "content": "<p>Nice!</p>",
        "id": 234178224,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1618240740
    },
    {
        "content": "<p>Wait, is this what you want? Seems to me that you want to see that the quotient by <code>ker phi</code> is free.</p>",
        "id": 234179127,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1618241074
    },
    {
        "content": "<p>(note that <code>submodule.exists_is_basis</code> is true even without the finite rank assumption)</p>",
        "id": 234181147,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1618241831
    },
    {
        "content": "<p>You're right. I don't find that torsion free implies free, but maybe I didn't search enough</p>",
        "id": 234182364,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1618242254
    },
    {
        "content": "<p>This is not yet in mathlib. I started to PR preliminaries with <a href=\"https://github.com/leanprover-community/mathlib/issues/7037\">#7037</a> and <a href=\"https://github.com/leanprover-community/mathlib/issues/7040\">#7040</a>, and <a href=\"https://github.com/leanprover-community/mathlib/issues/7160\">#7160</a> is currently under review. Maybe I should have done only one massive PR.</p>",
        "id": 234191666,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1618245888
    },
    {
        "content": "<p>If there is a urgent need I can also create a file in the liquid repository.</p>",
        "id": 234191748,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1618245918
    },
    {
        "content": "<p>With respect to the saturation of kernels, I think that this is already formalised.  Ot at least it is close to being formalised and might be within easy reach in the case of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Z}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Z</span></span></span></span></span>-/<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">N</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{N}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">N</span></span></span></span></span>-modules.</p>",
        "id": 234200645,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1618249519
    },
    {
        "content": "<p>Patrick, I do not think that this is urgent.  There is some more stuff that needs doing that does not depend on this, and we can always merge your unmerged branches into <code>lean-liquid</code>.  It will probably be easy to adapt, should there be changes in the statements.</p>",
        "id": 234200873,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1618249610
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span> I corrected some mini typos in the blueprint.</p>\n<p>What is the status of Theorem 2 in Lean? If not already done it seems a good subproject, that can be done independently of Gordan's lemma</p>",
        "id": 234201288,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1618249799
    },
    {
        "content": "<p>I will take a look now: I have been out all day and have a few things to catch up, so I may be a little slow in replying!</p>",
        "id": 234201634,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1618249924
    },
    {
        "content": "<p>Riccardo, I do not know how much of Theorem 2 is already in mathlib.  However, it will likely need some API developed around it.</p>",
        "id": 234202067,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1618250085
    },
    {
        "content": "<p>Here is what I would ideally hope that the API would be able to do:</p>",
        "id": 234202120,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1618250106
    },
    {
        "content": "<p>We already have <code>monoid_algebra</code>with an API</p>",
        "id": 234202160,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1618250123
    },
    {
        "content": "<p>The ring <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi><mo stretchy=\"false\">[</mo><mi>M</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">R[M]</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mclose\">]</span></span></span></span> is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span>-graded, and later we will want to do a Noetherian induction on the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Z}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Z</span></span></span></span></span>-graded ring <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span>.  It would be <em>awesome</em> if we could use a common API for dealing with <em>graded</em> rings/algebra, where the grading is by a more or less arbitrary (abelian) group, additive of multiplicative.</p>",
        "id": 234202388,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1618250211
    },
    {
        "content": "<p>Ok, <code>monoid_algebra</code> could work, though I have not worked with it.  Most of the arguments involve decomposing a non-necessarily homogeneous element, into its homogeneous components.  It would be great if the API could make it easy to do this.</p>",
        "id": 234202611,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1618250289
    },
    {
        "content": "<p>Possibly in the form of an induction principle or something analogous-</p>",
        "id": 234202653,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1618250304
    },
    {
        "content": "<p>I have no idea about graded stuff in mathlib, but <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi><mo stretchy=\"false\">[</mo><mi>M</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">R[M]</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mclose\">]</span></span></span></span> is in mathlib, and I don't see any problem to state Theorem 2, exactly as in the blueprint (so we don't need any graded ring).</p>",
        "id": 234203184,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1618250485
    },
    {
        "content": "<p>I mean, if we want to follow the algebraic proof there are no doubts that Theorem 2 is needed, exactly as it is in the blueprint, right?</p>",
        "id": 234203406,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1618250556
    },
    {
        "content": "<p>Yes, the point of the blueprint is that it is supposed to be spelling out exactly what we need to prove precisely the sorried statement in <code>toric.lem97</code>.</p>",
        "id": 234204217,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618250851
    },
    {
        "content": "<p>I need to worry about other things today and tomorrow, but on Wednesday I will get back to this, and in my mind what we need to do with this proof is to pull out more sublemmas, because I think the main argument is too long to be formalised painlessly in Lean -- we will get to that stage where it takes 10 seconds to write every line and this is no fun at all. Right now the two things I can see that we can pull off are Theorem 2, which is already pulled off, and the statement that if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Λ</mi></mrow><annotation encoding=\"application/x-tex\">\\Lambda</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\">Λ</span></span></span></span> is a finite free <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\Z</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Z</span></span></span></span></span>-module then it has a well-defined rank <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>r</mi><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">Λ</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">r(\\Lambda)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mopen\">(</span><span class=\"mord\">Λ</span><span class=\"mclose\">)</span></span></span></span>, and the theorem that if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ϕ</mi><mo>:</mo><mi mathvariant=\"normal\">Λ</mi><mo>→</mo><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\phi:\\Lambda\\to\\Z</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">ϕ</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\">Λ</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Z</span></span></span></span></span> is non-zero then the kernel of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ϕ</mi></mrow><annotation encoding=\"application/x-tex\">\\phi</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">ϕ</span></span></span></span> is also a finite free <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\Z</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Z</span></span></span></span></span>-module, with strictly smaller rank.</p>",
        "id": 234204569,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618250991
    },
    {
        "content": "<p>I completely agree that we need to find as much subgoals as possible. I can work on theorem 2</p>",
        "id": 234205002,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1618251145
    },
    {
        "content": "<p>Even using this last result in the main proof will be delicate, because the kernel of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ϕ</mi></mrow><annotation encoding=\"application/x-tex\">\\phi</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">ϕ</span></span></span></span> is a submodule, which we then promote to a module <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi mathvariant=\"normal\">Λ</mi><mo lspace=\"0em\" mathvariant=\"normal\" rspace=\"0em\">′</mo></msup></mrow><annotation encoding=\"application/x-tex\">\\Lambda'</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.751892em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">Λ</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.751892em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span></span></span></span>, and we will have to move <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>S</mi><mn>0</mn></msub><mo>:</mo><mo>=</mo><mi>S</mi><mo>∩</mo><mi>k</mi><mi>e</mi><mi>r</mi><mo stretchy=\"false\">(</mo><mi>ϕ</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">S_0:=S\\cap ker(\\phi)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.36687em;vertical-align:0em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∩</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">ϕ</span><span class=\"mclose\">)</span></span></span></span> into <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi mathvariant=\"normal\">Λ</mi><mo lspace=\"0em\" mathvariant=\"normal\" rspace=\"0em\">′</mo></msup></mrow><annotation encoding=\"application/x-tex\">\\Lambda'</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.751892em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">Λ</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.751892em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span></span></span></span>, prove finitely-generated there by induction, and then move the finite generation back to the submodule. This is just the sort of nonsense which is going to make the proof slightly delicate to formalise, but we have seen this kind of argument time and time again and we know it's possible. There is a risk it will make it long though, which is why I think we need to get as much stuff out of the main inductive step as we can.</p>",
        "id": 234205044,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618251164
    },
    {
        "content": "<p>A formal proof of theorem 2 would be very helpful! Thanks!</p>",
        "id": 234205100,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618251190
    },
    {
        "content": "<p>I am also very much hoping that we can extract this argument about <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>A</mi><mrow><mo>≥</mo><mn>0</mn></mrow></msub></mrow><annotation encoding=\"application/x-tex\">A_{\\geq0}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.928509em;vertical-align:-0.24517899999999998em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.301108em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mrel mtight\">≥</span><span class=\"mord mtight\">0</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.24517899999999998em;\"><span></span></span></span></span></span></span></span></span></span> being finitely-generated over <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>A</mi><mn>0</mn></msub></mrow><annotation encoding=\"application/x-tex\">A_0</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> as a separate lemma, but one will have to be very careful here that the lemma one extracts will actually be applicable in the case that one needs. I would advocate a \"top-down\" approach here -- this is not particularly fashionable amongst the CS crowd (they are paranoid people) but Johan and I and Patrick and many other mathematicians have been using this approach for a while and as far as I can see it works fine. What I mean here is: just take that sorried Gordan's Lemma in <code>toric.lem97</code> and start to prove it, but sorry <em>everything</em> along the way. For example, say that a free module has a rank, but sorry the definition. Claim that the submodule, when promoted to a module, is free of smaller rank, and sorry the proof. Then write down the grading, prove that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>A</mi><mn>0</mn></msub></mrow><annotation encoding=\"application/x-tex\">A_0</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> is a subring, sorry the proof it's finitely-generated over the base field, sorry the proof that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>A</mi><mrow><mo>≥</mo><mn>0</mn></mrow></msub></mrow><annotation encoding=\"application/x-tex\">A_{\\geq0}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.928509em;vertical-align:-0.24517899999999998em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.301108em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mrel mtight\">≥</span><span class=\"mord mtight\">0</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.24517899999999998em;\"><span></span></span></span></span></span></span></span></span></span> is finitely-generated over <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>A</mi><mn>0</mn></msub></mrow><annotation encoding=\"application/x-tex\">A_0</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>, now see if you can use results in the library to prove <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>A</mi><mrow><mo>≥</mo><mn>0</mn></mrow></msub></mrow><annotation encoding=\"application/x-tex\">A_{\\geq0}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.928509em;vertical-align:-0.24517899999999998em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.301108em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mrel mtight\">≥</span><span class=\"mord mtight\">0</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.24517899999999998em;\"><span></span></span></span></span></span></span></span></span></span> is finitely-generated over the base field and check that you can now finish the proof with Theorem 2 (i.e. check that your choice of precise formalisation of Theorem 2 suffices to finish the job).</p>",
        "id": 234205973,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618251528
    },
    {
        "content": "<p>This top-down approach now gives us a whole bunch of sorries (and already what I have said above might expand out into quite a long proof as well). Now we have to decide how to fill in those sorries, and the idea is to try and fill them in with new lemmas rather than solving these goals within this proof we've just written. Then one has to think about precisely the statement of the formalisation of the missing pieces, but because we have this top-down sorried proof, one can take one of the missing pieces (for example some statement that for a Z-graded Noetherian ring, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>A</mi><mrow><mo>≥</mo><mn>0</mn></mrow></msub></mrow><annotation encoding=\"application/x-tex\">A_{\\geq0}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.928509em;vertical-align:-0.24517899999999998em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.301108em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mrel mtight\">≥</span><span class=\"mord mtight\">0</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.24517899999999998em;\"><span></span></span></span></span></span></span></span></span></span> is finitely-generated over <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>A</mi><mn>0</mn></msub></mrow><annotation encoding=\"application/x-tex\">A_0</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>), attempt to formalise the statement, and before one even begins to prove it one can check to see if the statement is in the correct form to make it easy to fill in the sorry in the main proof. If it turns out that this makes the main proof even bigger, because there are issues switching from subtypes to types or problems checking that one grading matches with another, or problems because it turns out that there are two different notions of grading, then this is an indication that the formalised statement you have chosen might not be the best one. This way the top-down proof guides us and shows us how to formalise the intermediate statements, meaning that the end result won't have one horrible 300-line argument in it but will instead be a bunch of smaller results which it will be possible to glue together relatively painlessly.</p>",
        "id": 234206716,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618251819
    },
    {
        "content": "<p>So in fact Riccardo, one answer to your \"theorem 2 is needed, exactly as it is in the blueprint\" would be this: the blueprint states a mathematical theorem, not a formal Lean theorem. It might be best to start with the big prize, namely the precise sorried statement in the <code>lem97</code> file, and work down from there. You might find for example that ultimately we do not want a statement about <code>monoid_algebra R M</code>, but a statement about a ring which is canonically isomorphic to <code>monoid_algebra R M</code>. If you've gone ahead and formalised Theorem 2 but just for the \"concrete\" model of <code>monoid_algebra R M</code> in mathlib then you might find that your lemma will not \"fill in the hole\" that we need it to fill in. So I think that before anything is formalised, now we think we have a mathematical proof, it might be worth starting on the top-down approach.</p>",
        "id": 234207207,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618252018
    },
    {
        "content": "<p>I must be missing something.... what's theorem 2?</p>",
        "id": 234207208,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1618252020
    },
    {
        "content": "<p>It's in a pdf on the toric branch</p>",
        "id": 234207244,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618252034
    },
    {
        "content": "<p>Ah ok</p>",
        "id": 234207256,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1618252040
    },
    {
        "content": "<p>(I thought it was theorem n.2 from the blueprint for some value of n...)</p>",
        "id": 234207301,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1618252063
    },
    {
        "content": "<p>It's in <code>src/toric/gordan_algebraic_blueprint.tex</code>.</p>",
        "id": 234207302,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618252064
    },
    {
        "content": "<p>This is a mini-blueprint for Gordan's Lemma, because we realised that it was more complicated than we originally thought.</p>",
        "id": 234207404,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618252095
    },
    {
        "content": "<p>It could easily be put into the lean-liquid blueprint, but it will not be difficult to do this later.</p>",
        "id": 234207484,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618252131
    },
    {
        "content": "<p>It says that, for a commutative monoid <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> and a nontrivial ring <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>, the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>-algebra <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi><mo stretchy=\"false\">[</mo><mi>M</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">R[M]</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mclose\">]</span></span></span></span> is finitely generated (as <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>-algebra) if and only if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> is finitely generated as a monoid.</p>",
        "id": 234207972,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1618252320
    },
    {
        "content": "<p>Yeah I'm looking at it now...</p>",
        "id": 234208084,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1618252352
    },
    {
        "content": "<p>Oh this should totally be doable with current mathlib</p>",
        "id": 234208122,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1618252363
    },
    {
        "content": "<p>That's why I am asking if we're sure it is the theorem we need <span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span></p>",
        "id": 234208233,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1618252410
    },
    {
        "content": "<p>Yes I'm sure it's doable, but the big question is precisely how to formalise it. This is why I am suggesting that now we think we have a maths proof which should be possible to formalise reasonably (although I have not checked Damiano's argument about <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>A</mi><mrow><mo>≥</mo><mn>0</mn></mrow></msub></mrow><annotation encoding=\"application/x-tex\">A_{\\geq0}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.928509em;vertical-align:-0.24517899999999998em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.301108em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mrel mtight\">≥</span><span class=\"mord mtight\">0</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.24517899999999998em;\"><span></span></span></span></span></span></span></span></span></span> being finitely-generated over <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>A</mi><mn>0</mn></msub></mrow><annotation encoding=\"application/x-tex\">A_0</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> yet -- please someone else feel free to do this so we've had more than one pair of eyes on it!) the next step should be to start at the top and replace the one sorry in <code>lem97</code> with a bunch of sorries, thus showing us precisely the form of the sublemmas which we will need. As I've already said, I am concerned that if we prove a result about <code>monoid_algebra</code> then this will not be applicable in the situation we're interested in, and the actual result we need might be a result about an algebra which satisfies the universal property of <code>monoid_algebra</code>. Whether it is easiest to prove <code>monoid_algebra</code> first and deduce the result for the ring isomorphic to <code>monoid_algebra</code> afterwards, or whether it's easier to work with the universal property directly, is something I am not yet clear on. However there is often more than one universal property! We need something which is not too hard to check in the application, but furthermore strong enough to relatively painlessly come up with a unique isomorphism to the concrete <code>monoid_algebra</code> if we decide to formalise the theorem using this concrete model. This is precisely the mistake we made with the first schemes formalisation you see -- we proved a very messy result which involved several rings of the form <code>localisation R S</code> and then we needed to apply it to rings which had the universal property of <code>localisation R S</code> but were not definitionally equal to it, and I had to spend about a week developing tools for diagram chasing along morphisms coming from universal properties and it was no fun at all.</p>",
        "id": 234209829,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618253044
    },
    {
        "content": "<p>If this is helpful, I think that I can extract smaller lemmas from the mathematical proof.</p>",
        "id": 234210340,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1618253282
    },
    {
        "content": "<p>Would this be useful?  There are several results that are mentioned as \"mathematical one-liners\" that I imagine would expand quite a bit when formalized.  If this is helpful, I can start expanding the mathematical proof, by fracturing it more.</p>",
        "id": 234210489,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1618253342
    },
    {
        "content": "<p>Also, I would very much welcome someone else looking at the proof!</p>",
        "id": 234210554,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1618253376
    },
    {
        "content": "<p>We recently got <a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_free_group\">docs#is_free_group</a></p>",
        "id": 234214731,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1618255094
    },
    {
        "content": "<p>I feel like we should add similar classes for all such free constructions (including the monoid algebra)</p>",
        "id": 234214764,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1618255120
    },
    {
        "content": "<p>(note the universe restrictions in the definition BTW, along with <a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_free_group.unique_lift\">docs#is_free_group.unique_lift</a> )</p>",
        "id": 234214828,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1618255156
    },
    {
        "content": "<p>I started writing at least the statement of theorem 2,  to check if there are results we are missing to prove it, in this form or another.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.monoid_algebra</span>\n<span class=\"kn\">import</span> <span class=\"n\">ring_theory.finiteness</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">nontrivial</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">algebra</span> <span class=\"n\">submodule</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">monoid_alg_ft_iff</span> <span class=\"o\">:</span> <span class=\"n\">finite_type</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">add_monoid_algebra</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"bp\">⊤</span> <span class=\"o\">:</span> <span class=\"n\">submodule</span> <span class=\"n\">ℕ</span> <span class=\"n\">M</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">fg</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"gr\">sorry</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>Does someone see a way to use <code> [comm_monoid M]</code> instead of <code> [add_comm_monoid M]</code>? It seems much more natural to me, but then I don't know how to say <code>(⊤ : submodule ℕ M).fg </code>, since a multiplicative monoid is not a <code>ℕ</code>-semimodule, and all the theory of finitely generated stuff in mathlib is for subsemimodules.</p>",
        "id": 234297514,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1618307644
    },
    {
        "content": "<p>Hmm, I can use <code>additive M</code>but maybe this will introduce other problems in the proof.</p>",
        "id": 234297918,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1618307821
    },
    {
        "content": "<p>If we don't have stuff about finitely generated submonoids, then I don't think we can use multiplicative notation</p>",
        "id": 234298963,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1618308333
    },
    {
        "content": "<p>Unless you want to do another huge refactor of mathlib (-;</p>",
        "id": 234298987,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1618308347
    },
    {
        "content": "<p>No thanks <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 234299569,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1618308647
    },
    {
        "content": "<p>I am experimenting a little bit, but maybe the following statement is more reasonable</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">monoid_alg_ft_iff</span> <span class=\"o\">:</span> <span class=\"n\">finite_type</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">monoid_algebra</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"bp\">↔</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">M</span><span class=\"o\">,</span> <span class=\"n\">submonoid.closure</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">⊤</span> <span class=\"o\">:=</span>\n</code></pre></div>",
        "id": 234316775,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1618317440
    },
    {
        "content": "<p>I guess that works. But you run the risk that you will have to develop an API for <code>submonoid.fg</code> on the fly.</p>",
        "id": 234317300,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1618317637
    },
    {
        "content": "<p>Ok the big work thing I had to do is over and I will be looking at this starting in about an hour. Did anyone begin to flesh out the proof of the sorry in lem97? If not I'll start there. It's time we got Gordan out of the way.</p>",
        "id": 234320705,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618319077
    },
    {
        "content": "<p>I have not looked at the proof of explicit_gordan, but I still think that having graded rings/algebras could be useful for the proof.  At least some primitive form of it.</p>",
        "id": 234328485,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1618321897
    },
    {
        "content": "<p>Yes we absolutely need an API for graded rings here, for example you use all over the place the fact that if A is graded by a cancellative monoid M and if i+j=k is an identity in M and a_i * r = a_k in A with a_i in A_i etc then there's some a_j with a_i * a_j = a_k. We don't want to have to stop what we're doing to justify this sort of stuff. What is the status of M-gradings on A, M a commutative monoid and A a commutative ring? This sounds like something fun to make</p>",
        "id": 234331002,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618322752
    },
    {
        "content": "<p>I think <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> has/had some PRs on gradings on <code>direct_sum _</code>. But we don't have general gradings on general rings, afaik</p>",
        "id": 234331187,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1618322815
    },
    {
        "content": "<p>I agree that it would be fun to make, but I do not know what is available.</p>",
        "id": 234331224,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1618322828
    },
    {
        "content": "<p>My thinking was that a \"grading on a ring\" is just an isomorphism to a direct sum of submonoids</p>",
        "id": 234331416,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1618322889
    },
    {
        "content": "<p>I remember Eric had something about nat gradings (and I even remember arguing that nat gradings were the place to start) but we need int gradings</p>",
        "id": 234331470,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618322905
    },
    {
        "content": "<p>and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span>-gradings, where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> is an add_monoid, while we are at it?</p>",
        "id": 234331603,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1618322947
    },
    {
        "content": "<p>I am pushing for this, since two proofs in the blueprint would benefit from being able to use gradings: the one about the equivalence of fg for an add_monoid and the monoid_algebra, and the one about the Z-gradings</p>",
        "id": 234331893,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1618323049
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/direct_sum.ring\">docs#direct_sum.ring</a> has gradings <del>of</del> by an arbitrary <code>add_monoid</code></p>",
        "id": 234332234,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1618323162
    },
    {
        "content": "<p>What we're missing is something like the statement</p>\n<blockquote>\n<p><code>A : ι → monoid R</code> is a gradation of a ring <code>R</code> if <code>complete_lattice.independent (set.range A)</code> and there is a ring_equiv from <code>R</code> to <code>⨁ i, A i</code> whose inverse is roughly <code>direct_sum.to_monoid (λ i, add_submonoid.inclusion $ le_supr A i)</code></p>\n</blockquote>",
        "id": 234333154,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1618323482
    },
    {
        "content": "<p>I think that the two main properties that should be easily accessible are that</p>\n<ul>\n<li>every element of the graded ring is a finite sum of homogeneous elements</li>\n<li>product of homogeneous elements is homogeneous of degree the sum of the degrees.</li>\n</ul>\n<p>I imagine that this should form part of the definitions, but I have been wrong about such things in the past!</p>\n<p>Having this to hand already goes quite a long way into the proof of the first lemma about monoid generation.</p>\n<p>If it is not already in mathlib, it would also be good to extract a lemma that says that if a ring is generated by some set <code>s</code> and some other set <code>t</code> generates the generators, then <code>t</code> also generates.</p>",
        "id": 234334064,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1618323798
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> what we need right now I think is something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">ring_theory.subring</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.finsupp</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">big_operators</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">grading</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">graded_piece</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">independent</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">→₀</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">m</span> <span class=\"bp\">∈</span> <span class=\"n\">graded_piece</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"bp\">→</span>\n  <span class=\"n\">f.sum</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">m</span> <span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">span</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">→₀</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">m</span> <span class=\"bp\">∈</span> <span class=\"n\">graded_piece</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"n\">f.sum</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">m</span> <span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">r</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>and also a variant for <code>add_comm_monoid</code> (in fact in our application we only need <code>add_comm_monoid</code>). Do we have anything like this? We don't need to build the ring we have it already, we want to impose the grading a posteriori.</p>",
        "id": 234336132,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618324427
    },
    {
        "content": "<p>Kevin, maybe this is implicit, but don't we also want that multiplication between homogeneous pieces maps to the right homogeneous piece?</p>",
        "id": 234336514,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1618324527
    },
    {
        "content": "<p>Is it not a requirement for the graded pieces to be closed under addition?</p>",
        "id": 234336551,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1618324538
    },
    {
        "content": "<p>hmm :-)</p>",
        "id": 234336761,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618324587
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">grading</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">graded_piece</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">→</span> <span class=\"n\">add_subgroup</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">grading_mul</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">),</span>\n  <span class=\"n\">r</span> <span class=\"bp\">∈</span> <span class=\"n\">graded_piece</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">s</span> <span class=\"bp\">∈</span> <span class=\"n\">graded_piece</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">r</span> <span class=\"bp\">*</span> <span class=\"n\">s</span> <span class=\"bp\">∈</span> <span class=\"n\">graded_piece</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">*</span> <span class=\"n\">n</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">independent</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">→₀</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">m</span> <span class=\"bp\">∈</span> <span class=\"n\">graded_piece</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"bp\">→</span>\n  <span class=\"n\">f.sum</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">m</span> <span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">span</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">→₀</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">m</span> <span class=\"bp\">∈</span> <span class=\"n\">graded_piece</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"n\">f.sum</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">m</span> <span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">r</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>?</p>",
        "id": 234337409,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618324787
    },
    {
        "content": "<p>My attempt at my quoted description above is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">order.complete_lattice</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.direct_sum_graded</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.direct_sum</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">direct_sum</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">is_gradation</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">ι</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_monoid</span> <span class=\"n\">ι</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">add_submonoid</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n    <span class=\"n\">complete_lattice.independent</span> <span class=\"o\">(</span><span class=\"n\">set.range</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"bp\">∧</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">hone</span> <span class=\"n\">hmul</span><span class=\"o\">,</span>\n    <span class=\"k\">let</span> <span class=\"n\">inst</span> <span class=\"o\">:=</span> <span class=\"n\">direct_sum.gmonoid.of_add_submonoids</span> <span class=\"n\">A</span> <span class=\"n\">hone</span> <span class=\"n\">hmul</span> <span class=\"k\">in</span> <span class=\"kd\">by</span> <span class=\"n\">exactI</span>\n    <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">≃+*</span> <span class=\"bp\">⨁</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">A</span> <span class=\"n\">i</span><span class=\"o\">),</span>\n      <span class=\"c1\">-- this let is here to help the elaborator</span>\n      <span class=\"k\">let</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">⨁</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">A</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">→+</span> <span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"bp\">⨆</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">A</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n        <span class=\"n\">direct_sum.to_add_monoid</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">add_submonoid.inclusion</span> <span class=\"o\">(</span><span class=\"n\">le_supr</span> <span class=\"n\">A</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">_</span><span class=\"o\">))</span> <span class=\"k\">in</span>\n      <span class=\"n\">e.symm.to_add_equiv.to_add_monoid_hom</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">add_submonoid.subtype</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"n\">f</span>\n</code></pre></div>",
        "id": 234337570,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1618324835
    },
    {
        "content": "<p>If the semiring mafia get to this definition then the graded pieces will end up being add_submonoids, but I suspect one can prove they're subgroups from the other axioms if R has subtraction.</p>",
        "id": 234337704,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618324889
    },
    {
        "content": "<p>re syntax error: just end with <code>:= sorry</code></p>",
        "id": 234337864,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618324949
    },
    {
        "content": "<p>Yeah, I worked that out eventually, but what I actually meant was <code>: Prop :=</code></p>",
        "id": 234337906,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1618324965
    },
    {
        "content": "<p>... unless of course, the grading does not respect multiplication by <code>-1</code>, if it can! <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 234337919,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1618324971
    },
    {
        "content": "<p>Damiano, the trick is that if r is in R_m then you write -r as a linear combination of stuff in graded pieces</p>",
        "id": 234338296,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618325090
    },
    {
        "content": "<p>Kevin, is your <code>independent</code> equivalent to <a href=\"https://leanprover-community.github.io/mathlib_docs/find/complete_lattice.indepedent\">docs#complete_lattice.indepedent</a>?</p>",
        "id": 234338556,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1618325174
    },
    {
        "content": "<p>Ah, I see that now the graded pieces are <code>add_subgroup</code>s: I had missed that!</p>",
        "id": 234338630,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1618325204
    },
    {
        "content": "<p>so, yes, of course, the piece that contains <code>1</code> also contains <code>-1</code>!</p>",
        "id": 234338776,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1618325256
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/267928-condensed-mathematics/topic/toric/near/234338556\">said</a>:</p>\n<blockquote>\n<p>Kevin, is your <code>independent</code> equivalent to <a href=\"https://leanprover-community.github.io/mathlib_docs/find/complete_lattice.independent\">docs#complete_lattice.independent</a>?</p>\n</blockquote>\n<p>Yes.</p>",
        "id": 234339004,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618325317
    },
    {
        "content": "<p>... and is that easy to prove?</p>",
        "id": 234339140,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1618325378
    },
    {
        "content": "<p>Oh -- at least in the add_subgroup case.</p>",
        "id": 234339155,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618325386
    },
    {
        "content": "<p>In the add_subgroup case it's easy to prove on paper. Is that what you're asking?</p>",
        "id": 234339244,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618325411
    },
    {
        "content": "<p>Actually, does it automatically follow that <code>1</code> is homogeneous?  In my mind, I always think that the elements of degree <code>0</code> form a subring: they are clearly a subgroup that is closed under multiplication, but do they have a <code>1</code>?  Is the one of this piece the same as the <code>1</code> of the whole ring?</p>",
        "id": 234339323,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1618325442
    },
    {
        "content": "<p>I've just realized - your version is multiplicatively graded, but <code>direct_sum.ring</code> is additively graded</p>",
        "id": 234339418,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1618325475
    },
    {
        "content": "<p>for safe measure, should we add the axiom that the degree <code>0</code> piece is a subring?</p>",
        "id": 234339420,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1618325476
    },
    {
        "content": "<p>I only care about the case of an <code>add_comm_monoid</code> grading, I went with <code>comm_monoid</code> believing that I could perhaps use <code>to_additive</code> to generate the API for the <code>add_comm_monoid</code> variant (I'm assuming it ignores rings)</p>",
        "id": 234339738,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618325583
    },
    {
        "content": "<p>I was scared of that parenthesized assumption so decided to just focus on the additive case</p>",
        "id": 234339862,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1618325624
    },
    {
        "content": "<p>I guess it won't touch the rings but it could well touch the <code>add_subgroup R</code>'s :-/</p>",
        "id": 234340070,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618325668
    },
    {
        "content": "<p>Here's how to mesh Kevin's definition with my direct_sum stuff:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.direct_sum_graded</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">direct_sum</span>\n\n<span class=\"c1\">-- modified for additive grading, and a `one` axiom</span>\n<span class=\"kd\">structure</span> <span class=\"n\">add_grading</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">graded_piece</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">→</span> <span class=\"n\">add_subgroup</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">grading_one</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">graded_piece</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">grading_mul</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">),</span>\n  <span class=\"n\">r</span> <span class=\"bp\">∈</span> <span class=\"n\">graded_piece</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">s</span> <span class=\"bp\">∈</span> <span class=\"n\">graded_piece</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">r</span> <span class=\"bp\">*</span> <span class=\"n\">s</span> <span class=\"bp\">∈</span> <span class=\"n\">graded_piece</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">independent</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">→₀</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">m</span> <span class=\"bp\">∈</span> <span class=\"n\">graded_piece</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"bp\">→</span>\n  <span class=\"n\">f.sum</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">m</span> <span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">span</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">→₀</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">m</span> <span class=\"bp\">∈</span> <span class=\"n\">graded_piece</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"n\">f.sum</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">m</span> <span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">r</span><span class=\"o\">)</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_coe_to_sort</span> <span class=\"o\">(</span><span class=\"n\">add_grading</span> <span class=\"n\">M</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"bp\">⨁</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">g.graded_piece</span> <span class=\"n\">i</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">grading.gmonoid</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">add_grading</span> <span class=\"n\">M</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">direct_sum.gmonoid</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">g.graded_piece</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">direct_sum.gmonoid.of_add_subgroups</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">g.graded_piece</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"n\">g.grading_one</span> <span class=\"n\">g.grading_mul</span>\n</code></pre></div>",
        "id": 234340513,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1618325795
    },
    {
        "content": "<p>The reason my <code>independent</code> is the same as <code>complete_lattice.independent</code> is that Sups in the lattice of add_submonids is \"add_submonoid generated by\", and this is the same as \"finite sums of elements in the union\". Is that enough of a clue Eric or are you asking for something more formal?</p>",
        "id": 234340585,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618325817
    },
    {
        "content": "<p>My question was less \"why is that true\" and more \"how painful will it be to convince lean that is true\"</p>",
        "id": 234340677,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1618325847
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/267928-condensed-mathematics/topic/toric/near/234339420\">said</a>:</p>\n<blockquote>\n<p>for safe measure, should we add the axiom that the degree <code>0</code> piece is a subring?</p>\n</blockquote>\n<p>This is proven by <a href=\"https://github.com/leanprover-community/mathlib/issues/6851\">#6851</a> using the existing axioms</p>",
        "id": 234341191,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1618325998
    },
    {
        "content": "<p>Oh OK. Yeah it might be a bit painful -- we saw this recently with Patrick's challenge the other day. To say \"this subgroup A_0 of A has trivial intersection with the subgroup generated by these subgroups A_1, A_2, A_3, ...\" is the same as to say \"if I have f : nat -&gt;_0 A with f(i) in A_i and the sum of the f(i) is zero, then f(0) must be 0\", because f(0) is in both A_0 and the subgroup generated by the A_i for a &gt;= 1 which contains f(1)+f(2)+.... = -f(0). This is why I'm a bit worried about submonoids.</p>",
        "id": 234341524,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618326039
    },
    {
        "content": "<p>I think pretending the semiring mafia will never arrive and using subgroup instead of submonoid is an acceptable approach here</p>",
        "id": 234341991,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1618326111
    },
    {
        "content": "<p>But as a wannabe member of the constructivist cartel, I feel like your definition should provide <code>span</code> constructively as</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">span</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">→₀</span> <span class=\"n\">R</span> <span class=\"bp\">//</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">m</span> <span class=\"bp\">∈</span> <span class=\"n\">graded_piece</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"n\">f.sum</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">m</span> <span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">r</span><span class=\"o\">})</span>\n</code></pre></div>\n<p>or better</p>",
        "id": 234343575,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1618326411
    },
    {
        "content": "<p>Eric, thanks!  I am not able to follow quickly your argument, but it is great that the units line up!</p>",
        "id": 234344064,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1618326518
    },
    {
        "content": "<p>By \"units\" you mean <code>1</code> or \"pieces of code from Eric and Kevin\"?</p>",
        "id": 234344806,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1618326692
    },
    {
        "content": "<p>Eric, I meant the elements <code>1</code> in <code>R</code> and the element <code>1</code> in <code>graded_piece (0 : M)</code>.</p>",
        "id": 234345603,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1618326873
    },
    {
        "content": "<p>Note that even without the <code>(1 : R)</code> axiom you can still create an instance of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/direct_sum.ghas_mul\">docs#direct_sum.ghas_mul</a>, which shortly after <a href=\"https://github.com/leanprover-community/mathlib/issues/6786\">#6786</a>  will result in a <code>non_unital_semiring</code> structure on <code>add_grading M R</code></p>",
        "id": 234348192,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1618327691
    },
    {
        "content": "<p>Ok, I am happy with that, thanks!  Also, I wanted to make sure that we <em>did not</em> face non-unital rings (even in the degree <code>0</code> graded_piece`), hence my questions!  I would not want to demote these graded rings to graded rngs!</p>",
        "id": 234349273,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1618328052
    },
    {
        "content": "<p>Aargh <code>complete_lattice.independent</code> is a statement about subsets and we have a map from a monoid, so for example if the monoid is nontrivial and the map sends every element of the monoid to the same nonzero <code>add_subgroup</code> then they won't be independent in the sense I wrote (and that we need) but they'll be independent in the sense that the range of the function has size 1.</p>",
        "id": 234362297,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618332751
    },
    {
        "content": "<p>Oh, nice catch</p>",
        "id": 234362991,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1618333016
    },
    {
        "content": "<p>Just make the function<code>graded_piece</code>  injective?</p>",
        "id": 234363022,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1618333028
    },
    {
        "content": "<p>As sanity check I proved the easy implication of theorem 2 of the blueprint, here<br>\n<a href=\"https://github.com/leanprover-community/lean-liquid/blob/riccardobrasca/src/toric/theorem2.lean\">https://github.com/leanprover-community/lean-liquid/blob/riccardobrasca/src/toric/theorem2.lean</a></p>",
        "id": 234363288,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1618333128
    },
    {
        "content": "<p>Perhaps restating <a href=\"https://leanprover-community.github.io/mathlib_docs/find/complete_lattice.independent\">docs#complete_lattice.independent</a> in terms of an indexed collection is a good idea anyway though</p>",
        "id": 234363320,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1618333140
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/267928-condensed-mathematics/topic/toric/near/234363320\">said</a>:</p>\n<blockquote>\n<p>Perhaps restating <a href=\"https://leanprover-community.github.io/mathlib_docs/find/complete_lattice.independent\">docs#complete_lattice.independent</a> in terms of an indexed collection is a good idea anyway though</p>\n</blockquote>\n<p>How big of a refactor would this be?</p>",
        "id": 234363421,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1618333181
    },
    {
        "content": "<p>BTW, the algebraic geometer in me wants a grading to be a coaction by the coordinate ring of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"double-struck\">G</mi><mi>m</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\mathbb{G}_m</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83889em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathbb\">G</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">m</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> or something. (not a serious suggestion.)</p>",
        "id": 234363559,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1618333212
    },
    {
        "content": "<p>I've no idea how big that refactor would be, but I don't think <code>complete_lattice.independent</code> is used in all that many places yet</p>",
        "id": 234363978,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1618333349
    },
    {
        "content": "<p>Mainly just <a href=\"https://leanprover-community.github.io/mathlib_docs/order/compactly_generated.html\">https://leanprover-community.github.io/mathlib_docs/order/compactly_generated.html</a> I think</p>",
        "id": 234364021,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1618333369
    },
    {
        "content": "<p>I think the toric people want Z gradings, the projective scheme people want N gradings and in this proof we also want gradings by an arbitrary monoid</p>",
        "id": 234364670,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618333610
    },
    {
        "content": "<p><code>span</code> is just a statement about a Sup</p>",
        "id": 234365090,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618333742
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/267928-condensed-mathematics/topic/toric/near/234364670\">said</a>:</p>\n<blockquote>\n<p>I think the toric people want Z gradings, the projective scheme people want N gradings and in this proof we also want gradings by an arbitrary monoid</p>\n</blockquote>\n<p>IIRC a grading by a monoid M on an <code>R</code>-algebra is \"the same\" as a coaction of <code>R[M]</code>?</p>",
        "id": 234365411,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1618333861
    },
    {
        "content": "<p>Although this point of view would be hard to formalize for noncommutative monoids (since it involves a tensor product of bialgebras)</p>",
        "id": 234365530,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1618333918
    },
    {
        "content": "<p>Aha, this is some monoid scheme maybe</p>",
        "id": 234365532,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618333918
    },
    {
        "content": "<p>Do people grade with noncommutative monoids ever? <span class=\"user-mention\" data-user-id=\"317890\">@Julian Külshammer</span> ?</p>",
        "id": 234365676,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618333965
    },
    {
        "content": "<p>So in terms of lattices this map from a monoid is like a basis -- the Sup of everything is top, and the inf of (one piece) and (the Sup of all the other pieces) is zero. Is that a thing in lattices with a Sup?</p>",
        "id": 234366053,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618334108
    },
    {
        "content": "<blockquote>\n<p>Do people grade with noncommutative monoids ever? </p>\n</blockquote>\n<p>Based on what I found for <a href=\"https://leanprover-community.github.io/mathlib_docs/find/direct_sum.semiring\">docs#direct_sum.semiring</a> (as opposed to <a href=\"https://leanprover-community.github.io/mathlib_docs/find/direct_sum.comm_semiring\">docs#direct_sum.comm_semiring</a>), if your ring is not commutative then you don't need your index set to be either.<br>\nNot that that answers the question of whether its useful, just that its easy to generalize to.</p>",
        "id": 234366147,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1618334147
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/267928-condensed-mathematics/topic/toric/near/234366053\">said</a>:</p>\n<blockquote>\n<p>So in terms of lattices this map from a monoid is like a basis -- the Sup of everything is top, and the inf of (one piece) and (the Sup of all the other pieces) is zero. Is that a thing in lattices with a Sup?</p>\n</blockquote>\n<p>This sounds like some general notion of independence that comes up in matroid theory.</p>",
        "id": 234366392,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1618334224
    },
    {
        "content": "<p>Maybe this should move to #maths, this feels much more mathlibby than liquidy</p>",
        "id": 234366654,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618334314
    },
    {
        "content": "<p>I have looked a bit into your discussion, seeing that you're going to attack Gordan. I won't be of great help with the grading mafia but I'd be help to adapt the current proof of <code>lem97</code> to a new statement of <code>explicit_gordan</code>, if you come up with something different from what I used there.</p>",
        "id": 234375218,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1618337676
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> Is the emphasis on noncommutative or on monoids? There are articles written in my area of research about gradings by non-commutative groups and one definitely wants to consider <code>\\N</code>-gradings as well, so grading by possibile non-commutative monoids seems like an obvious choice for me. In most examples people compute the grading is by <code>\\N^r</code> or <code>\\Z^r</code> or <code>Z/2</code>, but I also don't see why it should be more difficult to formalise a grading by a noncommutative monoid than a commutative monoid. Do you have an example of a basic result which fails?</p>",
        "id": 234375224,
        "sender_full_name": "Julian Külshammer",
        "timestamp": 1618337678
    },
    {
        "content": "<p>There is also the case of the group algebra of a (finite) group, which is graded by the group itself.</p>",
        "id": 234377299,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1618338441
    },
    {
        "content": "<p>I know that we are going to change the statement like 30 times, but I was having too much fun, and here is the proof of theorem2 of the blueprint</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">monoid_alg_ft_iff_fg</span> <span class=\"o\">[</span><span class=\"n\">nontrivial</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"bp\">⊤</span> <span class=\"o\">:</span> <span class=\"n\">submodule</span> <span class=\"n\">ℕ</span> <span class=\"n\">M</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">fg</span> <span class=\"bp\">↔</span> <span class=\"n\">finite_type</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">add_monoid_algebra</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>It is in <a href=\"https://github.com/leanprover-community/lean-liquid/blob/riccardobrasca/src/toric/theorem2.lean\">https://github.com/leanprover-community/lean-liquid/blob/riccardobrasca/src/toric/theorem2.lean</a></p>",
        "id": 234578660,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1618435272
    },
    {
        "content": "<p>I think this might be fine -- we might later on need to apply it to something isomorphic to an add_monoid_algebra, but in this case we just will need to prove things like if A and B are isomorphic R-algebras and A is finite type then so is B.</p>",
        "id": 234578943,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618435406
    },
    {
        "content": "<p>We already have this!</p>",
        "id": 234578988,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1618435429
    },
    {
        "content": "<p>In which case I think you've done enough :-) I'm having a lot of fun with gradings, I have achieved far less today than I had hoped but it would still be wonderful to get Gordan done by the end of the week.</p>",
        "id": 234579456,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618435611
    },
    {
        "content": "<p>Kevin, is the definition of grading that you are using the one in<br>\n<a href=\"#narrow/stream/116395-maths/topic/Gradings.20on.20a.20ring/near/234389540\">https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Gradings.20on.20a.20ring/near/234389540</a></p>\n<p>I would be happy to contribute!</p>",
        "id": 234618893,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1618464091
    },
    {
        "content": "<p>Right now the technical issue is that there are two ways of saying that R is the direct sum of R_m and these should probably be unified.</p>",
        "id": 234622761,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618467584
    },
    {
        "content": "<p>Ok, if you want, I can try taking care of that.</p>",
        "id": 234622820,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1618467607
    },
    {
        "content": "<p>It's pretty gory. I need to do family stuff for another hour and then I'll have time for lean</p>",
        "id": 234622915,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618467674
    },
    {
        "content": "<p>Ok so it looks like Sebastien is fixing the mathlib diamond so I can tell you about gradings. I was going to work on this stuff today (and tomorrow), by the way.</p>\n<p>The mathlib branch <code>independent2</code> (which I'm about to PR) contains a definition of what it means for a function f:I -&gt; L (I an abstract type, L a complete lattice) to be \"independent\" -- it means that the inf of f(i) and (the Sup of the f(j) for j!=i) is bot. In applications, L will be the additive submonoids or subgroups of a ring or semiring, so this just says that f(i) intersect (subgroup generated by f(j) for j != i) is zero.</p>\n<p>The mathlib branch <code>grading</code>contains <code>independent2</code> (I merged the independent2 branch into it, even though the independent2 branch isn't in master) and also contains a recent PR of Eric's which defines <code>add_submonoid_is_internal</code>. This is a predicate on maps f : I -&gt; add_submonoid M which says \"the induced map from the direct sum of the f(i) to M is a bijection\". I've been trying to work with this and it's quite tricky. You can see for example in <code>ring_theory.grading</code> that I have an unfinished proof that R[X] is graded by the naturals and it looks pretty scary to me. Right now I am wondering whether Eric's \"the induced map from the direct sum is a bijection\" would be easier to work with if we rewrote it in the following way. The bijection is an injection and a surjection. To say that a map from a direct sum of additive abelian submonoids of M to M is injective is, I think, the same as saying that that the function from I to the submonoids is injective as above. Conversely the claim that the map is surjective is just the statement that the Sup of the image is Top (a.k.a. \"span\"). So right now I was thinking of abandoning my proof and writing more API, saying that <code>direct_sum.add_submonoid_is_internal graded_piece</code> is equivalent to <code>independent</code> + <code>span</code>. </p>\n<p>So right now as you can see it's all in quite a state, but I still feel confident that doing these examples (polynomials are graded by nat, monoid algebras are graded by the monoid) are the test cases which need to work before we can start on Gordan -- you can think of them as practice, if you like.</p>",
        "id": 234632893,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618473341
    },
    {
        "content": "<p>Kevin, thanks for the update!  I will try to take a look at grading on polynomials, then!</p>",
        "id": 234633558,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1618473644
    },
    {
        "content": "<p>The question is whether we should be continuing to battle through this proof (I think we should <em>not</em>) or whether we should prove that the bijection is an injection and a surjection, and injection is equivalent to <code>independent</code> and surjection equivalent to <code>span</code>.</p>",
        "id": 234635041,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618474398
    },
    {
        "content": "<p>I'll formalise the statement of what I'm thinking of and then push to <code>grading</code>.</p>",
        "id": 234635459,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618474614
    },
    {
        "content": "<p>Ok, thanks a lot!</p>",
        "id": 234635570,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1618474675
    },
    {
        "content": "<p>OK I pushed. In the <code>grading</code> branch of mathlib there are a bunch of sorries. My guess is that <code>direct_sum.add_submonoid_is_internal_iff_independent_and_span</code> helps (although it should be broken into two lemmas) with the examples, but I don't know for sure.</p>\n<p>Unfortunately, you might have to wait for the oleans, or make them yourself (this is what I have been doing -- I do <code>leanproject get-cache --rev 07614552f6b7157fa5582a8f2a536b390715cb14</code> and then <code>lean --make src/ring_theory/grading.lean</code> on the command line and wait about 5 minutes). Alternatively you can wait a few hours and then <code>leanproject get-cache</code> should work fine.</p>",
        "id": 234638077,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618475899
    },
    {
        "content": "<p>Thanks a lot, Kevin, for <code>grading</code> and for the instructions!</p>",
        "id": 234638293,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1618476027
    },
    {
        "content": "<p>You're describing <a href=\"https://github.com/leanprover-community/mathlib/tree/grading\">branch#grading</a> in mathlib not lean-liquid, right?</p>",
        "id": 234669386,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1618491318
    },
    {
        "content": "<p>I certainly assumed so: I pulled <code>grading</code> from mathlib.</p>",
        "id": 234669680,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1618491468
    },
    {
        "content": "<p>For polynomials i'd expect it's far easier to directly construct the inverse mapping to show bijectivity</p>",
        "id": 234671965,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1618492361
    },
    {
        "content": "<p>Which is just \"sum <code>direct_sum.of I ⟨monomial i (p.coeff i), sorry⟩</code> over <code>p.support</code>\"</p>",
        "id": 234672276,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1618492488
    },
    {
        "content": "<p>Can someone put me out of my misery?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.direct_sum</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.polynomial.basic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">polynomial</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">polynomial_equiv</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">≃</span>\n  <span class=\"n\">direct_sum</span> <span class=\"n\">ℕ</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">add_monoid_hom.mrange</span> <span class=\"o\">(</span><span class=\"n\">monomial</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_add_monoid_hom</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"gr\">sorry</span>\n<span class=\"c1\">-- error: don't know how to synthesize placeholder</span>\n</code></pre></div>\n<p>I can't get the equiv to typecheck :-(</p>",
        "id": 234681118,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618495449
    },
    {
        "content": "<p>Oh, I've got it: RHS doesn't know which poly ring. Sorry for the noise.</p>",
        "id": 234681486,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618495564
    },
    {
        "content": "<p>I am going nuts -- I have still not manage to state this equiv :-(</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.direct_sum</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.polynomial.basic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">polynomial</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">add_comm_monoid</span> <span class=\"o\">((</span><span class=\"n\">monomial</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→ₗ</span> <span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_add_monoid_hom.mrange</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">infer_instance</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">direct_sum</span> <span class=\"n\">ℕ</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">monomial</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→ₗ</span> <span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_add_monoid_hom.mrange</span><span class=\"o\">))</span> <span class=\"bp\">→</span>\n  <span class=\"n\">polynomial</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">⇑</span><span class=\"o\">(</span><span class=\"n\">direct_sum.to_add_monoid</span>\n    <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span>\n      <span class=\"o\">((</span><span class=\"n\">monomial</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→ₗ</span> <span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_add_monoid_hom.mrange.subtype</span> <span class=\"o\">:</span>\n        <span class=\"o\">((</span><span class=\"n\">monomial</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→ₗ</span> <span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_add_monoid_hom.mrange</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"bp\">→+</span> <span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">)))</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">type mismatch at application</span>\n<span class=\"cm\">  direct_sum.to_add_monoid (λ (i : ℕ), (monomial i).to_add_monoid_hom.mrange.subtype)</span>\n<span class=\"cm\">term</span>\n<span class=\"cm\">  λ (i : ℕ), (monomial i).to_add_monoid_hom.mrange.subtype</span>\n<span class=\"cm\">has type</span>\n<span class=\"cm\">  Π (i : ℕ), ↥((monomial i).to_add_monoid_hom.mrange) →+ polynomial R : Type</span>\n<span class=\"cm\">but is expected to have type</span>\n<span class=\"cm\">  Π (i : ℕ), ?m_1 i →+ ?m_2 : Type (max ? ?)</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>\n<p>What am I doing wrong?</p>",
        "id": 234689829,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618498262
    },
    {
        "content": "<p>Man, the elaborator is really getting the upper hand on you today</p>",
        "id": 234691233,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1618498718
    },
    {
        "content": "<p>My orange bars aren't cooperating so I can't help you yet</p>",
        "id": 234692895,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1618499026
    },
    {
        "content": "<p>If you break it into tiny pieces it cooperates:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">monomial_add_monoid_hom</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→+</span> <span class=\"n\">polynomial</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">monomial</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_add_monoid_hom</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">direct_sum.submonoids_to_add_monoid</span> <span class=\"o\">(</span><span class=\"n\">ι</span> <span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">ι</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">add_submonoid</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">direct_sum</span> <span class=\"n\">ι</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">A</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"bp\">→+</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n<span class=\"n\">direct_sum.to_add_monoid</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">subtype</span><span class=\"o\">)</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">direct_sum</span> <span class=\"n\">ℕ</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">monomial_add_monoid_hom</span> <span class=\"n\">R</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mrange</span><span class=\"o\">))</span> <span class=\"bp\">→+</span> <span class=\"n\">polynomial</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n<span class=\"n\">direct_sum.submonoids_to_add_monoid</span> <span class=\"n\">ℕ</span> <span class=\"o\">(</span><span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">monomial_add_monoid_hom</span> <span class=\"n\">R</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mrange</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 234696458,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1618499900
    },
    {
        "content": "<p>Ah, this works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">direct_sum</span> <span class=\"n\">ℕ</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"o\">((</span><span class=\"n\">monomial</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_add_monoid_hom</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→+</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mrange</span><span class=\"o\">))</span> <span class=\"bp\">→+</span> <span class=\"n\">polynomial</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n<span class=\"n\">direct_sum.to_add_monoid</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">monomial</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_add_monoid_hom.mrange.subtype</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 234696805,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1618500025
    },
    {
        "content": "<p>IN fact, it's the <code>⇑</code> causing you all the pain in your example</p>",
        "id": 234696968,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1618500088
    },
    {
        "content": "<p>Thanks! I put the <code>⇑</code> in because it wasn't working without it (indeed what I posted doesn't work without the <code>⇑</code> either)</p>",
        "id": 234699413,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618500858
    },
    {
        "content": "<p>Hmm, I see. This is supposed to be a field of an <code>equiv</code>. So I just tell it the type of the add_monoid_hom I guess.</p>",
        "id": 234699722,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618500950
    },
    {
        "content": "<p>My rule of thumb is that one should not put coercion arrows in lemma statements (or function coercion). If a coercion is necessary, it should be notated using typing syntax <code>(_ : _)</code>, and if it is function coercion, just apply as normal</p>",
        "id": 234700944,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1618501346
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/267928-condensed-mathematics/topic/toric/near/234699413\">said</a>:</p>\n<blockquote>\n<p>(indeed what I posted doesn't work without the <code>⇑</code> either)</p>\n</blockquote>\n<p>It does once you replace the <code>→</code> with <code>→+</code> I think</p>",
        "id": 234703814,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1618502362
    },
    {
        "content": "<p>But here's the actual problem:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.direct_sum</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.polynomial.basic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">polynomial</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">polynomial_equiv</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"n\">polynomial</span> <span class=\"n\">R</span> <span class=\"bp\">≃</span>\n  <span class=\"n\">direct_sum</span> <span class=\"n\">ℕ</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">monomial</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→ₗ</span> <span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_add_monoid_hom.mrange</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">inv_fun</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">direct_sum.to_add_monoid</span>\n    <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span>\n      <span class=\"o\">((</span><span class=\"n\">monomial</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→ₗ</span> <span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_add_monoid_hom.mrange.subtype</span> <span class=\"o\">:</span>\n        <span class=\"o\">((</span><span class=\"n\">monomial</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→ₗ</span> <span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_add_monoid_hom.mrange</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"bp\">→+</span> <span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">))),</span>\n  <span class=\"n\">left_inv</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">right_inv</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 234703860,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618502383
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>type mismatch at application\n  direct_sum.to_add_monoid (λ (i : ℕ), (monomial i).to_add_monoid_hom.mrange.subtype)\nterm\n  λ (i : ℕ), (monomial i).to_add_monoid_hom.mrange.subtype\nhas type\n  Π (i : ℕ), ↥((monomial i).to_add_monoid_hom.mrange) →+ polynomial R : Type\nbut is expected to have type\n  Π (i : ℕ), ?m_1 i →+ ?m_2 : Type (max ? ?)\n</code></pre></div>",
        "id": 234703958,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618502409
    },
    {
        "content": "<p>I got so frustrated with this that I just decided to prove the mem_supr lemmas :-)</p>",
        "id": 234704268,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618502511
    },
    {
        "content": "<p>Why not define it as an add_equiv?</p>",
        "id": 234707053,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1618503444
    },
    {
        "content": "<p>all I want to do is to prove that a function is bijective. It seemed to me that defining it as an <code>add_equiv</code> just meant I'd have to prove more things for no reason.</p>",
        "id": 234707216,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618503495
    },
    {
        "content": "<p>Here you go:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.direct_sum</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.polynomial.basic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">polynomial</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">direct_sum</span>\n<span class=\"kd\">noncomputable theory</span>\n\n<span class=\"kd\">abbreviation</span> <span class=\"n\">monomial.submonoid</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">add_submonoid</span> <span class=\"o\">(</span><span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">monomial</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→ₗ</span> <span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_add_monoid_hom.mrange</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">polynomial_equiv</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"bp\">⨁</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">monomial.submonoid</span> <span class=\"n\">R</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">≃+</span> <span class=\"n\">polynomial</span> <span class=\"n\">R</span>  <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">inv_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">p.sum</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">n</span> <span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"n\">direct_sum.of</span> <span class=\"n\">_</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">monomial</span> <span class=\"n\">n</span> <span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"n\">trivial</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩)),</span>\n  <span class=\"n\">left_inv</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">d</span><span class=\"o\">,</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">right_inv</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"bp\">..</span><span class=\"o\">(</span><span class=\"n\">direct_sum.to_add_monoid</span>\n    <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">monomial.submonoid</span> <span class=\"n\">R</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">subtype</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">⨁</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">monomial.submonoid</span> <span class=\"n\">R</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">→+</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 234708693,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1618504041
    },
    {
        "content": "<p>Thanks! I might not get back to this until tomorrow now -- right now I'm struggling with stuff like <code>∏ᶠ (i_1 : ι), ite (i_1 = i) x 1 = x</code></p>",
        "id": 234708861,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618504090
    },
    {
        "content": "<p>Solved:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.direct_sum</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.polynomial.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.polynomial</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">polynomial</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">direct_sum</span>\n<span class=\"kd\">noncomputable theory</span>\n\n<span class=\"kd\">abbreviation</span> <span class=\"n\">monomial.submonoid</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">add_submonoid</span> <span class=\"o\">(</span><span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">monomial</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→ₗ</span> <span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_add_monoid_hom.mrange</span>\n\n<span class=\"kd\">abbreviation</span> <span class=\"n\">monomial.to_submonoid</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→+</span> <span class=\"n\">monomial.submonoid</span> <span class=\"n\">R</span> <span class=\"n\">i</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">monomial</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→ₗ</span> <span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_add_monoid_hom.mrange_restrict</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">polynomial_equiv</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"bp\">⨁</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">monomial.submonoid</span> <span class=\"n\">R</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">≃+</span> <span class=\"n\">polynomial</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n<span class=\"n\">add_monoid_hom.to_add_equiv</span>\n  <span class=\"o\">(</span><span class=\"n\">direct_sum.to_add_monoid</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span>\n    <span class=\"o\">(</span><span class=\"n\">monomial.submonoid</span> <span class=\"n\">R</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">subtype</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">finsupp.lift_add_hom</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n    <span class=\"o\">(</span><span class=\"n\">direct_sum.of</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">monomial.submonoid</span> <span class=\"n\">R</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"o\">(</span><span class=\"n\">monomial.to_submonoid</span> <span class=\"n\">R</span> <span class=\"n\">n</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"kd\">begin</span>\n    <span class=\"n\">ext</span> <span class=\"n\">i</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"o\">:</span> <span class=\"mi\">2</span><span class=\"o\">,</span>\n    <span class=\"n\">dsimp</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">monomial</span><span class=\"o\">],</span>\n    <span class=\"n\">refl</span><span class=\"o\">,</span>\n  <span class=\"kd\">end</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"kd\">begin</span>\n    <span class=\"n\">ext</span> <span class=\"n\">i</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"mi\">2</span><span class=\"o\">,</span>\n    <span class=\"n\">dsimp</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">monomial</span><span class=\"o\">],</span>\n  <span class=\"kd\">end</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 234712946,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1618505524
    },
    {
        "content": "<p><code>simp ..., refl</code> also known as <code>simpa</code></p>",
        "id": 234713062,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1618505559
    },
    {
        "content": "<p><code>simp [monomial]</code> is needed because you're not supposed to use <code>finsupp.lift_add_hom</code> on polynomials</p>",
        "id": 234713100,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1618505575
    },
    {
        "content": "<p>oh it doesn't compile for me :-(</p>",
        "id": 234716800,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618506812
    },
    {
        "content": "<p>hmm, works on master, I'll have to merge into my branch.</p>",
        "id": 234718255,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618507350
    },
    {
        "content": "<p>OK great, it works on my branch, now I have to wait for several more hours and then pay some money to download oleans :-/ (my internet is broken right now)</p>",
        "id": 234719469,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618507767
    },
    {
        "content": "<p>To be honest, I do not understand the proof, but is this the same as Eric's proof, except for an <code>add_monoid_algebra</code>?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">add_monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">ι</span><span class=\"o\">]</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">polynomial</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">direct_sum</span>\n<span class=\"kd\">noncomputable theory</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">add_monoid_algebra</span>\n\n<span class=\"sd\">/-- `monomial s a` is the monomial `a * X^s` -/</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">Mm</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">add_monoid_algebra</span> <span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"o\">:=</span>\n<span class=\"n\">finsupp.lsingle</span> <span class=\"n\">i</span>\n\n<span class=\"kd\">abbreviation</span> <span class=\"n\">monomial.submonoid</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">add_submonoid</span> <span class=\"o\">(</span><span class=\"n\">add_monoid_algebra</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">Mm</span> <span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→ₗ</span> <span class=\"n\">add_monoid_algebra</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_add_monoid_hom.mrange</span>\n\n<span class=\"kd\">abbreviation</span> <span class=\"n\">monomial.to_submonoid</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→+</span> <span class=\"n\">monomial.submonoid</span> <span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"n\">i</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">Mm</span> <span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→ₗ</span> <span class=\"n\">add_monoid_algebra</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_add_monoid_hom.mrange_restrict</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">polynomial_equiv</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"bp\">⨁</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">monomial.submonoid</span> <span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">≃+</span> <span class=\"n\">add_monoid_algebra</span> <span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"o\">:=</span>\n<span class=\"n\">add_monoid_hom.to_add_equiv</span>\n  <span class=\"o\">(</span><span class=\"n\">direct_sum.to_add_monoid</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span>\n    <span class=\"o\">(</span><span class=\"n\">monomial.submonoid</span> <span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">subtype</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">finsupp.lift_add_hom</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n    <span class=\"o\">(</span><span class=\"n\">direct_sum.of</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">monomial.submonoid</span> <span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"o\">(</span><span class=\"n\">monomial.to_submonoid</span> <span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"n\">n</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"kd\">begin</span>\n    <span class=\"n\">ext</span> <span class=\"n\">i</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"o\">:</span> <span class=\"mi\">2</span><span class=\"o\">,</span>\n    <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"n\">Mm</span><span class=\"o\">],</span>\n  <span class=\"kd\">end</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"kd\">begin</span>\n    <span class=\"n\">ext</span> <span class=\"n\">i</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"mi\">2</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Mm</span><span class=\"o\">],</span>\n  <span class=\"kd\">end</span><span class=\"o\">)</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">add_monoid_algebra</span>\n</code></pre></div>",
        "id": 234734236,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1618513568
    },
    {
        "content": "<p>Right, a monoid_algebra version is probably sensible</p>",
        "id": 234736289,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1618514345
    },
    {
        "content": "<p>You can use finsupp.single_add_hom instead of touching lsingle</p>",
        "id": 234736357,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1618514368
    },
    {
        "content": "<p>I have not managed to get <code>finsupp.single_add_hom</code> to work.</p>\n<p>However, if I replace randomly <code>add_monoid_algebra</code> with <code>monoid_algebra</code>, not even everywhere, it seems to me that Lean does not complain: is this normal?</p>",
        "id": 234737218,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1618514674
    },
    {
        "content": "<p>Am I missing something?</p>",
        "id": 234737240,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1618514680
    },
    {
        "content": "<p>About the <code>finsupp.single_add_hom</code>: I should change the type of <code>Mm (i : M)</code> to be <code>R →+ add_monoid_algebra R M</code>, right?</p>\n<p>If I do so, though, the abbreviations are not happy afterwards...</p>",
        "id": 234738030,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1618514961
    },
    {
        "content": "<p>I think actually we want the version relating dfinsupp and finsupp</p>",
        "id": 234738328,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1618515057
    },
    {
        "content": "<p>Got it!</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- `monomial s a` is the monomial `a * X^s` -/</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">Mm</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→+</span> <span class=\"n\">add_monoid_algebra</span> <span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"o\">:=</span>\n<span class=\"n\">finsupp.single_add_hom</span> <span class=\"n\">i</span>\n\n<span class=\"kd\">abbreviation</span> <span class=\"n\">monomial.submonoid</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">add_submonoid</span> <span class=\"o\">(</span><span class=\"n\">add_monoid_algebra</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">Mm</span> <span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→+</span> <span class=\"n\">add_monoid_algebra</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mrange</span>\n\n<span class=\"kd\">abbreviation</span> <span class=\"n\">monomial.to_submonoid</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→+</span> <span class=\"n\">monomial.submonoid</span> <span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"n\">i</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">Mm</span> <span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→+</span> <span class=\"n\">add_monoid_algebra</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mrange_restrict</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">polynomial_equiv</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"bp\">⨁</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">monomial.submonoid</span> <span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">≃+</span> <span class=\"n\">add_monoid_algebra</span> <span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"o\">:=</span>\n<span class=\"n\">add_monoid_hom.to_add_equiv</span>\n  <span class=\"o\">(</span><span class=\"n\">direct_sum.to_add_monoid</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span>\n    <span class=\"o\">(</span><span class=\"n\">monomial.submonoid</span> <span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">subtype</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">finsupp.lift_add_hom</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n    <span class=\"o\">(</span><span class=\"n\">direct_sum.of</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">monomial.submonoid</span> <span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"o\">(</span><span class=\"n\">monomial.to_submonoid</span> <span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"n\">n</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"kd\">begin</span>\n    <span class=\"n\">ext</span> <span class=\"n\">i</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"o\">:</span> <span class=\"mi\">2</span><span class=\"o\">,</span>\n    <span class=\"n\">simpa</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Mm</span><span class=\"o\">,</span> <span class=\"n\">set_like.coe_mk</span><span class=\"o\">,</span> <span class=\"n\">finsupp.lift_add_hom_apply_single</span><span class=\"o\">,</span> <span class=\"n\">direct_sum.to_add_monoid_of</span><span class=\"o\">,</span>\n      <span class=\"n\">add_monoid_hom.coe_comp</span><span class=\"o\">,</span> <span class=\"n\">finsupp.single_add_hom_apply</span><span class=\"o\">,</span> <span class=\"n\">function.comp_app</span><span class=\"o\">,</span>\n      <span class=\"n\">add_submonoid.coe_subtype</span><span class=\"o\">],</span>\n  <span class=\"kd\">end</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"kd\">begin</span>\n    <span class=\"n\">ext</span> <span class=\"n\">i</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"mi\">2</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Mm</span><span class=\"o\">,</span> <span class=\"n\">finsupp.lift_add_hom_apply_single</span><span class=\"o\">,</span> <span class=\"n\">direct_sum.to_add_monoid_of</span><span class=\"o\">,</span>\n      <span class=\"n\">add_monoid_hom.coe_mrange_restrict</span><span class=\"o\">,</span> <span class=\"n\">add_monoid_hom.coe_comp</span><span class=\"o\">,</span> <span class=\"n\">finsupp.single_add_hom_apply</span><span class=\"o\">,</span>\n      <span class=\"n\">function.comp_app</span><span class=\"o\">,</span> <span class=\"n\">add_submonoid.coe_subtype</span><span class=\"o\">,</span> <span class=\"n\">add_monoid_hom.id_apply</span><span class=\"o\">],</span>\n  <span class=\"kd\">end</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 234738331,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1618515058
    },
    {
        "content": "<p>So replace <code>add_monoid_algebra</code> with <code>finsupp</code>, and <code>direct_sum</code> with <code>dfinsupp</code></p>",
        "id": 234738479,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1618515118
    },
    {
        "content": "<p>In any case, I view this simply as a confirmation that your approach is very robust: I could adapt it to work for the (add_)monoid_graded case, from the polynomial case, without actually understanding how it was working!</p>",
        "id": 234738481,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1618515120
    },
    {
        "content": "<p>Well those types are defeq!</p>",
        "id": 234738558,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1618515137
    },
    {
        "content": "<p>I'll PR a dfinsupp / finsupp version tomorrow</p>",
        "id": 234738632,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1618515162
    },
    {
        "content": "<blockquote>\n<p>Well those types are defeq!</p>\n</blockquote>\n<p>Aaah, that explains why Lean simply liked all of it!</p>",
        "id": 234738707,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1618515184
    },
    {
        "content": "<p>If you're looking for practice, we probably want a linear_equiv / submodule version of that def too</p>",
        "id": 234739170,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1618515339
    },
    {
        "content": "<p>I tried to do the replacement <code>finsupp + dfinsupp</code>, but I have failed.  It is also getting late, so I may not give it a go tonight!</p>",
        "id": 234739279,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1618515375
    },
    {
        "content": "<p>The key trick in the proof was to phrase things in a way that ext could pick up</p>",
        "id": 234739327,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1618515392
    },
    {
        "content": "<p>Btw, what is the <code>: 2</code> in ext?</p>",
        "id": 234739366,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1618515409
    },
    {
        "content": "<p>Ie, by solving <code>f.comp f_inv = id</code></p>",
        "id": 234739373,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1618515412
    },
    {
        "content": "<p>\"don't expand as far as p.coeff I\"</p>",
        "id": 234739396,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1618515423
    },
    {
        "content": "<p>ah, like <code>congr' 2</code>?</p>",
        "id": 234739441,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1618515441
    },
    {
        "content": "<p>It means \"apply ext twice\"</p>",
        "id": 234739457,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1618515448
    },
    {
        "content": "<p>except with ext?</p>",
        "id": 234739458,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1618515448
    },
    {
        "content": "<p>Yes</p>",
        "id": 234739463,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1618515450
    },
    {
        "content": "<p>I squeezed the the two <code>simp</code>s to speed up the processing: there is quite a lot of lemmas that show up!</p>",
        "id": 234741985,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1618516443
    },
    {
        "content": "<p>Anyway, I'm off for the day!</p>\n<p>Kevin and Eric, thanks a lot for gradings!</p>",
        "id": 234742052,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1618516467
    },
    {
        "content": "<p>These isomorphisms aren't the end of it, but they're definitely the hardest part. One also needs to check that <code>1</code> and <code>*</code> are well-behaved.</p>",
        "id": 234760240,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618523604
    },
    {
        "content": "<p>For polynomials this was easy. So this looks like it's a workable definition.</p>",
        "id": 234760289,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618523635
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/issues/7217\">#7217</a></p>",
        "id": 234813787,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1618561246
    },
    {
        "content": "<p>Typeclass search really wasn't happy here</p>",
        "id": 234813928,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1618561320
    },
    {
        "content": "<p>Frustratingly <code>add_monoid_hom.range</code> and <code>add_monoid_hom.mrange</code> are not defeq as types, so probably some refactoring to do before I can get the add_comm_group version easily</p>",
        "id": 234816948,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1618562776
    },
    {
        "content": "<p>These two monoid <code>range</code> things can be a bit annoying to work with because the definition always involves having to prove <code>mem_top</code>. <code>set.range</code> does not have this problem.</p>",
        "id": 234825583,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618566881
    },
    {
        "content": "<p>Have a look at <a href=\"https://leanprover-community.github.io/mathlib_docs/find/add_monoid_hom.range/src\">src#add_monoid_hom.range</a>, it solves that problem</p>",
        "id": 234830692,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1618569341
    },
    {
        "content": "<p>Once my other two cleanup PRs go though (<a href=\"https://github.com/leanprover-community/mathlib/issues/7218\">#7218</a>, <a href=\"https://github.com/leanprover-community/mathlib/issues/7220\">#7220</a>), I'll see what breaks if we do that everywhere</p>",
        "id": 234830904,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1618569435
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/subgroup.range\">docs#subgroup.range</a> ?</p>",
        "id": 234831388,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618569664
    },
    {
        "content": "<p>Oops, fixed</p>",
        "id": 234831684,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1618569841
    },
    {
        "content": "<p>It uses <a href=\"https://leanprover-community.github.io/mathlib_docs/find/subgroup.copy\">docs#subgroup.copy</a> to make it definitionally useful</p>",
        "id": 234831758,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1618569863
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> I need some API for <code>finite_free</code>. In <code>polyhedral_lattice.basic</code> you have a <code>move_this</code> section containing the definition. If I remove <code>[semimodule ℤ A]</code> from the definition (<code>A</code> is an <code>add_comm_group</code>) then the <code>combinatorial_lemma</code> file stops compiling: I get an error on line 378 with <code>rw oops</code> failing; <code>oops</code> is a proof of <code>@polyhedral_lattice.int_semimodule Λ _ = @add_comm_group.int_module Λ _</code>. If I remove the proof of <code>oops</code> and the rewrite, things work again. Is this what I'm supposed to be doing or are there reasons for me not to fiddle with this? The reason I ask is that my instinct is to set up <code>finite_free</code> for <code>comm_group</code>s as well as <code>add_comm_group</code>s and I'm not sure a <code>comm_group</code> can be a Z-module  in Lean.</p>",
        "id": 235361769,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618931866
    },
    {
        "content": "<p>bleurgh I now get errors in <code>polyhedral_lattice.finsupp</code>. Maybe I'll leave this until after the int refactor, my guess is that I have clashing semimodule instances here.</p>",
        "id": 235363226,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618932327
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> All of this will be solved in 1 or 2 days, when <span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span>'s <code>gsmul</code> PR is merged into mathlib.</p>",
        "id": 235391985,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1618943399
    },
    {
        "content": "<p>So I would suggest to just add <code>[semimodule int A]</code> assumptions for now, and we'll remove them in two days.</p>",
        "id": 235392131,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1618943432
    },
    {
        "content": "<p>The next problem I find I'm running into is that I'm reluctant to do anything involving <code>is_basis</code> now Anne has told us that they're bundling it. Right now I'm sorrying a bunch of basic algebra stuff and just trying to push on with the more serious stuff.</p>",
        "id": 235421479,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618955081
    },
    {
        "content": "<p>It seems that every time I try to generalize things about <code>finsupp</code> / <code>add_monoid_algebra</code> / <code>dfinsupp</code> / <code>direct_sum</code>, it makes things harder not easier for me... After making what I thought would be some handy API in <a href=\"https://github.com/leanprover-community/mathlib/issues/7217\">#7217</a> and <a href=\"https://github.com/leanprover-community/mathlib/issues/7293\">#7293</a>, I had to fight an <a href=\"https://github.com/leanprover-community/mathlib/blob/5d206164388594cfdb0f9a6dc4fa75441cc95a30/src/algebra/direct_sum_graded_monoid_algebra.lean#L33-L37\">more-awful-than-before battle</a> against the elaborator, and a <a href=\"https://github.com/leanprover-community/mathlib/blob/5d206164388594cfdb0f9a6dc4fa75441cc95a30/src/algebra/direct_sum_graded_monoid_algebra.lean#L65-L80\">similarly awful fight with <code>ext</code></a>. In the end <a href=\"https://github.com/leanprover-community/mathlib/blob/5d206164388594cfdb0f9a6dc4fa75441cc95a30/src/algebra/direct_sum_graded_monoid_algebra.lean#L60-L87\">I was able to construct</a>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- There is a ring equivalence between an `add_monoid_algebra` (e.g. a `polynomial`) and</span>\n<span class=\"sd\">the direct sum of `single_mrange k i` (e.g. the monomials of degree `i`). -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">to_direct_sum_mrange</span> <span class=\"o\">:</span> <span class=\"n\">add_monoid_algebra</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"bp\">≃+*</span> <span class=\"bp\">⨁</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"n\">single_mrange</span> <span class=\"n\">k</span> <span class=\"n\">i</span> <span class=\"o\">:=</span> <span class=\"n\">_</span>\n</code></pre></div>",
        "id": 235559500,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619029975
    },
    {
        "content": "<p>But these feel to me like the things we need in the API, so it's great that you're managing to do them; hopefully users can just hide behind what you're doing. The maps are nice, the proofs are hard but hopefully people will only need the maps.</p>",
        "id": 235560992,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619030643
    },
    {
        "content": "<p>But even using the maps was hard</p>",
        "id": 235561894,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619031023
    },
    {
        "content": "<p>See my first link</p>",
        "id": 235561939,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619031043
    },
    {
        "content": "<p><code>@</code> and <code>letI</code> everywhere</p>",
        "id": 235561969,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619031064
    },
    {
        "content": "<p>It's great that you are working on this! I haven't had the time, energy, and guts to work on this so far.</p>",
        "id": 235564127,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1619031896
    },
    {
        "content": "<p>But I'm wondering if things become easier when you try to do everything in terms of internal sums? So without <code>dfinsupp</code>.</p>",
        "id": 235564205,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1619031929
    },
    {
        "content": "<p>By internal sum I assume you mean some subtype of <code>finsupp</code>?</p>",
        "id": 235567252,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619033174
    },
    {
        "content": "<p>Well, or maybe even submodules of <code>add_monoid_algebra</code></p>",
        "id": 235568115,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1619033531
    },
    {
        "content": "<p>Can we have an \"intrinsic\" definition of <code>graded_ring</code>?</p>",
        "id": 235568171,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1619033552
    },
    {
        "content": "<p>Part of the motivation here was to enable a graded ring whose components are <a href=\"https://leanprover-community.github.io/mathlib_docs/find/pi_tensor_product\">docs#pi_tensor_product</a></p>",
        "id": 235569157,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619033952
    },
    {
        "content": "<p>For which an external direct sum is easier</p>",
        "id": 235569186,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619033969
    },
    {
        "content": "<p>But I suppose you can always have an internal direct sum of a sigma type</p>",
        "id": 235573148,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619035643
    },
    {
        "content": "<p>Graded ring = monoid object in the category of graded abelian groups. Can we make such a definition useful?</p>",
        "id": 235575511,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1619036721
    },
    {
        "content": "<p>Probably all the problems are there already in grading abelian groups?</p>",
        "id": 235585812,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619040719
    },
    {
        "content": "<p>Adam gave an update so I thought I'd give one too. I've had to made an API for gradings on rings and this has turned out to be delicate, just for stupid reasons: <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi><mo>=</mo><msub><mo>⨁</mo><mi>m</mi></msub><msub><mi>R</mi><mi>m</mi></msub></mrow><annotation encoding=\"application/x-tex\">R=\\bigoplus_mR_m</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0497100000000001em;vertical-align:-0.29971000000000003em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:-0.0000050000000000050004em;\">⨁</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.0016819999999999613em;\"><span style=\"top:-2.40029em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">m</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.29971000000000003em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">m</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> but the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>R</mi><mi>m</mi></msub></mrow><annotation encoding=\"application/x-tex\">R_m</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">m</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> are either additive subgroups of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> or abstract groups in their own right, so it seems that there are several ways of stating things, and I'm still not sure which is the most useful. For example I've managed to state in no fewer than four ways the fact that if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>r</mi><mo>∈</mo><msub><mi>R</mi><mi>m</mi></msub></mrow><annotation encoding=\"application/x-tex\">r\\in R_m</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">m</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> then the <code>m</code>th component of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>r</mi></mrow><annotation encoding=\"application/x-tex\">r</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span></span></span></span> is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>r</mi></mrow><annotation encoding=\"application/x-tex\">r</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span></span></span></span>. The main problem of course is that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi><mo>=</mo><msub><mo>⨁</mo><mi>m</mi></msub><msub><mi>R</mi><mi>m</mi></msub></mrow><annotation encoding=\"application/x-tex\">R=\\bigoplus_m R_m</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0497100000000001em;vertical-align:-0.29971000000000003em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:-0.0000050000000000050004em;\">⨁</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.0016819999999999613em;\"><span style=\"top:-2.40029em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">m</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.29971000000000003em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">m</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> is not true in Lean -- instead <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi><mo>≅</mo><msub><mo>⨁</mo><mi>m</mi></msub><msub><mi>R</mi><mi>m</mi></msub></mrow><annotation encoding=\"application/x-tex\">R\\cong \\bigoplus_m R_m</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≅</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0497100000000001em;vertical-align:-0.29971000000000003em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:-0.0000050000000000050004em;\">⨁</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.0016819999999999613em;\"><span style=\"top:-2.40029em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">m</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.29971000000000003em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">m</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> and neither map is remotely close to being the identity. </p>\n<p>I've reduced Gordan's Lemma (modulo some easy sorrys which I'm reluctant to fill in because <code>is_basis</code> is being refactored) to this lemma in commutative algebra that if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> is Noetherian and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\Z</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Z</span></span></span></span></span>-graded then <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>A</mi><mrow><mo>≥</mo><mn>0</mn></mrow></msub></mrow><annotation encoding=\"application/x-tex\">A_{\\geq0}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.928509em;vertical-align:-0.24517899999999998em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.301108em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mrel mtight\">≥</span><span class=\"mord mtight\">0</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.24517899999999998em;\"><span></span></span></span></span></span></span></span></span></span> is finitely-generated over <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>A</mi><mn>0</mn></msub></mrow><annotation encoding=\"application/x-tex\">A_0</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>, plus the assertion that if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ϕ</mi><mo>:</mo><msup><mi mathvariant=\"double-struck\">Z</mi><mi>n</mi></msup><mo>→</mo><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\phi:\\Z^n\\to\\Z</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">ϕ</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathbb\">Z</span></span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Z</span></span></span></span></span> is non-zero then the kernel is finite free of rank less than <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>. The former fact will be possible but of course we'll have the usual nonsense about how <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>A</mi><mn>0</mn></msub></mrow><annotation encoding=\"application/x-tex\">A_0</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>A</mi><mrow><mo>≥</mo><mn>0</mn></mrow></msub></mrow><annotation encoding=\"application/x-tex\">A_{\\geq0}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.928509em;vertical-align:-0.24517899999999998em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.301108em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mrel mtight\">≥</span><span class=\"mord mtight\">0</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.24517899999999998em;\"><span></span></span></span></span></span></span></span></span></span> are subrings but we want to consider them as rings and algebras etc etc; I've struggled through stuff like this before and I'm sure it will be possible. As for the subgroups of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi mathvariant=\"double-struck\">Z</mi><mi>n</mi></msup></mrow><annotation encoding=\"application/x-tex\">\\Z^n</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathbb\">Z</span></span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span></span></span>, I'm just hoping that we will have enough general machinery to make this not too hard.</p>",
        "id": 236100660,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619391903
    },
    {
        "content": "<p>It sounds like Coq may now have enough basics on polyhedral stuff for the \"convex geometry\" proof of Gordan's lemma <a href=\"https://arxiv.org/abs/2104.15021\">https://arxiv.org/abs/2104.15021</a></p>",
        "id": 237213328,
        "sender_full_name": "Peter Scholze",
        "timestamp": 1620069235
    },
    {
        "content": "<p>Are you now following computer science and logic on arXiv? Johan, what have we done?</p>",
        "id": 237216077,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1620070449
    },
    {
        "content": "<p>No I'm not, no worries</p>",
        "id": 237216900,
        "sender_full_name": "Peter Scholze",
        "timestamp": 1620070782
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"246273\">@Bhavik Mehta</span> and <span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> are developing a lot of convex geometry on the Discord.</p>",
        "id": 237218460,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1620071443
    },
    {
        "content": "<p>Oh hey yeah! Anything you need?</p>",
        "id": 237218580,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1620071497
    },
    {
        "content": "<p>A port of that paper would be nice <span aria-label=\"stuck out tongue wink\" class=\"emoji emoji-1f61c\" role=\"img\" title=\"stuck out tongue wink\">:stuck_out_tongue_wink:</span></p>",
        "id": 237218680,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1620071536
    },
    {
        "content": "<p>I think we might have enough convex geometry to get close to the geometry proof of Gordan's lemma since we have Krein-Milman, HB and supporting/separating hyperplane lemmas</p>",
        "id": 237221617,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1620072833
    },
    {
        "content": "<p>But from talking to <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> I understand it might be better to get the algebraic proof so that the theory of graded rings gets developed better?</p>",
        "id": 237221788,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1620072901
    },
    {
        "content": "<p>Well, we should have both, so that the theory of convex polyhedra and the theory of graded rings get developed better</p>",
        "id": 237221870,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1620072931
    },
    {
        "content": "<p>I read through the paper and all of this sounds very doable and interesting! I'm already PRing exposed faces, and then Krein-Milman. We shall see how far I get on the rest.</p>",
        "id": 237520723,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1620230438
    },
    {
        "content": "<p>Ah, and Bhavik seems to be already gone proving Gordan's lemma <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 237520836,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1620230470
    },
    {
        "content": "<p>Yes he's live streaming the topological proof on discord right now</p>",
        "id": 237521681,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1620230769
    },
    {
        "content": "<p>If we are still interested in the algebraic proof <code>add_monoid_algebra.finite_type_iff_fg</code> is now in mathlib. I will add the easy (and I think useless for LTE) version for groups next week.</p>",
        "id": 237827386,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1620396028
    },
    {
        "content": "<p>I think the algebraic proof is still the one we are aiming for.</p>",
        "id": 237837609,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1620399944
    },
    {
        "content": "<p>Unless <span class=\"user-mention\" data-user-id=\"246273\">@Bhavik Mehta</span> and <span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> think they can prove <code>explicit_gordan</code> before Kevin is done with grading exams, of course.</p>",
        "id": 237837878,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1620400055
    },
    {
        "content": "<p>That depends on whether Kevin finishes grading exams by Monday or not <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>",
        "id": 237844929,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1620402538
    },
    {
        "content": "<p>Ha! You think you'll be done by Monday? Sounds great!</p>",
        "id": 237847741,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1620403538
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"246273\">@Bhavik Mehta</span> just to be clear, there are several \"Gordan's Lemma\"s in the literature -- the one we want is much stronger than the one we were talking about recently, it needs all that matrix elimination stuff. I pointed you to precisely the lemma we needed in the LTE IIRC</p>",
        "id": 237874963,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1620414581
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/267928-condensed-mathematics/topic/toric/near/237874963\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"246273\">Bhavik Mehta</span> just to be clear, there are several \"Gordan's Lemma\"s in the literature -- the one we want is much stronger than the one we were talking about recently, it needs all that matrix elimination stuff. I pointed you to precisely the lemma we needed in the LTE IIRC</p>\n</blockquote>\n<p>In what sense is it much stronger? I think the only difference from the one we talked about (with finite intersections of rational hyperplanes) was that the version I was doing was for Z^n rather than any more general version</p>",
        "id": 237879977,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1620416757
    },
    {
        "content": "<p>Bhavik, if you can prove the version in LTE that would be absolutely fabulous. I am just pointing out that you showed me a lemma in a book and the lemma was called Gordan's Lemma but it was not what we are calling Gordan's Lemma, and what we want is what we are calling Gordan's Lemma.</p>",
        "id": 237885805,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1620419451
    },
    {
        "content": "<p>We were initially going to do the topological proof, but then I decided that the algebraic proof looked easier, so I started on this, but then internal grading turned out to be subtle (but do-able) so I'm persevering with it, but now the topological proof is looking easier again. </p>\n<p>I just did <code>rw submodule.smul_mem</code> and it failed, so I did <code>rw @submodule.smul_mem [fill in all the fields]</code> and <a href=\"https://gist.github.com/kbuzzard/0d90aae44ce2034af134400be2065d0a\">this happened</a>. Note that <code>pp.all</code> was off, I just triggered the Lean \"display more information if the pretty printer says that the terms match but I know they don't\".</p>",
        "id": 237886336,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1620419690
    },
    {
        "content": "<p>But my work will not be wasted because we have developed a grading API and I'm putting it through its paces (I suspect I know what I did wrong to get that error, by the way!)</p>",
        "id": 237886743,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1620419896
    },
    {
        "content": "<p>If I use <code>convert</code> instead of <code>refine</code> then my 2000-line-long error turns into</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">grade_zero.has_scalar</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">),</span> <span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"bp\">ᵢ</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">smul_with_zero.to_has_scalar</span>\n</code></pre></div>",
        "id": 237901238,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1620427683
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/267928-condensed-mathematics/topic/toric/near/237847741\">said</a>:</p>\n<blockquote>\n<p>Ha! You think you'll be done by Monday? Sounds great!</p>\n</blockquote>\n<p>A little late, but the gordan-bm branch of LTE now has an almost sorry-free proof of Gordan's lemma: the <em>only</em> sorry in the proof is showing that the dual of a finite free group is finite free; I'm pretty sure this is easy but I left it in case someone else was already doing it</p>",
        "id": 238542922,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1620852913
    },
    {
        "content": "<p>This last fact is probably even in mathlib!</p>",
        "id": 238543083,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1620852973
    },
    {
        "content": "<p>I think dual bases in mathlib are only for fields currently?</p>",
        "id": 238543123,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1620852989
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/basis.dual_basis\">docs#basis.dual_basis</a></p>",
        "id": 238543178,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1620853024
    },
    {
        "content": "<p>Ah yeah</p>",
        "id": 238543219,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1620853037
    },
    {
        "content": "<p>Right, it requires <code>K</code> to be a field whereas here it's the integers</p>",
        "id": 238543234,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1620853044
    },
    {
        "content": "<p>That's a shame</p>",
        "id": 238543251,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1620853053
    },
    {
        "content": "<p>I think it should mostly work for rings still</p>",
        "id": 238543259,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1620853057
    },
    {
        "content": "<p>If I have time I'll try to generalize that dual basis in mathlib.</p>",
        "id": 238543572,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1620853202
    },
    {
        "content": "<p>I want to play with these bundled bases anyway</p>",
        "id": 238543804,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1620853272
    },
    {
        "content": "<p>Mathlib probably needs a good API for free modules anyway.  My plan for next week was to start working on the rank of the kernel of a non zero <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi mathvariant=\"bold\">Z</mi><mi>n</mi></msup><mo>→</mo><mi mathvariant=\"bold\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbf{Z}^n \\to \\mathbf{Z}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68611em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbf\">Z</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68611em;vertical-align:0em;\"></span><span class=\"mord mathbf\">Z</span></span></span></span> and see what is missing.</p>",
        "id": 238544921,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1620853734
    },
    {
        "content": "<p>Do we even have <code>module.is_free</code> or something like that?</p>",
        "id": 238546562,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1620854439
    },
    {
        "content": "<p>I think Johan suggested to make a classe <code>finite_free</code> and build and API</p>",
        "id": 238547009,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1620854678
    },
    {
        "content": "<p>I don't think we have <code>module.is_free</code>, at least looking at how <a href=\"https://leanprover-community.github.io/mathlib_docs/find/submodule.basis_of_pid\">docs#submodule.basis_of_pid</a> is stated</p>",
        "id": 238547104,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1620854731
    },
    {
        "content": "<p>So we have projective modules and flat modules but not free modules?? :-) PS <span class=\"user-mention\" data-user-id=\"385895\">@Jon Eugster</span> you might like it over here.</p>",
        "id": 238551421,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1620857034
    },
    {
        "content": "<p>FYI: The section involving <a href=\"https://leanprover-community.github.io/mathlib_docs/find/basis.dual_basis\">docs#basis.dual_basis</a> ccompiles just fine if one replaces <code>[field K]</code> with <code>[comm_ring K]</code>, except for <a href=\"https://leanprover-community.github.io/mathlib_docs/find/basis.dual_dim_eq\">docs#basis.dual_dim_eq</a> which relies on the definition of <code>module.rank</code> which requires a field. I guess doing this properly would require defining the rank of a module which has a basis and showing that it doesn't depend on the choice of basis, and I don't have the energy to do such a large refactor...</p>",
        "id": 238559645,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1620862512
    },
    {
        "content": "<p>I think it's a good idea to generalize all the dual basis stuff. (And just leave <code>dual_dim_eq</code> for fields, for now.)</p>",
        "id": 238580949,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1620881236
    },
    {
        "content": "<p>In a separate refactor <code>module.rank</code> can be generalized.</p>",
        "id": 238580957,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1620881250
    },
    {
        "content": "<p>Note that <span class=\"user-mention\" data-user-id=\"260921\">@Markus Himmel</span> added <code>invariant_basis_number</code> to mathlib some while ago, and I've already used it succesfully for some of the <code>finite_free</code> sorries in LTE.</p>",
        "id": 238581045,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1620881305
    },
    {
        "content": "<p>I'm preparing a PR generalising dual basis</p>",
        "id": 238583094,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1620883563
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/issues/7599\">#7599</a></p>",
        "id": 238585083,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1620885735
    },
    {
        "content": "<p>It's on the merge queue, so hopefully we will have a sorry-free gordan in a couple of hours</p>",
        "id": 238732178,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1620979419
    },
    {
        "content": "<p>Well done to <span class=\"user-mention\" data-user-id=\"246273\">@Bhavik Mehta</span> who pushed through the topological proof in the end. So what is the current status of the proof of 9.4 of Analytic.pdf?</p>",
        "id": 238734658,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1620980974
    },
    {
        "content": "<p>Well done to <span class=\"user-mention\" data-user-id=\"246273\">@Bhavik Mehta</span> who pushed through the topological proof in the end. So what is the current status of the proof of 9.4 of Analytic.pdf?</p>",
        "id": 238734681,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1620980990
    },
    {
        "content": "<p>The current status is that Patrick is making good progress on 9.2.<br>\nAnd I want to define the Cech nerves that we need for <code>col_exact</code> pretty soon. But we need to find a timeslot where Adam and me are both available. And theres something like 8 hrs of timezone difference...</p>",
        "id": 238734841,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1620981073
    },
    {
        "content": "<p>I also want to do some refactoring, to make things smoother.</p>",
        "id": 238734982,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1620981171
    },
    {
        "content": "<p>So in the end this whole formalized maths thing has some connection to reality: each time topology and algebra can both be used, the topology proof is nicer!</p>",
        "id": 238735029,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1620981190
    },
    {
        "content": "<p>For example, <code>9.2</code> is currently stated for arbitrary powers of <code>M</code>. But that is very unnatural.</p>",
        "id": 238735034,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1620981191
    },
    {
        "content": "<p>Hopefully I'll have time to work on 9.2 today. Johan, did you read <a href=\"https://github.com/leanprover-community/lean-liquid/blob/master/src/prop_92/concrete.lean\">https://github.com/leanprover-community/lean-liquid/blob/master/src/prop_92/concrete.lean</a>?</p>",
        "id": 238735191,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1620981261
    },
    {
        "content": "<p>Reading it is not necessary, but I think you may find it interesting</p>",
        "id": 238735230,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1620981293
    },
    {
        "content": "<p>I read it a while ago. Let me have another look.</p>",
        "id": 238735504,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1620981435
    },
    {
        "content": "<p>I like the abstraction over <code>Tinv</code>. And doing the <code>T_inv _ Tinv</code> conjugation in the induction. It seems to work very well.</p>",
        "id": 238735545,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1620981465
    },
    {
        "content": "<p>Here is an example of what was slowing me down with the algebraic proof. Say <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> is a commutative ring and then later on you come up with a <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\Z</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord mathbb\">Z</span></span></span></span>-grading on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>, so additive subgroups <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>R</mi><mi>n</mi></msub></mrow><annotation encoding=\"application/x-tex\">R_n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>∈</mo><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">n\\in\\Z</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord mathbb\">Z</span></span></span></span> with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn><mo>∈</mo><msub><mi>R</mi><mn>0</mn></msub></mrow><annotation encoding=\"application/x-tex\">1\\in R_0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68354em;vertical-align:-0.0391em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>R</mi><mi>m</mi></msub><msub><mi>R</mi><mi>n</mi></msub><mo>⊆</mo><msub><mi>R</mi><mrow><mi>m</mi><mo>+</mo><mi>n</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">R_mR_n\\subseteq R_{m+n}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">m</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⊆</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.891661em;vertical-align:-0.208331em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.25833100000000003em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">m</span><span class=\"mbin mtight\">+</span><span class=\"mord mathnormal mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.208331em;\"><span></span></span></span></span></span></span></span></span></span> and such that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi><mo>=</mo><mo>⨁</mo><msub><mi>R</mi><mi>n</mi></msub></mrow><annotation encoding=\"application/x-tex\">R=\\bigoplus R_n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.00001em;vertical-align:-0.25001em;\"></span><span class=\"mop op-symbol small-op\" style=\"position:relative;top:-0.0000050000000000050004em;\">⨁</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> (this is \"=\" in the obvious untrue sense). I proved that if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> was Noetherian then <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>R</mi><mi>n</mi></msub></mrow><annotation encoding=\"application/x-tex\">R_n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> was a finitely-generated <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>R</mi><mn>0</mn></msub></mrow><annotation encoding=\"application/x-tex\">R_0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>-module generated by a finset <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>S</mi><mi>n</mi></msub><mo>⊆</mo><msub><mi>R</mi><mi>n</mi></msub></mrow><annotation encoding=\"application/x-tex\">S_n\\subseteq R_n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⊆</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>, and next I want to prove that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>R</mi><mrow><mo>≥</mo><mn>0</mn></mrow></msub></mrow><annotation encoding=\"application/x-tex\">R_{\\geq0}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.928509em;vertical-align:-0.24517899999999998em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.301108em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mrel mtight\">≥</span><span class=\"mord mtight\">0</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.24517899999999998em;\"><span></span></span></span></span></span></span></span></span></span> is a finitely-generated <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>R</mi><mn>0</mn></msub></mrow><annotation encoding=\"application/x-tex\">R_0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>-algebra, but now you have to move your finite generators of the promoted-to-type <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>R</mi><mi>n</mi></msub></mrow><annotation encoding=\"application/x-tex\">R_n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>≥</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">n\\geq0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≥</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span> into the also promoted-to-a-type <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>R</mi><mrow><mo>≥</mo><mn>0</mn></mrow></msub></mrow><annotation encoding=\"application/x-tex\">R_{\\geq0}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.928509em;vertical-align:-0.24517899999999998em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.301108em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mrel mtight\">≥</span><span class=\"mord mtight\">0</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.24517899999999998em;\"><span></span></span></span></span></span></span></span></span></span>, defined as the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>r</mi></mrow><annotation encoding=\"application/x-tex\">r</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span></span></span></span> such that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>r</mi><mi>z</mi></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">r_z=0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.04398em;\">z</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span> for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>z</mi><mo>&lt;</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">z&lt;0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.04398em;\">z</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span>, and you have to move your theorem which says that an arbitrary <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>r</mi><mo>∈</mo><msub><mi>R</mi><mi>n</mi></msub></mrow><annotation encoding=\"application/x-tex\">r\\in R_n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> is spanned by <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>S</mi><mi>n</mi></msub></mrow><annotation encoding=\"application/x-tex\">S_n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> to a theorem which says that the corresponding <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>r</mi><mo>∈</mo><msub><mi>R</mi><mrow><mo>≥</mo><mn>0</mn></mrow></msub></mrow><annotation encoding=\"application/x-tex\">r\\in R_{\\geq0}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.928509em;vertical-align:-0.24517899999999998em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.301108em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mrel mtight\">≥</span><span class=\"mord mtight\">0</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.24517899999999998em;\"><span></span></span></span></span></span></span></span></span></span> is in the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>R</mi><mn>0</mn></msub></mrow><annotation encoding=\"application/x-tex\">R_0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>-span of the moved <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>S</mi><mi>n</mi></msub></mrow><annotation encoding=\"application/x-tex\">S_n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> etc. Now I write I realise that I should write down an <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>R</mi><mn>0</mn></msub></mrow><annotation encoding=\"application/x-tex\">R_0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>-module morphism from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>R</mi><mi>n</mi></msub></mrow><annotation encoding=\"application/x-tex\">R_n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>R</mi><mrow><mo>≥</mo><mn>0</mn></mrow></msub></mrow><annotation encoding=\"application/x-tex\">R_{\\geq0}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.928509em;vertical-align:-0.24517899999999998em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.301108em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mrel mtight\">≥</span><span class=\"mord mtight\">0</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.24517899999999998em;\"><span></span></span></span></span></span></span></span></span></span> if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>≥</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">n\\geq0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≥</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span>. There were just tons of dumb things like this, as well as having to make the internal grading API from scratch, and I didn't have enough Lean time in the day to make progress at more than a snail's pace (when marking is over I should be in a much better state though). </p>\n<p>We will need grading when we do <code>Proj</code> for schemes, so I've known for a while we need a good grading API, and I'm optimistic that ultimately the API I've made for internal gradings, when tidied up (my next job) will be helpful here.</p>",
        "id": 238736123,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1620981849
    },
    {
        "content": "<p>By the way I did a lazy proof that the dual is finite free by hand just to be sure that my Gordan proof worked, so it's technically already sorry free! But of course the proof that should come from your PR is much better</p>",
        "id": 238749415,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1620990310
    }
]
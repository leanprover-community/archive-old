[
    {
        "content": "<p>This sounds like a worthwhile project whether or not we need it for LTE. What is the scope? I could even do it for my class I'm teaching this term. Is there a multivariable theory? Right now we have power series in an arbitrary collection of variables <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>σ</mi></mrow><annotation encoding=\"application/x-tex\">\\sigma</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">σ</span></span></span></span> over a semiring <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> defined as <code>(σ →₀ ℕ) → R</code> (so in particular <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>X</mi><mn>1</mn></msub><mo>+</mo><msub><mi>X</mi><mn>2</mn></msub><mo>+</mo><msub><mi>X</mi><mn>3</mn></msub><mo>+</mo><mo>⋯</mo></mrow><annotation encoding=\"application/x-tex\">X_1+X_2+X_3+\\cdots</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">3</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.31em;vertical-align:0em;\"></span><span class=\"minner\">⋯</span></span></span></span> is allowed if all the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>X</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">X_i</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> are variables). If <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> is furthermore commutative, Laurent series could just be defined by localising at the submonoid generated by <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>σ</mi></mrow><annotation encoding=\"application/x-tex\">\\sigma</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">σ</span></span></span></span>. Is that even a useful definition? Or are we sticking to the one-variable case?</p>",
        "id": 224888616,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1612280613
    },
    {
        "content": "<p>I think the needs for LTE are somewhat orthogonal to any standard approach, as these archimedean convergence bounds are fundamental to LTE.</p>",
        "id": 224888803,
        "sender_full_name": "Peter Scholze",
        "timestamp": 1612280685
    },
    {
        "content": "<p>And I don't think there's any reasonable multivariable theory</p>",
        "id": 224888856,
        "sender_full_name": "Peter Scholze",
        "timestamp": 1612280708
    },
    {
        "content": "<p>I think there's a well-defined map from the localisation to the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>-module <code>(σ →₀ ℤ) → R</code>although I don't see how to define it automatically because this isn't a ring so you can't use the universal property. But that's how to get <code>coeff</code> working I guess (it can be defined by hand).</p>",
        "id": 224888933,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1612280746
    },
    {
        "content": "<p>Localization also has a universal property on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>-modules</p>",
        "id": 224889022,
        "sender_full_name": "Peter Scholze",
        "timestamp": 1612280773
    },
    {
        "content": "<p>By the way <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> , I remember that at some point you were annoyed that to check that the structure presheaf is a sheaf on affine schemes, you could not use the universal property of localizations rings, as some map is a difference</p>",
        "id": 224889681,
        "sender_full_name": "Peter Scholze",
        "timestamp": 1612281013
    },
    {
        "content": "<p>Aah, as an <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>-module the localisation <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi><mo stretchy=\"false\">[</mo><mn>1</mn><mi mathvariant=\"normal\">/</mi><mi>S</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">R[1/S]</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mopen\">[</span><span class=\"mord\">1</span><span class=\"mord\">/</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mclose\">]</span></span></span></span> is the initial object for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>-modules such that elements of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span> act invertibly.</p>",
        "id": 224889704,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1612281020
    },
    {
        "content": "<p>The trick there would have been to use (truncated) simplicial objects</p>",
        "id": 224889717,
        "sender_full_name": "Peter Scholze",
        "timestamp": 1612281026
    },
    {
        "content": "<p>Yes, but this is just a gimmick</p>",
        "id": 224889719,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1612281027
    },
    {
        "content": "<p>Aah! I thought the trick was to talk about equalizers and not take the difference</p>",
        "id": 224889758,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1612281041
    },
    {
        "content": "<p>OK, that's the same</p>",
        "id": 224889798,
        "sender_full_name": "Peter Scholze",
        "timestamp": 1612281056
    },
    {
        "content": "<p>Just came to mind as I was in the simplicial mindset ;-)</p>",
        "id": 224889862,
        "sender_full_name": "Peter Scholze",
        "timestamp": 1612281080
    },
    {
        "content": "<p>I just flag it because in the Stacks project they take the difference, when doing the basic theory.</p>",
        "id": 224889895,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1612281091
    },
    {
        "content": "<p>Note that in LTE I also define the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">_</mi><msup><mo stretchy=\"false\">)</mo><msup><mi>T</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup></msup></mrow><annotation encoding=\"application/x-tex\">(\\_)^{T^{-1}}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1.2969199999999999em;vertical-align:-0.31em;\"></span><span class=\"mopen\">(</span><span class=\"mord\" style=\"margin-right:0.02778em;\">_</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9869199999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8913142857142857em;\"><span style=\"top:-2.931em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span> as an equalizer instead of a kernel. It's just a bit more natural, and makes a lot of things easier that you want to do afterwards.</p>",
        "id": 224890070,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1612281151
    },
    {
        "content": "<p>Sounds good to me! Equalizers are just uglier to draw</p>",
        "id": 224890153,
        "sender_full_name": "Peter Scholze",
        "timestamp": 1612281183
    },
    {
        "content": "<p>I actually wanted to scream \"but I did define it as an equalizer\" before realizing I didn't</p>",
        "id": 224890298,
        "sender_full_name": "Peter Scholze",
        "timestamp": 1612281241
    },
    {
        "content": "<p>Actually, in my paper with Thomas Nikolaus, John Rognes complained a lot when we were just formally replacing equalizers by fibres of the difference, for maps of spectra (in the sense of algebraic topology). Somehow in his mental model for spectra, you can't meaningfully take the difference of two maps.</p>",
        "id": 224890530,
        "sender_full_name": "Peter Scholze",
        "timestamp": 1612281324
    },
    {
        "content": "<p>So to give an <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo stretchy=\"false\">[</mo><mn>1</mn><mi mathvariant=\"normal\">/</mi><mi>S</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">A[1/S]</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mopen\">[</span><span class=\"mord\">1</span><span class=\"mord\">/</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mclose\">]</span></span></span></span>-module is to give an <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span>-module on which the elements of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span> act as bijections -- thanks Peter! Now if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> is a commutative ring (or probably even a commutative semiring) then <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><mo>:</mo><mo>=</mo></mrow><annotation encoding=\"application/x-tex\">M:=</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.36687em;vertical-align:0em;\"></span><span class=\"mrel\">=</span></span></span></span><code>(σ →₀ ℤ) → R</code> is a module for the ring <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>=</mo><mi>R</mi><mo stretchy=\"false\">[</mo><mo stretchy=\"false\">[</mo><mi>σ</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">]</mo><mo>:</mo><mo>=</mo></mrow><annotation encoding=\"application/x-tex\">A = R[[\\sigma]]:=</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mopen\">[</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">σ</span><span class=\"mclose\">]</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.36687em;vertical-align:0em;\"></span><span class=\"mrel\">=</span></span></span></span><code>(σ →₀ ℕ) → R</code>in which the elements of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>σ</mi></mrow><annotation encoding=\"application/x-tex\">\\sigma</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">σ</span></span></span></span> act as bijections, so it's a module for  <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo stretchy=\"false\">[</mo><mn>1</mn><mi mathvariant=\"normal\">/</mi><mi>σ</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">A[1/\\sigma]</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mopen\">[</span><span class=\"mord\">1</span><span class=\"mord\">/</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">σ</span><span class=\"mclose\">]</span></span></span></span>, and now you can define a map <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo stretchy=\"false\">[</mo><mn>1</mn><mi mathvariant=\"normal\">/</mi><mi>σ</mi><mo stretchy=\"false\">]</mo><mo>→</mo><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">A[1/\\sigma]\\to M</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mopen\">[</span><span class=\"mord\">1</span><span class=\"mord\">/</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">σ</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> by sending 1 to 1 and there's your <code>coeff</code>. Then you can specialise to the case <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>σ</mi><mo>=</mo><mo stretchy=\"false\">{</mo><mo>∗</mo><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">\\sigma=\\{*\\}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">σ</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">∗</span><span class=\"mclose\">}</span></span></span></span> and show e.g. that it's an ID if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> is an ID, a field if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> is a field etc. Is there any particular goal that you want Johan? I could definitely do this with my students. I promised them a possible walk through the foothills of Clausen-Scholze!</p>",
        "id": 224892771,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1612282119
    },
    {
        "content": "<p>A fun theorem is that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi><mo stretchy=\"false\">(</mo><mo stretchy=\"false\">(</mo><mi>T</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\mathbb Z((T))</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathbb\">Z</span><span class=\"mopen\">(</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mclose\">)</span><span class=\"mclose\">)</span></span></span></span> is a principal ideal domain. That would actually go in a direction that's helpful for LTE (see Lecture 7)</p>",
        "id": 224893131,
        "sender_full_name": "Peter Scholze",
        "timestamp": 1612282256
    },
    {
        "content": "<p>But it's almost certainly too hard to do in the course</p>",
        "id": 224893216,
        "sender_full_name": "Peter Scholze",
        "timestamp": 1612282290
    },
    {
        "content": "<p>If <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> is a PID is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi><mo stretchy=\"false\">(</mo><mo stretchy=\"false\">(</mo><mi>T</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">R((T))</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mopen\">(</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mclose\">)</span><span class=\"mclose\">)</span></span></span></span> a PID?</p>",
        "id": 224893339,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1612282326
    },
    {
        "content": "<p>I have students looking for projects.</p>",
        "id": 224893381,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1612282342
    },
    {
        "content": "<p>If <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> is a UFD then <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi><mo stretchy=\"false\">[</mo><mo stretchy=\"false\">[</mo><mi>T</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">R[[T]]</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mopen\">[</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mclose\">]</span><span class=\"mclose\">]</span></span></span></span> is a UFD, I believe.</p>",
        "id": 224893422,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1612282359
    },
    {
        "content": "<p>but I'm always a bit scared about dimension-counting in this context.</p>",
        "id": 224893471,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1612282384
    },
    {
        "content": "<p>I'd have to think about it, there are certainly some statements like this</p>",
        "id": 224893493,
        "sender_full_name": "Peter Scholze",
        "timestamp": 1612282395
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> Sorry, I haven't studied those sections enough to know what we'll need.</p>",
        "id": 224893498,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1612282396
    },
    {
        "content": "<p>Yes, basic intuition about dimensions gets pretty safely fucked up</p>",
        "id": 224893523,
        "sender_full_name": "Peter Scholze",
        "timestamp": 1612282409
    },
    {
        "content": "<p>(it was Judith Ludwig who taught me this)</p>",
        "id": 224893673,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1612282451
    },
    {
        "content": "<p>I think that R[[T]] is not a UFD in general if R is a UFD, there is a paper by Samuel on this<br>\n<a href=\"https://www.math.lsu.edu/~madden/M7210fall2012/Samuel-UFDs.pdf\">https://www.math.lsu.edu/~madden/M7210fall2012/Samuel-UFDs.pdf</a></p>",
        "id": 224894795,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1612282908
    },
    {
        "content": "<p>But if R is a regular UFD, then R[[T]] is a (regular) UFD as well</p>",
        "id": 224895087,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1612283025
    },
    {
        "content": "<p>oh wow it's amazing to see papers like this. \"For example the fact that every regular local ring is a UFD has been conjectured in the early 40s...but the general case has been settled only in 1959 by Auslander and Buchsbaum\". It's funny to imagine a time when this result wasn't \"well-known and in all the standard textbooks\"</p>",
        "id": 224898403,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1612284232
    },
    {
        "content": "<p>Apparently <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi><mo>:</mo><mo>=</mo><msub><mi mathvariant=\"double-struck\">F</mi><mn>2</mn></msub><mo stretchy=\"false\">[</mo><mi>x</mi><mo separator=\"true\">,</mo><mi>y</mi><mo separator=\"true\">,</mo><mi>z</mi><mo stretchy=\"false\">]</mo><mi mathvariant=\"normal\">/</mi><mo stretchy=\"false\">(</mo><msup><mi>z</mi><mn>2</mn></msup><mo>−</mo><msup><mi>x</mi><mn>3</mn></msup><mo>−</mo><msup><mi>y</mi><mn>7</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">R:=\\mathbb{F}_2[x,y,z]/(z^2-x^3-y^7)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.36687em;vertical-align:0em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathbb\">F</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.04398em;\">z</span><span class=\"mclose\">]</span><span class=\"mord\">/</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.04398em;\">z</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.897438em;vertical-align:-0.08333em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">3</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">7</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> is a counterexample!</p>",
        "id": 224900087,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1612284877
    },
    {
        "content": "<p>There is another notion of something related to Laurent series, but much more abstract, that could be defined in Lean, is that of Hahn series:<br>\n<a href=\"https://en.wikipedia.org/wiki/Hahn_series\">https://en.wikipedia.org/wiki/Hahn_series</a><br>\nIt could be defined as the series formed by the elements f in <code>(σ →₀ G) → R</code> , where R is a semiring, G an ordered_comm_monoid, whose support (to be defined) is well-ordered (i.e. any non-empty subset of the support of f has a least element), and in principle σ is finite (I did not check if it could work for any σ). If  <code>G= ℕ</code>, all the subsets are well-ordered, hence there is no condition, and you recover the formal_power_series.  If <code>G=ℤ</code>, the well-ordered subsets are the ones bounded below, and you get the laurent_power_series when<code> σ=unit</code>. <br>\nThe key point is the definition of the multiplication, and this can be done wiht the usual formulae using that {(e,e')S×S' | e*e'=g} for any g in G and any S, S' well ordered subsets of G is finite. <br>\nI know this goes far away of what it is need for condensed mathematics, but my impression is that most the machinery to define this is already done in the mathlib.</p>",
        "id": 225277576,
        "sender_full_name": "Xavier Xarles",
        "timestamp": 1612518061
    },
    {
        "content": "<p>Of course, I meant G is a linear_ordered_comm_monoid, not just ordered.</p>",
        "id": 225278364,
        "sender_full_name": "Xavier Xarles",
        "timestamp": 1612518570
    },
    {
        "content": "<p>I like these rings! It might be fun proving that, if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> is a field, one gets a spherically complete field this way</p>",
        "id": 225278451,
        "sender_full_name": "Peter Scholze",
        "timestamp": 1612518620
    },
    {
        "content": "<p>I had initially ruled out the approach of going via formal infinite series <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mo>∑</mo><mrow><mi>n</mi><mo>∈</mo><mi mathvariant=\"double-struck\">Z</mi></mrow></msub><msub><mi>a</mi><mi>n</mi></msub><msup><mi>T</mi><mi>n</mi></msup></mrow><annotation encoding=\"application/x-tex\">\\sum_{n\\in\\Z}a_nT^n</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1.07708em;vertical-align:-0.32708000000000004em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:-0.0000050000000000050004em;\">∑</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.18251299999999993em;\"><span style=\"top:-2.40029em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mrel mtight\">∈</span><span class=\"mord mtight\"><span class=\"mord mathbb mtight\">Z</span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32708000000000004em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span></span></span> because these formal infinite series are not a ring, but I see now that you can just put a multiplication on the subtype. Meh, so now we have some implementation decision. I've seen these Hahn series before within the context of higher rank valuations. The Wikipedia page you link to only sets up the one-variable theory. I convinced myself that Laurent series would work even for infinitely many variables -- there are many topologies (even in the two-variable case there are at least three choices), but the algebra is unambiguous.</p>\n<p>Maybe I'll leave Laurent series for now and try one of the other things Johan suggested.</p>",
        "id": 225288021,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1612525099
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"315546\">Xavier Xarles</span> <a href=\"#narrow/stream/267928-condensed-mathematics/topic/laurent.20series/near/225277576\">said</a>:</p>\n<blockquote>\n<p>There is another notion of something related to Laurent series, but much more abstract, that could be defined in Lean, is that of Hahn series:<br>\n<a href=\"https://en.wikipedia.org/wiki/Hahn_series\">https://en.wikipedia.org/wiki/Hahn_series</a><br>\nIt could be defined as the series formed by the elements f in <code>(σ →₀ G) → R</code> , where R is a semiring, G an ordered_comm_monoid, whose support (to be defined) is well-ordered (i.e. any non-empty subset of the support of f has a least element), and in principle σ is finite (I did not check if it could work for any σ). If  <code>G= ℕ</code>, all the subsets are well-ordered, hence there is no condition, and you recover the formal_power_series.  If <code>G=ℤ</code>, the well-ordered subsets are the ones bounded below, and you get the laurent_power_series when<code> σ=unit</code>. <br>\nThe key point is the definition of the multiplication, and this can be done wiht the usual formulae using that {(e,e')S×S' | e*e'=g} for any g in G and any S, S' well ordered subsets of G is finite. <br>\nI know this goes far away of what it is need for condensed mathematics, but my impression is that most the machinery to define this is already done in the mathlib.</p>\n</blockquote>\n<p>I've wanted to do Hahn series for ages, but every time I try, I get disappointed with how hard it is to work with well-founded subsets, rather than well-founded types. That API should still get built, and I still intend to get around to it if no one else does first.</p>",
        "id": 225433708,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1612651504
    },
    {
        "content": "<p>Do you know if there's a multivariable version?</p>",
        "id": 225434537,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1612652894
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> what do you mean by multivariable?</p>",
        "id": 225434834,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1612653465
    },
    {
        "content": "<p>One natural thing you can do when you have two ordered groups <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"normal\">Γ</mi><mn>1</mn></msub></mrow><annotation encoding=\"application/x-tex\">\\Gamma_1</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\">Γ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"normal\">Γ</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">\\Gamma_2</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\">Γ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> Is take their product <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Γ</mi><mo>:</mo><mo>=</mo><msub><mi mathvariant=\"normal\">Γ</mi><mn>1</mn></msub><mo>×</mo><msub><mi mathvariant=\"normal\">Γ</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">\\Gamma := \\Gamma_1 \\times \\Gamma_2</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\">Γ</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.36687em;vertical-align:0em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\">Γ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\">Γ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> with the lexicographic ordering, and consider the Hahn series field <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi><mo stretchy=\"false\">(</mo><mo stretchy=\"false\">(</mo><msup><mi>t</mi><mi mathvariant=\"normal\">Γ</mi></msup><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">k((t^\\Gamma))</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0913309999999998em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mopen\">(</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413309999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">Γ</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mclose\">)</span></span></span></span>.</p>",
        "id": 225434979,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1612653697
    },
    {
        "content": "<p>Right. But I think I'm asking something different. For example you can get single variable power series by applying the construction with Gamma=nat. But I don't think the construction in Wikipedia will give you power series in two variables...oh, does it? I just take nat^2? Oh!</p>",
        "id": 225435668,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1612654857
    },
    {
        "content": "<p>They stick to ordered groups in Wikipedia but ordered monoids seem to work fine</p>",
        "id": 225435802,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1612655054
    },
    {
        "content": "<p>But you won't get a valuation ring in general.</p>",
        "id": 225435909,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1612655238
    },
    {
        "content": "<p>(I don't know if this matters to you :) )</p>",
        "id": 225435914,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1612655250
    },
    {
        "content": "<p>I might get a valuation though</p>",
        "id": 225436183,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1612655754
    },
    {
        "content": "<p>Does every totally ordered monoid embed in its group completion?</p>",
        "id": 225436421,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1612656191
    },
    {
        "content": "<p>I'll have to look at what mathlib thinks a totally ordered monoid is. If a&lt;b implies a+c&lt;b+c then you're fine because this implies a!=b -&gt; a+c != b+c which is what you need for an embedding. But if the axiom is a&lt;=b implies a+c&lt;=b+c then there problems because {0,1,2} with absorbing 2 (1+2=2 etc) is a counterexample</p>",
        "id": 225449604,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1612681513
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/linear_ordered_monoid\">docs#linear_ordered_monoid</a></p>",
        "id": 225449652,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1612681585
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/ordered_monoid\">docs#ordered_monoid</a></p>",
        "id": 225449666,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1612681662
    },
    {
        "content": "<p>Hmm, maybe they have to be commutative?</p>",
        "id": 225449726,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1612681791
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/linear_ordered_comm_monoid\">docs#linear_ordered_comm_monoid</a></p>",
        "id": 225449853,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1612682028
    },
    {
        "content": "<p>Apparently they don't exist in Lean?</p>",
        "id": 225449982,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1612682215
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/linear_ordered_comm_monoid_with_zero\">docs#linear_ordered_comm_monoid_with_zero</a></p>",
        "id": 225449992,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1612682252
    },
    {
        "content": "<p>Those exist but the &lt; axiom isn't there because you can have c=0</p>",
        "id": 225450044,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1612682316
    },
    {
        "content": "<p>Maybe this is the way to think about it. A partial order on something is a binary relation. But which relation? We often use <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>≤</mo></mrow><annotation encoding=\"application/x-tex\">\\leq</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mrel\">≤</span></span></span></span> but <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>&lt;</mo></mrow><annotation encoding=\"application/x-tex\">&lt;</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mrel\">&lt;</span></span></span></span> is just as fundamental: in a partial order <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mo>&lt;</mo><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">a&lt;b</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span> iff <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mo>≤</mo><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">a\\leq b</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mo>≠</mo><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">a\\not=b</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\"><span class=\"mord vbox\"><span class=\"thinbox\"><span class=\"rlap\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"inner\"><span class=\"mrel\"></span></span><span class=\"fix\"></span></span></span></span></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.36687em;vertical-align:0em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span>, and conversely <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mo>≤</mo><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">a\\leq b</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span> iff <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mo>&lt;</mo><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">a&lt;b</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span> or <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mo>=</mo><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">a=b</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span>. Now consider the function <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>:</mo><mi mathvariant=\"double-struck\">R</mi><mo>→</mo><mi mathvariant=\"double-struck\">R</mi></mrow><annotation encoding=\"application/x-tex\">f:\\R\\to\\R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">R</span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">R</span></span></span></span></span> defined by <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">f(x)=0</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span>. Is this monotonic, i.e. does it preserve the partial order? Well, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mo>≤</mo><mi>b</mi><mtext>  </mtext><mo>⟹</mo><mtext>  </mtext><mi>f</mi><mo stretchy=\"false\">(</mo><mi>a</mi><mo stretchy=\"false\">)</mo><mo>≤</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>b</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">a\\leq b\\implies f(a)\\leq f(b)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.71844em;vertical-align:-0.024em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⟹</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">b</span><span class=\"mclose\">)</span></span></span></span> is true, and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mo>&lt;</mo><mi>b</mi><mtext>  </mtext><mo>⟹</mo><mtext>  </mtext><mi>f</mi><mo stretchy=\"false\">(</mo><mi>a</mi><mo stretchy=\"false\">)</mo><mo>&lt;</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>b</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">a&lt;b\\implies f(a)&lt;f(b)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.71844em;vertical-align:-0.024em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⟹</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">b</span><span class=\"mclose\">)</span></span></span></span> is false. Perhaps people say \"monotonic\" for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>≤</mo></mrow><annotation encoding=\"application/x-tex\">\\leq</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mrel\">≤</span></span></span></span>-preserving, and \"strictly monotonic\" for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>&lt;</mo></mrow><annotation encoding=\"application/x-tex\">&lt;</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mrel\">&lt;</span></span></span></span>-preserving. Looking at the relationship between <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>≤</mo></mrow><annotation encoding=\"application/x-tex\">\\leq</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mrel\">≤</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>&lt;</mo></mrow><annotation encoding=\"application/x-tex\">&lt;</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mrel\">&lt;</span></span></span></span> you can see that the dictionary mentions <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>=</mo></mrow><annotation encoding=\"application/x-tex\">=</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.36687em;vertical-align:0em;\"></span><span class=\"mrel\">=</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>≠</mo></mrow><annotation encoding=\"application/x-tex\">\\not=</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mrel\"><span class=\"mord vbox\"><span class=\"thinbox\"><span class=\"rlap\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"inner\"><span class=\"mrel\"></span></span><span class=\"fix\"></span></span></span></span></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.36687em;vertical-align:0em;\"></span><span class=\"mrel\">=</span></span></span></span>. Now every map is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>=</mo></mrow><annotation encoding=\"application/x-tex\">=</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.36687em;vertical-align:0em;\"></span><span class=\"mrel\">=</span></span></span></span>-preserving -- this is the so-called substitution property of equality, known to Lean as <code>eq.rec</code>. But the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>≠</mo></mrow><annotation encoding=\"application/x-tex\">\\not=</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mrel\"><span class=\"mord vbox\"><span class=\"thinbox\"><span class=\"rlap\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"inner\"><span class=\"mrel\"></span></span><span class=\"fix\"></span></span></span></span></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.36687em;vertical-align:0em;\"></span><span class=\"mrel\">=</span></span></span></span>-preserving maps are the injections, and your question is about injections. </p>\n<p>The fact that in some sense we don't know whether the fundamental operator which we should be considering is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>≤</mo></mrow><annotation encoding=\"application/x-tex\">\\leq</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mrel\">≤</span></span></span></span> or <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>&lt;</mo></mrow><annotation encoding=\"application/x-tex\">&lt;</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mrel\">&lt;</span></span></span></span> thus gives us this ambiguity when defining morphisms (should they be monic or strict monic?). But it also gives us ambiguity when defining algebraic structures on top of partial orders. Let's try to guess what an ordered commutative semiring should be. There are completely natural definitions for both <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>≤</mo></mrow><annotation encoding=\"application/x-tex\">\\leq</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mrel\">≤</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>&lt;</mo></mrow><annotation encoding=\"application/x-tex\">&lt;</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mrel\">&lt;</span></span></span></span>. For addition we can say  <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mo>≤</mo><mi>b</mi><mtext>  </mtext><mo>⟹</mo><mtext>  </mtext><mi>a</mi><mo>+</mo><mi>c</mi><mo>≤</mo><mi>b</mi><mo>+</mo><mi>c</mi></mrow><annotation encoding=\"application/x-tex\">a\\leq b\\implies a+c\\leq b+c</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.71844em;vertical-align:-0.024em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⟹</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathnormal\">c</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.77777em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">c</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mo>≤</mo><mi>b</mi><mo separator=\"true\">,</mo><mn>0</mn><mo>≤</mo><mi>c</mi><mtext>  </mtext><mo>⟹</mo><mtext>  </mtext><mi>a</mi><mi>c</mi><mo>≤</mo><mi>b</mi><mi>c</mi></mrow><annotation encoding=\"application/x-tex\">a\\leq b, 0\\leq c\\implies ac\\leq bc</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.549em;vertical-align:-0.024em;\"></span><span class=\"mord mathnormal\">c</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⟹</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">c</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mord mathnormal\">c</span></span></span></span>. Or we can say <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mo>&lt;</mo><mi>b</mi><mtext>  </mtext><mo>⟹</mo><mtext>  </mtext><mi>a</mi><mo>+</mo><mi>c</mi><mo>&lt;</mo><mi>b</mi><mo>+</mo><mi>c</mi></mrow><annotation encoding=\"application/x-tex\">a&lt;b\\implies a+c&lt;b+c</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.71844em;vertical-align:-0.024em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⟹</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">c</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.77777em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">c</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mo>&lt;</mo><mi>b</mi><mo separator=\"true\">,</mo><mn>0</mn><mo>&lt;</mo><mi>c</mi><mtext>  </mtext><mo>⟹</mo><mtext>  </mtext><mi>a</mi><mi>c</mi><mo>&lt;</mo><mi>b</mi><mi>c</mi></mrow><annotation encoding=\"application/x-tex\">a&lt;b,0&lt;c\\implies ac&lt;bc</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.549em;vertical-align:-0.024em;\"></span><span class=\"mord mathnormal\">c</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⟹</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">c</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mord mathnormal\">c</span></span></span></span>. These give us different answers. Even for commutative totally ordered additive monoids they're different because <code>fin n</code> = <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">{</mo><mn>0</mn><mo separator=\"true\">,</mo><mn>1</mn><mo separator=\"true\">,</mo><mn>2</mn><mo separator=\"true\">,</mo><mo>…</mo><mo separator=\"true\">,</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">\\{0,1,2,\\ldots,n-1\\}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">2</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">}</span></span></span></span> with its absorbing addition (a+b:=n-1 if real a+b is &gt;= n-1) is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>≤</mo></mrow><annotation encoding=\"application/x-tex\">\\leq</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mrel\">≤</span></span></span></span>-preserving but not <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>&lt;</mo></mrow><annotation encoding=\"application/x-tex\">&lt;</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mrel\">&lt;</span></span></span></span>-preserving, and this is happening because <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi><mo>↦</mo><mi>x</mi><mo>+</mo><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">x\\mapsto x+a</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.522em;vertical-align:-0.011em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">↦</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">a</span></span></span></span> might not be injective if we just preserve <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>≤</mo></mrow><annotation encoding=\"application/x-tex\">\\leq</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mrel\">≤</span></span></span></span> but it must be injective if we preserve <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>&lt;</mo></mrow><annotation encoding=\"application/x-tex\">&lt;</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mrel\">&lt;</span></span></span></span> because preserving <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>&lt;</mo></mrow><annotation encoding=\"application/x-tex\">&lt;</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mrel\">&lt;</span></span></span></span> on a total order is the same as preserving <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>≤</mo></mrow><annotation encoding=\"application/x-tex\">\\leq</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mrel\">≤</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>≠</mo></mrow><annotation encoding=\"application/x-tex\">\\not=</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mrel\"><span class=\"mord vbox\"><span class=\"thinbox\"><span class=\"rlap\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"inner\"><span class=\"mrel\"></span></span><span class=\"fix\"></span></span></span></span></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.36687em;vertical-align:0em;\"></span><span class=\"mrel\">=</span></span></span></span>. </p>\n<p>I think that if we stick to total orders then this related to the question of whether a morphism of structures-with-a-binary-relation <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> should satisfy <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi><mo stretchy=\"false\">(</mo><mi>a</mi><mo separator=\"true\">,</mo><mi>b</mi><mo stretchy=\"false\">)</mo><mtext>  </mtext><mo>⟹</mo><mtext>  </mtext><mi>R</mi><mo stretchy=\"false\">(</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>a</mi><mo stretchy=\"false\">)</mo><mo separator=\"true\">,</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>b</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">R(a,b)\\implies R(f(a),f(b)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⟹</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">b</span><span class=\"mclose\">)</span></span></span></span> or whether it should satisfy <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi><mo stretchy=\"false\">(</mo><mi>a</mi><mo separator=\"true\">,</mo><mi>b</mi><mo stretchy=\"false\">)</mo><mtext>  </mtext><mo>⟺</mo><mtext>  </mtext><mi>R</mi><mo stretchy=\"false\">(</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>a</mi><mo stretchy=\"false\">)</mo><mo separator=\"true\">,</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>b</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">R(a,b)\\iff R(f(a),f(b)))</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⟺</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">b</span><span class=\"mclose\">)</span><span class=\"mclose\">)</span><span class=\"mclose\">)</span></span></span></span>. Ultimately both concepts are useful. If you preserve <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>&lt;</mo></mrow><annotation encoding=\"application/x-tex\">&lt;</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mrel\">&lt;</span></span></span></span> on a total order then you also preserve <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>&gt;</mo></mrow><annotation encoding=\"application/x-tex\">&gt;</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mrel\">&gt;</span></span></span></span> and so <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mo>&lt;</mo><mi>b</mi><mtext>  </mtext><mo>⟺</mo><mtext>  </mtext><mi>f</mi><mo stretchy=\"false\">(</mo><mi>a</mi><mo stretchy=\"false\">)</mo><mo>&lt;</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>b</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">a&lt;b\\iff f(a)&lt;f(b)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.71844em;vertical-align:-0.024em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⟺</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">b</span><span class=\"mclose\">)</span></span></span></span>. However if you only preserve <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>≤</mo></mrow><annotation encoding=\"application/x-tex\">\\leq</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mrel\">≤</span></span></span></span> then you might not reflect it (i.e. <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>a</mi><mo stretchy=\"false\">)</mo><mo>≤</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>b</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">f(a)\\leq f(b)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">b</span><span class=\"mclose\">)</span></span></span></span> might not imply <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mo>≤</mo><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">a\\leq b</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span>). </p>\n<p>In short, it seems to me that there are two reasonable (from the point of view of model theory) definitions of a totally ordered commutative monoid, and the answer to your question is \"yes\" for one and \"no\" for the other.</p>",
        "id": 225454353,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1612690004
    },
    {
        "content": "<p>Ok I thought more about Hahn series and Laurent series. <span class=\"user-mention\" data-user-id=\"302826\">@Aaron Anderson</span> what do you think about this. Make a typeclass for well-founded subsets of a totally ordered type and try to get it to do the work. Define Hahn series for a totally ordered commutative add_monoid. The main goals are that power series in 1 variable are isomorphic to Hahn series if the monoid is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">N</mi></mrow><annotation encoding=\"application/x-tex\">\\N</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">N</span></span></span></span></span> and that power series in one variable X and then invert X is isomorphic to Hahn series if the monoid is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\Z</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Z</span></span></span></span></span>.</p>",
        "id": 225542838,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1612790591
    },
    {
        "content": "<p>These two results will probably inform the API for well-ordered subsets of a totally ordered type/abelian additive group. Note that Hahn series can be defined as functions to Gamma whose support is well-ordered and we have the API for support already</p>",
        "id": 225543055,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1612790686
    },
    {
        "content": "<p>Also I think one can construct a valuation from Hahn series on Gamma to <code>with_zero (multiplicative Gamma)</code> and this would be another good test of the API</p>",
        "id": 225543244,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1612790779
    },
    {
        "content": "<p>For me this sounds like a really fun couple of worlds in the lean puzzle game</p>",
        "id": 225543389,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1612790866
    },
    {
        "content": "<p>The other approach I was considering was just localising power series at the variable, but now I believe that the Hahn approach is much better. We'll need Hahn series one day anyway (they came up in the document we had to formalise perfectoid spaces but we skipped them) so we may as well do them now. Defining a Laurent series as a localisation is one line but then making the API for coefficients is a slight hassle; this way the coefficients will be easy. Finally localising power series gives a several variable version of Laurent series but I can't see the use of it. It's not even true that k((X))((Y))=k((Y))((X)), and neither these nor the localisation of k[[X,Y]] at X and Y is the field of fractions of k[[X,Y]] anyway, as far as I can see, so I can't really see any use in a multivariable Laurent series or even a natural construction, however if we do Hahn series we can apply to Z x Z and claim that this is something (I think it's k((X))((Y)) )</p>",
        "id": 225544336,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1612791277
    },
    {
        "content": "<p>Well, actually my game with the <code>add_comm_monoid</code> structure on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">N</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{N}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">N</span></span></span></span></span> this morning was aimed precisely at a definition of the Laurent series, without Hahn series. I think this should be doable, but I prefer not to interfere, basically because these Hahn series are probably more general, and because I am having enough fun in defining them that I'd go on even if it turns out that you will opt for another definition. Also, I can't spend too much time on this and I am very slow, so I don't feel like blocking anyone.</p>",
        "id": 225547553,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1612792821
    },
    {
        "content": "<p>Concerning the \"multivariable\" issue -- I think it is actually reasonable to think about <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi><mo stretchy=\"false\">(</mo><mo stretchy=\"false\">(</mo><msup><mi>t</mi><mi mathvariant=\"normal\">Γ</mi></msup><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">k((t^\\Gamma))</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0913309999999998em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mopen\">(</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413309999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">Γ</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mclose\">)</span></span></span></span> with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Γ</mi><mo>=</mo><mi mathvariant=\"double-struck\">Z</mi><mo>×</mo><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\Gamma = \\mathbb{Z} \\times \\mathbb{Z}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\">Γ</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.77222em;vertical-align:-0.08333em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Z</span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Z</span></span></span></span></span> as a 2-variable object. We just have to keep in mind that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Γ</mi></mrow><annotation encoding=\"application/x-tex\">\\Gamma</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\">Γ</span></span></span></span> is not a plain group, but rather an ordered group, so the convex subgroup <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi><mo>×</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Z} \\times 0</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.77222em;vertical-align:-0.08333em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Z</span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span> is \"canonical\" in the sense that it's the unique nontrivial proper convex subgroup. This corresponds to the coarsening of the valuation on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi><mo stretchy=\"false\">(</mo><mo stretchy=\"false\">(</mo><msup><mi>t</mi><mi mathvariant=\"normal\">Γ</mi></msup><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">k((t^\\Gamma))</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0913309999999998em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mopen\">(</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413309999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">Γ</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mclose\">)</span></span></span></span> whose residue field is the Hahn series field of the quotient <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi mathvariant=\"double-struck\">Z</mi><mo>×</mo><mi mathvariant=\"double-struck\">Z</mi><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">/</mi><mo stretchy=\"false\">(</mo><mi mathvariant=\"double-struck\">Z</mi><mo>×</mo><mn>0</mn><mo stretchy=\"false\">)</mo><mo>≅</mo><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">(\\mathbb{Z} \\times \\mathbb{Z} )/( \\mathbb{Z} \\times 0 )\\cong \\mathbb{Z}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathbb\">Z</span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Z</span></span><span class=\"mclose\">)</span><span class=\"mord\">/</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathbb\">Z</span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">0</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≅</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Z</span></span></span></span></span>. </p>\n<p>In other words, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi><mo stretchy=\"false\">(</mo><mo stretchy=\"false\">(</mo><msup><mi>t</mi><mi mathvariant=\"normal\">Γ</mi></msup><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">k((t^\\Gamma))</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0913309999999998em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mopen\">(</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413309999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">Γ</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mclose\">)</span></span></span></span> has it's usual canonical valuation <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi></mrow><annotation encoding=\"application/x-tex\">v</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span></span></span></span> with value group <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Γ</mi></mrow><annotation encoding=\"application/x-tex\">\\Gamma</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\">Γ</span></span></span></span>, but there is also a \"canonical\" valuation <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>w</mi></mrow><annotation encoding=\"application/x-tex\">w</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span></span></span></span> which coarsens <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi></mrow><annotation encoding=\"application/x-tex\">v</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span></span></span></span> whose value group is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Z}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Z</span></span></span></span></span> and the induced valuation on the residue field of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>w</mi></mrow><annotation encoding=\"application/x-tex\">w</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span></span></span></span> again has value group <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Z}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Z</span></span></span></span></span>.</p>\n<p>Geometrically, this should be thought of as the completion of a function field of a surface at a rank-2 flag of prime divisors. So in this sense, it really is a 2-dimensional object.</p>",
        "id": 225551259,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1612794513
    },
    {
        "content": "<p>In any case, I completely agree that it would be a fun project to formalize this stuff :)</p>",
        "id": 225551328,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1612794549
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/267928-condensed-mathematics/topic/laurent.20series/near/225542838\">said</a>:</p>\n<blockquote>\n<p>Ok I thought more about Hahn series and Laurent series. <span class=\"user-mention silent\" data-user-id=\"302826\">Aaron Anderson</span> what do you think about this. Make a typeclass for well-founded subsets of a totally ordered type and try to get it to do the work. Define Hahn series for a totally ordered commutative add_monoid. The main goals are that power series in 1 variable are isomorphic to Hahn series if the monoid is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">N</mi></mrow><annotation encoding=\"application/x-tex\">\\N</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">N</span></span></span></span></span> and that power series in one variable X and then invert X is isomorphic to Hahn series if the monoid is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\Z</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Z</span></span></span></span></span>.</p>\n</blockquote>\n<p>Starting over at <a href=\"https://github.com/leanprover-community/mathlib/issues/6113\">#6113</a></p>",
        "id": 225646073,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1612846400
    },
    {
        "content": "<p>I've defined some Laurent series, and the discussion is here:<br>\n<a href=\"#narrow/stream/116395-maths/topic/Hahn.20Series/near/226499114\">https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hahn.20Series/near/226499114</a></p>",
        "id": 226499216,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1613473116
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/267928-condensed-mathematics/topic/laurent.20series/near/225543244\">said</a>:</p>\n<blockquote>\n<p>Also I think one can construct a valuation from Hahn series on Gamma to <code>with_zero (multiplicative Gamma)</code> and this would be another good test of the API</p>\n</blockquote>\n<p>I'm aaaalmoooost there, and I've just found out that the order is backwards.</p>",
        "id": 228320418,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1614638760
    },
    {
        "content": "<p>I might just slap on a negative sign today, but this convinces me: we need a separate <code>add_valuation</code> definition (and possibly to flip the order on <code>multiplicative</code>)</p>",
        "id": 228320646,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1614638871
    },
    {
        "content": "<p>I know exactly what you're talking about :-) This happens already for DVR s</p>",
        "id": 228321775,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614639461
    },
    {
        "content": "<p>Can we just introduce a <code>negative_log</code> already? <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 228321865,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614639492
    },
    {
        "content": "<p>Would it be a problem to define <code>add_valuation</code> directly for now, and then figure out how to connect it to <code>valuation</code>?</p>",
        "id": 228322277,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1614639685
    },
    {
        "content": "<p>It seems like a better idea than just leaving the valuation on DVRs totally unbundled</p>",
        "id": 228322649,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1614639874
    },
    {
        "content": "<p>It also looks like we don't even have the p-adic valuation as a <code>valuation</code>?</p>",
        "id": 228322888,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1614640007
    },
    {
        "content": "<p>We have \"the p-adic absolute value\", right?</p>",
        "id": 228322906,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614640026
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/padic.is_absolute_value\">docs#padic.is_absolute_value</a></p>",
        "id": 228323071,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614640106
    },
    {
        "content": "<p>Oh, I see, you want the bundled <a href=\"https://leanprover-community.github.io/mathlib_docs/find/valuation\">docs#valuation</a> version.</p>",
        "id": 228323135,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614640134
    },
    {
        "content": "<p>Oh, this is a mess: <a href=\"https://leanprover-community.github.io/mathlib_docs/find/padic.valuation\">docs#padic.valuation</a> is the additive valuation, but it's just a plain function</p>",
        "id": 228323582,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614640387
    },
    {
        "content": "<p>I'm going to venture a guess that we have more unbundled additive valuations than we have bundled multiplicative valuations...</p>",
        "id": 228323735,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1614640447
    },
    {
        "content": "<p>...but then <code>polynomial.degree</code> could be an additive valuation (if defined on monoids), but the order would be follow the multiplicative convention. What a headache.</p>",
        "id": 228323875,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1614640525
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/267928-condensed-mathematics/topic/laurent.20series/near/228321865\">said</a>:</p>\n<blockquote>\n<p>Can we just introduce a <code>negative_log</code> already? <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>\n</blockquote>\n<p>What would this do?</p>",
        "id": 228327642,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1614642320
    },
    {
        "content": "<p>Take an ordered multiplicative monoid and map to an additive monoid with the opposite ordering.</p>",
        "id": 228327832,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614642421
    },
    {
        "content": "<p>So would this be a class/structure of bundled functions that do that, or would this be an explicit construction of one such function?</p>",
        "id": 228328222,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1614642611
    },
    {
        "content": "<p>I haven't actually thought about how to do this.</p>",
        "id": 228328294,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614642661
    },
    {
        "content": "<p>We want it to go from an additive monoid with a top to a monoid with zero</p>",
        "id": 228366331,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614670706
    },
    {
        "content": "<p>I've just seen the discussion you had yesterday about <code>valuation</code> vs <code>add_valuation</code> but I think I miss the point. <span class=\"user-mention\" data-user-id=\"302826\">@Aaron Anderson</span> What do you mean that \"the order is backwards\"?</p>",
        "id": 228731422,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1614845063
    },
    {
        "content": "<p>Is v(1)  &lt; v(p) or not? Depends on whether v is the additive or multiplicative valuation</p>",
        "id": 228731615,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614845224
    },
    {
        "content": "<p>And do I also get it right that the <code>add_val</code> you created in the <code>discrete_val_ring</code> file is not OK for the work here, since it definitionally takes values in <code>N</code>?</p>",
        "id": 228732080,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1614845499
    },
    {
        "content": "<p>That is an auxiliary definition which can easily be turned into a valuation in this sense</p>",
        "id": 228732506,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614845746
    },
    {
        "content": "<p>The reason I stopped afterwards is that the actual structure I wanted was not there. Aaron is making it now. I just mimiced the structure we had on the p-adic numbers</p>",
        "id": 228732655,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614845817
    },
    {
        "content": "<p>Namely, having a the def of multiplicative valuation and obtain the additive one automatically?</p>",
        "id": 228732853,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1614845926
    },
    {
        "content": "<p>The point is that there is no definition of the structure of an additive valuation in mathlib (and more generally no structure encapsulating <code>f(a*b)=f(a)+f(b)</code>  so we can't talk about additive valuations at all, until now. It's just a missing definition, nothing profound. But every definition comes with a cost -- the cost of making the API for the definition.</p>",
        "id": 228739151,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614849283
    },
    {
        "content": "<p>Compare the additive axiom of a valuation in the multiplicative and additive versions. In one version, you have <code>v(x + y) &lt;= max (v(x), v(y))</code>, in the other, you have <code>min(v(x),v(y)) &lt;= v(x + y)</code>.</p>",
        "id": 228807871,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1614876513
    },
    {
        "content": "<p>Oh, now I understand (looked up in wikipedia). What you call a \"multiplicative valuation with values in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">R</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{R}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">R</span></span></span></span></span>\" is an absolute value, and the \"multiplicative valuations\" generalize this to other codomains. Right?</p>",
        "id": 228809952,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1614877223
    },
    {
        "content": "<p>Absolute values are different yet still, as there you want <code>v(x + y) &lt;= v(x) + v(y)</code>.</p>",
        "id": 228813352,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1614878373
    },
    {
        "content": "<p>A multiplicative valuation with values in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">R</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{R}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">R</span></span></span></span></span> is an ULTRAmetric absolute value, which is stronger.</p>",
        "id": 228813538,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1614878423
    },
    {
        "content": "<p>My Laurent series PR has finally arrived: <a href=\"https://github.com/leanprover-community/mathlib/issues/7604\">#7604</a></p>",
        "id": 238659140,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1620929831
    },
    {
        "content": "<p>Taking requests for the API beyond this localization map.</p>",
        "id": 238659662,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1620930056
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"302826\">@Aaron Anderson</span>  I was looking at the file <code>hahn_series</code> and I see it still says that still remain TO DO</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"bp\">*</span> <span class=\"n\">Given</span> <span class=\"bp\">`</span><span class=\"o\">[</span><span class=\"n\">linear_ordered_add_comm_group</span> <span class=\"bp\">Γ</span><span class=\"o\">]</span><span class=\"bp\">`</span> <span class=\"n\">and</span> <span class=\"bp\">`</span><span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">R</span><span class=\"o\">]</span><span class=\"bp\">`</span><span class=\"o\">,</span> <span class=\"n\">define</span> <span class=\"bp\">`</span><span class=\"n\">field</span> <span class=\"o\">(</span><span class=\"n\">hahn_series</span> <span class=\"bp\">Γ</span> <span class=\"n\">R</span><span class=\"o\">)</span><span class=\"bp\">`.</span>\n  <span class=\"bp\">*</span> <span class=\"n\">Build</span> <span class=\"n\">an</span> <span class=\"n\">API</span> <span class=\"n\">for</span> <span class=\"n\">the</span> <span class=\"kd\">variable</span> <span class=\"bp\">`</span><span class=\"n\">X</span><span class=\"bp\">`</span>\n  <span class=\"bp\">*</span> <span class=\"n\">Define</span> <span class=\"n\">Laurent</span> <span class=\"n\">series</span>\n</code></pre></div>\n<p>But it seems to me that the third is OK, and I don't understand what is the second exactly. What about the first? Also, don't you think it would be nicer to point at the file <code>laurent_series</code> in this <code>doc</code> so that one knows where to look at, if needed?</p>",
        "id": 250782324,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1629988698
    },
    {
        "content": "<p>You're right, I need to update that. Documentation PR coming ASAP.</p>",
        "id": 250819529,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1630003228
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/issues/8883\">#8883</a></p>",
        "id": 250822207,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1630004402
    },
    {
        "content": "<p>Thanks!</p>",
        "id": 250824348,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1630005256
    }
]
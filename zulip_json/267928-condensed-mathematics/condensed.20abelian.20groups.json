[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"132603\">@Calle S√∂nne</span> and <span class=\"user-mention\" data-user-id=\"110064\">@Kenny Lau</span> and <span class=\"user-mention\" data-user-id=\"246273\">@Bhavik Mehta</span> have been working on defining condensed sets. A natural goal here would be to prove that the category of condensed abelian groups is an abelian category with all the extra stuff too (e.g. arbitrary products). This is Theorem 1.10 of <a href=\"http://www.math.uni-bonn.de/people/scholze/Condensed.pdf\">http://www.math.uni-bonn.de/people/scholze/Condensed.pdf</a> .</p>",
        "id": 219240078,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1607450470
    },
    {
        "content": "<p>Reid has suggested that we initially ignore the cardinal bounds; we can come back to them later (they are in some sense not the point of the challenge)</p>",
        "id": 219240179,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1607450516
    },
    {
        "content": "<p>More precisely, taking <code>Type 1</code>-sized sheaves on tiny (:= <code>Type 0</code>-sized) profinite sets</p>",
        "id": 219240570,
        "sender_full_name": "Reid Barton",
        "timestamp": 1607450673
    },
    {
        "content": "<p>This will be a nice test of the abelian category machinery, so this has great value independent of the application to the challenge.</p>",
        "id": 219240877,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1607450849
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span>'s effort towards ind-objects seem relevant as well, if we need to show that the category Pro-Fintype is the same as Profinite</p>",
        "id": 219244114,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1607452434
    },
    {
        "content": "<p>My plan was to <strong>define</strong> profinite sets as <code>Pro(FinType)</code> <span aria-label=\"rofl\" class=\"emoji emoji-1f923\" role=\"img\" title=\"rofl\">:rofl:</span></p>",
        "id": 219244219,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1607452467
    },
    {
        "content": "<p>But I got stuck with the details, tbh.</p>",
        "id": 219244262,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1607452486
    },
    {
        "content": "<p>I think regardless of the definition, the equivalence between the two categories ought to be there</p>",
        "id": 219244377,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1607452543
    },
    {
        "content": "<p>Yes absolutely.</p>",
        "id": 219244407,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1607452559
    },
    {
        "content": "<p>Do you have a branch where you're working on this out of interest?</p>",
        "id": 219244504,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1607452586
    },
    {
        "content": "<p>I haven't started anything seriously, just playing around.</p>",
        "id": 219244552,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1607452601
    },
    {
        "content": "<p>For example, I tried making some crazy inductive-quotient style definition, which works out fine, except for universe problems.</p>",
        "id": 219244627,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1607452639
    },
    {
        "content": "<p>And I tried the \"direct\" way where you define hom sets as</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><msub><mo><mi mathvariant=\"normal\">lim</mi><mo>‚Å°</mo></mo><mi>j</mi></msub><msub><mo><mi mathvariant=\"normal\">colim</mi><mo>‚Å°</mo></mo><mi>i</mi></msub><mi mathvariant=\"normal\">Hom</mi><mo>‚Å°</mo><mo stretchy=\"false\">(</mo><mi>F</mi><mo stretchy=\"false\">(</mo><mi>i</mi><mo stretchy=\"false\">)</mo><mo separator=\"true\">,</mo><mi>G</mi><mo stretchy=\"false\">(</mo><mi>j</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\operatorname{lim}_j \\operatorname{colim}_i \\operatorname{Hom}(F(i),G(j))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.036108em;vertical-align:-0.286108em;\"></span><span class=\"mop\"><span class=\"mop\"><span class=\"mord mathrm\">l</span><span class=\"mord mathrm\">i</span><span class=\"mord mathrm\">m</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mop\"><span class=\"mop\"><span class=\"mord mathrm\">c</span><span class=\"mord mathrm\">o</span><span class=\"mord mathrm\">l</span><span class=\"mord mathrm\">i</span><span class=\"mord mathrm\">m</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mop\"><span class=\"mord mathrm\">H</span><span class=\"mord mathrm\">o</span><span class=\"mord mathrm\">m</span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">)</span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p>but even defining the identity morphisms seems to be a major pain...</p>",
        "id": 219244785,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1607452716
    },
    {
        "content": "<p>I'm still not sure what definition would be best here...</p>",
        "id": 219244902,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1607452788
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">category_theory.limits.functor_category</span>\n<span class=\"kn\">import</span> <span class=\"n\">category_theory.full_subcategory</span>\n<span class=\"kn\">import</span> <span class=\"n\">category_theory.limits.types</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">category_theory</span>\n<span class=\"kn\">namespace</span> <span class=\"n\">limits</span>\n\n<span class=\"kd\">universes</span> <span class=\"n\">v</span> <span class=\"n\">u</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">small_category</span> <span class=\"n\">C</span><span class=\"o\">]</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">as_inductive</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"bp\">·µí·µñ</span> <span class=\"bp\">‚•§</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">D</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n<span class=\"o\">[</span><span class=\"bp\">ùíü</span> <span class=\"o\">:</span> <span class=\"n\">small_category</span> <span class=\"n\">D</span><span class=\"o\">]</span>\n<span class=\"o\">[</span><span class=\"n\">hD</span> <span class=\"o\">:</span> <span class=\"n\">is_filtered</span> <span class=\"n\">D</span><span class=\"o\">]</span>\n<span class=\"o\">(</span><span class=\"n\">Œ±</span> <span class=\"o\">:</span> <span class=\"n\">D</span> <span class=\"bp\">‚•§</span> <span class=\"n\">C</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"bp\">‚âÖ</span> <span class=\"n\">colimit</span> <span class=\"o\">(</span><span class=\"n\">Œ±</span> <span class=\"bp\">‚ãô</span> <span class=\"o\">(</span><span class=\"n\">yoneda</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"bp\">‚•§</span> <span class=\"n\">C</span><span class=\"bp\">·µí·µñ</span> <span class=\"bp\">‚•§</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)))</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">is_inductive</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"bp\">·µí·µñ</span> <span class=\"bp\">‚•§</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">mk'</span> <span class=\"o\">:</span> <span class=\"n\">nonempty</span> <span class=\"o\">(</span><span class=\"n\">as_inductive</span> <span class=\"n\">P</span><span class=\"o\">))</span>\n\n<span class=\"kd\">@[derive category]</span>\n<span class=\"kd\">def</span> <span class=\"n\">ind</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"bp\">·µí·µñ</span> <span class=\"bp\">‚•§</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">//</span> <span class=\"n\">is_inductive</span> <span class=\"n\">P</span><span class=\"o\">}</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">limits</span>\n<span class=\"kd\">end</span> <span class=\"n\">category_theory</span>\n</code></pre></div>\n<p>this works but I don't know if making C a small category is too restrictive</p>",
        "id": 219246993,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1607453818
    },
    {
        "content": "<p>Right, so this is the presentation of filtered colimits of representables in presheves. That's the right category.</p>",
        "id": 219247206,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1607453909
    },
    {
        "content": "<p>Yeah, but <code>Fintype</code> isn't a small category, so with this definition we don't get Ind(Fintype) \\iso Type</p>",
        "id": 219247594,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1607454110
    },
    {
        "content": "<p>There's a nice skeleton for <code>FinType</code>, already in mathlib :)</p>",
        "id": 219247664,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1607454125
    },
    {
        "content": "<p>Sure but I don't see any maths reason why Ind is only defined for small categories</p>",
        "id": 219247735,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1607454166
    },
    {
        "content": "<p>Ah this looks better:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">category_theory.limits.functor_category</span>\n<span class=\"kn\">import</span> <span class=\"n\">category_theory.full_subcategory</span>\n<span class=\"kn\">import</span> <span class=\"n\">category_theory.limits.types</span>\n<span class=\"kn\">import</span> <span class=\"n\">category_theory.Fintype</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">category_theory</span>\n<span class=\"kn\">namespace</span> <span class=\"n\">limits</span>\n\n<span class=\"kd\">universes</span> <span class=\"n\">v</span> <span class=\"n\">u</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">category.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">C</span><span class=\"o\">]</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">as_inductive</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"bp\">·µí·µñ</span> <span class=\"bp\">‚•§</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">D</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n<span class=\"o\">[</span><span class=\"bp\">ùíü</span> <span class=\"o\">:</span> <span class=\"n\">small_category</span> <span class=\"n\">D</span><span class=\"o\">]</span>\n<span class=\"o\">[</span><span class=\"n\">hD</span> <span class=\"o\">:</span> <span class=\"n\">is_filtered</span> <span class=\"n\">D</span><span class=\"o\">]</span>\n<span class=\"o\">(</span><span class=\"n\">Œ±</span> <span class=\"o\">:</span> <span class=\"n\">D</span> <span class=\"bp\">‚•§</span> <span class=\"n\">C</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">cocone</span> <span class=\"o\">(</span><span class=\"n\">Œ±</span> <span class=\"bp\">‚ãô</span> <span class=\"n\">yoneda</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">hc</span> <span class=\"o\">:</span> <span class=\"n\">is_colimit</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"bp\">‚âÖ</span> <span class=\"n\">c.X</span><span class=\"o\">)</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">is_inductive</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"bp\">·µí·µñ</span> <span class=\"bp\">‚•§</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">mk'</span> <span class=\"o\">:</span> <span class=\"n\">nonempty</span> <span class=\"o\">(</span><span class=\"n\">as_inductive</span> <span class=\"n\">P</span><span class=\"o\">))</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">C</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[derive category]</span>\n<span class=\"kd\">def</span> <span class=\"n\">ind</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"bp\">·µí·µñ</span> <span class=\"bp\">‚•§</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span> <span class=\"bp\">//</span> <span class=\"n\">is_inductive</span> <span class=\"n\">P</span><span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">thing</span> <span class=\"o\">:</span> <span class=\"n\">ind</span> <span class=\"n\">Fintype.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"bp\">‚âå</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"o\">:=</span>\n<span class=\"n\">sorry</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">limits</span>\n<span class=\"kd\">end</span> <span class=\"n\">category_theory</span>\n</code></pre></div>",
        "id": 219247857,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1607454225
    },
    {
        "content": "<p>some stuff building on that here: <a href=\"https://github.com/leanprover-community/mathlib/tree/ind-object\">https://github.com/leanprover-community/mathlib/tree/ind-object</a></p>",
        "id": 219250479,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1607455628
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/267928-condensed-mathematics/topic/condensed.20abelian.20groups/near/219240877\">said</a>:</p>\n<blockquote>\n<p>This will be a nice test of the abelian category machinery, so this has great value independent of the application to the challenge.</p>\n</blockquote>\n<p>I didnt know this existed!</p>",
        "id": 219263674,
        "sender_full_name": "Calle S√∂nne",
        "timestamp": 1607462163
    },
    {
        "content": "<p>Looks great</p>",
        "id": 219263698,
        "sender_full_name": "Calle S√∂nne",
        "timestamp": 1607462169
    },
    {
        "content": "<p>So where have people been working on this? I have just been (slowly) trying to build upon <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> s definition of Profinite sets on the branch Profinite2. So far I proved they have limits, so now I guess that the pretopology can be defined.</p>",
        "id": 219264982,
        "sender_full_name": "Calle S√∂nne",
        "timestamp": 1607462810
    },
    {
        "content": "<p>Abelian categories are now in mathlib!</p>",
        "id": 219268366,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1607464447
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.abelian\">docs#category_theory.abelian</a></p>",
        "id": 219268484,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1607464527
    },
    {
        "content": "<p>The first goal is to show that the category of sheaves of abelian groups on <code>Profinite</code> is an abelian category.</p>",
        "id": 219268588,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1607464568
    },
    {
        "content": "<p>It may be worthwhile to prove that this is true for abelian sheaves on any site.</p>",
        "id": 219273068,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1607467077
    },
    {
        "content": "<p>But this requires sheafification, which I don't think we have yet in mathlib for a general grothendieck topology</p>",
        "id": 219273404,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1607467267
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/267928-condensed-mathematics/topic/condensed.20abelian.20groups/near/219273068\">said</a>:</p>\n<blockquote>\n<p>It may be worthwhile to prove that this is true for abelian sheaves on any site.</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> tells me this isn't true in general</p>",
        "id": 219278519,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1607470130
    },
    {
        "content": "<p>(unless I'm misunderstanding something which is more than likely)</p>",
        "id": 219278589,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1607470175
    },
    {
        "content": "<p>Condensed abelian groups satisfy stronger axioms than just an abelian category that do not hold true in for general abelian sheaves. Maybe this is what he means?</p>",
        "id": 219278842,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1607470340
    },
    {
        "content": "<p>Probably, assume that I understood something wrong rather than that he said something wrong though :)</p>",
        "id": 219279083,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1607470487
    },
    {
        "content": "<p><a href=\"https://stacks.math.columbia.edu/tag/03CN\">https://stacks.math.columbia.edu/tag/03CN</a></p>",
        "id": 219279099,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1607470506
    },
    {
        "content": "<p>was just about to ask for that, thanks</p>",
        "id": 219279132,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1607470538
    },
    {
        "content": "<p>Looking through that it seems like it splits up quite nicely: <a href=\"https://stacks.math.columbia.edu/tag/03A3\">https://stacks.math.columbia.edu/tag/03A3</a> is just a statement on abelian categories, it requires that the category of abelian presheaves is abelian: <a href=\"https://stacks.math.columbia.edu/tag/03A6\">https://stacks.math.columbia.edu/tag/03A6</a>, and what's left then is that the abelian sheaves are a reflective subcategory where the reflector is left exact</p>",
        "id": 219279827,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1607471049
    },
    {
        "content": "<p>To get here of course we need to define abelian presheaves and sheaves, which I talked a bit about here: <a href=\"https://github.com/leanprover-community/mathlib/pull/5255#issuecomment-740065209\">https://github.com/leanprover-community/mathlib/pull/5255#issuecomment-740065209</a></p>",
        "id": 219279867,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1607471090
    },
    {
        "content": "<p>We also need the sheafification functor, but I'm sure you already have plans for that :)</p>",
        "id": 219280325,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1607471453
    },
    {
        "content": "<p>I do :)</p>",
        "id": 219280335,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1607471460
    },
    {
        "content": "<p><a href=\"https://github.com/b-mehta/topos/blob/master/src/applications/sheaves_on_a_site.lean\">Coming soon to a mathlib near you</a></p>",
        "id": 219280366,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1607471494
    },
    {
        "content": "<p>Is <code>Profinite</code> as in mathlib a small category? The results in stacks are stated only for small categories, as is the result I put in the link above</p>",
        "id": 219281671,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1607472446
    },
    {
        "content": "<p>It might be necessary to <code>ulift</code> the morphisms of <code>Profinite</code> to make it small in the next universe</p>",
        "id": 219281860,
        "sender_full_name": "Reid Barton",
        "timestamp": 1607472596
    },
    {
        "content": "<p>Do you think just doing that will solve the universe issues?</p>",
        "id": 219281958,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1607472655
    },
    {
        "content": "<p>It is the correct way to solve them in this context</p>",
        "id": 219282014,
        "sender_full_name": "Reid Barton",
        "timestamp": 1607472699
    },
    {
        "content": "<p>By the way do you have any suggestions for making the category of ind-objects? I had a go here: <a href=\"#narrow/stream/267928-condensed-mathematics/topic/condensed.20abelian.20groups/near/219247857\">https://leanprover.zulipchat.com/#narrow/stream/267928-condensed-mathematics/topic/condensed.20abelian.20groups/near/219247857</a> but it doesn't seem like the best way to me</p>",
        "id": 219282096,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1607472733
    },
    {
        "content": "<p>If I recall correctly, it's not that easy to prove that objects of this form are closed under filtered colimits</p>",
        "id": 219283950,
        "sender_full_name": "Reid Barton",
        "timestamp": 1607474254
    },
    {
        "content": "<p>which is the one property you'd hope would be obvious from this definition</p>",
        "id": 219283961,
        "sender_full_name": "Reid Barton",
        "timestamp": 1607474271
    },
    {
        "content": "<p>also the definition seems to indicate we lack a version of a colimit cocone indexed on the vertex</p>",
        "id": 219284089,
        "sender_full_name": "Reid Barton",
        "timestamp": 1607474356
    },
    {
        "content": "<p>I have a construction of the closure under a certain class of colimits somewhere, but I'm not sure it is very useful either</p>",
        "id": 219284129,
        "sender_full_name": "Reid Barton",
        "timestamp": 1607474390
    },
    {
        "content": "<p>oh but that was mostly to avoid enlarging the universe, which isn't an issue here</p>",
        "id": 219284243,
        "sender_full_name": "Reid Barton",
        "timestamp": 1607474481
    },
    {
        "content": "<p>Typically I'd assume that <code>C</code> is small and has finite colimits and take the full subcategory on the guys that send those to limits</p>",
        "id": 219284461,
        "sender_full_name": "Reid Barton",
        "timestamp": 1607474630
    },
    {
        "content": "<p>If <code>C</code> doesn't have finite colimits then I guess you can take flat functors?</p>",
        "id": 219284522,
        "sender_full_name": "Reid Barton",
        "timestamp": 1607474654
    },
    {
        "content": "<p>let's see what LPAC does</p>",
        "id": 219284546,
        "sender_full_name": "Reid Barton",
        "timestamp": 1607474674
    },
    {
        "content": "<p>it proves that being a filtered colimit of representables is equivalent to the corresponding colimit-preserving functor preserving finite limits</p>",
        "id": 219285243,
        "sender_full_name": "Reid Barton",
        "timestamp": 1607475162
    },
    {
        "content": "<p>Do you know how difficult that proof is to formalise?</p>",
        "id": 219285288,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1607475214
    },
    {
        "content": "<p>it doesn't look especially hard</p>",
        "id": 219285358,
        "sender_full_name": "Reid Barton",
        "timestamp": 1607475262
    },
    {
        "content": "<p>Lemma 2.24</p>",
        "id": 219285360,
        "sender_full_name": "Reid Barton",
        "timestamp": 1607475266
    },
    {
        "content": "<p>What's LPAC?</p>",
        "id": 219285440,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1607475348
    },
    {
        "content": "<p>Locally Presentable and Accessible Categories</p>",
        "id": 219285492,
        "sender_full_name": "Reid Barton",
        "timestamp": 1607475363
    },
    {
        "content": "<p>Oh yeah that looks very manageable</p>",
        "id": 219285517,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1607475409
    },
    {
        "content": "<p>at least if you replace \"directed\" in the statement by \"filtered\"</p>",
        "id": 219285541,
        "sender_full_name": "Reid Barton",
        "timestamp": 1607475440
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"246273\">Bhavik Mehta</span> <a href=\"#narrow/stream/267928-condensed-mathematics/topic/condensed.20abelian.20groups/near/219279083\">said</a>:</p>\n<blockquote>\n<p>Probably, assume that I understood something wrong rather than that he said something wrong though :)</p>\n</blockquote>\n<p>Apologies for the confusion -- this was a conversation we had on the discord and I'm pretty sure it was me who got it wrong -- I'd misremembered something. Arbitrary products are exact for condensed abelian groups (a product of epis is epi), and this is not true for sheaves of abelian groups on a general site, but all the axioms for an abelian category hold for sheaves of abelian groups on a general site (Bhavik I think I told you that arbitrary products might not exist in general).</p>",
        "id": 219285771,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1607475643
    },
    {
        "content": "<p>Yup, as you mentioned Scholze says something along these lines:<br>\n\"This makes Cond(Ab) exceptionally well-behaved, even more well-behaved than the category of abelian sheaves on a usual topos: Usually, infinite products fail to be exact.\"</p>",
        "id": 219285928,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1607475737
    },
    {
        "content": "<p>Your <code>thing</code> is an interesting test case, I feel like it will probably be pretty hard to prove directly</p>",
        "id": 219286413,
        "sender_full_name": "Reid Barton",
        "timestamp": 1607476150
    },
    {
        "content": "<p>I'm not sure if it'll make that easier but I do suspect the definition would be nicer as saying the corresponding colimit-preserving functor preserving finite limits</p>",
        "id": 219287218,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1607476865
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"132603\">@Calle S√∂nne</span> <a href=\"https://github.com/leanprover-community/mathlib/blob/1f1ba587f272d203a40801c6b21af453f7de6ee3/src/topology/subset_properties.lean#L1305\">https://github.com/leanprover-community/mathlib/blob/1f1ba587f272d203a40801c6b21af453f7de6ee3/src/topology/subset_properties.lean#L1305</a></p>",
        "id": 219371364,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1607535814
    },
    {
        "content": "<p>Getting back to the ind-objects stuff, I've got a workable definition of flat functor on an arbitrary category (ie, not necessarily small and with no assumptions on limits/colimits), together with a proof that it's the same notion as preserving finite limits if they exist in the category, and almost got that the category of flat functors (ie ind-objects) is closed under filtered colimits (if the category is small), so I'm not far off from formally showing they're the ind-completion</p>",
        "id": 224891401,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1612281615
    },
    {
        "content": "<p>The real tests here though are showing that ind Fintype = Type, and ind Fintype^op = Profinite^op</p>",
        "id": 224891645,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1612281703
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"246273\">@Bhavik Mehta</span> Those would be great to have, yes.</p>",
        "id": 224891861,
        "sender_full_name": "Peter Scholze",
        "timestamp": 1612281778
    },
    {
        "content": "<p>If anyone's interested in joining, I'm having a go at showing ind Fintype = Type in Kevin's discord!</p>",
        "id": 225867785,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1612975222
    },
    {
        "content": "<p>Does anyone know if this result will explicitly be helpful? Specifically Calle has shown the topology version without an explicit equivalence of categories, is that good enough for the liquid project or is the actual category theory helpful too</p>",
        "id": 226858099,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1613673394
    },
    {
        "content": "<p>I think the equivalence <code>Pro (FinType) \\equiv Profinite</code> is actually useful because there are a lot of arguments that work with some functor on <code>Profinite</code> where you reduce to the finite case using this equivalence.</p>",
        "id": 226858619,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1613673577
    },
    {
        "content": "<p>So after several months away doing other things I've now got some time to work on some research-level Lean (which is a very welcome state of affairs). Adam suggested that I look at the proof that condensed abelian groups are an abelian category. I've been watching the chat but not reading closely.</p>\n<p>I see we have <code>src/condensed/ab.lean</code> :D Some of the imports have sorrys though. The first one is in <code>for_mathlib/Profinite/disjoint_union.lean</code> and it's </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">is_preconnected.preimage</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">Œ±</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">Œ≤</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">Œ≤</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">is_preconnected</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">Œ≤</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">continuous_on</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">‚Åª¬π'</span> <span class=\"n\">s</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">hsf</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">‚äÜ</span> <span class=\"n\">set.range</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">is_preconnected</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">‚Åª¬π'</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>which seems wrong to me -- a counterexample would be beta=s={*} and alpha is an arbitrary (non-preconnected) topological space. The sorried lemma is used in the proof of <code>sigma.is_connected_iff</code>. Have I made a mistake here or is something fishy going on?</p>\n<p>The next sorried lemma is <code>finite_product_condition_iff_empty_condition_product_condition</code> in <code>src/condensed/is_proetale_sheaf.lean</code> and it's basically the statement that something works for finite products iff it works for empty products and binary products. I could imagine ploughing through this but it being looong. Is there some category theory miracle which would make this less painful? </p>\n<p>My impression from the comments in <code>condensed.basic</code> is that Bhavik is in the middle of removing the sorries there. Comments like \"I'm 90% sure this is true as stated\" by a sorried lemma are a bit scary though!</p>\n<p>Should we sort out these sorries before going for the proof that condensed abelian groups are an abelian category?</p>",
        "id": 260442019,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1636135263
    },
    {
        "content": "<p>pre: preimage of connected is connected; it seems like the only times these dubious sorried lemmas are used in the project is to  (correctly) classify connected subsets of sigma types and binary sums, so maybe I'll just have a go at proving these results (<code>sigma.is_connected_iff</code> and <code>sum.is_connected_iff</code>)</p>",
        "id": 260445122,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1636136617
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> Bhavik's sorry'd lemma is essentially proven</p>",
        "id": 260446529,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1636137301
    },
    {
        "content": "<p>See <code>is_proetale_sheaf_tfae</code> in the other file</p>",
        "id": 260446597,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1636137336
    },
    {
        "content": "<p>The application of \"pre-image of connected is connected\" is in a situation where the map is injective and open (and the connected subset is in the image of the map), and in that case I think it's OK.</p>",
        "id": 260446601,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1636137336
    },
    {
        "content": "<p>I agree that it would be good to take care of these sorries <span aria-label=\"thumbs up\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"thumbs up\">:thumbs_up:</span></p>",
        "id": 260446964,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1636137507
    },
    {
        "content": "<p>It will be reassuring to know that we got the category right.</p>",
        "id": 260446992,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1636137525
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">condensed_type_condition</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">empty</span> <span class=\"o\">:</span> <span class=\"n\">nonempty</span> <span class=\"n\">X.preserves_terminal</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">bin_prod</span> <span class=\"o\">:</span> <span class=\"n\">nonempty</span> <span class=\"n\">X.preserves_binary_products</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">pullbacks</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"n\">S'</span> <span class=\"o\">:</span> <span class=\"n\">Profinite.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">S'</span> <span class=\"bp\">‚ü∂</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">epi</span> <span class=\"n\">f</span><span class=\"o\">],</span>\n  <span class=\"n\">nonempty</span> <span class=\"o\">(</span><span class=\"n\">is_limit</span> <span class=\"o\">(</span><span class=\"n\">natural_fork</span> <span class=\"n\">X</span> <span class=\"n\">f</span><span class=\"o\">)))</span>\n\n<span class=\"c1\">-- (BM): I'm 90% sure this is true as stated, the forward direction is about halfway done.</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">sheaf_condition_iff</span> <span class=\"o\">:</span>\n  <span class=\"n\">presieve.is_sheaf</span> <span class=\"n\">proetale_topology</span> <span class=\"n\">X</span> <span class=\"bp\">‚Üî</span> <span class=\"n\">condensed_type_condition</span> <span class=\"n\">X</span> <span class=\"o\">:=</span>\n<span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>is essentially the equialence between 1 and 4 in </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">is_proetale_sheaf_tfae</span> <span class=\"o\">[</span><span class=\"n\">limits.has_terminal</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">limits.has_binary_products</span> <span class=\"n\">C</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">limits.has_equalizers</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"o\">[</span> <span class=\"n\">presheaf.is_sheaf</span> <span class=\"n\">proetale_topology</span> <span class=\"n\">Q</span><span class=\"o\">,</span>\n    <span class=\"n\">Q.is_proetale_sheaf</span><span class=\"o\">,</span>\n    <span class=\"n\">Q.is_proetale_sheaf_pullback</span><span class=\"o\">,</span>\n    <span class=\"n\">Q.empty_condition'</span> <span class=\"bp\">‚àß</span> <span class=\"n\">Q.product_condition'</span> <span class=\"bp\">‚àß</span> <span class=\"n\">Q.equalizer_condition'</span>\n  <span class=\"o\">]</span><span class=\"bp\">.</span><span class=\"n\">tfae</span> <span class=\"o\">:=</span>\n</code></pre></div>",
        "id": 260447250,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1636137669
    },
    {
        "content": "<p>Well, modulo a technicality about the equalizer condition vs. the pullback condition that's easy to see</p>",
        "id": 260447317,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1636137715
    },
    {
        "content": "<p>Oh, and note that the <code>tfae</code> statement works for presheaves taking values in any category, not just <code>Type*</code> whichh is the context of <code>sheaf_condition_iff</code></p>",
        "id": 260447454,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1636137774
    },
    {
        "content": "<p>Once <a href=\"https://github.com/leanprover-community/mathlib/issues/10169\">#10169</a> is merged ( <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span> ) I'll be able to add another characterization of sheaves similar to what appears in the following file<br>\n<a href=\"https://github.com/leanprover-community/lean-liquid/blob/sheafification_stuff/src/for_mathlib/sheafification/multifork_sheaf_condition.lean\">https://github.com/leanprover-community/lean-liquid/blob/sheafification_stuff/src/for_mathlib/sheafification/multifork_sheaf_condition.lean</a></p>",
        "id": 260447976,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1636138014
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/267928-condensed-mathematics/topic/condensed.20abelian.20groups/near/260446601\">said</a>:</p>\n<blockquote>\n<p>The application of \"pre-image of connected is connected\" is in a situation where the map is injective and open (and the connected subset is in the image of the map), and in that case I think it's OK.</p>\n</blockquote>\n<p>I don't really know where the <code>is_preconnected.preimage</code> came from. It's only needed in the case where the map is an open embedding.</p>",
        "id": 260449222,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1636138512
    },
    {
        "content": "<p>yeah I'm fixing it up right now</p>",
        "id": 260451634,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1636139570
    },
    {
        "content": "<p>lol the unused argument linter tells me that I never assumed f was continuous ;-)</p>",
        "id": 260454880,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1636141298
    },
    {
        "content": "<p>I love it when Lean does that</p>",
        "id": 260454905,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1636141311
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">is_preconnected.preimage</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">Œ±</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">Œ≤</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">Œ≤</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">is_preconnected</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">Œ≤</span><span class=\"o\">}</span>   <span class=\"o\">(</span><span class=\"n\">hfinj</span> <span class=\"o\">:</span> <span class=\"n\">function.injective</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hfopen</span> <span class=\"o\">:</span> <span class=\"n\">is_open_map</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">hsf</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">‚äÜ</span> <span class=\"n\">set.range</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">is_preconnected</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">‚Åª¬π'</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">Œª</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">hu</span> <span class=\"n\">hv</span> <span class=\"n\">hsuv</span> <span class=\"n\">hsu</span> <span class=\"n\">hsv</span><span class=\"o\">,</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">specialize</span> <span class=\"n\">hs</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">''</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">''</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hfopen</span> <span class=\"n\">u</span> <span class=\"n\">hu</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hfopen</span> <span class=\"n\">v</span> <span class=\"n\">hv</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">set.image_subset</span> <span class=\"n\">f</span> <span class=\"n\">hsuv</span><span class=\"o\">,</span>\n    <span class=\"n\">rwa</span> <span class=\"o\">[</span><span class=\"n\">set.image_preimage_eq'</span> <span class=\"n\">hsf</span><span class=\"o\">,</span> <span class=\"n\">set.image_union</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">this</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">obtain</span> <span class=\"o\">‚ü®</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hx1</span><span class=\"o\">,</span> <span class=\"n\">hx2</span><span class=\"o\">‚ü©</span> <span class=\"o\">:=</span> <span class=\"n\">hsu</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"o\">‚ü®</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hx1</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hx2</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">‚ü©</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">obtain</span> <span class=\"o\">‚ü®</span><span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">hy1</span><span class=\"o\">,</span> <span class=\"n\">hy2</span><span class=\"o\">‚ü©</span> <span class=\"o\">:=</span> <span class=\"n\">hsv</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"o\">‚ü®</span><span class=\"n\">f</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">hy1</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">hy2</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">‚ü©</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">obtain</span> <span class=\"o\">‚ü®</span><span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">hbs</span><span class=\"o\">,</span> <span class=\"n\">hbu</span><span class=\"o\">,</span> <span class=\"n\">hbv</span><span class=\"o\">‚ü©</span> <span class=\"o\">:=</span> <span class=\"n\">hs</span><span class=\"o\">,</span>\n    <span class=\"n\">obtain</span> <span class=\"o\">‚ü®</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">‚ü©</span> <span class=\"o\">:=</span> <span class=\"n\">hsf</span> <span class=\"n\">hbs</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">function.injective.mem_set_image</span> <span class=\"n\">hfinj</span> <span class=\"n\">at</span> <span class=\"n\">hbu</span> <span class=\"n\">hbv</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"o\">‚ü®</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">hbs</span><span class=\"o\">,</span> <span class=\"n\">hbu</span><span class=\"o\">,</span> <span class=\"n\">hbv</span><span class=\"o\">‚ü©</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 260454969,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1636141335
    },
    {
        "content": "<p>So I just pushed straight to master -- is that OK? I'll keep going -- this is a nice warm-up, I can probably get <code>for_mathlib/Profinite/disjoint_union.lean</code> sorry-free this evening (everyone else has gone out :D )</p>",
        "id": 260456691,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1636142271
    },
    {
        "content": "<p>Master is fine!</p>",
        "id": 260456933,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1636142376
    },
    {
        "content": "<p>What sorry's arre left?</p>",
        "id": 260456966,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1636142395
    },
    {
        "content": "<p>Just a couple of topological trivialities which Yael skipped</p>",
        "id": 260457707,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1636142677
    },
    {
        "content": "<p>Basically if you're connected and in a disjoint union (either a pair or a sigma type) then you're in one of them</p>",
        "id": 260457814,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1636142738
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> I pushed a complete mathlib bump to the LTE branch <code>bump-2021-11-05</code>. I didn't want to bump master directly, in case you're still working on this, so we should merge this to master when convenient.</p>",
        "id": 260464033,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1636145988
    },
    {
        "content": "<p>feel free to merge to master; I can't imagine that you'll break any of my local work</p>",
        "id": 260464151,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1636146015
    },
    {
        "content": "<p>Okay, done. Make sure to refresh your oleans!</p>",
        "id": 260464278,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1636146072
    },
    {
        "content": "<p>nothing broke :D</p>",
        "id": 260464701,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1636146337
    },
    {
        "content": "<p>OK that's me done for the day -- <code>for_mathlib.Profinite.disjoint_union</code> is now sorry-free. <span class=\"user-mention\" data-user-id=\"387244\">@Ya√´l Dillies</span> you seem to have written a bunch of that file -- I added in some extra assumptions to make \"pre-image of connected is connected\" true and also added a few more lemmas (see the longish proofs in lines &lt;= 90), maybe you want to golf them? I did my best.</p>",
        "id": 260474976,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1636153413
    },
    {
        "content": "<p>How come I have written a bunch of any file?</p>",
        "id": 260475038,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1636153446
    },
    {
        "content": "<p>oh you were git blamed for that file</p>",
        "id": 260475047,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1636153460
    },
    {
        "content": "<p>The only thing I could do was isolate 3 or 4 lemmas and fill in easy sorries.</p>",
        "id": 260475056,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1636153470
    },
    {
        "content": "<p>You made a commit \"prove sigma.compact_space\" from two weeks ago. You left some sorries, I just filled them in.</p>",
        "id": 260475130,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1636153546
    },
    {
        "content": "<p>Oh okay, yeah that's what I did.</p>",
        "id": 260475227,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1636153618
    },
    {
        "content": "<p>I wondered whether you wanted to be a perfectionist about the proofs</p>",
        "id": 260475230,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1636153620
    },
    {
        "content": "<p>How can you wonder about that? <span aria-label=\"stuck out tongue closed eyes\" class=\"emoji emoji-1f61d\" role=\"img\" title=\"stuck out tongue closed eyes\">:stuck_out_tongue_closed_eyes:</span></p>",
        "id": 260475254,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1636153636
    },
    {
        "content": "<p>Once you enter the <code>Profinite</code> namespace in that file, it become much more category-heavy (and that's my fault)</p>",
        "id": 260475273,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1636153669
    },
    {
        "content": "<p>If I filled in a sorry in a file Patrick wrote I suspect he'd want to have a look at it and tidy up the mess I'd made</p>",
        "id": 260475378,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1636153759
    },
    {
        "content": "<p>he has some principles ;-) (i.e. he's very good at writing short topology proofs)</p>",
        "id": 260475400,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1636153784
    },
    {
        "content": "<p>Adam I think it will be very good for me to engage with some of the category theory stuff again. I've done it twice in my life before and both times poor Scott has had to endure a huge amount of whingeing from me about how it is so hard to do category theory in Lean, followed slowly by me getting the hang of it a bit more, so I'm looking forward to learning more about it.</p>",
        "id": 260475535,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1636153876
    },
    {
        "content": "<p>I'm less sure that Scott will be, although maybe there are other people I can whinge to nowadays :D</p>",
        "id": 260475553,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1636153901
    },
    {
        "content": "<p>When you can comment out some field in some structure in some abstract nonsense category-theoretic structure because you know that <code>tidy</code> can solve it, and it works after 37 seconds, it makes all the pain completely worth it.</p>",
        "id": 260475860,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1636154148
    },
    {
        "content": "<p>I have some dumb questions related to \"a functor preserves finite products iff it preserves binary products and terminal objects\", another sorry on the way to the definition of condensed abelian groups. </p>\n<p>1) Where do things like \"if C is a category, X and Y are objects, and f : X -&gt; Y is an isomorphism, then f^{op} : Y^{op} -&gt; X^{op} is an isomorphism\" and \"if F : C -&gt; D is a functor, and F : X -&gt; Y is an isomorphism, then <a href=\"http://F.map\">F.map</a> f is an isomorphism\" live? I guess these will be definitions rather than theorems.</p>\n<p>2) Do we have a nonconstructive <code>singleton</code>? i.e. a Prop-valued \"I have precisely one term\"?</p>",
        "id": 260518007,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1636210543
    },
    {
        "content": "<p>1) <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.iso.op\">docs#category_theory.iso.op</a></p>",
        "id": 260518065,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1636210595
    },
    {
        "content": "<p>And <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.functor.map_iso\">docs#category_theory.functor.map_iso</a></p>",
        "id": 260518100,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1636210630
    },
    {
        "content": "<p>I think <a href=\"https://leanprover-community.github.io/mathlib_docs/find/unique\">docs#unique</a> for 2?</p>",
        "id": 260518162,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1636210694
    },
    {
        "content": "<p>Oh that's not Prop valued.</p>",
        "id": 260518168,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1636210718
    },
    {
        "content": "<p>For 1, the links above work if you are using <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.iso\">docs#category_theory.iso</a> but if you want to use <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.is_iso\">docs#category_theory.is_iso</a> then there should be some similarly named lemmas that accomplish the same thing</p>",
        "id": 260518318,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1636210824
    },
    {
        "content": "<p>ooh thanks a lot for these tips and links!</p>",
        "id": 260518969,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1636211464
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> you've made things like <code>category_theory.functor.finite_product_condition</code> (in <code>is_proetale_sheaf.lean</code>) be Prop-valued (asserting a function is bijective rather than asserting the data of an inverse) so I guess I'll stick with this convention</p>",
        "id": 260519075,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1636211619
    },
    {
        "content": "<p>We should have a lemma saying that a morphism in <code>Type*</code> has <code>is_iso</code> if it's bijective.</p>",
        "id": 260519139,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1636211702
    },
    {
        "content": "<p>you mean \"it should be there\" or \"I should make it right now\"?</p>",
        "id": 260519200,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1636211764
    },
    {
        "content": "<p>The reason I used plain properties of functions as opposed to category theoretic notions is because I later apply these to the values of some yoneda functors, and it's much easier to apply the conditions in this case</p>",
        "id": 260519206,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1636211771
    },
    {
        "content": "<p>I'm still not up to speed :-)</p>",
        "id": 260519208,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1636211776
    },
    {
        "content": "<p>I think it should be there...</p>",
        "id": 260519212,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1636211785
    },
    {
        "content": "<p>Somewhere <span aria-label=\"grimacing\" class=\"emoji emoji-1f62c\" role=\"img\" title=\"grimacing\">:grimacing:</span></p>",
        "id": 260519217,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1636211792
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.is_iso_iff_bijective\">docs#category_theory.is_iso_iff_bijective</a></p>",
        "id": 260519652,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1636212368
    },
    {
        "content": "<p>Thanks so much</p>",
        "id": 260519690,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1636212431
    },
    {
        "content": "<p>That file has all of the lemmas relating categorical notions in <code>Type*</code> to the usual properties of functions</p>",
        "id": 260519748,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1636212507
    },
    {
        "content": "<p>I'll try and get somewhere with the remaining sorry. It's not going to be fun but I think I'm thinking about it in the right way. On paper it's easy but in lean it's delicate. Take \"the empty profinite space\" for example. In my mind there is one such object. But lean knows about the empty type, or a sigma type over the empty type, or the product of the empty type and another type etc etc -- these are all types and who knows, they're probably not provably equal in Lean anyway, however of course they're isomorphic as profinite spaces and now one has to do some diagram chasing which is elementary and not hard to write down on paper -- the insight is realising that these empty types aren't equal and so you have to be careful drawing the diagrams :-)</p>",
        "id": 260519868,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1636212683
    },
    {
        "content": "<p>I think for that finite product sorry, the first step is to prove an analogue of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/fintype.induction_empty_option\">docs#fintype.induction_empty_option</a> for <a href=\"https://leanprover-community.github.io/mathlib_docs/find/Fintype\">docs#Fintype</a></p>",
        "id": 260520630,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1636213688
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/267928-condensed-mathematics/topic/condensed.20abelian.20groups/near/260474976\">said</a>:</p>\n<blockquote>\n<p>OK that's me done for the day -- <code>for_mathlib.Profinite.disjoint_union</code> is now sorry-free. <span class=\"user-mention silent\" data-user-id=\"387244\">Ya√´l Dillies</span> you seem to have written a bunch of that file -- I added in some extra assumptions to make \"pre-image of connected is connected\" true and also added a few more lemmas (see the longish proofs in lines &lt;= 90), maybe you want to golf them? I did my best.</p>\n</blockquote>\n<p>Oh wow! The final proofs aren't ending up much longer than where I left them.</p>",
        "id": 260520889,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1636214047
    },
    {
        "content": "<p>OK so I started on <code>finite_product_condition_iff_empty_condition_product_condition</code> (morally \"if P is a presheaf on Profinite then P (X1 disjoint union X2 disjoint .. disjoint Xn) = P X1 x P X2 x ... x P Xn iff this is true for n=0 and n=2\"). The issue is that the n=0 case is stated with empty and the n=2 case with binary products, whereas the general n case uses things like sigma types. </p>\n<p>Today I've managed to prove that the general n case implies the n=0 case. It doesn't sound like much but actually I learnt something about the kind of tools which were required to do this kind of proof in category theory. Thanks for the pointers yesterday Adam, they made things easier.</p>",
        "id": 260601463,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1636327024
    },
    {
        "content": "<p>OK so the next step is the following. We have <code>P</code> a contravariant functor from profinite types to types, and we have two profinite types <code>S</code> and <code>T</code>. Let X denote the map from <code>fin 2</code> to <code>Profinite</code> with <code>X 0 = S</code> and <code>X 1 = T</code>.  Notation : <code>a</code> is always <code>a : fin 2</code>. </p>\n<p>We are given that the obvious map from <code>P (Œ£ a, X a)</code> (think of the sigma type as just a disjoint union) to <code>Œ† a, P (X a)</code> (coming from the inclusions of the factors <code>X a</code> into the sigma type) is a bijection. We need to prove that the obvious map from <code>P (S ‚äï T) to P S √ó P T</code> is a bijection.</p>\n<p>Easy and useful: one can construct <code>S ‚äï T ‚âÉ Œ£ a, X a</code> commuting with the obvious maps from <code>S = X 0</code> and <code>T = X 1</code> into both sides. </p>\n<p>My idea: write down the map <code>P  (S ‚äï T) -&gt; P (Œ£ a, X a) -&gt; Œ† a, P (X a) -&gt; P S √ó P T</code>, prove it's a bijection because it's the composite of three bijections (the first because P of an iso is an iso, the second by hypothesis, and the third because I guess you can write down an inverse map?), and now argue that it's the same bijection as the obvious map because it agrees with the obvious map on the two factors.</p>",
        "id": 260606626,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1636334336
    },
    {
        "content": "<p>This feels like it's going to be very long, and we're still doing the easy part! I'm prepared to give it a go though.</p>",
        "id": 260606769,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1636334548
    },
    {
        "content": "<p>I think it would be a bit better to arrange the diagram as a commuting square, but it basically sounds good</p>",
        "id": 260607158,
        "sender_full_name": "Reid Barton",
        "timestamp": 1636335182
    },
    {
        "content": "<p><code>P (Œ£ a, X a) -&gt; P (S ‚äï T) </code></p>",
        "id": 260607167,
        "sender_full_name": "Reid Barton",
        "timestamp": 1636335195
    },
    {
        "content": "<p>right, I'm thinking of it as a square but writing it in lines</p>",
        "id": 260607174,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1636335218
    },
    {
        "content": "<p>i.e. never talk about the inverse of anything (sorry I forgot to reverse the map!)</p>",
        "id": 260607178,
        "sender_full_name": "Reid Barton",
        "timestamp": 1636335239
    },
    {
        "content": "<p>I have <code>e : S ‚äï T ‚âÉ Œ£ a, X a</code> and I'm happy to use the <code>iso</code> generated by <code>e</code></p>",
        "id": 260607227,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1636335280
    },
    {
        "content": "<p>oh it's just dawned on me what you mean</p>",
        "id": 260607234,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1636335309
    },
    {
        "content": "<p>but it will make your verification that the map is the right one harder, since you will need to use the fact that the two directions of <code>e</code> are equal</p>",
        "id": 260607236,
        "sender_full_name": "Reid Barton",
        "timestamp": 1636335315
    },
    {
        "content": "<p>it's easier to use the fact that <code>f</code> and <code>fg</code> iso =&gt; <code>g</code> iso or whatever</p>",
        "id": 260607242,
        "sender_full_name": "Reid Barton",
        "timestamp": 1636335332
    },
    {
        "content": "<p>gotcha -- prove the square commutes and then deduce the iso on the bottom line from the other three. I'm still not completely on top of the idea that this buys me something.</p>",
        "id": 260607293,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1636335411
    },
    {
        "content": "<p>Earlier on I was writing down bijections between <code>pempty</code> and <code>Œ£ a : pempty, X a</code> but here it was easy because to prove that a map between two types is a bijection it suffices to show that both types are singletons (for products) or empty (for sums)</p>",
        "id": 260607360,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1636335543
    },
    {
        "content": "<p>doing this exercise really pushed home to me the fact that \"the\" empty type, represented in two different ways in type theory, gives me two objects in a category of types which I cannot consider as equal.</p>",
        "id": 260607412,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1636335604
    },
    {
        "content": "<p>Category theory is just set theory with extensionality removed, thus making it harder to do anything.</p>",
        "id": 260607428,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1636335648
    },
    {
        "content": "<p>yeah but it's okay because everything is canonical <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 260607444,
        "sender_full_name": "Reid Barton",
        "timestamp": 1636335703
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/267928-condensed-mathematics/topic/condensed.20abelian.20groups/near/260607293\">said</a>:</p>\n<blockquote>\n<p>I'm still not completely on top of the idea that this buys me something.</p>\n</blockquote>\n<p>It doesn't buy you much. I just claim it will be easier to check that the square commutes (maybe the proof will even be <code>refl</code>?) than that your three-fold composite will be the right map. Consider that the square would still commute, and just as obviously, even if <code>a : fin 3</code> instead</p>",
        "id": 260607565,
        "sender_full_name": "Reid Barton",
        "timestamp": 1636335911
    },
    {
        "content": "<p>In this case your approach will just need to simplify something like <code>P.map e &gt;&gt; P.map e.symm</code>, which is easy but in general this is work that you can avoid by drawing the right diagram</p>",
        "id": 260607636,
        "sender_full_name": "Reid Barton",
        "timestamp": 1636336017
    },
    {
        "content": "<p>Thanks for the comments! I'll go with the square.</p>",
        "id": 260607744,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1636336197
    }
]
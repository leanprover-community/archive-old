[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130384\">@Riccardo Brasca</span> I just pushed a class <code>has_snake_lemma</code>.</p>",
        "id": 254179148,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1632216977
    },
    {
        "content": "<p>Here is an excerpt:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">has_snake_lemma</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">Œ¥</span> <span class=\"o\">:</span> <span class=\"n\">snake_input.proj</span> <span class=\"bp\">ùíú</span> <span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"bp\">‚ü∂</span> <span class=\"n\">snake_input.proj</span> <span class=\"bp\">ùíú</span> <span class=\"o\">(</span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"mi\">0</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">exact_Œ¥</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"o\">(</span><span class=\"n\">D</span> <span class=\"o\">:</span> <span class=\"n\">snake_input</span> <span class=\"bp\">ùíú</span><span class=\"o\">),</span> <span class=\"n\">exact</span> <span class=\"o\">((</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">‚ü∂</span><span class=\"o\">[</span><span class=\"n\">D</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">Œ¥.app</span> <span class=\"n\">D</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">Œ¥_exact</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"o\">(</span><span class=\"n\">D</span> <span class=\"o\">:</span> <span class=\"n\">snake_input</span> <span class=\"bp\">ùíú</span><span class=\"o\">),</span> <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">Œ¥.app</span> <span class=\"n\">D</span><span class=\"o\">)</span> <span class=\"o\">((</span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"bp\">‚ü∂</span><span class=\"o\">[</span><span class=\"n\">D.1</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"mi\">1</span><span class=\"o\">)))</span> <span class=\"c1\">-- why can't I write `‚ü∂[D]`</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">snake_lemma</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">has_snake_lemma</span> <span class=\"bp\">ùíú</span><span class=\"o\">]</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"bp\">ùíú</span><span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Œ¥</span> <span class=\"o\">(</span><span class=\"n\">D</span> <span class=\"o\">:</span> <span class=\"n\">snake_input</span> <span class=\"bp\">ùíú</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">D.obj</span> <span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"bp\">‚ü∂</span> <span class=\"n\">D.obj</span> <span class=\"o\">(</span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">has_snake_lemma.Œ¥.app</span> <span class=\"n\">D</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">exact_Œ¥</span> <span class=\"o\">(</span><span class=\"n\">D</span> <span class=\"o\">:</span> <span class=\"n\">snake_input</span> <span class=\"bp\">ùíú</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">exact</span> <span class=\"o\">((</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">‚ü∂</span><span class=\"o\">[</span><span class=\"n\">D</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">Œ¥</span> <span class=\"n\">D</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">has_snake_lemma.exact_Œ¥</span> <span class=\"n\">D</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">Œ¥_exact</span> <span class=\"o\">(</span><span class=\"n\">D</span> <span class=\"o\">:</span> <span class=\"n\">snake_input</span> <span class=\"bp\">ùíú</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">Œ¥</span> <span class=\"n\">D</span><span class=\"o\">)</span> <span class=\"o\">((</span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"bp\">‚ü∂</span><span class=\"o\">[</span><span class=\"n\">D</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"n\">has_snake_lemma.Œ¥_exact</span> <span class=\"n\">D</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">snake_lemma</span>\n</code></pre></div>",
        "id": 254179186,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1632217002
    },
    {
        "content": "<p>The trouble with the snake lemma is that nobody shows that it is functorial.</p>",
        "id": 254179215,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1632217024
    },
    {
        "content": "<p>But we will certainly need that.</p>",
        "id": 254179230,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1632217033
    },
    {
        "content": "<p>So I defined a category <code>snake_input</code> consisting of the diagrams to which the snake lemma applies. And <code>has_snake_lemma</code> asserts that there is a <code>Œ¥</code> that snakes through the diagram.</p>",
        "id": 254179337,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1632217084
    },
    {
        "content": "<p>I also added some wacky definitions. For example, if <code>D</code> is such a diagram, then <code>(0,1) ‚ü∂[D] (0,2)</code> is the arrow in the top right, between the two rightmost kernels.</p>",
        "id": 254179441,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1632217170
    },
    {
        "content": "<p>You are too fast!<br>\nBut it seems very good for me: we can already use in practice if we need it and I can work on the proof, right?</p>",
        "id": 254179740,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1632217350
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- The base diagram for the snake lemma. The object are indexed by `fin 4 √ó fin 3`:</span>\n\n<span class=\"sd\">(0,0) --&gt; (0,1) --&gt; (0,2)              | the kernels</span>\n<span class=\"sd\">  |         |         |</span>\n<span class=\"sd\">  v         v         v</span>\n<span class=\"sd\">(1,0) --&gt; (1,1) --&gt; (1,2)              | the first exact row</span>\n<span class=\"sd\">  |         |         |</span>\n<span class=\"sd\">  v         v         v</span>\n<span class=\"sd\">(2,0) --&gt; (2,1) --&gt; (2,2)              | the second exact row</span>\n<span class=\"sd\">  |         |         |</span>\n<span class=\"sd\">  v         v         v</span>\n<span class=\"sd\">(3,0) --&gt; (3,1) --&gt; (3,2)              | the cokernels</span>\n\n<span class=\"sd\">-/</span>\n<span class=\"kd\">@[derive [preorder, decidable_eq]</span><span class=\"o\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">snake_diagram</span> <span class=\"o\">:=</span> <span class=\"n\">fin</span> <span class=\"mi\">4</span> <span class=\"bp\">√ó</span> <span class=\"n\">fin</span> <span class=\"mi\">3</span>\n</code></pre></div>",
        "id": 254179742,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1632217352
    },
    {
        "content": "<p>Yeah, I hope that with this notation, it is even somewhat usable when proving things.</p>",
        "id": 254179893,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1632217376
    },
    {
        "content": "<p>If you write down 12 objects and 17 maps, you completely go crazy.</p>",
        "id": 254179932,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1632217403
    },
    {
        "content": "<p>So now there are two subgoals:</p>\n<ol>\n<li>show that an abelian category with enough projectives has an instance of <code>has_snake_lemma</code></li>\n<li>if you have <code>has_snake_lemma</code> then derived functors are delta functors.</li>\n</ol>",
        "id": 254180171,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1632217557
    },
    {
        "content": "<p>OK, I can work on 1. Is this in some branch?</p>",
        "id": 254180564,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1632217747
    },
    {
        "content": "<p>It's in <code>master</code>, thank you!</p>",
        "id": 254181277,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1632218113
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130384\">@Riccardo Brasca</span> great. I'll work on (2)</p>",
        "id": 254186881,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1632221318
    },
    {
        "content": "<p>I see that in <code>is_snake_input</code> you wrote <code>row_exact : ‚àÄ i, exact ((i,0) ‚ü∂[D] (i,1)) ((i,1) ‚ü∂[D] (i,2))</code>. For <code>i = 0</code> and <code>i = 3</code> this is automatic, right? It is part of what I call the snake lemma (easier than working with <code>Œ¥</code> of course). Do we know that <code>ker</code> is left exact?</p>",
        "id": 254229401,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1632239119
    },
    {
        "content": "<p>Mh, maybe I am confused, but in <code>is_snake_input</code>, where is the condition that <code>F (0,0)</code> is the kernel of <code>F 0 0 ‚ü∂ F 1 0</code>?</p>",
        "id": 254229781,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1632239254
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130384\">@Riccardo Brasca</span> You are right!</p>",
        "id": 254233152,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1632240408
    },
    {
        "content": "<p>So we should remove those conditions (and add them to <code>has_snake_lemma</code>)</p>",
        "id": 254233199,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1632240428
    },
    {
        "content": "<p>The kernel condition is the combination of <code>col_exact</code> and <code>mono</code>.</p>",
        "id": 254233250,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1632240443
    },
    {
        "content": "<p>Ah sure</p>",
        "id": 254234263,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1632240828
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130384\">@Riccardo Brasca</span> I pushed a fix for the <code>is_snake_input</code> stuff.</p>",
        "id": 254267432,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1632253815
    },
    {
        "content": "<p>So now <code>row_exact‚ÇÄ</code> and <code>row_exact‚ÇÉ</code> are sorried lemmas.</p>",
        "id": 254267471,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1632253836
    },
    {
        "content": "<p>Looks like <code>for_mathlib/fin_functor</code> is missing?</p>",
        "id": 254299878,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1632271808
    },
    {
        "content": "<p>Oops, sorry.</p>",
        "id": 254312853,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1632284110
    },
    {
        "content": "<p>I pushed it</p>",
        "id": 254312862,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1632284120
    },
    {
        "content": "<p>Is there a reason we have</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"bp\">ùíú</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">category.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"bp\">ùíú</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_images</span> <span class=\"bp\">ùíú</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_zero_morphisms</span> <span class=\"bp\">ùíú</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_kernels</span> <span class=\"bp\">ùíú</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>instead of</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"bp\">ùíú</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">category.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"bp\">ùíú</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">abelian</span> <span class=\"bp\">ùíú</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>? The full snake lemma surely need an abelian category, and I don't think it is a reasonable task to check which part need weaker assumptions, unless we really need it...</p>",
        "id": 254331460,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1632298763
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130384\">@Riccardo Brasca</span> certainly just provide the instance under abelian assumptions</p>",
        "id": 254332861,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1632299534
    },
    {
        "content": "<p>but the definition doesn't need more. And at some point people might want to do exact categories with snake lemmas, or something like that.</p>",
        "id": 254332890,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1632299556
    },
    {
        "content": "<p>I've started the proof of <code>row_exact‚ÇÄ</code>. It's not that fun, but with the notation you introduced is quite doable. I will try a <code>calc</code> block instead of rewriting everything for the second part, to check which one is better.</p>",
        "id": 254364604,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1632316477
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130384\">@Riccardo Brasca</span> I wanted to play around with pseudoelements to see how hard (or easy) it was and I filled in that sorry in <code>row_exact‚ÇÄ</code>. Do you want me to push, or do you already have a working proof? </p>\n<p>I found it quite natural to do this proof along the same lines as a pen-and-paper diagram chase.</p>",
        "id": 254399108,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1632329223
    },
    {
        "content": "<p>Go ahead!</p>",
        "id": 254399190,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1632329259
    },
    {
        "content": "<p>Yes, the part with pseudoelements is really the same as with pen and paper, I just wanted to play with Johan's notation</p>",
        "id": 254399268,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1632329282
    },
    {
        "content": "<p>Okay, it's pushed. One key point I added was this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">local</span> <span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"kd\">instance</span><span class=\"o\">]</span> <span class=\"n\">abelian.pseudoelement.over_to_sort</span>\n  <span class=\"n\">abelian.pseudoelement.hom_to_fun</span>\n  <span class=\"n\">abelian.pseudoelement.has_zero</span>\n</code></pre></div>\n<p>which makes working with pseudoelements very natural</p>",
        "id": 254399516,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1632329383
    },
    {
        "content": "<p>The definition of <code>Œ¥</code> must be done using universal properties of course,  but then we can again check exactness using pseudoelements.</p>",
        "id": 254400146,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1632329601
    },
    {
        "content": "<p>The proof I found on the internet uses the interesting ideas that, if the category has enough projectives, then exactness can be checked using \"projective pseudoelements\" (meaning that the source is projective). I have the impression that working with these is really easier than with general pseudoelements (we can take literally the difference)</p>",
        "id": 254400585,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1632329762
    },
    {
        "content": "<p>The universal properties should make it easy to construct a morphism from the kernel of the right-most map to the cokernel of the left-most map. We just need to build an isomorphhism between the corresponding objects in the diagram and these kernel/cokernels, whichh can be done using <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.abelian.is_iso_of_mono_of_epi\">docs#category_theory.abelian.is_iso_of_mono_of_epi</a> and the characterization of (in/bij)ectivity using pseudoelements.</p>",
        "id": 254400939,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1632329902
    },
    {
        "content": "<p>We have to try, but usually at some point one take the difference of certains elements. I am not sure this works very well with pseudo elements, but I would be happy to be proven wrong</p>",
        "id": 254404357,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1632331090
    },
    {
        "content": "<p>On the other hand, with enough projectives, a sequence is exact iff for all P projective hom(P, -) is exact. In particular, after having fixed P, we have a genuine sequence of abelian groups, and the usual proof works</p>",
        "id": 254404978,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1632331378
    },
    {
        "content": "<p>And one can lift along epi, so it's better than usual yoneda</p>",
        "id": 254405151,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1632331453
    },
    {
        "content": "<p>Aside. I'm quite happy with how this looks:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"bp\">ùíú</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">category</span> <span class=\"bp\">ùíú</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">abelian</span> <span class=\"bp\">ùíú</span><span class=\"o\">]</span>\n\n<span class=\"kn\">local</span> <span class=\"kd\">notation</span> <span class=\"bp\">`</span><span class=\"n\">kernel_map</span><span class=\"bp\">`</span>   <span class=\"o\">:=</span> <span class=\"n\">kernel.map</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span>\n<span class=\"kn\">local</span> <span class=\"kd\">notation</span> <span class=\"bp\">`</span><span class=\"n\">cokernel_map</span><span class=\"bp\">`</span> <span class=\"o\">:=</span> <span class=\"n\">cokernel.map</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">mk_of_short_exact_sequence_hom</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">short_exact_sequence</span> <span class=\"bp\">ùíú</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">‚ü∂</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">snake_diagram</span> <span class=\"bp\">‚•§</span> <span class=\"bp\">ùíú</span> <span class=\"o\">:=</span>\n<span class=\"n\">mk_functor</span>\n<span class=\"c\">/-</span><span class=\"cm\"> == Passing in the matrix of objects first, to make Lean happy == -/</span>\n<span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"n\">kernel</span> <span class=\"n\">f.1</span><span class=\"o\">,</span> <span class=\"n\">kernel</span> <span class=\"n\">f.2</span><span class=\"o\">,</span> <span class=\"n\">kernel</span> <span class=\"n\">f.3</span><span class=\"o\">],</span>\n  <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"n\">A.1</span><span class=\"o\">,</span> <span class=\"n\">A.2</span><span class=\"o\">,</span> <span class=\"n\">A.3</span><span class=\"o\">],</span>\n  <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"n\">B.1</span><span class=\"o\">,</span> <span class=\"n\">B.2</span><span class=\"o\">,</span> <span class=\"n\">B.3</span><span class=\"o\">],</span>\n  <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"n\">cokernel</span> <span class=\"n\">f.1</span><span class=\"o\">,</span> <span class=\"n\">cokernel</span> <span class=\"n\">f.2</span><span class=\"o\">,</span> <span class=\"n\">cokernel</span> <span class=\"n\">f.3</span><span class=\"o\">]]</span>\n<span class=\"c\">/-</span><span class=\"cm\"> == All the morphisms in the diagram == -/</span>\n  <span class=\"c\">/-</span><span class=\"cm\"> ker f.1 -/</span>   <span class=\"o\">(</span><span class=\"n\">kernel_map</span> <span class=\"n\">f.sq1</span><span class=\"o\">)</span>   <span class=\"c\">/-</span><span class=\"cm\"> ker f.2 -/</span>   <span class=\"o\">(</span><span class=\"n\">kernel_map</span> <span class=\"n\">f.sq2</span><span class=\"o\">)</span>   <span class=\"c\">/-</span><span class=\"cm\"> ker f.3 -/</span>\n  <span class=\"o\">(</span><span class=\"n\">kernel.Œπ</span> <span class=\"n\">_</span><span class=\"o\">)</span>                         <span class=\"o\">(</span><span class=\"n\">kernel.Œπ</span> <span class=\"n\">_</span><span class=\"o\">)</span>                         <span class=\"o\">(</span><span class=\"n\">kernel.Œπ</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n  <span class=\"c\">/-</span><span class=\"cm\">   A.1   -/</span>          <span class=\"n\">A.f</span>           <span class=\"c\">/-</span><span class=\"cm\">   A.2   -/</span>          <span class=\"n\">A.g</span>           <span class=\"c\">/-</span><span class=\"cm\">   A.3   -/</span>\n       <span class=\"n\">f.1</span>                                  <span class=\"n\">f.2</span>                                  <span class=\"n\">f.3</span>\n  <span class=\"c\">/-</span><span class=\"cm\">   B.1   -/</span>          <span class=\"n\">B.f</span>           <span class=\"c\">/-</span><span class=\"cm\">   B.2   -/</span>          <span class=\"n\">B.g</span>           <span class=\"c\">/-</span><span class=\"cm\">   B.3   -/</span>\n  <span class=\"o\">(</span><span class=\"n\">cokernel.œÄ</span> <span class=\"n\">_</span><span class=\"o\">)</span>                       <span class=\"o\">(</span><span class=\"n\">cokernel.œÄ</span> <span class=\"n\">_</span><span class=\"o\">)</span>                       <span class=\"o\">(</span><span class=\"n\">cokernel.œÄ</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n  <span class=\"c\">/-</span><span class=\"cm\"> coker f.1 -/</span> <span class=\"o\">(</span><span class=\"n\">cokernel_map</span> <span class=\"n\">f.sq1</span><span class=\"o\">)</span> <span class=\"c\">/-</span><span class=\"cm\"> coker f.2 -/</span> <span class=\"o\">(</span><span class=\"n\">cokernel_map</span> <span class=\"n\">f.sq2</span><span class=\"o\">)</span> <span class=\"c\">/-</span><span class=\"cm\"> coker f.3 -/</span>\n<span class=\"c\">/-</span><span class=\"cm\"> == Prove that the squares commute == -/</span>\n<span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">delta</span> <span class=\"n\">kernel.map</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">kernel.lift_Œπ</span><span class=\"o\">]</span> <span class=\"o\">})</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">delta</span> <span class=\"n\">kernel.map</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">kernel.lift_Œπ</span><span class=\"o\">]</span> <span class=\"o\">})</span>\n<span class=\"n\">f.sq1</span> <span class=\"n\">f.sq2</span>\n<span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">delta</span> <span class=\"n\">cokernel.map</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">cokernel.œÄ_desc</span><span class=\"o\">]</span> <span class=\"o\">})</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">delta</span> <span class=\"n\">cokernel.map</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">cokernel.œÄ_desc</span><span class=\"o\">]</span> <span class=\"o\">})</span>\n</code></pre></div>",
        "id": 254405247,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1632331492
    },
    {
        "content": "<p>Very nice!</p>",
        "id": 254405625,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1632331651
    },
    {
        "content": "<p>I'll work on constructing <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Œ¥</mi></mrow><annotation encoding=\"application/x-tex\">\\delta</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03785em;\">Œ¥</span></span></span></span> this afternoon.</p>",
        "id": 254416389,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1632335789
    },
    {
        "content": "<p>I've added a general skeleton for the construction of delta here:<br>\n<a href=\"https://github.com/leanprover-community/lean-liquid/blob/b87355041bf779b20e4177b4300d19a7aff0ddf6/src/for_mathlib/snake_lemma.lean#L668\">https://github.com/leanprover-community/lean-liquid/blob/b87355041bf779b20e4177b4300d19a7aff0ddf6/src/for_mathlib/snake_lemma.lean#L668</a></p>\n<p>I'm fairly sure this definition is correct, but a second pair of eyes would be helpful :)</p>",
        "id": 254442995,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1632346472
    },
    {
        "content": "<p>I'll take a look once I've had breakfast (-;</p>",
        "id": 254478494,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1632371020
    },
    {
        "content": "<p>I proved one of the main maps was an isomorphism, so I'm more confident now that it's correct ;)</p>",
        "id": 254478579,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1632371093
    },
    {
        "content": "<p>I am proving <code>row_exact‚ÇÉ</code>.</p>",
        "id": 254536612,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1632404429
    },
    {
        "content": "<p><code>row_exact‚ÇÉ</code> is <code>sorry</code> free.</p>\n<p>Some random comments:</p>\n<ul>\n<li>this is the first place where <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.abelian.pseudoelement.sub_of_eq_image\">docs#category_theory.abelian.pseudoelement.sub_of_eq_image</a> is used in this file. Everything worked extremely well, exactly as with pen and paper. I think this is very promising, since <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.abelian.pseudoelement.sub_of_eq_image\">docs#category_theory.abelian.pseudoelement.sub_of_eq_image</a> replace the difference of pseudoelements, that can not be done in general. So it's possible that even for <code>Œ¥</code> the proof will be as the classical one.</li>\n<li>I did</li>\n</ul>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">‚Üê</span> <span class=\"n\">abelian.pseudoelement.comp_apply</span><span class=\"o\">,</span> <span class=\"bp\">‚Üê</span> <span class=\"n\">D.map_comp</span><span class=\"o\">,</span> <span class=\"n\">map_eq</span> <span class=\"n\">hD</span> <span class=\"o\">((</span><span class=\"n\">hom</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">‚â´</span> <span class=\"o\">(</span><span class=\"n\">hom</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">))</span> <span class=\"o\">((</span><span class=\"n\">hom</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">‚â´</span> <span class=\"o\">(</span><span class=\"n\">hom</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)),</span>\n      <span class=\"n\">D.map_comp</span><span class=\"o\">,</span> <span class=\"n\">abelian.pseudoelement.comp_apply</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>or something similar several time, and it seems that Adam had to do to the same. Maybe it's reasonable to write a tactic for that, but I have no idea if it's worth the effort.</p>",
        "id": 254557867,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1632412088
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">riccardos_tactic</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">unit</span> <span class=\"o\">:=</span>\n<span class=\"bp\">`</span><span class=\"o\">[</span><span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">‚Üê</span> <span class=\"n\">abelian.pseudoelement.comp_apply</span><span class=\"o\">,</span> <span class=\"bp\">‚Üê</span> <span class=\"n\">D.map_comp</span><span class=\"o\">,</span> <span class=\"n\">map_eq</span> <span class=\"n\">hD</span> <span class=\"o\">((</span><span class=\"n\">hom</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">‚â´</span> <span class=\"o\">(</span><span class=\"n\">hom</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">))</span> <span class=\"o\">((</span><span class=\"n\">hom</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">‚â´</span> <span class=\"o\">(</span><span class=\"n\">hom</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)),</span>\n      <span class=\"n\">D.map_comp</span><span class=\"o\">,</span> <span class=\"n\">abelian.pseudoelement.comp_apply</span><span class=\"o\">]]</span>\n</code></pre></div>",
        "id": 254558698,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1632412431
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130384\">@Riccardo Brasca</span> Voila: <span aria-label=\"this\" class=\"emoji emoji-1f446\" role=\"img\" title=\"this\">:this:</span> is your tactic</p>",
        "id": 254558777,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1632412447
    },
    {
        "content": "<p>Oh, that was fast!</p>",
        "id": 254558985,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1632412528
    },
    {
        "content": "<p>Mmh, sometimes we need it for the composition of three morphisms rather than two, and we also need to specify some <code>_</code>... it doesn't matter, copy/paste is perfectly fine.</p>",
        "id": 254559344,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1632412650
    },
    {
        "content": "<p>BTW, since we are in a \"snake lemma mood\", do we need also the very first and very last element of the sequence?</p>",
        "id": 254559425,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1632412681
    },
    {
        "content": "<p>I mean, using the terminology in <a href=\"https://en.wikipedia.org/wiki/Snake_lemma\">wikipedia</a>, the kernel of the first map of the snake is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ker</mi><mo>‚Å°</mo><mo stretchy=\"false\">(</mo><mi>f</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\ker(f)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\">ker</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mclose\">)</span></span></span></span>, and the cokernel of the last one is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mrow><mi mathvariant=\"normal\">c</mi><mi mathvariant=\"normal\">o</mi><mi mathvariant=\"normal\">k</mi><mi mathvariant=\"normal\">e</mi><mi mathvariant=\"normal\">r</mi></mrow><mo stretchy=\"false\">(</mo><msup><mi>g</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">‚Ä≤</mo></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\mathrm{coker}(g&#x27;)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.001892em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">coker</span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.751892em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">‚Ä≤</span></span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>.</p>",
        "id": 254559625,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1632412742
    },
    {
        "content": "<p>So we get a 8 terms exact sequence (plus zeros at the beginning and at the end).</p>",
        "id": 254559689,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1632412765
    },
    {
        "content": "<p>Do we have 8 term exact sequences in mathlib or just short exact sequences and long exact sequences?</p>",
        "id": 254560135,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1632412911
    },
    {
        "content": "<p>I think we only have <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.exact\">docs#category_theory.exact</a>, that is about two composable morphisms</p>",
        "id": 254560391,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1632413019
    },
    {
        "content": "<p>Johan (or someone else) defined</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">short_exact_sequence</span> <span class=\"o\">[</span><span class=\"n\">has_images</span> <span class=\"bp\">ùíû</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_zero_morphisms</span> <span class=\"bp\">ùíû</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_kernels</span> <span class=\"bp\">ùíû</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">fst</span> <span class=\"n\">snd</span> <span class=\"n\">trd</span> <span class=\"o\">:</span> <span class=\"bp\">ùíû</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">fst</span> <span class=\"bp\">‚ü∂</span> <span class=\"n\">snd</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">snd</span> <span class=\"bp\">‚ü∂</span> <span class=\"n\">trd</span><span class=\"o\">)</span>\n<span class=\"o\">[</span><span class=\"n\">mono'</span>  <span class=\"o\">:</span> <span class=\"n\">mono</span> <span class=\"n\">f</span><span class=\"o\">]</span>\n<span class=\"o\">[</span><span class=\"n\">epi'</span>   <span class=\"o\">:</span> <span class=\"n\">epi</span> <span class=\"n\">g</span><span class=\"o\">]</span>\n<span class=\"o\">[</span><span class=\"n\">exact'</span> <span class=\"o\">:</span> <span class=\"n\">exact</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>in LTE</p>",
        "id": 254560518,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1632413055
    },
    {
        "content": "<p>I had imagined that the snake lemma was going to be 6 separate statements of the form \"I'm exact here\"</p>",
        "id": 254562773,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1632413955
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/267928-condensed-mathematics/topic/snake.20lemma/near/254562773\">said</a>:</p>\n<blockquote>\n<p>I had imagined that the snake lemma was going to be 6 separate statements of the form \"I'm exact here\"</p>\n</blockquote>\n<p>it probably will be.</p>",
        "id": 254562989,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1632414029
    },
    {
        "content": "<p>I finished off the last few sorry's needed for the definition of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Œ¥</mi></mrow><annotation encoding=\"application/x-tex\">\\delta</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03785em;\">Œ¥</span></span></span></span>. Now we can think about the actual proof of the snake lemma ;)</p>",
        "id": 254577484,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1632419929
    },
    {
        "content": "<p>One half of the snake lemma is now done in the following form:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">exact_to_Œ¥</span> <span class=\"o\">:</span> <span class=\"n\">exact</span> <span class=\"o\">((</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">‚ü∂</span><span class=\"o\">[</span><span class=\"n\">D</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">))</span> <span class=\"n\">hD.Œ¥</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span>\n</code></pre></div>",
        "id": 254608745,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1632432650
    },
    {
        "content": "<p>The other half is now done as well:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">exact_to_Œ¥</span> <span class=\"o\">:</span> <span class=\"n\">exact</span> <span class=\"o\">((</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">‚ü∂</span><span class=\"o\">[</span><span class=\"n\">D</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">))</span> <span class=\"n\">hD.Œ¥</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">exact_from_Œ¥</span> <span class=\"o\">:</span> <span class=\"n\">exact</span> <span class=\"n\">hD.Œ¥</span> <span class=\"o\">((</span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"bp\">‚ü∂</span><span class=\"o\">[</span><span class=\"n\">D</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span>\n</code></pre></div>",
        "id": 254632422,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1632446389
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> Wow, amazing work!</p>",
        "id": 254643110,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1632452535
    },
    {
        "content": "<p>Thanks! I was a bit careless with nonterminal simps, and many of the proofs can probably be golfed a bit (and hopefully sped up as well). I'll try to do a bit of cleanup soon.</p>",
        "id": 254644336,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1632453618
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> maybe we should ignore that cleanup for now</p>",
        "id": 254645889,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1632455081
    },
    {
        "content": "<p>Yesterday I discovered the salamander lemma: <a href=\"https://ncatlab.org/nlab/show/salamander+lemma\">https://ncatlab.org/nlab/show/salamander+lemma</a></p>",
        "id": 254645928,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1632455115
    },
    {
        "content": "<p>Mulling over it yesterday and tonight, I'm now thinking we could have a side project that puts a big fat <strong>E</strong> back in LTE: develop a DSL for double complex diagram chases, together with an integration into the widget framework.</p>",
        "id": 254646026,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1632455191
    },
    {
        "content": "<p>It would use some sort of proof-by-reflection technique (if I understand correctly what that means)</p>",
        "id": 254646061,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1632455228
    },
    {
        "content": "<p>Together with integration in the widget framework, this could create pretty slick pointy-clicky proofs that also look good. And they might be quite fast as well.</p>",
        "id": 254646102,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1632455279
    },
    {
        "content": "<p>Salamander = more evolved snake?</p>",
        "id": 254646211,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1632455355
    },
    {
        "content": "<p>And it would be a really nice addition to mathlib, that could be used to create pretty proofs of other \"double complex\" lemmas as well, like the four lemmas, five lemma, 3x3 lemma, LES for a SES of chain complexes.</p>",
        "id": 254646230,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1632455378
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/267928-condensed-mathematics/topic/snake.20lemma/near/254646211\">said</a>:</p>\n<blockquote>\n<p>Salamander = more evolved snake?</p>\n</blockquote>\n<p>More like: small snake. It provides a toolkit of small building blocks that you assemble to prove things like the snake lemma.</p>",
        "id": 254646287,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1632455408
    },
    {
        "content": "<p>Ah I see. I'm about to go to sleep... I'll have to look tomorrow. Integrating these arguments with widgets would be amazing!</p>",
        "id": 254646500,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1632455582
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"284160\">@Eric Rodriguez</span></p>",
        "id": 254657238,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1632464725
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> Amazing!!</p>",
        "id": 254669116,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1632472068
    },
    {
        "content": "<p>Can someone give me a brief explanation of how a diagram chase (especially a \"double complex\" one) works? I know very basic category theory (not even limits yet :[) but have been wanting to learn it for a while anyways, and from brief googling it seems to be mostly using properties of monos/epis</p>",
        "id": 254679445,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1632477665
    },
    {
        "content": "<p>Yeah, that's right. But in this DSL, that would all be hidden away.</p>",
        "id": 254680820,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1632478364
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> <span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> <span class=\"user-mention\" data-user-id=\"130384\">@Riccardo Brasca</span> Wolfang Soergel just pointed out to me that the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Œ¥</mi></mrow><annotation encoding=\"application/x-tex\">\\delta</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03785em;\">Œ¥</span></span></span></span> in the snake lemma is the <em>unique</em> map from <code>ker c</code> to <code>coker a</code> that is compatible with the natural surjective maps <code>ker diag -&gt; ker c</code> and <code>ker diag -&gt; coker a</code>, where <code>diag</code> is the diagonal map <code>B -&gt; C'</code> in the second square of the snake diagram.</p>",
        "id": 254681009,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1632478472
    },
    {
        "content": "<p>So you cannot choose <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>‚àí</mo><mi>Œ¥</mi></mrow><annotation encoding=\"application/x-tex\">-\\delta</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.77777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">‚àí</span><span class=\"mord mathnormal\" style=\"margin-right:0.03785em;\">Œ¥</span></span></span></span>.</p>",
        "id": 254681024,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1632478483
    },
    {
        "content": "<p>This universal property will certainly be helpful if we want to prove naturality of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Œ¥</mi></mrow><annotation encoding=\"application/x-tex\">\\delta</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03785em;\">Œ¥</span></span></span></span> at some point.</p>",
        "id": 254681055,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1632478501
    },
    {
        "content": "<p>A simple example with both a words and a picture is in the <a href=\"https://738.f21.matthewrobertballard.com/notes/2021_09_09/#adapted-objects\">notes</a> from my current class. There it is just proving a retract of an exact complex is exact. </p>\n<p>The punchline is ‚Äútake an element and push it around‚Äù</p>",
        "id": 254681137,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1632478549
    },
    {
        "content": "<p>but note that this picture is happening in Mod(R) or implicitly using the Freyd-Mitchell embedding theorem and not really using properties of monic/epics in the categorical sense, otherwise you can't perform the step \"there exists <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>b</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">‚Ä≤</mo></msup></mrow><annotation encoding=\"application/x-tex\">b&#x27;</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.751892em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">b</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.751892em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">‚Ä≤</span></span></span></span></span></span></span></span></span></span></span></span> sent to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span>\"</p>",
        "id": 254682347,
        "sender_full_name": "Reid Barton",
        "timestamp": 1632479206
    },
    {
        "content": "<p>Yes of course</p>",
        "id": 254682565,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1632479324
    },
    {
        "content": "<p>If you want to be completely precise, you draw some diagrams of Hom spaces instead and really use universal properties.</p>",
        "id": 254682757,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1632479431
    },
    {
        "content": "<p>Perhaps the biggest caveat is typos <span aria-label=\"blushing\" class=\"emoji emoji-1f633\" role=\"img\" title=\"blushing\">:blushing:</span></p>",
        "id": 254682806,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1632479464
    },
    {
        "content": "<p>Ah yes, we should prove uniqueness. And it's probably not that hard!</p>",
        "id": 254696078,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1632486932
    },
    {
        "content": "<p>By the way I am now in love with the salamander lemma!</p>",
        "id": 254696109,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1632486951
    },
    {
        "content": "<p>I envy you. I've been trying to fall in love with this lemma for years and never managed. I'm always excited each time I start reading that webpage but this excitement doesn't survive until the end of the page.</p>",
        "id": 254697526,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1632487649
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> It took a while for me to click as well.</p>",
        "id": 254697984,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1632487882
    },
    {
        "content": "<p>Also, it's not clear how to do this in Lean. We need really good data structures to manage these diagrams.</p>",
        "id": 254698021,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1632487901
    },
    {
        "content": "<p>That's why I think a proof by reflection might help.</p>",
        "id": 254698046,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1632487912
    },
    {
        "content": "<p>Well, maybe \"in love\" is a little bit too much...<br>\nIt's true that we should see in practice if deducing the snake lemma (for example) is really easy from the salamander or not, but at least it gives a general technique.</p>",
        "id": 254698973,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1632488356
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/267928-condensed-mathematics/topic/snake.20lemma/near/254698021\">said</a>:</p>\n<blockquote>\n<p>Also, it's not clear how to do this in Lean. We need really good data structures to manage these diagrams.</p>\n</blockquote>\n<p>We would also need a nice way to go between e.g. <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>c</mi><mi>o</mi><mi>k</mi><mi>e</mi><mi>r</mi><mi>n</mi><mi>e</mi><mi>l</mi><mo stretchy=\"false\">(</mo><mn>0</mn><mo>‚Üí</mo><mi>M</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">cokernel(0 \\to M)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">co</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">er</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mopen\">(</span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">‚Üí</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mclose\">)</span></span></span></span>, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi><mi>e</mi><mi>r</mi><mi>n</mi><mi>e</mi><mi>l</mi><mo stretchy=\"false\">(</mo><mi>M</mi><mo>‚Üí</mo><mn>0</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">kernel(M \\to 0)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">er</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">‚Üí</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">0</span><span class=\"mclose\">)</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> and similarly silly things. I think this will be one of the main annoying points in deducing the snake lemma from the salamander lemma</p>",
        "id": 254702014,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1632489518
    },
    {
        "content": "<p>Right, but such a DSL could hopefully take care of that</p>",
        "id": 254702088,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1632489548
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306577\">@Matthew Ballard</span> this is the most accurate thing I have ever seen (from your webpage)</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>Learning Outcomes\n\nAfter successful completion of this course, you will be able to:\n\n    Localize abelian categories for fun and profit\n    Draw confusing diagrams that claim to explain the octohedral axiom\n    Day dream about stable ‚àû\\infty‚àû-categories\n</code></pre></div>",
        "id": 254703247,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1632490017
    },
    {
        "content": "<p>Even that has a typo: <del>abelian</del> triangulated</p>",
        "id": 254703358,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1632490066
    },
    {
        "content": "<p>Also, it's the octahedral axiom. <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 254714516,
        "sender_full_name": "Reid Barton",
        "timestamp": 1632494228
    },
    {
        "content": "<blockquote>\n<p>Finally, we ignore TR4) until we actually need it (as is tradition).</p>\n</blockquote>",
        "id": 254714851,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1632494342
    },
    {
        "content": "<p>Though, Neeman's presentation of it is great.</p>",
        "id": 254715080,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1632494425
    },
    {
        "content": "<p>Perhaps to get the topic back on the rails, I would like to say I am interested in embedding commutative diagrams in some efficient data structure that can be, perhaps, be automated over. Almost any check of this type in practice is a toucan-sam type follow your nose process.</p>",
        "id": 254716112,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1632494868
    },
    {
        "content": "<p>I also imagine that anything developed would not be limited to bi-complexes but would be applicable to higher dimensional versions.</p>",
        "id": 254716359,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1632494958
    },
    {
        "content": "<p>The good news is that we now have <a href=\"https://leanprover-community.github.io/mathlib_docs/find/prefunctor\">docs#prefunctor</a> which we can use to model diagrams</p>",
        "id": 254717053,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1632495232
    },
    {
        "content": "<p>The most naive thing I can think of is picking a node and submodule of that component and pushing it around via images and inverse images.</p>",
        "id": 254717465,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1632495392
    },
    {
        "content": "<p>We would also need some structure that should let us label which pairs of composable morphisms in the diagram are exact.</p>",
        "id": 254717601,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1632495453
    },
    {
        "content": "<p>I wonder whether there is some decidable theory lurking around here...</p>",
        "id": 254719468,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1632496090
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/267928-condensed-mathematics/topic/snake.20lemma/near/254717601\">said</a>:</p>\n<blockquote>\n<p>We would also need some structure that should let us label which pairs of composable morphisms in the diagram are exact.</p>\n</blockquote>\n<p>Right. The question can kinda be rephrased as: pass to Grothendieck group and see if this push/pull correspondence is actually a function</p>",
        "id": 254932046,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1632663428
    },
    {
        "content": "<p>Turning the salamander lemma into a nice proof-method is going to be a serious side project. I very much think that it should be done. It would be a beautiful spin-off of LTE.</p>",
        "id": 255034559,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1632743582
    },
    {
        "content": "<p>But I'm not sure LTE should wait for that to finish.</p>",
        "id": 255034578,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1632743591
    },
    {
        "content": "<p>I suggest we continue further discussion of the salamander project in this thread: <a href=\"#narrow/stream/267928-condensed-mathematics/topic/salamander.20tactic\">https://leanprover.zulipchat.com/#narrow/stream/267928-condensed-mathematics/topic/salamander.20tactic</a></p>",
        "id": 255034928,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1632743763
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130384\">@Riccardo Brasca</span> Did you prove that <code>(0,0) ‚ü∂[D] (0,1)</code> is a mono if <code>(1,0) ‚ü∂[D] (1,1)</code> is a mono?</p>",
        "id": 255038675,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1632745551
    },
    {
        "content": "<p>Not yet, I can do it today. (The most general statement is, I think, that there is a mono <code>ker((1,0) ‚ü∂[D] (1,1)) ‚ü∂[D] (0,0)</code>.)</p>",
        "id": 255039268,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1632745842
    },
    {
        "content": "<p>I pushed a bit more horseshoe stuff.</p>",
        "id": 255043053,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1632747567
    },
    {
        "content": "<p>One bit of the construction would be to get a short exact sequence of kernels, if the snake diagram has the right shape: i.e., the first \"actual\" row is short exact, and the first \"actual\" vertical map is an epi (so that the cokernel vanishes, and <code>Œ¥</code> becomes the zero map. I sketched this construction, but it still has some sorries.</p>",
        "id": 255043354,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1632747666
    },
    {
        "content": "<p>I've proved</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">ker_row‚ÇÅ_to_row‚ÇÇ</span> <span class=\"o\">(</span><span class=\"n\">hD</span> <span class=\"o\">:</span> <span class=\"n\">is_snake_input</span> <span class=\"n\">D</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">kernel.Œπ</span> <span class=\"o\">((</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"bp\">‚ü∂</span><span class=\"o\">[</span><span class=\"n\">D</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">1</span><span class=\"o\">)))</span> <span class=\"bp\">‚â´</span> <span class=\"o\">((</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"bp\">‚ü∂</span><span class=\"o\">[</span><span class=\"n\">D</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"mi\">0</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n</code></pre></div>\n<p>From here it should be easy to define</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">long_row‚ÇÄ</span> <span class=\"o\">(</span><span class=\"n\">hD</span> <span class=\"o\">:</span> <span class=\"n\">is_snake_input</span> <span class=\"n\">D</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">kernel</span> <span class=\"o\">((</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"bp\">‚ü∂</span><span class=\"o\">[</span><span class=\"n\">D</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"bp\">‚ü∂</span> <span class=\"n\">D.obj</span> <span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>but I am little bit lost in the library. If someone wants to contribute please go ahead. The proof of the exactness should be easy using pseudoelements.</p>",
        "id": 255059387,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1632753701
    },
    {
        "content": "<p>To construct this, you probably need to identify <code>D.obj (0,0)</code> with <code>ker ((1,0) \\hom[D] (2,0))</code> and compose that with <code>ker.map</code> or <code>ker.\\iota</code> and <code>ker.lift</code></p>",
        "id": 255059919,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1632753853
    },
    {
        "content": "<p>I can construct this later today</p>",
        "id": 255059951,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1632753862
    },
    {
        "content": "<p>Yes, the math is clear. I just don't know which is the best path in Lean. Using subobjects? There is <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.abelian.is_limit_image'\">docs#category_theory.abelian.is_limit_image'</a> that probably says that the image has the universal property of the kernel, but I don't know what a fork is :)</p>",
        "id": 255060224,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1632753955
    },
    {
        "content": "<p>Oh, what I mean is that I think the path I sketched above is the best path ;)</p>",
        "id": 255061034,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1632754223
    },
    {
        "content": "<p>I really don't like subobjects, but maybe I just haven't suffered enough in trying to use them</p>",
        "id": 255061106,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1632754249
    },
    {
        "content": "<p>The point is that the universal property of the kernel lets you define a map from <code>D.obj (0,0)</code> to the kernel of <code>(1,0) -&gt; (2,0)</code>, and pseudoelements can hhelp you prove that this map is an isomorphism.</p>",
        "id": 255061504,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1632754360
    },
    {
        "content": "<p>I'm asking because I don't see in mathlib that <code>ker g</code> is isomorphic to <code>image f</code> if <code>exact f g</code> (at least, not explicitly), and usually when such a basic fact is missing is just because it is formulated in a more general way.</p>",
        "id": 255061581,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1632754386
    },
    {
        "content": "<p>Ah, I see what you mean, proving directly that this map is an iso!</p>",
        "id": 255061694,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1632754429
    },
    {
        "content": "<p>Take a look for example at what I did in the other corner of the diagram :)<br>\n<a href=\"https://github.com/leanprover-community/lean-liquid/blob/f7435bcd76bb16f1a2748830b59f7999860d35d0/src/for_mathlib/snake_lemma.lean#L859\">https://github.com/leanprover-community/lean-liquid/blob/f7435bcd76bb16f1a2748830b59f7999860d35d0/src/for_mathlib/snake_lemma.lean#L859</a></p>",
        "id": 255061847,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1632754470
    },
    {
        "content": "<p>So exactness should follow immediately, nice!</p>",
        "id": 255061864,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1632754475
    },
    {
        "content": "<p>(I have to teach now, but I'll be back later)</p>",
        "id": 255061870,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1632754479
    },
    {
        "content": "<p>I have to stop for today <span aria-label=\"unamused\" class=\"emoji emoji-1f612\" role=\"img\" title=\"unamused\">:unamused:</span></p>",
        "id": 255079135,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1632760622
    },
    {
        "content": "<p>Something's broken in <code>for_mathlib/snake_lemma.lean</code>...</p>",
        "id": 255079493,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1632760749
    },
    {
        "content": "<p>Oh, nevemind. I just had to get the correct mathlib version</p>",
        "id": 255080389,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1632761082
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130384\">@Riccardo Brasca</span> I replaced <code>epi_iff_exact_zero_right'</code> with <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.abelian.tfae_epi\">docs#category_theory.abelian.tfae_epi</a> in the epi proof for <code>kernel_sequence</code>, which fixed the error in <code>for_mathlib/snake_lemma</code>.</p>",
        "id": 255092066,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1632765646
    },
    {
        "content": "<p>Merci. I didn't know about that <code>tfae_epi</code></p>",
        "id": 255093096,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1632765969
    },
    {
        "content": "<p>Me neither! I went to prove it for a mathlib PR and there it was!</p>",
        "id": 255094456,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1632766477
    },
    {
        "content": "<p>the same file also has the useful <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.abelian.exact_cokernel\">docs#category_theory.abelian.exact_cokernel</a> but it's missing the analogue for kernels.</p>",
        "id": 255094657,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1632766557
    },
    {
        "content": "<p>I've added</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">ker_row‚ÇÅ_to_top_left</span> <span class=\"o\">(</span><span class=\"n\">hD</span> <span class=\"o\">:</span> <span class=\"n\">is_snake_input</span> <span class=\"n\">D</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">kernel</span> <span class=\"o\">((</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"bp\">‚ü∂</span><span class=\"o\">[</span><span class=\"n\">D</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"bp\">‚ü∂</span> <span class=\"n\">D.obj</span> <span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">letI</span> <span class=\"o\">:=</span> <span class=\"n\">hD.col_mono</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">limits.kernel.lift</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">ker_row‚ÇÅ_to_row‚ÇÇ</span> <span class=\"n\">hD</span><span class=\"o\">))</span> <span class=\"bp\">‚â´</span>\n    <span class=\"o\">(</span><span class=\"n\">limits.kernel.lift</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(((</span><span class=\"n\">abelian.exact_iff</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"o\">(</span><span class=\"n\">hD.col_exact‚ÇÅ</span> <span class=\"mi\">0</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"o\">))</span> <span class=\"bp\">‚â´</span>\n    <span class=\"n\">inv</span> <span class=\"o\">(</span><span class=\"n\">abelian.images.factor_thru_image</span> <span class=\"o\">((</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"bp\">‚ü∂</span><span class=\"o\">[</span><span class=\"n\">D</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">0</span><span class=\"o\">)))</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>The map from the first kernel of the second row to the top left element.  This become zero when composed with <code>(0,0) ‚ü∂[D] (0,1)</code>, but to prove this I need</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">ker_row‚ÇÅ_to_top_left_comp_eq_Œπ</span> <span class=\"o\">(</span><span class=\"n\">hD</span> <span class=\"o\">:</span> <span class=\"n\">is_snake_input</span> <span class=\"n\">D</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ker_row‚ÇÅ_to_top_left</span> <span class=\"n\">hD</span> <span class=\"bp\">‚â´</span>\n  <span class=\"o\">((</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"bp\">‚ü∂</span><span class=\"o\">[</span><span class=\"n\">D</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">0</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"n\">kernel.Œπ</span> <span class=\"o\">((</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"bp\">‚ü∂</span><span class=\"o\">[</span><span class=\"n\">D</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">1</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>I am not sure the definition of <code>ker_row‚ÇÅ_to_top_left</code> is the best one, it goes through <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.abelian.images.is_iso_factor_thru_image\">docs#category_theory.abelian.images.is_iso_factor_thru_image</a> that complicates life a little. If someone wants to prove <code>ker_row‚ÇÅ_to_top_left_comp_eq_Œπ</code> (even changing <code>ker_row‚ÇÅ_to_top_left </code>) please go ahead. I will resume working on this in one or two hours.</p>",
        "id": 255191275,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1632823565
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/267928-condensed-mathematics/topic/snake.20lemma/near/255094657\">said</a>:</p>\n<blockquote>\n<p>the same file also has the useful <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.abelian.exact_cokernel\">docs#category_theory.abelian.exact_cokernel</a> but it's missing the analogue for kernels.</p>\n</blockquote>\n<p>The dual is <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.exact_kernel_Œπ\">docs#category_theory.exact_kernel_Œπ</a>, isn't it?</p>",
        "id": 255212503,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1632834332
    },
    {
        "content": "<p>Yes!</p>",
        "id": 255212906,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1632834498
    },
    {
        "content": "<p>I've extended the snake to the left: <code>ker_row‚ÇÅ_to_top_left: kernel ((1,0) ‚ü∂[D] (1,1))  ‚ü∂ D.obj (0,0)</code> is a mono, and <code>exact (ker_row‚ÇÅ_to_top_left hD) ((0,0) ‚ü∂[D] (0,1))</code>, in particular if <code>(1,0) ‚ü∂[D] (1,1)</code> is a mono then <code>(0,0) ‚ü∂[D] (0,1)</code> is a mono.</p>",
        "id": 255215208,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1632835431
    },
    {
        "content": "<p>The dual statement should have the same proof.</p>",
        "id": 255215371,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1632835484
    },
    {
        "content": "<p>It's not as readable as I would like, but it works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">six_term_exact_seq</span> <span class=\"o\">(</span><span class=\"n\">hD</span> <span class=\"o\">:</span> <span class=\"n\">is_snake_input</span> <span class=\"n\">D</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">exact_seq</span> <span class=\"bp\">ùíú</span> <span class=\"o\">[(</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"bp\">‚ü∂</span><span class=\"o\">[</span><span class=\"n\">D</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"mi\">1</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">‚ü∂</span><span class=\"o\">[</span><span class=\"n\">D</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">),</span> <span class=\"n\">hD.Œ¥</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"bp\">‚ü∂</span><span class=\"o\">[</span><span class=\"n\">D</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"mi\">1</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">‚ü∂</span><span class=\"o\">[</span><span class=\"n\">D</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">)]</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">refine</span> <span class=\"n\">exact_seq.cons</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">hD.row_exact‚ÇÄ</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">refine</span> <span class=\"n\">exact_seq.cons</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">hD.exact_to_Œ¥</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">refine</span> <span class=\"n\">exact_seq.cons</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">hD.exact_from_Œ¥</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">refine</span> <span class=\"n\">exact_seq.cons</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">hD.row_exact‚ÇÉ</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">refine</span> <span class=\"n\">exact_seq.single</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 255416611,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1632928418
    },
    {
        "content": "<p>I think it looks quite good actually!</p>",
        "id": 255425564,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1632931493
    },
    {
        "content": "<p>We could develop some API for <code>exact_seq</code>similar to all the stuff we have for <code>tfae</code>.</p>",
        "id": 255425651,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1632931525
    },
    {
        "content": "<p>I just wrote a <code>congr</code> lemma for it.</p>",
        "id": 255430093,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1632933148
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">six_term_exact_seq</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">category</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">abelian</span> <span class=\"n\">C</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñï</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">chain_complex</span> <span class=\"o\">(</span><span class=\"n\">short_exact_sequence</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"n\">‚Ñï</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">exact_seq</span> <span class=\"n\">C</span> <span class=\"o\">[</span>\n    <span class=\"o\">(</span><span class=\"n\">homology_functor</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"o\">((</span><span class=\"n\">Fst_Snd</span> <span class=\"n\">C</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">app</span> <span class=\"n\">A</span><span class=\"o\">),</span> <span class=\"c1\">-- H‚Åø‚Å∫¬π(A‚ÇÅ) ‚ü∂ H‚Åø‚Å∫¬π(A‚ÇÇ)</span>\n    <span class=\"o\">(</span><span class=\"n\">homology_functor</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"o\">((</span><span class=\"n\">Snd_Trd</span> <span class=\"n\">C</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">app</span> <span class=\"n\">A</span><span class=\"o\">),</span> <span class=\"c1\">-- H‚Åø‚Å∫¬π(A‚ÇÇ) ‚ü∂ H‚Åø‚Å∫¬π(A‚ÇÉ)</span>\n    <span class=\"n\">Œ¥</span> <span class=\"n\">n</span> <span class=\"n\">A</span><span class=\"o\">,</span>                                                <span class=\"c1\">-- H‚Åø‚Å∫¬π(A‚ÇÉ) ‚ü∂ H‚Åø(A‚ÇÅ)</span>\n    <span class=\"o\">(</span><span class=\"n\">homology_functor</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"o\">((</span><span class=\"n\">Fst_Snd</span> <span class=\"n\">C</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">app</span> <span class=\"n\">A</span><span class=\"o\">),</span>     <span class=\"c1\">-- H‚Åø(A‚ÇÅ)   ‚ü∂ H‚Åø(A‚ÇÇ)</span>\n    <span class=\"o\">(</span><span class=\"n\">homology_functor</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"o\">((</span><span class=\"n\">Snd_Trd</span> <span class=\"n\">C</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">app</span> <span class=\"n\">A</span><span class=\"o\">)</span>      <span class=\"c1\">-- H‚Åø(A‚ÇÅ)   ‚ü∂ H‚Åø(A‚ÇÉ)</span>\n  <span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">have</span> <span class=\"n\">key</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">snake_input</span> <span class=\"n\">n</span> <span class=\"n\">A</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"bp\">.</span><span class=\"n\">six_term_exact_seq</span><span class=\"o\">,</span>\n  <span class=\"n\">dsimp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">snake_input</span><span class=\"o\">,</span> <span class=\"n\">snake_diagram</span><span class=\"o\">,</span>\n    <span class=\"n\">snake_diagram.mk_functor''</span><span class=\"o\">,</span> <span class=\"n\">snake_diagram.mk_functor'</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">key</span><span class=\"o\">,</span>\n  <span class=\"n\">refine</span> <span class=\"n\">exact_seq.congr</span> <span class=\"n\">key</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">clear</span> <span class=\"n\">key</span><span class=\"o\">,</span>\n  <span class=\"n\">iterate</span> <span class=\"mi\">5</span> <span class=\"o\">{</span> <span class=\"n\">refine</span> <span class=\"n\">exact_seq.arrow_congr.cons</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">rotate</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"n\">exact_seq.arrow_congr.nil</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"n\">snake_diagram.mk_functor_map_f0</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"n\">snake_diagram.mk_functor_map_g0</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">refl</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"n\">snake_diagram.mk_functor_map_f3</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"n\">snake_diagram.mk_functor_map_g3</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 255431138,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1632933523
    },
    {
        "content": "<p>The six term exact sequence for a \"chain complex of short exact sequences\" = \"short exact sequence of chain complexes\".</p>",
        "id": 255431220,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1632933553
    },
    {
        "content": "<p>I've added <code>bottom_right_to_coker_row‚ÇÇ : D.obj (3, 2) ‚ü∂ cokernel ((2,1) ‚ü∂[D] (2,2))</code>, the last map in the \"long snake\". I don't think I will have time to work on it tomorrow, so if someone wants to prove that it is an epi and exactness in the last step please go ahead, The proofs should be similar to those of <code>ker_row‚ÇÅ_to_top_left_mono</code> and <code>long_row‚ÇÄ_exact</code>.</p>",
        "id": 255444359,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1632938360
    },
    {
        "content": "<p>Thanks!</p>",
        "id": 255444934,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1632938551
    },
    {
        "content": "<p>I've proved <code>long_row‚ÇÉ_exact</code>. So the snake is an exact sequence of 10 terms (the first and the last are <code>0</code>).</p>",
        "id": 255584055,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1633012227
    },
    {
        "content": "<p>So this</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">eight_term_exact_seq</span> <span class=\"o\">(</span><span class=\"n\">hD</span> <span class=\"o\">:</span> <span class=\"n\">is_snake_input</span> <span class=\"n\">D</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">exact_seq</span> <span class=\"bp\">ùíú</span> <span class=\"o\">[</span><span class=\"n\">hD.ker_row‚ÇÅ_to_top_left</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"bp\">‚ü∂</span><span class=\"o\">[</span><span class=\"n\">D</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"mi\">1</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">‚ü∂</span><span class=\"o\">[</span><span class=\"n\">D</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">),</span>\n  <span class=\"n\">hD.Œ¥</span><span class=\"o\">,</span>\n  <span class=\"o\">(</span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"bp\">‚ü∂</span><span class=\"o\">[</span><span class=\"n\">D</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"mi\">1</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">‚ü∂</span><span class=\"o\">[</span><span class=\"n\">D</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">),</span> <span class=\"n\">hD.bottom_right_to_coker_row‚ÇÇ</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">refine</span> <span class=\"n\">exact_seq.cons</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">hD.long_row‚ÇÄ_exact</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">refine</span> <span class=\"n\">exact_seq.cons</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">hD.row_exact‚ÇÄ</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">refine</span> <span class=\"n\">exact_seq.cons</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">hD.exact_to_Œ¥</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">refine</span> <span class=\"n\">exact_seq.cons</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">hD.exact_from_Œ¥</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">refine</span> <span class=\"n\">exact_seq.cons</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">hD.row_exact‚ÇÉ</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">refine</span> <span class=\"n\">exact_seq.cons</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">hD.long_row‚ÇÉ_exact</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">refine</span> <span class=\"n\">exact_seq.single</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>works well.  I tried to add the zero at the beginning, but Lean is not happy and wants <code>has_zero (arrow ùíú)</code>.</p>",
        "id": 255595934,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1633016484
    },
    {
        "content": "<p>I think if you pass in <code>(0 : 0 \\hom ??)</code> for the correct <code>??</code>, it will work (there is a coercion from morphisms to arrows)</p>",
        "id": 255596613,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1633016749
    },
    {
        "content": "<p>E.g.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">local</span> <span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"kd\">instance</span><span class=\"o\">]</span> <span class=\"n\">limits.has_zero_object.has_zero</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">eight_term_exact_seq</span> <span class=\"o\">(</span><span class=\"n\">hD</span> <span class=\"o\">:</span> <span class=\"n\">is_snake_input</span> <span class=\"n\">D</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">exact_seq</span> <span class=\"bp\">ùíú</span> <span class=\"o\">[</span>\n    <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">‚ü∂</span> <span class=\"n\">kernel</span> <span class=\"o\">((</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"bp\">‚ü∂</span><span class=\"o\">[</span><span class=\"n\">D</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">1</span><span class=\"o\">))),</span>\n    <span class=\"n\">hD.ker_row‚ÇÅ_to_top_left</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"bp\">‚ü∂</span><span class=\"o\">[</span><span class=\"n\">D</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"mi\">1</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">‚ü∂</span><span class=\"o\">[</span><span class=\"n\">D</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">),</span>\n    <span class=\"n\">hD.Œ¥</span><span class=\"o\">,</span>\n    <span class=\"o\">(</span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"bp\">‚ü∂</span><span class=\"o\">[</span><span class=\"n\">D</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"mi\">1</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">‚ü∂</span><span class=\"o\">[</span><span class=\"n\">D</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">),</span> <span class=\"n\">hD.bottom_right_to_coker_row‚ÇÇ</span><span class=\"o\">,</span>\n    <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">cokernel</span> <span class=\"o\">((</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">‚ü∂</span><span class=\"o\">[</span><span class=\"n\">D</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">))</span> <span class=\"bp\">‚ü∂</span> <span class=\"mi\">0</span><span class=\"o\">)]</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">  refine exact_seq.cons _ _ hD.long_row‚ÇÄ_exact _ _,</span>\n<span class=\"cm\">  refine exact_seq.cons _ _ hD.row_exact‚ÇÄ _ _,</span>\n<span class=\"cm\">  refine exact_seq.cons _ _ hD.exact_to_Œ¥ _ _,</span>\n<span class=\"cm\">  refine exact_seq.cons _ _ hD.exact_from_Œ¥ _ _,</span>\n<span class=\"cm\">  refine exact_seq.cons _ _ hD.row_exact‚ÇÉ _ _,</span>\n<span class=\"cm\">  refine exact_seq.cons _ _ hD.long_row‚ÇÉ_exact _ _,</span>\n<span class=\"cm\">  refine exact_seq.single _,</span>\n<span class=\"cm\">  -/</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 255597998,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1633017234
    },
    {
        "content": "<p>I added the zeros :) (and pushed)</p>",
        "id": 255599071,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1633017592
    },
    {
        "content": "<p>Nice!</p>",
        "id": 255600023,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1633017905
    },
    {
        "content": "<p>I don't see the difference with what I wrote, but your code works :)<br>\nWe now have <code>ten_term_exact_seq</code>, <code>eight_term_exact_seq</code>, and <code>six_term_exact_seq</code>.</p>",
        "id": 255663592,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1633043387
    },
    {
        "content": "<p>I added the <code>local [instance]</code> too :) That may have been missing?</p>",
        "id": 255663710,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1633043454
    },
    {
        "content": "<p>Maybe... it's time to go to bed for me</p>",
        "id": 255663894,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1633043578
    },
    {
        "content": "<p>Do we need naturality of the snake somewhere?</p>",
        "id": 256381883,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1633512219
    },
    {
        "content": "<p>I don't think so</p>",
        "id": 256381970,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1633512255
    },
    {
        "content": "<p>You know these 1-picture-proofs of Pythagoras? Like <a href=\"https://betterexplained.com/wp-content/uploads/2016/10/pythagorean-proof.png\">https://betterexplained.com/wp-content/uploads/2016/10/pythagorean-proof.png</a></p>\n<div class=\"message_inline_image\"><a href=\"https://betterexplained.com/wp-content/uploads/2016/10/pythagorean-proof.png\"><img src=\"https://uploads.zulipusercontent.net/cfb4a9811f5fb41e329f4e5b08676e91d44f8296/68747470733a2f2f6265747465726578706c61696e65642e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031362f31302f7079746861676f7265616e2d70726f6f662e706e67\"></a></div><p><a href=\"https://www.3blue1brown.com/content/blog/exact-sequence-picturebook/PuzzlingThroughExactSequences.pdf\">https://www.3blue1brown.com/content/blog/exact-sequence-picturebook/PuzzlingThroughExactSequences.pdf</a> by Ravi Vakil contains a proof of the snake lemma (page 23) in one picture.</p>",
        "id": 267312552,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1641672191
    },
    {
        "content": "<p><span aria-label=\"lizard\" class=\"emoji emoji-1f98e\" role=\"img\" title=\"lizard\">:lizard:</span></p>",
        "id": 267312855,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1641672558
    }
]
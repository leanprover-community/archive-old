[
    {
        "content": "<p>My partner's away, my kids are out, and I'm sick of marking, so I'm going to do some LTE work. The stuff in <code>for_mathlib/acyclic</code> looks pretty straightforward to knock off (hopefully) -- is anyone else working on this? I'm trying the sorrys now.</p>",
        "id": 284243917,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1653765042
    },
    {
        "content": "<p>Johan and I were hacking on this yesterday</p>",
        "id": 284244511,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1653765859
    },
    {
        "content": "<p>I think this will be a bit of a challlenge:<br>\n<a href=\"https://github.com/leanprover-community/lean-liquid/blob/edc56f03a7883d9ebe76a8b31e18e0212fa7df2f/src/for_mathlib/acyclic.lean#L430\">https://github.com/leanprover-community/lean-liquid/blob/edc56f03a7883d9ebe76a8b31e18e0212fa7df2f/src/for_mathlib/acyclic.lean#L430</a></p>",
        "id": 284244533,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1653765914
    },
    {
        "content": "<p>And a few of the sorries in <code>Ext_compute_with_acyclic_naturality</code> will probably also be a little challenging.</p>",
        "id": 284244540,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1653765949
    },
    {
        "content": "<p>This stuff is quite good fun :-)</p>",
        "id": 284244662,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1653766098
    },
    {
        "content": "<p>I'll take a look at your challenge! The night is young.</p>",
        "id": 284244674,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1653766122
    },
    {
        "content": "<p>Have you done anything with this file which isn't currently on <code>master</code>? I was working on the sorry in <code>cochain_complex.hom_to_single_of_hom</code></p>",
        "id": 284244753,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1653766265
    },
    {
        "content": "<p>I really like these kinds of levels</p>",
        "id": 284244759,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1653766291
    },
    {
        "content": "<p>Can you imagine life without widgets? I can just dive into each of these goals thinking \"I haven't even read the question but I know this is some diagram in category theory and it's really easy to draw it on paper because I can just query the goal state\"</p>",
        "id": 284244820,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1653766362
    },
    {
        "content": "<p>Shall I just push directly to <code>master</code>?</p>",
        "id": 284244975,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1653766609
    },
    {
        "content": "<p>Yes please</p>",
        "id": 284245148,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1653766843
    },
    {
        "content": "<p>Do we have this?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">category_theory.abelian.exact</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">category_theory</span> <span class=\"n\">category_theory.limits</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"bp\">ùìê</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span>\n  <span class=\"o\">[</span><span class=\"n\">category</span> <span class=\"bp\">ùìê</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">abelian</span> <span class=\"bp\">ùìê</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"bp\">ùìê</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">hY</span> <span class=\"o\">:</span> <span class=\"n\">is_zero</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">subsingleton</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">‚ü∂</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"gr\">admit</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 284245375,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1653767198
    },
    {
        "content": "<p>I think I find abelian category theory much more fun than category theory :-)</p>",
        "id": 284245387,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1653767237
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.limits.is_zero.eq_of_tgt\">docs#category_theory.limits.is_zero.eq_of_tgt</a></p>",
        "id": 284245462,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1653767402
    },
    {
        "content": "<p>(or something like that...)</p>",
        "id": 284245505,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1653767414
    },
    {
        "content": "<p>There is also a <code>eq_of_src</code> variant</p>",
        "id": 284245512,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1653767429
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">is_zero.subsingleton_right</span> <span class=\"o\">{</span><span class=\"bp\">ùìê</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">category</span> <span class=\"bp\">ùìê</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">abelian</span> <span class=\"bp\">ùìê</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"bp\">ùìê</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"bp\">ùìê</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hY</span> <span class=\"o\">:</span> <span class=\"n\">is_zero</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">subsingleton</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">‚ü∂</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">‚ü®</span><span class=\"bp\">Œª</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"kd\">begin</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">hY</span> <span class=\"k\">with</span> <span class=\"o\">‚ü®</span><span class=\"bp\">-</span><span class=\"o\">,</span> <span class=\"n\">hY</span><span class=\"o\">‚ü©,</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">‚ü®‚ü®</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">‚ü©‚ü©</span> <span class=\"o\">:=</span> <span class=\"n\">hY</span> <span class=\"n\">X</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span><span class=\"o\">‚ü©</span>\n</code></pre></div>",
        "id": 284245842,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1653767887
    },
    {
        "content": "<p>I just took it all apart :-) I'm learning how it all works.</p>",
        "id": 284245848,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1653767904
    },
    {
        "content": "<p><code>@unique.subsingleton _ (hY.unique_from X).some</code> should also work</p>",
        "id": 284245859,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1653767942
    },
    {
        "content": "<p>and <code>abelian</code> is not needed <span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span></p>",
        "id": 284245868,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1653767976
    },
    {
        "content": "<p>I think it would be generally easier to use <code>eq_of_src</code> and <code>eq_of_tgt</code> instead of adding various <code>subsingleton</code> instances using <code>haveI</code> or whatnot inside tactic blocks.</p>",
        "id": 284245920,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1653768009
    },
    {
        "content": "<p>I'm just experimenting with this stuff for the first time and would be very happy to hear style comments! I thought the subsingleton approach was all abstract and cool :-)</p>",
        "id": 284246185,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1653768339
    },
    {
        "content": "<p>I like that I can use</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#print</span> <span class=\"kd\">prefix</span> <span class=\"n\">category_theory.limits.is_zero</span>\n</code></pre></div>\n<p>to get the API for this concept I've not really used before</p>",
        "id": 284246448,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1653768723
    },
    {
        "content": "<p>Hey! <code>cochain_complex.hom_to_single_of_hom</code> : computer says no.<br>\nHere's the first case I can't do:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">ùìê</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">,</span>\n<span class=\"n\">_inst_1</span> <span class=\"o\">:</span> <span class=\"n\">category</span> <span class=\"bp\">ùìê</span><span class=\"o\">,</span>\n<span class=\"n\">_inst_2</span> <span class=\"o\">:</span> <span class=\"n\">abelian</span> <span class=\"bp\">ùìê</span><span class=\"o\">,</span>\n<span class=\"n\">_inst_3</span> <span class=\"o\">:</span> <span class=\"n\">enough_projectives</span> <span class=\"bp\">ùìê</span><span class=\"o\">,</span>\n<span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">cochain_complex</span> <span class=\"bp\">ùìê</span> <span class=\"n\">‚Ñ§</span><span class=\"o\">,</span>\n<span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"bp\">ùìê</span><span class=\"o\">,</span>\n<span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñ§</span><span class=\"o\">,</span>\n<span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">C.X</span> <span class=\"o\">(</span><span class=\"n\">j.add</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">‚ü∂</span> <span class=\"n\">B</span>\n<span class=\"bp\">‚ä¢</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"n\">C.d</span> <span class=\"n\">j</span> <span class=\"o\">(</span><span class=\"n\">j.add</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">‚â´</span> <span class=\"n\">f</span> <span class=\"bp\">‚â´</span> <span class=\"o\">(</span><span class=\"n\">homological_complex.single_iso</span> <span class=\"n\">B</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">inv</span>\n</code></pre></div>",
        "id": 284246848,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1653769388
    },
    {
        "content": "<p>This is the <code>j + 1 = i</code> branch.</p>",
        "id": 284246921,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1653769466
    },
    {
        "content": "<p>I pushed to master, I'll try and fathom out the mathematical assertion I'm making.</p>",
        "id": 284246990,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1653769566
    },
    {
        "content": "<p>I'm now quite confused. I would ignore me for a while.</p>",
        "id": 284247062,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1653769707
    },
    {
        "content": "<p>Yeah I think my proof has gone astray ;-)</p>",
        "id": 284247139,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1653769889
    },
    {
        "content": "<p>I now understand my mistake. I had lost information about <code>f</code>. The definition looks like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">cochain_complex.hom_to_single_of_hom</span>\n  <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">cochain_complex</span> <span class=\"bp\">ùìê</span> <span class=\"n\">‚Ñ§</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"bp\">ùìê</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñ§</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">C.X</span> <span class=\"n\">i</span> <span class=\"bp\">‚ü∂</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">C</span> <span class=\"bp\">‚ü∂</span> <span class=\"o\">(</span><span class=\"n\">homological_complex.single</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">obj</span> <span class=\"n\">B</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"bp\">Œª</span> <span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">j</span> <span class=\"bp\">=</span> <span class=\"n\">i</span> <span class=\"k\">then</span> <span class=\"n\">eq_to_hom</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"bp\">‚â´</span> <span class=\"n\">f</span> <span class=\"bp\">‚â´</span> <span class=\"o\">(</span><span class=\"n\">homological_complex.single_iso</span> <span class=\"n\">_</span> <span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">inv</span>\n    <span class=\"k\">else</span> <span class=\"mi\">0</span><span class=\"o\">,</span>\n  <span class=\"n\">comm'</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"gr\">sorry</span>\n  <span class=\"kd\">end</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>but if you look at the goal state in the <code>comm'</code> proof then there's no mention of the definition of <code>f</code>!</p>",
        "id": 284247284,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1653770138
    },
    {
        "content": "<p>oh this is an actual problem: I don't know how to get to the definition of <code>f</code> in that proof.</p>",
        "id": 284247364,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1653770279
    },
    {
        "content": "<p><code>change ite _ _ _</code> doesn't work?</p>",
        "id": 284247425,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1653770336
    },
    {
        "content": "<p>oh lol there are two <code>f</code>s</p>",
        "id": 284247717,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1653770858
    },
    {
        "content": "<p>OK so here is the issue. You want to define a morphism of complexes, from a general complex C to a \"skyscraper\" complex with only one term B in position i. You want to magic this up from a map from a map from C[i] to B in the the obvious way. The problem: one of the squares doesn't commute.  That map from C[i] to B had better be zero on the image of C[i-1] for this construction to work, right?</p>",
        "id": 284247927,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1653771154
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> do you agree that this is a false <code>sorry</code>?</p>",
        "id": 284247938,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1653771176
    },
    {
        "content": "<p>I mean, before I started messing with it on <code>master</code>.</p>",
        "id": 284247946,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1653771191
    },
    {
        "content": "<p>Yeah it's false</p>",
        "id": 284248096,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1653771408
    },
    {
        "content": "<p>I propose this modification:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">cochain_complex.hom_to_single_of_hom</span>\n  <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">cochain_complex</span> <span class=\"bp\">ùìê</span> <span class=\"n\">‚Ñ§</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"bp\">ùìê</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñ§</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">C.X</span> <span class=\"n\">i</span> <span class=\"bp\">‚ü∂</span> <span class=\"n\">B</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñ§</span><span class=\"o\">,</span> <span class=\"n\">C.d</span> <span class=\"n\">j</span> <span class=\"n\">i</span> <span class=\"bp\">‚â´</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">):</span>\n  <span class=\"n\">C</span> <span class=\"bp\">‚ü∂</span> <span class=\"o\">(</span><span class=\"n\">homological_complex.single</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">obj</span> <span class=\"n\">B</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"bp\">Œª</span> <span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">j</span> <span class=\"bp\">=</span> <span class=\"n\">i</span> <span class=\"k\">then</span> <span class=\"n\">eq_to_hom</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"bp\">‚â´</span> <span class=\"n\">f</span> <span class=\"bp\">‚â´</span> <span class=\"o\">(</span><span class=\"n\">homological_complex.single_iso</span> <span class=\"n\">_</span> <span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">inv</span>\n    <span class=\"k\">else</span> <span class=\"mi\">0</span><span class=\"o\">,</span>\n</code></pre></div>",
        "id": 284248097,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1653771408
    },
    {
        "content": "<p>Oops!</p>",
        "id": 284248099,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1653771419
    },
    {
        "content": "<p><code>Ext_compute_with_acyclic_inv_eq_aux</code> breaks -- I'm checking out the random extra goal which has now appeared :-)</p>",
        "id": 284248161,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1653771487
    },
    {
        "content": "<p>Yeah that would have to be fixed as well...</p>",
        "id": 284248190,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1653771551
    },
    {
        "content": "<p>Sorry we got the map in the wrong direction</p>",
        "id": 284248193,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1653771561
    },
    {
        "content": "<p>A map on the ith term induces a map <strong>from</strong> <code>single.obj ...</code></p>",
        "id": 284248211,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1653771593
    },
    {
        "content": "<p>So I can try to fix this: if you want to write the new defs I can fill in the proofs, on a branch or something -- I don't really just want to blunder in as I'm only just learning about this part of the code base for the first time</p>",
        "id": 284248325,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1653771670
    },
    {
        "content": "<p>I won't have time to work on LTE until Monday.</p>",
        "id": 284248386,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1653771782
    },
    {
        "content": "<p>OK, I'll keep digging :-)</p>",
        "id": 284248690,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1653772311
    },
    {
        "content": "<p>Oh I think I understand. Fixing it up.</p>",
        "id": 284249242,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1653773248
    },
    {
        "content": "<p>No, this isn't true either. To make sure that the map from B to C_i induces a map from the singleton complex B[i] into C, you need that the given map is in the kernel of C_i -&gt; C_{i+1}.</p>",
        "id": 284249357,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1653773429
    },
    {
        "content": "<p>OK so after the dust has cleared: I appear to have broken the statement of <code>Ext_compute_with_acylic_inv_eq</code>. Here is a revised <code>Ext_compute_with_acyclic_inv_eq_aux</code> : </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Ext_compute_with_acyclic_inv_eq_aux</span> <span class=\"o\">(</span><span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">AddCommGroup.of</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"bp\">‚ü∂</span> <span class=\"o\">(</span><span class=\"n\">homological_complex.single</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"n\">i</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">obj</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"bp\">‚ü∂</span> <span class=\"o\">((</span><span class=\"n\">Ext</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">obj</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"o\">(</span><span class=\"n\">of'</span> <span class=\"n\">C</span><span class=\"o\">)))</span><span class=\"bp\">.</span><span class=\"n\">obj</span> <span class=\"o\">((</span><span class=\"n\">single</span> <span class=\"bp\">ùìê</span> <span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">obj</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">Œª</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">of'</span> <span class=\"n\">C</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">œÄ</span> <span class=\"bp\">‚â´</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">dsimp</span> <span class=\"n\">at</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n    <span class=\"n\">refine</span> <span class=\"o\">(</span><span class=\"n\">homotopy_category.quotient</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n    <span class=\"n\">refine</span> <span class=\"n\">_</span> <span class=\"bp\">‚â´</span> <span class=\"o\">(</span><span class=\"n\">homological_complex.single_shift</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">inv.app</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n    <span class=\"n\">refine</span> <span class=\"n\">f</span> <span class=\"bp\">‚â´</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n    <span class=\"n\">refine</span> <span class=\"n\">eq_to_hom</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">map_zero'</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">map_add'</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>The change is that the hom set we're mapping into the Ext group is now smaller; it's only the morphisms of complexes from C to B[-i] instead of the possibly larger group of morphisms <code>C.X (-i) ‚ü∂ B</code>.</p>",
        "id": 284249940,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1653774439
    },
    {
        "content": "<p>I think I can fix it. In the application we need to construct a map from a kernel and we were throwing away information, using kernel.\\iota and instead constructing a map on a bigger space -- we were throwing away precisely what we needed to make the diagram commute.</p>",
        "id": 284250264,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1653774953
    },
    {
        "content": "<p>Ha ha there is a nasty sub-boss. We have some function f which is given as some fancy object in a kernel but you know when you unravel it that the <code>spec</code> of it  you'll get a group hom with a nice property. However just attempting to extract this and I ran into <code>classical.choice</code>, which was used to construct the kernel of the group homomorphism in <code>Ab</code> :-)</p>",
        "id": 284251542,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1653776919
    },
    {
        "content": "<p>I think at the end of the day we're interested in the case where <code>C</code> is a resolution by acyclic objects, and in that case, the original construction should actually be okay, except that some hypotheses were missing. I think the version of <code>hom_to_single_of_hom</code> that Kevin proposed above should work.</p>",
        "id": 284260563,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1653791957
    },
    {
        "content": "<p>OK so I have pushed my suggested change of route to <code>master</code>. <span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> you might want to have a look at it. My changes start at line 402. I slightly weaken <code>Ext_compute_with_acyclic_inv_eq_aux</code>. I add a new definition <code>kernel_yoneda_complex_to_morphism_to_single</code> saying that if you have <code>f</code> in the kernel of <code>(C‚±º‚Çä‚ÇÅ ‚ü∂ B) ‚ü∂ (C‚±º ‚ü∂ B)</code> then you can define a map of complexes C -&gt; B[j+1] ; I seem to have made an off by one error but I'll fix it later. In particular there might still be a false sorry but I will sort it out later; I need be disciplined and to do some solid marking for a few hours now.</p>",
        "id": 284284759,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1653828751
    },
    {
        "content": "<p>Sorry -- I thought I had fixed all the false sorries; it was only when I was writing the previous message that I noticed the possible off by one error.</p>",
        "id": 284284772,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1653828779
    },
    {
        "content": "<p>Near the end of the file, a rewrite broke and I now suspect that this will be because of the off by one error I've made. Will fix later (maybe 10pm UK time tonight)</p>",
        "id": 284285250,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1653829369
    },
    {
        "content": "<p>OK I've made some progress (and fixed the off by one error). Things are a bit tidier than before but I still didn't finish one annoying <code>sorry</code>.</p>\n<p><span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> why are you stating such an ugly <code>Ext_compute_with_acyclic_naturality</code> ? One of the things you have in the<br>\nstatement is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>    <span class=\"o\">(((</span><span class=\"n\">preadditive_yoneda.obj</span> <span class=\"n\">B</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">right_op.map_homological_complex</span> <span class=\"n\">_</span> <span class=\"bp\">‚ãô</span>\n      <span class=\"n\">homological_complex.unop_functor.right_op</span> <span class=\"bp\">‚ãô</span> <span class=\"o\">(</span><span class=\"n\">_root_.homology_functor</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"n\">i</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">op</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">unop</span>\n</code></pre></div>\n<p>This contains no fewer than 5 <code>op/unop</code>isms. Is this really the form you want it to be in? I've been trying to avoid Ab^{op} completely. My refactor broke your proof but I'm wondering why you want to prove it at all!</p>",
        "id": 284320249,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1653881179
    },
    {
        "content": "<p>If we had contravariant functors we wouldn't need any <code>op</code>s at all. You could have a Yoneda : B \\func (B \\contrafunc Ab), have a contra_map_homological_complex sending B-valued complexes with shape c to Ab-valued complexes with shape c.symm (note that c.symm.symm is definitionally c), you never see another <code>op</code> in your life. What do you think?</p>",
        "id": 284320422,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1653881412
    },
    {
        "content": "<p>Doesn't that mean duplicating the entire category library?</p>",
        "id": 284321843,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1653883485
    },
    {
        "content": "<p>It is already duplicating all the limits stuff into colimits.</p>",
        "id": 284321853,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1653883503
    },
    {
        "content": "<p>Yeah! But then no more fighting <code>op</code>s so we can delete all that stuff. Right now we have two ways of talking about contravariant functor and both of them are inconvenient. The explicit op-free definition feels more natural -- we're never thinking about <code>op c</code> in reality, we're thinking about c but with the arrows going the other way and this is just interchanging the order of the inputs to the hom functor</p>",
        "id": 284347145,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1653904946
    },
    {
        "content": "<p>For example if someone said to you \"hey let's delete colimits, they're just limits in <code>op</code> so we don't need them\" you'd be like \"well I'm not so sure, that sounds like it would make a bunch of stuff a lot more fiddly\". I'm looking at this op nonsense and thinking it would be less fiddly with contravariant functors. Maybe I'm wrong though, I'm a newcomer to this part of the library</p>",
        "id": 284347722,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1653905267
    },
    {
        "content": "<p>Analogously, we added <a href=\"https://leanprover-community.github.io/mathlib_docs/find/antitone\">docs#antitone</a> lately and it makes stuff much cleaner.</p>",
        "id": 284348404,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1653905686
    },
    {
        "content": "<p>The op-free definition of a contravariant functor has better definitional properties too; it's a genuinely simpler object</p>",
        "id": 284348653,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1653905847
    },
    {
        "content": "<p>But you will need 4 definitions of composition of functor.</p>",
        "id": 284349662,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1653906551
    },
    {
        "content": "<p>And I guess they can't share notation</p>",
        "id": 284349678,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1653906568
    },
    {
        "content": "<p>Yup. And they'll all have better definitional properties than anything we have now, because we're already doing those four definitions in our code but we're filling our terms with op (o) and f.op instead. Adam's term has no fewer than five \"no-op\" applications in. If you like you could say I was proposing deleting all of them and doing it a new way</p>",
        "id": 284350668,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1653907286
    },
    {
        "content": "<p>Btw, I guess I actually wrote that last decl in the file</p>",
        "id": 284350832,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1653907404
    },
    {
        "content": "<p>Note that <code>unop_functor</code> is a different beast. It doesn't just disappear if you add contravariant functors.</p>",
        "id": 284350977,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1653907503
    },
    {
        "content": "<p>Oh great! Why did you write it like that? Is it something that's coming up later and we need it to be in that form? I am still in marking hell but I've got my eye on it</p>",
        "id": 284351654,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1653907956
    },
    {
        "content": "<p>I'm about to spend an hour hacking on this file before I start marking again</p>",
        "id": 284351715,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1653908010
    },
    {
        "content": "<p>Yeah we need it in <code>Lbar/ext.lean</code></p>",
        "id": 284352919,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1653908604
    },
    {
        "content": "<p>But I don't really care too much about where you put the <code>op</code>s.</p>",
        "id": 284352958,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1653908627
    },
    {
        "content": "<p>Because <code>f.op.unop</code> is defeq to <code>f</code>. And the same for <code>op (unop X)</code>. So in the end, all those different ways will be defeq.</p>",
        "id": 284353034,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1653908658
    },
    {
        "content": "<p>Is <code>op X \\hom op Y</code> defeq to <code>Y \\hom X</code>?</p>",
        "id": 284353412,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1653908895
    },
    {
        "content": "<p>Yes</p>",
        "id": 284353492,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1653908966
    },
    {
        "content": "<p>Nice! OK so I have finished the \"annoying sorry\" mentioned above, so a summary of my work is that the false sorry is now modified so it's true, and proved; and the consequences are that <code>Ext_compute_with_acylic_inv_eq</code> still compiles as well as it did before (i.e. there's a sorry in both the statement and the proof) and the proof of <code>Ext_compute_with_acyclic_naturality</code> is a bit more broken than it was, because a rewrite which used to work, no longer works.</p>",
        "id": 284361300,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1653913951
    },
    {
        "content": "<p>OK I got the rewrite working again. I've pushed. I now have sorried data and I don't know the maths well enough to know what the data should be. I'm unlikely to work on this file for the next 6 hours or so because I need to stop doing Lean and start doing marking. Please <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> or <span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> let me know if I'm taking things backwards! I don't really know what I'm doing, I'm just blundering in really. I've learnt tons in the last two days!</p>",
        "id": 284376909,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1653922398
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> I think there is an issue with the missing data in the proof:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">preadditive_yoneda.obj</span> <span class=\"n\">B</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">obj</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"o\">(</span><span class=\"n\">C‚ÇÅ.X</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"n\">i</span><span class=\"o\">)))</span> <span class=\"bp\">‚ü∂</span> <span class=\"o\">((</span><span class=\"n\">Ext</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">obj</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"o\">(</span><span class=\"n\">of'</span> <span class=\"n\">C‚ÇÅ</span><span class=\"o\">)))</span><span class=\"bp\">.</span><span class=\"n\">obj</span> <span class=\"o\">((</span><span class=\"n\">single</span> <span class=\"bp\">ùìê</span> <span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">obj</span> <span class=\"n\">B</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>The natural thing here would be something simiilar to what we discussed above about <code>hom_to_single_of_hom</code> composed with <code>Ext_compute_with_acyclic_inv_eq_aux</code>, but as you noted there is a missing hypothesis which I don't think we can deduce here.</p>",
        "id": 284385541,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1653926978
    },
    {
        "content": "<p>Oh interesting! So we need to sort out the mathematics here.</p>",
        "id": 284391891,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1653931972
    },
    {
        "content": "<p>I'm working on it now.</p>",
        "id": 284391997,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1653932065
    },
    {
        "content": "<p>I'll have some time later to work on this. I'd pushed all I had by the way</p>",
        "id": 284392038,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1653932107
    },
    {
        "content": "<p>Okay, I've broken up the primary naturality proof into three smaller naturality proofs which should be doable independently.<br>\nI think this makes it much clearer what's actually goiing on here...</p>",
        "id": 284394775,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1653934563
    },
    {
        "content": "<p>The three smaller naturality sorries are in <code>for_mathlib/acyclic</code>.</p>",
        "id": 284394807,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1653934595
    },
    {
        "content": "<p>I'm about to start hacking on this again</p>",
        "id": 284398163,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1653937600
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> there is one new sorry in <code>for_mathlib/derived/example.lean</code></p>",
        "id": 284400448,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1653939690
    },
    {
        "content": "<p>That takes care of the of the three sorries I mentioned above, I already solved the fiirst one, and I'm working on the last one now.</p>",
        "id": 284400516,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1653939739
    },
    {
        "content": "<p>Well, I have to do other things for a little while. I'll try to finish off the third sorry later</p>",
        "id": 284401035,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1653940279
    },
    {
        "content": "<p>I didn't get very far :-( I spent most of the evening learning about the area.</p>",
        "id": 284416541,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1653957743
    },
    {
        "content": "<p>The proof I was working on turned out to be quite difficult because at some point II have to switch from equality to homotopy.<br>\nDo we have a well-establiished way to do such proofs?</p>",
        "id": 284468486,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1654000745
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/eq_of_homotopy\">docs#eq_of_homotopy</a> (modulo some namespace)</p>",
        "id": 284468547,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1654000780
    },
    {
        "content": "<p>That's not quite what I need</p>",
        "id": 284468818,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1654000914
    },
    {
        "content": "<p>I have two maps <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo separator=\"true\">,</mo><mi>g</mi></mrow><annotation encoding=\"application/x-tex\">f,g</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span></span></span></span> and the goal is to show that the compositiion (approx) <code>kernel.\\iota d \\gg f \\gg cokernel.\\pi d = kernell.\\iota d \\gg g \\gg cokernel.\\pi d</code>.</p>",
        "id": 284468949,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1654000972
    },
    {
        "content": "<p>And what I can prove that is <code>f</code> and <code>g</code> are homotopic</p>",
        "id": 284469005,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1654001010
    },
    {
        "content": "<p>Hmm, I guess we need more API for that. Can you state a selfcontained lemma?</p>",
        "id": 284469152,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1654001072
    },
    {
        "content": "<p>I'm doing that now.</p>",
        "id": 284469236,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1654001116
    },
    {
        "content": "<p>Lemma added to <code>for_mathlib/homotopy_category_lemmas</code>... additional sorries incoming.</p>",
        "id": 284471508,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1654002130
    },
    {
        "content": "<p>And I suppose we already know that an additive functor preserves homotopies?</p>",
        "id": 284471577,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1654002166
    },
    {
        "content": "<p>Indeed: <a href=\"https://leanprover-community.github.io/mathlib_docs/find/functor.map_homotopy\">docs#functor.map_homotopy</a></p>",
        "id": 284471706,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1654002224
    },
    {
        "content": "<p>(mod namespaces)</p>",
        "id": 284471719,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1654002230
    },
    {
        "content": "<p>Alright, <code>for_mathlib/acyclic</code> is sorry-free, but there are some dependent sorries in <code>for_mathliib/homotopy_category_lemmas</code> and <code>for_mathlib/derived/example</code></p>",
        "id": 284473540,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1654003087
    },
    {
        "content": "<p><code>for_mathlib/derived/example</code> is very slow for me. I think we should clean-up/reorganize that file. It's doing 10 things and some.</p>",
        "id": 284474596,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1654003564
    },
    {
        "content": "<p>But I'm very glad that the bulk of this naturality proof is now done! Merci!</p>",
        "id": 284474641,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1654003582
    }
]
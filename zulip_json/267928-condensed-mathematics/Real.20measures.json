[
    {
        "content": "<p>The branch <code>Radon_wip</code> now has the following isomorphism</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Radon_iso_real_measures</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">Profinite.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">})</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñù</span><span class=\"bp\">‚â•</span><span class=\"mi\">0</span><span class=\"o\">)</span>\n  <span class=\"o\">[</span><span class=\"n\">fact</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">p</span><span class=\"o\">)]</span> <span class=\"o\">[</span><span class=\"n\">fact</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">‚â§</span> <span class=\"mi\">1</span><span class=\"o\">)]</span> <span class=\"o\">:</span>\n  <span class=\"n\">CompHaus.of</span> <span class=\"o\">(</span><span class=\"n\">X.Radon</span> <span class=\"n\">p</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"bp\">‚âÖ</span>\n  <span class=\"o\">(</span><span class=\"n\">CompHausFiltPseuNormGrp‚ÇÅ.level.obj</span> <span class=\"n\">c</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">obj</span>\n  <span class=\"o\">((</span><span class=\"n\">Profinite.extend</span> <span class=\"o\">(</span><span class=\"n\">real_measures.functor</span> <span class=\"n\">p</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">obj</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n</code></pre></div>\n<p>in the file <code>src/examples/Radon/main.lean</code>, but it depends on a bunch of relatively small sorries.</p>\n<p>If anyone wants to help fill in these sorries, that would be greatly appreciated!</p>",
        "id": 292773369,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1660144193
    },
    {
        "content": "<p>Here <code>X.Radon p c</code> is defined as the space of all continuous linear maps <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Œº</mi><mo>:</mo><mi>C</mi><mo stretchy=\"false\">(</mo><mi>X</mi><mo separator=\"true\">,</mo><mi mathvariant=\"double-struck\">R</mi><mo stretchy=\"false\">)</mo><mo>‚Üí</mo><mi mathvariant=\"double-struck\">R</mi></mrow><annotation encoding=\"application/x-tex\">\\mu : C(X,\\mathbb{R}) \\to \\mathbb{R}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">Œº</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathbb\">R</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">‚Üí</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">R</span></span></span></span> such that for any clopen partition <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi><mo>=</mo><msub><mo>‚à™</mo><mi>i</mi></msub><msub><mi>U</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">X = \\cup_i U_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mbin\">‚à™</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.109em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span>, one has <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mo>‚àë</mo><mi>i</mi></msub><mi mathvariant=\"normal\">‚à£</mi><mi>Œº</mi><mo stretchy=\"false\">(</mo><msub><mn mathvariant=\"double-struck\">1</mn><msub><mi>U</mi><mi>i</mi></msub></msub><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">‚à£</mi><mo>‚â§</mo><mi>c</mi></mrow><annotation encoding=\"application/x-tex\">\\sum_i |\\mu(\\mathbb{1}_{U_i}) | \\le c</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0497em;vertical-align:-0.2997em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:0em;\">‚àë</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.162em;\"><span style=\"top:-2.4003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2997em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">‚à£</span><span class=\"mord mathnormal\">Œº</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord\">1</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10903em;\">U</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3281em;\"><span style=\"top:-2.357em;margin-left:-0.109em;margin-right:0.0714em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.143em;\"><span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2501em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mord\">‚à£</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">‚â§</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">c</span></span></span></span></p>",
        "id": 292773647,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1660144284
    },
    {
        "content": "<p>(Well, rather I have used discrete quotients of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span> instead of clopen partitions.)</p>",
        "id": 292774752,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1660144562
    },
    {
        "content": "<p>If needed, we could use this to put a comphaus filtered pseudo normed group structure on the space of Radon measures, and show that it's condensification is isomorphic to what we call <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">M</mi></mrow><annotation encoding=\"application/x-tex\">\\mathcal{M}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathcal\">M</span></span></span></span> in <code>challenge.lean</code> -- this should be fairly straightforward with what we have now.</p>",
        "id": 292775605,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1660144826
    },
    {
        "content": "<p>I'm going through <code>src/examples/Radon/setup.lean</code>, if that is helpful!</p>",
        "id": 292777709,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1660145523
    },
    {
        "content": "<p>I should also mention that the file <code>example/radon_aux</code> (which is completely commented out) has a few proofs that would be useful for some of these sorries!</p>",
        "id": 292777987,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1660145619
    },
    {
        "content": "<p>For example, I think most of the sorries in <code>Radon/setup</code> are some minor variants of proofs in <code>radon_aux.lean</code>.</p>",
        "id": 292778155,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1660145660
    },
    {
        "content": "<p>Turns out that I did not have as much time as I hoped: I pushed one proof in <code>Radon/setup</code>, copied over from <code>radon_aux</code> on <a href=\"https://github.com/leanprover-community/mathlib/tree/adomani_radon\">branch#adomani_radon</a>.</p>\n<p>(The link does not work, but the branch name is indeed <code>adomani_radon</code>.)</p>",
        "id": 292789394,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1660149071
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span> please feel free to push directly to the <code>Radon_wip</code> branch!</p>",
        "id": 292796239,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1660151415
    },
    {
        "content": "<p>I just did!</p>",
        "id": 292806353,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1660155076
    },
    {
        "content": "<p>I added the following to the file <code>examples/radon_measures</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñù</span><span class=\"bp\">‚â•</span><span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">fact</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">p</span><span class=\"o\">)]</span> <span class=\"o\">[</span><span class=\"n\">fact</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">‚â§</span> <span class=\"mi\">1</span><span class=\"o\">)]</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">Profinite.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">})</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">real_measures.condensed</span> <span class=\"n\">p</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">obj</span> <span class=\"n\">S</span> <span class=\"bp\">‚âÖ</span>\n  <span class=\"n\">CompHausFiltPseuNormGrp.to_Condensed.obj</span>\n  <span class=\"o\">(</span><span class=\"n\">CHFPNG‚ÇÅ_to_CHFPNG‚Çë‚Çó.obj</span> <span class=\"bp\">$</span> <span class=\"n\">S.Radon_png</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">CompHausFiltPseuNormGrp.to_Condensed.map_iso</span> <span class=\"bp\">$</span>\n<span class=\"n\">CHFPNG‚ÇÅ_to_CHFPNG‚Çë‚Çó.map_iso</span> <span class=\"bp\">$</span> <span class=\"o\">(</span><span class=\"n\">S.Radon_png_iso</span> <span class=\"n\">p</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n</code></pre></div>\n<p>But again, it depends on a whole lot of small sorries (all of which should be props!).</p>\n<p>All of this is in the <code>Radon_wip</code> branch, in case anyone wants to help fill in some sorries.</p>",
        "id": 292941583,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1660228486
    },
    {
        "content": "<p>Once this and the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>l</mi><mi>p</mi></msup></mrow><annotation encoding=\"application/x-tex\">l^p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">p</span></span></span></span></span></span></span></span></span></span></span> example file that Heather and Filippo are working on are done, then I think we have essentially all of the examples we would want for our project!</p>",
        "id": 292942147,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1660228658
    },
    {
        "content": "<p>I hope it shouldn't get too much larger ;)</p>\n<div class=\"codehilite\" data-code-language=\"Bash\"><pre><span></span><code>find lean-liquid/src/examples/Radon -name <span class=\"s1\">'*.lean'</span> <span class=\"p\">|</span> xargs wc -l\n  <span class=\"m\">505</span> lean-liquid/src/examples/Radon/png_reflects_limits.lean\n  <span class=\"m\">244</span> lean-liquid/src/examples/Radon/LC_limit.lean\n  <span class=\"m\">176</span> lean-liquid/src/examples/Radon/LC_comparison.lean\n  <span class=\"m\">173</span> lean-liquid/src/examples/Radon/png.lean\n  <span class=\"m\">331</span> lean-liquid/src/examples/Radon/setup.lean\n   <span class=\"m\">81</span> lean-liquid/src/examples/Radon/defs.lean\n  <span class=\"m\">311</span> lean-liquid/src/examples/Radon/main.lean\n <span class=\"m\">1821</span> total\n</code></pre></div>",
        "id": 292990241,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1660244813
    },
    {
        "content": "<p>I killed most of the sorries in the <code>examples/Radon</code> folder, but my laptop is about to run out of battery and I won't have time to work on this for the rest of the day. Anyone want to finish off the last few?</p>",
        "id": 293086464,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1660302645
    },
    {
        "content": "<p>I'll look at them after I finish the mathlib bump, if nobody beats me.</p>",
        "id": 293086556,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1660302684
    },
    {
        "content": "<p>You would need to merge master into this branch as well once the mathlib bump is done, but that should be fairly easy since this folder is essentially completely isolated.</p>",
        "id": 293086768,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1660302755
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Bash\"><pre><span></span><code>find lean-liquid/src/examples/Radon -name <span class=\"s1\">'*.lean'</span> <span class=\"p\">|</span> xargs wc -l\n  <span class=\"m\">505</span> lean-liquid/src/examples/Radon/png_reflects_limits.lean\n  <span class=\"m\">254</span> lean-liquid/src/examples/Radon/LC_limit.lean\n  <span class=\"m\">213</span> lean-liquid/src/examples/Radon/LC_comparison.lean\n  <span class=\"m\">253</span> lean-liquid/src/examples/Radon/png.lean\n  <span class=\"m\">331</span> lean-liquid/src/examples/Radon/setup.lean\n   <span class=\"m\">81</span> lean-liquid/src/examples/Radon/defs.lean\n  <span class=\"m\">337</span> lean-liquid/src/examples/Radon/main.lean\n <span class=\"m\">1974</span> total\n</code></pre></div>\n<p>Can you keep it under, say, 2400?</p>",
        "id": 293087075,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1660302858
    },
    {
        "content": "<p>Let's find out!</p>",
        "id": 293087502,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1660303049
    },
    {
        "content": "<p>Okay, I killed all the remaining sorries:</p>\n<div class=\"codehilite\" data-code-language=\"Bash\"><pre><span></span><code>find lean-liquid/src/examples/Radon -name <span class=\"s1\">'*.lean'</span> <span class=\"p\">|</span> xargs wc -l\n  <span class=\"m\">505</span> lean-liquid/src/examples/Radon/png_reflects_limits.lean\n  <span class=\"m\">254</span> lean-liquid/src/examples/Radon/LC_limit.lean\n  <span class=\"m\">352</span> lean-liquid/src/examples/Radon/LC_comparison.lean\n  <span class=\"m\">253</span> lean-liquid/src/examples/Radon/png.lean\n  <span class=\"m\">421</span> lean-liquid/src/examples/Radon/setup.lean\n  <span class=\"m\">169</span> lean-liquid/src/examples/Radon/defs.lean\n  <span class=\"m\">337</span> lean-liquid/src/examples/Radon/main.lean\n <span class=\"m\">2291</span> total\n</code></pre></div>\n<p>I haven't done any linting and this stuff includes a lot of new defs.</p>",
        "id": 293336760,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1660443341
    },
    {
        "content": "<p>I am removing some unused arguments, but I broke some proof now.  I am trying to fix it, but in 10 minutes I will have to go.  Should I revert the changes to a working version?</p>",
        "id": 293343885,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1660454331
    },
    {
        "content": "<p>Actually, all the <code>Radon</code> folder builds on my machine now, so maybe this is good!</p>",
        "id": 293344100,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1660454657
    },
    {
        "content": "<p>Ok, CI is linting now!  It turns out that a lot of <code>compact, t2</code> assumptions were not needed.</p>",
        "id": 293344184,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1660454806
    },
    {
        "content": "<p>Branch <code>adomani_lint_universe</code> should pass CI on GitHub but seems to have universe issues on my local machine.  This is the reason for not pushing directly to <code>Radon_wip</code>.  I do not really know what to do with universe issues, though.</p>\n<p>Linting locally <code>examples/Radon/png_reflects_limits.lean</code> gives:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c\">/-</span><span class=\"cm\"> The `check_univs` linter reports: -/</span>\n<span class=\"c\">/-</span><span class=\"cm\"> THE STATEMENTS OF THE FOLLOWING DECLARATIONS HAVE BAD UNIVERSE LEVELS. This usually means that there is a `max u v` in the type where neither `u` nor `v` occur by themselves. Solution: Find the type (or type bundled with data) that has this universe argument and provide the universe level explicitly. If this happens in an implicit argument of the declaration, a better solution is to move this argument to a `variables` command (then it's not necessary to provide the universe level).</span>\n<span class=\"cm\">It is possible that this linter gives a false positive on definitions where the value of the definition has the universes occur separately, and the definition will usually be used with explicit universe arguments. In this case, feel free to add `@[nolint check_univs]`. -/</span>\n<span class=\"k\">#check</span> <span class=\"bp\">@</span><span class=\"n\">CompHausFiltPseuNormGrp‚ÇÅ.create_iso_from_level</span> <span class=\"c\">/-</span><span class=\"cm\"> universes [u_1, u_2] only occur together. -/</span>\n</code></pre></div>\n<p>and some doc-blames.</p>\n<p>These issues arose when I removed some \"unused\" hypotheses.</p>",
        "id": 293372479,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1660477308
    },
    {
        "content": "<p>Hmmm... I'll try to take a look later today</p>",
        "id": 293372683,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1660477437
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span> if you explicitly specify that both X and Y are in CompHausFilt...Grp_1.{u} (i.e. explicitly add the u), in that declaration, does that fix the issue?</p>",
        "id": 293372847,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1660477525
    },
    {
        "content": "<p>Sorry, I left my computer: I will try to look at it in a couple of hours.</p>",
        "id": 293372934,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1660477573
    },
    {
        "content": "<p>Well, in any case, everything in the file where that problematic declaration is made should be in the same universe level u. I would guess that adding the universe parameter explicitly everywhere would fix the issue</p>",
        "id": 293373165,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1660477731
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/267928-condensed-mathematics/topic/Real.20measures/near/293372847\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> if you explicitly specify that both X and Y are in CompHausFilt...Grp_1.{u} (i.e. explicitly add the u), in that declaration, does that fix the issue?</p>\n</blockquote>\n<p>Adam, fixing the universe worked!  Locally, I only see doc-blames.  I pushed my branch to GitHub: if it again compiles with no errors, I will merge <code>Random_wip</code> with it.</p>\n<p>Btw, even without the universe fix, CI was happy and green.</p>",
        "id": 293399992,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1660483653
    },
    {
        "content": "<p>Great! And many MANY thanks for your help Damiano!</p>",
        "id": 293400333,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1660483864
    },
    {
        "content": "<p>Ok, I have pushed the version that compiled and added 2 (or maybe 3) doc-strings.</p>",
        "id": 293400785,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1660484168
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/267928-condensed-mathematics/topic/Real.20measures/near/293400333\">said</a>:</p>\n<blockquote>\n<p>Great! And many MANY thanks for your help Damiano!</p>\n</blockquote>\n<p>No worries!  It was really all very easy: Lean was guiding me through unused assumptions and most of them were typeclass assumptions, so nothing else to fix!</p>",
        "id": 293400852,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1660484223
    },
    {
        "content": "<p>I also just pushed over doc-strings for <code>Radon.setup</code>.  I will probably not have any more time today to add more doc-strings, though.</p>",
        "id": 293405093,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1660486774
    },
    {
        "content": "<p>I thought that I had only added doc-string, but the build failed.  I have to leave now: feel free to revert to the previous successful build: I do not know what went wrong with the doc-strings...</p>",
        "id": 293407617,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1660488308
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/lean-liquid/pull/113\">https://github.com/leanprover-community/lean-liquid/pull/113</a></p>",
        "id": 293561441,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1660578458
    },
    {
        "content": "<p>So here's a thing we should discuss: I think I would like <em>all</em> of <code>examples/*</code> to be as readable as possible.<br>\nSo what do you think of moving 90% of the Radon stuff to a new (top-level?) directory. And then only have some demo stuff in the <code>examples/</code> dir?</p>",
        "id": 293562550,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1660578819
    },
    {
        "content": "<p>Fine with me!</p>",
        "id": 293562819,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1660578907
    },
    {
        "content": "<p>Let me do it now</p>",
        "id": 293562845,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1660578918
    },
    {
        "content": "<p>Ok I moved it. I think I fixed all the imports, but let's see if CI agrees</p>",
        "id": 293564350,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1660579384
    },
    {
        "content": "<p>The <code>examples/radon_measures</code> file is self contained as far as I'm concerned.</p>",
        "id": 293564748,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1660579527
    },
    {
        "content": "<p>I'm going to push some typos in doc-strings, if that's alright with you.<br>\n(Although I might wait for CI to finish anyway!)</p>",
        "id": 293565968,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1660579937
    },
    {
        "content": "<p>I was a little haphazard with some docstrings, please go ahead!</p>",
        "id": 293566577,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1660580159
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/267928-condensed-mathematics/topic/Real.20measures/near/293566577\">said</a>:</p>\n<blockquote>\n<p>I was a little haphazard with some docstrings, please go ahead!</p>\n</blockquote>\n<p>Some of the \"copy-pasted\" ones, were not even copy-pasted!  <span aria-label=\"rofl\" class=\"emoji emoji-1f923\" role=\"img\" title=\"rofl\">:rofl:</span></p>",
        "id": 293566974,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1660580295
    },
    {
        "content": "<p>Jokes aside, the doc-strings look great!  I am always grateful when I can read some words, before parsing Lean code.</p>",
        "id": 293567298,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1660580403
    },
    {
        "content": "<p>Hmm after <span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span> 's comment about docstrings vs comments in the examples folder, I looked more closely at some of the other files, and we seem to have a mix of <code>/-</code>, <code>/--</code> and <code>/-!</code>. We should probably come up with something consistent. What do you think we should do?</p>",
        "id": 293574044,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1660582626
    },
    {
        "content": "<p>I guess we're intending for these files to be \"literate lean\" (analogous to literate haskell, literate agda, etc.). I guess we have a standard way to do this, but I never thought about such issues.</p>",
        "id": 293574335,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1660582730
    },
    {
        "content": "<p>My impression is that the examples folder is likely one that will get the attention of the large number of mathematicians.  For this reason, I think that it will probably not be a \"typical\" literate file.  I tend to use <code>/-</code> comments for remarks that are either helpful to maintain a proof or inside an actual tactic block, to guide what is going on.  In the case of the examples folder, I think that the code should not need any such comments, but it would probably be beneficial if it were <em>much</em> more verbose than usual mathlib (or even lean-liquid) files.</p>\n<p>For this reason, Adam, I thought that your comments would have fit well as doc-strings.</p>",
        "id": 293575633,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1660583187
    },
    {
        "content": "<p>In fact, I wonder whether the examples folder should also contain some counter-/non-examples, since, for me at least, they are also very useful.</p>",
        "id": 293575778,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1660583264
    },
    {
        "content": "<p>As I see it, the only benefit of docstrings over comments is that they are used by docgen to generate documentation.</p>",
        "id": 293575780,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1660583267
    },
    {
        "content": "<p>Well, that and by the vscode/emacs extensions to display the docstring of a given declaration. </p>\n<p>In this respect, I don't really see any reason to add docstrings to examples</p>",
        "id": 293585782,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1660583320
    },
    {
        "content": "<p>I think that in my mind, docgens for lean-liquid were a reality and I was following the conventions that I would use for mathlib, in this respect.</p>\n<p>Still, even if there will never be automatically generated documentation for the whole of lean-liquid, maybe the examples folder could be an exception and still have some form of (possibly rudimentary) exposed web-page.</p>",
        "id": 293586211,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1660583522
    },
    {
        "content": "<p>The correct thing to do is probably just use <code>/-!</code> for everything</p>",
        "id": 293587521,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1660584069
    },
    {
        "content": "<p>(or almost everything)</p>",
        "id": 293587536,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1660584074
    },
    {
        "content": "<p>Well, in any case, since this affects all the example files, we should probably just make whatever change we need to once the rest of the files are done.</p>",
        "id": 293589442,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1660584799
    },
    {
        "content": "<p>Yeah, I think using <code>/-!</code> everywhere makes sense.</p>",
        "id": 293590404,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1660585168
    },
    {
        "content": "<p>But in the end it doesn't matter too much I guess.</p>",
        "id": 293590957,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1660585380
    },
    {
        "content": "<p>The nice thing about something like this</p>\n<blockquote>\n<h1>A test of literate lean programming</h1>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">category_theory.limits.has_limit</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">category_theory</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">test</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span>\n</code></pre></div><br>\n</p>\n</blockquote>",
        "id": 293591202,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1660585449
    },
    {
        "content": "<p>is that it displays nicely in github</p>",
        "id": 293591223,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1660585456
    },
    {
        "content": "<blockquote>\n<h1>A test of literate lean programming</h1>\n<p>Here is a lean code block:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">category_theory.limits.has_limit</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">category_theory</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">test</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span>\n</code></pre></div>\n<p>And some more plain markdown.</p>\n</blockquote>",
        "id": 293591335,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1660585499
    },
    {
        "content": "<p>We could easily write some script to scrape the lean blocks into a separate file to ensure it compiles.</p>",
        "id": 293591424,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1660585524
    },
    {
        "content": "<p>maybe this can even be part of <code>leanproject</code>?</p>",
        "id": 293591574,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1660585578
    },
    {
        "content": "<p>Since github renders latex now, this could be a really nice feature</p>",
        "id": 293591921,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1660585712
    },
    {
        "content": "<p>I think we can look into that. But it's future work.</p>",
        "id": 293606314,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1660591294
    },
    {
        "content": "<p>I would suggest merging the Radon PR now. I'm happy with the examples file.</p>",
        "id": 293606343,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1660591307
    },
    {
        "content": "<p>We can then standardise docstrings etc in future PRs.</p>",
        "id": 293606364,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1660591318
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> <span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span> do you agree?</p>",
        "id": 293606421,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1660591327
    },
    {
        "content": "<p>I also agree!</p>",
        "id": 293606840,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1660591486
    },
    {
        "content": "<p>I clicked \"merge\"</p>",
        "id": 293608953,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1660592293
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"492774\">@Sky Wilshaw</span> recently set up <a href=\"https://leanprover-community.github.io/con-nf/docs\">docgen for Con(NF)</a> and I love it. I highly encourage you to do the same.</p>",
        "id": 293609274,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1660592423
    },
    {
        "content": "<p>But that will reveal how messy we've been!</p>",
        "id": 293609373,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1660592468
    },
    {
        "content": "<p>The first step towards redemption! <span aria-label=\"stuck out tongue wink\" class=\"emoji emoji-1f61c\" role=\"img\" title=\"stuck out tongue wink\">:stuck_out_tongue_wink:</span></p>",
        "id": 293609530,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1660592531
    },
    {
        "content": "<p>I already took a stab at fixing the type of comments in some files a while back. I could finish that up quickly if you want me to.</p>",
        "id": 293609693,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1660592613
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"369530\">@Peter Scholze</span> I think <code>examples/</code> now contains a nice set of \"demos\" to illustrate the ingredients of the main statement. Only an example of a p-Banach is missing, but that's WIP. Are there other things you would like to see?<br>\nOr do you have questions about what is currently there?</p>",
        "id": 293615709,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1660595236
    },
    {
        "content": "<p>Thanks, that looks quite convincing!</p>\n<p>Someone just told me the following psychological effect (basically confirmation bias, but I found it striking nonetheless). Person A makes up a rule of which sequences of three numbers are \"good\" (the others are \"bad\"). The job of Person B is to figure out the rule. To get started, A gives an example of a good sequence. For example, they might say \"1,2,4\" is good. Then B asks \"is 1,3,6 good?\". A: Yes. B: Is 1,4,8 good? A: Yes. B: Is 1,5,10 good? A: Yes. B: Is the rule that 1,n,2n is good? A: No. B: Is 1,6,12 good? A: Yes. B: Is 1,7,14 good? A: Yes B: But you see, the rule is that 1,n,2n is good! A: No, that is not the rule.</p>\n<p>Apparently people are much rather trying to confirm their idea of what the rule is, then trying to prove it false by finding counterexamples. (In the experiment, A chose the rule \"any increasing sequence is good\", but virtually no person B ever chose any sequence violating that...)</p>\n<p>In the case at hand, I am psychologically predisposed to think that the computer is accurately capturing the mathematics, and your examples are confirming this; sometimes you've added lots of syntactic sugar to make it look seamless. But somehow these are all \"positive\" examples. I'm not exactly sure what I'm asking for; I guess I'm just currently feeling that mathematics remains a human activity, because if I were to truly check that the computer did the right thing, I would have to unravel the whole proof in my head and convince myself that it all adds up. (You might argue that I only need to check your examples file, but I'm not sure; for one, there's too much syntax I don't really understand and where something sneaky might hide; for the other, the examples files don't actually contain the definitions (because those need a lot of background...), so the above tale on confirmation bias becomes relevant, I think.)</p>\n<p>PS: In line 32 of Ext.lean, you say that the example gives the isomorphism of Ext-groups <em>functorially in X</em> (but not Y?). Why is functoriality in X built in? To me the statement reads like a non-functorial isomorphism. (Which probably just confirms that I don't actually understand what the Lean code means...)</p>",
        "id": 293659809,
        "sender_full_name": "Peter Scholze",
        "timestamp": 1660629819
    },
    {
        "content": "<p>Thanks for your input! I very much agree that mathematics is a human activity. But I also think that using a computer is a human activity (-;<br>\nI guess your 3-number-sequence tale is saying that we should somehow look for counter-counter-examples? Not sure what that means...</p>",
        "id": 293662562,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1660632049
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"369530\">Peter Scholze</span> <a href=\"#narrow/stream/267928-condensed-mathematics/topic/Real.20measures/near/293659809\">said</a>:</p>\n<blockquote>\n<p>PS: In line 32 of Ext.lean, you say that the example gives the isomorphism of Ext-groups <em>functorially in X</em> (but not Y?). Why is functoriality in X built in? To me the statement reads like a non-functorial isomorphism. (Which probably just confirms that I don't actually understand what the Lean code means...)</p>\n</blockquote>\n<p>Good point. It is actually functorial on both objects. But as you rightly observe the statement as written only gives an isomorphism on objects and doesn't treat morphisms at all. So the documentation on the line above is not exactly in sync with the Lean code.</p>",
        "id": 293662842,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1660632223
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/267928-condensed-mathematics/topic/Real.20measures/near/293662842\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"369530\">Peter Scholze</span> <a href=\"#narrow/stream/267928-condensed-mathematics/topic/Real.20measures/near/293659809\">said</a>:</p>\n<blockquote>\n<p>PS: In line 32 of Ext.lean, you say that the example gives the isomorphism of Ext-groups <em>functorially in X</em> (but not Y?). Why is functoriality in X built in? To me the statement reads like a non-functorial isomorphism. (Which probably just confirms that I don't actually understand what the Lean code means...)</p>\n</blockquote>\n<p>Good point. It is actually functorial on both objects. But as you rightly observe the statement as written only gives an isomorphism on objects and doesn't treat morphisms at all. So the documentation on the line above is not exactly in sync with the Lean code.</p>\n</blockquote>\n<p>Well, please make sure the comments and the Lean code <em>are</em> in sync. In that example, I could \"feel\" that something is not quite right. For some of the claims about Radon measures, there's too much syntax for me to understand what's really going on, and I simply have to trust you that the Lean code means what you write in the comments.</p>",
        "id": 293669092,
        "sender_full_name": "Peter Scholze",
        "timestamp": 1660636040
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"369530\">@Peter Scholze</span> If there is Lean code in <code>examples/*</code> that you cannot read, that means we didn't do our homework well. Please flag such lines, so that we can try to improve them.</p>",
        "id": 293669296,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1660636142
    },
    {
        "content": "<p>Let me flag two things: </p>\n<p>\"(f + g).down.val s = f.down.val s + g.down.val s\" -- I have no idea what .down.val means.</p>\n<p>\"inducing (Œª Œº : filtration (S.Radon_png p) c, embedding_into_the_weak_dual p S Œº) := ‚ü®rfl‚ü©\" -- Here I think I'm confused why you have to write some \\lambda code (which I kind of understand, but is very far from mathematical notation); can you not simply use the map embedding_into_the_weak_dual ? Or is the code just about restricting to a filtration step?</p>",
        "id": 293670017,
        "sender_full_name": "Peter Scholze",
        "timestamp": 1660636475
    },
    {
        "content": "<p>Also, what you call \"embedding\" is only a map in the Lean code.</p>",
        "id": 293670088,
        "sender_full_name": "Peter Scholze",
        "timestamp": 1660636509
    },
    {
        "content": "<p>I guess strictly speaking with your examples, everything could be zero. You would have to argue that the elements constructed via the example on line 96 give the expected linear functionals on continuous functions, otherwise those example elements might just be zero.</p>",
        "id": 293670300,
        "sender_full_name": "Peter Scholze",
        "timestamp": 1660636605
    },
    {
        "content": "<p>Maybe another required example file would be for profinite sets, actually. Maybe all your profinite sets in universe level 0 are just finite sets?</p>",
        "id": 293670452,
        "sender_full_name": "Peter Scholze",
        "timestamp": 1660636684
    },
    {
        "content": "<p>Regarding the \\lambda code: I must admit that it took me a long time to realize that this is not about two elements \\lambda and \\mu of filtration (S.Radon_png p) c!</p>",
        "id": 293670652,
        "sender_full_name": "Peter Scholze",
        "timestamp": 1660636797
    },
    {
        "content": "<p>Also, in this \\lambda-code line: Why is the rfl in angle brackets?</p>",
        "id": 293671011,
        "sender_full_name": "Peter Scholze",
        "timestamp": 1660636945
    },
    {
        "content": "<p>Also, in Ext.lean, you can't seriously imagine I can read a line like</p>\n<p>\"example (n : ‚Ñï) (X Y : ùìê) : ((Ext' n).obj (op X)).obj Y =<br>\n  ((Ext n).obj (op ((single _ 0).obj X))).obj ((single _ 0).obj Y)\"</p>\n<p><span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 293671867,
        "sender_full_name": "Peter Scholze",
        "timestamp": 1660637384
    },
    {
        "content": "<p>Ok, that's useful feedback! We'll try to improve things!</p>",
        "id": 293672122,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1660637500
    },
    {
        "content": "<p>Sorry for playing devil's advocate here!</p>",
        "id": 293672231,
        "sender_full_name": "Peter Scholze",
        "timestamp": 1660637540
    },
    {
        "content": "<p>Actually, can you explain what the \".obj\" is doing?</p>",
        "id": 293672482,
        "sender_full_name": "Peter Scholze",
        "timestamp": 1660637654
    },
    {
        "content": "<p>Is it that a functor is some bundled information, and in particular it's a map on objects, and one has to say that explicitly?</p>",
        "id": 293672566,
        "sender_full_name": "Peter Scholze",
        "timestamp": 1660637701
    },
    {
        "content": "<p>I'm sure you've already tried to make the API for functors nicer, but it would really be good if Lean could figure out itself that if you apply a functor to something whose type is that of an object of the source category, it's supposed to apply the map on objects (while if the type is that of morphism between objects, it applies the map on morphisms)</p>",
        "id": 293672797,
        "sender_full_name": "Peter Scholze",
        "timestamp": 1660637848
    },
    {
        "content": "<p>Yes, unfortunately we have to write <code>F.obj X</code> and <code>F.map f</code> at the moment. We tried to have better notation, so that you could just write <code>F X</code> and <code>F f</code>, but it was too brittle. However, we have good hopes that in Lean 4 we can actually make this work.</p>",
        "id": 293675567,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1660639304
    },
    {
        "content": "<p>In fact I was discussing this just yesterday (making Lean understand that for <code>F : C ‚•§ D</code>, <code>X Y : C</code>, <code>f : X ‚ü∂ Y</code>, <code>F X</code> means <code>F.obj X</code> and <code>F f</code> means <code>F.map f</code>) and the <code>.obj</code> bit is fine. What's not is the <code>.map</code> one because it's a function dependent in <code>X</code> and <code>Y</code> in a way that subtly exceeds the limits of our current system.</p>",
        "id": 293675726,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1660639382
    },
    {
        "content": "<p>The way to do this currently is using <a href=\"https://leanprover-community.github.io/mathlib_docs/find/has_coe_to_fun\">docs#has_coe_to_fun</a>. <code>has_coe_to_fun Œ± Œ≤</code> (<code>Œ± : Type*</code>, <code>Œ≤ : Œ± ‚Üí Sort*</code>) means that <code>a : Œ±</code> can be thought of as a map of type <code>Œ≤ a</code>. So what we would want is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">has_coe_to_fun</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"bp\">‚•§</span> <span class=\"n\">D</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">Œª</span> <span class=\"n\">F</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">‚ü∂</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"bp\">‚Üí</span> <span class=\"o\">(</span><span class=\"n\">F.obj</span> <span class=\"n\">X</span> <span class=\"bp\">‚ü∂</span> <span class=\"n\">F.obj</span> <span class=\"n\">Y</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n</code></pre></div>\n<p>but <code>Œª F, (X ‚ü∂ Y) ‚Üí (F.obj X ‚ü∂ F.obj Y)</code> depends on <code>X</code> and <code>Y</code>, which do not appear in the <code>C ‚•§ D</code> argument. Mathematically, this is because a functor is not actually two maps, but a map on objects and many maps on homs.</p>",
        "id": 293676385,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1660639745
    },
    {
        "content": "<p>Wait, it <em>is</em> actually two maps, if you quantify over <code>X</code> and <code>Y</code>. So the following works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">category_theory.functor.basic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">category_theory</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"n\">D</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">category</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">category</span> <span class=\"n\">D</span><span class=\"o\">]</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_coe_to_fun</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"bp\">‚•§</span> <span class=\"n\">D</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">Œª</span> <span class=\"n\">F</span><span class=\"o\">,</span> <span class=\"bp\">‚àÄ</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">},</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">‚ü∂</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"bp\">‚Üí</span> <span class=\"o\">(</span><span class=\"n\">F.obj</span> <span class=\"n\">X</span> <span class=\"bp\">‚ü∂</span> <span class=\"n\">F.obj</span> <span class=\"n\">Y</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"o\">‚ü®</span><span class=\"bp\">Œª</span> <span class=\"n\">F</span> <span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">F.map</span> <span class=\"n\">f</span><span class=\"o\">‚ü©</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">‚ü∂</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"bp\">‚•§</span> <span class=\"n\">D</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">F</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">F.map</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 293676939,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1660640026
    },
    {
        "content": "<p>But now you want a map on the objects as well, so you need a second <code>has_coe_to_fun</code>. And this is where things go haywire</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">category_theory.functor.basic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">category_theory</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"n\">D</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">category</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">category</span> <span class=\"n\">D</span><span class=\"o\">]</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">obj_coe</span> <span class=\"o\">:</span> <span class=\"n\">has_coe_to_fun</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"bp\">‚•§</span> <span class=\"n\">D</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">Œª</span> <span class=\"n\">F</span><span class=\"o\">,</span> <span class=\"n\">C</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">D</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">‚ü®</span><span class=\"bp\">Œª</span> <span class=\"n\">F</span><span class=\"o\">,</span> <span class=\"n\">F.obj</span><span class=\"o\">‚ü©</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">hom_coe</span> <span class=\"o\">:</span> <span class=\"n\">has_coe_to_fun</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"bp\">‚•§</span> <span class=\"n\">D</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">Œª</span> <span class=\"n\">F</span><span class=\"o\">,</span> <span class=\"bp\">‚àÄ</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">},</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">‚ü∂</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"bp\">‚Üí</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">X</span> <span class=\"bp\">‚ü∂</span> <span class=\"n\">F</span> <span class=\"n\">Y</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"o\">‚ü®</span><span class=\"bp\">Œª</span> <span class=\"n\">F</span> <span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">F.map</span> <span class=\"n\">f</span><span class=\"o\">‚ü©</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">‚ü∂</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"bp\">‚•§</span> <span class=\"n\">D</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">F</span> <span class=\"n\">X</span> <span class=\"bp\">‚ü∂</span> <span class=\"n\">F</span> <span class=\"n\">Y</span> <span class=\"o\">:=</span> <span class=\"n\">F</span> <span class=\"n\">f</span> <span class=\"c1\">-- Lean confused</span>\n</code></pre></div>",
        "id": 293677167,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1660640119
    },
    {
        "content": "<p>If you want to understand what's going on, you need to know what <a href=\"https://leanprover-community.github.io/mathlib_docs/find/out_param\">docs#out_param</a> does and I highly encourage you read <span class=\"user-mention\" data-user-id=\"238446\">@Anne Baanen</span>'s recent <a href=\"https://arxiv.org/abs/2202.01629\">paper on bundled hom typeclasses</a>.</p>",
        "id": 293677385,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1660640224
    },
    {
        "content": "<p>In short, Lean doesn't try to guess whether you mean to use <code>F : C ‚•§ D</code> as a <code>C ‚Üí D</code> or as a <code>‚àÄ {X Y : C}, (X ‚ü∂ Y) ‚Üí (F X ‚ü∂ F Y)</code> for performance reasons. So it picks whichever it finds first, which is doomed to fail half of the time.</p>",
        "id": 293677676,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1660640376
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/267928-condensed-mathematics/topic/Real.20measures/near/293672122\">said</a>:</p>\n<blockquote>\n<p>Ok, that's useful feedback! We'll try to improve things!</p>\n</blockquote>\n<p>Agreed! That's very useful! It's easy for us to forget that Lean3 is still a different language.</p>",
        "id": 293701861,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1660651377
    },
    {
        "content": "<p>Here's a start on the profinite example file<br>\n<a href=\"https://github.com/leanprover-community/lean-liquid/pull/115\">https://github.com/leanprover-community/lean-liquid/pull/115</a></p>\n<p>Two additional things that could potentially be added, if you think it's worthwhile:</p>\n<ol>\n<li>Explain how to view a profinite set as a limit of finite sets.</li>\n<li>Explain how the proetale topology is defined</li>\n</ol>",
        "id": 293704316,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1660652390
    },
    {
        "content": "<p>More generally, I would say the example files are not about fully checking the defs all the way down to the axioms, but rather all the way down to mathlib.</p>",
        "id": 293705735,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1660652983
    },
    {
        "content": "<p>We didn't do that in some cases (e.g. mathlib doesn't have delta functors), but I think that's what we should aim for (within reason)</p>",
        "id": 293706149,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1660653123
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"369530\">Peter Scholze</span> <a href=\"#narrow/stream/267928-condensed-mathematics/topic/Real.20measures/near/293671867\">said</a>:</p>\n<blockquote>\n<p>Also, in Ext.lean, you can't seriously imagine I can read a line like</p>\n<p>\"example (n : ‚Ñï) (X Y : ùìê) : ((Ext' n).obj (op X)).obj Y =<br>\n  ((Ext n).obj (op ((single _ 0).obj X))).obj ((single _ 0).obj Y)\"</p>\n<p><span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>\n</blockquote>\n<p>I'm going to introduce a coe to fun for functors just on the object level. Also, I'm introducing a coercion from an abelian category to the bounded homotopy category <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi><mo>‚Ü¶</mo><mi>X</mi><mo stretchy=\"false\">[</mo><mn>0</mn><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">X \\mapsto X[0]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6943em;vertical-align:-0.011em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">‚Ü¶</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mopen\">[</span><span class=\"mord\">0</span><span class=\"mclose\">]</span></span></span></span>. With those tricks, we have</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/--</span>\n<span class=\"sd\">`Ext' n (X,B)` is definitionally equal to `Ext n (X, B)`.</span>\n<span class=\"sd\">We have to manually tell Lean that a coercion is involved in this case using `‚Üë`.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñï</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"bp\">ùìê</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">Ext'</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"n\">X</span><span class=\"o\">))</span> <span class=\"n\">Y</span> <span class=\"bp\">=</span>\n  <span class=\"o\">(</span><span class=\"n\">Ext</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"bp\">‚Üë</span><span class=\"n\">X</span><span class=\"o\">))</span> <span class=\"bp\">‚Üë</span><span class=\"n\">Y</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>I hope that looks a bit more reasonable?</p>",
        "id": 293711868,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1660655305
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/lean-liquid/pull/116\">https://github.com/leanprover-community/lean-liquid/pull/116</a><br>\nI addressed most of Peter's comments above. Please feel free to push to this branch with further fixes!</p>",
        "id": 293718699,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1660656622
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Ya√´l Dillies</span> Could you summarize this functor map issue and post it as an MWE on <a class=\"stream\" data-stream-id=\"270676\" href=\"/#narrow/stream/270676-lean4\">#lean4</a> ? We might need to do something special to make it work.</p>",
        "id": 293767998,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1660671605
    },
    {
        "content": "<p>Sure!</p>",
        "id": 293768033,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1660671623
    },
    {
        "content": "<p>Can this be accomplished in lean4 with unification hints?</p>",
        "id": 293768506,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1660671833
    },
    {
        "content": "<p>Really just having <code>F X</code> for <code>F.obj X</code> would already be nice. I know this was discussed in the olden days of lean-category-theory. I can't remember what the specific reason for not supporting it was.</p>",
        "id": 293768618,
        "sender_full_name": "Reid Barton",
        "timestamp": 1660671866
    },
    {
        "content": "<p>Maybe <span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> knows? It could well be something that no longer makes sense in the context of current mathlib</p>",
        "id": 293770389,
        "sender_full_name": "Reid Barton",
        "timestamp": 1660672532
    },
    {
        "content": "<p>I got this to work in Lean4.... but it feels hacky and it probably won't scale</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">Quiver</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">hom</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">A</span> <span class=\"bp\">‚Üí</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">PreFunctor</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Quiver</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Quiver</span> <span class=\"n\">B</span><span class=\"o\">]</span> <span class=\"n\">where</span>\n  <span class=\"n\">obj</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">B</span>\n  <span class=\"n\">map</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">}</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">Quiver.hom</span> <span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">Quiver.hom</span> <span class=\"o\">(</span><span class=\"n\">obj</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">obj</span> <span class=\"n\">Y</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Quiver</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Quiver</span> <span class=\"n\">B</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">CoeFun</span> <span class=\"o\">(</span><span class=\"n\">PreFunctor</span> <span class=\"n\">A</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">Œª</span> <span class=\"n\">F</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">A</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">coe</span> <span class=\"o\">:=</span> <span class=\"n\">PreFunctor.obj</span>\n\n<span class=\"kd\">notation</span> <span class=\"n\">F</span> <span class=\"n\">O</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">PreFunctor.map</span> <span class=\"n\">F</span> <span class=\"n\">O</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Quiver</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Quiver</span> <span class=\"n\">B</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">PreFunctor</span> <span class=\"n\">A</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"o\">:=</span> <span class=\"n\">F</span> <span class=\"n\">X</span>\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Quiver</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Quiver</span> <span class=\"n\">B</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">PreFunctor</span> <span class=\"n\">A</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Quiver.hom</span> <span class=\"n\">X</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Quiver.hom</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">F</span> <span class=\"n\">f</span>\n</code></pre></div>",
        "id": 293780269,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1660676045
    },
    {
        "content": "<p>Removing the <code>: B</code> in the last line breaks the last example</p>",
        "id": 293780385,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1660676091
    },
    {
        "content": "<p>Another option</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">Quiver</span> <span class=\"n\">where</span>\n  <span class=\"n\">carrier</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span>\n  <span class=\"n\">hom</span> <span class=\"o\">:</span> <span class=\"n\">carrier</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">carrier</span> <span class=\"bp\">‚Üí</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">CoeSort</span> <span class=\"n\">Quiver</span> <span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">where</span> <span class=\"n\">coe</span> <span class=\"o\">:=</span> <span class=\"n\">Quiver.carrier</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">PreFunctor</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">Quiver</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">obj</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">B</span>\n  <span class=\"n\">map</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">}</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">A.hom</span> <span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">B.hom</span> <span class=\"o\">(</span><span class=\"n\">obj</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">obj</span> <span class=\"n\">Y</span><span class=\"o\">)</span>\n\n<span class=\"kd\">notation</span> <span class=\"n\">F</span> <span class=\"n\">O</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">PreFunctor.obj</span> <span class=\"n\">F</span> <span class=\"n\">O</span>\n<span class=\"kd\">notation</span> <span class=\"n\">F</span> <span class=\"n\">O</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">PreFunctor.map</span> <span class=\"n\">F</span> <span class=\"n\">O</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">Quiver</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">PreFunctor</span> <span class=\"n\">A</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"o\">:=</span> <span class=\"n\">F</span> <span class=\"n\">X</span>\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">Quiver</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">PreFunctor</span> <span class=\"n\">A</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">A.hom</span> <span class=\"n\">X</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">B.hom</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">F</span> <span class=\"n\">f</span>\n</code></pre></div>",
        "id": 293783766,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1660677417
    },
    {
        "content": "<p>Harris wrote</p>\n<blockquote>\n<p>Thus formalization inevitably requires a human decision to read a proposed formalization as a translation of the human proof: in other words an act of faith, like the acts of faith that sustain human mathematics in this first half of the 21st century ‚Äî in the refereeing process, in the published documents, and in the seminar room.  Formalization can only eliminate the epistemological antinomies if humans are excluded from the process entirely, and the machines are left to sort it out among themselves.  </p>\n</blockquote>\n<p>over at <a href=\"https://siliconreckoner.substack.com/p/game-over-for-mathematicians\">https://siliconreckoner.substack.com/p/game-over-for-mathematicians</a> .<br>\nI guess that it's the same kind of thing that Peter was also talking about when he said that mathematics remains a human activity.</p>",
        "id": 295042062,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1661346245
    },
    {
        "content": "<p>I realize that Harris is talking about the translation here, and I agree with the sentiment that mathematics remains a human activity, but I think Harris has missed a key distinction. In mathematics as practiced today, the act of faith is in the <em>proofs</em> of the proposed results. Definitions are (and have been) frequently taken for granted. In fact, we often conflate multiple definitions for convenience by appealing to some notion of equivalence between the two. If I go to a conference on C‚ãÜ-algebras and start talking about them, no one will wonder whether or not I'm talking about a different definition than the one they are used to; in this sense, definitions (frequently) are an <em>implicit</em> act of faith.</p>\n<p>In contrast, when formalizing, it is <em>only</em> the definitions that one must take on faith, assuming one can adequately parse the statements of the theorems. In so doing, we have completely eliminated the previously required act of faith, and only now do we (i.e., your everyday mathematicians) realize that the implicit act of faith for definitions really should have been explicit all along. </p>\n<p>Moreover, by formalizing enough theorems, one can verify the usual behavior of a given object, thereby minimizing the possibility that they are defined in a way sufficiently different to cause problems. That is, if it looks like a duck and quacks like a duck, it is generally (although admittedly not always) a duck.</p>\n<p>So, does formalization completely eliminate all acts of faith for a human to \"verify\" for themselves the correctness of a certain theorem? No, but it greatly shifts where our faith rests.</p>",
        "id": 295058844,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1661351425
    },
    {
        "content": "<p>Also, when formalizing, you know that someone talking about X is necessarily using the same definition of X as everyone else using the same system.</p>",
        "id": 295066469,
        "sender_full_name": "Fr√©d√©ric Dupuis",
        "timestamp": 1661353931
    },
    {
        "content": "<p>... when formalizing <em>in mathlib</em>, at least.</p>",
        "id": 295083924,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1661359215
    },
    {
        "content": "<p>at least, if both people are using the same version of mathlib <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 295085850,
        "sender_full_name": "Reid Barton",
        "timestamp": 1661359878
    },
    {
        "content": "<blockquote>\n<p>‚ÄúWe are very good at figuring out things that computers can‚Äôt do. If we were to imagine a future in which all the theorems we currently know about could be proven on a computer, we would just figure out other things that a computer can‚Äôt solve, and that would become ‚Äòmathematics.‚Äô ‚Äù</p>\n</blockquote>",
        "id": 295092212,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1661361777
    },
    {
        "content": "<p>Ellenberg's quote <a href=\"https://www.quantamagazine.org/in-computers-we-trust-20130222/\">here</a> has stayed with me</p>",
        "id": 295092346,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1661361837
    },
    {
        "content": "<p>I guess my perspective here was that for this project, it's unfeasible to check the definitions. To a human it's easier to convince themselves that there are enough ideas in there to get a proof, than to say with absolute certainty that all the definitions entering the theorem statement are correct.</p>\n<p>Even after your example files, it could be that a lot of things are secretly zero, and it's an absolute impossibility for me to read enough of the Lean code to check all your definitions -- it's just way too much buildup! (And this checking would require me to have a much better understanding of Lean's syntax.)</p>\n<p>Arguably, this issue becomes less pressing once a lot of stuff is in a trusted library like mathlib. So if somebody proves a theorem and formalizes it, then the referee has an easy job if all the definitions entering their main theorem are in that library. But much of the development of mathematics lies in finding good definitions! So in a paper with new definitions and theorems <em>about those new definitions</em>, the refereeing process will be almost as tedious as before, if not more (as now one has to be make sure the definitions are absolutely correct before they can be allowed to enter the library).</p>\n<p>What happened in the first half of LTE is that I could really see how you were following the manuscript line-by-line and, in the process of carefully translating it into Lean, catching a number of small slips. This type of process is certainly something where formal proof verification is doing an excellent job, and it really radically changed my confidence in the argument. However, the second half of LTE has not added anything to my confidence (but it was already at 100% ;-) , so maybe that's not saying much). But of course it's a really impressive achievement to get all this mathematical machinery done in Lean!</p>",
        "id": 295358650,
        "sender_full_name": "Peter Scholze",
        "timestamp": 1661493502
    },
    {
        "content": "<p>That's actually an interesting observation, I think. Because initially, I think part of the reasoning for making 9.1 the final goal of the challenge as opposed to 9.4/9.5 was that it is easy to check the statement of 9.1 whereas checking that we got all the definition entering into 9.4/9.5 right would be a lot nastier.<br>\nAnd probably this is still true for an outsider. What I mean is that Peter is probably one of the few people (Dustin being another)</p>\n<blockquote>\n<p>[I]n the first half of LTE is that I could really see how you were following the manuscript line-by-line and, in the process of carefully translating it into Lean, catching a number of small slips. This type of process is certainly something where formal proof verification is doing an excellent job, and it really radically changed my confidence in the argument.</p>\n</blockquote>\n<p>could be true. And for the rest of the world, it is a lot easier to be convinced by a formal verification of 9.1 then by the results of the first half that led up to 9.4/9.5.</p>",
        "id": 295365240,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1661497296
    },
    {
        "content": "<p>Yes, that's right. I think for an outsider, it's definitely easier to be convinced by reading some of the definitions and examples that you give, in order to trust that you probably have the definitions right, and to read the final statement (which certainly is very clean!). But I'd argue that this process will not get up to 100% confidence, and I feel that in this specific situation for me, the confidence level I can get via this procedure is below the one I have via other means.</p>",
        "id": 295369133,
        "sender_full_name": "Peter Scholze",
        "timestamp": 1661499406
    },
    {
        "content": "<p>I do think that these observations have never really showed up before.</p>",
        "id": 295369577,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1661499634
    },
    {
        "content": "<p>In other big projects, like 4CT, Odd-Order, Kepler, etc... checking the statement is feasible for most people after they spend a little amount of time learning some syntax.</p>",
        "id": 295369662,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1661499681
    },
    {
        "content": "<p>This feels a little like the P vs NP distinction, possibly in reverse: some statements are easy to parse, but their proofs are hard.  With the P vs NP analogy, parsing the statement is P, while proving it is NP.</p>\n<p>This is probably what happens in the (most) of the examples of formalization so far.</p>\n<p>In the case of LTE, even the statement is diffcult to parse, regardless of whether it is the formalized statement or the \"informal\" one.</p>",
        "id": 295375255,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1661502246
    },
    {
        "content": "<p>I agree.</p>\n<p>I guess something I've said a while ago (incidentally in an e-mail to Michael Harris...) is relevant here again: To me, the main obstacle in writing papers is often not finding the proofs, but finding the \"right\" definitions, and stating the \"relevant\" theorems. If this is done right, the proofs almost come for free. But for such papers, formalization is of little use -- they could only ever check the proofs (and catch the occasional slip), but those were always the part that was relatively straightforward.</p>",
        "id": 295376309,
        "sender_full_name": "Peter Scholze",
        "timestamp": 1661502770
    },
    {
        "content": "<p>The proof in LTE really is one of the few examples where I thought we had the right definitions and stated the relevant theorem, but the proof was still hard and unintuitive.</p>",
        "id": 295376823,
        "sender_full_name": "Peter Scholze",
        "timestamp": 1661503030
    },
    {
        "content": "<p>Do you think the situation for this particular proof has changed compared to 2 years ago?</p>",
        "id": 295377455,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1661503340
    },
    {
        "content": "<p>E.g. by the insight that Gordan's lemma plays a non-trivial key role.</p>",
        "id": 295377519,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1661503383
    },
    {
        "content": "<p>What do you mean by \"the situation\"? If you mean that I find it hard and unintuitive, that's gotten slightly better, but is still true.</p>",
        "id": 295377526,
        "sender_full_name": "Peter Scholze",
        "timestamp": 1661503387
    },
    {
        "content": "<p>Yeah, that's what I meant.</p>",
        "id": 295377544,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1661503401
    },
    {
        "content": "<p>It's still the case that I have not been able to convey the idea of the proof in speaking to any other mathematician...</p>",
        "id": 295377614,
        "sender_full_name": "Peter Scholze",
        "timestamp": 1661503440
    },
    {
        "content": "<p>i.e., of the kind that even if they did not fully understand all the details, they could not go home and reconstruct the argument from the hints I gave</p>",
        "id": 295377721,
        "sender_full_name": "Peter Scholze",
        "timestamp": 1661503480
    },
    {
        "content": "<p>Maybe some definitions are still missing? But they would probably not be used outside this proof.</p>",
        "id": 295377767,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1661503512
    },
    {
        "content": "<p>LTE builds a lot more theory around pseudo-normed groups. But I understand that this doesn't really pay off on paper.</p>",
        "id": 295377888,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1661503565
    },
    {
        "content": "<p>Well, that's certainly a relevant notion, and I've certainly toyed around with making a bit more theory there. But it doesn't really get to the heart of the matter...</p>",
        "id": 295377968,
        "sender_full_name": "Peter Scholze",
        "timestamp": 1661503615
    },
    {
        "content": "<p>I think the hardest bit is maybe the \"normed homological algebra\". You would like to say \"assume that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> is a <em>splittable</em> pseudo-normed group, then it is <em>just</em> a spectral sequence argument\".</p>",
        "id": 295378007,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1661503637
    },
    {
        "content": "<p>Proving that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mover accent=\"true\"><mi mathvariant=\"script\">M</mi><mo>Àâ</mo></mover></mrow><annotation encoding=\"application/x-tex\">\\bar{\\mathcal{M}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8201em;\"></span><span class=\"mord accent\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8201em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord mathcal\">M</span></span><span style=\"top:-3.2523em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"accent-body\" style=\"left:-0.1667em;\"><span class=\"mord\">Àâ</span></span></span></span></span></span></span></span></span></span> is splittable boils down to Gordan's lemma. That part is quite intuitive, I think.</p>",
        "id": 295378064,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1661503672
    },
    {
        "content": "<p>But even the statement of 9.5 is pretty gnarly, because of all the norms and inequalities.</p>",
        "id": 295378180,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1661503729
    },
    {
        "content": "<p>Hmm yes. The problem is that all these notions come with their own <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>œµ</mi></mrow><annotation encoding=\"application/x-tex\">\\epsilon</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">œµ</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Œ¥</mi></mrow><annotation encoding=\"application/x-tex\">\\delta</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03785em;\">Œ¥</span></span></span></span>, etc.</p>",
        "id": 295378183,
        "sender_full_name": "Peter Scholze",
        "timestamp": 1661503732
    },
    {
        "content": "<p>Right, if that could somehow be packaged up in a convenient way, then there might be a chance that 9.6 + 9.6=&gt;9.5 becomes \"just a spectral sequence\" argument.</p>",
        "id": 295378245,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1661503775
    },
    {
        "content": "<p>For the pseudonormed stuff, there was some really nice discussion also here on the chat about possible formalizations (as some monoidal functors from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"double-struck\">R</mi><mrow><mo>‚â•</mo><mn>0</mn></mrow></msub></mrow><annotation encoding=\"application/x-tex\">\\mathbb R_{\\geq 0}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9341em;vertical-align:-0.2452em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">R</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mrel mtight\">‚â•</span><span class=\"mord mtight\">0</span></span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2452em;\"><span></span></span></span></span></span></span></span></span></span> or something), but nothing really gives a nice abelian category or anything</p>",
        "id": 295378268,
        "sender_full_name": "Peter Scholze",
        "timestamp": 1661503789
    },
    {
        "content": "<p>I think one example of such \"convenient packaging\" is big-O notation. Of course that doesn't help us here. But maybe a suitable analogue could be made.</p>",
        "id": 295378721,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1661504018
    },
    {
        "content": "<p>So that once that notation is in place, you can run an \"algebraic\" argument.</p>",
        "id": 295378772,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1661504043
    },
    {
        "content": "<p>I very much would want to have such a repackaging of the proof!</p>",
        "id": 295383193,
        "sender_full_name": "Peter Scholze",
        "timestamp": 1661505859
    },
    {
        "content": "<p>I spent the last week or so, trying to see where there is movement in the proof. But (unsurprisingly) there is very little flexibility. There are two ideas that I feel I haven't exhausted yet:</p>\n<ol>\n<li>The original proof has to deal with the very inexplicit nature of Breen--Deligne resolutions. Can we get some juice out of working with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>Q</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">‚Ä≤</mo></msup></mrow><annotation encoding=\"application/x-tex\">Q&#x27;</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9463em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">Q</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">‚Ä≤</span></span></span></span></span></span></span></span></span></span></span></span>?</li>\n<li>The original proof uses in one very particular place that deep restrictions have a small operator norm. Can we use this to our advantage in more places?</li>\n</ol>",
        "id": 296051085,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1661845341
    }
]
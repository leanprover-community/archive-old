[
    {
        "content": "<p>A little project: develop some API for <code>torsion_free</code>.<br>\nIf we want to do this mathlib style, then we probably need:</p>\n<p>Definitions:</p>\n<ul>\n<li>torsion free modules <code>module.torsion_free</code>?</li>\n<li>torsion free (additive) groups <code>torsion_free</code>/<code>add_torsion_free</code>?</li>\n<li>(do we care about the noncommutative case?)</li>\n</ul>\n<p>Glue:</p>\n<ul>\n<li>glue between the two additive notions</li>\n</ul>\n<p>API:</p>\n<ul>\n<li>finite <code>direct_sum</code> of add_groups / modules</li>\n<li>subgroups/submodules</li>\n</ul>",
        "id": 227615409,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614180475
    },
    {
        "content": "<p>What's the definition of torsion-free over rings with zero divisors?</p>",
        "id": 227615535,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614180517
    },
    {
        "content": "<p>I guess now that we have regular elements in mathlib (right?) we can say that the module has no torsion with respect to every regular element.</p>",
        "id": 227615629,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614180560
    },
    {
        "content": "<p>I think we can also choose to only develop the notion for modules. But when someone shows up and wants to apply it to a multiplicative group, we'll need to duplicate the API at that point.</p>",
        "id": 227616065,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614180715
    },
    {
        "content": "<p>Maybe that's even better, because then we can crystallize the API just in the module case, and afterwards the copy-pasta should be straightforward when we want to adapt it to groups.</p>",
        "id": 227616168,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614180747
    },
    {
        "content": "<p>Oh, I just noticed that <code>is_regular</code> is defined for anything with <code>has_mul</code> <span aria-label=\"rofl\" class=\"emoji emoji-1f923\" role=\"img\" title=\"rofl\">:rofl:</span></p>",
        "id": 227616438,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614180843
    },
    {
        "content": "<p>I am not sure whether the definition of <code>is_regular</code> already applies to modules, but if it does not apply \"as is\", it should really be defined by saying that a scalar <code>r</code> is regular for a module <code>M</code> should mean that smultiplication by <code>r</code> is injective.</p>",
        "id": 227622307,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1614182641
    },
    {
        "content": "<p>For instance, I would say that <code>1 : \\Z</code> is regular on <code>zmod 2</code>, but <code>2</code> is not.  I have not thought too much about the case in which the module is not faithful, though, so I am not sure whether down the line, you would like to avoid these cases...</p>",
        "id": 227622971,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1614182800
    },
    {
        "content": "<p>So here's a definition that works in general:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.regular</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">mul_action</span> <span class=\"n\">M</span> <span class=\"n\">X</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">torsion_free</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">),</span> <span class=\"n\">is_regular</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">function.injective</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"n\">m</span> <span class=\"bp\">•</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 227646477,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614190676
    },
    {
        "content": "<p>But to get torsion-free groups out of this, we have to do some gymnastics:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- is this somewhere?</span>\n<span class=\"kd\">instance</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">mul_action</span> <span class=\"n\">ℕ</span> <span class=\"n\">G</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"bp\">^</span><span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"n\">one_smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">mul_smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">pow_mul'</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">nat.pos_regular</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">is_regular</span> <span class=\"n\">m</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">hh</span><span class=\"o\">,</span>\n    <span class=\"n\">rwa</span> <span class=\"n\">nat.mul_right_inj</span> <span class=\"n\">h</span> <span class=\"n\">at</span> <span class=\"n\">hh</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">hh</span><span class=\"o\">,</span>\n    <span class=\"n\">rwa</span> <span class=\"n\">nat.mul_left_inj</span> <span class=\"n\">h</span> <span class=\"n\">at</span> <span class=\"n\">hh</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">nat.succ_regular</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">is_regular</span> <span class=\"o\">(</span><span class=\"n\">m</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">nat.pos_regular</span> <span class=\"o\">(</span><span class=\"n\">m</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">$</span> <span class=\"n\">nat.succ_pos</span> <span class=\"n\">_</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">cond</span> <span class=\"o\">:</span> <span class=\"n\">torsion_free</span> <span class=\"n\">ℕ</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">),</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">x</span><span class=\"bp\">^</span><span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"bp\">→</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intros</span> <span class=\"n\">n</span> <span class=\"n\">x</span> <span class=\"n\">hn</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">induction</span> <span class=\"n\">n</span> <span class=\"k\">with</span> <span class=\"n\">m</span> <span class=\"n\">hm</span><span class=\"o\">,</span> <span class=\"o\">{</span><span class=\"n\">finish</span><span class=\"o\">},</span>\n  <span class=\"n\">rw</span> <span class=\"o\">(</span><span class=\"k\">show</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span><span class=\"bp\">^</span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">),</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">)</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">refine</span> <span class=\"n\">cond</span> <span class=\"o\">(</span><span class=\"n\">m</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">nat.succ_regular</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 227646557,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614190698
    },
    {
        "content": "<p>But for torsion-free add_groups the gymnastics should be less convoluted, right?</p>",
        "id": 227649489,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614191866
    },
    {
        "content": "<p>yeah, those should have an automatic instance of a mul-action by <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Z}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Z</span></span></span></span></span>.</p>",
        "id": 227653058,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614193208
    },
    {
        "content": "<p>In the regular file there should be a lemma about nonzero elements of integral domains being regular.  I think that, with Eric's refactor, N should be an integral domain... maybe!</p>",
        "id": 227653113,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1614193226
    },
    {
        "content": "<p>Or is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">N</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{N}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">N</span></span></span></span></span> an integral semidomain?</p>",
        "id": 227653178,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614193256
    },
    {
        "content": "<p>Maybe: I'm not at my computer and cannot check...</p>",
        "id": 227653272,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1614193296
    },
    {
        "content": "<p>(that was a joke <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span> I really hope no one defines a semidomain)</p>",
        "id": 227653290,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614193306
    },
    {
        "content": "<p>Oh, but <code>domain</code> extends <code>ring</code> in mathlib.</p>",
        "id": 227653521,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614193389
    },
    {
        "content": "<p>Certainly, an N is commutative, there is a lemma that allows you to only prove left regular.</p>",
        "id": 227653537,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1614193391
    },
    {
        "content": "<p>Actually, this works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">nat.pos_regular</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">is_regular</span> <span class=\"n\">m</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">is_regular_of_cancel_monoid_with_zero</span> <span class=\"n\">h.ne.symm</span>\n</code></pre></div>",
        "id": 227665121,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1614198015
    },
    {
        "content": "<p>I learned recently that <code>lt.ne'</code> is the same as <code>lt.ne.symm</code>.</p>",
        "id": 227665950,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1614198354
    },
    {
        "content": "<p>Thanks for the characters' saving tip!</p>",
        "id": 227667068,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1614198755
    },
    {
        "content": "<p>Maybe a better name for <code>is_regular_of_cancel_monoid_with_zero</code> would be <code>is_regular_of_ne_zero</code>?</p>",
        "id": 227667346,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1614198846
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span> I like that name! Sounds good</p>",
        "id": 227668576,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614199296
    },
    {
        "content": "<p>I'll PR it tomorrow, but feel free to change it now, if you want!  I'm pretty sure no one has used the lemma yet</p>",
        "id": 227669795,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1614199710
    },
    {
        "content": "<p>PR <a href=\"https://github.com/leanprover-community/mathlib/issues/6408\">#6408</a></p>",
        "id": 227712526,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1614223676
    },
    {
        "content": "<p>Adam, the instance <code>mul_action</code> works, with the same proof, for a <code>monoid</code>.  Given an earlier discussion, maybe we should also have an instance of <code>mul_action pnat G</code>, for any semigroup <code>G</code>!  <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- is this somewhere?</span>\n<span class=\"kd\">instance</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">mul_action</span> <span class=\"n\">ℕ</span> <span class=\"n\">G</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"bp\">^</span><span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"n\">one_smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">mul_smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">pow_mul'</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 227714405,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1614225654
    },
    {
        "content": "<p>Sounds good to me!</p>",
        "id": 227715377,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614226638
    },
    {
        "content": "<p>How generally are natural-number powers defined in mathlib?</p>",
        "id": 227715388,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614226667
    },
    {
        "content": "<p>We can go as general as that...</p>",
        "id": 227715389,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614226673
    },
    {
        "content": "<p>I don't know how easy it would be to make the <code>to_additive</code> machine work there...</p>",
        "id": 227715448,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614226711
    },
    {
        "content": "<p>(if it can be made to work at all!)</p>",
        "id": 227715456,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614226723
    },
    {
        "content": "<p>yeah, the trouble is that we are switch the sides of the action</p>",
        "id": 227715660,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614226971
    },
    {
        "content": "<p>Regardless of whether we use it or not, I decided to give a try to defining <code>pnat</code> powers, but I seem to be lacking good techniques to work with them: can you suggest a better proof?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">power</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">semigroup</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">has_pow</span> <span class=\"n\">G</span> <span class=\"n\">pnat</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">pow</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n  <span class=\"n\">intros</span> <span class=\"n\">g</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n  <span class=\"n\">induction</span> <span class=\"n\">n</span> <span class=\"k\">with</span> <span class=\"n\">n</span> <span class=\"n\">n0</span><span class=\"o\">,</span>\n  <span class=\"n\">generalize'</span> <span class=\"n\">hn</span> <span class=\"o\">:</span> <span class=\"n\">n.pred</span> <span class=\"bp\">=</span> <span class=\"n\">np</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">n1</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">n.pred.succ</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">nat.succ_pred_eq_of_pos</span> <span class=\"n\">n0</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">hn</span> <span class=\"n\">at</span> <span class=\"n\">n1</span><span class=\"o\">,</span>\n  <span class=\"n\">subst</span> <span class=\"n\">n1</span><span class=\"o\">,</span>\n  <span class=\"n\">induction</span> <span class=\"n\">np</span> <span class=\"k\">with</span> <span class=\"n\">np</span> <span class=\"n\">hnp</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">g</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">hnp</span> <span class=\"n\">np.succ_pos</span> <span class=\"n\">np.pred_succ</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">g</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 227720439,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1614231106
    },
    {
        "content": "<p>In particular, I could not find a suitable \"pnat induction\" lemma in the library.</p>",
        "id": 227720499,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1614231138
    },
    {
        "content": "<p>Moreover, to then make it work, it seems that it should be proven for <code>{n // 0 &lt; n}</code> as well as for <code>pnat</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">semigroup</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">pnat</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">hm</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">m</span><span class=\"o\">}</span>\n<span class=\"k\">#check</span> <span class=\"n\">g</span> <span class=\"bp\">^</span> <span class=\"n\">n</span> <span class=\"c1\">--works</span>\n<span class=\"k\">#check</span> <span class=\"o\">(⟨</span><span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">hm</span><span class=\"o\">⟩</span> <span class=\"o\">:</span> <span class=\"n\">pnat</span><span class=\"o\">)</span> <span class=\"c1\">--works</span>\n<span class=\"k\">#check</span> <span class=\"n\">g</span> <span class=\"bp\">^</span> <span class=\"o\">(⟨</span><span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">hm</span><span class=\"o\">⟩</span> <span class=\"o\">:</span> <span class=\"n\">pnat</span><span class=\"o\">)</span>\n<span class=\"c1\">-- fails: `failed to synthesize type class instance for [...] ⊢ has_pow G {n // 0 &lt; n}`</span>\n</code></pre></div>",
        "id": 227720622,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1614231256
    },
    {
        "content": "<p>I'm not sure that going as far down as semigroups is necessary, however this might just be because everyone is always happy to stop at monoids. Damiano -- nobody uses <code>pnat</code> so it doesn't surprise me that you can't find induction. Just define pnat.rec_on and make a PR, and then apply it instead. Don't forget to tag it <code>elab_as_eliminator</code> so that lean has a better chance of figuring out the so-called \"motive\" <code>C</code>. Maybe experimenting with semigroups will be a good excuse to make <code>pnat</code> great again</p>",
        "id": 227734459,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614242124
    },
    {
        "content": "<p>Is there a strong need for <code>pnat</code> powers?</p>",
        "id": 227734497,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614242154
    },
    {
        "content": "<p>You'll have problems making an API for your current  definition because you've made it in tactic mode. Try #print ing it to see what kind of a monster it is</p>",
        "id": 227734629,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614242224
    },
    {
        "content": "<p>Not really, I don't see any harm in sticking to monoids</p>",
        "id": 227734656,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614242253
    },
    {
        "content": "<p>The issue is that with a semigroup you don't have g^0</p>",
        "id": 227734682,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614242274
    },
    {
        "content": "<p>I have no application in mind that would want an action of a <code>semigroup</code> instead of a <code>monoid</code>: in most situations that I can imagine, there is very little difficulty in extending a <code>semigroup</code> to a <code>monoid</code> by adding a \"natural\" identity.  Thus, for the moment, I would not go further down this road.  The above was mostly an experiment to work with <code>pnat</code>and I am glad that Kevin confirms that it is missing some functionality!</p>",
        "id": 227735709,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1614242909
    },
    {
        "content": "<p>Besides, I am failing to produce an element of <code>G</code> by induction.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[elab_as_eliminator]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">pnat.rec_on</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">pnat</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">pnat</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">p1</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">cases</span> <span class=\"n\">n</span> <span class=\"k\">with</span> <span class=\"n\">n</span> <span class=\"n\">n0</span><span class=\"o\">,</span>\n  <span class=\"n\">generalize'</span> <span class=\"n\">hn</span> <span class=\"o\">:</span> <span class=\"n\">n.pred</span> <span class=\"bp\">=</span> <span class=\"n\">np</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">n1</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">n.pred.succ</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">nat.succ_pred_eq_of_pos</span> <span class=\"n\">n0</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">hn</span> <span class=\"n\">at</span> <span class=\"n\">n1</span><span class=\"o\">,</span>\n  <span class=\"n\">subst</span> <span class=\"n\">n1</span><span class=\"o\">,</span>\n  <span class=\"n\">induction</span> <span class=\"n\">np</span> <span class=\"k\">with</span> <span class=\"n\">np</span> <span class=\"n\">hnp</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">p1</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">hp</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">np.succ_pos</span><span class=\"o\">⟩</span> <span class=\"o\">(</span><span class=\"n\">hnp</span> <span class=\"n\">_</span> <span class=\"n\">np.pred_succ</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">power_Np</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">semigroup</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">has_pow</span> <span class=\"n\">G</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"bp\">//</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">pow</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n  <span class=\"n\">intros</span> <span class=\"n\">g</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">pnat.rec_on</span> <span class=\"n\">n</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n<span class=\"c1\">-- fails saying</span>\n\n<span class=\"n\">invalid</span> <span class=\"bp\">'</span><span class=\"n\">pnat.rec_on'</span> <span class=\"n\">application</span><span class=\"o\">,</span> <span class=\"n\">elaborator</span> <span class=\"n\">has</span> <span class=\"n\">special</span> <span class=\"n\">support</span> <span class=\"n\">for</span> <span class=\"n\">this</span> <span class=\"n\">kind</span> <span class=\"n\">of</span> <span class=\"n\">application</span>\n<span class=\"o\">(</span><span class=\"n\">it</span> <span class=\"n\">is</span> <span class=\"n\">handled</span> <span class=\"n\">as</span> <span class=\"n\">an</span> <span class=\"s2\">\"eliminator\"</span><span class=\"o\">),</span> <span class=\"n\">but</span> <span class=\"n\">the</span> <span class=\"n\">expected</span> <span class=\"n\">type</span> <span class=\"n\">must</span> <span class=\"n\">be</span> <span class=\"n\">known</span>\n<span class=\"n\">state</span><span class=\"o\">:</span>\n<span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"bp\">?</span><span class=\"o\">,</span>\n<span class=\"n\">_inst_1</span> <span class=\"o\">:</span> <span class=\"n\">semigroup</span> <span class=\"n\">G</span><span class=\"o\">,</span>\n<span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">,</span>\n<span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"bp\">//</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">}</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">G</span>\n<span class=\"kd\">end</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>Using <code>refine</code> instead of <code>apply</code> gives:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">power_Np</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">semigroup</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">has_pow</span> <span class=\"n\">G</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"bp\">//</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">pow</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n  <span class=\"n\">intros</span> <span class=\"n\">g</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n  <span class=\"n\">refine</span> <span class=\"n\">pnat.rec_on</span> <span class=\"n\">n</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n<span class=\"c1\">-- fails saying</span>\n\n<span class=\"s2\">\"eliminator\"</span> <span class=\"n\">elaborator</span> <span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">compute</span> <span class=\"n\">the</span> <span class=\"n\">motive</span>\n<span class=\"n\">state</span><span class=\"o\">:</span>\n<span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"bp\">?</span><span class=\"o\">,</span>\n<span class=\"n\">_inst_1</span> <span class=\"o\">:</span> <span class=\"n\">semigroup</span> <span class=\"n\">G</span><span class=\"o\">,</span>\n<span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">,</span>\n<span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"bp\">//</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">}</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">G</span>\n</code></pre></div>",
        "id": 227736009,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1614243113
    },
    {
        "content": "<p>I think <code>Sort</code> needs to be replaced by <code>Sort*</code></p>",
        "id": 227736732,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614243583
    },
    {
        "content": "<p>I think <code>Sort = Prop</code></p>",
        "id": 227736756,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614243602
    },
    {
        "content": "<p>And my gut feeling is that the <code>subst</code> command is inserting an <code>eq.rec</code> which might be tough to prove things about. I'm stuck away from Lean right now but I would be tempted to write this in term mode using <code>nat.rec</code> and trying to avoid a further <code>eq.rec</code></p>",
        "id": 227737104,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614243775
    },
    {
        "content": "<p>Presumably there's pnat.pred to nat and a map the other way too and it's just a case of composing these with nat.rec</p>",
        "id": 227737276,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614243870
    },
    {
        "content": "<p>But your eliminator problems might just be the Sort issue</p>",
        "id": 227737353,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614243924
    },
    {
        "content": "<p>OK I'm at a PC, I'll give this pnat thing a go</p>",
        "id": 227742065,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614246566
    },
    {
        "content": "<p>Your <code>lemma</code> should be a <code>def</code></p>",
        "id": 227742417,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614246736
    },
    {
        "content": "<p>I was talking to a student, so I am now reading your comments!</p>",
        "id": 227744036,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1614247576
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"bp\">+</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">n.nat_pred.succ_pnat</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span> <span class=\"c1\">-- fails :-(</span>\n</code></pre></div>\n<p>This is the problem. Maybe you need the <code>eq.rec</code> to get over this.</p>",
        "id": 227745994,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614248627
    },
    {
        "content": "<p>I am also having a hard time working with this...</p>",
        "id": 227746103,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1614248676
    },
    {
        "content": "<p>the <code>subst</code> command was there, since I could not even <code>rw</code> it in the goal (which I understand I should avoid anyway, but there was already something that I found strange)</p>",
        "id": 227746185,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1614248733
    },
    {
        "content": "<p>This could be fixed by redefining <code>pnat</code> to be <code>nat</code>.</p>",
        "id": 227746283,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614248776
    },
    {
        "content": "<p>I would like that.  In fact, I would like to define a <code>nat</code> depending on a <code>nat</code> to stand for the \"naturals at least equal to _\"!</p>",
        "id": 227746403,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1614248855
    },
    {
        "content": "<p>With the <code>Sort*</code>, the induction applied to the definition of <code>has_pow</code> and it was easy:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">power_Np</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">semigroup</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">has_pow</span> <span class=\"n\">G</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"bp\">//</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">pow</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">g</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"o\">((</span><span class=\"n\">pnat.rec_on</span> <span class=\"n\">n</span> <span class=\"n\">id</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">m</span> <span class=\"n\">pm1</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">pm1</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">g</span><span class=\"o\">))</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>However, as you predicted, the lemma</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">pow_one</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">semigroup</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">g</span> <span class=\"bp\">^</span> <span class=\"o\">(⟨</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">nat.one_pos</span><span class=\"o\">⟩</span> <span class=\"o\">:</span> <span class=\"n\">pnat</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"o\">:=</span>\n</code></pre></div>\n<p>went from being <code>rfl</code> to being not soluble by me!</p>",
        "id": 227746748,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1614249029
    },
    {
        "content": "<p>I think that I will give up: I am not sure how to make progress on this, and I am also not in need for defining induction or powers using <code>pnat</code>.</p>",
        "id": 227747145,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1614249251
    },
    {
        "content": "<p>I need to stop because I am teaching in 5 hours and I've still not started on my blog post or pushed any material. Because the proof of <code>foo</code> below is not <code>rfl</code>, one has to use <code>eq.subst</code> (whose proof is just <code>eq.rec</code>) to push through this approach:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.pnat.basic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">nat</span>\n\n<span class=\"c1\">-- example (n : ℕ+) : n.nat_pred.succ_pnat = n := rfl -- fails :-(</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"bp\">+</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">n.nat_pred.succ_pnat</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n  <span class=\"n\">cases</span> <span class=\"n\">n</span> <span class=\"k\">with</span> <span class=\"n\">m</span> <span class=\"n\">hm</span><span class=\"o\">,</span>\n  <span class=\"n\">ext</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">m</span><span class=\"o\">,</span>\n    <span class=\"n\">cases</span> <span class=\"n\">hm</span><span class=\"o\">,</span>\n  <span class=\"n\">refl</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"c1\">-- now `eq.subst (foo n) : p (n.nat_pred.succ_pnat) → p n</span>\n\n<span class=\"kd\">@[elab_as_eliminator]</span>\n<span class=\"kd\">def</span> <span class=\"n\">pnat.rec_on</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">pnat</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">pnat</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">p1</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n<span class=\"n\">eq.subst</span> <span class=\"o\">(</span><span class=\"n\">foo</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">nat.rec</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"o\">(</span><span class=\"n\">succ_pnat</span> <span class=\"n\">m</span><span class=\"o\">))</span> <span class=\"n\">p1</span>\n  <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">m</span> <span class=\"o\">(</span><span class=\"n\">pm</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"o\">(</span><span class=\"n\">succ_pnat</span> <span class=\"n\">m</span><span class=\"o\">)),</span> <span class=\"o\">(</span><span class=\"n\">hp</span> <span class=\"o\">(</span><span class=\"n\">succ_pnat</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"n\">pm</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"o\">(</span><span class=\"n\">succ_pnat</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))))</span> <span class=\"n\">n.nat_pred</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>The crucial thing about <code>nat.rec</code> is that if you have <code>C0 : C 0</code> and <code>Csucc n : C n -&gt; C (n + 1)</code> and you define your function <code>f</code> with <code>nat.rec</code>, then <code>f 0 = c0</code> and <code>f (n + 1) = Csucc n (f n)</code> are both <code>rfl</code>. The <code>eq.subst</code> will mess all this up though. I think the way to proceed is not as above but instead to use <code>nat.rec</code> on <code>n.1</code>. I'll try this later on but right now I need to focus on my class.</p>",
        "id": 227748374,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614249977
    },
    {
        "content": "<p>Some smart people have looked at <code>pnat</code> and the fact that nobody has defined <code>pnat.rec</code> is telling. There's the induction principle but this has fewer problems because Prop is easier to handle than Type.</p>",
        "id": 227748620,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614250152
    },
    {
        "content": "<p>Here's a proof using <code>nat.rec</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[elab_as_eliminator]</span>\n<span class=\"kd\">def</span> <span class=\"n\">pnat.rec_on</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">pnat</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">pnat</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">p1</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">n</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">induction</span> <span class=\"n\">n</span> <span class=\"k\">with</span> <span class=\"n\">n</span> <span class=\"n\">IH</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">absurd</span> <span class=\"n\">h</span> <span class=\"n\">dec_trivial</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">cases</span> <span class=\"n\">n</span> <span class=\"k\">with</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">p1</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">hp</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">IH</span> <span class=\"n\">n.succ_pos</span><span class=\"o\">)</span> <span class=\"o\">}</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 227748865,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1614250309
    },
    {
        "content": "<p>(I can use tactics because I'm a professional <span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span> )</p>",
        "id": 227748920,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1614250325
    },
    {
        "content": "<p>Very nice, Mario!  Thank you!</p>",
        "id": 227749337,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1614250603
    },
    {
        "content": "<p>also don't forget the equation lemmas:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">pnat.rec_on_one</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">pnat</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">p</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">p1</span> <span class=\"n\">hp</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">pnat.rec_on</span> <span class=\"mi\">1</span> <span class=\"n\">p</span> <span class=\"n\">p1</span> <span class=\"n\">hp</span> <span class=\"bp\">=</span> <span class=\"n\">p1</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">pnat.rec_on_succ</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">pnat</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">pnat</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">p1</span> <span class=\"n\">hp</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">@</span><span class=\"n\">pnat.rec_on</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">p</span> <span class=\"n\">p1</span> <span class=\"n\">hp</span> <span class=\"bp\">=</span> <span class=\"n\">hp</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">pnat.rec_on</span> <span class=\"n\">n</span> <span class=\"n\">p</span> <span class=\"n\">p1</span> <span class=\"n\">hp</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">cases</span> <span class=\"n\">n</span> <span class=\"k\">with</span> <span class=\"n\">n</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">cases</span> <span class=\"n\">n</span><span class=\"bp\">;</span> <span class=\"o\">[</span><span class=\"n\">exact</span> <span class=\"n\">absurd</span> <span class=\"n\">h</span> <span class=\"n\">dec_trivial</span><span class=\"o\">,</span> <span class=\"n\">refl</span><span class=\"o\">]</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 227749400,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1614250635
    },
    {
        "content": "<p>Unfortunately as you can see they aren't both refl</p>",
        "id": 227749426,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1614250655
    },
    {
        "content": "<p>because <code>pnat</code> isn't actually an inductive type</p>",
        "id": 227749441,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1614250673
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span> it doesn't matter if the proofs aren't refl -- what matters is that the proofs exist!</p>",
        "id": 227751300,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614251697
    },
    {
        "content": "<p>PR <a href=\"https://github.com/leanprover-community/mathlib/issues/6410\">#6410</a> : Mario's induction for <code>pnat</code>!</p>",
        "id": 227752338,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1614252281
    },
    {
        "content": "<p>Note that Mario's proof did indeed do induction on <code>n : nat</code> rather than <code>n.nat_pred</code>.</p>",
        "id": 227753813,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614253155
    },
    {
        "content": "<p>Yes, I thought that working with a natural number was better than working with an absurd induction step and then splitting cases, but I was wrong!</p>",
        "id": 227754008,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1614253276
    },
    {
        "content": "<p>This now works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">power_Np</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">semigroup</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">has_pow</span> <span class=\"n\">G</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"bp\">//</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">pow</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">g</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"kd\">begin</span>\n  <span class=\"n\">revert</span> <span class=\"n\">g</span><span class=\"o\">,</span>\n  <span class=\"n\">refine</span> <span class=\"n\">pnat.rec_on</span> <span class=\"n\">n</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">id</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"bp\">λ</span> <span class=\"n\">n</span> <span class=\"n\">pm1</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">pm1</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">g</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">action_one</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">semigroup</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">g</span> <span class=\"bp\">^</span> <span class=\"o\">(⟨</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">nat.one_pos</span><span class=\"o\">⟩</span> <span class=\"o\">:</span> <span class=\"n\">pnat</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">action_succ</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">semigroup</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">g</span> <span class=\"bp\">^</span> <span class=\"o\">(⟨</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">succ_pos</span><span class=\"o\">⟩</span> <span class=\"o\">:</span> <span class=\"n\">pnat</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"bp\">^</span> <span class=\"o\">(⟨</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">n.succ_pos</span><span class=\"o\">⟩</span> <span class=\"o\">:</span> <span class=\"n\">pnat</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">g</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 227754146,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1614253358
    },
    {
        "content": "<p>However, Lean almost immediately complains about excessive memory consumption.  This might be a consequence of having the lemma in the <code>liquid</code> project and not on the separate file <code>data/pnat/basic</code>.</p>",
        "id": 227754501,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1614253575
    },
    {
        "content": "<p>unlikely, that shouldn't make much difference</p>",
        "id": 227756633,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1614254829
    },
    {
        "content": "<p>If you modified a basic file and then went back to the liquid project then lean might be going crazy compiling mathlib in the editor</p>",
        "id": 227756688,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1614254881
    },
    {
        "content": "<p>Ok, I closed all tabs other than the one where I am working (which at the moment does not even depend on the <code>pnat</code> thing) and I hope that there will no longer be memory issues!</p>",
        "id": 227756814,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1614254962
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/267928-condensed-mathematics/topic/torsion.20free/near/227748920\">said</a>:</p>\n<blockquote>\n<p>(I can use tactics because I'm a professional <span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span> )</p>\n</blockquote>\n<p>Is it a good idea to use the equation compiler instead?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[recursor]</span>\n<span class=\"kd\">def</span> <span class=\"n\">pnat.rec</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">pnat</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">p1</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">n</span>\n<span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">rfl.le.not_lt</span> <span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">elim</span>\n<span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">p1</span>\n<span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">hp</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">pnat.rec</span> <span class=\"o\">⟨</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">n.succ_pos</span><span class=\"o\">⟩)</span>\n\n<span class=\"kd\">@[elab_as_eliminator]</span>\n<span class=\"kd\">def</span> <span class=\"n\">pnat.rec_on</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">pnat</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">pnat</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">p1</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n<span class=\"n\">pnat.rec</span> <span class=\"n\">p1</span> <span class=\"n\">hp</span> <span class=\"n\">n</span>\n</code></pre></div>",
        "id": 227760319,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1614256973
    },
    {
        "content": "<p>The term you get is a bit messier, but how much this matters depends on the context. That proof there is actually using well founded recursion, so it won't compute very well</p>",
        "id": 227764959,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1614259121
    },
    {
        "content": "<p>you can get it to at least use bounded recursion if you do the initial cases on pnat separate from the main recursion</p>",
        "id": 227765079,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1614259174
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">pnat.rec_aux</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">pnat</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">p1</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"o\">⟨</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">rfl.le.not_lt</span> <span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">elim</span>\n<span class=\"bp\">|</span> <span class=\"mi\">1</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"n\">p1</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"n\">hp</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">pnat.rec_aux</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">n.succ_pos</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[recursor]</span>\n<span class=\"kd\">def</span> <span class=\"n\">pnat.rec</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">pnat</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">p1</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">n</span>\n<span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">pnat.rec_aux</span> <span class=\"n\">p1</span> <span class=\"n\">hp</span> <span class=\"n\">n</span> <span class=\"n\">h</span>\n</code></pre></div>",
        "id": 227765436,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1614259323
    },
    {
        "content": "<p>Using tactics here makes it easier to control the exact recursion structure</p>",
        "id": 227765652,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1614259430
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> I should think the proof of the pudding will be whether you can prove <code>rec_on_one</code> and <code>rec_on_succ</code>.</p>",
        "id": 227836806,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614286394
    },
    {
        "content": "<p>The equation compiler almost proves them for you</p>",
        "id": 227837036,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1614286479
    },
    {
        "content": "<p>At least, it emits proofs of type defeq to the ones we care about</p>",
        "id": 227837518,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1614286666
    },
    {
        "content": "<p>But Mario's right about it producing an undesirably long term</p>",
        "id": 227837660,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1614286711
    },
    {
        "content": "<p>I want to revive the <code>torsion free</code> part of this thread.</p>\n<p>While experimenting with the <code>toric</code> branch, it seems that assuming <code>is_basis</code> is a very good substitute for <code>torsion free</code>.</p>\n<p>While this may not be a very robust or general approach, working with modules admitting a basis is actually not such a mathematically weird idea.  Of course, you would not be able to apply these statements about the rationals viewed as a module of the integers (or the naturals!), but maybe this is not what we need...</p>",
        "id": 228067860,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1614443221
    },
    {
        "content": "<p>I have just pushed a loooong proof that the direct sum of <code>polyhedral_lattice</code>s is torsion free, to remove one <code>sorry</code> from the <code>instance : polyhedral_lattice (⨁ i, Λ i)</code> of  <code>polyhedral_lattice.basic</code>. But something strange happens : when adding<code>import linear_algebra.direct_sum_module</code> at the beginning of the file, the code breaks on line 167 (this has nothing to do with my proof). I can't understand where this comes from, so I left my proof commented (and replaced it with a <code>sorry</code>), hoping that someone can fix the problem.</p>",
        "id": 229566921,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1615328603
    },
    {
        "content": "<p>It fails on the end of the namespace? <a href=\"https://github.com/leanprover-community/lean-liquid/blob/6de12c8fa1eefa02db4ada2babd5bbf06785de44/src/polyhedral_lattice/basic.lean#L167\">https://github.com/leanprover-community/lean-liquid/blob/6de12c8fa1eefa02db4ada2babd5bbf06785de44/src/polyhedral_lattice/basic.lean#L167</a></p>",
        "id": 229588800,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1615340982
    },
    {
        "content": "<p>Yes, the <code>rw [hl, finset.smul_sum, ← finset.univ_sigma_univ, finset.sum_sigma],</code> on line 159 compiles well if <code>import linear_algebra.direct_sum_module</code> is not called, but when adding <code>import linear_algebra.direct_sum_module</code>, it suddenly fails.</p>",
        "id": 229619887,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1615364791
    },
    {
        "content": "<p>On the other hand, the <code>sorry</code>s on lines 156, 158, 164 were already there.</p>",
        "id": 229620763,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1615365305
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"300245\">@Filippo A. E. Nuccio</span> what do you think, is <code>torsion_free</code> working well?</p>",
        "id": 229621028,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1615365447
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span> suggested that another way to say \"finite free abelian group\" is something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">\\</span><span class=\"n\">ex</span> <span class=\"o\">{</span><span class=\"bp\">\\</span><span class=\"n\">iota</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"bp\">\\</span><span class=\"n\">iota</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">is_basis</span> <span class=\"n\">int</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 229621134,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1615365492
    },
    {
        "content": "<p>Well, I think it works pretty well. I was able without too much pain to prove that the direct sum of torsion-free modules is torsion-free, basically mimicking the \"natural\" proof</p>",
        "id": 229621142,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1615365494
    },
    {
        "content": "<p>And I think <span class=\"user-mention\" data-user-id=\"238446\">@Anne Baanen</span> was also experimenting with making this the definition of <code>free</code></p>",
        "id": 229621171,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1615365508
    },
    {
        "content": "<p>Well, I have just worked with it yesterday, but I found the API pretty good.</p>",
        "id": 229621205,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1615365534
    },
    {
        "content": "<p>In particular, it seems perfectly well-suited for saying what being torsion (or not) is over very general basis other than <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Z}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Z</span></span></span></span></span></p>",
        "id": 229621264,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1615365577
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/267928-condensed-mathematics/topic/torsion.20free/near/229621171\">said</a>:</p>\n<blockquote>\n<p>And I think <span class=\"user-mention silent\" data-user-id=\"238446\">Anne Baanen</span> was also experimenting with making this the definition of <code>free</code></p>\n</blockquote>\n<p>But <code>free</code> and <code>torsion_free</code> are quite far apart, as notions, no?</p>",
        "id": 229621381,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1615365632
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"300245\">@Filippo A. E. Nuccio</span> Yes, but for <code>polyhedral_lattice</code> we want to say \"finite free abelian group\"</p>",
        "id": 229621454,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1615365681
    },
    {
        "content": "<p>And in the end I don't care how we say it. So we should pick the version that is easiest to work with</p>",
        "id": 229621475,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1615365698
    },
    {
        "content": "<p>So far, the definition looked good to me</p>",
        "id": 229621574,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1615365749
    },
    {
        "content": "<p>Filippo, I looked at your proof and I have a small streamlining of it.  However, I also get the weird issues later on, so I am hesitant to push it anywhere!  I leave it here, in case you find it useful.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">tf</span> <span class=\"o\">:=</span>\n  <span class=\"kd\">begin</span>\n    <span class=\"n\">intros</span> <span class=\"n\">v</span> <span class=\"n\">hv</span> <span class=\"n\">n</span> <span class=\"n\">hnv</span><span class=\"o\">,</span>\n    <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">nzv_i</span><span class=\"o\">⟩</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">),</span> <span class=\"n\">direct_sum.component</span> <span class=\"n\">ℤ</span> <span class=\"n\">ι</span> <span class=\"bp\">Λ</span> <span class=\"n\">i</span> <span class=\"n\">v</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">not_forall</span><span class=\"o\">,</span>\n      <span class=\"n\">rwa</span> <span class=\"o\">[</span><span class=\"n\">ne.def</span><span class=\"o\">,</span> <span class=\"n\">direct_sum.ext_iff</span> <span class=\"n\">ℤ</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hv</span> <span class=\"o\">},</span>\n    <span class=\"k\">have</span> <span class=\"n\">tf_i</span> <span class=\"o\">:</span> <span class=\"n\">torsion_free</span> <span class=\"o\">(</span><span class=\"bp\">Λ</span> <span class=\"n\">i</span><span class=\"o\">),</span>\n    <span class=\"o\">{</span> <span class=\"k\">suffices</span> <span class=\"n\">pl_i</span> <span class=\"o\">:</span> <span class=\"n\">polyhedral_lattice</span> <span class=\"o\">(</span><span class=\"bp\">Λ</span> <span class=\"n\">i</span><span class=\"o\">),</span>\n      <span class=\"n\">exact</span> <span class=\"n\">pl_i.tf</span><span class=\"o\">,</span>\n      <span class=\"n\">apply_assumption</span> <span class=\"o\">},</span>\n    <span class=\"n\">refine</span> <span class=\"n\">tf_i</span> <span class=\"o\">(</span><span class=\"n\">direct_sum.component</span> <span class=\"n\">ℤ</span> <span class=\"n\">ι</span> <span class=\"bp\">Λ</span> <span class=\"n\">i</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"n\">nzv_i</span> <span class=\"n\">n</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">linear_map.map_smul_of_tower</span><span class=\"o\">,</span>\n    <span class=\"n\">convert</span> <span class=\"o\">(</span><span class=\"n\">direct_sum.ext_iff</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"n\">hnv</span> <span class=\"n\">i</span><span class=\"o\">,</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span>\n</code></pre></div>",
        "id": 229622633,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1615366341
    },
    {
        "content": "<p>Ok, thanks. I'll improve it. But do you understand the problem with <code>import</code>ing <code>direct_sum_module</code>?</p>",
        "id": 229622868,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1615366456
    },
    {
        "content": "<p>No, I have not looked into the <code>import</code> issue.</p>",
        "id": 229623063,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1615366565
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> May be you have an idea of this <code>import</code> issue? Also, what is your plan for this file <code>polyhedral_lattice.basis</code>, is it reasonable to continue working on this trying to \"kill\" some <code>sorry</code>'?</p>",
        "id": 229626941,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1615368489
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"300245\">@Filippo A. E. Nuccio</span> I will take a look at the import issue now</p>",
        "id": 229627074,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1615368591
    },
    {
        "content": "<p>At some point you were thinking about 9.7, right? If we pin down some statement of Gordan's lemma, would you like to try proving Gordan =&gt; 9.7?</p>",
        "id": 229627157,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1615368623
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/267928-condensed-mathematics/topic/torsion.20free/near/229627157\">said</a>:</p>\n<blockquote>\n<p>At some point you were thinking about 9.7, right? If we pin down some statement of Gordan's lemma, would you like to try proving Gordan =&gt; 9.7?</p>\n</blockquote>\n<p>I had just opened the file to look into this! <span aria-label=\"time\" class=\"emoji emoji-1f557\" role=\"img\" title=\"time\">:time:</span></p>",
        "id": 229627204,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1615368656
    },
    {
        "content": "<p>For <code>polyhedral_lattice.basis</code>, we first have to decide what is the best way for us to say \"finite free abelian group\". And I think the point where we want to use this most is in the proof of Gordan. So Damiano will have to tell us what he likes best (-;</p>",
        "id": 229627252,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1615368685
    },
    {
        "content": "<p>To bisect the problem; does importing <code>linear_algebra.dfinsupp</code> instead break it too?</p>",
        "id": 229627451,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1615368780
    },
    {
        "content": "<p>BTW: Is there already a formulation of Gordan's lemma in the library? Or is it coming with Damiano's work?</p>",
        "id": 229627519,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1615368801
    },
    {
        "content": "<p>No, we have to do this ourselves</p>",
        "id": 229627536,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1615368813
    },
    {
        "content": "<p>Damiano is building the machine to prove it</p>",
        "id": 229627550,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1615368821
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"300245\">@Filippo A. E. Nuccio</span> shall we do a quick video call, to work out a sketch?</p>",
        "id": 229627593,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1615368844
    },
    {
        "content": "<p>Also, the import issue doesn't show up for me</p>",
        "id": 229627671,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1615368858
    },
    {
        "content": "<p>I get an error on some <code>rw</code></p>",
        "id": 229627686,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1615368865
    },
    {
        "content": "<p>I also get an error on a <code>rw</code> further down the line.</p>",
        "id": 229634615,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1615372329
    },
    {
        "content": "<p>(my day today is littered with commitments ever once in a while, so my comments are scattered and I can only concentrate on small stuff!)</p>",
        "id": 229634668,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1615372375
    },
    {
        "content": "<p>I tried looking at the <code>import</code> issue: I could not understand why it breaks, but was able to make it progress further, a <code>simp</code> step away from <code>sorry</code> where it stopped earlier.  It is not pretty, but it seems to (partially) work and also incorporates a proof of <code>fg</code>.  Let me know what you think!</p>",
        "id": 229675175,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1615388513
    },
    {
        "content": "<p>What is the status here? Is this some issue with a broken proof or is the problem weirder?</p>",
        "id": 229804571,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1615446662
    },
    {
        "content": "<p>I do not know what the problem is.  When I looked at it, there were two relevant proofs:</p>\n<ul>\n<li>a complete, commented out, proof, needing some import, also commented out; and</li>\n<li>an incomplete proof further down that led, with no errors, to a <code>sorry</code>.</li>\n</ul>\n<p>(If you look at the file, it might be easier to follow what I am saying.)</p>\n<p>Adding the imports needed for the commented proof, made a <code>rw</code> step of the second proof no longer work.  With a bad trick, I was able to push the now-broken proof a couple of steps further, just until the <code>simp</code> before its ending sorry.</p>\n<p>I think that this is where the situation is right now.</p>",
        "id": 229813625,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1615452112
    },
    {
        "content": "<p>Yes, indeed, this is the situation. It seems strange that adding an <code>import</code> breaks a <code>rw</code> proof, but may be this comes from more things having the same name? At any rate, after discussions with <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> , it is now probably time to wait a little bit for this file as we're waiting for a <code>PR</code> about free modules on <code>mathlib</code>, which seems on its way to be merged.</p>",
        "id": 229842906,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1615467241
    },
    {
        "content": "<p>On the other hand, <span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span>  I still don't find the <code>fg</code> proof, was it for the direct sum?</p>",
        "id": 229842995,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1615467263
    },
    {
        "content": "<p>Oh, I might have said <code>fg</code> for <code>tf</code>: I simply golfed your proof, whichever one if was!! <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 229864230,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1615475447
    },
    {
        "content": "<p>I didn't follow the discussion... to we have somewhere that free implies torsion free (yes, I mean the easy implication)?</p>",
        "id": 232742669,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1617277262
    },
    {
        "content": "<p>I think we have it somewhere: I am going to look for it, but do you need for something else or for discussion we had with Damiano? Because the situation changed a bit and became slightly out of date.</p>",
        "id": 232742799,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1617277349
    },
    {
        "content": "<p>I am trying to prove  <code>pre_generators_finite</code>. In any case if we want to play with lattices something like <code>a • x = b • x  →  a = b</code> (with <code>x</code> nonzero) seems very natural... and that is all what I need.</p>",
        "id": 232743097,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1617277509
    },
    {
        "content": "<p>We have <a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_basis.no_zero_smul_divisors\">docs#is_basis.no_zero_smul_divisors</a>  that is all I need.</p>",
        "id": 232744383,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1617278279
    }
]
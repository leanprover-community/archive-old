[
    {
        "content": "<p>At the moment <code>C.X_prev i</code> is not defeq to <code>C.X j</code> for any <code>j</code>. Besides that, it is only defined for categories with a <code>0</code>-object, which is not always the case (e.g. <code>FreeAb ùìê</code>).</p>\n<p>In particular <code>C.d_from i : C.X_prev i ‚Üí C.X i</code> is not defeq to <code>C.d j i</code> for any <code>j</code>. This means that all sorts of <code>simp</code>(s) lemmas don't apply.<br>\nOne solution would be to add a function <code>c.pred</code> to <code>complex_shape</code> that sends <code>i</code> to the correct <code>j</code> whenever it exists, and to <code>i</code> otherwise. The upshot is that <code>C.d (c.pred i) i</code> is the correct function in all meaningful cases and equal to <code>0</code> in all the edge cases (because <code>C.d j i = 0</code> when <code>¬¨ c.rel j i</code>).</p>\n<p>This definition has good defeqs, and it works in categories without zero objects.</p>\n<p>I think we can attempt this refactor orthogonally to the other proposed homology refactors.</p>\n<p>I welcome feedback from <span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> <span class=\"user-mention\" data-user-id=\"459699\">@Jo√´l Riou</span> <span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> <span class=\"user-mention\" data-user-id=\"439483\">@Andrew Yang</span></p>",
        "id": 290807506,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1658777521
    },
    {
        "content": "<p>Why do we need <code>X_prev</code> in the first place? Would it make sense if the homology functor takes in <code>i j k</code> and a proof <code>i + 1 = j</code> and <code>j+1 = k</code>?<br>\nIf so, do we need <code>X_prev</code> at all?</p>",
        "id": 290808117,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1658777845
    },
    {
        "content": "<p>Then you can't talk about <code>H‚ÇÄ</code> of an <code>‚Ñï</code>-indexed complex.</p>",
        "id": 290808805,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1658778222
    },
    {
        "content": "<p>Why don't you take a proof that <code>i = pred j</code> and <code>k = succ j</code>?</p>",
        "id": 290809125,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1658778377
    },
    {
        "content": "<p>That is, rely on the truncatedness of nat subtraction (or more generally on the behavior of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/order.pred\">docs#order.pred</a> on minimal elements).</p>",
        "id": 290809273,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1658778472
    },
    {
        "content": "<p>This doesn't generalize to arbitrary indexes though. You would require at least an order on it?</p>",
        "id": 290809383,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1658778525
    },
    {
        "content": "<p>But maybe that generality is not needed?</p>",
        "id": 290809405,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1658778543
    },
    {
        "content": "<p>That's all the problem, right? When you don't have anywhere to go, you shouldn't try to go anywhere. When you're the maximal element, you shouldn't try to look at the next bit.</p>",
        "id": 290809442,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1658778578
    },
    {
        "content": "<p>I meant that there might not be a notion of \"maximal element\" in every case that we currently support?</p>",
        "id": 290809583,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1658778639
    },
    {
        "content": "<p>Is it possible to consider cyclic complexes?</p>",
        "id": 290809637,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1658778667
    },
    {
        "content": "<p>It is currently possible, but I doubt we have ever used it.</p>",
        "id": 290809690,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1658778691
    },
    {
        "content": "<p>I'm still a bit inclined to support only <code>Z</code>-indexed complexes and provide some wrapper for padding zeroes in the front and in the end and that's it.<br>\nI think someone gave reason why this is bad but I couldn't find it now.</p>",
        "id": 290809824,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1658778763
    },
    {
        "content": "<p>If you do not use it, then you aren't losing any generality by assuming an order on the indices, because you could recover <code>‚â§</code> by defining <code>a ‚â§ b := ‚àÉ n, X_succ^[n] a = b</code>.</p>",
        "id": 290809850,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1658778775
    },
    {
        "content": "<p>I do not mind replacing <code>X.X_prev i</code> by <code>X.X i</code> when <code>c.prev i = none</code>, but do we really need this? More precisely, do we want to attempt defining homology when we do not even have a zero object?</p>\n<p>More seriously, if I interpret your suggestion properly, you would like to replace <code>c.prev</code> which sends <code>i</code> to the unique <code>j</code> such that <code>c.rel j i</code> when it exists, by some datum <code>c.pred</code> which would be a certain choice of <code>j</code>. (Of course, mathematically speaking, there is only one such <code>j</code>, but two choices may not be defeq.) I think it is not a good idea. I strongly prefer the current design. For example, for <code>cochain C ‚Ñ§</code>, we would presumably set <code>c.pred i</code> to be <code>i-1</code> and similarly for <code>c.succ</code>, so that the homology at <code>i</code> of a complex <code>K</code> would be defined as the homology of the \"short_complex\" <code>K.X (i-1) ‚ü∂ K.X i ‚ü∂ K.X (i+1)</code>? The obvious problem I see is that if in some theorem we want to study the cohomology in degree <code>n+2</code>, then this complex will be <code>K.X (n+2-1) ‚ü∂ K.X (n+2) ‚ü∂ K.X (n+2+1)</code>, and <code>n+2-1</code> is not definitionally equal to <code>n+1</code> and <code>n+2+1</code> is not defeq to <code>n+3</code>.</p>\n<p>I think that the best approach is to keep the current design for the definition of the homology, and use isomorphisms like <code>prev_functor_iso_eval</code> and <code>next_functor_iso_eval</code> that I introduced in <code>for_mathlib/short_complex_homological_complex.lean</code>. For example, if <code>i</code>, <code>j</code>, <code>k</code> are indices such that <code>c.rel i j</code> and <code>c.rel j k</code>, it is easy to deduce from these isomorphisms that the homology functor at <code>j</code> functorialy identifies to the homology of the \"short_complex\" <code>K.X i ‚ü∂ K.X j ‚ü∂ K.X k</code>, and of course, in the case of integers, one may get an isomorphism with the homology of <code>K.X (n-1) ‚ü∂ K.X n ‚ü∂ K.X (n+1)</code>, if this is what we want? I do not really see what we would gain by making this the definition of the homology.</p>\n<p>I have encountered a similar matter recently when I have been trying to check the axioms of model categories for the category of bounded above complexes in an abelian category <code>C</code> with enough projectives. In order to obtain lifting properties, it was useful to introduce the <code>hom_complex F G</code> of two cochain complexes <code>F</code> and <code>G</code> (indexed by <code>‚Ñ§</code>). Mathematically speaking,  an <code>n</code>-cochain of <code>hom_complex F G</code> is the datum of maps <code>F.X p ‚ü∂ G.X (p+n)</code> for all <code>p</code>. In Lean, working with that definition soon becomes an absolute nightmare because when doing computations, you have to use a lot of <code>eq_to_hom</code>. Finally, I have chosen to define an <code>n</code>-cochain of <code>hom_complex F G</code> as the datum of maps <code>F.X p ‚ü∂ G.X q</code> when <code>hpq : p+n=q</code>. Doing so, I was able to make some computations with cocycles and coboundaries: for example, if <code>F</code> is bounded above and consists of projective objects and <code>G</code> is acyclic, I can show that <code>hom_complex F G</code> is acyclic. For the associativity of the composition of cochains, the statement is like this</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">comp_assoc</span> <span class=\"o\">{</span><span class=\"n\">n‚ÇÅ</span> <span class=\"n\">n‚ÇÇ</span> <span class=\"n\">n‚ÇÉ</span> <span class=\"n\">n‚ÇÅ‚ÇÇ</span> <span class=\"n\">n‚ÇÇ‚ÇÉ</span> <span class=\"n\">n‚ÇÅ‚ÇÇ‚ÇÉ</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñ§</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">z‚ÇÅ</span> <span class=\"o\">:</span> <span class=\"n\">cochain</span> <span class=\"n\">F</span> <span class=\"n\">G</span> <span class=\"n\">n‚ÇÅ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">z‚ÇÇ</span> <span class=\"o\">:</span> <span class=\"n\">cochain</span> <span class=\"n\">G</span> <span class=\"n\">K</span> <span class=\"n\">n‚ÇÇ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">z‚ÇÉ</span> <span class=\"o\">:</span> <span class=\"n\">cochain</span> <span class=\"n\">K</span> <span class=\"n\">L</span> <span class=\"n\">n‚ÇÉ</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h‚ÇÅ‚ÇÇ</span> <span class=\"o\">:</span> <span class=\"n\">n‚ÇÅ‚ÇÇ</span> <span class=\"bp\">=</span> <span class=\"n\">n‚ÇÅ</span> <span class=\"bp\">+</span> <span class=\"n\">n‚ÇÇ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h‚ÇÇ‚ÇÉ</span> <span class=\"o\">:</span> <span class=\"n\">n‚ÇÇ‚ÇÉ</span> <span class=\"bp\">=</span> <span class=\"n\">n‚ÇÇ</span> <span class=\"bp\">+</span> <span class=\"n\">n‚ÇÉ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h‚ÇÅ‚ÇÇ‚ÇÉ</span> <span class=\"o\">:</span> <span class=\"n\">n‚ÇÅ‚ÇÇ‚ÇÉ</span> <span class=\"bp\">=</span> <span class=\"n\">n‚ÇÅ</span> <span class=\"bp\">+</span> <span class=\"n\">n‚ÇÇ</span> <span class=\"bp\">+</span> <span class=\"n\">n‚ÇÉ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">cochain.comp</span> <span class=\"o\">(</span><span class=\"n\">cochain.comp</span> <span class=\"n\">z‚ÇÅ</span> <span class=\"n\">z‚ÇÇ</span> <span class=\"n\">h‚ÇÅ‚ÇÇ</span><span class=\"o\">)</span> <span class=\"n\">z‚ÇÉ</span> <span class=\"o\">(</span><span class=\"k\">show</span> <span class=\"n\">n‚ÇÅ‚ÇÇ‚ÇÉ</span> <span class=\"bp\">=</span> <span class=\"n\">n‚ÇÅ‚ÇÇ</span> <span class=\"bp\">+</span> <span class=\"n\">n‚ÇÉ</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">h‚ÇÅ‚ÇÇ</span><span class=\"o\">,</span> <span class=\"n\">h‚ÇÅ‚ÇÇ‚ÇÉ</span><span class=\"o\">])</span> <span class=\"bp\">=</span>\n    <span class=\"n\">cochain.comp</span> <span class=\"n\">z‚ÇÅ</span> <span class=\"o\">(</span><span class=\"n\">cochain.comp</span> <span class=\"n\">z‚ÇÇ</span> <span class=\"n\">z‚ÇÉ</span> <span class=\"n\">h‚ÇÇ‚ÇÉ</span><span class=\"o\">)</span>\n      <span class=\"o\">(</span><span class=\"k\">show</span> <span class=\"n\">n‚ÇÅ‚ÇÇ‚ÇÉ</span> <span class=\"bp\">=</span> <span class=\"n\">n‚ÇÅ</span> <span class=\"bp\">+</span> <span class=\"n\">n‚ÇÇ‚ÇÉ</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">h‚ÇÇ‚ÇÉ</span><span class=\"o\">,</span> <span class=\"n\">h‚ÇÅ‚ÇÇ‚ÇÉ</span><span class=\"o\">,</span> <span class=\"n\">add_assoc</span><span class=\"o\">])</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span>\n</code></pre></div>\n<p>As the associativity of the addition in <code>‚Ñ§</code> is not a definitional equality, I had to introduce these <code>n‚ÇÅ‚ÇÇ</code>, <code>n‚ÇÇ‚ÇÉ</code> and <code>n‚ÇÅ‚ÇÇ‚ÇÉ</code>. The situation when <code>n‚ÇÅ‚ÇÇ</code> et al. must be defeq to <code>n‚ÇÅ+n‚ÇÇ</code>, etc, seems to me like attempting to define <code>c.pred n = n-1</code>. I believe that similarly as I experimented it with <code>hom_complex</code>, this may cause more harm than relief.</p>",
        "id": 290818546,
        "sender_full_name": "Jo√´l Riou",
        "timestamp": 1658783198
    },
    {
        "content": "<p>I think that we should keep all the isomorphisms that are currently there. One of the issues that I am trying to solve is that</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">F.map_homological_complex</span> <span class=\"n\">C</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">X_prev</span> <span class=\"n\">i</span>\n<span class=\"c1\">-- and</span>\n<span class=\"o\">(</span><span class=\"n\">F.map_homological_complex</span> <span class=\"n\">C</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">d_from</span> <span class=\"n\">i</span>\n</code></pre></div>\n<p>are not of the form <code>F.obj blah</code> and <code>F.map blah</code>. (Not even prop-eq.). So you loose access to a whole lot of library lemmas.<br>\nOf course we can write a whole bunch of specialised lemmas to deal with <code>F.map_iso (C.X_prev_iso i)</code> etc... but with my proposed change all the \"combinatorics\" is shifted to calculations in the indexing type <code>Œπ</code>.<br>\nAs you rightly point out, we don't get good defeqs in <code>Œπ</code>. But the situtation certainly didn't get worse than before.</p>\n<p>For actual computations with <code>homology</code>, I think we need another refactor (or 2), to implement a mix of your <code>homology_(pre)_datum</code> and my <code>has_homology</code>, and maybe also Adam's idea.</p>",
        "id": 290844605,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1658804821
    },
    {
        "content": "<p>Here's some sketchy code with a potential idea;</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">category_theory.abelian.exact</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.homology.homological_complex</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">category_theory</span>\n<span class=\"kn\">open</span> <span class=\"n\">category_theory.limits</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">category</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_zero_morphisms</span> <span class=\"n\">A</span><span class=\"o\">]</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">short_complex</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"n\">C</span> <span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">L</span> <span class=\"bp\">‚ü∂</span> <span class=\"n\">C</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"bp\">‚ü∂</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">‚â´</span> <span class=\"n\">g</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">A</span><span class=\"o\">}</span>\n\n<span class=\"kd\">@[ext]</span>\n<span class=\"kd\">structure</span> <span class=\"n\">short_complex.hom</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"n\">short_complex</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">S.L</span> <span class=\"bp\">‚ü∂</span> <span class=\"n\">T.L</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">S.C</span> <span class=\"bp\">‚ü∂</span> <span class=\"n\">T.C</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">S.R</span> <span class=\"bp\">‚ü∂</span> <span class=\"n\">T.R</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">wlc'</span> <span class=\"o\">:</span> <span class=\"n\">l</span> <span class=\"bp\">‚â´</span> <span class=\"n\">T.f</span> <span class=\"bp\">=</span> <span class=\"n\">S.f</span> <span class=\"bp\">‚â´</span> <span class=\"n\">c</span> <span class=\"bp\">.</span> <span class=\"n\">obviously</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">wcr'</span> <span class=\"o\">:</span> <span class=\"n\">c</span> <span class=\"bp\">‚â´</span> <span class=\"n\">T.g</span> <span class=\"bp\">=</span> <span class=\"n\">S.g</span> <span class=\"bp\">‚â´</span> <span class=\"n\">r</span> <span class=\"bp\">.</span> <span class=\"n\">obviously</span><span class=\"o\">)</span>\n\n<span class=\"n\">restate_axiom</span> <span class=\"n\">short_complex.hom.wlc'</span>\n<span class=\"n\">restate_axiom</span> <span class=\"n\">short_complex.hom.wcr'</span>\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"n\">reassoc</span><span class=\"o\">]</span> <span class=\"n\">short_complex.hom.wlc</span> <span class=\"n\">short_complex.hom.wcr</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">short_complex.category</span> <span class=\"o\">:</span> <span class=\"n\">category</span> <span class=\"o\">(</span><span class=\"n\">short_complex</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">hom</span> <span class=\"o\">:=</span> <span class=\"n\">short_complex.hom</span><span class=\"o\">,</span>\n  <span class=\"n\">id</span> <span class=\"o\">:=</span> <span class=\"bp\">Œª</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"o\">{</span> <span class=\"n\">l</span> <span class=\"o\">:=</span> <span class=\"mi\">ùüô</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">c</span> <span class=\"o\">:=</span> <span class=\"mi\">ùüô</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"mi\">ùüô</span> <span class=\"n\">_</span> <span class=\"o\">},</span>\n  <span class=\"n\">comp</span> <span class=\"o\">:=</span> <span class=\"bp\">Œª</span> <span class=\"n\">S</span> <span class=\"n\">T</span> <span class=\"n\">W</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"o\">{</span> <span class=\"n\">l</span> <span class=\"o\">:=</span> <span class=\"n\">f.l</span> <span class=\"bp\">‚â´</span> <span class=\"n\">g.l</span><span class=\"o\">,</span> <span class=\"n\">c</span> <span class=\"o\">:=</span> <span class=\"n\">f.c</span> <span class=\"bp\">‚â´</span> <span class=\"n\">g.c</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"n\">f.r</span> <span class=\"bp\">‚â´</span> <span class=\"n\">g.r</span> <span class=\"o\">}</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">homology_gadget</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">short_complex</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"n\">kernel_fork</span> <span class=\"n\">S.g</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">hK</span> <span class=\"o\">:</span> <span class=\"n\">is_limit</span> <span class=\"n\">K</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">Q</span> <span class=\"o\">:</span> <span class=\"n\">cokernel_cofork</span> <span class=\"n\">S.f</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">hQ</span> <span class=\"o\">:</span> <span class=\"n\">is_colimit</span> <span class=\"n\">Q</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">œÄ</span> <span class=\"o\">:</span> <span class=\"n\">K.X</span> <span class=\"bp\">‚ü∂</span> <span class=\"n\">H</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">Œπ</span> <span class=\"o\">:</span> <span class=\"n\">H</span> <span class=\"bp\">‚ü∂</span> <span class=\"n\">Q.X</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">wK</span> <span class=\"o\">:</span> <span class=\"n\">hK.lift</span> <span class=\"o\">(</span><span class=\"n\">kernel_fork.of_Œπ</span> <span class=\"n\">_</span> <span class=\"n\">S.w</span><span class=\"o\">)</span> <span class=\"bp\">‚â´</span> <span class=\"n\">œÄ</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">wQ</span> <span class=\"o\">:</span> <span class=\"n\">Œπ</span> <span class=\"bp\">‚â´</span> <span class=\"n\">hQ.desc</span> <span class=\"o\">(</span><span class=\"n\">cokernel_cofork.of_œÄ</span> <span class=\"n\">_</span> <span class=\"n\">S.w</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">hœÄ</span> <span class=\"o\">:</span> <span class=\"n\">is_colimit</span> <span class=\"o\">(</span><span class=\"n\">cokernel_cofork.of_œÄ</span> <span class=\"n\">œÄ</span> <span class=\"n\">wK</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">hŒπ</span> <span class=\"o\">:</span> <span class=\"n\">is_limit</span> <span class=\"o\">(</span><span class=\"n\">kernel_fork.of_Œπ</span> <span class=\"n\">Œπ</span> <span class=\"n\">wQ</span><span class=\"o\">))</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">has_homology</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">short_complex</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">cond</span> <span class=\"o\">[]</span> <span class=\"o\">:</span> <span class=\"n\">nonempty</span> <span class=\"o\">(</span><span class=\"n\">homology_gadget</span> <span class=\"n\">S</span><span class=\"o\">))</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">short_complex</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">has_homology</span> <span class=\"n\">S</span><span class=\"o\">]</span>\n\n<span class=\"kd\">noncomputable theory</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">short_complex.homology_gadget</span> <span class=\"o\">:</span> <span class=\"n\">homology_gadget</span> <span class=\"n\">S</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">has_homology.cond</span> <span class=\"n\">S</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">some</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">short_complex.homology</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"o\">:=</span> <span class=\"n\">S.homology_gadget.H</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">short_complex.homology_lift</span> <span class=\"o\">{</span><span class=\"n\">Q</span> <span class=\"o\">:</span> <span class=\"n\">cokernel_cofork</span> <span class=\"n\">S.f</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hQ</span> <span class=\"o\">:</span> <span class=\"n\">is_colimit</span> <span class=\"n\">Q</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">‚ü∂</span> <span class=\"n\">Q.X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">X</span> <span class=\"bp\">‚ü∂</span> <span class=\"n\">S.homology</span> <span class=\"o\">:=</span>\n<span class=\"n\">S.homology_gadget.hŒπ.lift</span> <span class=\"o\">(</span><span class=\"n\">kernel_fork.of_Œπ</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"bp\">‚â´</span> <span class=\"n\">hQ.desc</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">w</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">short_complex.homology_desc</span> <span class=\"o\">{</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"n\">kernel_fork</span> <span class=\"n\">S.g</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hK</span> <span class=\"o\">:</span> <span class=\"n\">is_limit</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">K.X</span> <span class=\"bp\">‚ü∂</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">S.homology</span> <span class=\"bp\">‚ü∂</span> <span class=\"n\">X</span> <span class=\"o\">:=</span>\n<span class=\"n\">S.homology_gadget.hœÄ.desc</span> <span class=\"o\">(</span><span class=\"n\">cokernel_cofork.of_œÄ</span> <span class=\"o\">(</span><span class=\"n\">hK.lift</span> <span class=\"n\">_</span> <span class=\"bp\">‚â´</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"n\">w</span><span class=\"o\">)</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">has_kernels</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_cokernels</span> <span class=\"n\">A</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">short_complex.map_homology</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"n\">short_complex</span> <span class=\"n\">A</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">has_homology</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_homology</span> <span class=\"n\">T</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">‚ü∂</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">S.homology</span> <span class=\"bp\">‚ü∂</span> <span class=\"n\">T.homology</span> <span class=\"o\">:=</span>\n<span class=\"n\">S.homology_desc</span> <span class=\"o\">(</span><span class=\"n\">limit.is_limit</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">T.homology_lift</span> <span class=\"o\">(</span><span class=\"n\">colimit.is_colimit</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">kernel.Œπ</span> <span class=\"n\">_</span> <span class=\"bp\">‚â´</span> <span class=\"n\">f.c</span> <span class=\"bp\">‚â´</span> <span class=\"n\">cokernel.œÄ</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">$</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">)</span> <span class=\"gr\">sorry</span>\n\n<span class=\"c1\">-- etc...</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">short_complex.glue</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"n\">short_complex</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">cl</span> <span class=\"o\">:</span> <span class=\"n\">S.C</span> <span class=\"bp\">‚âÖ</span> <span class=\"n\">T.L</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">rc</span> <span class=\"o\">:</span> <span class=\"n\">S.R</span> <span class=\"bp\">‚âÖ</span> <span class=\"n\">T.C</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">cl.hom</span> <span class=\"bp\">‚â´</span> <span class=\"n\">T.f</span> <span class=\"bp\">=</span> <span class=\"n\">S.g</span> <span class=\"bp\">‚â´</span> <span class=\"n\">rc.hom</span><span class=\"o\">)</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">complex_shape.up</span> <span class=\"n\">‚Ñ§</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">rel</span> <span class=\"mi\">0</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">A</span><span class=\"o\">)</span>\n<span class=\"kd\">structure</span> <span class=\"n\">homological_complex'</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">complex_shape</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">short_complex</span> <span class=\"n\">A</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">glue</span> <span class=\"o\">:</span> <span class=\"bp\">Œ†</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">c.rel</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">glue</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">j</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">zero_f</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">‚àÄ</span> <span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"bp\">¬¨</span> <span class=\"n\">c.rel</span> <span class=\"n\">j</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">‚Üí</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">zero_g</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">‚àÄ</span> <span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"bp\">¬¨</span> <span class=\"n\">c.rel</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"bp\">‚Üí</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">g</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n</code></pre></div>\n</div></div>",
        "id": 290844887,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1658805199
    },
    {
        "content": "<p>The idea is that a homological complex is built up of a bunch of small complexes glued together with isomorphisms.<br>\nThe morphisms are tedious to write in Lean with this approach. The benefit is that mapping this via an additive functor is easy, and it solves Johan's issue that <code>(F.map_homological_complex C).X_prev i</code> is not defeq to <code>F.obj _</code>.</p>",
        "id": 290845073,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1658805365
    },
    {
        "content": "<p>(There may be some compatibilities missing with the isomorphisms involved in the definition of <code>homological_complex'</code>, but I hope the idea is clear enough.)</p>",
        "id": 290845471,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1658805872
    },
    {
        "content": "<p>But doesn't this mean that now there are isomorphisms <em>everywhere</em>?</p>",
        "id": 290845530,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1658805958
    },
    {
        "content": "<p>I think we <em>should</em> have something like this when doing abstract homological algebra. But I don't know if it should be built right into the defn of complexes.</p>",
        "id": 290845577,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1658805993
    },
    {
        "content": "<p>Having an unbundled version, where you get to choose the defeqs of the homology object (instead of using choice) is very useful, I think.</p>",
        "id": 290845590,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1658806033
    },
    {
        "content": "<p>We already have a bunch of isomorphisms to deal with, because that's how we can relate <code>C.X_next i</code> to <code>C.X (i+1)</code> (for example). I guess I'm just suggesting that these isomorphisms be part of the structure itself.</p>",
        "id": 290846055,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1658806721
    },
    {
        "content": "<p>For the homology issue, I think we should mimic the way you can describe an explicit limit with good defeq properties in terms of an explicit cone and an explicit term of <code>is_limit ...</code>. That's roughly what <code>homology_gadget</code> is trying to accomplish.</p>",
        "id": 290846085,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1658806796
    },
    {
        "content": "<p>With this approach to complexes, we would no longer have <code>C.d i j</code> for arbitrary <code>i, j</code>. In fact, all we will have is <code>C.d_to i</code> and <code>C.d_from i</code></p>",
        "id": 290846166,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1658806907
    },
    {
        "content": "<p>About <code>has_homology</code>, my opinion is that it is excellent in order to prove that homology is a self-dual notion, but it is not practical enough in order to do computations because the burden of proof in order to get a <code>has_homology</code> is too strong as we experienced it in the LTE. My proposal of <code>homology_iso_datum</code> was not to take a kernel of <code>g</code> and a cokernel of <code>f</code>, but to compute the homology as a quotient of a subobject, by first taking a kernel <code>K</code> of <code>g</code> and then a cokernel of <code>S.L ‚ü∂ K</code>. It is not self-dual, but computations are easy...</p>\n<p>About the definition of complexes, my proposal would be the following, which seems to be the closest to the usual way mathematicians would think about complexes:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">homological_complex''</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">complex_shape</span> <span class=\"n\">Œπ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">Œπ</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">C</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"bp\">Œ†</span> <span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"o\">(</span><span class=\"n\">hij</span> <span class=\"o\">:</span> <span class=\"n\">c.rel</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">),</span> <span class=\"n\">X</span> <span class=\"n\">i</span> <span class=\"bp\">‚ü∂</span> <span class=\"n\">X</span> <span class=\"n\">j</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">d_comp_d'</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"n\">k</span> <span class=\"n\">hij</span> <span class=\"n\">hjk</span><span class=\"o\">,</span> <span class=\"n\">d</span> <span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"n\">hij</span> <span class=\"bp\">‚â´</span> <span class=\"n\">d</span> <span class=\"n\">j</span> <span class=\"n\">k</span> <span class=\"n\">hjk</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">.</span> <span class=\"n\">obviously</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>(I think <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>  suggested this also.)</p>\n<p>In category theory, we should focus more on morphisms than on objects. Adam's definition may solve some difficulties, but I believe it creates more problems because of the unpractical notion of morphisms it would require. I can imagine how painful this would be for the proof of the Dold-Kan correspondence.</p>\n<p>I think that what homology in mathlib needs the most is a more functorial approach. My introducing the <em>category</em> <code>short_complex</code> unlocked the verification of naturality properties. Anyway, the definition of homology is intricate, so that I do not think we need to change the defs: we can use a <em>few</em> isomorphisms.</p>",
        "id": 290848106,
        "sender_full_name": "Jo√´l Riou",
        "timestamp": 1658809442
    },
    {
        "content": "<p>Another problem I see is that we currently have <code>chain_complex C Œ±</code> which is defined when <code>[add_right_cancel_semigroup Œ±]</code> and <code>[has_one Œ±]</code>. In the case of <code>‚Ñï</code>, one may define <code>c.pred i = i-1</code> and <code>c.succ i = i+1</code>, but with a general <code>Œ±</code>, this would not work.</p>\n<p>The only possible gain I may see in Johan's approach is that the \"short_complex\" around <code>i</code> attached to a complex <code>K</code> is mapped by an additive functor <code>F</code> to the \"short_complex\" around <code>i</code> attached to <code>F.map_homological_complex K</code>. It seems it would a definitional equality (if we allow the irrelevant differential <code>K.d i i</code> which I would like to get rid of...). In the LTE, I have precisely obtained this isomorphism with the current API <code>short_complex.functor_homological_complex C c i ‚ãô F.map_short_complex ‚âÖ F.map_homological_complex c ‚ãô short_complex.functor_homological_complex D c i</code>. It was not that painful! Then, is it really worth setting a priori <code>c.pred</code> and <code>c.succ</code> only for that purpose? I think that the more \"on-demand\" approach that I have suggested above is enough.</p>",
        "id": 290849549,
        "sender_full_name": "Jo√´l Riou",
        "timestamp": 1658811498
    },
    {
        "content": "<p>I just opened <a href=\"https://github.com/leanprover-community/mathlib/pull/15690\">#15690</a> as an experiment. It implements my idea, and the result is a <code>+148 ‚àí331</code> diff.<br>\nVery little API surface has changed, but proofs became a lot shorter. I have not removed lemmas/definitions that are now just thin wrappers around other defs/lemmas. We could easily remove more stuff in the future.</p>\n<p>As I said before, I am very much in favour of the other proposals. I think they can coexist with this one. If anything, my PR will mean that future refactors will be easier.</p>",
        "id": 290884499,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1658838986
    },
    {
        "content": "<p>I have nothing to object to this PR, as long as <code>next</code> and <code>pred</code> are defined using choice, and are not part of a datum that would be fields  of the <code>complex_shape</code> structure. (Of course, some name changes shall be necessary, like <code>X_prev_iso_zero</code>!)</p>",
        "id": 290905139,
        "sender_full_name": "Jo√´l Riou",
        "timestamp": 1658847248
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"459699\">@Jo√´l Riou</span> Can you explain why you think they shouldn't become fields of <code>complex_shape</code>? Up to propositional equality there is no difference at all. And if we provide default arguments, you could pretend that those fields are not there at all.</p>",
        "id": 290909336,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1658848942
    },
    {
        "content": "<p>I have tried to give some arguments above. One is about <code>(co)chain_complex</code>, and another is about annoying indices like <code>(n+1)-1</code> that will pop out. Could you explain what are the arguments in favour of this?</p>",
        "id": 290986228,
        "sender_full_name": "Jo√´l Riou",
        "timestamp": 1658895702
    },
    {
        "content": "<p>Sure, we will have those problems. But we also have them now (in mathlib master, and on my refactor).<br>\nIn fact, if you do make <code>succ</code> and <code>pred</code> fields of <code>complex_shape</code> then <code>complex_shape.pred (1:‚Ñï) = 0</code> would be defeq, but with the current refactor it isn't.<br>\nBut I'm happy with keeping the current version. I just don't think that extra defeqs will do any harm.</p>",
        "id": 290986826,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1658896257
    },
    {
        "content": "<p>The homology is a subquotient of <code>K.X i</code>. For example, <code>K.boundaries i</code> is defined as the image subobject of <code>K.d_to i</code>, which is <code>K.d (c.prev i) i</code> with your refactor. When we want to use this, we have <code>boundaries_eq_image_subobject</code> and <code>boundaries_iso_image</code> which take as an input a relation <code>c.rel j i</code> to express the boundaries as the image of <code>K.d j i</code>. I do not see how setting a preferred <code>c.pred</code> would make the situation any better because I doubt that this chosen <code>c.pred</code> would be the best possible in most of the situations (because of the <code>(n+1)-1</code> type of issues). Setting a priori a presumably \"better\" def of <code>c.pred</code> does not seem to be that useful in my opinion. I would rather keep the <code>c.prev</code> of your PR and have a more \"on-demand\" approach that is already provided by lemmas such as <code>boundaries_iso_image</code>.</p>\n<p>(Note also that for the succ, even though <code>0+1 = 1</code> is a definitional equality, Lean may sometimes have difficulties identifying the two, which would imply more use of <code>erw</code> rather than <code>rw/simp</code>. If we have to work on homology in degree 0, it may still be more convenient to explicitly say that we want to work with <code>1</code> rather than <code>0.succ</code> or <code>0+1</code>.)</p>\n<p>It may not do any harm, but this would still be more work when defining a <code>complex_shape</code> (and it may break <code>(co)chain_complex</code> as I suggested above). Then, is it really worth?</p>",
        "id": 290991351,
        "sender_full_name": "Jo√´l Riou",
        "timestamp": 1658901029
    },
    {
        "content": "<p>Yes, I agree that any potential benefits of having <code>pred</code> and <code>succ</code> as fields of <code>complex_shape</code> are not so large. So I'm very happy to leave them as definitions, like I do in the current PR.</p>",
        "id": 290991772,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1658901505
    },
    {
        "content": "<p>The linter is now happy with</p>\n<blockquote>\n<p>refactor(algebra/homology): better defeqs, less case splitting <a href=\"https://github.com/leanprover-community/mathlib/pull/15690\">#15690</a></p>\n</blockquote>",
        "id": 291081699,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1658943090
    }
]
[
    {
        "content": "<p>We have currently proven a mix of thm 9.4 and 9.5. To get the actual 9.4, we need to prove it for profinite sets <code>S</code>. So far, we only have it for finite sets <code>S</code>.</p>\n<p>What do we need to do:</p>\n<ul>\n<li>Make <code>Mbar_le</code> into a functor on finite sets.</li>\n<li>For <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi><mo>=</mo><msub><mrow><mi>lim</mi><mo>⁡</mo></mrow><mi>i</mi></msub><msub><mi>S</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">S = \\lim_i S_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"mop\"><span class=\"mop\">lim</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> a profinite set, define <code>Mbar_le.profinite</code>: <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mover accent=\"true\"><mi mathvariant=\"script\">M</mi><mo stretchy=\"true\">‾</mo></mover><msup><mi>r</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup></msub><mo stretchy=\"false\">(</mo><mi>S</mi><msub><mo stretchy=\"false\">)</mo><mrow><mo>≤</mo><mi>c</mi></mrow></msub><mo>=</mo><msub><mrow><mi>lim</mi><mo>⁡</mo></mrow><mi>i</mi></msub><msub><mover accent=\"true\"><mi mathvariant=\"script\">M</mi><mo stretchy=\"true\">‾</mo></mover><msup><mi>r</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup></msub><mo stretchy=\"false\">(</mo><msub><mi>S</mi><mi>i</mi></msub><msub><mo stretchy=\"false\">)</mo><mrow><mo>≤</mo><mi>c</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">\\overline{\\mathcal M}_{r&#x27;}(S)_{\\le c} = \\lim_i \\overline{\\mathcal M}_{r&#x27;}(S_i)_{\\le c}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.13333em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord overline\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8833300000000001em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathcal\">M</span></span></span><span style=\"top:-3.80333em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"overline-line\" style=\"border-bottom-width:0.04em;\"></span></span></span></span></span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32797999999999994em;\"><span style=\"top:-2.5500000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02778em;\">r</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6828285714285715em;\"><span style=\"top:-2.786em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.295179em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mrel mtight\">≤</span><span class=\"mord mathnormal mtight\">c</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.24517899999999998em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.13333em;vertical-align:-0.25em;\"></span><span class=\"mop\"><span class=\"mop\">lim</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord overline\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8833300000000001em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathcal\">M</span></span></span><span style=\"top:-3.80333em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"overline-line\" style=\"border-bottom-width:0.04em;\"></span></span></span></span></span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32797999999999994em;\"><span style=\"top:-2.5500000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02778em;\">r</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6828285714285715em;\"><span style=\"top:-2.786em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.295179em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mrel mtight\">≤</span><span class=\"mord mathnormal mtight\">c</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.24517899999999998em;\"><span></span></span></span></span></span></span></span></span></span>. This should be a functor on profinite sets. Feel free to improve the name.<ul>\n<li>Add instances, so that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mover accent=\"true\"><mi mathvariant=\"script\">M</mi><mo stretchy=\"true\">‾</mo></mover><msup><mi>r</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup></msub><mo stretchy=\"false\">(</mo><mi>S</mi><msub><mo stretchy=\"false\">)</mo><mrow><mo>≤</mo><mi>c</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">\\overline{\\mathcal M}_{r&#x27;}(S)_{\\le c}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.13333em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord overline\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8833300000000001em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathcal\">M</span></span></span><span style=\"top:-3.80333em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"overline-line\" style=\"border-bottom-width:0.04em;\"></span></span></span></span></span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32797999999999994em;\"><span style=\"top:-2.5500000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02778em;\">r</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6828285714285715em;\"><span style=\"top:-2.786em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.295179em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mrel mtight\">≤</span><span class=\"mord mathnormal mtight\">c</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.24517899999999998em;\"><span></span></span></span></span></span></span></span></span></span> is a profinite set.</li>\n</ul>\n</li>\n<li>Define <code>Mbar.profinite</code>: <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mover accent=\"true\"><mi mathvariant=\"script\">M</mi><mo stretchy=\"true\">‾</mo></mover><msup><mi>r</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup></msub><mo stretchy=\"false\">(</mo><mi>S</mi><mo stretchy=\"false\">)</mo><mo>=</mo><msub><mo>⋃</mo><mrow><mi>c</mi><mo>≥</mo><mn>0</mn></mrow></msub><msub><mover accent=\"true\"><mi mathvariant=\"script\">M</mi><mo stretchy=\"true\">‾</mo></mover><msup><mi>r</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup></msub><mo stretchy=\"false\">(</mo><mi>S</mi><msub><mo stretchy=\"false\">)</mo><mrow><mo>≤</mo><mi>c</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">\\overline{\\mathcal M}_{r&#x27;}(S) = \\bigcup_{c \\ge 0} \\overline{\\mathcal M}_{r&#x27;}(S)_{\\le c}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.13333em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord overline\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8833300000000001em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathcal\">M</span></span></span><span style=\"top:-3.80333em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"overline-line\" style=\"border-bottom-width:0.04em;\"></span></span></span></span></span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32797999999999994em;\"><span style=\"top:-2.5500000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02778em;\">r</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6828285714285715em;\"><span style=\"top:-2.786em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.278219em;vertical-align:-0.39488900000000005em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:-0.0000050000000000050004em;\">⋃</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15139799999999992em;\"><span style=\"top:-2.40029em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">c</span><span class=\"mrel mtight\">≥</span><span class=\"mord mtight\">0</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.39488900000000005em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord overline\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8833300000000001em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathcal\">M</span></span></span><span style=\"top:-3.80333em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"overline-line\" style=\"border-bottom-width:0.04em;\"></span></span></span></span></span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32797999999999994em;\"><span style=\"top:-2.5500000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02778em;\">r</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6828285714285715em;\"><span style=\"top:-2.786em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.295179em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mrel mtight\">≤</span><span class=\"mord mathnormal mtight\">c</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.24517899999999998em;\"><span></span></span></span></span></span></span></span></span></span>. This should be a functor on profinite sets. Feel free to improve the name.<ul>\n<li>Add instances, so that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mover accent=\"true\"><mi mathvariant=\"script\">M</mi><mo stretchy=\"true\">‾</mo></mover><msup><mi>r</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup></msub><mo stretchy=\"false\">(</mo><mi>S</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\overline{\\mathcal M}_{r&#x27;}(S)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.13333em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord overline\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8833300000000001em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathcal\">M</span></span></span><span style=\"top:-3.80333em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"overline-line\" style=\"border-bottom-width:0.04em;\"></span></span></span></span></span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32797999999999994em;\"><span style=\"top:-2.5500000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02778em;\">r</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6828285714285715em;\"><span style=\"top:-2.786em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mclose\">)</span></span></span></span> is a <code>profinitely_filtered_pseudo_normed_group_with_Tinv</code>.</li>\n</ul>\n</li>\n<li>State thm 9.4 for profinite <code>S</code>, and prove it.\n*</li>\n</ul>",
        "id": 246813559,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1626935855
    },
    {
        "content": "<p>All of this can be done without needing the definition of a condensed set.</p>",
        "id": 246813569,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1626935879
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/267928-condensed-mathematics/topic/Mbar.20functor/near/246813559\">said</a>:</p>\n<blockquote>\n<ul>\n<li>Make <code>Mbar_le</code> into a functor on finite sets.</li>\n</ul>\n</blockquote>\n<p>It might be best to not touch the current definition, and instead define <code>Mbar_le.functor</code> as functor from <code>FinType</code> to <code>Profinite</code>. Evaluating it on a finite set can then be defeq to <code>Mbar_le</code>.</p>",
        "id": 246817176,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1626939533
    },
    {
        "content": "<p>I've started on functorializing(?) <code>Mbar</code>.</p>",
        "id": 246863724,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1626968062
    },
    {
        "content": "<p>I assume the following is correct (for Mbar, I'll work on <code>Mbar_le</code> next)?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- Given an element of `Mbar r' S` and a function `f : S → T`, this</span>\n<span class=\"sd\">  constructs an associated element of `Mbar r' T`. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">map</span> <span class=\"o\">:</span> <span class=\"n\">Mbar</span> <span class=\"n\">r'</span> <span class=\"n\">S</span> <span class=\"bp\">→</span> <span class=\"n\">Mbar</span> <span class=\"n\">r'</span> <span class=\"n\">T</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">F</span><span class=\"o\">,</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">t</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"bp\">∑</span> <span class=\"n\">s</span> <span class=\"k\">in</span> <span class=\"n\">finset.univ.filter</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">s'</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">s'</span> <span class=\"bp\">=</span> <span class=\"n\">t</span><span class=\"o\">),</span> <span class=\"n\">F</span> <span class=\"n\">s</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n  <span class=\"n\">coeff_zero'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">summable'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"kd\">begin</span>\n     <span class=\"bp\">...</span>\n  <span class=\"kd\">end</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 246864013,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1626968179
    },
    {
        "content": "<p>In the end, the functor <code>Mbar</code> on profinite sets will be defined in terms of the functor <code>Mbar_le</code> on profinite sets (see the sketch above).<br>\nSo I think it isn't necessary to turn <code>Mbar</code> (as we have it right now) into a functor on finite sets.</p>",
        "id": 246865069,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1626968645
    },
    {
        "content": "<p>We will need an iso between <code>[fintype S], (Mbar_functor r').obj S</code> and <code>Mbar r' S</code></p>",
        "id": 246865141,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1626968682
    },
    {
        "content": "<p>I understand, but <code>Mbar_le</code> is defined as a subset of <code>Mbar</code>.</p>",
        "id": 246865146,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1626968683
    },
    {
        "content": "<p>Fair enough.</p>",
        "id": 246865221,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1626968710
    },
    {
        "content": "<p>So now that this <code>Mbar.map</code> is defined, we just need to show that it's compatible with the filtration.</p>",
        "id": 246865276,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1626968737
    },
    {
        "content": "<p>Do we not have a topology on <code>Mbar</code> so that the <code>Mbar_le</code>s are subspaces?</p>",
        "id": 246869516,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1626970680
    },
    {
        "content": "<p>I remember we discussed this a while back, but I don't remember what the conclusion was :)</p>",
        "id": 246869610,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1626970712
    },
    {
        "content": "<p>You run into defeq issues.</p>",
        "id": 246870339,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1626971056
    },
    {
        "content": "<p>Because <code>Mbar_le</code> naturally gets a profinite topology. You can put the colimit topology on <code>Mbar</code>. But then the subspace topology on <code>Mbar_le</code> will only be propeq, not defeq to the topology you started with.</p>",
        "id": 246870405,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1626971097
    },
    {
        "content": "<p>Man... formalizing is hard.</p>",
        "id": 246870662,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1626971218
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/lean-liquid/blob/ee3d614135c82452cd37f72383ac152b2962668a/src/Mbar/Mbar_le.lean#L497\">https://github.com/leanprover-community/lean-liquid/blob/ee3d614135c82452cd37f72383ac152b2962668a/src/Mbar/Mbar_le.lean#L497</a></p>",
        "id": 246879251,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1626974814
    },
    {
        "content": "<p>I guess to extend this to a functor on <code>Profinite</code> we can take a right Kan extension, but do we actually want to do that?</p>",
        "id": 246879321,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1626974846
    },
    {
        "content": "<p>I'm always feeling uneasy with Kan extensions <span aria-label=\"see no evil\" class=\"emoji emoji-1f648\" role=\"img\" title=\"see no evil\">:see_no_evil:</span> <br>\nBut if it is a Kan extension, then probably that is the best way to do it.</p>",
        "id": 246881113,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1626975670
    },
    {
        "content": "<p>By the way, is there a better way to write things like <code>∑ s in finset.univ.filter (λ s', f s' = t), F s n</code>?</p>",
        "id": 246881707,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1626975956
    },
    {
        "content": "<p>I've also wished for a better way, but I don't think we have it yet.</p>",
        "id": 246884187,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1626977083
    },
    {
        "content": "<p>We don't have <code>preimage (f : X -&gt; Y) (y : Y) : set X</code>?</p>",
        "id": 246914586,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1626994117
    },
    {
        "content": "<p>It would have to be a finset in this case, not a set</p>",
        "id": 246914673,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1626994201
    },
    {
        "content": "<p>Why wouldn't (sum s : {t}.preimage f) work, since you have a fintype?</p>",
        "id": 246914906,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1626994414
    },
    {
        "content": "<p>The coe sort would also be a fintype.</p>",
        "id": 246914919,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1626994429
    },
    {
        "content": "<p>I'm confused. What is <code>sum</code>?</p>",
        "id": 246916168,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1626995343
    },
    {
        "content": "<p>I don't have a unicode keyboard at the moment. I mean \\sum, the sum sigma.</p>",
        "id": 246916309,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1626995463
    },
    {
        "content": "<p>You'd have a sum over a coesort, and you'd have a coerced s in F s n, but they would mean the same values.</p>",
        "id": 246916360,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1626995517
    },
    {
        "content": "<p>I still don't understand what <code>sum s : {t}.preimage f</code> is supposed to mean... This seems like it's saying that the <code>sum</code> of <code>s</code> is a term of <code>{t}.preimage f</code>. But what I want to do is to take a sum where the index varies over <code>{t}.preimage f</code>.</p>",
        "id": 246917501,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1626996688
    },
    {
        "content": "<p>And sure, I can take a sum over the type associated to the preimage, but I feel like this will cause more pain when compared with a slightly less than optimal notation</p>",
        "id": 246917750,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1626996932
    },
    {
        "content": "<p>Instead of \"sigma s in filter ... \", say \"sigma s : coerced ...\" and rely on fintype sums. I understand the hesitancy about pain.</p>",
        "id": 246917960,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1626997153
    },
    {
        "content": "<p>Ah I see what you mean now. But yes, I'm afraid the pain will be worse with this, since I rely on things like <a href=\"https://leanprover-community.github.io/mathlib_docs/find/finset.sum_bUnion\">docs#finset.sum_bUnion</a> (in the reverse direction) for a few of the proofs involved</p>",
        "id": 246918052,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1626997225
    },
    {
        "content": "<p>What I was saying is that \"take a sum where the index varies over <code>{t}.preimage f</code>.\" is precisely <code>∑ s : {t}.preimage f, F s n</code></p>",
        "id": 246918065,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1626997259
    },
    {
        "content": "<p>Right, there are a lot of slightly incompatible forms. And it gets worse because rw isn't strong enough to rewrite around them unless you match the syntax precisely.</p>",
        "id": 246918159,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1626997347
    },
    {
        "content": "<p>What I really want is notation <code>∑ a in S where p a, f a</code> to mean <code>∑ a in S.filter p, f a</code>.</p>",
        "id": 246918182,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1626997381
    },
    {
        "content": "<p>How would you do it in the finset.univ case?</p>",
        "id": 246918542,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1626997796
    },
    {
        "content": "<p>Without the <code>in S</code>, but with the <code>where p a</code></p>",
        "id": 246918631,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1626997878
    },
    {
        "content": "<p>I guess <code>finsum</code> might be useful as well. But I haven't yet tried using it in places like this.</p>",
        "id": 246923943,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1627003508
    },
    {
        "content": "<p>Adding notation for the <code>S.filter p</code> step would make things more readable, which is good. But then we would still need a bunch of API lemmas, to make it usable.</p>",
        "id": 246924168,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1627003751
    },
    {
        "content": "<p>I just pushed the extension of the functor from <code>Fintype</code> to <code>Profinite</code> here:<br>\n<a href=\"https://github.com/leanprover-community/lean-liquid/blob/284acf5fe6b2f78cecce80715b003226aff00dd7/src/Mbar/Mbar_le.lean#L515\">https://github.com/leanprover-community/lean-liquid/blob/284acf5fe6b2f78cecce80715b003226aff00dd7/src/Mbar/Mbar_le.lean#L515</a></p>\n<p>(and a general version here <a href=\"https://github.com/leanprover-community/lean-liquid/blob/master/src/for_mathlib/Profinite/extend.lean\">https://github.com/leanprover-community/lean-liquid/blob/master/src/for_mathlib/Profinite/extend.lean</a> )</p>",
        "id": 247009285,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1627062096
    },
    {
        "content": "<p>I used the presentation of a profinite set as a limit of its discrete quotients for this, but at some point we should probably relate this to the Kan extension.</p>",
        "id": 247009334,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1627062123
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> Thanks!</p>",
        "id": 247061514,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1627112042
    },
    {
        "content": "<p>Concerning <code>Mbar.profinite</code>... how should we define this? You wrote a union above, which is presumably a colimit, so a priori should involve some sheafification if we want a condensed object.</p>",
        "id": 247083139,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1627144682
    },
    {
        "content": "<p>filtered colimits need not be sheafified in condensed sets!</p>",
        "id": 247094949,
        "sender_full_name": "Peter Scholze",
        "timestamp": 1627162465
    },
    {
        "content": "<p>Great!</p>",
        "id": 247095077,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1627162704
    },
    {
        "content": "<p>I've defined a thing called <code>Mbar.profinite</code> here <br>\n<a href=\"https://github.com/leanprover-community/lean-liquid/blob/0cf5a881a1c416b3d71aeb0a9c0b1603e376c551/src/Mbar/Mbar_le.lean#L585\">https://github.com/leanprover-community/lean-liquid/blob/0cf5a881a1c416b3d71aeb0a9c0b1603e376c551/src/Mbar/Mbar_le.lean#L585</a><br>\nOf course there is much more to do, including proving that it's actually a sheaf ;)</p>",
        "id": 247226737,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1627316947
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> Awesome. Checking that it is a sheaf would need some stuff from the beginning of Condensed.pdf.</p>",
        "id": 247226970,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1627317053
    },
    {
        "content": "<p>As in, we want easier sheaf conditions, for the special setting that we're in.</p>",
        "id": 247227005,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1627317073
    },
    {
        "content": "<p>I've been really busy with a tonne of other stuff. And next week I'll be on holidays. (This week I have 2 more talks to give.)<br>\nBut I think we should copy the strategy of the first half: make a push for the statement first.</p>",
        "id": 247227114,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1627317123
    },
    {
        "content": "<p>And if I understand Peter's comment above, the fact that it doesn't require sheafification probably boils down to the fact that filtered colimits commute with finite limits in <code>Type*</code>,</p>",
        "id": 247227167,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1627317139
    },
    {
        "content": "<p>This <code>Mbar.profinite</code> is a good test case. We'll need it anyway, even though it doesn't show up in the statement.</p>",
        "id": 247227200,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1627317159
    },
    {
        "content": "<p>In the end, we need something that we might call <code>signed_radon_measure : CondMod(real)</code>. This beast is another of those sheafs, and its definition looks very similar to <code>Mbar.profinite</code>.</p>",
        "id": 247227383,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1627317261
    },
    {
        "content": "<p>You don't need condensed <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">R</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord mathbb\">R</span></span></span></span>-modules for the statement! It takes place in condensed abelian groups</p>",
        "id": 247255691,
        "sender_full_name": "Peter Scholze",
        "timestamp": 1627330509
    },
    {
        "content": "<p>I realized that I misspoke above. <code>Mbar.profinite</code> is not even a presheaf on <code>Profinite</code>. I made a version called <code>Mbar.precondensed</code> here <a href=\"https://github.com/leanprover-community/lean-liquid/blob/50f0c86e29b0988cabee4911c026591f33de255f/src/Mbar/Mbar_le.lean#L605\">https://github.com/leanprover-community/lean-liquid/blob/50f0c86e29b0988cabee4911c026591f33de255f/src/Mbar/Mbar_le.lean#L605</a> which, to every <code>S : Profinite</code> actually associates the presheaf on <code>Profinite</code> associated to <code>Mbar(S)</code>. The universes make it a bit of a mess.</p>\n<p>What's happening is the following:</p>\n<ol>\n<li><code>Mbar_le.bifunctor</code> is the functor which to every <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>c</mi><mo>:</mo><msub><mi mathvariant=\"double-struck\">R</mi><mrow><mo>≥</mo><mn>0</mn></mrow></msub></mrow><annotation encoding=\"application/x-tex\">c : \\mathbb{R}_{\\geq 0}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">c</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.934069em;vertical-align:-0.24517899999999998em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">R</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.301108em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mrel mtight\">≥</span><span class=\"mord mtight\">0</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.24517899999999998em;\"><span></span></span></span></span></span></span></span></span></span> and <code>S : Profinite</code> associates the profinite set <code>Mbar_le r' c S</code>.</li>\n<li>Next, compose with the functor sending a profinite set to the representable presheaf.</li>\n<li>Finally, take the colimit of these presheaves as <code>c</code> varies to obtain <code>Mbar.precondensed</code>.</li>\n</ol>\n<p>Note that <code>Mbar_le r' c S</code> is defined as a limit in <code>Profinite</code>, where, a priori, we should be taking a limit of presheaves on <code>Profinite</code>, but this should give the same result. <br>\nIs it actually important for us to consider <code>Mbar_le r' c S</code> for profinite <code>S</code> as a condensed set?</p>",
        "id": 247262395,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1627333469
    },
    {
        "content": "<p>Concerning the universe issue, which is related to the discussion <a href=\"#narrow/stream/267928-condensed-mathematics/topic/condensed.20sets/near/245993721\">https://leanprover.zulipchat.com/#narrow/stream/267928-condensed-mathematics/topic/condensed.20sets/near/245993721</a> I ended up using presheaves of the form </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">as_small.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">}</span> <span class=\"n\">Profinite.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">})</span><span class=\"bp\">ᵒᵖ</span> <span class=\"bp\">⥤</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">u</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 247263358,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1627333738
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span>  We will need to treat <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">M</mi><mo stretchy=\"false\">(</mo><mi>S</mi><mo separator=\"true\">,</mo><mi mathvariant=\"double-struck\">Z</mi><mo stretchy=\"false\">(</mo><mo stretchy=\"false\">(</mo><mi>T</mi><mo stretchy=\"false\">)</mo><msub><mo stretchy=\"false\">)</mo><mrow><mo>&gt;</mo><mi>r</mi></mrow></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\mathcal M(S, \\Z((T))_{&gt;r})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathcal\">M</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathbb\">Z</span><span class=\"mopen\">((</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mclose\">)</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.22737em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mrel mtight\">&gt;</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02778em;\">r</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.17737em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> as a condensed abelian group, at some point. But I'm not sure that we need <code>Mbar</code> as condensed something. We need <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mover accent=\"true\"><mi mathvariant=\"script\">M</mi><mo stretchy=\"true\">‾</mo></mover><msup><mi>r</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup></msub><mo stretchy=\"false\">(</mo><mi>S</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\overline{\\mathcal M}_{r&#x27;}(S)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.13333em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord overline\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8833300000000001em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathcal\">M</span></span></span><span style=\"top:-3.80333em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"overline-line\" style=\"border-bottom-width:0.04em;\"></span></span></span></span></span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32797999999999994em;\"><span style=\"top:-2.5500000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02778em;\">r</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6828285714285715em;\"><span style=\"top:-2.786em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mclose\">)</span></span></span></span> for profinite <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span>. But by the time we need it, we have left the condensed world behind us already.</p>",
        "id": 247293703,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1627360863
    },
    {
        "content": "<p>I guess the question then is still about how <span class=\"tex-error\">$$\\overline\\mathcal{M}_{r'}(S)$$</span> is defined. In which category does the colimit occur?</p>",
        "id": 247322542,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1627386701
    },
    {
        "content": "<p>In the category of abelian groups, I think.</p>",
        "id": 247324967,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1627388231
    },
    {
        "content": "<p>Well, the mbar_le's are just sets.</p>",
        "id": 247325025,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1627388276
    },
    {
        "content": "<p>(well, Profinite sets)</p>",
        "id": 247325077,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1627388291
    },
    {
        "content": "<p>Ooh, right. Sorry. So it is a colimit of sets. And the result is a profinitely filtered pseudo-normed group.</p>",
        "id": 247325358,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1627388469
    },
    {
        "content": "<p>I see. Is it clear that this agrees with the construction coming from the condensed world if one forgets the condensed structure?</p>",
        "id": 247325498,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1627388543
    },
    {
        "content": "<p>In any case the thing I originally defined as <code>Mbar.profinite</code> is exactly this colimit of sets</p>",
        "id": 247325614,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1627388630
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/267928-condensed-mathematics/topic/Mbar.20functor/near/247325498\">said</a>:</p>\n<blockquote>\n<p>I see. Is it clear that this agrees with the construction coming from the condensed world if one forgets the condensed structure?</p>\n</blockquote>\n<p>I guess the question is to what extent taking the representable presheaf commutes with taking colimits?</p>",
        "id": 247325945,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1627388808
    },
    {
        "content": "<p>I think that it should be fine, because profinite sets are compact. So any map <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi><mo>→</mo><mi mathvariant=\"script\">M</mi><mo stretchy=\"false\">(</mo><mi>S</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">T \\to \\mathcal M(S)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathcal\">M</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mclose\">)</span></span></span></span> will factor via some <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">M</mi><mo stretchy=\"false\">(</mo><mi>S</mi><msub><mo stretchy=\"false\">)</mo><mrow><mo>≤</mo><mi>c</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">\\mathcal M(S)_{\\le c}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathcal\">M</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.295179em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mrel mtight\">≤</span><span class=\"mord mathnormal mtight\">c</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.24517899999999998em;\"><span></span></span></span></span></span></span></span></span></span>.</p>",
        "id": 247326023,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1627388859
    },
    {
        "content": "<p>That sounds right.</p>",
        "id": 247326728,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1627389286
    },
    {
        "content": "<p>Ah, I guess the general nonsense fact is that the representable (by a profinite set) condensed sets are compact objects.</p>",
        "id": 247328227,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1627390206
    }
]
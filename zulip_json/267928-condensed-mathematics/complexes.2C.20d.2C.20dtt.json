[
    {
        "content": "<p>Here's a pretty heretical proposal, that takes ideas from Floris, Scott, and Sebastien:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">category_theory.limits.shapes.zero</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">category_theory</span> <span class=\"n\">category_theory.limits</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">has_succ</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- fix this to something better?</span>\n<span class=\"kd\">notation</span> <span class=\"bp\">`Ş`</span> <span class=\"o\">:=</span> <span class=\"n\">has_succ.succ</span>\n\n<span class=\"c1\">-- do we want this for every semiring??</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_succ</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">⟩</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_succ</span> <span class=\"n\">ℤ</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">differential_object_aux</span> <span class=\"o\">(</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">S₀</span> <span class=\"n\">S₁</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n  <span class=\"o\">[</span><span class=\"n\">category</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_zero_morphisms</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">differential</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">X</span> <span class=\"o\">(</span><span class=\"n\">S₀</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">⟶</span> <span class=\"n\">X</span> <span class=\"o\">(</span><span class=\"n\">S₁</span> <span class=\"n\">i</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">differential2</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">S₁</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">S₀</span> <span class=\"n\">j</span><span class=\"o\">),</span>\n  <span class=\"n\">differential</span> <span class=\"n\">i</span> <span class=\"bp\">≫</span> <span class=\"n\">eq_to_hom</span> <span class=\"o\">(</span><span class=\"k\">show</span> <span class=\"n\">X</span> <span class=\"o\">(</span><span class=\"n\">S₁</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">X</span> <span class=\"o\">(</span><span class=\"n\">S₀</span> <span class=\"n\">j</span><span class=\"o\">),</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"bp\">≫</span> <span class=\"n\">differential</span> <span class=\"n\">j</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">cov</span> <span class=\"o\">:</span> <span class=\"n\">bool</span><span class=\"o\">}</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">has_succ</span> <span class=\"n\">ι</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">category</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_zero_morphisms</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">differential_object</span> <span class=\"o\">:</span> <span class=\"n\">bool</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span>\n<span class=\"bp\">|</span> <span class=\"n\">tt</span> <span class=\"o\">:=</span> <span class=\"n\">differential_object_aux</span> <span class=\"n\">ι</span> <span class=\"n\">id</span> <span class=\"bp\">Ş</span> <span class=\"n\">V</span>\n<span class=\"bp\">|</span> <span class=\"n\">ff</span> <span class=\"o\">:=</span> <span class=\"n\">differential_object_aux</span> <span class=\"n\">ι</span> <span class=\"bp\">Ş</span> <span class=\"n\">id</span> <span class=\"n\">V</span>\n\n<span class=\"kd\">abbreviation</span> <span class=\"n\">chain_complex</span> <span class=\"o\">:=</span> <span class=\"n\">differential_object</span> <span class=\"n\">ι</span> <span class=\"n\">V</span> <span class=\"n\">ff</span>\n\n<span class=\"kd\">abbreviation</span> <span class=\"n\">cochain_complex</span> <span class=\"o\">:=</span> <span class=\"n\">differential_object</span> <span class=\"n\">ι</span> <span class=\"n\">V</span> <span class=\"n\">tt</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">differential_object</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"n\">V</span><span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">cov</span> <span class=\"o\">:</span> <span class=\"n\">bool</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">differential_object</span> <span class=\"n\">ι</span> <span class=\"n\">V</span> <span class=\"n\">cov</span><span class=\"o\">),</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">V</span>\n<span class=\"bp\">|</span> <span class=\"n\">tt</span> <span class=\"o\">:=</span> <span class=\"n\">differential_object_aux.X</span>\n<span class=\"bp\">|</span> <span class=\"n\">ff</span> <span class=\"o\">:=</span> <span class=\"n\">differential_object_aux.X</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">ι</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">cov</span> <span class=\"o\">:</span> <span class=\"n\">bool</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">differential_object</span> <span class=\"n\">ι</span> <span class=\"n\">V</span> <span class=\"n\">cov</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">),</span> <span class=\"n\">C.X</span> <span class=\"n\">i</span> <span class=\"bp\">⟶</span> <span class=\"n\">C.X</span> <span class=\"n\">j</span>\n<span class=\"bp\">|</span> <span class=\"n\">tt</span> <span class=\"n\">C</span> <span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"o\">:=</span>\n<span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">Ş</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">j</span>\n<span class=\"k\">then</span> <span class=\"n\">differential_object_aux.differential</span> <span class=\"n\">C</span> <span class=\"n\">i</span> <span class=\"bp\">≫</span> <span class=\"n\">eq_to_hom</span> <span class=\"o\">(</span><span class=\"k\">show</span> <span class=\"n\">C.X</span> <span class=\"o\">(</span><span class=\"bp\">Ş</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">C.X</span> <span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"n\">h</span><span class=\"o\">)</span>\n<span class=\"k\">else</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"n\">ff</span> <span class=\"n\">C</span> <span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"o\">:=</span>\n<span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"bp\">Ş</span> <span class=\"n\">j</span>\n<span class=\"k\">then</span> <span class=\"n\">eq_to_hom</span> <span class=\"o\">(</span><span class=\"k\">show</span> <span class=\"n\">C.X</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">C.X</span> <span class=\"o\">(</span><span class=\"bp\">Ş</span> <span class=\"n\">j</span><span class=\"o\">),</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"bp\">≫</span> <span class=\"n\">differential_object_aux.differential</span> <span class=\"n\">C</span> <span class=\"n\">j</span>\n<span class=\"k\">else</span> <span class=\"mi\">0</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">d_comp_d</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">differential_object</span> <span class=\"n\">ι</span> <span class=\"n\">V</span> <span class=\"n\">cov</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">C.d</span> <span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"bp\">≫</span> <span class=\"n\">C.d</span> <span class=\"n\">j</span> <span class=\"n\">k</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">cases</span> <span class=\"n\">cov</span><span class=\"o\">,</span>\n  <span class=\"n\">all_goals</span>\n  <span class=\"o\">{</span> <span class=\"n\">dsimp</span> <span class=\"o\">[</span><span class=\"n\">d</span><span class=\"o\">],</span> <span class=\"n\">split_ifs</span> <span class=\"k\">with</span> <span class=\"n\">h1</span> <span class=\"n\">h2</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">subst</span> <span class=\"n\">h1</span><span class=\"o\">,</span> <span class=\"n\">subst</span> <span class=\"n\">h2</span><span class=\"o\">,</span>\n      <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">differential_object_aux.differential2</span> <span class=\"n\">C</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">rfl</span> <span class=\"o\">},</span>\n    <span class=\"n\">all_goals</span> <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">zero_comp</span><span class=\"o\">,</span> <span class=\"n\">comp_zero</span><span class=\"o\">]</span> <span class=\"o\">}</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">differential_object</span>\n</code></pre></div>",
        "id": 228905575,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614926883
    },
    {
        "content": "<p>This allows us to work with chain/cochain complexes indexed by <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\Z</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Z</span></span></span></span></span>, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">N</mi></mrow><annotation encoding=\"application/x-tex\">\\N</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">N</span></span></span></span></span>, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">N</mi><mo>×</mo><mo stretchy=\"false\">{</mo><mn>0</mn><mo separator=\"true\">,</mo><mn>1</mn><mo separator=\"true\">,</mo><mn>2</mn><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">\\N \\times \\{0,1,2\\}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.77222em;vertical-align:-0.08333em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">N</span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">2</span><span class=\"mclose\">}</span></span></span></span> etc...</p>",
        "id": 228905661,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614926947
    },
    {
        "content": "<p><code>d_comp_d</code> is true without any proof obligations</p>",
        "id": 228905684,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614926962
    },
    {
        "content": "<p><code>d i j</code> is a map from <code>C.X i</code> to <code>C.X j</code>, for all <code>i</code> and <code>j</code></p>",
        "id": 228905696,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614926981
    },
    {
        "content": "<p>It solves (read: sidesteps) the issue of whether <code>d i : C.X i -&gt; C.X (i-1)</code> or <code>d i : C.X (i+1) -&gt; C.X i</code>.<br>\nAs <span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> points out in <a href=\"https://github.com/leanprover-community/mathlib/issues/6260\">#6260</a>, both conventions are used in maths literature.</p>\n<p>With this proposal <code>d i j : C.X i -&gt; C.X j</code>, you just need to provide both <code>i</code> and <code>j</code>, so that issue doesn't occure <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span> <span aria-label=\"relieved\" class=\"emoji emoji-1f60c\" role=\"img\" title=\"relieved\">:relieved:</span> <span aria-label=\"see no evil\" class=\"emoji emoji-1f648\" role=\"img\" title=\"see no evil\">:see_no_evil:</span></p>",
        "id": 228905914,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614927154
    },
    {
        "content": "<p>So far for the immediate advantages that I see.<br>\nDownsides:</p>\n<ul>\n<li>We get no type checker guarantees that <code>d</code> makes sense.</li>\n<li>We get no type inference for <code>d _ _ x</code>, we have to always remind Lean about the target of <code>d</code></li>\n<li>Readability might be hampered by having all those <code>i</code> and <code>j</code>s explicit.</li>\n</ul>",
        "id": 228905975,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614927230
    },
    {
        "content": "<p>What is wrong with just asking for <code>d {i} {j} (h : j = i + 1)</code>? Didn't this work fine?</p>\n<p>I personally think that to make some sense of what is happening here, we need an explicit \"challenge problem\" which can be a test case for any method? e.g. \"implement chain complexes and then prove lemma X\"? Do you have a good test case in mind Johan? We can try all methods against it, and of course we can make a list of challenge problems if necessary.</p>",
        "id": 228914269,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614933144
    },
    {
        "content": "<p><code>soft_truncation.lean</code> is a nice test case</p>",
        "id": 228914345,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614933193
    },
    {
        "content": "<p>Can you be more explicit? Where do I look? I've been very busy for the past few days.</p>",
        "id": 228914382,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614933228
    },
    {
        "content": "<p>(but I feel very free right now :-) although I have a large document to read for an 11am meeting...but it's not 9am yet :P )</p>",
        "id": 228914468,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614933258
    },
    {
        "content": "<p>It's in <code>src/</code></p>",
        "id": 228914513,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614933280
    },
    {
        "content": "<p>and full of <code>sorry</code>s</p>",
        "id": 228914518,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614933284
    },
    {
        "content": "<p>The downside with your proposal is that we'll have to prove <code>h : j = i + 1</code> a lot, really a lot.</p>",
        "id": 228914559,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614933308
    },
    {
        "content": "<p>And those proofs are all boring and distracting</p>",
        "id": 228914577,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614933316
    },
    {
        "content": "<p>But on the other hand, it does give some coherence for the type checker to hang on to.</p>",
        "id": 228914594,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614933332
    },
    {
        "content": "<p>So I feel like we have to choose between two evils (-;</p>",
        "id": 228914611,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614933345
    },
    {
        "content": "<p>I am not saying the <code>h</code> way is better. I think we just need to experiment with both because we are not working on lean-liquid here, we are making some big decision about how to implement chain complexes in Lean so it's definitely worth some thought. I just think that rather than a bunch of people posting random code we need an explicit \"test suite\" somehow.</p>",
        "id": 228914725,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614933396
    },
    {
        "content": "<p>I am still very unclear about what I am supposed to be doing with my \"rival\" proposal. You are using <code>cochain_complex</code> which apparently is already in mathlib. Is one of the rules that we must stick to mathlib's <code>cochain_complex</code>? And the challenge is an explicit question about <code>NormedGroup</code>?</p>",
        "id": 228915012,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614933569
    },
    {
        "content": "<p>No! I'm not using mathlibs version</p>",
        "id": 228915034,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614933586
    },
    {
        "content": "<p>Sorry for the confusion</p>",
        "id": 228915045,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614933590
    },
    {
        "content": "<p>In the top post I propose a rival to mathlib's version</p>",
        "id": 228915119,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614933611
    },
    {
        "content": "<p>Am I looking at the right file? <code>src/system_of_complexes/soft_truncation.lean</code>?</p>",
        "id": 228915131,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614933615
    },
    {
        "content": "<p>Yes</p>",
        "id": 228915157,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614933631
    },
    {
        "content": "<p>but it doesn't use my top post yet</p>",
        "id": 228915173,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614933638
    },
    {
        "content": "<p>I'm currently viewing LTE as the test suite. Working on converting to my proposal, to see how it works</p>",
        "id": 228915228,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614933668
    },
    {
        "content": "<p>So is the situation the following: </p>\n<p>CHALLENGE: create a definition of cochain complex of NormedGroups, define the soft truncation of a cochain complex of normed groups, and give a complete proof of the assertion that the soft truncation is (k,K)-exact in degrees &lt;= m for c&gt;= c0 iff the original complex is (k,K)-exact in degrees &lt;= m for c&gt;= c0.</p>\n<p>And right now we have <br>\nIncomplete entry 1: <code>src/system_of_complexes/soft_truncation.lean</code><br>\nIncomplete entry 2: Johan's post above<br>\nNon-existent entry 3: my <code>d</code> idea.</p>\n<p>Is this an accurate description of what is going on? I might well have some time today to hack on this and my understanding (correct me if I'm wrong) is that yesterday you and Adam decided that this is really becoming the key question. </p>\n<p>Have I got the statement of the challenge right?</p>",
        "id": 228915753,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614933938
    },
    {
        "content": "<p>And we are to use the definition of <code>NormedGroup</code> in the liquid repo but we can use any definition of cochain complex that we like, although we will have to come up with our own definition of <code>is_bounded_exact</code> for that definition?</p>",
        "id": 228915899,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614934018
    },
    {
        "content": "<p>Wait, the challenge isn't even true, because you can have terms of negative degree which mess things up.</p>\n<p>I would really appreciate guidance towards what the challenge is so I can work on this this afternoon.</p>",
        "id": 228916660,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614934218
    },
    {
        "content": "<p>One advantage of not having to prove <code>j = i + 1</code> is for the <code>0</code> case in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">N</mi></mrow><annotation encoding=\"application/x-tex\">\\N</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">N</span></span></span></span></span>-indexed complexes: the cohomology is always <code>(d i (i+1).ker) / (d (i-1) i).im</code>, regardless of whether <code>i = 0</code> or not (and <code>j = i + 1</code> in this case is just not true).</p>\n<p>Also, regarding the fact that there would be too many <code>i</code> and <code>j</code> everywhere, one can register <code>d' {i} (x : C i) = d i (i+1) x</code> and use <code>d'</code> in most situations, and <code>d</code> when one has to do something nontrivial with the indices (or exchange the two notations maybe).</p>",
        "id": 228916739,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1614934228
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> yes, that challenge sounds about right</p>",
        "id": 228916806,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614934235
    },
    {
        "content": "<p>but it could be extended to a full proof of <code>normed_snake</code> and <code>normed_spectral</code></p>",
        "id": 228916923,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614934253
    },
    {
        "content": "<p>If those work smoothly, that is pretty good evidence that we found a workable definition</p>",
        "id": 228917029,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614934270
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span> I agree that we could use some notation to get rid of some of the <code>i</code>s or <code>j</code>s</p>",
        "id": 228917227,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614934310
    },
    {
        "content": "<p>(But <code>d'</code> is taken because we have differentials in the horizontal and vertical direction (-;</p>",
        "id": 228917478,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614934337
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/267928-condensed-mathematics/topic/complexes.2C.20d.2C.20dtt/near/228916660\">said</a>:</p>\n<blockquote>\n<p>Wait, the challenge isn't even true, because you can have terms of negative degree which mess things up.</p>\n<p>I would really appreciate guidance towards what the challenge is so I can work on this this afternoon.</p>\n</blockquote>\n<p>I think for me the challenge includes to have something that gracefully handles <code>nat</code>-indexed and <code>int</code>-indexed complexes.</p>",
        "id": 228917900,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614934406
    },
    {
        "content": "<p>What is <code>normed_snake</code>? I see <code>weak_normed_snake</code> in <code>src/normed_snake</code> but this looks like it is proved. I am still unclear about what the challenge is. So far I said something which is definitely unprovable (i.e. false) and you said \"that challenge sounds about right\", and you are saying things which I don't understand in the sense that I am not sure which formal statement you are talking about.</p>",
        "id": 228917937,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614934412
    },
    {
        "content": "<p>But designing a good test suite is hard</p>",
        "id": 228917959,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614934419
    },
    {
        "content": "<p>I just want an explicit <code>sorry</code>, that's all.</p>",
        "id": 228918033,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614934431
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/267928-condensed-mathematics/topic/complexes.2C.20d.2C.20dtt/near/228917937\">said</a>:</p>\n<blockquote>\n<p>What is <code>normed_snake</code>? I see <code>weak_normed_snake</code> in <code>src/normed_snake</code> but this looks like it is proved. I am still unclear about what the challenge is. So far I said something which is definitely unprovable (i.e. false) and you said \"that challenge sounds about right\", and you are saying things which I don't understand in the sense that I am not sure which formal statement you are talking about.</p>\n</blockquote>\n<p>It's proved using mathlibs definition of <code>chain_complex</code>.</p>",
        "id": 228918070,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614934436
    },
    {
        "content": "<p>And it worked? So what is the problem?</p>",
        "id": 228918279,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614934454
    },
    {
        "content": "<p>Well, it \"worked\". We've had quite some discussions to get past that hurdle</p>",
        "id": 228918422,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614934477
    },
    {
        "content": "<p>I don't understand what you mean.</p>",
        "id": 228918498,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614934490
    },
    {
        "content": "<p>I am trying to work out what the ACTUAL QUESTION is.</p>",
        "id": 228918520,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614934496
    },
    {
        "content": "<p>Well, we needed Mario to get us past several DTT hurdles, right?</p>",
        "id": 228918569,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614934508
    },
    {
        "content": "<p>I don't know.</p>",
        "id": 228918652,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614934522
    },
    {
        "content": "<p>All I know is that I have three hours this afternoon to try and be helpful and I am trying to figure out right now what I can do before admin kicks in in 5 minutes.</p>",
        "id": 228918880,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614934558
    },
    {
        "content": "<p>I understand</p>",
        "id": 228918977,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614934569
    },
    {
        "content": "<p>But maybe I don't have a clear problem description...</p>",
        "id": 228919079,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614934580
    },
    {
        "content": "<p>OK then maybe I am asking for too much.</p>",
        "id": 228919296,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614934607
    },
    {
        "content": "<p>When we tried to unsorry <code>soft_truncation</code> we quickly ran into DTT issues.</p>",
        "id": 228919307,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614934608
    },
    {
        "content": "<p>We could solve them with <em>a lot</em> of <code>eq_to_hom</code>, but that's just ugly.</p>",
        "id": 228919422,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614934623
    },
    {
        "content": "<p>OK so let's go back to that file.</p>",
        "id": 228919426,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614934623
    },
    {
        "content": "<p>So I want something better.</p>",
        "id": 228919514,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614934639
    },
    {
        "content": "<p>But Floris reminded us that we also want to support long exact sequences. Which are indexed by <code>nat x (fin 3)</code> or something like that</p>",
        "id": 228919614,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614934665
    },
    {
        "content": "<p>So I'm trying to be so general that it also captures that</p>",
        "id": 228919628,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614934676
    },
    {
        "content": "<p>I think that if you want them to start correctly you might want <code>int x (fin 3)</code></p>",
        "id": 228919735,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614934707
    },
    {
        "content": "<p>otherwise you have to say \"my first map is injective\" explicitly.</p>",
        "id": 228919812,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614934754
    },
    {
        "content": "<p>Tate's cohomology theory for finite groups has H^n for all integers n :-/</p>",
        "id": 228919900,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614934801
    },
    {
        "content": "<p>Right, but the main point is that we maybe don't want to assume that <code>int x (fin 3)</code> has an <code>add_comm_group</code> instance that provided the <code>i</code> -&gt; <code>i + 1</code> structure</p>",
        "id": 228920024,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614934844
    },
    {
        "content": "<p>Instead we should have a generic <code>succ : I -&gt; I</code> on the indexing type</p>",
        "id": 228920060,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614934860
    },
    {
        "content": "<p>OK so I will simply have a look at soft_truncation from the <code>d {i} {j} (h)</code> viewpoint. I know that you and others have thought about it a lot more than me but I would like to try it myself so I can understand the issues other people have with this idea better.</p>",
        "id": 228920125,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614934895
    },
    {
        "content": "<p>I agree that the <code>succ</code> idea is brilliant.</p>",
        "id": 228920147,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614934907
    },
    {
        "content": "<p>Yes, please test it. I haven't tested that idea nearly enough.</p>",
        "id": 228920410,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614935010
    },
    {
        "content": "<p>If the idea you're talking about is <code>succ</code> then I think Floris tested it a lot in his thesis :-)</p>",
        "id": 228920455,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614935036
    },
    {
        "content": "<p>I am still confused about <code>soft_truncation'_is_bounded_exact_iff</code>. What if C is a complex with a poorly behaved term in degree -37 stopping <code>is_bounded_exact</code> from being true. Then it's not bounded_exact, but its soft truncation might be. In <code>system_of_complexes/soft_truncation</code> the lemma is stated as an iff.</p>",
        "id": 228920940,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614935255
    },
    {
        "content": "<p>I think I'm in a similar position to Kevin. I'd like to try out these problems but I have no idea what the problem statement is, much less the informal proof</p>",
        "id": 228921174,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1614935356
    },
    {
        "content": "<p>I'm on board with the \"theme\" of dealing with chain complexes, but I guess there's a particular theorem in mind?</p>",
        "id": 228921276,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1614935412
    },
    {
        "content": "<p>Did I forget to add the assumption that <code>C</code> is bounded exact in negative degrees?</p>",
        "id": 228921450,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614935514
    },
    {
        "content": "<p>I had it in a TODO at some point, but it may have been lost in some process</p>",
        "id": 228921527,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614935533
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> What do you mean with \"particular theorem\"?</p>",
        "id": 228921570,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614935552
    },
    {
        "content": "<p>API theorems? Or the big goal?</p>",
        "id": 228921593,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614935562
    },
    {
        "content": "<p>Something that has DTT hell issues</p>",
        "id": 228921623,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1614935582
    },
    {
        "content": "<p>probably not the big goal</p>",
        "id": 228921667,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1614935601
    },
    {
        "content": "<p>Ok, <code>soft_truncation</code> has those</p>",
        "id": 228921799,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614935672
    },
    {
        "content": "<p>Let me see if I can find the code for the first <code>sorry</code>, which is what Adam wrote (on some branch?)</p>",
        "id": 228921877,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614935720
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> Aah, on master the first <code>def</code> is already complete now</p>",
        "id": 228922037,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614935814
    },
    {
        "content": "<p>And the second <code>def</code> has <code>sorry -- annoying )-;</code>, so there you go <span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span></p>",
        "id": 228922077,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614935836
    },
    {
        "content": "<p>Complete proofs are fine, especially if the result is unsatisfactory</p>",
        "id": 228922096,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1614935849
    },
    {
        "content": "<p>link?</p>",
        "id": 228922131,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1614935874
    },
    {
        "content": "<p>First sorry is on line 37 <span aria-label=\"rofl\" class=\"emoji emoji-1f923\" role=\"img\" title=\"rofl\">:rofl:</span></p>",
        "id": 228922596,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614936093
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/lean-liquid/blob/master/src/system_of_complexes/soft_truncation.lean#L37\">https://github.com/leanprover-community/lean-liquid/blob/master/src/system_of_complexes/soft_truncation.lean#L37</a></p>",
        "id": 228922601,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614936095
    },
    {
        "content": "<p>Small success story:</p>\n<p><em>before</em></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">of_shift</span>  <span class=\"o\">{</span><span class=\"n\">k</span> <span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"bp\">≥</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">hk</span> <span class=\"o\">:</span> <span class=\"n\">fact</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">≤</span> <span class=\"n\">k</span><span class=\"o\">)]</span> <span class=\"o\">{</span><span class=\"n\">c₀</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"bp\">≥</span><span class=\"mi\">0</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">c</span> <span class=\"bp\">≥</span> <span class=\"n\">c₀</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">m</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"bp\">*</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">),</span>\n   <span class=\"bp\">∃</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"n\">c</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">),</span> <span class=\"bp\">∥</span><span class=\"n\">res</span> <span class=\"n\">x</span> <span class=\"bp\">-</span> <span class=\"n\">d</span> <span class=\"n\">y</span><span class=\"bp\">∥</span> <span class=\"bp\">≤</span> <span class=\"n\">K</span> <span class=\"bp\">*</span> <span class=\"bp\">∥</span><span class=\"n\">d</span> <span class=\"n\">x</span><span class=\"bp\">∥</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n   <span class=\"n\">C.is_bounded_exact</span> <span class=\"n\">k</span> <span class=\"n\">K</span> <span class=\"n\">m</span> <span class=\"n\">c₀</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intros</span> <span class=\"n\">c</span> <span class=\"n\">hc</span> <span class=\"n\">i</span> <span class=\"n\">hi</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"n\">specialize</span> <span class=\"n\">H</span> <span class=\"n\">c</span> <span class=\"n\">hc</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">linarith</span><span class=\"o\">),</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">sub_add_cancel</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">H</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">H</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">to_exact</span> <span class=\"o\">(</span><span class=\"n\">hC</span> <span class=\"o\">:</span> <span class=\"n\">C.is_weak_bounded_exact</span> <span class=\"n\">k</span> <span class=\"n\">K</span> <span class=\"n\">m</span> <span class=\"n\">c₀</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">δ</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"bp\">≥</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hδ</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">δ</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">c</span> <span class=\"bp\">≥</span> <span class=\"n\">c₀</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">m</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"bp\">*</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">),</span>\n    <span class=\"n\">d</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">→</span> <span class=\"bp\">∃</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"n\">c</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">),</span> <span class=\"n\">res</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">d</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">C.is_bounded_exact</span> <span class=\"n\">k</span> <span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"bp\">+</span> <span class=\"n\">δ</span><span class=\"o\">)</span> <span class=\"n\">m</span> <span class=\"n\">c₀</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">apply</span> <span class=\"n\">is_bounded_exact.of_shift</span><span class=\"o\">,</span>\n  <span class=\"n\">intros</span> <span class=\"n\">c</span> <span class=\"n\">hc</span> <span class=\"n\">i</span> <span class=\"n\">hi</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"n\">by_cases</span> <span class=\"n\">hdx</span> <span class=\"o\">:</span> <span class=\"n\">d</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">rcases</span> <span class=\"n\">H</span> <span class=\"n\">c</span> <span class=\"n\">hc</span> <span class=\"n\">i</span> <span class=\"n\">hi</span> <span class=\"n\">x</span> <span class=\"n\">hdx</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">hy</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">hy</span><span class=\"o\">,</span> <span class=\"n\">hdx</span><span class=\"o\">]⟩</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"n\">K</span> <span class=\"bp\">+</span> <span class=\"n\">δ</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"bp\">≥</span><span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"bp\">∥</span><span class=\"n\">d</span> <span class=\"n\">x</span><span class=\"bp\">∥</span> <span class=\"bp\">=</span> <span class=\"n\">K</span> <span class=\"bp\">*</span> <span class=\"bp\">∥</span><span class=\"n\">d</span> <span class=\"n\">x</span><span class=\"bp\">∥</span> <span class=\"bp\">+</span> <span class=\"n\">δ</span> <span class=\"bp\">*</span> <span class=\"bp\">∥</span><span class=\"n\">d</span> <span class=\"n\">x</span><span class=\"bp\">∥</span><span class=\"o\">,</span> <span class=\"n\">apply_mod_cast</span> <span class=\"n\">add_mul</span><span class=\"o\">,</span>\n    <span class=\"n\">simp_rw</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">hC</span> <span class=\"n\">c</span> <span class=\"n\">hc</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">δ</span><span class=\"bp\">*∥</span><span class=\"n\">d</span> <span class=\"n\">x</span><span class=\"bp\">∥</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">mul_pos</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">exact_mod_cast</span> <span class=\"n\">hδ</span><span class=\"o\">)</span> <span class=\"bp\">$</span> <span class=\"n\">norm_pos_iff.mpr</span> <span class=\"n\">hdx</span><span class=\"o\">),</span> <span class=\"n\">linarith</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 228926709,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614938130
    },
    {
        "content": "<p><em>after</em></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">to_exact</span> <span class=\"o\">(</span><span class=\"n\">hC</span> <span class=\"o\">:</span> <span class=\"n\">C.is_weak_bounded_exact</span> <span class=\"n\">k</span> <span class=\"n\">K</span> <span class=\"n\">m</span> <span class=\"n\">c₀</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">δ</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"bp\">≥</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hδ</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">δ</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">c</span> <span class=\"bp\">≥</span> <span class=\"n\">c₀</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span> <span class=\"bp\">≤</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"bp\">*</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"n\">i</span><span class=\"o\">,</span>\n    <span class=\"n\">C.d</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">→</span> <span class=\"bp\">∃</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"n\">c</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">),</span> <span class=\"n\">res</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">C.d</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">C.is_bounded_exact</span> <span class=\"n\">k</span> <span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"bp\">+</span> <span class=\"n\">δ</span><span class=\"o\">)</span> <span class=\"n\">m</span> <span class=\"n\">c₀</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intros</span> <span class=\"n\">c</span> <span class=\"n\">hc</span> <span class=\"n\">i</span> <span class=\"n\">hi</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"n\">by_cases</span> <span class=\"n\">hdx</span> <span class=\"o\">:</span> <span class=\"n\">C.d</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">rcases</span> <span class=\"n\">H</span> <span class=\"n\">c</span> <span class=\"n\">hc</span> <span class=\"n\">i</span> <span class=\"n\">hi</span> <span class=\"n\">x</span> <span class=\"n\">hdx</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">hy</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">hy</span><span class=\"o\">,</span> <span class=\"n\">hdx</span><span class=\"o\">]⟩</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"n\">K</span> <span class=\"bp\">+</span> <span class=\"n\">δ</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"bp\">≥</span><span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"bp\">∥</span><span class=\"n\">C.d</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">x</span><span class=\"bp\">∥</span>\n      <span class=\"bp\">=</span> <span class=\"n\">K</span> <span class=\"bp\">*</span> <span class=\"bp\">∥</span><span class=\"n\">C.d</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">x</span><span class=\"bp\">∥</span> <span class=\"bp\">+</span> <span class=\"n\">δ</span> <span class=\"bp\">*</span> <span class=\"bp\">∥</span><span class=\"n\">C.d</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">x</span><span class=\"bp\">∥</span><span class=\"o\">,</span> <span class=\"n\">apply_mod_cast</span> <span class=\"n\">add_mul</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">hC</span> <span class=\"n\">c</span> <span class=\"n\">hc</span> <span class=\"n\">_</span> <span class=\"n\">hi</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">δ</span><span class=\"bp\">*∥</span><span class=\"n\">C.d</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">x</span><span class=\"bp\">∥</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">mul_pos</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">exact_mod_cast</span> <span class=\"n\">hδ</span><span class=\"o\">)</span> <span class=\"bp\">$</span> <span class=\"n\">norm_pos_iff.mpr</span> <span class=\"n\">hdx</span><span class=\"o\">)</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 228926737,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614938146
    },
    {
        "content": "<p>In particular the entire <code>of_shift</code> lemma is no longer needed</p>",
        "id": 228926807,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614938166
    },
    {
        "content": "<p>Also, the statements aren't about <code>i + 1 + 1</code>, but just about <code>i</code> and <code>i-1</code>, as you would do on paper.</p>",
        "id": 228926847,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614938188
    },
    {
        "content": "<hr>\n<p><code>system_of_complexes/basic</code> works again, I pushed to <code>jmc-complex</code></p>",
        "id": 228927689,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614938572
    },
    {
        "content": "<p>If you want to test a new approach to the problem I am not so sure that adapting the proof of the (weak) snake lemma is a good test. The proof is not very short, but there are no DTT issues, at least in the first version I wrote. The only thing I did was to let Lean take care of all the indexes, and I never wrote <code>i + 1 + 1 + 1</code>, only <code>_</code>, and it worked like a charm (there are no <code>i - 1</code> in the proof). The same for the the real numbers, I started with <code>k * (k * (k * c))</code> instead of <code>k ^ 3 * c</code> and I forgot about it.</p>",
        "id": 228932068,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1614940731
    },
    {
        "content": "<p>hmm, maybe the DTT issues were not in <code>normed_snake</code> but in the lemma that Patrick was trying to prove</p>",
        "id": 228932789,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614941122
    },
    {
        "content": "<p>Namely going from weak exactness to strong exactness</p>",
        "id": 228932810,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614941136
    },
    {
        "content": "<p>yes, in that lemma there are some <code>i-1</code></p>",
        "id": 228936921,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1614943282
    },
    {
        "content": "<p>I think that Sebastien's question about nat can be phrased in the following way: should <code>succ : \\a \\to \\a</code> be beefed up to an equiv? I think he says no but I am thinking yes.</p>",
        "id": 228945151,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614947602
    },
    {
        "content": "<p>No, I agree with Sebastien</p>",
        "id": 228945923,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614947998
    },
    {
        "content": "<p>There are many reasons to keep <code>nat</code> available as long as possible.</p>",
        "id": 228945982,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614948013
    },
    {
        "content": "<p>See also <a href=\"https://github.com/leanprover-community/mathlib/issues/6260\">#6260</a> by Scott, where he basically duplicates the entire api to <code>nat</code>.</p>",
        "id": 228946031,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614948049
    },
    {
        "content": "<p>There will be two definitions of \"exact\" if we keep <code>nat</code>, one saying <code>A 0 -&gt; A 1 -&gt; A 2 -&gt; ...</code> is exact if it's exact from A1, and a second one saying \"and furthermore A0 -&gt; A1 is injective\".</p>",
        "id": 228946240,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614948142
    },
    {
        "content": "<p>We need <code>with_neg_one_nat</code> ;-)</p>",
        "id": 228946314,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614948186
    },
    {
        "content": "<p>By exact, you mean zero cohomology, i.e., <code>(d (i-1) i).im = (d i (i+1)).ker</code> for all <code>i</code>, right? This definition already contains the fact that the first arrow is injective, by taking <code>i = 0</code>  :-)</p>",
        "id": 228946517,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1614948296
    },
    {
        "content": "<p>My understanding is that the definition of \"<code>A -&gt; B -&gt; C -&gt; D</code> is exact\" means \"exactness at B and C only\". So no, I don't mean this -- I think \"<code>A 0 -&gt; A 1 -&gt; A 2 -&gt; ...</code> exact\" doesn't imply injectivity of <code>A 0 -&gt; A 1</code>. Or at least I thought that the standard definition didn't mean this. I thought that this was why for short exact sequences we write \"0 -&gt; A -&gt; B -&gt; C -&gt; 0\" and not just \"A -&gt; B -&gt; C\" -- exactness of the latter is just exactness at B. But honestly I cannot see this being a problem, as long as people are careful to spell out in docstrings what everything means. It might be a situation where a mathematician can misunderstand a claim being made in Lean but this can be fixed with docstrings.</p>",
        "id": 228950421,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614950040
    },
    {
        "content": "<p>Here is my effort so far with the \"feed in the proofs\" variant. It is going well -- I have got further than Johan:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">system_of_complexes.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">for_mathlib.normed_group_quotient</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">!</span>\n<span class=\"cm\"># Soft truncation</span>\n\n<span class=\"cm\">In this file we define soft truncation functors</span>\n<span class=\"cm\">for (systems of) complexes of normed groups.</span>\n\n<span class=\"cm\">We call these `soft_truncation'` to distinguish them from the usual soft truncation functors.</span>\n<span class=\"cm\">The difference is solely in the definition of the object in degree `0`.</span>\n<span class=\"cm\">Usually this object is defined as `C 0` modulo the kernel of `d : C 0 ⟶ C 1`.</span>\n<span class=\"cm\">Instead, we define it as `C 0` modulo the image of `d : C (-1) ⟶ C 0`.</span>\n<span class=\"cm\">Hence the two definitions agree iff `C` is exact in degree `0`.</span>\n\n<span class=\"cm\">-/</span>\n\n<span class=\"kd\">noncomputable theory</span>\n<span class=\"n\">open_locale</span> <span class=\"n\">nnreal</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">category_theory</span> <span class=\"n\">category_theory.limits</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">has_succ</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">has_succ</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- I can't find that Turkish(?) symbol on my keyboard :-(</span>\n<span class=\"kd\">notation</span> <span class=\"bp\">`</span><span class=\"n\">Sc</span><span class=\"bp\">`</span> <span class=\"o\">:=</span> <span class=\"n\">has_succ.succ</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">int.has_succ</span> <span class=\"o\">:</span> <span class=\"n\">has_succ</span> <span class=\"n\">ℤ</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">z</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">⟩</span>\n\n<span class=\"kn\">local</span> <span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"kd\">instance</span><span class=\"o\">]</span> <span class=\"n\">int.has_succ</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">dsource</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Sc</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"kd\">def</span> <span class=\"n\">dtarget</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Sc</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">sub_add_cancel</span> <span class=\"n\">n</span> <span class=\"mi\">1</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">has_succ</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">cochain_complex'</span>\n\n<span class=\"kd\">universes</span> <span class=\"n\">v</span> <span class=\"n\">u</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">cochain_complex'</span> <span class=\"o\">(</span><span class=\"bp\">𝒞</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">category.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"bp\">𝒞</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_zero_morphisms</span> <span class=\"bp\">𝒞</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">has_succ</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"bp\">𝒞</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Sc</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"n\">i</span> <span class=\"bp\">⟶</span> <span class=\"n\">X</span> <span class=\"n\">j</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">d_squared'</span> <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hij</span> <span class=\"o\">:</span> <span class=\"n\">Sc</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hjk</span> <span class=\"o\">:</span> <span class=\"n\">Sc</span> <span class=\"n\">j</span> <span class=\"bp\">=</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"n\">hij</span><span class=\"o\">)</span> <span class=\"bp\">≫</span> <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"n\">hjk</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n\n<span class=\"kn\">local</span> <span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"kd\">instance</span><span class=\"o\">]</span> <span class=\"n\">int.has_succ</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"bp\">𝒞</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">category.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"bp\">𝒞</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_zero_morphisms</span> <span class=\"bp\">𝒞</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">cochain_complex'</span> <span class=\"bp\">𝒞</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">d_squared_left</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">C.d</span> <span class=\"o\">(</span><span class=\"n\">dsource</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">≫</span> <span class=\"n\">C.d</span> <span class=\"o\">(</span><span class=\"n\">dsource</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"n\">C.d_squared'</span> <span class=\"o\">(</span><span class=\"n\">dsource</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">dsource</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">d_squared_middle</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">C.d</span> <span class=\"o\">(</span><span class=\"n\">dtarget</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">≫</span> <span class=\"n\">C.d</span> <span class=\"o\">(</span><span class=\"n\">dsource</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"n\">C.d_squared'</span> <span class=\"o\">(</span><span class=\"n\">dtarget</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">dsource</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">d_squared_right</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">C.d</span> <span class=\"o\">(</span><span class=\"n\">dtarget</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"bp\">≫</span> <span class=\"n\">C.d</span> <span class=\"o\">(</span><span class=\"n\">dtarget</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"n\">C.d_squared'</span> <span class=\"o\">(</span><span class=\"n\">dtarget</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">dtarget</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">cochain_complex'</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">NormedGroup</span>\n<span class=\"kn\">open</span> <span class=\"n\">quotient_add_group</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">soft_truncation'</span>\n\n<span class=\"kn\">local</span> <span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"kd\">instance</span><span class=\"o\">]</span> <span class=\"n\">int.has_succ</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">X</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">cochain_complex'</span> <span class=\"n\">NormedGroup</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span> <span class=\"bp\">→</span> <span class=\"n\">NormedGroup</span>\n<span class=\"bp\">|</span> <span class=\"bp\">-</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"bp\">+</span><span class=\"n\">n</span><span class=\"o\">]</span>  <span class=\"o\">:=</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span>       <span class=\"o\">:=</span> <span class=\"n\">coker</span> <span class=\"o\">(</span><span class=\"n\">C.d</span> <span class=\"o\">(</span><span class=\"n\">dtarget</span> <span class=\"mi\">0</span><span class=\"o\">))</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">:</span><span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">C.X</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">d</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">cochain_complex'</span> <span class=\"n\">NormedGroup</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Sc</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">j</span><span class=\"o\">),</span> <span class=\"n\">X</span> <span class=\"n\">C</span> <span class=\"n\">i</span> <span class=\"bp\">⟶</span> <span class=\"n\">X</span> <span class=\"n\">C</span> <span class=\"n\">j</span>\n<span class=\"bp\">|</span> <span class=\"bp\">-</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"bp\">+</span><span class=\"n\">n</span><span class=\"o\">]</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"mi\">1</span> <span class=\"n\">rfl</span> <span class=\"o\">:=</span> <span class=\"n\">coker.lift</span> <span class=\"o\">(</span><span class=\"n\">d_squared_right</span> <span class=\"n\">C</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">m</span><span class=\"bp\">+</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"n\">C.d</span> <span class=\"n\">h</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">d_squared'</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">cochain_complex'</span> <span class=\"n\">NormedGroup</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"n\">k</span><span class=\"o\">:</span><span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hij</span> <span class=\"o\">:</span> <span class=\"n\">Sc</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hjk</span> <span class=\"o\">:</span> <span class=\"n\">Sc</span> <span class=\"n\">j</span> <span class=\"bp\">=</span> <span class=\"n\">k</span><span class=\"o\">),</span> <span class=\"n\">d</span> <span class=\"n\">C</span> <span class=\"n\">hij</span> <span class=\"bp\">≫</span> <span class=\"n\">d</span> <span class=\"n\">C</span> <span class=\"n\">hjk</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"bp\">-</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"bp\">+</span><span class=\"n\">n</span><span class=\"o\">]</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"k\">show</span> <span class=\"mi\">0</span> <span class=\"bp\">≫</span> <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"n\">zero_comp</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"mi\">1</span> <span class=\"mi\">2</span> <span class=\"n\">rfl</span> <span class=\"n\">rfl</span> <span class=\"o\">:=</span> <span class=\"k\">show</span> <span class=\"n\">coker.lift</span> <span class=\"o\">(</span><span class=\"n\">d_squared_right</span> <span class=\"n\">C</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">≫</span> <span class=\"n\">C.d</span> <span class=\"o\">(</span><span class=\"n\">dsource</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"gr\">sorry</span> <span class=\"c1\">-- provable</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">:</span><span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">:</span><span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">q</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">:</span><span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"n\">hij</span> <span class=\"n\">hjk</span> <span class=\"o\">:=</span> <span class=\"n\">C.d_squared'</span> <span class=\"n\">hij</span> <span class=\"n\">hjk</span>\n</code></pre></div>\n<p>The equation compiler is doing some extraordinary things.</p>",
        "id": 228950545,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614950085
    },
    {
        "content": "<p>By \"further than Johan\" I just mean that I got the analogue of his line 37 sorry :-)</p>",
        "id": 228951235,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614950417
    },
    {
        "content": "<p>hah! that looks quite nice!</p>",
        "id": 228952130,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614950784
    },
    {
        "content": "<p>Should I press on or try to figure out how to prove this stuff like coker.lift &gt;&gt; f = 0?</p>",
        "id": 228952468,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614950926
    },
    {
        "content": "<p>Mathematically my sorry is this: we have C-1 -&gt; C0 -&gt; C1 exact, so we get a map coker(C-1-&gt;C0)-&gt;C1, and we want to prove that if you compose with C1 -&gt; C2 you get zero. This follows because if you start with something in the coker you can compute its image in C1 by lifting to C0 and applying d, so the result follows from C0 -&gt; C1 -&gt; C2 being zero.</p>",
        "id": 228952834,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614951080
    },
    {
        "content": "<p>In short, the composite map (coker C-1 -&gt; C0) -&gt; C2 is zero because it is the <code>lift</code> of C0 -&gt; C2 which is 0, so the result follows from uniqueness of lifts. Do we have this sort of thing?</p>",
        "id": 228953058,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614951179
    },
    {
        "content": "<p>Oh, I see exactly what we have, it's all in our repo, I had assumed it was in mathlib. Thanks Adam and Riccardo!</p>",
        "id": 228953486,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614951355
    },
    {
        "content": "<p><code>src/system_of_complexes/completion.lean</code> now also compiles again on my experiment.<br>\nWe might want to have a friendly wrapper for</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code> <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">i'</span><span class=\"o\">,</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">i'</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">linarith</span><span class=\"o\">⟩,</span> <span class=\"c1\">-- lowers `i` by one</span>\n</code></pre></div>",
        "id": 228974098,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614958977
    },
    {
        "content": "<p>I'm off to bed. If anyone wants to play around with <code>jmc-complex</code>, please go ahead. Despite the initials, I don't claim that branch (-;</p>",
        "id": 229023804,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614977997
    },
    {
        "content": "<p>I filled in one sorry, and I added the lemma that <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> mentioned earlier (I hope I didn't duplicate Kevin's work here).</p>",
        "id": 229028307,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614979946
    },
    {
        "content": "<p>The lemma is here: <a href=\"https://github.com/leanprover-community/lean-liquid/blob/ed4cdd6bb95a9c491fb65f2b7bdf9cd24a68535c/src/normed_group/NormedGroup.lean#L183\">https://github.com/leanprover-community/lean-liquid/blob/ed4cdd6bb95a9c491fb65f2b7bdf9cd24a68535c/src/normed_group/NormedGroup.lean#L183</a></p>\n<p>and the filled sorry is here: <a href=\"https://github.com/leanprover-community/lean-liquid/blob/ed4cdd6bb95a9c491fb65f2b7bdf9cd24a68535c/src/system_of_complexes/soft_truncation.lean#L43\">https://github.com/leanprover-community/lean-liquid/blob/ed4cdd6bb95a9c491fb65f2b7bdf9cd24a68535c/src/system_of_complexes/soft_truncation.lean#L43</a></p>",
        "id": 229028419,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614980001
    },
    {
        "content": "<p>oh nice! I'm about to start on</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">If this commutes</span>\n<span class=\"cm\">    A ----&gt; B ---&gt; E</span>\n<span class=\"cm\">    |       |      |</span>\n<span class=\"cm\">    |       |      |</span>\n<span class=\"cm\">   \\/      \\/      \\/</span>\n<span class=\"cm\">    C ----&gt; D ---&gt; F</span>\n\n<span class=\"cm\">then so does this</span>\n\n<span class=\"cm\">coker (A → B) ----&gt; E</span>\n<span class=\"cm\">   |                |</span>\n<span class=\"cm\">   | coker.map      |</span>\n<span class=\"cm\">   |                |</span>\n<span class=\"cm\">   \\/               \\/</span>\n<span class=\"cm\">coker (C → D) ----&gt; F</span>\n<span class=\"cm\">-/</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">domino</span> <span class=\"o\">{</span><span class=\"n\">E</span> <span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">NormedGroup.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}}{</span><span class=\"n\">fab</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">⟶</span> <span class=\"n\">B</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">fbd</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"bp\">⟶</span> <span class=\"n\">D</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">fac</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">⟶</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">fcd</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"bp\">⟶</span> <span class=\"n\">D</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">fab</span> <span class=\"bp\">≫</span> <span class=\"n\">fbd</span> <span class=\"bp\">=</span> <span class=\"n\">fac</span> <span class=\"bp\">≫</span> <span class=\"n\">fcd</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">fbe</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"bp\">⟶</span> <span class=\"n\">E</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">fdf</span> <span class=\"o\">:</span> <span class=\"n\">D</span> <span class=\"bp\">⟶</span> <span class=\"n\">F</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">fef</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">⟶</span> <span class=\"n\">F</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"n\">fbe</span> <span class=\"bp\">≫</span> <span class=\"n\">fef</span> <span class=\"bp\">=</span> <span class=\"n\">fbd</span> <span class=\"bp\">≫</span> <span class=\"n\">fdf</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"gr\">sorry</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 229031342,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614981500
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> this is for the sorry in <code>map_comm</code>. I'm writing my own <code>soft_truncation.lean</code> in branch <code>proof_that_succ_i_equals_j</code> using a different definition of <code>cochain_complex</code>. But if it's not hard to fill in the sorrys in master's <code>cochain_complex</code> then we still don't really know which is best.</p>",
        "id": 229031451,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614981577
    },
    {
        "content": "<p>Oh, I jsut pushed that proof too :)</p>",
        "id": 229031531,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614981604
    },
    {
        "content": "<p>oh great!</p>",
        "id": 229031571,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614981616
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/lean-liquid/blob/4151ab41f819db023b285bbfe202d79ce89a9022/src/normed_group/NormedGroup.lean#L183\">https://github.com/leanprover-community/lean-liquid/blob/4151ab41f819db023b285bbfe202d79ce89a9022/src/normed_group/NormedGroup.lean#L183</a></p>",
        "id": 229031620,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614981638
    },
    {
        "content": "<p>Note the comment...</p>",
        "id": 229031635,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614981642
    },
    {
        "content": "<p>And now there are no sorry's in the soft truncation definition in Johan's branch</p>",
        "id": 229031719,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614981680
    },
    {
        "content": "<p>Oh nice! So it works!</p>",
        "id": 229031994,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614981808
    },
    {
        "content": "<p>Yeah, it works :)</p>",
        "id": 229032006,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614981816
    },
    {
        "content": "<p>Err, sorry I lied.</p>",
        "id": 229032030,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614981839
    },
    {
        "content": "<p>I didn't finish <code>soft_truncation</code>, just the inductive definitions above it</p>",
        "id": 229032090,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614981851
    },
    {
        "content": "<p>Well, all the \"data\" is there at least.</p>",
        "id": 229032137,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614981882
    },
    {
        "content": "<p>The proofs I gave for these coker lemmas are not very categorical. I'm using the fact that there are actually elements around (by using this <code>coker.\\pi_surjective</code> trick)</p>",
        "id": 229032367,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614981993
    },
    {
        "content": "<p>Oh, and I just realized that this <code>soft_truncation</code>file now has some universe-related errors at the bottom :(</p>",
        "id": 229032633,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614982101
    },
    {
        "content": "<p>I was going to ask that you took a look at the proofs I pushed, in case you could see any shortcuts or tidying.</p>",
        "id": 229032638,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614982104
    },
    {
        "content": "<p>Oh sure.</p>",
        "id": 229032733,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614982148
    },
    {
        "content": "<p>I've pushed the NormedGroup stuff to master, because we'll need it whatever design decisions are made about complexes, right? I'm assuming this <code>soft_truncation</code> thing is actually important?</p>",
        "id": 229032929,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614982250
    },
    {
        "content": "<p>I might try to refactor these with the epimorphism instance for coker.\\pi that I just added. I like your proofs much more than mine, by the way!</p>",
        "id": 229034573,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614982933
    },
    {
        "content": "<p>But somehow this argument using surjectivity of \\pi should be encapsulated in the epimorphism property.</p>",
        "id": 229034610,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614982957
    },
    {
        "content": "<p>OK so <a href=\"https://github.com/leanprover-community/lean-liquid/blob/proof_that_succ_i_equals_j/src/system_of_complexes/soft_truncation_with_h_proofs.lean\">here</a> is what the soft_truncation looks like with <code>d {i} {j} (h : Succ i = j)</code>. I was really surprised by the equation compiler -- I was expecting to have far more cases to deal with. It's sorry-free but to go any further would require changing more definitions -- I've already written my own cochain_complex to get this far.</p>",
        "id": 229039929,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614985807
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> I filled in two sorries in the jmc-complex branch because the proofs were the same as the ones in my branch -- <code>tidy</code> found them for me and then I tidied them up. The last two sorrys in the file are I believe unprovable right now because as far as I can see there's nothing stopping a general complex misbehaving in negative degrees, which will stop it being &lt;=k-exact in degrees &lt;= m but won't stop the truncation being exact.</p>",
        "id": 229042497,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614987261
    },
    {
        "content": "<p>Yeah I think you're right. I guess the backward implication should be true (and the one we care about?)</p>",
        "id": 229042673,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614987376
    },
    {
        "content": "<p>Does <code>tidy</code> solve <code>soft_truncation'_d_neg</code>?</p>",
        "id": 229042716,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614987403
    },
    {
        "content": "<p>Or even <code>rfl</code>?</p>",
        "id": 229042724,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614987408
    },
    {
        "content": "<p>No, the definition of these things is by cases on the constructor for int so nothing unfolds until you have done cases on the int. Surely you need to start with something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">soft_truncation'_d_neg</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"bp\">≥</span><span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hi</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">((</span><span class=\"n\">soft_truncation'.obj</span> <span class=\"n\">C</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">d</span> <span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">soft_truncation'.obj</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"n\">c</span> <span class=\"n\">i</span> <span class=\"bp\">⟶</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">cases</span> <span class=\"n\">i</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">exfalso</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">hi</span><span class=\"o\">,</span> <span class=\"n\">linarith</span> <span class=\"o\">},</span>\n  <span class=\"gr\">sorry</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 229043800,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614988115
    },
    {
        "content": "<p>Oh, I see what's going on now. Yes it's more complicated since there's both an <code>i</code> and <code>j</code>involved and <code>j</code> can very well be positive.</p>",
        "id": 229044512,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614988578
    },
    {
        "content": "<p>I don't know anything about these systems of complexes, I didn't use them today.</p>",
        "id": 229044878,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614988815
    },
    {
        "content": "<p>If I recall correctly, d here is defined as the usual d if j is i+1 and 0 otherwise.</p>",
        "id": 229045141,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614988972
    },
    {
        "content": "<p>I couldn't find the exact form of that definition so I gave up :-)</p>",
        "id": 229046054,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614989558
    },
    {
        "content": "<p>I wanted to definitionally unwind everything but in the end I got lost trying to chase everything back</p>",
        "id": 229046104,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614989594
    },
    {
        "content": "<p>This is the definition:<br>\n<a href=\"https://github.com/leanprover-community/lean-liquid/blob/4e4f7d630e53a3f4ea08d6ef1359e5ecd2cbcece/src/system_of_complexes/complex.lean#L137\">https://github.com/leanprover-community/lean-liquid/blob/4e4f7d630e53a3f4ea08d6ef1359e5ecd2cbcece/src/system_of_complexes/complex.lean#L137</a></p>",
        "id": 229046608,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614989908
    },
    {
        "content": "<p>But it looks a bit complicated because Johan made one definition for both chain complexes and cochain complexes with this <code>coherent_indices</code> gadget</p>",
        "id": 229046642,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614989940
    },
    {
        "content": "<p>Thanks a lot for your help.</p>",
        "id": 229070156,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1615010495
    },
    {
        "content": "<p>As far as I can see, everything works again, apart from <code>normed_snake.lean</code></p>",
        "id": 229070161,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1615010511
    },
    {
        "content": "<p>I'm getting some crazy timeouts there. We should probably split that proof into 3 or 4 pieces, if possible.</p>",
        "id": 229070208,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1615010533
    },
    {
        "content": "<p>Everything compiles again!</p>",
        "id": 229081621,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1615021651
    },
    {
        "content": "<p>I pushed to <code>jmc-complex</code></p>",
        "id": 229081624,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1615021660
    },
    {
        "content": "<p>I just want to remark that the coker stuff I pushed to master might result in a rather trivial conflict with that branch because I cut and pasted a lemma about maps between cokers commuting and gave it a docstring</p>",
        "id": 229082313,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1615022319
    },
    {
        "content": "<p>I already merged it</p>",
        "id": 229082317,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1615022331
    },
    {
        "content": "<p>I'm still very unclear about what the question is, or even if there is a question. It seems that both the jmc-conplex branch and the proof branch work fine</p>",
        "id": 229082355,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1615022381
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"111080\">@Floris van Doorn</span> I would be very interested in your feedback on <a href=\"https://github.com/leanprover-community/lean-liquid/blob/jmc-complex/src/system_of_complexes/complex.lean\">https://github.com/leanprover-community/lean-liquid/blob/jmc-complex/src/system_of_complexes/complex.lean</a></p>",
        "id": 229262250,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1615191348
    },
    {
        "content": "<p>I notice that in my complexes I had the following condition for d^2=0: I took as inputs i, j, k, a proof hij that j=succ(i) and a proof hjk that k=succ(j), and then I just asked that d hij o d hjk = 0, so I avoided eq_to_hom completely. Your differential objects need them. I am nervous about differential_object.differential because you don't have the flexibility to do this kind of thing.</p>",
        "id": 229331124,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1615221342
    },
    {
        "content": "<p>On a related matter, I would like to have the following statement: a short exact sequence of complexes gives us a long exact sequence of cohomology, for R-modules. This is needed for flatness, it's needed for Amelia's MSc, and some variant is presumably needed for this project. Is the issue that we are still trying to figure out how best to state this?</p>",
        "id": 229331439,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1615221450
    },
    {
        "content": "<p>Didn't Amelia (or another student of yours) define trinagulated categories? This might be the way to go.</p>",
        "id": 229331580,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1615221494
    },
    {
        "content": "<p>Aah! Reading further ahead I see that your <code>coherent_indices</code> trick avoids the problem by  asking for a proof that i = succ j, so I am much happier :-) Yes, someone else I think even made a PR for triangles in a category!</p>",
        "id": 229331756,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1615221561
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/issues/6539\">#6539</a> -- this is Luke's coursework for my course.</p>",
        "id": 229331941,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1615221626
    },
    {
        "content": "<p>It should be fairly straightforward to define the homotopy category of chain complexes, and that's trinagulated.</p>",
        "id": 229333289,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1615222103
    },
    {
        "content": "<p>(once we decide on the \"correct\" definition of chain complexes, of course!)</p>",
        "id": 229333340,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1615222124
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/267928-condensed-mathematics/topic/complexes.2C.20d.2C.20dtt/near/229331124\">said</a>:</p>\n<blockquote>\n<p>I notice that in my complexes I had the following condition for d^2=0: I took as inputs i, j, k, a proof hij that j=succ(i) and a proof hjk that k=succ(j), and then I just asked that d hij o d hjk = 0, so I avoided eq_to_hom completely. Your differential objects need them. I am nervous about differential_object.differential because you don't have the flexibility to do this kind of thing.</p>\n</blockquote>\n<p>I agree that we might want to have some other constructors that give more flexibility, specially for <code>chain_complex</code> and <code>cochain_complex</code>.</p>",
        "id": 229338958,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1615224071
    },
    {
        "content": "<p>This definition is made in such a way that those two specializations have a common backend, which allows us to prove things just once.</p>",
        "id": 229339040,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1615224102
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/267928-condensed-mathematics/topic/complexes.2C.20d.2C.20dtt/near/229331941\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://github.com/leanprover-community/mathlib/issues/6539\">#6539</a> -- this is Luke's coursework for my course.</p>\n</blockquote>\n<p>Wow, this is cool. Let's review this and build upon it!</p>",
        "id": 229339078,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1615224123
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> I'm worried about the explicit mention of <code>eq_to_hom</code> in the definition of <code>differential_object</code>. I see that you have to do quite some rewriting with properties about <code>eq_to_hom</code>, and I think that will get annoying quickly. Oh, but as you said, you could write constructors for <code>differential_object</code> specific to <code>chain_complex</code> or <code>cochain_complex</code>.</p>\n<p>You will also have to deal with the fact that e.g. <code>differential_object ℤ (+1) 0</code> and <code>differential_object ℤ 0 (-1)</code> are isomorphic but not equal. But I think you will have to deal with that in any definition. Even if a definition doesn't really see the distinction, like in Kevin's definition in his example earlier this thread, or in my Lean 2 definition, you still have to deal with it. You might start with a family of maps that naturally go from <code>X n -&gt; X (n-1)</code> or another family of maps that is defined so that it has type <code>X (n+1) -&gt; X n</code>, and you have to put them both in the definition of <code>differential_object</code>. In Lean 2, I did this my defining different kind of constructors, depending on the type of the maps (<a href=\"https://github.com/cmu-phil/Spectral/blob/master/algebra/graded.hlean#L106-L122\">https://github.com/cmu-phil/Spectral/blob/master/algebra/graded.hlean#L106-L122</a>).</p>\n<p>I like the trick you do with <code>coherent_indices</code>, that might be a nice way to deal with the fact that you don't have to provide proofs of equality every time (at least, in the statement of theorems).</p>\n<p>This looks like a fine way of doing it, and something we can build enough bells and whistles (constructors, computation rules) around that makes working with it possible. I also like Kevin's definition in this thread, but it might be nicer to work with the <code>coherent_indices</code> predicate, so that we don't have to apply each differential to an equality.</p>\n<p>Question: is there a reason why you things in terms of <code>differential_object'</code> instead of the more general <code>differential_object</code> (without a prime)? That last one is more general, and would be useful because it also captures the notion of graded objects / graded morphism of degrees other than +1/-1, right?</p>",
        "id": 229377489,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1615239011
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"111080\">@Floris van Doorn</span> <br>\nRight now mathematically a major thing we are missing is complexes of R-modules indexed by the integers. If we have a working theory for these, and also for the theory of complexes of R-modules indexed by the naturals, and also for the theory of complexes of R-modules indexed by <code>fin 3 x int</code> then we will be able to do a lot of new stuff, starting with the statement of the long exact sequence of cohomology associated to a short exact sequence of complexes. More generally we would like all these for abelian categories, but I am unclear about whether this is too much to ask right now because diagram chasing (i.e. the actual proof) in a non-concrete category is hard right now because we don't have this Freyd representation theorem saying that every abelian category is a full subcategory of an appropriate concrete category (usually R-modules or Ab) and apparently we lack the tactics/infrastructure to work directly with the axioms of an abelian category.</p>",
        "id": 229379702,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1615239982
    },
    {
        "content": "<p>Regarding working directly with an abelian category, it might be worth having at look at <a href=\"https://github.com/leanprover-community/mathlib/issues/6308\">#6308</a> (constructing the normalized Moore complex from a simplicial object in an abelian category). It works with intersections of kernels of a bunch of maps, and I think is fairly ergonomic. Of course it is not an example of a diagram-chase argument.</p>",
        "id": 229405864,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1615252644
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"111080\">@Floris van Doorn</span> Thanks a lot for all the feedback. Regarding the final question: I didn't see how to generalise to <code>differential_object</code>, so I worked with <code>differential_object'</code> instead.</p>",
        "id": 229424805,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1615268133
    },
    {
        "content": "<p>I'm thinking about the following renames:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">differential_object</span>  <span class=\"bp\">-&gt;</span> <span class=\"n\">predifferential_object</span>\n<span class=\"n\">differential_object'</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">differential_object</span>\n</code></pre></div>",
        "id": 229424856,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1615268167
    },
    {
        "content": "<p>How do people feel about merging this branch into master?</p>",
        "id": 229430544,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1615272768
    },
    {
        "content": "<p>I personally think that the experiment is 100% over, but on the other hand, further experimentation can be done on master</p>",
        "id": 229430580,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1615272802
    },
    {
        "content": "<p>And I don't really want to start making progress on 9.6 on this branch, because that's not the purpose of this branch</p>",
        "id": 229430592,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1615272830
    },
    {
        "content": "<p>If you're happy with it, let's merge. We can go on forever coming up with new tests or alternative ways of doing things. The big question with any definition is \"is it possible to make enough basic API for mathematicians to be able to take over?\" and once you've found a set-up for which the answer is \"yes\", this will do.</p>",
        "id": 229431043,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1615273199
    },
    {
        "content": "<p>Ok, I merged the branch</p>",
        "id": 229431493,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1615273493
    },
    {
        "content": "<p>So <code>jmc-complex</code> is now officially EOL</p>",
        "id": 229431500,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1615273501
    },
    {
        "content": "<p>As things go... after merging I realised what the <em>correct</em> <span aria-label=\"tm\" class=\"emoji emoji-2122\" role=\"img\" title=\"tm\">:tm:</span> definition is.</p>",
        "id": 229447956,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1615282607
    },
    {
        "content": "<p>I claim that this is the underlying structure that we want to prove a lot of things about:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">differential_object</span> <span class=\"o\">(</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">category</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_zero_morphisms</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"n\">X</span> <span class=\"n\">i</span> <span class=\"bp\">⟶</span> <span class=\"n\">X</span> <span class=\"n\">j</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">d_comp_d</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">d</span> <span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"bp\">≫</span> <span class=\"n\">d</span> <span class=\"n\">j</span> <span class=\"n\">k</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 229448225,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1615282748
    },
    {
        "content": "<p>Difference with the previous def:</p>\n<ul>\n<li>no mention of <code>S0</code> or <code>S1</code></li>\n<li>no <code>eq_to_hom</code></li>\n<li>this <code>d</code> can be used immediately, no sugar on top</li>\n</ul>",
        "id": 229448323,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1615282802
    },
    {
        "content": "<p>This even allows us to use <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi><mo>×</mo><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\Z \\times \\Z</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.77222em;vertical-align:-0.08333em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Z</span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Z</span></span></span></span></span> as indexing object, and get double complexes out of it.</p>",
        "id": 229448438,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1615282834
    },
    {
        "content": "<p>No mention of <code>succ</code> or <code>pred</code> or whatever</p>",
        "id": 229448467,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1615282848
    },
    {
        "content": "<p>Ooh, wait, I retract the comment about double complexes</p>",
        "id": 229448504,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1615282866
    },
    {
        "content": "<p>Because <code>d_comp_d</code> is false there</p>",
        "id": 229448525,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1615282877
    },
    {
        "content": "<p>So maybe I will remove that axiom!</p>",
        "id": 229448533,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1615282884
    },
    {
        "content": "<p>We can add it on top later, when we specialize to subcategories of (co)chain complexes etc</p>",
        "id": 229448568,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1615282908
    },
    {
        "content": "<p>If instead you use</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">differential_object</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">category</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_zero_morphisms</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"n\">X</span> <span class=\"n\">i</span> <span class=\"bp\">⟶</span> <span class=\"n\">X</span> <span class=\"n\">j</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">d_comp_d</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">d</span> <span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"bp\">≫</span> <span class=\"n\">d</span> <span class=\"n\">j</span> <span class=\"n\">k</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>then a double complex would share the same <code>V</code> and <code>X</code>, but it would have two <code>d</code>s, the horizontal one and the vertical one, and each of these would satisfy the <code>d_comp_d</code> axiom.</p>",
        "id": 229450714,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1615283906
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span> that is true, but then it is unbundled. Not sure what's best</p>",
        "id": 229451062,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1615284071
    },
    {
        "content": "<p>Right. I'd say it's probably best to do bundled, because things like spectral sequences will be much easier like that.</p>",
        "id": 229459100,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1615288031
    },
    {
        "content": "<p>I was just considering the Hochschild-Serre spectral sequence when preparing my workshop for this week, which is going to be on group cohomology. I honestly think that group cohomology is a wonderful test case for complexes (and right now I am even wondering if it all works for monoid cohomology). I know exactly how to set it up having supervised two projects in the area and learnt from my mistakes. I will be doing the \"low degree\" version on Thursday which does not need complexes, but the \"general degree\" version does and it seems to me like a very natural goal. When my talk is done I might spend some time making one of those GitHub projects in order to flesh out my ideas.</p>",
        "id": 229478689,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1615297653
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> Will you be broadcasting the workshop? On Discord?</p>",
        "id": 229479581,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1615297992
    },
    {
        "content": "<p>Yes, it's 1600-1800 London time on the Discord</p>",
        "id": 229484193,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1615299814
    },
    {
        "content": "<p>I just merged another refactor of complexes. Hopefully this doesn't establish a pattern...</p>",
        "id": 229544889,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1615320659
    },
    {
        "content": "<p>But this time, there are very few <code>eq_to_hom</code>s, even under the hood.</p>",
        "id": 229544948,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1615320679
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> <span class=\"user-mention\" data-user-id=\"111080\">@Floris van Doorn</span> If you could take another look, that would be great. If you like this design, I think we should move it to mathlib.</p>",
        "id": 230309420,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1615796932
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span>,</p>\n<p>Let me see if I have this right. In this definition of <code>differential_object</code>, we have a <code>d i j</code> from <code>X i</code> to <code>X j</code>, for every <code>i j</code>. Moreover we ask immediately that <code>d i j \\gg d j k = d i k</code>. </p>\n<p>(First of all, it definitely needs a different name: <code>differential_object</code> is a standard name in real maths.)</p>\n<p>This gadget is almost, but not quite, a functor from <code>indiscrete I</code> to the target category, where <code>indiscrete</code> is a not-yet-existing type synonym that puts a single morphism between every pair of objects. The reason it isn't a functor is that we don't want to insist that <code>d i i</code> is the identity. So it's only a <code>semifunctor</code> between <code>semicategory</code>s.</p>\n<p>As a second step, when we want to define <code>chain_complex</code> or <code>cochain_complex</code> (either <code>nat</code> or <code>int</code> indexed), we pass to the full subcategory of <code>differential_object</code> where some specified collection of the <code>d i j</code> are zero (e.g. only if <code>j = i + 1</code> can it be nonzero).</p>\n<p>I don't really understand what <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> has been doing on <code>ses_to_les</code>. Showing that <code>differential_object</code> has equalizers or images or something doesn't seem to serve much purpose: because you'll still need to do separate work to build these again in the subcategory; possibly the main bit of the work?</p>\n<p>(That said, I suspect that a big chunk of the theory of limits works perfectly well for semicategories, and it even seems plausible that if <code>V</code> has limits, semifunctors <code>J \\func V</code> does too...?)</p>\n<p>It seemed like there was a proposal to define the <code>homology</code> functor right at the level of <code>differential_object</code>, but I don't see what the intention is here. You can talk about the intersections of all the kernels of <code>d i j</code> as <code>j</code> varies, and the union of all the images of <code>d k i</code> as <code>k</code> varies, but the image union won't sit in the kernel intersection.</p>\n<p>Help?</p>",
        "id": 230946636,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1616106105
    },
    {
        "content": "<p>I don't think d i j &gt;&gt; d j k is defined to be anything initially. Very early on we define it to be 0. The idea is that all d i j if j isn't i + 1 are supposed to be 0 (including d i i).</p>",
        "id": 230949993,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616108360
    },
    {
        "content": "<p>In an abelian category you could talk about the join of all the images. But I'm not sure this is the way to go. I think I've understood all this a bit better now -- I started a thread in #maths about it</p>",
        "id": 230950186,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616108450
    },
    {
        "content": "<p>Oh, okay, I woke up confused. Yes, I agree the stuff about semifunctoriality is not what Johan had in mind, and is not in the definition.</p>",
        "id": 230950788,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1616108834
    },
    {
        "content": "<p>I don't know whether to continue here on in #maths. I agree that my stuff on the branch is problematic, I had not realised this issue about how we might have to do a whole bunch of stuff again but now I fear you're right.</p>",
        "id": 230951887,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616109535
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> I'm open to changing things that don't work well. In particular, I'm very much in favour of changing the name.</p>",
        "id": 230982975,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616136824
    },
    {
        "content": "<p>I think that it's important that <code>d i i</code> is not the identity.</p>",
        "id": 230982985,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616136840
    },
    {
        "content": "<p>And it would be great if we can model both chain and cochain complexes together, somehow.</p>",
        "id": 230983038,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616136869
    },
    {
        "content": "<p>Yes, sorry, me saying <code>d i i</code> should be the identity was me being very confused.</p>",
        "id": 230983065,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1616136912
    },
    {
        "content": "<p>Do you have a suggestion for a new name?</p>",
        "id": 230983160,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616137020
    },
    {
        "content": "<p>I was tempted by something like <code>pre_dgo</code>. It's not yet a <code>dgo</code> = \"differential graded object\", because the differential and the grading don't see each other.</p>",
        "id": 230983498,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1616137369
    },
    {
        "content": "<p>Another thing I don't know is how to define the boundary map in a non concrete setting. You have four short exact sequences An-&gt; Bn -&gt; Cn (horizontal) in a complex (vertical, 0&lt;= n&lt;= 3) and you have something in the Ker/im subquotient of C2. Now lift to B2 by instantiating an exists, push to B3 and lift to A3 instantiating another one. For R-mod the epis are surjections and you can just do it with choice. I'm assuming there's a way to do it from the category axioms but I don't see it yet</p>",
        "id": 230983538,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616137414
    },
    {
        "content": "<blockquote>\n<p><code>pre_dgo</code></p>\n</blockquote>\n<p>sounds like just the right level of obfuscation for these obscure objects (-;</p>",
        "id": 230983617,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616137480
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> <code>s/situations/surjections/</code> auto-complete-fail?</p>",
        "id": 230983645,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616137522
    },
    {
        "content": "<p>Graded object -- in all sensible cases the d map respects the grading if you allow a twist of your index set</p>",
        "id": 230983653,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616137530
    },
    {
        "content": "<p>If we go for this d^2=0 model with one d then we're ruling out double complexes anyway. There we need two d 's and the axiom that they commute...wait, that isn't even true :-( a sensible d1d2 from A i j to B i+1 j+1 isn'ta silly d2d1</p>",
        "id": 230983894,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616137763
    },
    {
        "content": "<p>This sounds like exactly the sort of thing Markus gave us pseudoelements to do</p>",
        "id": 230983897,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1616137765
    },
    {
        "content": "<p>I thought that pseudoelements were just homs from a random object? The problem is that Z/4 -&gt; Z/2 is a surjection in the category of abelian groups but this unfortunately doesn't mean that Hom(X,Z/4) -&gt; Hom(X,Z/2) is a surjection, e.g. if X=Z/2 then this map is the zero map and doesn't hit the identity. I'm just asking how to state the snake lemma in an arbitrary abelian category basically. I don't see how to define the boundary map from ker(f3) to coker(f1) in a non-concrete setting.</p>",
        "id": 231024114,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616161417
    },
    {
        "content": "<p>I think using monos and epis</p>",
        "id": 231024275,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616161474
    },
    {
        "content": "<p>And for the boundary map, yeah, map into the diagram from some random object and use the mono/epi property of the morphisms involved</p>",
        "id": 231024358,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616161514
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"246273\">@Bhavik Mehta</span> maybe we should formalize the Freyd embedding theorem?</p>",
        "id": 231024528,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616161566
    },
    {
        "content": "<p>but epi doesn't imply surjection on hom sets -- if A -&gt; B is epi then Hom(X,A) -&gt; hom(X,B) might not be a surjection. I don't see how to start with this boundary map right now.</p>",
        "id": 231024652,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616161618
    },
    {
        "content": "<p>I'm just thinking of the usual snake lemma, no Hom(X,Y) involved there.</p>",
        "id": 231024808,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616161680
    },
    {
        "content": "<p>I need to define a map from ker(f3) to coker(f1). How do I even start? This is what I'm missing</p>",
        "id": 231024905,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616161707
    },
    {
        "content": "<p>Take <code>ker (f3)</code> to be the \"test object\" (the object you're mapping from)</p>",
        "id": 231024957,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616161736
    },
    {
        "content": "<p>Kevin I think you're thinking of generalised elements rather than pseudoelements</p>",
        "id": 231025010,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1616161753
    },
    {
        "content": "<p>Then chase around what happens to the identity morphism on <code>ker f3</code>.</p>",
        "id": 231025055,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616161770
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.abelian.pseudoelements\">docs#category_theory.abelian.pseudoelements</a></p>",
        "id": 231025071,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1616161776
    },
    {
        "content": "<p>Also if <span class=\"user-mention\" data-user-id=\"260921\">@Markus Himmel</span> is about, I think he could give much more helpful answers</p>",
        "id": 231025113,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1616161799
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/267928-condensed-mathematics/topic/complexes.2C.20d.2C.20dtt/near/231025055\">said</a>:</p>\n<blockquote>\n<p>Then chase around what happens to the identity morphism on <code>ker f3</code>.</p>\n</blockquote>\n<p>I don't understand what this means. I don't know the \"initial move\" right now.</p>",
        "id": 231025195,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616161823
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- An epimorphism is surjective on pseudoelements. -/</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">pseudo_surjective_of_epi</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"n\">Q</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"bp\">⟶</span> <span class=\"n\">Q</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">epi</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">function.surjective</span> <span class=\"n\">f</span> <span class=\"o\">:=</span>\n</code></pre></div>\n<p>What is this black magic?</p>",
        "id": 231025277,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616161859
    },
    {
        "content": "<p>That's the definition of epi :)</p>",
        "id": 231025322,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616161884
    },
    {
        "content": "<p>There's a coe from morphisms to functions on pseudoelements, and that function is surj iff the morphism is epi</p>",
        "id": 231025476,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1616161944
    },
    {
        "content": "<p>I don't know what pseudoelements are, but one way to think about this is that you take <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">H</mi><mi mathvariant=\"normal\">o</mi><mi mathvariant=\"normal\">m</mi></mrow><annotation encoding=\"application/x-tex\">\\mathrm{Hom}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">H</span><span class=\"mord mathrm\">o</span><span class=\"mord mathrm\">m</span></span></span></span></span>'s from some test object <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span>, but you allow yourself to replace <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span> by anything mapping surjectively onto it, at will</p>",
        "id": 231025588,
        "sender_full_name": "Peter Scholze",
        "timestamp": 1616162007
    },
    {
        "content": "<p>Yes, this seems to be the pseudoelement trick</p>",
        "id": 231025621,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616162024
    },
    {
        "content": "<p>(Formally, there are enough projective objects in the pro-category, but this is surely overkill)</p>",
        "id": 231025744,
        "sender_full_name": "Peter Scholze",
        "timestamp": 1616162074
    },
    {
        "content": "<p>so I just replace ker(f3) by ker(f2) for example, which maps to B2.</p>",
        "id": 231025764,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616162084
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">A</span> <span class=\"n\">classic</span> <span class=\"n\">application</span> <span class=\"n\">of</span> <span class=\"n\">pseudoelements</span> <span class=\"n\">are</span> <span class=\"n\">diagram</span> <span class=\"n\">lemmas</span> <span class=\"n\">like</span> <span class=\"n\">the</span> <span class=\"n\">four</span> <span class=\"kd\">lemma</span> <span class=\"n\">or</span> <span class=\"n\">the</span> <span class=\"n\">snake</span> <span class=\"kd\">lemma</span><span class=\"bp\">.</span>\n</code></pre></div>\n<p><span class=\"user-mention\" data-user-id=\"246273\">@Bhavik Mehta</span> do you know if Markus did the snake lemma? I think I need it for some class of categories e.g. abelian categories, I mean, I need it for R-modules, but I think Johan already hacked out a proof of that a long time ago -- I would rather prove it in an abelian category (once I've figured out how to define the boundary map!)</p>",
        "id": 231026385,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616162338
    },
    {
        "content": "<p>I did the snake lemma, but it didn't make it into mathlib</p>",
        "id": 231026567,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1616162404
    },
    {
        "content": "<p>Boundary map: I end up with some object A which surjects onto ker(f3) and also maps to coker(f1). I guess now I need to prove some results which says that something factors through something but I see how to do it now.</p>",
        "id": 231026599,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616162409
    },
    {
        "content": "<p>Where is it? I might be able to mathlib it up.</p>",
        "id": 231026637,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616162421
    },
    {
        "content": "<p>I've just this minute understood how to state it :-)</p>",
        "id": 231026706,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616162448
    },
    {
        "content": "<p>Kevin, if <code>X</code> is the top-right element in the diagram for the snake lemma, and <code>f3</code>is the map down from it, you probably want the map <code>ker(f3) -&gt; X</code> as your \"test object\"</p>",
        "id": 231026750,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616162466
    },
    {
        "content": "<p>Does zulip do tikz?</p>",
        "id": 231026805,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616162490
    },
    {
        "content": "<p>yes I see how to do it all now</p>",
        "id": 231026815,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616162493
    },
    {
        "content": "<p>It's <a href=\"https://github.com/TwoFX/lean-homological-algebra/blob/lean-3.8.0/src/diagram_lemmas/snake_diagram.lean\">here</a> but it's far from pretty</p>",
        "id": 231026821,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1616162495
    },
    {
        "content": "<p><span class=\"tex-error\">\\begin{tikzcd}\nA \\ar[r] &amp; B\n\\end{tikzcd}</span></p>",
        "id": 231026876,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616162516
    },
    {
        "content": "<p>It's A1 -&gt; B1 -&gt; C1 above A2 -&gt; B2 -&gt; C2 with maps f1, f2, f3 :-)</p>",
        "id": 231026988,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616162550
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/267928-condensed-mathematics/topic/complexes.2C.20d.2C.20dtt/near/231024528\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"246273\">Bhavik Mehta</span> maybe we should formalize the Freyd embedding theorem?</p>\n</blockquote>\n<p>About this, I remember <span class=\"user-mention\" data-user-id=\"260921\">@Markus Himmel</span> saying this was too hard at the time, but now that there's renewed interest and need in this, do you think it's feasible if a bunch of us work on it? If so, do you have an idea of what approaches would be cleanest?</p>",
        "id": 231029988,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1616163769
    },
    {
        "content": "<p>Actually, would this even help in the case of the snake lemma? You wouldn't want the <em>construction of the map</em> to depend on an embedding into a category of modules</p>",
        "id": 231030143,
        "sender_full_name": "Peter Scholze",
        "timestamp": 1616163836
    },
    {
        "content": "<p>And I think the construction of the map should be the most tedious part of this</p>",
        "id": 231030260,
        "sender_full_name": "Peter Scholze",
        "timestamp": 1616163870
    },
    {
        "content": "<p>The pseudoelement construction of the map goes like this: if 0 -&gt; A1 -&gt; B1 -&gt; C1 -&gt; 0 and same for 2 and we have maps down fA, fB, fC, then the crucial definition is X := B1 x_{B2} A2, which maps to C1 and to coker(fA), and one checks that X -&gt; C1 is surjective and its kernel is mapped to zero in coker(fA), so X induces a map C1 -&gt; coker(fA).</p>",
        "id": 231044188,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616168850
    },
    {
        "content": "<p>I think you should also take a fibre product over C_1 with the kernel of fC?</p>",
        "id": 231045157,
        "sender_full_name": "Peter Scholze",
        "timestamp": 1616169204
    },
    {
        "content": "<p>sorry you're right, I switched notation between pen and typing :-/ X maps to ker(C1) is surjective, but to get the map you should pull back again.</p>",
        "id": 231045705,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616169412
    },
    {
        "content": "<p>New style complexes and homotopies are in mathlib!!!</p>",
        "id": 238902838,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1621089943
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> I think that maybe the <code>comm'</code> field in <code>hom</code> is stated in the wrong direction compared to <code>nat_trans.naturality</code>. Because now we need</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">mul_one_iso</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">mul</span> <span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">obj</span> <span class=\"n\">BD</span> <span class=\"bp\">≅</span> <span class=\"n\">BD</span> <span class=\"o\">:=</span>\n<span class=\"n\">homological_complex.iso_of_components</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">FreeMat.one_mul_iso.app</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">$</span>\n<span class=\"bp\">λ</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">FreeMat.one_mul_iso.hom.naturality</span> <span class=\"o\">(</span><span class=\"n\">BD.d</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n<span class=\"c1\">-- notice the `.symm` at the end of the previous line</span>\n</code></pre></div>",
        "id": 238909212,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1621096170
    },
    {
        "content": "<p>Another bug:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">src</span><span class=\"bp\">/</span><span class=\"n\">category_theory</span><span class=\"bp\">/</span><span class=\"n\">limits</span><span class=\"bp\">/</span><span class=\"n\">shapes</span><span class=\"bp\">/</span><span class=\"n\">zero.lean</span>\n<span class=\"mi\">180</span><span class=\"o\">:</span><span class=\"n\">localized</span> <span class=\"s2\">\"attribute [instance] has_zero_object.has_zero\"</span> <span class=\"k\">in</span> <span class=\"n\">zero_object</span>\n<span class=\"mi\">181</span><span class=\"o\">:</span><span class=\"n\">localized</span> <span class=\"s2\">\"attribute [instance] has_zero_object.unique_to\"</span> <span class=\"k\">in</span> <span class=\"n\">zero_object</span>\n<span class=\"mi\">182</span><span class=\"o\">:</span><span class=\"n\">localized</span> <span class=\"s2\">\"attribute [instance] has_zero_object.unique_from\"</span> <span class=\"k\">in</span> <span class=\"n\">zero_object</span>\n</code></pre></div>\n<p>these should use fully qualified names</p>",
        "id": 238909405,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1621096333
    },
    {
        "content": "<p>Ooh, and this is a more serious bug:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- #check @homotopy</span>\n<span class=\"n\">homotopy</span> <span class=\"o\">:</span>\n  <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_3</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_2</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">_inst_1</span> <span class=\"o\">:</span> <span class=\"n\">category</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">_inst_2</span> <span class=\"o\">:</span> <span class=\"n\">has_zero_object</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">_inst_3</span> <span class=\"o\">:</span> <span class=\"n\">category_theory.preadditive</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">complex_shape</span> <span class=\"n\">ι</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"n\">D</span> <span class=\"o\">:</span> <span class=\"n\">homological_complex</span> <span class=\"n\">V</span> <span class=\"n\">c</span><span class=\"o\">},</span>\n    <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"bp\">⟶</span> <span class=\"n\">D</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"bp\">⟶</span> <span class=\"n\">D</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"n\">u_3</span> <span class=\"n\">u_1</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>The definition of <code>homotopy</code> requires <code>has_zero_object</code> whereas it should only ask for zero morphisms. The category <code>FreeMat</code> doesn't have a zero object.</p>",
        "id": 238909852,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1621096785
    },
    {
        "content": "<p>I've pushed what I've done so far (not so much) to <code>homological-refactor</code></p>",
        "id": 238910027,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1621096930
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/issues/7619\">#7619</a> fixes the locale issue</p>",
        "id": 238910450,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1621097377
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/267928-condensed-mathematics/topic/complexes.2C.20d.2C.20dtt/near/238909852\">said</a>:</p>\n<blockquote>\n<p>Ooh, and this is a more serious bug:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- #check @homotopy</span>\n<span class=\"n\">homotopy</span> <span class=\"o\">:</span>\n  <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_3</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_2</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">_inst_1</span> <span class=\"o\">:</span> <span class=\"n\">category</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">_inst_2</span> <span class=\"o\">:</span> <span class=\"n\">has_zero_object</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">_inst_3</span> <span class=\"o\">:</span> <span class=\"n\">category_theory.preadditive</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">complex_shape</span> <span class=\"n\">ι</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"n\">D</span> <span class=\"o\">:</span> <span class=\"n\">homological_complex</span> <span class=\"n\">V</span> <span class=\"n\">c</span><span class=\"o\">},</span>\n    <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"bp\">⟶</span> <span class=\"n\">D</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"bp\">⟶</span> <span class=\"n\">D</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"n\">u_3</span> <span class=\"n\">u_1</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>The definition of <code>homotopy</code> requires <code>has_zero_object</code> whereas it should only ask for zero morphisms. The category <code>FreeMat</code> doesn't have a zero object.</p>\n</blockquote>\n<p>I think you need <code>preadditive</code> for <code>homotopy</code>. But you're right, it shouldn't require zero objects</p>",
        "id": 238910754,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1621097670
    },
    {
        "content": "<p>The way it is currently set-up it fundamentally uses zero objects in some aux definitions.</p>",
        "id": 238910774,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1621097701
    },
    {
        "content": "<p>oof</p>",
        "id": 238910798,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1621097722
    },
    {
        "content": "<p>It's not just weakening the type class and we're good to go. We'll really need to tweak some code.</p>",
        "id": 238910805,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1621097726
    },
    {
        "content": "<p>Oh I see... you need zero objects for <code>X_next</code> and its friends</p>",
        "id": 238911018,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1621097912
    },
    {
        "content": "<p>So we can only talk about the next and previous objects when we have zero objects. That's an issue all in itself isn't it?</p>",
        "id": 238911068,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1621097991
    },
    {
        "content": "<p>Yes, I think so.</p>",
        "id": 238911095,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1621098004
    },
    {
        "content": "<p>Well, I guess we have <code>C.next</code> which gives <code>option ...</code></p>",
        "id": 238911134,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1621098015
    },
    {
        "content": "<p>For <code>nat</code>-indexed complexes with objects in a category without zero object we are basically stuck</p>",
        "id": 238911182,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1621098037
    },
    {
        "content": "<p>Aha, so we need to take <code>option</code> more serious</p>",
        "id": 238911211,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1621098052
    },
    {
        "content": "<p>Yeah, we can change the definition of <code>homotopy.comm</code> to match on some option type, but that will get tedious really quickly</p>",
        "id": 238911341,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1621098156
    },
    {
        "content": "<p>I think there are two options: state 4 (?) conditions, that deal with all the edge cases,<br>\nor turn <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>h</mi><mi>i</mi></msub><mo>∘</mo><msub><mi>d</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">h_i \\circ d_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">h</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∘</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> into a new definition, and make this <code>0</code> whenever <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>h</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">h_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">h</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> is not defined</p>",
        "id": 238911482,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1621098255
    },
    {
        "content": "<p>Oh that's a good idea!</p>",
        "id": 238911499,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1621098274
    },
    {
        "content": "<p>The one with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>h</mi><mi>i</mi></msub><mo>∘</mo><msub><mi>d</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">h_i \\circ d_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">h</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∘</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> I mean</p>",
        "id": 238911514,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1621098295
    },
    {
        "content": "<p>Quick sketch--</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">d_next</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"n\">C.X</span> <span class=\"n\">i</span> <span class=\"bp\">⟶</span> <span class=\"n\">D.X</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">C.X</span> <span class=\"n\">i</span> <span class=\"bp\">⟶</span> <span class=\"n\">D.X</span> <span class=\"n\">i</span> <span class=\"o\">:=</span>\n<span class=\"k\">match</span> <span class=\"n\">c.next</span> <span class=\"n\">i</span> <span class=\"k\">with</span>\n<span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"o\">⟨</span><span class=\"n\">i'</span><span class=\"o\">,</span><span class=\"n\">w</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">C.d</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">≫</span> <span class=\"n\">f</span> <span class=\"n\">i'</span> <span class=\"n\">i</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">prev_d</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"n\">C.X</span> <span class=\"n\">i</span> <span class=\"bp\">⟶</span> <span class=\"n\">D.X</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">C.X</span> <span class=\"n\">j</span> <span class=\"bp\">⟶</span> <span class=\"n\">D.X</span> <span class=\"n\">j</span> <span class=\"o\">:=</span>\n<span class=\"k\">match</span> <span class=\"n\">c.prev</span> <span class=\"n\">j</span> <span class=\"k\">with</span>\n<span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"o\">⟨</span><span class=\"n\">j'</span><span class=\"o\">,</span><span class=\"n\">w</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">f</span> <span class=\"n\">j</span> <span class=\"n\">j'</span> <span class=\"bp\">≫</span> <span class=\"n\">D.d</span> <span class=\"n\">_</span> <span class=\"n\">_</span>\n<span class=\"kd\">end</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">A homotopy `h` between chain maps `f` and `g` consists of components `h i j : C.X i ⟶ D.X j`</span>\n<span class=\"sd\">which are zero unless `c.rel j i`, satisfying the homotopy condition.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">@[ext, nolint has_inhabited_instance]</span>\n<span class=\"kd\">structure</span> <span class=\"n\">homotopy</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"bp\">⟶</span> <span class=\"n\">D</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">hom</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"n\">C.X</span> <span class=\"n\">i</span> <span class=\"bp\">⟶</span> <span class=\"n\">D.X</span> <span class=\"n\">j</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">zero'</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"bp\">¬</span> <span class=\"n\">c.rel</span> <span class=\"n\">j</span> <span class=\"n\">i</span> <span class=\"bp\">→</span> <span class=\"n\">hom</span> <span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">.</span> <span class=\"n\">obviously</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">comm'</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">f.f</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">d_next</span> <span class=\"n\">hom</span> <span class=\"n\">_</span> <span class=\"bp\">+</span> <span class=\"n\">prev_d</span> <span class=\"n\">hom</span> <span class=\"n\">_</span> <span class=\"bp\">.</span> <span class=\"n\">obviously'</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 238912142,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1621098763
    },
    {
        "content": "<p>I have to go for now, but I'll try to play with this defn later</p>",
        "id": 238912164,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1621098808
    },
    {
        "content": "<p><span aria-label=\"rofl\" class=\"emoji emoji-1f923\" role=\"img\" title=\"rofl\">:rofl:</span> why a line break in <code>comm'</code>? The condition is now really short... <span aria-label=\"rofl\" class=\"emoji emoji-1f923\" role=\"img\" title=\"rofl\">:rofl:</span></p>",
        "id": 238912165,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1621098810
    },
    {
        "content": "<p>I think I like this idea. It's quite close to the informal justifications that we give when someone asks about the edge conditions.</p>",
        "id": 238912424,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1621099076
    },
    {
        "content": "<p>Sorry, the above is wrong -- we need this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[ext, nolint has_inhabited_instance]</span>\n<span class=\"kd\">structure</span> <span class=\"n\">homotopy</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"bp\">⟶</span> <span class=\"n\">D</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">hom</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"n\">C.X</span> <span class=\"n\">i</span> <span class=\"bp\">⟶</span> <span class=\"n\">D.X</span> <span class=\"n\">j</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">zero'</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"bp\">¬</span> <span class=\"n\">c.rel</span> <span class=\"n\">j</span> <span class=\"n\">i</span> <span class=\"bp\">→</span> <span class=\"n\">hom</span> <span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">.</span> <span class=\"n\">obviously</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">comm'</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">f.f</span> <span class=\"n\">i</span> <span class=\"bp\">-</span> <span class=\"n\">g.f</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">d_next</span> <span class=\"n\">hom</span> <span class=\"n\">_</span> <span class=\"bp\">+</span> <span class=\"n\">prev_d</span> <span class=\"n\">hom</span> <span class=\"n\">_</span> <span class=\"bp\">.</span> <span class=\"n\">obviously'</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 238913708,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1621100304
    },
    {
        "content": "<p>( I deleted too much :) )</p>",
        "id": 238913797,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1621100410
    },
    {
        "content": "<p>Modulo a couple of sorry's and some linting that needs to be done, here's a branch with the fix to <code>homotopy</code>: <a href=\"https://github.com/leanprover-community/mathlib/tree/homotopy_fix\">branch#homotopy_fix</a></p>",
        "id": 238916967,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1621103638
    },
    {
        "content": "<p>I don't know how this affects all the other PRs though...</p>",
        "id": 238917045,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1621103677
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> please feel free to adopt and/or do whatever you want with this branch!</p>",
        "id": 238917257,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1621103946
    },
    {
        "content": "<p>I think <span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> is the only one with a clear overview of how this will affect the other PRs</p>",
        "id": 238917271,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1621103989
    },
    {
        "content": "<p>Okay, I've fixed a few sorries. You changed the term order in <code>comm'</code>, so I'm updating some things in the inductive constructions to match that, but may end up flipping the term order back later.</p>",
        "id": 238938987,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1621128297
    },
    {
        "content": "<p>I'll try the last sorry now, then try it out in <a href=\"https://github.com/leanprover-community/mathlib/tree/homotopy_category\">branch#homotopy_category</a>. If it works okay there (it should) everything else will probably be fine.</p>",
        "id": 238939023,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1621128334
    },
    {
        "content": "<p>This is a nice fix, <span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span>!</p>",
        "id": 238939031,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1621128342
    },
    {
        "content": "<p>It seems there's more work required to restore the proof of <code>homology_map_eq_of_homotopy</code> in this branch.</p>",
        "id": 238940281,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1621129760
    },
    {
        "content": "<p>We need to be able to see easily that <code>d_next</code> factors through <code>d_from</code> (which is the case whether these are zero or not).</p>",
        "id": 238940306,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1621129799
    },
    {
        "content": "<p>Okay, I've dealt with this.</p>",
        "id": 238941541,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1621131179
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/tree/homotopy_category\">branch#homotopy_category</a> works with no changes, so I've just merged this branch into that.</p>",
        "id": 238941551,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1621131195
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span>, do you want to make <a href=\"https://github.com/leanprover-community/mathlib/tree/homotopy_fix\">branch#homotopy_fix</a> a separate PR, and I'll add the dependency?</p>",
        "id": 238941554,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1621131215
    },
    {
        "content": "<p>Sure, that works! I won't be able to open the PR tonight, but I can probably do it at some point tomorrow, or you could open the PR now if you have time.</p>",
        "id": 238941749,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1621131438
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/issues/7621\">#7621</a></p>",
        "id": 238945102,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1621135176
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span>, a way above in this thread you said <code>FreeMat</code> doesn't have a zero object. Surely <code>Free k (Mat R)</code> (not that we actually have that yet, <code>sorry</code>) has a zero object. (Err... the zero-ary direct sum? not sure what to call it besides the zero object!) Am I being confused?</p>",
        "id": 238966438,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1621160447
    },
    {
        "content": "<p>Another minor bug: <code>homotopy</code> is not in the <code>category_theory</code> namespace. I guess that <code>_root_.homotopy</code> deserves to be reserved for homotopies in topology.</p>",
        "id": 239203503,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1621318866
    },
    {
        "content": "<p>Another small bug:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- move to mathlib</span>\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">simps</span><span class=\"o\">]</span> <span class=\"n\">homotopy.refl</span> <span class=\"n\">homotopy.symm</span> <span class=\"n\">homotopy.trans</span> <span class=\"n\">homotopy.comp_left</span> <span class=\"n\">homotopy.comp_right</span>\n</code></pre></div>",
        "id": 239204721,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1621319691
    },
    {
        "content": "<p>I don't think we should put anything about homological algebra in the <code>category_theory</code> namespace. If we need to disambiguate two versions of <code>homotopy</code> lets use <code>homological_algebra.homotopy</code> or <code>homology.homotopy</code> or <code>topology.homotopy</code> or <code>continuous_map.homotopy</code>.</p>",
        "id": 239213530,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1621324949
    },
    {
        "content": "<p><code>homological_complex.homotopy</code>?</p>",
        "id": 239213635,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1621324995
    },
    {
        "content": "<p>So, we merged the homotopy fix that uses <code>d_next</code> and <code>prev_d</code>. But now I'm wondering if the following hack would be too evil to pass up:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">complex_shape.next'</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">match</span> <span class=\"n\">c.next</span> <span class=\"n\">i</span> <span class=\"k\">with</span>\n<span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"o\">:=</span> <span class=\"n\">i</span>\n<span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"bp\">\\&lt;</span><span class=\"n\">j</span><span class=\"o\">,</span><span class=\"n\">w</span><span class=\"bp\">\\&gt;</span> <span class=\"o\">:=</span> <span class=\"n\">j</span>\n</code></pre></div>\n<p>etc...<br>\nThen we can still write \"the usual homotopy condition\", using <code>hom i (c.prev' i)</code> and <code>hom (c.next' i) i</code>. But for the edge cases these will become \"vertical\" homotopy maps composed with \"stationary\" differentials. Those compositions will be <code>0</code> for two reasons <span aria-label=\"smiley\" class=\"emoji emoji-1f603\" role=\"img\" title=\"smiley\">:smiley:</span></p>",
        "id": 239223556,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1621330118
    },
    {
        "content": "<p>The branch <code>homological-refactor</code> compiles again, but I've sorried 4 proofs:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"mi\">1</span>       <span class=\"n\">src</span><span class=\"bp\">/</span><span class=\"n\">normed_spectral.lean</span>\n<span class=\"mi\">1</span>       <span class=\"n\">src</span><span class=\"bp\">/</span><span class=\"n\">thm95</span><span class=\"bp\">/</span><span class=\"n\">homotopy.lean</span>\n<span class=\"mi\">1</span>       <span class=\"n\">src</span><span class=\"bp\">/</span><span class=\"n\">thm95</span><span class=\"bp\">/</span><span class=\"n\">default.lean</span>\n<span class=\"mi\">10</span>      <span class=\"n\">src</span><span class=\"bp\">/</span><span class=\"n\">thm95</span><span class=\"bp\">/</span><span class=\"kd\">constants</span><span class=\"bp\">.</span><span class=\"n\">lean</span>\n<span class=\"mi\">1</span>       <span class=\"n\">src</span><span class=\"bp\">/</span><span class=\"n\">locally_constant</span><span class=\"bp\">/</span><span class=\"n\">SemiNormedGroup.lean</span>\n<span class=\"mi\">1</span>       <span class=\"n\">src</span><span class=\"bp\">/</span><span class=\"n\">prop_92</span><span class=\"bp\">/</span><span class=\"n\">prop_92.lean</span>\n<span class=\"mi\">2</span>       <span class=\"n\">src</span><span class=\"bp\">/</span><span class=\"n\">prop_92</span><span class=\"bp\">/</span><span class=\"n\">concrete.lean</span>\n<span class=\"mi\">1</span>       <span class=\"n\">src</span><span class=\"bp\">/</span><span class=\"n\">breen_deligne</span><span class=\"bp\">/</span><span class=\"n\">eg.lean</span>\n<span class=\"mi\">1</span>       <span class=\"n\">src</span><span class=\"bp\">/</span><span class=\"n\">pseudo_normed_group</span><span class=\"bp\">/</span><span class=\"n\">system_of_complexes.lean</span>\n<span class=\"n\">Total</span><span class=\"o\">:</span>  <span class=\"mi\">19</span>\n</code></pre></div>",
        "id": 239224911,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1621330732
    },
    {
        "content": "<p>Once those are fixed, I'll merge into master</p>",
        "id": 239224945,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1621330749
    },
    {
        "content": "<p>I'm now porting the last file in the homological refactor, which had to wait for another mathlib PR.</p>",
        "id": 239372662,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1621405598
    },
    {
        "content": "<p>After that LTE old style chain complexes can be forcefully kicked out of the project. So long, and thanks for all the fish!</p>",
        "id": 239372693,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1621405630
    },
    {
        "content": "<p>It also means that the blueprint will compile again. Right now it is upset that there are two notions of chain complex in the project.</p>",
        "id": 239372734,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1621405661
    },
    {
        "content": "<p>ooh, that went really smooth. 800 lines less in the project</p>",
        "id": 239373087,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1621405888
    },
    {
        "content": "<p>What's the current de Bruijn factor of LTE?</p>",
        "id": 239375145,
        "sender_full_name": "Peter Scholze",
        "timestamp": 1621407276
    },
    {
        "content": "<p>What happens when you say \"by a well known result this monoid is finitely generated\" and we write 1000 lines justifying this? I've never really understood that bit of the de Bruijn story</p>",
        "id": 239375910,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1621407737
    },
    {
        "content": "<p>Good question. Is Gordan's lemma part of mathlib? I think it should be. Everything that ends in mathlib shouldn't count towards the de Bruijn factor</p>",
        "id": 239376025,
        "sender_full_name": "Peter Scholze",
        "timestamp": 1621407791
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">$</span> <span class=\"n\">git</span> <span class=\"n\">ls</span><span class=\"bp\">-</span><span class=\"n\">files</span> <span class=\"bp\">|</span> <span class=\"n\">rg</span> <span class=\"s2\">\"[.]tex\"</span> <span class=\"bp\">|</span> <span class=\"n\">rg</span> <span class=\"bp\">-</span><span class=\"n\">v</span> <span class=\"n\">web</span> <span class=\"bp\">|</span> <span class=\"n\">rg</span> <span class=\"bp\">-</span><span class=\"n\">v</span> <span class=\"n\">macros</span> <span class=\"bp\">|</span> <span class=\"n\">xargs</span> <span class=\"n\">wc</span>\n  <span class=\"mi\">294</span>  <span class=\"mi\">1333</span> <span class=\"mi\">10790</span> <span class=\"n\">src</span><span class=\"bp\">/</span><span class=\"n\">CLC.tex</span>\n   <span class=\"mi\">84</span>   <span class=\"mi\">329</span>  <span class=\"mi\">2628</span> <span class=\"n\">src</span><span class=\"bp\">/</span><span class=\"n\">Mbar.tex</span>\n   <span class=\"mi\">61</span>    <span class=\"mi\">76</span>  <span class=\"mi\">1559</span> <span class=\"n\">src</span><span class=\"bp\">/</span><span class=\"n\">blueprint.tex</span>\n  <span class=\"mi\">375</span>  <span class=\"mi\">1629</span> <span class=\"mi\">12449</span> <span class=\"n\">src</span><span class=\"bp\">/</span><span class=\"n\">breen_deligne.tex</span>\n   <span class=\"mi\">22</span>    <span class=\"mi\">65</span>   <span class=\"mi\">549</span> <span class=\"n\">src</span><span class=\"bp\">/</span><span class=\"n\">content.tex</span>\n  <span class=\"mi\">117</span>   <span class=\"mi\">777</span>  <span class=\"mi\">5853</span> <span class=\"n\">src</span><span class=\"bp\">/</span><span class=\"n\">homotopies.tex</span>\n   <span class=\"mi\">96</span>   <span class=\"mi\">487</span>  <span class=\"mi\">3779</span> <span class=\"n\">src</span><span class=\"bp\">/</span><span class=\"n\">normed_groups.tex</span>\n  <span class=\"mi\">578</span>  <span class=\"mi\">3280</span> <span class=\"mi\">24037</span> <span class=\"n\">src</span><span class=\"bp\">/</span><span class=\"n\">normed_homological.tex</span>\n  <span class=\"mi\">234</span>  <span class=\"mi\">1033</span>  <span class=\"mi\">8196</span> <span class=\"n\">src</span><span class=\"bp\">/</span><span class=\"n\">polyhedral_lattice.tex</span>\n  <span class=\"mi\">331</span>  <span class=\"mi\">1877</span> <span class=\"mi\">14912</span> <span class=\"n\">src</span><span class=\"bp\">/</span><span class=\"n\">proof.tex</span>\n <span class=\"mi\">2192</span> <span class=\"mi\">10886</span> <span class=\"mi\">84752</span> <span class=\"n\">total</span>\n</code></pre></div>",
        "id": 239383958,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1621412170
    },
    {
        "content": "<p>The numbers are <code>lines</code>, <code>words</code>, <code>characters</code></p>",
        "id": 239383985,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1621412184
    },
    {
        "content": "<p>For the Lean repo we get (excluding <code>for_mathlib</code>)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code> <span class=\"mi\">15462</span>  <span class=\"mi\">94994</span> <span class=\"mi\">603189</span> <span class=\"n\">total</span>\n</code></pre></div>",
        "id": 239384120,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1621412262
    },
    {
        "content": "<p>Freek likes to compress the files (TeX and Lean) and compare lengths afterwards. And maybe ignoring <code>for_mathlib</code> is OK.</p>",
        "id": 239384140,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1621412273
    },
    {
        "content": "<p>I agree that a proper comparison should first compress everything</p>",
        "id": 239384226,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1621412303
    },
    {
        "content": "<p>Maybe comparing the blueprint with the repo is a more reasonable thing than comparing the relevant parts of the paper</p>",
        "id": 239384229,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1621412304
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"369530\">@Peter Scholze</span> But we aren't done yet...</p>",
        "id": 239389050,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1621414730
    },
    {
        "content": "<p>Yes, but I'd be surprised if this changes by another factor of 2 <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>",
        "id": 239389091,
        "sender_full_name": "Peter Scholze",
        "timestamp": 1621414756
    },
    {
        "content": "<p>True</p>",
        "id": 239389099,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1621414764
    },
    {
        "content": "<p>About this factor, I should point out that, in Lemma 9.2, the most Lean-consuming line is clearly \"We first note that any locally constant function <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>φ</mi><mo>∈</mo><mi>V</mi><mo stretchy=\"false\">(</mo><msubsup><mi>M</mi><mrow><mo>≤</mo><msup><mi>r</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mi>c</mi></mrow><mi>a</mi></msubsup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\varphi ∈ V(M_{\\leq r&#x27;c}^a)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7335400000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">φ</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.1201590000000001em;vertical-align:-0.370159em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-2.42502em;margin-left:-0.10903em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mrel mtight\">≤</span><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02778em;\">r</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6828285714285715em;\"><span style=\"top:-2.786em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mord mathnormal mtight\">c</span></span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">a</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.370159em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>  can be extended to a locally constant function <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mover accent=\"true\"><mi>φ</mi><mo>ˉ</mo></mover><mo>∈</mo><mi>V</mi><mo stretchy=\"false\">(</mo><msubsup><mi>M</mi><mrow><mo>≤</mo><mi>c</mi></mrow><mi>a</mi></msubsup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\bar \\varphi ∈ V(M_{\\leq c}^a)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7622199999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord accent\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.56778em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord mathnormal\">φ</span></span><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"accent-body\" style=\"left:-0.16666em;\"><span class=\"mord\">ˉ</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.19444em;\"><span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.092179em;vertical-align:-0.342179em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-2.4530000000000003em;margin-left:-0.10903em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mrel mtight\">≤</span><span class=\"mord mathnormal mtight\">c</span></span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">a</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.342179em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>  with the same norm\". This took much more work than juggling with sums and norm estimates.</p>",
        "id": 239390192,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1621415356
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/issues/7651\">#7651</a> and <a href=\"https://github.com/leanprover-community/mathlib/issues/7656\">#7656</a> (both merged) can be used to get rid of <code>for_mathlib/simplicial/right_op.lean</code>. I can do it later today, but just thought I would mention it in case anyone is already doing some cleaning up</p>",
        "id": 239421131,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1621430018
    },
    {
        "content": "<p>I did half of it</p>",
        "id": 239421711,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1621430209
    },
    {
        "content": "<p>Which half is left?</p>",
        "id": 239422165,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1621430363
    },
    {
        "content": "<p>I only removed the first bit.</p>",
        "id": 239422671,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1621430540
    },
    {
        "content": "<p>Because Lean told me it already existed, when I bumped mathlib</p>",
        "id": 239422702,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1621430553
    },
    {
        "content": "<p>Oh <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 239423045,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1621430669
    },
    {
        "content": "<p>Okay, <code>for_mathlib/simplicial/right_op.lean</code> is no more.</p>",
        "id": 239432889,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1621434220
    },
    {
        "content": "<p>I think we should have some <code>(co)chain_complex.mk_hom_of</code> that says you only need to check commutativity of squares. That would play nice with <code>(co)chain_complex.of</code></p>",
        "id": 239434530,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1621434752
    },
    {
        "content": "<p>But it shouldn't assume that the complexes are constructed using <code>.of</code></p>",
        "id": 239434715,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1621434804
    },
    {
        "content": "<p>We have it... <a href=\"https://leanprover-community.github.io/mathlib_docs/find/cochain_complex.of_hom\">docs#cochain_complex.of_hom</a></p>",
        "id": 239434980,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1621434897
    },
    {
        "content": "<p>Some of the code in <code>for_mathlib/simplicial/complex</code> can be simplified using this</p>",
        "id": 239435085,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1621434931
    },
    {
        "content": "<p>Ah sorry, that assumes they're constructed using of</p>",
        "id": 239435238,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1621434974
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/cochain_complex.augment\">docs#cochain_complex.augment</a> can also be useful</p>",
        "id": 239435494,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1621435074
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/267928-condensed-mathematics/topic/complexes.2C.20d.2C.20dtt/near/239434980\">said</a>:</p>\n<blockquote>\n<p>We have it... <a href=\"https://leanprover-community.github.io/mathlib_docs/find/cochain_complex.of_hom\">docs#cochain_complex.of_hom</a></p>\n</blockquote>\n<p>But this one does assume that the complexes are constructed using <code>.of</code></p>",
        "id": 239437556,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1621435742
    },
    {
        "content": "<p>Ooh, you already said that <span aria-label=\"face palm\" class=\"emoji emoji-1f926\" role=\"img\" title=\"face palm\">:face_palm:</span></p>",
        "id": 239437582,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1621435753
    },
    {
        "content": "<p>Do we have any complexes not constructed using <code>.of</code> in LTE?</p>",
        "id": 239437762,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1621435817
    },
    {
        "content": "<p>Yeah, complexes constructed using <code>.of</code> but then pushed through 5 functors</p>",
        "id": 239437974,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1621435895
    },
    {
        "content": "<p>Right</p>",
        "id": 239438195,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1621435972
    },
    {
        "content": "<p>We probably also need a construction saying that any complex is isomorphic to <code>.of</code> of something</p>",
        "id": 239439690,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1621436450
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/issues/7666\">#7666</a> is fixes the problem of <code>hom_of</code> by adding <code>c.rel i j</code> as condition to <code>hom.comm'</code>.<br>\nInstead of <code>restate_axiom hom.comm'</code> I then state <code>hom.comm</code> without <code>c.rel i j</code>.<br>\nUpshot: when using <code>hom.comm</code> you don't need the assumption, but when you need to verify the axiom you get the extra assumption.</p>",
        "id": 239455566,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1621441775
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/issues/7673\">#7673</a> does the same for <code>d_comp_d'</code></p>",
        "id": 239488447,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1621454995
    }
]
[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> <span class=\"user-mention\" data-user-id=\"112857\">@Leonardo de Moura</span>  Do you think that the nsmul/gsmul type of diamonds that we had before the refactor can be gracefully dealt with by Lean 4. Maybe not current stock Lean 4. But could we teach it to deal with such diamonds in principle?<br>\n(Asking on this stream instead of <a class=\"stream\" data-stream-id=\"270676\" href=\"/#narrow/stream/270676-lean4\">#lean4</a> because Peter is also interested in the question and answers.)</p>",
        "id": 235705231,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1619108007
    },
    {
        "content": "<p>I don't think that there is anything in particular about nsmul that is problematic</p>",
        "id": 235705449,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619108092
    },
    {
        "content": "<p>The performance issues we are hitting are just because we have a large hierarchy, plus possibly something odd in the kernel settings</p>",
        "id": 235705685,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619108174
    },
    {
        "content": "<p>I have no idea whether lean 4 will change things, because it will change so many things that this problem will barely be recognizable. We will have entirely different problems in lean 4 (hopefully less overall but there is no easy comparison)</p>",
        "id": 235705870,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619108261
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> We are committed to making sure Lean 4 serves all of our sub-communities. It would be great for us to have a (small) self-contained Lean file that exposes the problem you mentioned. Do you think you could it?</p>",
        "id": 235709259,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1619109665
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span> did the refactor, so he might be in a better shape to do this.</p>",
        "id": 235711640,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1619110578
    },
    {
        "content": "<p>do we actually have an example of a slow definition?</p>",
        "id": 235711728,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619110620
    },
    {
        "content": "<p>We are trying to drill down to the bottom of the speed issue in <a href=\"#narrow/stream/113488-general/topic/mathlib.20repo.20GitHub.20actions.20queue\">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mathlib.20repo.20GitHub.20actions.20queue</a></p>",
        "id": 235711763,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1619110636
    },
    {
        "content": "<p>I think there are two issues:</p>\n<ol>\n<li>Why is Lean 3 slow after the refactor. (That's not what my question in this thread is about.)</li>\n<li>Can we make \"minimalistic\" definitions in Lean 4. Or do we need to have \"forgetful inheritance\" in many places. (That's what I was intending in OP.)</li>\n</ol>",
        "id": 235711969,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1619110718
    },
    {
        "content": "<p>Examples where we use this pattern: <code>metric_space</code> includes a copy of <code>uniform_space</code> includes a copy of <code>topological_space</code>.<br>\nAnd now: <code>add_comm_monoid</code> includes (what amounts to) a copy of <code>semimodule nat</code>, and <code>add_comm_group</code> is about to include on top of that a \"copy\" of <code>module int</code>.<br>\nBut there is now a pattern. Because <code>[division_ring R] [char_zero R]</code> will give an instance of <code>algebra rat R</code>. And so there's another \"forgetful diamond\" lurking around the corner.</p>",
        "id": 235712466,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1619110891
    },
    {
        "content": "<p>I think that what we see after the refactor is just a symptom, that kernel checking of definitional equality is very slow in some situations. Since I have added three fields to structures as basic as <code>monoid</code> and <code>add_monoid</code>, it made some iterated unfolding/refolding steps heavier, hence the slowness. Normally, this should be solved by not using old style structures (and Leo had warned us about this some time ago!)</p>",
        "id": 235712683,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1619110952
    },
    {
        "content": "<p>It may certainly be a symptom of something else. But my question (2) is aiming more at the underlying philosophy of library design that we should aim for / adhere to. Can we \"just\" write down the \"minimalist\" definitions that are in some sense the Platonic \"correct\" ones. Or should we be prepared to have 3x more data in <code>add_comm_group</code> than one would (naively) expect.</p>",
        "id": 235713154,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1619111105
    },
    {
        "content": "<p>There is a slight difference between the topological and the algebraic examples. For topology, you want the product topology and the metric topology on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi><mo>×</mo><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">X \\times Y</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span></span></span></span> to be defeq. But there isn't some universal theorem telling you that it should (afaik).<br>\nIn the algebraic examples, we have instances <code>subsingleton (module int A)</code> for arbitrary abelian groups <code>A</code>, and similarly <code>subsingleton (algebra int R)</code> for arbitrary rings <code>R</code>, etc...</p>",
        "id": 235713511,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1619111225
    },
    {
        "content": "<p>It seems to me that a typechecker could in principle take advantage of such <code>subsingleton</code>s at a low level.<br>\nBut I can absolutely understand that this may be a completely ridiculous idea from a performance point of view.<br>\nI just don't have enough understanding to know whether it is just a tiny bit ridiculous or super-duper ridiculous.</p>",
        "id": 235713757,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1619111315
    },
    {
        "content": "<p>In general, I think I lean towards \"first make it fast, then fix the UX\". So if we need long-winded definitions in order to have a fast kernel, I'm very happy to make that trade off.</p>",
        "id": 235713944,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1619111401
    },
    {
        "content": "<p>It's more than a performance issue. You are talking about having multiple paths of typeclass inference that are not defeq. In order to make that work seamlessly lean has to be able to cast between types, and I think that getting good UX on this is an open problem</p>",
        "id": 235715027,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619111829
    },
    {
        "content": "<p>Ok, that's a useful answer. (I was hoping that maybe it was a problem that was solved in Lean 4.)</p>",
        "id": 235715275,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1619111934
    },
    {
        "content": "<p>The problem that is potentially solved in lean 4 is the performance issues we are having with deep algebraic hierarchies with many fields</p>",
        "id": 235715554,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619112053
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112857\">Leonardo de Moura</span> <a href=\"#narrow/stream/267928-condensed-mathematics/topic/nsmul.20and.20Lean.204/near/235709259\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> We are committed to making sure Lean 4 serves all of our sub-communities. It would be great for us to have a (small) self-contained Lean file that exposes the problem you mentioned. Do you think you could it?</p>\n</blockquote>\n<p>Thanks a lot for your commitment to all these diverse sub-communities. Let me try to answer your question. In the last few days, I think I gained a better understanding of the issue, and more or less understand why the answer to my vague question is \"you don't want this\". The answer seems to be: use forgetful inheritance and new-style structures.</p>\n<p>But at the same time I stumbled on a related issue. Let me first say that it is currently not a serious problem for LTE. So there is not really an urgent need to solve a particular problem.</p>\n<p>The problem is the following. In mathlib we have the following definition (the details don't matter, what matters is that it is in mathlib):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- A seminormed group is an additive group endowed with a norm for which `dist x y = ∥x - y∥`</span>\n<span class=\"sd\">defines a pseudometric space structure. -/</span>\n<span class=\"kd\">class</span> <span class=\"n\">semi_normed_group</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">has_norm</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">add_comm_group</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">pseudo_metric_space</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">dist_eq</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">dist</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">norm</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">-</span> <span class=\"n\">y</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>In LTE we have the following definition (again, the details don't really matter, what matters is that this definition is in LTE and contains data):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">pseudo_normed_group</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">[</span><span class=\"n\">to_add_comm_group</span> <span class=\"o\">:</span> <span class=\"n\">add_comm_group</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n<span class=\"o\">(</span><span class=\"n\">filtration</span> <span class=\"o\">[]</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"bp\">≥</span><span class=\"mi\">0</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"n\">M</span><span class=\"o\">)</span>\n<span class=\"c\">/-</span><span class=\"cm\"> snip -/</span>\n</code></pre></div>\n<p>Finally, we have the following instance:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">semi_normed_group</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">pseudo_normed_group</span> <span class=\"n\">V</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">filtration</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"bp\">|</span> <span class=\"n\">nnnorm</span> <span class=\"n\">v</span> <span class=\"bp\">≤</span> <span class=\"n\">c</span><span class=\"o\">},</span>\n  <span class=\"c\">/-</span><span class=\"cm\"> snip -/</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>Now this is a source of diamonds: we end up with two propeq-but-not-defeq instances on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mrow><mi mathvariant=\"normal\">H</mi><mi mathvariant=\"normal\">o</mi><mi mathvariant=\"normal\">m</mi></mrow><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">Λ</mi><mo separator=\"true\">,</mo><mi>M</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\mathrm{Hom}(\\Lambda, M)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">Hom</span></span><span class=\"mopen\">(</span><span class=\"mord\">Λ</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mclose\">)</span></span></span></span> (whatever that may be).</p>\n<p>The usual solution would be: refactor the definition of <code>semi_normed_group</code> so that it extends <code>pseudo_normed_group</code> using forgetful inheritance.</p>\n<p>But since <code>pseudo_normed_group</code> is in LTE, this is not an option. And it is currently not clear that this definition belongs in mathlib.</p>\n<p>Let me stress again that the diamond does not cause serious trouble in LTE. It shows up, but we can work around it with a couple lines of code.</p>\n<p>But I do think that this is an example of a more general pattern: that \"small\" projects depending on a big library like mathlib will want to inject new definitions in the middle of the hierarchy. The current design strategy of forgetful inheritance only seems to work for monolithic libraries.<br>\nI hope the picture is somewhat clear, and I would be very interested in hearing your thoughts about strategies for working with multiple interdependent Lean packages that build and extend the same hierarchy.</p>",
        "id": 236895169,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1619813783
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">bar</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">foo.to_bar</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">foo</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">bar</span> <span class=\"n\">X</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"n\">i.n</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">prod.foo</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">foo</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">foo</span> <span class=\"n\">Y</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">×</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">i.n</span> <span class=\"bp\">+</span> <span class=\"n\">j.n</span> <span class=\"o\">}</span> <span class=\"c1\">-- X + Y</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">prod.bar</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">bar</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">bar</span> <span class=\"n\">Y</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">bar</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">×</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"n\">j.m</span> <span class=\"bp\">+</span> <span class=\"n\">i.m</span> <span class=\"o\">}</span> <span class=\"c1\">-- Y + X, i.e. opposite order</span>\n\n<span class=\"c1\">-- non-defeq diamond</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">foo</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">foo</span> <span class=\"n\">Y</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">foo.to_bar</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">×</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">prod.bar</span> <span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span> <span class=\"c1\">-- not `rfl`</span>\n\n<span class=\"c1\">-- fix: refactor foo</span>\n<span class=\"kd\">class</span> <span class=\"n\">foo_fixed</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">foo_fixed.to_bar</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">foo_fixed</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">bar</span> <span class=\"n\">X</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"n\">i.m</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">prod.foo_fixed</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">foo_fixed</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">foo_fixed</span> <span class=\"n\">Y</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">foo_fixed</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">×</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">i.n</span> <span class=\"bp\">+</span> <span class=\"n\">j.n</span><span class=\"o\">,</span>\n  <span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"n\">j.m</span> <span class=\"bp\">+</span> <span class=\"n\">i.m</span><span class=\"o\">,</span>  <span class=\"c1\">-- makes diamond go away</span>\n  <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">i.h</span><span class=\"o\">,</span> <span class=\"n\">j.h</span><span class=\"o\">,</span> <span class=\"n\">nat.add_comm</span><span class=\"o\">],</span> <span class=\"c1\">-- proof now inserted into type class system</span>\n  <span class=\"kd\">end</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">foo_fixed</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">foo_fixed</span> <span class=\"n\">Y</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">foo_fixed.to_bar</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">×</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">prod.bar</span> <span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"c1\">-- but what if `foo` is in a dependency so we can't refactor it?</span>\n</code></pre></div>",
        "id": 237012834,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619915266
    },
    {
        "content": "<p>An even better example would be m=2°n because this cannot be fixed with a change of definition of <a href=\"http://prod.bar\">prod.bar</a> -- will update tomorrow</p>",
        "id": 237014022,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619916590
    },
    {
        "content": "<p>Better example -- can't be fixed by refactoring <code>bar</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">bar</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">foo.to_bar</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">foo</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">bar</span> <span class=\"n\">X</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">i.n</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">prod.foo</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">foo</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">foo</span> <span class=\"n\">Y</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">×</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">i.n</span> <span class=\"bp\">+</span> <span class=\"n\">j.n</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">prod.bar</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">bar</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">bar</span> <span class=\"n\">Y</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">bar</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">×</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"n\">i.m</span> <span class=\"bp\">+</span> <span class=\"n\">j.m</span> <span class=\"o\">}</span>\n\n<span class=\"c1\">-- important example with m odd means we can't refactor `bar` to include `foo`</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">bar</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span><span class=\"o\">}</span>\n\n<span class=\"c1\">-- non-defeq diamond because `2*(a+b)` and `2*a+2*b` are not defeq</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">foo</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">foo</span> <span class=\"n\">Y</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">foo.to_bar</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">×</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">prod.bar</span> <span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span> <span class=\"c1\">-- not `rfl`</span>\n\n<span class=\"c1\">-- fix: refactor foo to include bar</span>\n<span class=\"kd\">class</span> <span class=\"n\">foo_fixed</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">foo_fixed.to_bar</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">foo_fixed</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">bar</span> <span class=\"n\">X</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"n\">i.m</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">prod.foo_fixed</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">foo_fixed</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">foo_fixed</span> <span class=\"n\">Y</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">foo_fixed</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">×</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">i.n</span> <span class=\"bp\">+</span> <span class=\"n\">j.n</span><span class=\"o\">,</span>\n  <span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"n\">i.m</span> <span class=\"bp\">+</span> <span class=\"n\">j.m</span><span class=\"o\">,</span>\n  <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">i.h</span><span class=\"o\">,</span> <span class=\"n\">j.h</span><span class=\"o\">,</span> <span class=\"n\">nat.left_distrib</span><span class=\"o\">],</span> <span class=\"c1\">-- proof inserted into system here</span>\n  <span class=\"kd\">end</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">foo_fixed</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">foo_fixed</span> <span class=\"n\">Y</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">foo_fixed.to_bar</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">×</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">prod.bar</span> <span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"c1\">-- but what if `foo` is in a dependency so we can't refactor it when we discover we need `bar`?</span>\n</code></pre></div>",
        "id": 237038697,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619945559
    },
    {
        "content": "<p>One possible way to handle the dependency is:</p>\n<ul>\n<li>Have <code>foo_fixed</code> extend foo</li>\n<li><code>attribute [-instance]</code> every <code>foo</code> instance in the upstream project</li>\n<li>Write a foo_fixed version of every such instance.</li>\n</ul>\n<p>However, even this can fail if lemma  statements end up being about the old foo instance, and obviously this scales very poorly</p>",
        "id": 237038949,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619945886
    }
]
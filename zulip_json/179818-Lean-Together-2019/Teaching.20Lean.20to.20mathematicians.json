[
    {
        "content": "<p>I have been thinking for a while now about how to teach Lean to absolute beginners, because that is currently the bottleneck we have at Imperial -- not enough people able to get started. Gabriel and I are running a teaching session tomorrow 0900-1030 and 1100-1200 and some people have confessed to knowing no Lean at all, which is of course absolutely fine, but how to get them started?</p>\n<p>My boys like learning through puzzle-solving. So here are some puzzles:</p>\n<p><a href=\"https://github.com/kbuzzard/mathematics-in-lean\" target=\"_blank\" title=\"https://github.com/kbuzzard/mathematics-in-lean\">https://github.com/kbuzzard/mathematics-in-lean</a></p>",
        "id": 154532336,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1546810941
    },
    {
        "content": "<p>The problem is that if you know no Lean at all, even these problems are too hard. You have to install Lean, and then how do you fill in the sorry?</p>",
        "id": 154532337,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1546810942
    },
    {
        "content": "<p>So there is some stuff which helps with that here:</p>\n<p><a href=\"http://wwwf.imperial.ac.uk/~buzzard/lean_together/source/leantogether.html\" target=\"_blank\" title=\"http://wwwf.imperial.ac.uk/~buzzard/lean_together/source/leantogether.html\">http://wwwf.imperial.ac.uk/~buzzard/lean_together/source/leantogether.html</a></p>",
        "id": 154532342,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1546810968
    },
    {
        "content": "<p>This is some teaching material written in sphinx.</p>",
        "id": 154532354,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1546811003
    },
    {
        "content": "<p>I mean, Lean is intended for CS majors..</p>",
        "id": 154532362,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1546811029
    },
    {
        "content": "<blockquote>\n<p>I mean, Lean is intended for CS majors..</p>\n</blockquote>\n<p>Lean is definitely not intended for CS majors only.  Isn't the whole point of this workshop/project to get mathematicians to like Lean?</p>",
        "id": 154532432,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1546811161
    },
    {
        "content": "<p>to get <em>more</em> mathematicians to like Lean</p>",
        "id": 154532551,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1546811363
    },
    {
        "content": "<p>And there's a very poor quality video which I made on my own laptop, and which is a bit laughable in places, but it's currently the best I've got. It's sort of an advert for what an absolute beginner can aspire to.</p>\n<p><a href=\"http://wwwf.imperial.ac.uk/~buzzard/lean_together/lean_intro.mp4\" target=\"_blank\" title=\"http://wwwf.imperial.ac.uk/~buzzard/lean_together/lean_intro.mp4\">http://wwwf.imperial.ac.uk/~buzzard/lean_together/lean_intro.mp4</a></p>\n<p>Videos are a pain to make, I want to zoom into various bits of the screen etc, and I know how to do all of this in theory but it would take me absolutely hours to make it exactly how I want it.</p>",
        "id": 154532552,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1546811369
    },
    {
        "content": "<p>you can certainly give a side (or interface) of Lean that is more suitable for mathematicians, but it won't change the fact that Lean is built for CS majors</p>",
        "id": 154532607,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1546811431
    },
    {
        "content": "<p>Should we  play the video tomorrow morning in case you have difficulties getting up on time?</p>",
        "id": 154532610,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1546811439
    },
    {
        "content": "<p>How would you understand structural induction if you're just some regular mathematician who never thinks about logic</p>",
        "id": 154532618,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1546811475
    },
    {
        "content": "<p>You think most CS majors think about logic?</p>",
        "id": 154532665,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1546811559
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> I like the video!</p>",
        "id": 154546873,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1546837268
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">interactive</span> <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">ring</span>\n\n<span class=\"kn\">inductive</span> <span class=\"n\">is_even</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"n\">zero</span> <span class=\"o\">:</span> <span class=\"n\">is_even</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"n\">step</span> <span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">is_even</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">is_even</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span><span class=\"o\">)</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"n\">is_even</span> <span class=\"mi\">4</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n<span class=\"n\">repeat</span> <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"n\">is_even</span><span class=\"bp\">.</span><span class=\"n\">step</span> <span class=\"o\">},</span>\n<span class=\"n\">apply</span> <span class=\"n\">is_even</span><span class=\"bp\">.</span><span class=\"n\">zero</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"n\">is_even</span> <span class=\"mi\">5</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n<span class=\"n\">intro</span> <span class=\"n\">even_five</span><span class=\"o\">,</span>\n<span class=\"n\">cases</span> <span class=\"n\">even_five</span> <span class=\"k\">with</span> <span class=\"bp\">_</span> <span class=\"n\">even_three</span><span class=\"o\">,</span>\n<span class=\"n\">cases</span> <span class=\"n\">even_three</span> <span class=\"k\">with</span> <span class=\"bp\">_</span> <span class=\"n\">even_one</span><span class=\"o\">,</span>\n<span class=\"n\">cases</span> <span class=\"n\">even_one</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">even_if_double</span> <span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">is_even</span> <span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n<span class=\"n\">induction</span> <span class=\"n\">n</span> <span class=\"k\">with</span> <span class=\"n\">d</span> <span class=\"n\">hd</span><span class=\"o\">,</span>\n<span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">is_even</span><span class=\"bp\">.</span><span class=\"n\">zero</span> <span class=\"o\">},</span>\n<span class=\"o\">{</span> <span class=\"k\">show</span> <span class=\"n\">is_even</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)),</span>\n  <span class=\"n\">rw</span> <span class=\"n\">mul_add</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">is_even</span><span class=\"bp\">.</span><span class=\"n\">step</span><span class=\"o\">,</span>\n  <span class=\"n\">assumption</span><span class=\"o\">,</span>\n <span class=\"o\">},</span>\n<span class=\"kn\">end</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">double_if_even</span> <span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">is_even</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"bp\">∃</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">m</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n<span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">induction</span> <span class=\"n\">h</span> <span class=\"k\">with</span> <span class=\"n\">d</span> <span class=\"n\">Hd</span> <span class=\"n\">ih</span><span class=\"o\">,</span>\n<span class=\"o\">{</span> <span class=\"n\">use</span> <span class=\"mi\">0</span><span class=\"o\">,</span>\n  <span class=\"n\">refl</span>\n<span class=\"o\">},</span>\n<span class=\"o\">{</span> <span class=\"n\">cases</span> <span class=\"n\">ih</span> <span class=\"k\">with</span> <span class=\"n\">n</span> <span class=\"n\">Hn</span><span class=\"o\">,</span>\n  <span class=\"n\">use</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">),</span>\n  <span class=\"n\">rw</span> <span class=\"n\">Hn</span><span class=\"o\">,</span>\n  <span class=\"n\">refl</span><span class=\"o\">,</span>\n <span class=\"o\">}</span>\n<span class=\"kn\">end</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">even_iff_double</span> <span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">is_even</span> <span class=\"n\">n</span> <span class=\"bp\">↔</span> <span class=\"bp\">∃</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">m</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n<span class=\"n\">split</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">double_if_even</span><span class=\"o\">,</span>\n<span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">cases</span> <span class=\"n\">h</span> <span class=\"k\">with</span> <span class=\"n\">d</span> <span class=\"n\">Hd</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"n\">Hd</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">even_if_double</span>\n<span class=\"kn\">end</span>\n\n<span class=\"kn\">inductive</span> <span class=\"n\">is_odd</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"n\">one</span> <span class=\"o\">:</span> <span class=\"n\">is_odd</span> <span class=\"mi\">1</span>\n<span class=\"bp\">|</span> <span class=\"n\">step</span> <span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">is_odd</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">is_odd</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span><span class=\"o\">)</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">odd_iff_double_add_one</span> <span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">is_odd</span> <span class=\"n\">n</span> <span class=\"bp\">↔</span> <span class=\"bp\">∃</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"n\">sorry</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">even_of_not_odd</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n<span class=\"bp\">¬</span> <span class=\"n\">is_odd</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">is_even</span> <span class=\"n\">n</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"n\">is_even</span><span class=\"bp\">.</span><span class=\"n\">zero</span>\n<span class=\"bp\">|</span> <span class=\"mi\">1</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"k\">begin</span> <span class=\"n\">exfalso</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">constructor</span> <span class=\"kn\">end</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"n\">h</span> <span class=\"o\">:=</span>\n  <span class=\"k\">have</span> <span class=\"n\">ih</span> <span class=\"o\">:</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">even_of_not_odd</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n  <span class=\"k\">begin</span>\n  <span class=\"n\">constructor</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">ih</span><span class=\"o\">,</span>\n  <span class=\"n\">intro</span> <span class=\"n\">hn</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">constructor</span><span class=\"o\">,</span> <span class=\"n\">assumption</span><span class=\"o\">,</span>\n  <span class=\"kn\">end</span>\n\n<span class=\"bp\">#</span><span class=\"kn\">print</span> <span class=\"n\">even_of_not_odd</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">not_odd_of_even</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">is_even</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"bp\">¬</span> <span class=\"n\">is_odd</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n<span class=\"n\">intros</span> <span class=\"n\">n</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n<span class=\"n\">induction</span> <span class=\"n\">h</span> <span class=\"k\">with</span> <span class=\"n\">m</span> <span class=\"n\">m</span> <span class=\"n\">hm</span><span class=\"o\">,</span>\n<span class=\"o\">{</span><span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">cases</span> <span class=\"n\">h</span><span class=\"o\">},</span>\n<span class=\"o\">{</span><span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">hm</span><span class=\"o\">,</span> <span class=\"n\">cases</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">assumption</span><span class=\"o\">},</span>\n<span class=\"kn\">end</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">even_iff_not_odd</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">is_even</span> <span class=\"n\">n</span> <span class=\"bp\">↔</span> <span class=\"bp\">¬</span> <span class=\"n\">is_odd</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n<span class=\"n\">intro</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">split</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">not_odd_of_even</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">even_of_not_odd</span>\n<span class=\"kn\">end</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">odd_square</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">is_odd</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">is_odd</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">*</span><span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n<span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">odd_iff_double_add_one</span><span class=\"o\">],</span>\n<span class=\"n\">intro</span> <span class=\"n\">m</span><span class=\"o\">,</span>\n<span class=\"n\">intros</span>  <span class=\"n\">h</span><span class=\"o\">,</span>\n<span class=\"n\">use</span> <span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">m</span><span class=\"bp\">*</span><span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">subst</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">ring</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">even_square</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">is_even</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">*</span><span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">is_even</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n<span class=\"n\">conv</span> <span class=\"k\">in</span> <span class=\"o\">(</span><span class=\"n\">is_even</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">*</span><span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">even_iff_not_odd</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n<span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">even_iff_not_odd</span><span class=\"o\">],</span>\n<span class=\"n\">intros</span> <span class=\"n\">h1</span> <span class=\"n\">h2</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">h1</span><span class=\"o\">,</span>\n<span class=\"n\">apply</span> <span class=\"n\">odd_square</span><span class=\"o\">,</span> <span class=\"n\">assumption</span>\n<span class=\"kn\">end</span>\n\n<span class=\"kn\">set_option</span> <span class=\"n\">pp</span><span class=\"bp\">.</span><span class=\"n\">all</span> <span class=\"n\">true</span>\n<span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"o\">(</span><span class=\"mi\">7</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span>\n</pre></div>\n\n\n<p>This is what Gabriel and I generated in the second hour of the tutorial</p>",
        "id": 154564805,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1546864640
    },
    {
        "content": "<p>If any beginners have any questions about this then feel free to ask.</p>",
        "id": 154565129,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1546864981
    },
    {
        "content": "<p><a href=\"https://github.com/kbuzzard/xena/tree/master/lean_together\" target=\"_blank\" title=\"https://github.com/kbuzzard/xena/tree/master/lean_together\">https://github.com/kbuzzard/xena/tree/master/lean_together</a> Random stuff from Monday tutorial</p>",
        "id": 154566899,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1546866822
    },
    {
        "content": "<p>Does anyone have a hint for the following exercise? The idea is to replace the `sorry' with a proof, as elementary as possible (without importing any libraries, if possible). As you can guess, I'm quite new to this! </p>\n<p><code>variables (X : Type) (P Q : X → Prop)</code></p>\n<p><code>example : ∀ x, P x ∧ Q x → ∀ x, Q x ∧ P x :=\nbegin\nsorry\nend</code></p>\n<p>So far I have <br>\n<code> intro a, intro G, cases G with PH QH, intro b, split, </code><br>\nbut then I have a proof of Q a, and I want a proof of Q b. I want to say `but a was arbitrary', but don't know how to do this in Lean... </p>\n<p>Thanks very much!</p>",
        "id": 154581547,
        "sender_full_name": "David Holmes",
        "timestamp": 1546878801
    },
    {
        "content": "<p>I think you are missing a pair of parentheses</p>",
        "id": 154581665,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1546878894
    },
    {
        "content": "<p>Yes, I think you want to prove <code>(∀ x, P x ∧ Q x) → (∀ x, Q x ∧ P x)</code>, that will be easier!</p>",
        "id": 154581713,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1546878933
    },
    {
        "content": "<p>Thanks, will try that. The version I gave was Kevin's exercise, so maybe there is a type there.</p>",
        "id": 154581797,
        "sender_full_name": "David Holmes",
        "timestamp": 1546879002
    },
    {
        "content": "<p>Note, on Zulip you can format Lean code by enclosing it with  </p>\n<div class=\"codehilite\"><pre><span></span>```lean\n</pre></div>\n\n\n<p>and three backticks at the end.</p>",
        "id": 154581808,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1546879020
    },
    {
        "content": "<p>Oh many thanks David -- I always forget that \\forall is super-greedy. Do you know how computer scientists do BIDMAS by the way?</p>",
        "id": 154592069,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1546887960
    },
    {
        "content": "<p>PS did I manage to fix it?</p>",
        "id": 154594472,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1546889755
    },
    {
        "content": "<p>Yup, looks good (and also the exists one below). I'm almost there, having fun with the final one now... BIDMAS I'm not sure about, but for now I like lots of brackets for certainty!</p>",
        "id": 154600678,
        "sender_full_name": "David Holmes",
        "timestamp": 1546894665
    },
    {
        "content": "<p>Each piece of notation has a number between 0 and about 1000 attached to it (to both sides of it in the case that it's an infix operator like +)</p>",
        "id": 154604138,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1546897801
    },
    {
        "content": "<p>You can see the numbers using <code>#print notation *</code> or whatever notation you want to understand</p>",
        "id": 154604237,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1546897859
    },
    {
        "content": "<p>My favourite piece of notation is <code>$</code></p>",
        "id": 154604272,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1546897893
    },
    {
        "content": "<p>Away from notation, actual functions given by name have a super high number</p>",
        "id": 154604360,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1546897963
    },
    {
        "content": "<p>You can tell functions from notation because function names are in lower case letters and notation is pretty much everything else</p>",
        "id": 154604397,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1546898022
    },
    {
        "content": "<p>And then you just say \"Pratt parser\" and all your inputs are resolved by lean</p>",
        "id": 154604490,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1546898098
    },
    {
        "content": "<p>Functions don't have to be lower case letters. But function application indeed has super high priority</p>",
        "id": 154604521,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1546898127
    },
    {
        "content": "<p>And the CS guys are excited about something in Lean 4 relating to this</p>",
        "id": 154604523,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1546898128
    },
    {
        "content": "<p>I think because it will make notation cooler or something</p>",
        "id": 154604592,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1546898171
    },
    {
        "content": "<p>Have you seen the notation for \"mod n\" is some crazy [ZMOD n] thing? I can't even remember what the notation is, I always have to look it up</p>",
        "id": 154604660,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1546898261
    },
    {
        "content": "<p>Will this be fixed in Lean 4?</p>",
        "id": 154604719,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1546898285
    },
    {
        "content": "<p>I had better get back to my talk</p>",
        "id": 154604726,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1546898300
    },
    {
        "content": "<p>The notation for a ≡ b (mod n) when n, a, and b are integers is <code>a ≡ b [ZMOD n]</code>, that hardly seems so crazy.</p>",
        "id": 154604915,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1546898437
    },
    {
        "content": "<blockquote>\n<p>The notation for a ≡ b (mod n) when n, a, and b are integers is <code>a ≡ b [ZMOD n]</code>, that hardly seems so crazy.</p>\n</blockquote>\n<p>Why isn't it just <code>a ≡ b mod n</code> ?</p>",
        "id": 154609481,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1546902984
    },
    {
        "content": "<blockquote>\n<p>The problem is that if you know no Lean at all, even these problems are too hard. You have to install Lean, and then how do you fill in the sorry?</p>\n</blockquote>\n<p>Hmm,  I know someone who co-wrote a book for teaching haskell to complete beginners (Haskell Book). She might be a good person to talk to!</p>",
        "id": 154636786,
        "sender_full_name": "Zans Mihejevs",
        "timestamp": 1546944816
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"198366\">@David Holmes</span> complained that the basic logic exercises were too boring :-) [I think in the sense that he felt that the proofs should be done by automation rather than by him]. He liked the canonical nat exercise (defining <code>+ and </code>*<code> and </code>&lt;` and proving basic stuff about them) at <a href=\"https://xenaproject.wordpress.com/2017/10/31/building-the-non-negative-integers-from-scratch/\" target=\"_blank\" title=\"https://xenaproject.wordpress.com/2017/10/31/building-the-non-negative-integers-from-scratch/\">https://xenaproject.wordpress.com/2017/10/31/building-the-non-negative-integers-from-scratch/</a></p>\n<p>That exercise involves building a new structure from scratch and then defining functions on it and proving stuff about it. But the new structure relies on nothing at all. Here is a sketch of how to build the complex numbers, given the real numbers.</p>\n<p><a href=\"https://github.com/kbuzzard/xena/blob/master/lean_together/complex.lean\" target=\"_blank\" title=\"https://github.com/kbuzzard/xena/blob/master/lean_together/complex.lean\">https://github.com/kbuzzard/xena/blob/master/lean_together/complex.lean</a></p>\n<p>Here we need to have mathlib installed, so we can have the reals. Actually probably one could get away with axiomatising the reals here and avoiding mathlib, but I did not do this. If we made a new constant called <code>real</code> and added an axiom that it was a ring, one should be able to prove that the complexes are also a ring, because really we are constructing <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>R</mi><mo>[</mo><mi>x</mi><mo>]</mo><mi mathvariant=\"normal\">/</mi><mo>(</mo><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">R[x]/(x^2+1)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.8141079999999999em;\"></span><span class=\"strut bottom\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.00773em;\">R</span><span class=\"mopen\">[</span><span class=\"mord mathit\">x</span><span class=\"mclose\">]</span><span class=\"mord mathrm\">/</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathit\">x</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathrm mtight\">2</span></span></span></span></span></span></span></span><span class=\"mbin\">+</span><span class=\"mord mathrm\">1</span><span class=\"mclose\">)</span></span></span></span> where <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.00773em;\">R</span></span></span></span> is an arbitrary ring.</p>",
        "id": 154832510,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1547119780
    },
    {
        "content": "<p>Too boring? Hmm, maybe. I think the problem is that I would have found them painful to do on paper, forgetting lean, because I'm not sure what I should assume and what needs to be proven (for example, it was not immediately clear that I should assume excluded middle, but prove <code>\\not (p \\and \\not p)</code>, just because I am not used to working with these things. Certainly I wouldn't be unhappy to have them done by automation! I did find the exercises with the natural numbers much more fun, because I felt I understood what I was aiming for. Occasionally it felt like fighting with the system, but most of the time things just worked as I hoped. May have a go at the complexes soon...</p>",
        "id": 154863761,
        "sender_full_name": "David Holmes",
        "timestamp": 1547147748
    },
    {
        "content": "<p>Hmm, can I cheat/have a hint? Is there a command to say 'apply the ring structure of the real numbers' without giving every detail? For example, I want to show <code>re a * re c - im a * im c + (re b * re c - im b * im c) = re a * re c - im a * im c + re b * re c - im b * im c</code>, which is `immediate' from the fact that \\bbR is a commutative ring, but fiddly to prove step by step... Thanks! On the other hand, if this is part of the exercise I'm pretty sure I can do it, but I don't want to :-).</p>",
        "id": 154877253,
        "sender_full_name": "David Holmes",
        "timestamp": 1547159086
    },
    {
        "content": "<p><code>by ring</code></p>",
        "id": 154877565,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1547159383
    },
    {
        "content": "<p>When I do this exercise now David, I write a tactic to do all the work for me :-)</p>",
        "id": 154899369,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1547191410
    },
    {
        "content": "<p>Ie a tactic which just applies other tactics :-)</p>",
        "id": 154899374,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1547191431
    },
    {
        "content": "<p>Thanks very much, but I'm still doing something wrong. A minimal non-working example with the same error is </p>\n<div class=\"codehilite\"><pre><span></span>import data.real.basic\nexample : (1 : ℝ) + 2 = 3 :=\nbegin\nby ring,\nend\n\nexample (a b c: ℝ) :\n(a + b) * c = a * c + b * c :=\nbegin\nby ring,\nend\n</pre></div>\n\n\n<p>giving the error </p>\n<p>type mismatch at application<br>\n  tactic.istep 5 3 5 3 ring<br>\nterm<br>\n  ring<br>\nhas type<br>\n  Type ? → Type ? : Type (?+1)<br>\nbut is expected to have type<br>\n  tactic ?m_1 : Type ?</p>\n<p>Kevin's suggestion of writing a tactic sounds sensible, but I think I'm not at that point yet...</p>",
        "id": 154900247,
        "sender_full_name": "David Holmes",
        "timestamp": 1547192796
    },
    {
        "content": "<p><code>import tactic.ring</code>?</p>",
        "id": 154900257,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1547192827
    },
    {
        "content": "<p>Or whatever auto-completion makes of that.</p>",
        "id": 154900261,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1547192847
    },
    {
        "content": "<p>I agree that the error message is cryptic. It would be nicer if it said \"tactic ring not found\" or something like that.</p>",
        "id": 154900306,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1547192884
    },
    {
        "content": "<p>I'm not at a pc right now (indeed I'm waiting for a 51 and am going to be a few minutes late) but I just mean defining a new tactic which strings together other tactics, it's trivial</p>",
        "id": 154900327,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1547192963
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"198366\">@David Holmes</span>  The problem is: tactics are just a certain kind of types. And now we have two versions of <code>ring</code>, living in different namespaces. One is a tactic, and the other is the typeclass that gives ring structure to a <code>R : Type</code>. (E.g. the ring structure on the reals). Without importing the tactic, it finds the other one, which confuses Lean, and gives you a cryptic error message.</p>",
        "id": 154900331,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1547192996
    },
    {
        "content": "<p>It works, thanks Johan! Kevin, writing tactics to string together others sounds really neat, especially if its trivial :-).</p>",
        "id": 154900643,
        "sender_full_name": "David Holmes",
        "timestamp": 1547193467
    },
    {
        "content": "<p>If you want to know what <code>ring</code> does (up to \"isomorphism of algorithms\" <span class=\"emoji emoji-1f606\" title=\"lol\">:lol:</span>), you should read Kevin's blogpost about it.</p>",
        "id": 154900739,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1547193574
    },
    {
        "content": "<p>A small additional note: <code>by _</code> is equivalent to <code>begin _ end</code>, where <code>_</code> is a single tactic. So you can just write <code>by ring</code>, or <code>begin ring end</code>.</p>",
        "id": 154901337,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1547194386
    },
    {
        "content": "<p>Hi Kevin, <br>\nIn the `complex' exercises, I made it up to and including </p>\n<div class=\"codehilite\"><pre><span></span>theorem add_mul (a b c : ℂ) :\n(a + b) * c = a * c + b * c := sorry\n</pre></div>\n\n\n<p>Will try the next ones later. The only thing I needed (other than what you provided) was the line </p>\n<div class=\"codehilite\"><pre><span></span>import tactic.ring\n</pre></div>\n\n\n<p>and the tactic <code>by ring</code>. </p>\n<p>I wonder about more efficient ways to do some of this. I defined addition by </p>\n<div class=\"codehilite\"><pre><span></span>definition add : ℂ → ℂ → ℂ\n| ⟨x1,y1⟩ ⟨x2,y2⟩ := ⟨x1 + x2, y1 + y2⟩\n</pre></div>\n\n\n<p>then needed things like </p>\n<div class=\"codehilite\"><pre><span></span>lemma re_add (a b : ℂ) :\nre (a + b) = re a + re b:=\nbegin\nhave h : a + b = ⟨re(a+b), im(a+b) ⟩, rw eta,\nhave ha : a = ⟨ re a, im a ⟩,rw eta,\nhave hb : b = ⟨ re b, im b ⟩,rw eta,\nhave H : a + b = ⟨re(a) + re(b), im(a+b) ⟩, rw ha, rw hb,\nunfold re, refl, rw H, refl,\nend\n</pre></div>\n\n\n<p>whose proof was harder than I expected. Then my proof of distributivity was </p>\n<div class=\"codehilite\"><pre><span></span>theorem add_mul (a b c : ℂ) :\n(a + b) * c = a * c + b * c :=\nbegin\napply ext,\nhave Hrleft: re ((a+b) * c) = re(a + b)* re(c) - im(a + b) * im(c),\napply re_mult,\nhave Hrright : re(a * c + b * c) = re a * re c - im a * im c + re b * re c - im b * im c,\nhave h1 : re(a*c) = re a * re c - im a * im c, apply re_mult,\nhave h2 : re(b*c) = re b * re c - im b * im c, apply re_mult,\nrw [re_add], rw[h1], rw [h2], by ring, rw [Hrright],\nhave H : re(a + b)* re(c) - im(a + b) * im(c) = re a * re c - im a * im c + re b * re c - im b * im c,\nrw [re_add], rw im_add, by ring, rw [Hrleft], rw H, -- now done with the real component\n-- onto the imaginary part\nhave Hileft : im((a + b) * c) = re (a + b) * im c + re c * im (a + b),\napply im_mult,\nhave Hiright : im(a * c + b * c) = re a * im c + re c * im a + re b * im c + re c * im b,\nhave h1 : im(a*c) = re a * im c + re c * im a, apply im_mult,\nhave h2 : im(b*c) = re b * im c + re c * im b, apply im_mult,\nrw [im_add], rw[h1], rw [h2], by ring, rw [Hiright],\nhave H : re(a + b)* im(c) + re(c) * im(a + b) = re a * im c + re b * im c + re c * im a + re c * im b,\nrw [re_add], rw im_add, by ring, rw [Hileft], rw H, by ring,\nend\n</pre></div>\n\n\n<p>(attached my code <a href=\"/user_uploads/3121/W5bzU97AUkl2kyShuTAzZRbM/complex.lean\" target=\"_blank\" title=\"complex.lean\">complex.lean</a> in case interesting/easier to read). Which was not really so bad, but doing this for every axiom would hurt a bit. </p>\n<p>These proof were all basically computations, so maybe tactic mode was not the best choice? But I am starting to like tactic mode quite a bit. </p>\n<p>I often felt I wanted to start a proof about a complex number <code>a</code> by saying 'write <code>a = x + iy</code>', but not sure if there is an analogue of that in Lean that functions as I would hope. Working around it got kind of messy, but perhaps that's life. </p>\n<p>[I'm putting this here (and not as a pm to Kevin) in case it is useful to other people, but I don't really know how the forum works so please let me know if I'm spamming!]</p>",
        "id": 154928489,
        "sender_full_name": "David Holmes",
        "timestamp": 1547224461
    },
    {
        "content": "<p>Posts like this are fine. Yes, there are better ways, but in my mind these struggles are interesting to go through once, just to make sure you understand what's going on.</p>\n<p><a href=\"https://github.com/leanprover/mathlib/blob/774e7fa39a8513c5c06e27c3e8bf4c124efd9db7/analysis/complex.lean\" target=\"_blank\" title=\"https://github.com/leanprover/mathlib/blob/774e7fa39a8513c5c06e27c3e8bf4c124efd9db7/analysis/complex.lean\">https://github.com/leanprover/mathlib/blob/774e7fa39a8513c5c06e27c3e8bf4c124efd9db7/analysis/complex.lean</a></p>\n<p>That was my effort at the time. I wrote a tactic called <code>crunch</code> which just did the ring theory I needed.</p>\n<p>Defining structures and making them work properly is hard for mathematicians, because mathematicians don't instinctively think to define things like eta and ext.</p>",
        "id": 154930105,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1547226111
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">theorem</span> <span class=\"n\">add_mul</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">c</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">c</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">apply</span> <span class=\"n\">ext</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">re_add</span><span class=\"o\">,</span><span class=\"n\">re_mul</span><span class=\"o\">,</span><span class=\"n\">re_add</span><span class=\"o\">,</span><span class=\"n\">im_add</span><span class=\"o\">,</span><span class=\"n\">re_mul</span><span class=\"o\">,</span><span class=\"n\">re_mul</span><span class=\"o\">],</span>\n    <span class=\"n\">ring</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">im_add</span><span class=\"o\">,</span><span class=\"n\">im_mul</span><span class=\"o\">,</span><span class=\"n\">re_add</span><span class=\"o\">,</span><span class=\"n\">im_add</span><span class=\"o\">,</span><span class=\"n\">im_mul</span><span class=\"o\">,</span><span class=\"n\">im_mul</span><span class=\"o\">],</span>\n    <span class=\"n\">ring</span> <span class=\"o\">},</span>\n<span class=\"kn\">end</span>\n</pre></div>\n\n\n<p>The <code>ring</code> tactic can solve a goal of the form <code>(re a + re b) * re c - (im a + im b) * im c = re a * re c - im a * im c + (re b * re c - im b * im c)</code> so we just apply the lemmas we know to turn it into a goal of this form. If the lemmas <code>re_add</code> etc are all tagged with the <code>simp</code> attribute then perhaps instead of the rewrite one could write <code>suffices : (re a + re b) * re c - blah blah blah, by simp</code>.</p>",
        "id": 154987156,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1547305607
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">theorem</span> <span class=\"n\">add_mul</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">c</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">c</span> <span class=\"o\">:=</span>\n<span class=\"n\">ext</span>\n  <span class=\"o\">(</span><span class=\"k\">show</span> <span class=\"o\">(</span><span class=\"bp\">_+_</span><span class=\"o\">)</span><span class=\"bp\">*_-</span><span class=\"o\">(</span><span class=\"bp\">_+_</span><span class=\"o\">)</span><span class=\"bp\">*_=</span><span class=\"o\">(</span><span class=\"bp\">_-_</span><span class=\"o\">)</span><span class=\"bp\">+</span><span class=\"o\">(</span><span class=\"bp\">_-_</span><span class=\"o\">),</span> <span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">add_mul</span><span class=\"o\">,</span> <span class=\"n\">add_mul</span><span class=\"o\">,</span> <span class=\"n\">add_sub_comm</span><span class=\"o\">])</span>\n  <span class=\"o\">(</span><span class=\"k\">show</span> <span class=\"o\">(</span><span class=\"bp\">_+_</span><span class=\"o\">)</span><span class=\"bp\">*_+</span><span class=\"o\">(</span><span class=\"bp\">_+_</span><span class=\"o\">)</span><span class=\"bp\">*_=</span><span class=\"o\">(</span><span class=\"bp\">_+_</span><span class=\"o\">)</span><span class=\"bp\">+</span><span class=\"o\">(</span><span class=\"bp\">_+_</span><span class=\"o\">),</span> <span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">add_mul</span><span class=\"o\">,</span> <span class=\"n\">add_mul</span><span class=\"o\">,</span> <span class=\"n\">add_assoc</span><span class=\"o\">,</span> <span class=\"n\">add_left_comm</span> <span class=\"o\">(</span><span class=\"n\">b</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"bp\">*_</span><span class=\"o\">),</span> <span class=\"err\">←</span> <span class=\"n\">add_assoc</span><span class=\"o\">])</span>\n</pre></div>",
        "id": 154987800,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1547306825
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> What's the new link for whatever was at <a href=\"http://wwwf.imperial.ac.uk/~buzzard/lean_together/source/leantogether.html\" target=\"_blank\" title=\"http://wwwf.imperial.ac.uk/~buzzard/lean_together/source/leantogether.html\">http://wwwf.imperial.ac.uk/~buzzard/lean_together/source/leantogether.html</a> ?</p>",
        "id": 155132580,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1547511530
    },
    {
        "content": "<p>Sorry -- link fixed. I added some more (very sketchy) exercises and broke everything in the process.</p>",
        "id": 155152962,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1547539838
    },
    {
        "content": "<p>Thanks Kevin, your proof is very nice - doing in 2 lines what took me 7. Also much easier to read! Moving on to the other cases seems more reasonable now.</p>",
        "id": 156402310,
        "sender_full_name": "David Holmes",
        "timestamp": 1547848004
    },
    {
        "content": "<p>Kenny, what you wrote looks very neat, but I can't get it to work. I guess i need to add <code>begin</code> and <code>end</code>, but then I get an error on the first <code>show</code>, saying <code>function expected at\n  (λ (this : (?m_5 + ?m_6) * ?m_7 - (?m_10 + ?m_11) * ?m_12 = ?m_15 - ?m_16 + (?m_18 - ?m_19)), this) ?m_20\nterm has type\n  (?m_5 + ?m_6) * ?m_7 - (?m_10 + ?m_11) * ?m_12 = ?m_15 - ?m_16 + (?m_18 - ?m_19)\n</code>.<br>\nAny suggestions on what I'm doing wrong?</p>",
        "id": 156402395,
        "sender_full_name": "David Holmes",
        "timestamp": 1547848072
    },
    {
        "content": "<p>I think at that time I couldn't import mathlib so I made up my own complex numbers; the definition of multiplication may have been different (my proof relies heavily on definitional equalities)</p>",
        "id": 156402574,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1547848171
    },
    {
        "content": "<p>doesn't something like <code>by ext; ring</code> work?</p>",
        "id": 156403084,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1547848594
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">complex</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n\n<span class=\"n\">attribute</span> <span class=\"o\">[</span><span class=\"n\">extensionality</span><span class=\"o\">]</span> <span class=\"n\">complex</span><span class=\"bp\">.</span><span class=\"n\">ext</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">add_mul&#39;</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">c</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">c</span> <span class=\"o\">:=</span>\n<span class=\"k\">by</span> <span class=\"n\">ext</span><span class=\"bp\">;</span> <span class=\"n\">simp</span><span class=\"bp\">;</span> <span class=\"n\">ring</span>\n</pre></div>",
        "id": 156403365,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1547848811
    },
    {
        "content": "<p>Hi Mario, <br>\nThanks for the suggestion. I'm sure that works with the complex numbers in Lean, but this was part of an exercise to construct the complex numbers from the real numbers (so never used <code>import data.complex.basic</code>). I just get the usual <code>simplify tactic failed to simplify</code>. I think if some of my earlier lemmas had the simp attribute it might also work, but not yet sure how to go about that (and maybe it is not the goal of the exercise).</p>",
        "id": 156405084,
        "sender_full_name": "David Holmes",
        "timestamp": 1547850520
    },
    {
        "content": "<p>You need simp lemmas for addition and multiplication</p>",
        "id": 156408900,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1547854962
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"kn\">lemma</span> <span class=\"n\">add_re</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"bp\">+</span> <span class=\"n\">w</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">re</span> <span class=\"bp\">=</span> <span class=\"n\">z</span><span class=\"bp\">.</span><span class=\"n\">re</span> <span class=\"bp\">+</span> <span class=\"n\">w</span><span class=\"bp\">.</span><span class=\"n\">re</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"kn\">lemma</span> <span class=\"n\">add_im</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"bp\">+</span> <span class=\"n\">w</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">im</span> <span class=\"bp\">=</span> <span class=\"n\">z</span><span class=\"bp\">.</span><span class=\"n\">im</span> <span class=\"bp\">+</span> <span class=\"n\">w</span><span class=\"bp\">.</span><span class=\"n\">im</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"kn\">lemma</span> <span class=\"n\">mul_re</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"bp\">*</span> <span class=\"n\">w</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">re</span> <span class=\"bp\">=</span> <span class=\"n\">z</span><span class=\"bp\">.</span><span class=\"n\">re</span> <span class=\"bp\">*</span> <span class=\"n\">w</span><span class=\"bp\">.</span><span class=\"n\">re</span> <span class=\"bp\">-</span> <span class=\"n\">z</span><span class=\"bp\">.</span><span class=\"n\">im</span> <span class=\"bp\">*</span> <span class=\"n\">w</span><span class=\"bp\">.</span><span class=\"n\">im</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"kn\">lemma</span> <span class=\"n\">mul_im</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"bp\">*</span> <span class=\"n\">w</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">im</span> <span class=\"bp\">=</span> <span class=\"n\">z</span><span class=\"bp\">.</span><span class=\"n\">re</span> <span class=\"bp\">*</span> <span class=\"n\">w</span><span class=\"bp\">.</span><span class=\"n\">im</span> <span class=\"bp\">+</span> <span class=\"n\">z</span><span class=\"bp\">.</span><span class=\"n\">im</span> <span class=\"bp\">*</span> <span class=\"n\">w</span><span class=\"bp\">.</span><span class=\"n\">re</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</pre></div>",
        "id": 156408917,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1547854999
    },
    {
        "content": "<p>of course you can prove the theorem by <code>add_mul</code> since this is already proven in <code>data.complex.basic</code>, but if you are rewriting it on your own you want <code>complex.ext</code> and these re/im lemmas and then everything should follow by <code>ring</code> like I said</p>",
        "id": 156408984,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1547855070
    }
]
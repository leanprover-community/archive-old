[
    {
        "content": "<p>I want to state that <code>(f x) ++ (g x): List α</code> has no duplicates and that <code>((f x) ++ (g x).to_finset = h x</code> (maybe there is some notion of a disjoint_finset?).<br>\nLater, I would like to argue that if <code>g x = y::ys</code>, then <code>y \\not \\in ys ++ f x</code>.<br>\nWhat is the best way to formalize that? I thought about stating <code>(f x ++ g x).length = (h x).card</code>. Is there a better way?</p>",
        "id": 221243614,
        "sender_full_name": "Henning Dieterichs",
        "timestamp": 1609359851
    },
    {
        "content": "<p>This is a question about lists, right? Nothing to do with finsets. The way you prove the theorem will depend on how you are saying that L++M has no dupes.</p>",
        "id": 221243825,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1609360079
    },
    {
        "content": "<p>Then you just need theorems like nodupes(L++M) iff nodupes(M++L) and nodupes(a::L) -&gt; a not in L.</p>",
        "id": 221244035,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1609360226
    },
    {
        "content": "<p>I would like to optimize the formalization for later arguments, not for provability of the theorem itself (I guess it will be easy to prove, but I have to use this argument many times). Well, it is about lists, but there is a connection to finsets. <code>h x</code> is a finset, but I need the order in <code>f x</code>.</p>",
        "id": 221244038,
        "sender_full_name": "Henning Dieterichs",
        "timestamp": 1609360228
    },
    {
        "content": "<p>Sure but <code>h x</code> never occurred in your question</p>",
        "id": 221244100,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1609360300
    },
    {
        "content": "<p>Use can use <code>nodup</code> for the first constraint.</p>",
        "id": 221244103,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1609360301
    },
    {
        "content": "<p>And there a lot of lemmas about how <code>nodup</code> interfaces with append, concatenate, and mem.</p>",
        "id": 221244175,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1609360330
    },
    {
        "content": "<p>Great, if there's a <a href=\"https://leanprover-community.github.io/mathlib_docs/find/list.nodup\">docs#list.nodup</a> that would be perfect</p>",
        "id": 221244179,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1609360334
    },
    {
        "content": "<p>oh, nice thanks! Sorry that I missed that.</p>",
        "id": 221244287,
        "sender_full_name": "Henning Dieterichs",
        "timestamp": 1609360435
    },
    {
        "content": "<p>You could look for the lemmas I'm suggesting with <code>library_search</code> and then prove <code>nodup (L++(m::M))</code> implies m isn't in M++L, although I guess I'm a bit surprised that you have swapped L and M.</p>",
        "id": 221244421,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1609360545
    },
    {
        "content": "<p>I haven't had good luck finding the right <code>mem</code> lemmas via <code>library_search</code>, but have found them via <code>suggest</code>.</p>",
        "id": 221244620,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1609360698
    },
    {
        "content": "<p>In my case, library_searched worked great!</p>",
        "id": 221245156,
        "sender_full_name": "Henning Dieterichs",
        "timestamp": 1609361179
    },
    {
        "content": "<p>I guess this is the difference between math and program verification:<br>\n<a href=\"/user_uploads/3121/c2tjU9YiGAaoXCyOCWHSj3Fr/image.png\">image.png</a>  :D</p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/c2tjU9YiGAaoXCyOCWHSj3Fr/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/c2tjU9YiGAaoXCyOCWHSj3Fr/image.png\"></a></div>",
        "id": 221245308,
        "sender_full_name": "Henning Dieterichs",
        "timestamp": 1609361338
    },
    {
        "content": "<p>We get really long goals like that, it's just that we don't notice they're long because everything is folded up into typeclasses.</p>",
        "id": 221245623,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1609361630
    },
    {
        "content": "<p>How do you stay concentrated when looking at such goals? I tend to get lost in the sheer amount of identifiers. If I'm not very careful, I lose the idea of the proof and it gets very ugly.</p>",
        "id": 221245895,
        "sender_full_name": "Henning Dieterichs",
        "timestamp": 1609361879
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"234196\">@Henning Dieterichs</span> i ran into a similar problem during my bsc thesis (which was also cs-oriented), also struggling to keep up with the goals.<br>\ni found that two things help:</p>\n<ul>\n<li>when defining some inductive/definition, start by proving \"obvious\" facts about the inductive/definition, regardless of whether you think you will need it down the line.</li>\n<li>work through longer proofs with pen and paper and denote intuitive subgoals in your paper proof as lemmas, proving them separately. then, write out the big proof in dependence of all these sorry'd lemmas.</li>\n</ul>\n<p>your pen and paper proofs should be precise so that you don't need to do so much work for the formalized proof. <br>\nin my experience, without such a pen and paper proof, you can get lost very easily, especially when you start applying theorems and simplification like a human pattern matcher without looking at the bigger picture.<br>\nmeanwhile, the first bullet point means that you won't have to unfold as many layers, leading to more concise goals.</p>",
        "id": 221248368,
        "sender_full_name": "Marc Huisinga",
        "timestamp": 1609363997
    },
    {
        "content": "<p>in the end, i didn't follow those tips nearly well enough myself, which is part of the reason why i couldn't conclude the proof in its entirety.</p>",
        "id": 221248489,
        "sender_full_name": "Marc Huisinga",
        "timestamp": 1609364087
    },
    {
        "content": "<p>thanks for your advice! Except for the pen&amp;paper proof, I'm already trying to do that. I'm very optimistic to be able to close all my goals, but I'm sure many of my proofs are very bloated and look like brute force.</p>",
        "id": 221249055,
        "sender_full_name": "Henning Dieterichs",
        "timestamp": 1609364611
    },
    {
        "content": "<p>Also, let ... in ... don't simplify cleanly often, so I just avoid using them in definitions often</p>",
        "id": 221249067,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1609364626
    },
    {
        "content": "<p>Here, you have a big goal because it's not simplifying the defeq structure record accession</p>",
        "id": 221249141,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1609364705
    },
    {
        "content": "<p>This screenshot looks like either not enough abstraction (e.g. some append operation on whatever the structures are) or too much unfolding rather than applying lemmas</p>",
        "id": 221253842,
        "sender_full_name": "Reid Barton",
        "timestamp": 1609369218
    },
    {
        "content": "<p>You have a lot of subexpressions there of the form <code>{field1 := f, ...}.field1</code>, which simplify to <code>f</code> (perhaps via <code>dsimp only</code>)</p>",
        "id": 221280384,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1609408599
    },
    {
        "content": "<p>I struggled to solve this goal with the definition of nodup:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">disjoint</span><span class=\"o\">:</span> <span class=\"n\">disjoint</span> <span class=\"n\">ant_tr1.leaves</span> <span class=\"n\">ant_tr2.leaves</span><span class=\"o\">,</span>\n<span class=\"n\">ant_ih_tr1</span> <span class=\"o\">:</span>\n  <span class=\"o\">((</span><span class=\"n\">R</span> <span class=\"n\">ant_tr1</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">acc</span> <span class=\"bp\">++</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">ant_tr1</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">inacc</span> <span class=\"bp\">++</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">ant_tr1</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">red</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_finset</span> <span class=\"bp\">=</span> <span class=\"n\">ant_tr1.leaves</span> <span class=\"bp\">∧</span>\n    <span class=\"o\">((</span><span class=\"n\">R</span> <span class=\"n\">ant_tr1</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">acc</span> <span class=\"bp\">++</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">ant_tr1</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">inacc</span> <span class=\"bp\">++</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">ant_tr1</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">red</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">nodup</span><span class=\"o\">,</span>\n<span class=\"n\">ant_ih_tr2</span> <span class=\"o\">:</span>\n  <span class=\"o\">((</span><span class=\"n\">R</span> <span class=\"n\">ant_tr2</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">acc</span> <span class=\"bp\">++</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">ant_tr2</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">inacc</span> <span class=\"bp\">++</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">ant_tr2</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">red</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_finset</span> <span class=\"bp\">=</span> <span class=\"n\">ant_tr2.leaves</span> <span class=\"bp\">∧</span>\n    <span class=\"o\">((</span><span class=\"n\">R</span> <span class=\"n\">ant_tr2</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">acc</span> <span class=\"bp\">++</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">ant_tr2</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">inacc</span> <span class=\"bp\">++</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">ant_tr2</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">red</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">nodup</span>\n<span class=\"bp\">⊢</span> <span class=\"o\">((</span><span class=\"n\">R</span> <span class=\"n\">ant_tr1</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">acc</span> <span class=\"bp\">++</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">ant_tr2</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">acc</span> <span class=\"bp\">++</span> <span class=\"o\">((</span><span class=\"n\">R</span> <span class=\"n\">ant_tr1</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">inacc</span> <span class=\"bp\">++</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">ant_tr2</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">inacc</span><span class=\"o\">)</span> <span class=\"bp\">++</span>\n     <span class=\"o\">((</span><span class=\"n\">R</span> <span class=\"n\">ant_tr1</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">red</span> <span class=\"bp\">++</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">ant_tr2</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">red</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">nodup</span>\n</code></pre></div>\n<p>There is <code>list.nodup_append_comm</code>, but the simplifier couldn't make use of it. Manually applying the lemmas to rearrange the terms was too hard for me.</p>\n<p>This custom theorem helped a lot: <code>theorem nodup_iff_card { α: Type } [decidable_eq α] (a: list α): a.nodup ↔ a.length = a.to_finset.card</code>. Maybe it's a good candidate for mathlib? There is <a href=\"https://leanprover-community.github.io/mathlib_docs/data/finset/basic.html#list.to_finset_card_of_nodup\">list.to_finset_card_of_nodup</a>, but it is one direction only.<br>\nIt was much easier to show <code>(a ++ b ++ c ++ ...).length = (a ++ b ++ c ++ ...).to_finset.card</code>, since <code>nat.add</code> and <code>finset.union</code> are commutative and the simplifier can solve goals where only assoc and comm rules are needed.</p>",
        "id": 221296209,
        "sender_full_name": "Henning Dieterichs",
        "timestamp": 1609428081
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> <code>dsimp only</code> helps! I just used unfold before.</p>",
        "id": 221296211,
        "sender_full_name": "Henning Dieterichs",
        "timestamp": 1609428085
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/236449-Program-verification/topic/Lists.20Without.20Duplicates/near/221253842\">said</a>:</p>\n<blockquote>\n<p>This screenshot looks like either not enough abstraction (e.g. some append operation on whatever the structures are) or too much unfolding rather than applying lemmas</p>\n</blockquote>\n<p>I felt the same (not only here but for many of my proofs). However, I have no clue how to improve that. At that point, I didn't unfold much and I don't know what new lemmas could help me to get more insight.</p>\n<p>This is an except of what I'm working on:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">LeafPartition</span> <span class=\"o\">:=</span> <span class=\"n\">mk</span> <span class=\"o\">::</span> <span class=\"o\">(</span><span class=\"n\">acc</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">Leaf</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">inacc</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">Leaf</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">red</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">Leaf</span><span class=\"o\">)</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">Ant</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">leaf</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">leaf</span><span class=\"o\">:</span> <span class=\"n\">Leaf</span><span class=\"o\">):</span> <span class=\"n\">Ant</span>\n<span class=\"bp\">|</span> <span class=\"n\">branch</span> <span class=\"o\">(</span><span class=\"n\">tr1</span><span class=\"o\">:</span> <span class=\"n\">Ant</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">tr2</span><span class=\"o\">:</span> <span class=\"n\">Ant</span><span class=\"o\">):</span> <span class=\"n\">Ant</span>\n<span class=\"bp\">|</span> <span class=\"n\">diverge</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">tr</span><span class=\"o\">:</span> <span class=\"n\">Ant</span><span class=\"o\">):</span> <span class=\"n\">Ant</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"n\">Ant</span> <span class=\"n\">bool</span> <span class=\"bp\">→</span> <span class=\"n\">LeafPartition</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">Ant.leaf</span> <span class=\"n\">can_prove_empty</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">if</span> <span class=\"n\">can_prove_empty</span> <span class=\"k\">then</span> <span class=\"o\">⟨</span> <span class=\"o\">[],</span> <span class=\"o\">[],</span> <span class=\"o\">[</span><span class=\"n\">n</span><span class=\"o\">]</span> <span class=\"o\">⟩</span> <span class=\"k\">else</span> <span class=\"o\">⟨</span> <span class=\"o\">[</span><span class=\"n\">n</span><span class=\"o\">],</span> <span class=\"o\">[],</span> <span class=\"o\">[]</span> <span class=\"o\">⟩</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">Ant.diverge</span> <span class=\"n\">can_prove_empty</span> <span class=\"n\">tr</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n    <span class=\"k\">match</span> <span class=\"n\">R</span> <span class=\"n\">tr</span><span class=\"o\">,</span> <span class=\"n\">can_prove_empty</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"o\">⟨</span> <span class=\"o\">[],</span> <span class=\"o\">[],</span> <span class=\"n\">m</span> <span class=\"o\">::</span> <span class=\"n\">ms</span> <span class=\"o\">⟩,</span> <span class=\"n\">ff</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span> <span class=\"o\">[],</span> <span class=\"o\">[</span><span class=\"n\">m</span><span class=\"o\">],</span> <span class=\"n\">ms</span> <span class=\"o\">⟩</span>\n    <span class=\"bp\">|</span> <span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">r</span>\n    <span class=\"kd\">end</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">Ant.branch</span> <span class=\"n\">tr1</span> <span class=\"n\">tr2</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n    <span class=\"k\">let</span> <span class=\"n\">r1</span> <span class=\"o\">:=</span> <span class=\"n\">R</span> <span class=\"n\">tr1</span><span class=\"o\">,</span> <span class=\"n\">r2</span> <span class=\"o\">:=</span> <span class=\"n\">R</span> <span class=\"n\">tr2</span> <span class=\"k\">in</span>\n        <span class=\"o\">⟨</span> <span class=\"n\">r1.acc</span> <span class=\"bp\">++</span> <span class=\"n\">r2.acc</span><span class=\"o\">,</span> <span class=\"n\">r1.inacc</span> <span class=\"bp\">++</span> <span class=\"n\">r2.inacc</span><span class=\"o\">,</span> <span class=\"n\">r1.red</span> <span class=\"bp\">++</span> <span class=\"n\">r2.red</span> <span class=\"o\">⟩</span>\n</code></pre></div>\n<p>I want to prove that the result is indeed a partition of all leaves, if the leaves of every branch in <code>ant</code> are disjoint.<br>\nThe goal above is for the branch case.</p>",
        "id": 221296601,
        "sender_full_name": "Henning Dieterichs",
        "timestamp": 1609428576
    },
    {
        "content": "<p>What does using <code>finset</code> give you? That two lists are the same if you remove duplicates and forget about order?</p>",
        "id": 221296675,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1609428617
    },
    {
        "content": "<p>What's <code>Leaf</code> defined as?</p>",
        "id": 221297085,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1609429081
    },
    {
        "content": "<p>Leaf is an arbitrary Type</p>",
        "id": 221297143,
        "sender_full_name": "Henning Dieterichs",
        "timestamp": 1609429103
    },
    {
        "content": "<p>The code above currently gives me</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">don't</span> <span class=\"n\">know</span> <span class=\"n\">how</span> <span class=\"n\">to</span> <span class=\"n\">synthesize</span> <span class=\"n\">placeholder</span>\n<span class=\"n\">context</span><span class=\"o\">:</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">Ant</span> <span class=\"n\">bool</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n</code></pre></div>\n<p>in the definition of <code>R</code></p>",
        "id": 221297236,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1609429217
    },
    {
        "content": "<p>Sorry, it is not a MWE... Creating a MWE would be hard. The code was just to give context.<br>\nMaybe adding <code>[decidable_eq Leaf]</code> to R fixes this, I have this globally.</p>",
        "id": 221297259,
        "sender_full_name": "Henning Dieterichs",
        "timestamp": 1609429264
    },
    {
        "content": "<blockquote>\n<p>What does using finset give you? That two lists are the same if you remove duplicates and forget about order?</p>\n</blockquote>\n<p>I know that <code>as ++ bs ++ cs ++ ds</code> has no duplicates. I want to show that <code>ds ++ bs ++ cs ++ as</code> has no duplicates (it's just a permutation - that should be trivial to show).<br>\nHowever, this is difficult, as I cannot automatically rearrange the terms - after all, permutating the lists changes them. (This is a step of my proof in the branch case)</p>\n<p>BUT, it is easy to prove with lean that <code>(ds ++ bs ++ cs ++ as).length = (as ++ bs ++ cs ++ ds).length</code> and that <code>(ds ++ bs ++ cs ++ as).to_finset = (as ++ bs ++ cs ++ ds).to_finset</code>! (Since length and to_finset is some kind of homomorphism into a commutative monoid)</p>",
        "id": 221297271,
        "sender_full_name": "Henning Dieterichs",
        "timestamp": 1609429292
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/list.perm.nodup_iff\">docs#list.perm.nodup_iff</a></p>",
        "id": 221297488,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1609429537
    },
    {
        "content": "<p>How difficult would it be to convince lean that <code>as ++ bs ++ cs ++ ds</code> is a permutation of <code>ds ++ bs ++ cs ++ as</code>?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span> <span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">as</span> <span class=\"n\">bs</span> <span class=\"n\">cs</span> <span class=\"n\">ds</span><span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">):</span> <span class=\"o\">(</span><span class=\"n\">as</span> <span class=\"bp\">++</span> <span class=\"n\">bs</span> <span class=\"bp\">++</span> <span class=\"n\">cs</span> <span class=\"bp\">++</span> <span class=\"n\">ds</span><span class=\"o\">)</span> <span class=\"bp\">~</span> <span class=\"o\">(</span><span class=\"n\">ds</span> <span class=\"bp\">++</span> <span class=\"n\">bs</span> <span class=\"bp\">++</span> <span class=\"n\">cs</span> <span class=\"bp\">++</span> <span class=\"n\">as</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n    <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 221297585,
        "sender_full_name": "Henning Dieterichs",
        "timestamp": 1609429632
    },
    {
        "content": "<p>One min, checking that</p>",
        "id": 221297679,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1609429718
    },
    {
        "content": "<p>I think lean's automation really likes equalities. In my limited experience, definitions that are made out of equalities are much easier to reason about than definitions that involve recursively defined predicates</p>",
        "id": 221297788,
        "sender_full_name": "Henning Dieterichs",
        "timestamp": 1609429820
    },
    {
        "content": "<p>I assume you've already found <a href=\"https://leanprover-community.github.io/mathlib_docs/find/list.perm_append_comm\">docs#list.perm_append_comm</a></p>",
        "id": 221298844,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1609430819
    },
    {
        "content": "<p>there is also comm for nodup directly, but is hard to apply manually</p>",
        "id": 221298871,
        "sender_full_name": "Henning Dieterichs",
        "timestamp": 1609430871
    },
    {
        "content": "<p>I think the key to this kind of problem is that </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">a</span><span class=\"bp\">~</span><span class=\"n\">a'</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">b</span> <span class=\"bp\">~</span> <span class=\"n\">b'</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">++</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">~</span> <span class=\"o\">(</span><span class=\"n\">a'</span> <span class=\"bp\">++</span> <span class=\"n\">b'</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>(otherwise you could not really apply perm_append_comm recursively)<br>\n...which states that <code>++</code> is well-defined on the equivalence class of permutations. But this just yields union on multisets.<br>\nAnd if you remove duplicates, you get finsets, so maybe it might be easier to work with finsets directly?</p>",
        "id": 221299366,
        "sender_full_name": "Henning Dieterichs",
        "timestamp": 1609431141
    },
    {
        "content": "<p>Working with finsets directly is definitely the way to go here</p>",
        "id": 221299391,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1609431177
    },
    {
        "content": "<p>That lemma is <a href=\"https://leanprover-community.github.io/mathlib_docs/find/list.perm.append\">docs#list.perm.append</a></p>",
        "id": 221299427,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1609431238
    },
    {
        "content": "<p>Yeah but that lemma won't work because of how the terms are associated.</p>",
        "id": 221299513,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1609431308
    },
    {
        "content": "<p>and there's a missing <code>@[trans]</code> lemma for perms.</p>",
        "id": 221299524,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1609431333
    },
    {
        "content": "<p>I would just use the comm and assoc lemmas and swap stuff by hand. You could even train the simplifier to do this</p>",
        "id": 221299731,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1609431509
    },
    {
        "content": "<p>Here's a full proof using those:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span> <span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">as</span> <span class=\"n\">bs</span> <span class=\"n\">cs</span> <span class=\"n\">ds</span><span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">as</span> <span class=\"bp\">++</span> <span class=\"n\">bs</span> <span class=\"bp\">++</span> <span class=\"n\">cs</span> <span class=\"bp\">++</span> <span class=\"n\">ds</span><span class=\"o\">)</span> <span class=\"bp\">~</span> <span class=\"o\">(</span><span class=\"n\">ds</span> <span class=\"bp\">++</span> <span class=\"n\">bs</span> <span class=\"bp\">++</span> <span class=\"n\">cs</span> <span class=\"bp\">++</span> <span class=\"n\">as</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">calc</span> <span class=\"o\">(</span><span class=\"n\">as</span> <span class=\"bp\">++</span> <span class=\"n\">bs</span> <span class=\"bp\">++</span> <span class=\"n\">cs</span> <span class=\"bp\">++</span> <span class=\"n\">ds</span><span class=\"o\">)</span> <span class=\"bp\">~</span> <span class=\"n\">as</span> <span class=\"bp\">++</span> <span class=\"o\">(</span><span class=\"n\">bs</span> <span class=\"bp\">++</span> <span class=\"n\">cs</span> <span class=\"bp\">++</span> <span class=\"n\">ds</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">list.append_assoc</span><span class=\"o\">]</span>\n                        <span class=\"bp\">...</span> <span class=\"bp\">~</span> <span class=\"o\">(</span><span class=\"n\">bs</span> <span class=\"bp\">++</span> <span class=\"n\">cs</span> <span class=\"bp\">++</span> <span class=\"n\">ds</span><span class=\"o\">)</span> <span class=\"bp\">++</span> <span class=\"n\">as</span> <span class=\"o\">:</span> <span class=\"n\">list.perm_append_comm</span>\n                        <span class=\"bp\">...</span> <span class=\"bp\">~</span> <span class=\"o\">(</span><span class=\"n\">bs</span> <span class=\"bp\">++</span> <span class=\"o\">(</span><span class=\"n\">cs</span> <span class=\"bp\">++</span> <span class=\"n\">ds</span><span class=\"o\">))</span> <span class=\"bp\">++</span> <span class=\"n\">as</span> <span class=\"o\">:</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">list.append_assoc</span><span class=\"o\">]</span>\n                        <span class=\"bp\">...</span> <span class=\"bp\">~</span> <span class=\"o\">(</span><span class=\"n\">bs</span> <span class=\"bp\">++</span> <span class=\"o\">(</span><span class=\"n\">ds</span> <span class=\"bp\">++</span> <span class=\"n\">cs</span><span class=\"o\">))</span> <span class=\"bp\">++</span> <span class=\"n\">as</span> <span class=\"o\">:</span> <span class=\"n\">list.perm.append_right</span> <span class=\"n\">_</span> <span class=\"bp\">$</span> <span class=\"n\">list.perm.append_left</span> <span class=\"n\">_</span> <span class=\"n\">list.perm_append_comm</span>\n                        <span class=\"bp\">...</span> <span class=\"bp\">~</span> <span class=\"o\">(</span><span class=\"n\">bs</span> <span class=\"bp\">++</span> <span class=\"n\">ds</span> <span class=\"bp\">++</span> <span class=\"n\">cs</span><span class=\"o\">)</span> <span class=\"bp\">++</span> <span class=\"n\">as</span> <span class=\"o\">:</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">list.append_assoc</span><span class=\"o\">]</span>\n                        <span class=\"bp\">...</span> <span class=\"bp\">~</span> <span class=\"o\">(</span><span class=\"n\">ds</span> <span class=\"bp\">++</span> <span class=\"n\">bs</span> <span class=\"bp\">++</span> <span class=\"n\">cs</span> <span class=\"bp\">++</span> <span class=\"n\">as</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">list.perm.append_right</span> <span class=\"n\">_</span> <span class=\"bp\">$</span> <span class=\"n\">list.perm.append_right</span> <span class=\"n\">_</span> <span class=\"n\">list.perm_append_comm</span>\n</code></pre></div>",
        "id": 221299802,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1609431563
    },
    {
        "content": "<p>Now get the simplifier to do it!</p>",
        "id": 221299826,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1609431582
    },
    {
        "content": "<p>But the simplifier can't solve associativity / commutativity goals?</p>",
        "id": 221299891,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1609431607
    },
    {
        "content": "<p>In my case though, I have 6 variables (<code>⟨ r1.acc ++ r2.acc, r1.inacc ++ r2.inacc, r1.red ++ r2.red ⟩</code>) :D So without automation it gets really hard</p>",
        "id": 221299896,
        "sender_full_name": "Henning Dieterichs",
        "timestamp": 1609431616
    },
    {
        "content": "<p>That's what <a href=\"https://leanprover-community.github.io/mathlib_docs/tactics.html#ac_refl\">tactic#ac_refl</a> is for, right?</p>",
        "id": 221299899,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1609431619
    },
    {
        "content": "<p>Except that only works for equality</p>",
        "id": 221299914,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1609431633
    },
    {
        "content": "<p>I would definitely try the simplifier.</p>",
        "id": 221299918,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1609431638
    },
    {
        "content": "<p>It's just key to prove</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">perm_foldl_append_iff</span> <span class=\"o\">{</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">l</span> <span class=\"n\">l'</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)}</span> <span class=\"o\">:</span>\n  <span class=\"n\">foldl</span> <span class=\"n\">append</span> <span class=\"n\">b</span> <span class=\"n\">l</span> <span class=\"bp\">~</span> <span class=\"n\">foldl</span> <span class=\"n\">append</span> <span class=\"n\">b</span> <span class=\"n\">l'</span> <span class=\"bp\">↔</span> <span class=\"n\">l</span> <span class=\"bp\">~</span> <span class=\"n\">l'</span> <span class=\"o\">:=</span>\n</code></pre></div>",
        "id": 221299927,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1609431647
    },
    {
        "content": "<p>You can take the quotients of lists under permutations to turn your <code>~</code> into an <code>=</code></p>",
        "id": 221299930,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1609431649
    },
    {
        "content": "<p>But then you have multisets</p>",
        "id": 221299938,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1609431653
    },
    {
        "content": "<p>You tell it comm and assoc and left_comm and it will then just put things into its favourite order. I don't know if it'll work but it's worth a try.</p>",
        "id": 221299977,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1609431703
    },
    {
        "content": "<p>Failing that, <code>abel</code> should be generalised to all operations, not just addition, and perhaps it should do this too</p>",
        "id": 221300076,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1609431787
    },
    {
        "content": "<p>not sure if relevant, but i've found <a href=\"https://leanprover-community.github.io/mathlib_docs/find/list.perm_iff_count\">docs#list.perm_iff_count</a> very useful for working with <code>perm</code></p>",
        "id": 221300193,
        "sender_full_name": "Marc Huisinga",
        "timestamp": 1609431917
    },
    {
        "content": "<p>Here's how to use <code>abel</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span> <span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">as</span> <span class=\"n\">bs</span> <span class=\"n\">cs</span> <span class=\"n\">ds</span><span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">as</span> <span class=\"bp\">++</span> <span class=\"n\">bs</span> <span class=\"bp\">++</span> <span class=\"n\">cs</span> <span class=\"bp\">++</span> <span class=\"n\">ds</span><span class=\"o\">)</span> <span class=\"bp\">~</span> <span class=\"o\">(</span><span class=\"n\">ds</span> <span class=\"bp\">++</span> <span class=\"n\">bs</span> <span class=\"bp\">++</span> <span class=\"n\">cs</span> <span class=\"bp\">++</span> <span class=\"n\">as</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"bp\">←</span><span class=\"n\">multiset.coe_eq_coe</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">multiset.coe_add</span><span class=\"o\">],</span>\n  <span class=\"n\">abel</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 221300330,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1609432059
    },
    {
        "content": "<p>I wonder if <a href=\"https://leanprover-community.github.io/mathlib_docs/find/multiset.coe_add\">docs#multiset.coe_add</a> simplifies in the wrong direction</p>",
        "id": 221300512,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1609432208
    },
    {
        "content": "<p>It seems like it's much easier to work with multisets than permutations of lists</p>",
        "id": 221300525,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1609432220
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">as</span> <span class=\"n\">bs</span> <span class=\"n\">cs</span> <span class=\"n\">ds</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">as</span> <span class=\"bp\">++</span> <span class=\"n\">bs</span> <span class=\"bp\">++</span> <span class=\"n\">cs</span> <span class=\"bp\">++</span> <span class=\"n\">ds</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">nodup</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"n\">ds</span> <span class=\"bp\">++</span> <span class=\"n\">bs</span> <span class=\"bp\">++</span> <span class=\"n\">cs</span> <span class=\"bp\">++</span> <span class=\"n\">as</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">nodup</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">apply</span> <span class=\"n\">list.perm.nodup_iff</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">multiset.coe_eq_coe</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">multiset.coe_add</span><span class=\"o\">,</span> <span class=\"n\">add_left_comm</span><span class=\"o\">,</span> <span class=\"n\">add_comm</span><span class=\"o\">],</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 221300929,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1609432586
    },
    {
        "content": "<p>oops, too late</p>",
        "id": 221300951,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1609432615
    },
    {
        "content": "<p>I don't think <code>coe_add</code> is the wrong direction. Usually you would use the simplifier on a multiset goal after <code>rcases</code> to make it about lists and it will turn everything into lists</p>",
        "id": 221301152,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1609432794
    },
    {
        "content": "<p>this problem is a little unusual in that you want to add an additional wrapping layer rather than remove one</p>",
        "id": 221301220,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1609432823
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/236449-Program-verification/topic/Lists.20Without.20Duplicates/near/221300929\">said</a>:</p>\n<blockquote>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">as</span> <span class=\"n\">bs</span> <span class=\"n\">cs</span> <span class=\"n\">ds</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">as</span> <span class=\"bp\">++</span> <span class=\"n\">bs</span> <span class=\"bp\">++</span> <span class=\"n\">cs</span> <span class=\"bp\">++</span> <span class=\"n\">ds</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">nodup</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"n\">ds</span> <span class=\"bp\">++</span> <span class=\"n\">bs</span> <span class=\"bp\">++</span> <span class=\"n\">cs</span> <span class=\"bp\">++</span> <span class=\"n\">as</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">nodup</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">apply</span> <span class=\"n\">list.perm.nodup_iff</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">multiset.coe_eq_coe</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">multiset.coe_add</span><span class=\"o\">,</span> <span class=\"n\">add_left_comm</span><span class=\"o\">,</span> <span class=\"n\">add_comm</span><span class=\"o\">],</span>\n<span class=\"kd\">end</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Which is almost the same as this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">nodup_iff_card</span> <span class=\"o\">{</span> <span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">):</span> <span class=\"n\">a.nodup</span> <span class=\"bp\">↔</span> <span class=\"n\">a.length</span> <span class=\"bp\">=</span> <span class=\"n\">a.to_finset.card</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n    <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">as</span> <span class=\"n\">bs</span> <span class=\"n\">cs</span> <span class=\"n\">ds</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">as</span> <span class=\"bp\">++</span> <span class=\"n\">bs</span> <span class=\"bp\">++</span> <span class=\"n\">cs</span> <span class=\"bp\">++</span> <span class=\"n\">ds</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">nodup</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"n\">ds</span> <span class=\"bp\">++</span> <span class=\"n\">bs</span> <span class=\"bp\">++</span> <span class=\"n\">cs</span> <span class=\"bp\">++</span> <span class=\"n\">as</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">nodup</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">nodup_iff_card</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">nodup_iff_card</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">finset.union_comm</span><span class=\"o\">,</span> <span class=\"n\">finset.union_left_comm</span><span class=\"o\">,</span> <span class=\"n\">nat.add_comm</span><span class=\"o\">,</span> <span class=\"n\">nat.add_left_comm</span><span class=\"o\">],</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 221301300,
        "sender_full_name": "Henning Dieterichs",
        "timestamp": 1609432918
    },
    {
        "content": "<p>except it has one fewer sorry :)</p>",
        "id": 221301388,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1609433022
    },
    {
        "content": "<p>I'm calling it a day now. Thank you for all your help in 2020 and see you in 2021! I wish you a happy new year ;)</p>",
        "id": 221301514,
        "sender_full_name": "Henning Dieterichs",
        "timestamp": 1609433129
    },
    {
        "content": "<p>You won't be doing Lean to summon in the new year??</p>",
        "id": 221301806,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1609433412
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"gr\">sorry</span><span class=\"o\">,</span>\n</code></pre></div>",
        "id": 221301849,
        "sender_full_name": "Henning Dieterichs",
        "timestamp": 1609433450
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"234196\">@Henning Dieterichs</span> <br>\nThese are the sorts of definitional lemmas I would make:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.list.basic</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">Leaf</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">Leaf</span><span class=\"o\">]</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">LeafPartition</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">acc</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"o\">[])</span>\n<span class=\"o\">(</span><span class=\"n\">inacc</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"o\">[])</span>\n<span class=\"o\">(</span><span class=\"n\">red</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"o\">[])</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">Ant</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">leaf</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">Leaf</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Ant</span>\n<span class=\"bp\">|</span> <span class=\"n\">branch</span> <span class=\"o\">(</span><span class=\"n\">tr1</span> <span class=\"o\">:</span> <span class=\"n\">Ant</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">tr2</span> <span class=\"o\">:</span> <span class=\"n\">Ant</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Ant</span>\n<span class=\"bp\">|</span> <span class=\"n\">diverge</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">tr</span> <span class=\"o\">:</span> <span class=\"n\">Ant</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Ant</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Ant</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"n\">Ant</span> <span class=\"n\">bool</span> <span class=\"n\">Leaf</span> <span class=\"bp\">→</span> <span class=\"n\">LeafPartition</span> <span class=\"n\">Leaf</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">leaf</span> <span class=\"n\">bb</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">ite</span> <span class=\"n\">bb</span> <span class=\"o\">{</span><span class=\"n\">red</span> <span class=\"o\">:=</span> <span class=\"o\">[</span><span class=\"n\">l</span><span class=\"o\">],</span> <span class=\"bp\">..</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">acc</span> <span class=\"o\">:=</span> <span class=\"o\">[</span><span class=\"n\">l</span><span class=\"o\">],</span> <span class=\"bp\">..</span><span class=\"o\">}</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">diverge</span> <span class=\"n\">bb</span> <span class=\"n\">tr</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">ite</span> <span class=\"n\">bb</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">tr</span><span class=\"o\">)</span> <span class=\"o\">(</span>\n    <span class=\"k\">match</span> <span class=\"n\">R</span> <span class=\"n\">tr</span> <span class=\"k\">with</span>\n      <span class=\"bp\">|</span> <span class=\"o\">⟨[],</span> <span class=\"o\">[],</span> <span class=\"n\">m</span> <span class=\"o\">::</span> <span class=\"n\">ms</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">inacc</span> <span class=\"o\">:=</span> <span class=\"o\">[</span><span class=\"n\">m</span><span class=\"o\">],</span> <span class=\"n\">red</span> <span class=\"o\">:=</span> <span class=\"n\">ms</span><span class=\"o\">,</span> <span class=\"bp\">..</span><span class=\"o\">}</span>\n      <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">R</span> <span class=\"n\">tr</span>\n    <span class=\"kd\">end</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">branch</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">{</span>\n    <span class=\"n\">acc</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">acc</span> <span class=\"bp\">++</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">y</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">acc</span><span class=\"o\">,</span>\n    <span class=\"n\">inacc</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">inacc</span> <span class=\"bp\">++</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">y</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">inacc</span><span class=\"o\">,</span>\n    <span class=\"n\">red</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">red</span> <span class=\"bp\">++</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">y</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">red</span>\n  <span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">R_leaf_true</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">Leaf</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">leaf</span> <span class=\"n\">tt</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"n\">red</span> <span class=\"o\">:=</span> <span class=\"o\">[</span><span class=\"n\">l</span><span class=\"o\">],</span> <span class=\"bp\">..</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">R_leaf_false</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">Leaf</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">leaf</span> <span class=\"n\">ff</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"n\">acc</span> <span class=\"o\">:=</span> <span class=\"o\">[</span><span class=\"n\">l</span><span class=\"o\">],</span> <span class=\"bp\">..</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">R_branch</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Ant</span> <span class=\"n\">bool</span> <span class=\"n\">Leaf</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">branch</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">=</span>\n  <span class=\"o\">{</span> <span class=\"n\">acc</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">acc</span> <span class=\"bp\">++</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">y</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">acc</span><span class=\"o\">,</span> <span class=\"n\">inacc</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">inacc</span> <span class=\"bp\">++</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">y</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">inacc</span><span class=\"o\">,</span>\n    <span class=\"n\">red</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">red</span> <span class=\"bp\">++</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">y</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">red</span> <span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">R_diverge_true</span> <span class=\"o\">(</span><span class=\"n\">tr</span> <span class=\"o\">:</span> <span class=\"n\">Ant</span> <span class=\"n\">bool</span> <span class=\"n\">Leaf</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">diverge</span> <span class=\"n\">tt</span> <span class=\"n\">tr</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">R</span> <span class=\"n\">tr</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">R_diverge_false_cons</span> <span class=\"o\">{</span><span class=\"n\">tr</span> <span class=\"o\">:</span> <span class=\"n\">Ant</span> <span class=\"n\">bool</span> <span class=\"n\">Leaf</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">Leaf</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">ms</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">Leaf</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"n\">tr</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"n\">red</span> <span class=\"o\">:=</span> <span class=\"n\">m</span> <span class=\"o\">::</span> <span class=\"n\">ms</span><span class=\"o\">,</span> <span class=\"bp\">..</span><span class=\"o\">})</span> <span class=\"o\">:</span>\n  <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">diverge</span> <span class=\"n\">ff</span> <span class=\"n\">tr</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"n\">inacc</span> <span class=\"o\">:=</span> <span class=\"o\">[</span><span class=\"n\">m</span><span class=\"o\">],</span> <span class=\"n\">red</span> <span class=\"o\">:=</span> <span class=\"n\">ms</span><span class=\"o\">,</span> <span class=\"bp\">..</span><span class=\"o\">}</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">R_diverge_false_not</span> <span class=\"o\">{</span><span class=\"n\">tr</span> <span class=\"o\">:</span> <span class=\"n\">Ant</span> <span class=\"n\">bool</span> <span class=\"n\">Leaf</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">Leaf</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">ms</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">Leaf</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">tr</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">red</span> <span class=\"bp\">=</span> <span class=\"o\">[]</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">tr</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">acc</span> <span class=\"bp\">≠</span> <span class=\"o\">[]</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">tr</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">inacc</span> <span class=\"bp\">≠</span> <span class=\"o\">[])</span> <span class=\"o\">:</span>\n  <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">diverge</span> <span class=\"n\">ff</span>  <span class=\"n\">tr</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">R</span> <span class=\"n\">tr</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">hr</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">tr</span><span class=\"o\">)</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">_</span> <span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">hac</span><span class=\"o\">,</span> <span class=\"n\">tlac</span><span class=\"o\">⟩,</span> <span class=\"n\">_</span> <span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">hin</span><span class=\"o\">,</span> <span class=\"n\">tlin</span><span class=\"o\">⟩,</span> <span class=\"n\">_</span> <span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">hre</span><span class=\"o\">,</span> <span class=\"n\">tlre</span><span class=\"o\">⟩⟩</span><span class=\"bp\">;</span>\n  <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"n\">hr</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">h</span> <span class=\"bp\">&lt;|&gt;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"n\">hr</span><span class=\"o\">],</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 221304453,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1609435698
    },
    {
        "content": "<p>you should use <code>tt</code> and <code>ff</code> instead of <code>true</code> and <code>false</code></p>",
        "id": 221305646,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1609436954
    },
    {
        "content": "<p>Fixed. In general, there'd likely be some way to have it be over Prop and not bool, right?</p>",
        "id": 221305827,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1609437128
    },
    {
        "content": "<p>Well <code>R</code> itself is over <code>bool</code> so the lemmas should be too</p>",
        "id": 221305864,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1609437199
    },
    {
        "content": "<p>if it used <code>Prop</code> though your cases should use <code>p -&gt; ...</code> and <code>\\neg p -&gt; ...</code> instead of <code>true</code> and <code>false</code></p>",
        "id": 221305871,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1609437221
    },
    {
        "content": "<p>Right, I meant that <code>R</code> itself might be over Prop. Since the original example had the bools named as <code>can_prove_empty</code></p>",
        "id": 221306183,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1609437572
    },
    {
        "content": "<p><code>Ant</code> has three type arguments btw, that seems odd</p>",
        "id": 221306206,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1609437602
    },
    {
        "content": "<p>the beta argument is unused</p>",
        "id": 221306265,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1609437616
    },
    {
        "content": "<p>Ah, I meant</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Ant</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">leaf</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Ant</span>\n<span class=\"bp\">|</span> <span class=\"n\">branch</span> <span class=\"o\">(</span><span class=\"n\">tr1</span> <span class=\"o\">:</span> <span class=\"n\">Ant</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">tr2</span> <span class=\"o\">:</span> <span class=\"n\">Ant</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Ant</span>\n<span class=\"bp\">|</span> <span class=\"n\">diverge</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">tr</span> <span class=\"o\">:</span> <span class=\"n\">Ant</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Ant</span>\n</code></pre></div>",
        "id": 221306985,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1609438295
    },
    {
        "content": "<p>Anyway,  it was an attempt to make the example shared by the other poster above compile, just to show examples of the structure default values and the definitional lemmas.</p>",
        "id": 221307046,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1609438329
    },
    {
        "content": "<p>Here's a proof of something that I think roughly approximates the goal:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.multiset.basic</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">Leaf</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">LeafPartition</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">acc</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"o\">[])</span>\n<span class=\"o\">(</span><span class=\"n\">inacc</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"o\">[])</span>\n<span class=\"o\">(</span><span class=\"n\">red</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"o\">[])</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">Ant</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">leaf</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Ant</span>\n<span class=\"bp\">|</span> <span class=\"n\">branch</span> <span class=\"o\">(</span><span class=\"n\">tr1</span> <span class=\"o\">:</span> <span class=\"n\">Ant</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">tr2</span> <span class=\"o\">:</span> <span class=\"n\">Ant</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Ant</span>\n<span class=\"bp\">|</span> <span class=\"n\">diverge</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">tr</span> <span class=\"o\">:</span> <span class=\"n\">Ant</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Ant</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Ant</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"n\">Ant</span> <span class=\"n\">bool</span> <span class=\"n\">Leaf</span> <span class=\"bp\">→</span> <span class=\"n\">LeafPartition</span> <span class=\"n\">Leaf</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">leaf</span> <span class=\"n\">bb</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">ite</span> <span class=\"n\">bb</span> <span class=\"o\">{</span><span class=\"n\">red</span> <span class=\"o\">:=</span> <span class=\"o\">[</span><span class=\"n\">l</span><span class=\"o\">],</span> <span class=\"bp\">..</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">acc</span> <span class=\"o\">:=</span> <span class=\"o\">[</span><span class=\"n\">l</span><span class=\"o\">],</span> <span class=\"bp\">..</span><span class=\"o\">}</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">diverge</span> <span class=\"n\">bb</span> <span class=\"n\">tr</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">ite</span> <span class=\"n\">bb</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">tr</span><span class=\"o\">)</span> <span class=\"o\">(</span>\n    <span class=\"k\">match</span> <span class=\"n\">R</span> <span class=\"n\">tr</span> <span class=\"k\">with</span>\n      <span class=\"bp\">|</span> <span class=\"o\">⟨[],</span> <span class=\"o\">[],</span> <span class=\"n\">m</span> <span class=\"o\">::</span> <span class=\"n\">ms</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">inacc</span> <span class=\"o\">:=</span> <span class=\"o\">[</span><span class=\"n\">m</span><span class=\"o\">],</span> <span class=\"n\">red</span> <span class=\"o\">:=</span> <span class=\"n\">ms</span><span class=\"o\">,</span> <span class=\"bp\">..</span><span class=\"o\">}</span>\n      <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">R</span> <span class=\"n\">tr</span>\n    <span class=\"kd\">end</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">branch</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">{</span>\n    <span class=\"n\">acc</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">acc</span> <span class=\"bp\">++</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">y</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">acc</span><span class=\"o\">,</span>\n    <span class=\"n\">inacc</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">inacc</span> <span class=\"bp\">++</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">y</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">inacc</span><span class=\"o\">,</span>\n    <span class=\"n\">red</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">red</span> <span class=\"bp\">++</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">y</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">red</span>\n  <span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">leaves</span> <span class=\"o\">:</span> <span class=\"n\">Ant</span> <span class=\"n\">bool</span> <span class=\"n\">Leaf</span> <span class=\"bp\">→</span> <span class=\"n\">list</span> <span class=\"n\">Leaf</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">leaf</span> <span class=\"n\">bb</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">[</span><span class=\"n\">l</span><span class=\"o\">]</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">diverge</span> <span class=\"n\">bb</span> <span class=\"n\">tr</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">leaves</span> <span class=\"n\">tr</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">branch</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">leaves</span> <span class=\"n\">x</span> <span class=\"bp\">++</span> <span class=\"n\">leaves</span> <span class=\"n\">y</span>\n\n<span class=\"kn\">section</span>\n<span class=\"kn\">local</span> <span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"n\">leaves</span> <span class=\"n\">R</span> <span class=\"n\">add_left_comm</span> <span class=\"n\">add_comm</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">R_perm</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Ant</span> <span class=\"n\">bool</span> <span class=\"n\">Leaf</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">leaves</span> <span class=\"n\">a</span> <span class=\"bp\">~</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">acc</span> <span class=\"bp\">++</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">inacc</span> <span class=\"bp\">++</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">red</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">multiset.coe_eq_coe</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">multiset.coe_add</span><span class=\"o\">],</span>\n  <span class=\"n\">induction</span> <span class=\"n\">a</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp</span><span class=\"bp\">;</span> <span class=\"n\">split_ifs</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">multiset.coe_add</span><span class=\"o\">,</span> <span class=\"bp\">*</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"bp\">-</span><span class=\"n\">multiset.coe_eq_coe</span><span class=\"o\">],</span> <span class=\"n\">split_ifs</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">multiset.coe_add</span><span class=\"o\">,</span> <span class=\"bp\">*</span><span class=\"o\">],</span>\n    <span class=\"n\">rcases</span> <span class=\"n\">hr</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">a_tr</span><span class=\"o\">)</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">_</span> <span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">hac</span><span class=\"o\">,</span> <span class=\"n\">tlac</span><span class=\"o\">⟩,</span> <span class=\"n\">_</span> <span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">hin</span><span class=\"o\">,</span> <span class=\"n\">tlin</span><span class=\"o\">⟩,</span> <span class=\"n\">_</span> <span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">hre</span><span class=\"o\">,</span> <span class=\"n\">tlre</span><span class=\"o\">⟩⟩</span><span class=\"bp\">;</span>\n    <span class=\"n\">refl</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 221307059,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1609438356
    },
    {
        "content": "<p>the proof is a bit bombastic, it just cases on everything</p>",
        "id": 221307091,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1609438394
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/236449-Program-verification/topic/Lists.20Without.20Duplicates/near/221307059\">said</a>:</p>\n<blockquote>\n<p>Here's a proof of something that I think roughly approximates the goal:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">...</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">R_perm</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Ant</span> <span class=\"n\">bool</span> <span class=\"n\">Leaf</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">leaves</span> <span class=\"n\">a</span> <span class=\"bp\">~</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">acc</span> <span class=\"bp\">++</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">inacc</span> <span class=\"bp\">++</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">red</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">multiset.coe_eq_coe</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">multiset.coe_add</span><span class=\"o\">],</span>\n  <span class=\"n\">induction</span> <span class=\"n\">a</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp</span><span class=\"bp\">;</span> <span class=\"n\">split_ifs</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">multiset.coe_add</span><span class=\"o\">,</span> <span class=\"bp\">*</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"bp\">-</span><span class=\"n\">multiset.coe_eq_coe</span><span class=\"o\">],</span> <span class=\"n\">split_ifs</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">multiset.coe_add</span><span class=\"o\">,</span> <span class=\"bp\">*</span><span class=\"o\">],</span>\n    <span class=\"n\">rcases</span> <span class=\"n\">hr</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">a_tr</span><span class=\"o\">)</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">_</span> <span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">hac</span><span class=\"o\">,</span> <span class=\"n\">tlac</span><span class=\"o\">⟩,</span> <span class=\"n\">_</span> <span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">hin</span><span class=\"o\">,</span> <span class=\"n\">tlin</span><span class=\"o\">⟩,</span> <span class=\"n\">_</span> <span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">hre</span><span class=\"o\">,</span> <span class=\"n\">tlre</span><span class=\"o\">⟩⟩</span><span class=\"bp\">;</span>\n    <span class=\"n\">refl</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n<span class=\"bp\">...</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Nice <span aria-label=\"flushed\" class=\"emoji emoji-1f633\" role=\"img\" title=\"flushed\">:flushed:</span>  I didn't think such a short proof could do it.<br>\nI wonder though, I thought <code>simp</code> should, in general, be only used for closing goals?</p>",
        "id": 221347839,
        "sender_full_name": "Henning Dieterichs",
        "timestamp": 1609500353
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"234196\">Henning Dieterichs</span> <a href=\"#narrow/stream/236449-Program-verification/topic/Lists.20Without.20Duplicates/near/221347839\">said</a>:</p>\n<blockquote>\n<p>I wonder though, I thought <code>simp</code> should, in general, be only used for closing goals?</p>\n</blockquote>\n<p>if you want to use simp in the middle of a proof (e.g. because the subgoal is extremely verbose), one way to make simp less brittle is to run <code>squeeze_simp</code> instead and then paste the output for a <code>simp only</code> call. this can also greatly boost performance (or at least it used to).</p>",
        "id": 221353088,
        "sender_full_name": "Marc Huisinga",
        "timestamp": 1609509883
    },
    {
        "content": "<p>Thanks for pointing that out. I often wondered which lemmas simp used.</p>",
        "id": 221362924,
        "sender_full_name": "Henning Dieterichs",
        "timestamp": 1609526031
    },
    {
        "content": "<p>For more low-level output you can also turn on <code>set_option trace.simplify true</code>, see the start of <a href=\"https://leanprover-community.github.io/extras/simp.html\">the community page on the simplifier</a>.</p>",
        "id": 221363615,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1609527054
    }
]
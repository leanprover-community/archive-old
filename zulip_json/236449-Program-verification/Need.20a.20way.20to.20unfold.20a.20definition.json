[
    {
        "content": "<p>Sorry for bringing up the stupid example again. I'm just annoyingly stuck and it seems to be really lean-specific. The moral equivalent goes  through in Coq no problem because we can unfold a fixpoint definition. Here goes:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"kn\">variables</span> <span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span>\n\n<span class=\"kn\">inductive</span> <span class=\"n\">color</span>\n<span class=\"bp\">|</span> <span class=\"n\">red</span>\n<span class=\"bp\">|</span> <span class=\"n\">black</span>\n\n<span class=\"kn\">inductive</span> <span class=\"n\">node</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">leaf</span> <span class=\"o\">{}</span> <span class=\"o\">:</span> <span class=\"n\">node</span>\n<span class=\"bp\">|</span> <span class=\"n\">tree</span> <span class=\"o\">{}</span> <span class=\"o\">(</span><span class=\"n\">color</span> <span class=\"o\">:</span> <span class=\"n\">color</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">left</span> <span class=\"o\">:</span> <span class=\"n\">node</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">val</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">right</span> <span class=\"o\">:</span> <span class=\"n\">node</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">node</span>\n\n<span class=\"n\">def</span> <span class=\"n\">balance</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">color</span> <span class=\"bp\">→</span> <span class=\"n\">node</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">node</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">node</span> <span class=\"n\">α</span>\n<span class=\"bp\">|</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">black</span> <span class=\"o\">(</span><span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">red</span> <span class=\"o\">(</span><span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">red</span> <span class=\"n\">a</span> <span class=\"n\">x</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">y</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"n\">z</span> <span class=\"n\">d</span> <span class=\"o\">:=</span>\n    <span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">red</span> <span class=\"o\">(</span><span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">black</span> <span class=\"n\">a</span> <span class=\"n\">x</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">y</span> <span class=\"o\">(</span><span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">black</span> <span class=\"n\">c</span> <span class=\"n\">z</span> <span class=\"n\">d</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">black</span> <span class=\"o\">(</span><span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">red</span> <span class=\"n\">a</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">red</span> <span class=\"n\">b</span> <span class=\"n\">y</span> <span class=\"n\">c</span><span class=\"o\">))</span> <span class=\"n\">z</span> <span class=\"n\">d</span> <span class=\"o\">:=</span>\n    <span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">red</span> <span class=\"o\">(</span><span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">black</span> <span class=\"n\">a</span> <span class=\"n\">x</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">y</span> <span class=\"o\">(</span><span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">black</span> <span class=\"n\">c</span> <span class=\"n\">z</span> <span class=\"n\">d</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">black</span> <span class=\"n\">a</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">red</span> <span class=\"o\">(</span><span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">red</span> <span class=\"n\">b</span> <span class=\"n\">y</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"n\">z</span> <span class=\"n\">d</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n    <span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">red</span> <span class=\"o\">(</span><span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">black</span> <span class=\"n\">a</span> <span class=\"n\">x</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">y</span> <span class=\"o\">(</span><span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">black</span> <span class=\"n\">c</span> <span class=\"n\">z</span> <span class=\"n\">d</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">black</span> <span class=\"n\">a</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">red</span> <span class=\"n\">b</span> <span class=\"n\">y</span> <span class=\"o\">(</span><span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">red</span> <span class=\"n\">c</span> <span class=\"n\">z</span> <span class=\"n\">d</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n     <span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">red</span> <span class=\"o\">(</span><span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">black</span> <span class=\"n\">a</span> <span class=\"n\">x</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">y</span> <span class=\"o\">(</span><span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">black</span> <span class=\"n\">c</span> <span class=\"n\">z</span> <span class=\"n\">d</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">color</span> <span class=\"n\">a</span> <span class=\"n\">x</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span> <span class=\"n\">a</span> <span class=\"n\">x</span> <span class=\"n\">b</span>\n\n<span class=\"bp\">#</span><span class=\"kn\">print</span> <span class=\"kn\">prefix</span> <span class=\"n\">balance</span><span class=\"bp\">.</span><span class=\"n\">equations</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">b</span> <span class=\"n\">y</span> <span class=\"n\">c</span> <span class=\"n\">z</span> <span class=\"n\">d</span><span class=\"o\">,</span> <span class=\"n\">balance</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">black</span> <span class=\"o\">(</span><span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">red</span> <span class=\"o\">(</span><span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">red</span> <span class=\"n\">a</span> <span class=\"n\">x</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">y</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"n\">z</span> <span class=\"n\">d</span> <span class=\"bp\">=</span>\n    <span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">red</span> <span class=\"o\">(</span><span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">black</span> <span class=\"n\">a</span> <span class=\"n\">x</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">y</span> <span class=\"o\">(</span><span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">black</span> <span class=\"n\">c</span> <span class=\"n\">z</span> <span class=\"n\">d</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n    <span class=\"c1\">-- intros, refl, -- should work</span>\n    <span class=\"n\">rintros</span> <span class=\"n\">a</span> <span class=\"n\">x</span> <span class=\"n\">b</span> <span class=\"n\">y</span> <span class=\"o\">(</span><span class=\"n\">c</span><span class=\"bp\">|⟨</span><span class=\"n\">cc</span><span class=\"bp\">|</span><span class=\"n\">cc</span><span class=\"o\">,</span> <span class=\"n\">cl</span><span class=\"o\">,</span> <span class=\"n\">cv</span><span class=\"o\">,</span> <span class=\"n\">cr</span><span class=\"bp\">⟩</span><span class=\"o\">)</span> <span class=\"n\">z</span> <span class=\"o\">(</span><span class=\"n\">d</span><span class=\"bp\">|⟨</span><span class=\"n\">dc</span><span class=\"bp\">|</span><span class=\"n\">dc</span><span class=\"o\">,</span> <span class=\"n\">dl</span><span class=\"bp\">|⟨</span><span class=\"n\">dlc</span><span class=\"bp\">|</span><span class=\"n\">dlc</span><span class=\"o\">,</span> <span class=\"n\">dll</span><span class=\"o\">,</span> <span class=\"n\">dlv</span><span class=\"o\">,</span> <span class=\"n\">dlr</span><span class=\"bp\">⟩</span><span class=\"o\">,</span> <span class=\"n\">dv</span><span class=\"o\">,</span> <span class=\"n\">dr</span><span class=\"bp\">|⟨</span><span class=\"n\">drc</span><span class=\"bp\">|</span><span class=\"n\">drc</span><span class=\"o\">,</span> <span class=\"n\">drl</span><span class=\"o\">,</span> <span class=\"n\">drv</span><span class=\"o\">,</span> <span class=\"n\">drr</span><span class=\"bp\">⟩⟩</span><span class=\"o\">),</span>\n    <span class=\"n\">all_goals</span> <span class=\"o\">{</span><span class=\"n\">refl</span><span class=\"o\">}</span>\n<span class=\"kn\">end</span>\n</code></pre></div>\n\n\n<p>I've found a very concise proof, but it's deeply unsatisfying. First notice, that the statement of the lemma is literally the pattern match, so it really should just go through with <code>refl</code>. In fact nothing in the context or anywhere else gives us a hint at all what to do next.</p>\n<p>I haven't found any tactic to make any progress, unfold doesn't say anything. And the fact, that I have to destruct <code>dl</code> and <code>dr</code> is because of lines 3 and 4 of the pattern match. If we erase them, we don't have to do that much distinction by cases. In total the equation compiler creates 122 equations.</p>\n<p>The root cause seems to be that the equation compiler is introducing cases which are meaningless in the context.</p>\n<p>What it conceptually should do, is go over the first case in the pattern match,  see, that the first pattern is <code>color.black</code>, so we do have to destruct the first argument. Keep that fact around, go to the next argument, see that it needs a pattern on node because we encountered <code>node.tree</code>. Next we see that color needs to be split again, etc. </p>\n<p>If the compiler did a backtracking search during the generation of cases, we'd end up with quite a bit fewer cases and the lemmas would be more useful, because they'd quantify over all <code>c</code> and <code>d</code> in this particular case, fixing <code>refl</code>.</p>\n<p>Now if the compiler can't do that / be told to do that / can't be fixed, the next best thing would be a tactic, that lets us destruct based on the concrete lambda.</p>\n<p>If <code>unfold</code> worked in this case, we should get something like <code>[a lot of the body is gone, because we're in a deeply nested case...] (fun x, x.cases_on ...)</code>. At that point, we could make a tactic (I'm going to call it <code>unfold_cases</code>), that takes the type of <code>x</code>, and destructs it. As a consequence we'd get a few new goals.</p>\n<p>With this tactic, we could write the proof as this, I think: <code>intros, repeat { refl &lt;|&gt; unfold_cases }</code>.</p>\n<p>If we want to avoid exploding the whole body, we could always do the distinction by cases and then elide the body.</p>\n<p>I'd be happy to have a go at writing such a tactic, but I don't even know how to unfold the definition. I can't find what to pass as the config to <code>unfold</code>; <code>delta</code>, <code>dsimp</code> and <code>simp</code> all do nothing. </p>\n<p>Any help would be very, very welcome. I've been struggling with this example for a year now on and off and I'm determined to make it work is some nice way.</p>\n<p>And I'm pretty sure this is not a fluke, but rather something that's quite deeply linked to the distinction between Coq and lean so it'll come in handy in pretty much all cases of non-trivial pattern match expressions. It may not come up in maths that much but comes up tons in reasoning about programs.</p>",
        "id": 202878232,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593876234
    },
    {
        "content": "<p>Yeah, I see it's pretty hairy. Writing a good equation compiler is quite a difficult task. I think a tactic like you describe that can use details of the specification of the function would be very useful indeed</p>",
        "id": 202878914,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1593877155
    },
    {
        "content": "<p>It's now possible to roll our own syntax for functions and call the built-in equation compiler. I could imagine a way of defining equations so that, we can at least prove the branches used in the specification of the function as lemmas / additional equations, even if it doesn't match the definition exactly</p>",
        "id": 202879020,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1593877309
    },
    {
        "content": "<p>ya, adding the lemmas for the cases would be fine. They should be easy to construct proofs for too, as they are really just distinction by cases, refl (by definition).</p>",
        "id": 202879103,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593877430
    },
    {
        "content": "<p>is there any kind of docu / examples where I could learn something about the API? I struggle to find docu.</p>",
        "id": 202879234,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593877568
    },
    {
        "content": "<p>Here is a good tutorial on the writing of automation <a href=\"https://github.com/leanprover-community/mathlib/blob/master/docs/extras/tactic_writing.md\">https://github.com/leanprover-community/mathlib/blob/master/docs/extras/tactic_writing.md</a>. Looking at the code of <code>tactic.core</code> in mathlib should provide you with a lot of good examples</p>",
        "id": 202879978,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1593878667
    },
    {
        "content": "<p>Oh and here is a guide for the available tactics <a href=\"https://leanprover-community.github.io/mathlib_docs/tactics.html\">https://leanprover-community.github.io/mathlib_docs/tactics.html</a></p>",
        "id": 202880220,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1593878992
    },
    {
        "content": "<p>Ya, I've studied both before writing here. At this point, I think my next step would be getting the AST of the goal that I need. So I could inspect it and figure out what to <code>cases</code> on.</p>",
        "id": 202880397,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593879201
    },
    {
        "content": "<p>That sounds like a good exercise. Please keep me posted, maybe I can give you a couple of nudges</p>",
        "id": 202880564,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1593879455
    },
    {
        "content": "<p>k will do</p>",
        "id": 202880623,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593879519
    },
    {
        "content": "<p>alright, this is not very useful. When I unfold the application a few times, I get to a \"constant\" named \"balance\".</p>",
        "id": 202885891,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593887454
    },
    {
        "content": "<p>I don't get its body.</p>",
        "id": 202885893,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593887459
    },
    {
        "content": "<p>Don't try to do too much in one definition. For one thing, it's easier to have separate <code>balance_l</code> and <code>balance_r</code> functions rather than doing both at once. Plus, it's impossible for all of these case splits to be true by <code>refl</code>, even if the equation compiler didn't do some superfluous case splits, because they overlap</p>",
        "id": 202887430,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593889927
    },
    {
        "content": "<p>Additionally, there will be far fewer cases if you consider only well formed red black trees</p>",
        "id": 202887464,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593890039
    },
    {
        "content": "<p>With valid RB trees, you mean having a type family that does things like enforcing the balance or red-black invariant by construction, right? Then it's becomes a GADT and we can prove much more about it during construction.</p>",
        "id": 202887527,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593890155
    },
    {
        "content": "<p>doing that ends up with a more painful insertion algorithm, though. In particular it becomes a mutually recursive insertion.</p>",
        "id": 202887577,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593890202
    },
    {
        "content": "<p>I wrote this once a long long time ago. Here's how I did it:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">inductive</span> <span class=\"n\">rb_node</span> <span class=\"o\">(</span><span class=\"n\">D</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">bool</span> <span class=\"bp\">→</span> <span class=\"n\">nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">nil</span> <span class=\"o\">:</span> <span class=\"n\">rb_node</span> <span class=\"n\">ff</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"n\">red</span> <span class=\"o\">:</span> <span class=\"n\">D</span> <span class=\"bp\">→</span> <span class=\"bp\">Π</span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">rb_node</span> <span class=\"n\">ff</span> <span class=\"n\">n</span><span class=\"o\">),</span> <span class=\"n\">rb_node</span> <span class=\"n\">tt</span> <span class=\"n\">n</span>\n<span class=\"bp\">|</span> <span class=\"n\">black</span> <span class=\"o\">:</span> <span class=\"n\">D</span> <span class=\"bp\">→</span> <span class=\"bp\">Π</span><span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"n\">a</span><span class=\"o\">},</span> <span class=\"n\">rb_node</span> <span class=\"n\">a</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">rb_node</span> <span class=\"n\">ff</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">rb_node</span> <span class=\"n\">ff</span> <span class=\"o\">(</span><span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">rb_node</span>\n  <span class=\"n\">def</span> <span class=\"n\">blackR</span> <span class=\"o\">{</span><span class=\"n\">D</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">D</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"n\">a</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">rb_node</span> <span class=\"n\">D</span> <span class=\"n\">ff</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">rb_node</span> <span class=\"n\">D</span> <span class=\"n\">a</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">rb_node</span> <span class=\"n\">D</span> <span class=\"n\">ff</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"n\">ff</span><span class=\"o\">,</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"n\">black</span> <span class=\"n\">d</span> <span class=\"n\">l</span> <span class=\"n\">r</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"n\">tt</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">red</span> <span class=\"n\">d&#39;</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"n\">black</span> <span class=\"n\">d&#39;</span> <span class=\"o\">(</span><span class=\"n\">red</span> <span class=\"n\">d</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"n\">z</span>\n  <span class=\"kn\">end</span>\n\n  <span class=\"kn\">section</span>\n  <span class=\"c1\">-- An rb_node whose invariant has been broken. The bool,nat type parameters refer to the</span>\n  <span class=\"c1\">-- original type of the node before being broken.</span>\n  <span class=\"kn\">inductive</span> <span class=\"n\">ins_broken</span> <span class=\"o\">(</span><span class=\"n\">D</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">bool</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n  <span class=\"bp\">|</span> <span class=\"n\">fixed</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span><span class=\"o\">{</span><span class=\"n\">b</span><span class=\"o\">},</span> <span class=\"n\">rb_node</span> <span class=\"n\">D</span> <span class=\"n\">b</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">ins_broken</span> <span class=\"n\">b</span>\n  <span class=\"bp\">|</span> <span class=\"n\">redden</span> <span class=\"o\">:</span> <span class=\"n\">rb_node</span> <span class=\"n\">D</span> <span class=\"n\">tt</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">ins_broken</span> <span class=\"n\">ff</span>\n  <span class=\"bp\">|</span> <span class=\"n\">redL</span> <span class=\"o\">:</span> <span class=\"n\">D</span> <span class=\"bp\">→</span> <span class=\"bp\">Π</span><span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">rb_node</span> <span class=\"n\">D</span> <span class=\"n\">tt</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">rb_node</span> <span class=\"n\">D</span> <span class=\"n\">b</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">ins_broken</span> <span class=\"n\">tt</span>\n  <span class=\"bp\">|</span> <span class=\"n\">redR</span> <span class=\"o\">:</span> <span class=\"n\">D</span> <span class=\"bp\">→</span> <span class=\"bp\">Π</span><span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">rb_node</span> <span class=\"n\">D</span> <span class=\"n\">b</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">rb_node</span> <span class=\"n\">D</span> <span class=\"n\">tt</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">ins_broken</span> <span class=\"n\">tt</span>\n\n  <span class=\"kn\">open</span> <span class=\"n\">ins_broken</span>\n  <span class=\"n\">def</span> <span class=\"n\">insert2</span> <span class=\"o\">{</span><span class=\"n\">D</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">has_lt</span> <span class=\"n\">D</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">decidable_rel</span> <span class=\"o\">((</span><span class=\"bp\">&lt;</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">D</span> <span class=\"bp\">→</span> <span class=\"n\">D</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)]</span> <span class=\"o\">(</span><span class=\"n\">dat</span> <span class=\"o\">:</span> <span class=\"n\">D</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">replace</span> <span class=\"o\">:</span> <span class=\"n\">bool</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">rb_node</span> <span class=\"n\">D</span> <span class=\"n\">a</span> <span class=\"n\">n</span><span class=\"o\">),</span> <span class=\"n\">ins_broken</span> <span class=\"n\">D</span> <span class=\"n\">n</span> <span class=\"n\">a</span>\n  <span class=\"bp\">|</span> <span class=\"n\">ff</span> <span class=\"mi\">0</span> <span class=\"o\">(</span><span class=\"n\">nil</span> <span class=\"bp\">._</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">redden</span> <span class=\"o\">(</span><span class=\"n\">red</span> <span class=\"n\">dat</span> <span class=\"o\">(</span><span class=\"n\">nil</span> <span class=\"n\">D</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">nil</span> <span class=\"n\">D</span><span class=\"o\">))</span>\n  <span class=\"bp\">|</span> <span class=\"n\">tt</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">red</span> <span class=\"n\">d</span> <span class=\"n\">l</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">match</span> <span class=\"n\">cmp</span> <span class=\"n\">dat</span> <span class=\"n\">d</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">ordering</span><span class=\"bp\">.</span><span class=\"n\">lt</span> <span class=\"o\">:=</span> <span class=\"k\">match</span> <span class=\"n\">insert2</span> <span class=\"n\">l</span> <span class=\"k\">with</span>\n      <span class=\"bp\">|</span> <span class=\"n\">fixed</span> <span class=\"n\">c</span> <span class=\"o\">:=</span> <span class=\"n\">fixed</span> <span class=\"o\">(</span><span class=\"n\">red</span> <span class=\"n\">d</span> <span class=\"n\">c</span> <span class=\"n\">r</span><span class=\"o\">)</span>\n      <span class=\"bp\">|</span> <span class=\"n\">redden</span> <span class=\"n\">c</span> <span class=\"o\">:=</span> <span class=\"n\">redL</span> <span class=\"n\">d</span> <span class=\"bp\">_</span> <span class=\"n\">c</span> <span class=\"n\">r</span>\n      <span class=\"kn\">end</span>\n    <span class=\"bp\">|</span> <span class=\"n\">ordering</span><span class=\"bp\">.</span><span class=\"n\">eq</span> <span class=\"o\">:=</span> <span class=\"n\">fixed</span> <span class=\"o\">(</span><span class=\"n\">red</span> <span class=\"o\">(</span><span class=\"n\">cond</span> <span class=\"n\">replace</span> <span class=\"n\">dat</span> <span class=\"n\">d</span><span class=\"o\">)</span> <span class=\"n\">l</span> <span class=\"n\">r</span><span class=\"o\">)</span>\n    <span class=\"bp\">|</span> <span class=\"n\">ordering</span><span class=\"bp\">.</span><span class=\"n\">gt</span> <span class=\"o\">:=</span> <span class=\"k\">match</span> <span class=\"n\">insert2</span> <span class=\"n\">r</span> <span class=\"k\">with</span>\n      <span class=\"bp\">|</span> <span class=\"n\">fixed</span> <span class=\"n\">c</span> <span class=\"o\">:=</span> <span class=\"n\">fixed</span> <span class=\"o\">(</span><span class=\"n\">red</span> <span class=\"n\">d</span> <span class=\"n\">l</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n      <span class=\"bp\">|</span> <span class=\"n\">redden</span> <span class=\"n\">c</span> <span class=\"o\">:=</span> <span class=\"n\">redR</span> <span class=\"n\">d</span> <span class=\"bp\">_</span> <span class=\"n\">l</span> <span class=\"n\">c</span>\n      <span class=\"kn\">end</span>\n    <span class=\"kn\">end</span>\n  <span class=\"bp\">|</span> <span class=\"n\">ff</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">black</span> <span class=\"bp\">._</span> <span class=\"n\">d</span> <span class=\"bp\">._</span> <span class=\"n\">a</span> <span class=\"n\">l</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">match</span> <span class=\"n\">cmp</span> <span class=\"n\">dat</span> <span class=\"n\">d</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">ordering</span><span class=\"bp\">.</span><span class=\"n\">lt</span> <span class=\"o\">:=</span> <span class=\"k\">match</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">insert2</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"k\">with</span>\n      <span class=\"bp\">|</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"n\">fixed</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"n\">fixed</span> <span class=\"o\">(</span><span class=\"n\">black</span> <span class=\"n\">d</span> <span class=\"n\">l</span> <span class=\"n\">r</span><span class=\"o\">)</span>\n      <span class=\"bp\">|</span> <span class=\"n\">ff</span><span class=\"o\">,</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"n\">redden</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"n\">fixed</span> <span class=\"o\">(</span><span class=\"n\">black</span> <span class=\"n\">d</span> <span class=\"n\">l</span> <span class=\"n\">r</span><span class=\"o\">)</span>\n      <span class=\"bp\">|</span> <span class=\"n\">tt</span><span class=\"o\">,</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"n\">redL</span> <span class=\"n\">d₂</span> <span class=\"n\">b</span> <span class=\"o\">(</span><span class=\"n\">red</span> <span class=\"n\">d₁</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">w</span> <span class=\"o\">:=</span> <span class=\"n\">redden</span> <span class=\"o\">(</span><span class=\"n\">red</span> <span class=\"n\">d₂</span> <span class=\"o\">(</span><span class=\"n\">black</span> <span class=\"n\">d₁</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">black</span> <span class=\"n\">d</span> <span class=\"n\">z</span> <span class=\"n\">w</span><span class=\"o\">))</span>\n      <span class=\"bp\">|</span> <span class=\"n\">tt</span><span class=\"o\">,</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"n\">redR</span> <span class=\"n\">d₁</span> <span class=\"n\">b</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">red</span> <span class=\"n\">d₂</span> <span class=\"n\">y</span> <span class=\"n\">z</span><span class=\"o\">),</span> <span class=\"n\">w</span> <span class=\"o\">:=</span> <span class=\"n\">redden</span> <span class=\"o\">(</span><span class=\"n\">red</span> <span class=\"n\">d₂</span> <span class=\"o\">(</span><span class=\"n\">black</span> <span class=\"n\">d₁</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">black</span> <span class=\"n\">d</span> <span class=\"n\">z</span> <span class=\"n\">w</span><span class=\"o\">))</span>\n      <span class=\"kn\">end</span>\n    <span class=\"bp\">|</span> <span class=\"n\">ordering</span><span class=\"bp\">.</span><span class=\"n\">eq</span> <span class=\"o\">:=</span> <span class=\"n\">fixed</span> <span class=\"o\">(</span><span class=\"n\">black</span> <span class=\"o\">(</span><span class=\"n\">cond</span> <span class=\"n\">replace</span> <span class=\"n\">dat</span> <span class=\"n\">d</span><span class=\"o\">)</span> <span class=\"n\">l</span> <span class=\"n\">r</span><span class=\"o\">)</span>\n    <span class=\"bp\">|</span> <span class=\"n\">ordering</span><span class=\"bp\">.</span><span class=\"n\">gt</span> <span class=\"o\">:=</span> <span class=\"k\">match</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">insert2</span> <span class=\"n\">r</span> <span class=\"k\">with</span>\n      <span class=\"bp\">|</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">fixed</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"n\">fixed</span> <span class=\"o\">(</span><span class=\"n\">black</span> <span class=\"n\">d</span> <span class=\"n\">l</span> <span class=\"n\">r</span><span class=\"o\">)</span>\n      <span class=\"bp\">|</span> <span class=\"n\">ff</span><span class=\"o\">,</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">redden</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"n\">fixed</span> <span class=\"o\">(</span><span class=\"n\">blackR</span> <span class=\"n\">d</span> <span class=\"n\">l</span> <span class=\"n\">r</span><span class=\"o\">)</span>\n      <span class=\"bp\">|</span> <span class=\"n\">tt</span><span class=\"o\">,</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"n\">red</span> <span class=\"n\">d₁</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">redden</span> <span class=\"o\">(</span><span class=\"n\">red</span> <span class=\"n\">d₂</span> <span class=\"n\">z</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">redden</span> <span class=\"o\">(</span><span class=\"n\">red</span> <span class=\"n\">d</span> <span class=\"o\">(</span><span class=\"n\">black</span> <span class=\"n\">d₁</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">black</span> <span class=\"n\">d₂</span> <span class=\"n\">z</span> <span class=\"n\">w</span><span class=\"o\">))</span>\n      <span class=\"kn\">end</span>\n    <span class=\"kn\">end</span>\n  <span class=\"kn\">end</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">rb_node</span>\n</code></pre></div>",
        "id": 202887641,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593890291
    },
    {
        "content": "<p>And what do you mean by overlapping, btw? Pattern matches are disjoint by definition, no? The second case only applies, if the first one didn't, I.e. we could even have a new information in the local context, saying that it is not compatible with the any of the previous cases.</p>",
        "id": 202887667,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593890375
    },
    {
        "content": "<p>Maybe that's the way you write the branches of the definition, but in the equations they all have to stand alone. That's why there are so many case splits</p>",
        "id": 202887723,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593890428
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">def</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"bp\">ℕ</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"n\">m</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span>\n<span class=\"bp\">|</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"mi\">2</span>\n</code></pre></div>\n\n\n<p>Obviously we can't have the equation <code>foo.equations_1 : foo m 0 = 1</code> here</p>",
        "id": 202887750,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593890486
    },
    {
        "content": "<p>so lean has to case split it and you get <code>foo (m+1) 0 = 1</code> instead</p>",
        "id": 202887764,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593890514
    },
    {
        "content": "<p>Unlike Coq's <code>Program Definition</code>, lean does not have definitions where the later branches come with preconditions saying that the earlier branches don't match</p>",
        "id": 202887823,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593890586
    },
    {
        "content": "<p>Ah... that's different from my mental model coming from F#. I always think of them as the next branch having a proof of the previous not having matched.</p>",
        "id": 202887895,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593890716
    },
    {
        "content": "<p>the only way lean can express that property is by case splitting until it's true by disjointness of constructors</p>",
        "id": 202887904,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593890758
    },
    {
        "content": "<p>something like <code>forall m, (forall n, (0, n) &lt;&gt; (m, 0)) -&gt; rest</code> wouldn't work?</p>",
        "id": 202887950,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593890806
    },
    {
        "content": "<p>Which means that when you have a definition like </p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">def</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"n\">node</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">A</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">red</span> <span class=\"o\">(</span><span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">red</span> <span class=\"n\">a</span> <span class=\"n\">x</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">y</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span>\n<span class=\"bp\">|</span> <span class=\"bp\">_</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span>\n</code></pre></div>\n\n\n<p>it generates a ton of case splits. If you do it twice it generates a square ton</p>",
        "id": 202887962,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593890836
    },
    {
        "content": "<p>I'm just saying that this isn't how the equation compiler works</p>",
        "id": 202887967,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593890854
    },
    {
        "content": "<p>ok fair enough.</p>",
        "id": 202887972,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593890865
    },
    {
        "content": "<p>I can imagine a variation on the equation compiler that generates those, although it might be difficult to work with</p>",
        "id": 202887993,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593890882
    },
    {
        "content": "<p>does that mean I'm just simply restricted how I have to write the definition, or could that in general be solved using tactics?</p>",
        "id": 202888018,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593890912
    },
    {
        "content": "<p>One thing you can do is to split the definition into smaller parts</p>",
        "id": 202888019,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593890928
    },
    {
        "content": "<p>it's a bit like <code>ite</code> vs. <code>dite</code>, isn't it?</p>",
        "id": 202888020,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593890930
    },
    {
        "content": "<p>Done properly, it can eliminate the superfluous case splits (so you can get the proofs by <code>refl</code> back when possible)</p>",
        "id": 202888028,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593890961
    },
    {
        "content": "<p>You can also very precisely specify the case split tree using by using <code>induction</code> and <code>cases</code> to write the definition</p>",
        "id": 202888076,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593891018
    },
    {
        "content": "<p>right, sure, but then I do it by hand, right?</p>",
        "id": 202888095,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593891054
    },
    {
        "content": "<p>as in during the proof, right?</p>",
        "id": 202888105,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593891078
    },
    {
        "content": "<p>you do the same case splits in the proof</p>",
        "id": 202888110,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593891089
    },
    {
        "content": "<p>you have to do that anyway</p>",
        "id": 202888113,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593891096
    },
    {
        "content": "<p>I wonder if it could be written almost like a relation, with 5 separate constructors.</p>",
        "id": 202888171,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593891188
    },
    {
        "content": "<p>then you'd only have 5 cases</p>",
        "id": 202888173,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593891198
    },
    {
        "content": "<p>Indeed, I recommend it</p>",
        "id": 202888175,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593891209
    },
    {
        "content": "<p>That's what <code>ins_broken</code> is accomplishing in my code snippet</p>",
        "id": 202888179,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593891222
    },
    {
        "content": "<p>Do we have any control about how the equation compiler does its work? perhaps some attributes or something?</p>",
        "id": 202888246,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593891332
    },
    {
        "content": "<p>maybe help it out a little?</p>",
        "id": 202888250,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593891342
    },
    {
        "content": "<p>not really</p>",
        "id": 202888251,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593891344
    },
    {
        "content": "<p>You can help it out by writing the equations in a particular way</p>",
        "id": 202888255,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593891359
    },
    {
        "content": "<p>is there a white paper that describes the algo, so I could know what is and what isn't good?</p>",
        "id": 202888306,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593891405
    },
    {
        "content": "<p>I don't think so, but equation compilation has a literature from systems like Agda already</p>",
        "id": 202888314,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593891464
    },
    {
        "content": "<p>ah, ok, so I'll have to look it up there.</p>",
        "id": 202888358,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593891488
    },
    {
        "content": "<p>Generally speaking, superfluous case splits happen in examples like <code>foo : ℕ → ℕ → ℕ</code> above, which will probably have 4 cases instead of 3 because it decides which things need splitting at the top level and then splits all of them</p>",
        "id": 202888377,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593891570
    },
    {
        "content": "<p>I do have to say, I was really hoping to write down the definition as naturally as possible and use tactics to prove the cases. Having to change the definition so the compiler is happier, is a bit disappointing.</p>",
        "id": 202888378,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593891579
    },
    {
        "content": "<p>You can still do that, if you don't care about the 100 cases thing</p>",
        "id": 202888397,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593891602
    },
    {
        "content": "<p>you should prove the equations you want regardless</p>",
        "id": 202888422,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593891612
    },
    {
        "content": "<p>I really don't care too much about the cases, but unfortunately unfold doesn't help.</p>",
        "id": 202888424,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593891636
    },
    {
        "content": "<p>so I literally don't see what cases need to be considered.</p>",
        "id": 202888426,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593891648
    },
    {
        "content": "<p>even a tactic that would do something like \"here's a definition, you introduce all the cases as per definition and create goals, please\" would pretty much fix the problem.</p>",
        "id": 202888444,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593891707
    },
    {
        "content": "<p>it's that I can't see what cases are missing that makes is to hard to work with.</p>",
        "id": 202888483,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593891736
    },
    {
        "content": "<p>I think we could have a <code>split_unfold foo</code> tactic that attempts to unfold <code>foo</code> and do case splits on any variables that block unfolding</p>",
        "id": 202888489,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593891754
    },
    {
        "content": "<p>that would be amazing, I tried doing something like that, but so far not too much luck.</p>",
        "id": 202888503,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593891793
    },
    {
        "content": "<p>I can unfold the goal a bit, but then I just get a constant \"balance\".</p>",
        "id": 202888509,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593891815
    },
    {
        "content": "<p>not the lambda that it corresponds to.</p>",
        "id": 202888516,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593891823
    },
    {
        "content": "<p>It doesn't correspond to a lambda that would be helpful for you anyway</p>",
        "id": 202888568,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593891859
    },
    {
        "content": "<p>I guess in Coq matches get compiled to primitive matches so this kind of display makes sense?</p>",
        "id": 202888579,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593891905
    },
    {
        "content": "<p>it does this:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">to_set</span> <span class=\"n\">l</span> <span class=\"n\">x</span> <span class=\"bp\">\\/</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">v</span> <span class=\"bp\">\\/</span> <span class=\"n\">to_set</span> <span class=\"n\">r</span> <span class=\"n\">x</span> <span class=\"bp\">&lt;-&gt;</span>\n<span class=\"n\">to_set</span>\n  <span class=\"k\">match</span> <span class=\"n\">c</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">red</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">tree</span> <span class=\"n\">c</span> <span class=\"n\">l</span> <span class=\"n\">v</span> <span class=\"n\">r</span>\n  <span class=\"bp\">|</span> <span class=\"n\">black</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"k\">match</span> <span class=\"n\">l</span> <span class=\"k\">with</span>\n      <span class=\"bp\">|</span> <span class=\"n\">leaf</span> <span class=\"bp\">=&gt;</span>\n          <span class=\"k\">match</span> <span class=\"n\">r</span> <span class=\"k\">with</span>\n          <span class=\"bp\">|</span> <span class=\"n\">leaf</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">tree</span> <span class=\"n\">c</span> <span class=\"n\">l</span> <span class=\"n\">v</span> <span class=\"n\">r</span>\n          <span class=\"bp\">|</span> <span class=\"n\">tree</span> <span class=\"n\">color0</span> <span class=\"n\">b</span> <span class=\"n\">y</span> <span class=\"n\">d</span> <span class=\"bp\">=&gt;</span>\n              <span class=\"k\">match</span> <span class=\"n\">color0</span> <span class=\"k\">with</span>\n              <span class=\"bp\">|</span> <span class=\"n\">red</span> <span class=\"bp\">=&gt;</span>\n                  <span class=\"k\">match</span> <span class=\"n\">b</span> <span class=\"k\">with</span>\n                  <span class=\"bp\">|</span> <span class=\"n\">leaf</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">match</span> <span class=\"n\">d</span> <span class=\"k\">with</span>\n                            <span class=\"bp\">|</span> <span class=\"n\">leaf</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">tree</span> <span class=\"n\">c</span> <span class=\"n\">l</span> <span class=\"n\">v</span> <span class=\"n\">r</span>\n                            <span class=\"bp\">|</span> <span class=\"n\">tree</span> <span class=\"n\">color1</span> <span class=\"n\">c0</span> <span class=\"n\">z</span> <span class=\"n\">d0</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">match</span> <span class=\"n\">color1</span> <span class=\"k\">with</span>\n                                                     <span class=\"bp\">|</span> <span class=\"n\">red</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">tree</span> <span class=\"n\">red</span> <span class=\"o\">(</span><span class=\"n\">tree</span> <span class=\"n\">black</span> <span class=\"n\">l</span> <span class=\"n\">v</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">y</span> <span class=\"o\">(</span><span class=\"n\">tree</span> <span class=\"n\">black</span> <span class=\"n\">c0</span> <span class=\"n\">z</span> <span class=\"n\">d0</span><span class=\"o\">)</span>\n                                                     <span class=\"bp\">|</span> <span class=\"n\">black</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">tree</span> <span class=\"n\">c</span> <span class=\"n\">l</span> <span class=\"n\">v</span> <span class=\"n\">r</span>\n                                                     <span class=\"kn\">end</span>\n                            <span class=\"kn\">end</span>\n                  <span class=\"bp\">|</span> <span class=\"n\">tree</span> <span class=\"n\">color1</span> <span class=\"n\">b0</span> <span class=\"n\">y0</span> <span class=\"n\">c0</span> <span class=\"bp\">=&gt;</span>\n                      <span class=\"k\">match</span> <span class=\"n\">color1</span> <span class=\"k\">with</span>\n                      <span class=\"bp\">|</span> <span class=\"n\">red</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">tree</span> <span class=\"n\">red</span> <span class=\"o\">(</span><span class=\"n\">tree</span> <span class=\"n\">black</span> <span class=\"n\">l</span> <span class=\"n\">v</span> <span class=\"n\">b0</span><span class=\"o\">)</span> <span class=\"n\">y0</span> <span class=\"o\">(</span><span class=\"n\">tree</span> <span class=\"n\">black</span> <span class=\"n\">c0</span> <span class=\"n\">y</span> <span class=\"n\">d</span><span class=\"o\">)</span>\n                      <span class=\"bp\">|</span> <span class=\"n\">black</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">match</span> <span class=\"n\">d</span> <span class=\"k\">with</span>\n                                 <span class=\"bp\">|</span> <span class=\"n\">leaf</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">tree</span> <span class=\"n\">c</span> <span class=\"n\">l</span> <span class=\"n\">v</span> <span class=\"n\">r</span>\n                                 <span class=\"bp\">|</span> <span class=\"n\">tree</span> <span class=\"n\">color2</span> <span class=\"n\">c1</span> <span class=\"n\">z</span> <span class=\"n\">d0</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">match</span> <span class=\"n\">color2</span> <span class=\"k\">with</span>\n                                                          <span class=\"bp\">|</span> <span class=\"n\">red</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">tree</span> <span class=\"n\">red</span> <span class=\"o\">(</span><span class=\"n\">tree</span> <span class=\"n\">black</span> <span class=\"n\">l</span> <span class=\"n\">v</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">y</span> <span class=\"o\">(</span><span class=\"n\">tree</span> <span class=\"n\">black</span> <span class=\"n\">c1</span> <span class=\"n\">z</span> <span class=\"n\">d0</span><span class=\"o\">)</span>\n                                                          <span class=\"bp\">|</span> <span class=\"n\">black</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">tree</span> <span class=\"n\">c</span> <span class=\"n\">l</span> <span class=\"n\">v</span> <span class=\"n\">r</span>\n                                                          <span class=\"kn\">end</span>\n                                 <span class=\"kn\">end</span>\n                      <span class=\"kn\">end</span>\n                  <span class=\"kn\">end</span>\n              <span class=\"bp\">|</span> <span class=\"n\">black</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">tree</span> <span class=\"n\">c</span> <span class=\"n\">l</span> <span class=\"n\">v</span> <span class=\"n\">r</span>\n              <span class=\"kn\">end</span>\n          <span class=\"kn\">end</span>\n      <span class=\"bp\">|</span> <span class=\"n\">tree</span> <span class=\"n\">color0</span> <span class=\"n\">a</span> <span class=\"n\">x0</span> <span class=\"n\">c0</span> <span class=\"bp\">=&gt;</span>\n          <span class=\"k\">match</span> <span class=\"n\">color0</span> <span class=\"k\">with</span>\n          <span class=\"bp\">|</span> <span class=\"n\">red</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"o\">(</span><span class=\"n\">and</span> <span class=\"n\">more</span><span class=\"o\">)</span>\n              <span class=\"bp\">```</span>\n</code></pre></div>",
        "id": 202888644,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593892023
    },
    {
        "content": "<p>so you immediately see what do and you can make a tactic destructing the top match expr.</p>",
        "id": 202888651,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593892054
    },
    {
        "content": "<p>my attempt so far was this:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">meta</span> <span class=\"n\">def</span> <span class=\"n\">find_matching</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">expr</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">name</span> <span class=\"bp\">→</span> <span class=\"n\">tactic</span> <span class=\"n\">expr</span>\n<span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"o\">:=</span> <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">failed</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">H</span><span class=\"bp\">::</span><span class=\"n\">Hs</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">do</span>\n    <span class=\"n\">t</span> <span class=\"err\">←</span> <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">resolve_name</span> <span class=\"n\">H</span><span class=\"o\">,</span>\n    <span class=\"n\">t</span> <span class=\"err\">←</span> <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">to_expr</span> <span class=\"n\">t</span><span class=\"o\">,</span>\n    <span class=\"n\">t</span> <span class=\"err\">←</span> <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">infer_type</span> <span class=\"n\">t</span><span class=\"o\">,</span>\n    <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">unify</span> <span class=\"n\">e</span> <span class=\"n\">t</span> <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">transparency</span><span class=\"bp\">.</span><span class=\"n\">all</span> <span class=\"bp\">&gt;&gt;</span> <span class=\"n\">return</span> <span class=\"n\">t</span>\n\n<span class=\"n\">meta</span> <span class=\"n\">def</span> <span class=\"n\">trace_goal</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">unit</span> <span class=\"o\">:=</span>\n<span class=\"n\">do</span>  <span class=\"n\">goal</span> <span class=\"err\">←</span> <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">target</span><span class=\"o\">,</span>\n    <span class=\"n\">names</span> <span class=\"err\">←</span> <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">get_eqn_lemmas_for</span> <span class=\"n\">ff</span> <span class=\"bp\">`</span><span class=\"n\">balance</span><span class=\"o\">,</span>\n    <span class=\"n\">find_matching</span> <span class=\"n\">goal</span> <span class=\"n\">names</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">trace</span>\n</code></pre></div>",
        "id": 202888711,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593892103
    },
    {
        "content": "<p>It finds the lemmas. And I was hoping to instantiate each one of them like <code>apply</code> and if it doesn't unify with the current context, kill off the lemma for the current path.</p>",
        "id": 202888722,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593892162
    },
    {
        "content": "<p>If you <code>delta balance balance._main</code> you can see something pretty similar</p>",
        "id": 202888724,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593892171
    },
    {
        "content": "<p>so you'd get fewer and fewer lemmas work.</p>",
        "id": 202888726,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593892178
    },
    {
        "content": "<p>ya, looking good, now we'd need to make the root thing go away.</p>",
        "id": 202888777,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593892255
    },
    {
        "content": "<p>root thing?</p>",
        "id": 202888782,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593892269
    },
    {
        "content": "<p>because <code>color.black.cases_on</code> should become just one branch, right?</p>",
        "id": 202888784,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593892284
    },
    {
        "content": "<p><code>dsimp</code></p>",
        "id": 202888785,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593892291
    },
    {
        "content": "<p>I see. so now after <code>dsimp</code> it I think looks like this: <code>node.rec (blablabla) c</code>. so the tactic would now have to go and split <code>c</code>, correct?</p>",
        "id": 202888842,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593892430
    },
    {
        "content": "<p>yea</p>",
        "id": 202888915,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593892547
    },
    {
        "content": "<p>that's probably the best way to do it: first <code>delta</code> then <code>dsimp</code> until you get stuck, then call <code>cases</code> to split on all stuck recursors; this generates the split tree, and then you can restart from the beginning with the split tree and then use regular <code>rw</code> to apply the equation lemmas</p>",
        "id": 202888971,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593892668
    },
    {
        "content": "<p>it would be nice if the equation compiler reported the split tree though, that would save a lot of trouble</p>",
        "id": 202889011,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593892704
    },
    {
        "content": "<p>I've got this beautiful pattern:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">b</span> <span class=\"n\">y</span> <span class=\"n\">c</span> <span class=\"n\">z</span> <span class=\"n\">d</span><span class=\"o\">,</span> <span class=\"n\">balance</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">black</span> <span class=\"o\">(</span><span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">red</span> <span class=\"o\">(</span><span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">red</span> <span class=\"n\">a</span> <span class=\"n\">x</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">y</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"n\">z</span> <span class=\"n\">d</span> <span class=\"bp\">=</span>\n    <span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">red</span> <span class=\"o\">(</span><span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">black</span> <span class=\"n\">a</span> <span class=\"n\">x</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">y</span> <span class=\"o\">(</span><span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">black</span> <span class=\"n\">c</span> <span class=\"n\">z</span> <span class=\"n\">d</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n    <span class=\"c1\">-- intros, refl, -- should work</span>\n    <span class=\"c1\">-- rintros a x b y (c|⟨cc|cc, cl, cv, cr⟩) z (d|⟨dc|dc, dl|⟨dlc|dlc, dll, dlv, dlr⟩, dv, dr|⟨drc|drc, drl, drv, drr⟩⟩),</span>\n    <span class=\"c1\">-- all_goals {refl}</span>\n    <span class=\"n\">intros</span><span class=\"o\">,</span>\n    <span class=\"n\">delta</span> <span class=\"n\">balance</span> <span class=\"n\">balance</span><span class=\"bp\">._</span><span class=\"n\">main</span><span class=\"o\">,</span>\n    <span class=\"n\">dsimp</span><span class=\"o\">,</span>\n    <span class=\"n\">cases</span> <span class=\"n\">c</span><span class=\"bp\">;</span> <span class=\"n\">refl</span> <span class=\"bp\">&lt;|&gt;</span> <span class=\"n\">dsimp</span><span class=\"o\">,</span>\n    <span class=\"n\">cases</span> <span class=\"n\">d</span><span class=\"bp\">;</span> <span class=\"n\">refl</span> <span class=\"bp\">&lt;|&gt;</span> <span class=\"n\">dsimp</span><span class=\"o\">,</span>\n    <span class=\"n\">cases</span> <span class=\"n\">d_color</span><span class=\"bp\">;</span> <span class=\"n\">refl</span> <span class=\"bp\">&lt;|&gt;</span> <span class=\"n\">dsimp</span><span class=\"o\">,</span>\n    <span class=\"n\">cases</span> <span class=\"n\">d_left</span><span class=\"bp\">;</span> <span class=\"n\">refl</span> <span class=\"bp\">&lt;|&gt;</span> <span class=\"n\">dsimp</span><span class=\"o\">,</span>\n    <span class=\"n\">cases</span> <span class=\"n\">d_right</span><span class=\"bp\">;</span> <span class=\"n\">refl</span> <span class=\"bp\">&lt;|&gt;</span> <span class=\"n\">dsimp</span><span class=\"o\">,</span>\n    <span class=\"n\">cases</span> <span class=\"n\">d_right_color</span><span class=\"bp\">;</span> <span class=\"n\">refl</span> <span class=\"bp\">&lt;|&gt;</span> <span class=\"n\">dsimp</span><span class=\"o\">,</span>\n    <span class=\"n\">cases</span> <span class=\"n\">d_left_color</span><span class=\"bp\">;</span> <span class=\"n\">refl</span> <span class=\"bp\">&lt;|&gt;</span> <span class=\"n\">dsimp</span><span class=\"o\">,</span>\n    <span class=\"n\">cases</span> <span class=\"n\">d_right</span><span class=\"bp\">;</span> <span class=\"n\">refl</span> <span class=\"bp\">&lt;|&gt;</span> <span class=\"n\">dsimp</span><span class=\"o\">,</span>\n    <span class=\"n\">cases</span> <span class=\"n\">d_right_color</span><span class=\"bp\">;</span> <span class=\"n\">refl</span> <span class=\"bp\">&lt;|&gt;</span> <span class=\"n\">dsimp</span><span class=\"o\">,</span>\n    <span class=\"n\">cases</span> <span class=\"n\">d_right</span><span class=\"bp\">;</span> <span class=\"n\">refl</span> <span class=\"bp\">&lt;|&gt;</span> <span class=\"n\">dsimp</span><span class=\"o\">,</span>\n    <span class=\"n\">cases</span> <span class=\"n\">d_right_color</span><span class=\"bp\">;</span> <span class=\"n\">refl</span> <span class=\"bp\">&lt;|&gt;</span> <span class=\"n\">dsimp</span><span class=\"o\">,</span>\n    <span class=\"n\">cases</span> <span class=\"n\">c_color</span><span class=\"bp\">;</span> <span class=\"n\">refl</span> <span class=\"bp\">&lt;|&gt;</span> <span class=\"n\">dsimp</span><span class=\"o\">,</span>\n    <span class=\"n\">cases</span> <span class=\"n\">d</span><span class=\"bp\">;</span> <span class=\"n\">refl</span> <span class=\"bp\">&lt;|&gt;</span> <span class=\"n\">dsimp</span><span class=\"o\">,</span>\n    <span class=\"n\">cases</span> <span class=\"n\">d_color</span><span class=\"bp\">;</span> <span class=\"n\">refl</span> <span class=\"bp\">&lt;|&gt;</span> <span class=\"n\">dsimp</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n</code></pre></div>",
        "id": 202889106,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593892889
    },
    {
        "content": "<p>very repetitive, but it's entirely obvious what to do next.</p>",
        "id": 202889108,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593892905
    },
    {
        "content": "<p>and it's directly driven by the goal, no guessing.</p>",
        "id": 202889158,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593892937
    },
    {
        "content": "<p>so I think, we could pattern match <code>%%x.cases_on _ c</code> and then <code>cases c</code> or something like that.</p>",
        "id": 202889174,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593892992
    },
    {
        "content": "<p>You can also try <code>casesm</code>. First you try refl, then <code>casesm color</code>, try refl again then try <code>casesm</code> on trees but without repetition</p>",
        "id": 202889225,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1593893067
    },
    {
        "content": "<p>the problem with that is that the type here is recursive, so you can end up splitting forever if you don't consult the definition</p>",
        "id": 202889241,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593893108
    },
    {
        "content": "<p>I kind of like the idea of finding occurrences of <code>rec_on</code> or <code>cases_on</code> and unfold them.</p>",
        "id": 202889308,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593893210
    },
    {
        "content": "<p>that should be fairly safe and make progress, because it shrinks the lambda.</p>",
        "id": 202889313,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593893225
    },
    {
        "content": "<p>I would like the <code>split_unfold</code> tactic to not split <code>rec</code> terms that were manually written (not part of the equation compiler splitting) though</p>",
        "id": 202889371,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593893307
    },
    {
        "content": "<p>no problem</p>",
        "id": 202889377,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593893341
    },
    {
        "content": "<p><code>id_rhs</code> is a special term added by the compiler.</p>",
        "id": 202889391,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593893353
    },
    {
        "content": "<p>so we should only split on them.</p>",
        "id": 202889393,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593893359
    },
    {
        "content": "<p>just an identity function for this very purpose; to drive case splits.</p>",
        "id": 202889405,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593893392
    },
    {
        "content": "<p>Looking at the term, it looks like <code>id_rhs</code> protects individual branches of the definition</p>",
        "id": 202889454,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593893442
    },
    {
        "content": "<p>I don't know if <code>dsimp</code> simplifies it</p>",
        "id": 202889457,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593893455
    },
    {
        "content": "<p>so that really means, to find the tree, we could probably do a tree walk over the expr, collecting <code>id_rhs</code></p>",
        "id": 202889464,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593893475
    },
    {
        "content": "<p>we don't need to dsimp at all, I don't think.</p>",
        "id": 202889483,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593893517
    },
    {
        "content": "<p>the <code>._main</code> is normalized after all.</p>",
        "id": 202889522,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593893536
    },
    {
        "content": "<p>so we could walk that definition directly to get the tree.</p>",
        "id": 202889525,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593893552
    },
    {
        "content": "<p>and <code>dsimp</code> seems to keep it in place btw.</p>",
        "id": 202889530,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593893581
    },
    {
        "content": "<p>I run <code>dsimp</code> at every step and still see it. It goes away once the <code>rec</code> and <code>cases_on</code> are invoked.</p>",
        "id": 202889546,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593893622
    },
    {
        "content": "<p>oh, that sounds more like it's not being touched because it is in a dependent position</p>",
        "id": 202889609,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593893681
    },
    {
        "content": "<p>so I finished the proof using this weird script above, it's very mechanical and super fast it checks in like 200ms.</p>",
        "id": 202889754,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593893907
    },
    {
        "content": "<p>Cool! Do you want to PR it?</p>",
        "id": 202890003,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1593894366
    },
    {
        "content": "<p>Well, I don't have a tactic for it. Just verified that this mechanical thing works.</p>",
        "id": 202890018,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593894432
    },
    {
        "content": "<p>At the moment, though each line still has a different identifier.</p>",
        "id": 202890021,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593894446
    },
    {
        "content": "<p>I wouldn't mind a bit of help with the tactic, but then, yes sure, I'll make a PR.</p>",
        "id": 202890022,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593894467
    },
    {
        "content": "<p>see if you can derive the name from the goal, so that your tactic is repeated verbatim n times</p>",
        "id": 202890082,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593894496
    },
    {
        "content": "<p>even if it's something hacky like ~ <code>last (get_app_args target)</code></p>",
        "id": 202890092,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593894534
    },
    {
        "content": "<p>yep, I think it's a lambda application each time.</p>",
        "id": 202890100,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593894552
    },
    {
        "content": "<p>so if I pattern match the expr, that should work.</p>",
        "id": 202890105,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593894563
    },
    {
        "content": "<p>Indeed</p>",
        "id": 202890179,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1593894646
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> consider using <code>app_arg</code> instead of <code>last (get_app_args _)</code>, it's faster and simpler</p>",
        "id": 202890278,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1593894801
    },
    {
        "content": "<p>The ~ is because that's totally made up</p>",
        "id": 202890325,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593894861
    },
    {
        "content": "<p>where's a handwavy emoji when you need one</p>",
        "id": 202890335,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593894914
    },
    {
        "content": "<p>hehe</p>",
        "id": 202890710,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593895625
    },
    {
        "content": "<p>horrible, unelegant, not pretty and all, but effective:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">meta</span> <span class=\"n\">def</span> <span class=\"n\">get_arg</span> <span class=\"o\">:</span> <span class=\"n\">expr</span> <span class=\"bp\">→</span> <span class=\"n\">tactic</span> <span class=\"n\">expr</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">expr</span><span class=\"bp\">.</span><span class=\"n\">app</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">pure</span> <span class=\"n\">y</span>\n<span class=\"bp\">|</span> <span class=\"bp\">_</span> <span class=\"o\">:=</span> <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">failed</span>\n\n<span class=\"n\">meta</span> <span class=\"n\">def</span> <span class=\"n\">split_unfold</span> <span class=\"o\">:=</span>\n<span class=\"n\">do</span>  <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"err\">%%</span><span class=\"n\">l</span> <span class=\"bp\">=</span> <span class=\"err\">%%</span><span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"err\">←</span> <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">target</span><span class=\"o\">,</span>\n    <span class=\"n\">head</span> <span class=\"err\">←</span> <span class=\"n\">get_arg</span> <span class=\"n\">l</span><span class=\"o\">,</span>\n    <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">cases</span> <span class=\"n\">head</span>\n\n\n\n<span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">b</span> <span class=\"n\">y</span> <span class=\"n\">c</span> <span class=\"n\">z</span> <span class=\"n\">d</span><span class=\"o\">,</span> <span class=\"n\">balance</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">black</span> <span class=\"o\">(</span><span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">red</span> <span class=\"o\">(</span><span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">red</span> <span class=\"n\">a</span> <span class=\"n\">x</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">y</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"n\">z</span> <span class=\"n\">d</span> <span class=\"bp\">=</span>\n    <span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">red</span> <span class=\"o\">(</span><span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">black</span> <span class=\"n\">a</span> <span class=\"n\">x</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">y</span> <span class=\"o\">(</span><span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">black</span> <span class=\"n\">c</span> <span class=\"n\">z</span> <span class=\"n\">d</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n    <span class=\"c1\">-- intros, refl, -- should work</span>\n    <span class=\"c1\">-- rintros a x b y (c|⟨cc|cc, cl, cv, cr⟩) z (d|⟨dc|dc, dl|⟨dlc|dlc, dll, dlv, dlr⟩, dv, dr|⟨drc|drc, drl, drv, drr⟩⟩),</span>\n    <span class=\"c1\">-- all_goals {refl}</span>\n    <span class=\"n\">intros</span><span class=\"o\">,</span>\n    <span class=\"n\">delta</span> <span class=\"n\">balance</span><span class=\"o\">,</span>\n    <span class=\"n\">dsimp</span><span class=\"o\">,</span>\n    <span class=\"n\">repeat</span> <span class=\"o\">{</span><span class=\"n\">split_unfold</span><span class=\"o\">,</span> <span class=\"n\">all_goals</span> <span class=\"o\">{</span><span class=\"n\">refl</span> <span class=\"bp\">&lt;|&gt;</span> <span class=\"n\">dsimp</span> <span class=\"bp\">&lt;|&gt;</span> <span class=\"n\">skip</span><span class=\"o\">}},</span>\n<span class=\"kn\">end</span>\n</code></pre></div>",
        "id": 202890842,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593895916
    },
    {
        "content": "<p><code>get_arg</code> should already exist</p>",
        "id": 202891025,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593896227
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/expr.app_arg/src\">src#expr.app_arg</a></p>",
        "id": 202891027,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593896238
    },
    {
        "content": "<p>the kind of experience, I'd want would be something like you have the normal local context, where balance is kept as a constant, nothing fancy.  Then you'd call <code>unfold_split balance with  lc ll lv lr</code>. It would do the <code>delta balance, dsimp</code> internally to find the next arg. Then throw away the state, and simply do the <code>split</code> on said identifier.</p>",
        "id": 202891071,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593896286
    },
    {
        "content": "<p>I was thinking that <code>split_unfold</code> would split as many times as necessary to apply <code>unfold balance</code> once in every subgoal</p>",
        "id": 202891098,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593896344
    },
    {
        "content": "<p>ya, could do that too.</p>",
        "id": 202891107,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593896390
    },
    {
        "content": "<p>then we need the full tree.</p>",
        "id": 202891151,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593896408
    },
    {
        "content": "<p>either way, it'd be nice, if we don't do the <code>delta</code> in the user-visible state.</p>",
        "id": 202891157,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593896423
    },
    {
        "content": "<p>yeah, it would do your <code>repeat {split_unfold, all_goals ...}</code> loop internally</p>",
        "id": 202891169,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593896436
    },
    {
        "content": "<p>yep.</p>",
        "id": 202891174,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593896448
    },
    {
        "content": "<p>actually, I don't think we should be unfolding the apps like this... The equational lemmas tell us exactly what cases are possible.</p>",
        "id": 202891909,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593897762
    },
    {
        "content": "<p>If we go and unfold apps wildly, we may end up unfolding inside of user code which is a bad idea.</p>",
        "id": 202891918,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593897786
    },
    {
        "content": "<p>so we should really use the definitional lemmas to infer the split tree. and then use the local context to decide which ones are missing</p>",
        "id": 202891927,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593897835
    },
    {
        "content": "<p>I'm pretty sure that's safer, don't you think?</p>",
        "id": 202891966,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593897848
    },
    {
        "content": "<p>I don't think using the equational lemmas is going to be easy. In comparison, doing case for the calls to rec in the user code should be a small enough issue. If you use <code>match</code> in your code, the tactic won't see the <code>rec</code> calls so you really have to invoke them directly. And when you do, you can have an option to say \"do one less than you otherwise would\"</p>",
        "id": 202892037,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1593898014
    },
    {
        "content": "<p>One thing you can use the equation tree for is check if you have done enough <code>cases</code>. If you can find an equation that matches your current state, you should stop going into more case analysis.</p>",
        "id": 202892091,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1593898090
    },
    {
        "content": "<p>ah, the argument being, that we FIRST unfold the arguments and only then things in the body.</p>",
        "id": 202892105,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593898145
    },
    {
        "content": "<p>so by noticing, we've done enough cases, we can use that as the exit criterion.</p>",
        "id": 202892112,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593898162
    },
    {
        "content": "<p>exactly</p>",
        "id": 202892121,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1593898181
    },
    {
        "content": "<p>in that case the raw delta unfolding is not really a problem, because we will consume the whole definition.</p>",
        "id": 202892185,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593898251
    },
    {
        "content": "<p>exactly</p>",
        "id": 202892205,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1593898316
    },
    {
        "content": "<p>I could see using <code>split_unfold balance</code> as one would use <code>cases</code>. We can tag the resulting goals and do a proof by case or do <code>split_unfold balance; finish</code> (with <code>finish</code> or other tactic)</p>",
        "id": 202892298,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1593898443
    },
    {
        "content": "<p>I don't think so.</p>",
        "id": 202892388,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593898642
    },
    {
        "content": "<p>In case you DO want to tag, <code>rcases</code> does the trick.</p>",
        "id": 202892393,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593898658
    },
    {
        "content": "<p><code>split_unfold</code> is specifically about not having to do that.</p>",
        "id": 202892396,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593898674
    },
    {
        "content": "<p><code>rcases</code> already does the cartesian explosion for you.</p>",
        "id": 202892436,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593898692
    },
    {
        "content": "<p>but I really can't see how you can use inference and have to provide explicit identifiers at the same time.</p>",
        "id": 202892464,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593898791
    },
    {
        "content": "<p>Right but it does it with a pattern that you provide it. <code>split_unfold</code> detects that pattern. If you don't want to do the proof by case you don't have to. If you do, it's easy to enable</p>",
        "id": 202892513,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1593898834
    },
    {
        "content": "<p>But what would be the identifiers you provide?</p>",
        "id": 202892528,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593898889
    },
    {
        "content": "<p>There's a pattern that you can follow:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">cases</span> <span class=\"n\">xs</span><span class=\"o\">,</span>\n<span class=\"n\">case</span> <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">nil</span> <span class=\"o\">:</span>\n<span class=\"o\">{</span> <span class=\"c\">/-</span><span class=\"cm\"> proof when xs is nil -/</span> <span class=\"o\">},</span>\n<span class=\"n\">case</span> <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"n\">xs</span>\n<span class=\"o\">{</span> <span class=\"c\">/-</span><span class=\"cm\"> proof when xs is cons -/</span> <span class=\"o\">},</span>\n</code></pre></div>\n\n\n<p>That's actually what I refer to as \"tagging the goals\"</p>",
        "id": 202892532,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1593898895
    },
    {
        "content": "<p>AH, that you mean.</p>",
        "id": 202892535,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593898907
    },
    {
        "content": "<p>i thought you meant naming the locals.</p>",
        "id": 202892540,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593898917
    },
    {
        "content": "<p>No, like you say, for that <code>rcases</code> does a good job already.</p>",
        "id": 202892588,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1593898940
    },
    {
        "content": "<p>I'm really excited now, once we have this as a tactic, proving large cases will be much nicer :D</p>",
        "id": 202892605,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593898986
    },
    {
        "content": "<p>:) me too</p>",
        "id": 202892659,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1593899046
    },
    {
        "content": "<p>Have you considered what you want to do if <code>balance</code> occurs more than once in the goal?</p>",
        "id": 202895895,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1593905520
    },
    {
        "content": "<p>Ya, I'm just walking around the house thinking about it.</p>",
        "id": 202896026,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593905757
    },
    {
        "content": "<p>Let alone under quantifiers.</p>",
        "id": 202896068,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593905773
    },
    {
        "content": "<p>I'm tempted to change the interface a bit</p>",
        "id": 202896073,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593905782
    },
    {
        "content": "<p>how about you'd <code>unfold_split balance color.black (node.tree col left v right)</code>...</p>",
        "id": 202896089,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593905827
    },
    {
        "content": "<p>I.e. rather than trying to do the cartesian explosion that'd be needed for fully solving the problem for multiple occurrences, we'd ask the user to give us an expression</p>",
        "id": 202896096,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593905871
    },
    {
        "content": "<p>and we'd unfold to the point where the definition goes away in that case.</p>",
        "id": 202896139,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593905885
    },
    {
        "content": "<p>That's one way. You could also make up an attribute to tag <code>balance</code> with and generate an inductive relation for it, to encode the graph of the function. If I simplify, for definition <code>f</code>, you'd have the property that <code>f x = y &lt;-&gt; r x y</code></p>",
        "id": 202896337,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1593906345
    },
    {
        "content": "<p>Then, if you try to prove <code>P (f x)</code>, you can replace it with <code>∀ y, r x y -&gt; P y</code> and then doing <code>cases</code> on the <code>r x y</code> gives you all the cases that you care about</p>",
        "id": 202896400,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1593906473
    },
    {
        "content": "<p>Ah, so rather than doing induction on <code>x</code>, we'd do induction over <code>r</code>, yes?</p>",
        "id": 202896441,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593906498
    },
    {
        "content": "<p>that's right</p>",
        "id": 202896445,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1593906523
    },
    {
        "content": "<p>ya, that looks really neat, actually.</p>",
        "id": 202896452,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593906537
    },
    {
        "content": "<p>So how could I have the compiler spit out the definitions?</p>",
        "id": 202896460,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593906556
    },
    {
        "content": "<p>Go in <code>tactic.ext</code>, you'll see that, when you apply <code>ext</code> to a structure definition, it generates theorems. In your case, instead, you'd generate an inductive type</p>",
        "id": 202896513,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1593906663
    },
    {
        "content": "<p>Ok, I'll look, thx</p>",
        "id": 202896522,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593906700
    },
    {
        "content": "<p>do I understand correctly that the <code>ext</code> attribute is only used inside of a call to the <code>ext</code> tactic and gets created on the fly? Or is there somehow a separate code-gen phase (didn't read the code in detail yet)</p>",
        "id": 202896738,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593907169
    },
    {
        "content": "<p>oh, I see. It's the <code>after_set</code> of the <code>user_attribute</code> that generates the code.</p>",
        "id": 202896842,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593907325
    },
    {
        "content": "<p>That's right. You tag your structures and lemmas with <code>ext</code>. For structures, it creates an extensionality lemma and puts the <code>ext</code> attribute on it. For lemmas, it just puts them in a table of extensionality lemmas indexed by the type they apply to</p>",
        "id": 202896937,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1593907548
    },
    {
        "content": "<p>The <code>ext</code> tactic reads that table and selects the right lemmas when needed</p>",
        "id": 202896978,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1593907570
    },
    {
        "content": "<p>wahoo, I can now generate a relation :). It's a dumb one, just added the identity function, but my attribute works :D</p>",
        "id": 202897769,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593909307
    },
    {
        "content": "<p>I think the idea of generating additional lemma or the graph run into the same kind of problem. By the time we get access to the expr that corresponds to the definition of the function, the pattern match is lost. So we again have to reconstruct the decision procedure from the lambda. And the decision procedure is NOT what is written in the matter match, in fact that's the reason why <code>refl</code> doesn't work.</p>",
        "id": 202903589,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593921109
    },
    {
        "content": "<p>The usefulness of that lemma is not to do away with the machinery that we discussed but to separate two parts of the problem. When generating the lemmas, you have a simple, controlled proof state. That makes the case distinction logic less susceptible to breaking. When we use them, the proof state maybe be less clean but the lemmas should present a nice interface</p>",
        "id": 202904197,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1593922288
    },
    {
        "content": "<p>yes, that makes a lot of sense</p>",
        "id": 202904249,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593922392
    },
    {
        "content": "<p>and I think I might a way how to reconstruct the \"pattern match\" cases from the lemmas.</p>",
        "id": 202904252,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593922414
    },
    {
        "content": "<p>In one of my projects I designed a data structure that creates a set based on cartesian products, as in it detects when a particular subset is a cartesian product.</p>",
        "id": 202904292,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593922474
    },
    {
        "content": "<p>this mechanism could be used to figure out what combinations of equations form a subset, that is a cartesian product</p>",
        "id": 202904300,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593922526
    },
    {
        "content": "<p>and then when it is a cartesian product, you can universally quantify instead of the distinction by cases.</p>",
        "id": 202904342,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593922564
    },
    {
        "content": "<p>From the lemmas, I think that should be more straightforward than that.</p>",
        "id": 202904344,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1593922565
    },
    {
        "content": "<blockquote>\n<p>Then, if you try to prove P (f x), you can replace it with ∀ y, r x y -&gt; P y and then doing cases on the r x y gives you all the cases that you care about</p>\n</blockquote>",
        "id": 202904350,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1593922612
    },
    {
        "content": "<p>when you have <code>h : r x y</code>, doing <code>cases h</code> should give you the perfect case distinction</p>",
        "id": 202904353,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1593922645
    },
    {
        "content": "<p>right, but what's the structure of <code>r</code>? just a single inductive with 122 cases?</p>",
        "id": 202904394,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593922723
    },
    {
        "content": "<p>I thought we would want it to be compactified.</p>",
        "id": 202904400,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593922750
    },
    {
        "content": "<p>You can put that in a derived lemma of the shape:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">elab_as_eliminator</span><span class=\"o\">]</span>\n<span class=\"kn\">lemma</span> <span class=\"n\">balance_rec</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">P</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span>\n</code></pre></div>",
        "id": 202904401,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1593922757
    },
    {
        "content": "<p>No, <code>r</code> would just have the few equations that you care about</p>",
        "id": 202904424,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1593922794
    },
    {
        "content": "<p>exactly, but the difficulty is to generate <code>r</code> from the definition.</p>",
        "id": 202904465,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593922823
    },
    {
        "content": "<p>Or were you thinking to hand-write <code>r</code>?</p>",
        "id": 202904466,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593922834
    },
    {
        "content": "<p>No, I see that I overlooked a difficulty, you're right</p>",
        "id": 202904470,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1593922859
    },
    {
        "content": "<p>it boils down to finding a way how to compress the number of cases.</p>",
        "id": 202904478,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593922885
    },
    {
        "content": "<p>You'd still need to filter the cases.</p>",
        "id": 202904479,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1593922886
    },
    {
        "content": "<p>once we have that, the equation lemmas are fine</p>",
        "id": 202904481,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593922897
    },
    {
        "content": "<p>in fact <code>=</code> is just such a relation after all</p>",
        "id": 202904484,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593922907
    },
    {
        "content": "<p>That's true (on both accounts)</p>",
        "id": 202904522,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1593922924
    },
    {
        "content": "<p>When generating the relation, we can take care of the case filtering there</p>",
        "id": 202904524,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1593922945
    },
    {
        "content": "<p>right. Or we can generate some augmented helper cases for the equation lemmas.</p>",
        "id": 202904530,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593922983
    },
    {
        "content": "<p>something like <code>case_1</code>.</p>",
        "id": 202904532,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593922994
    },
    {
        "content": "<p>then you'd <code>apply case_1</code>.</p>",
        "id": 202904533,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593923003
    },
    {
        "content": "<p>and it's pretty much exactly your <code>forall y, r x y -&gt; P y</code></p>",
        "id": 202904539,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593923028
    },
    {
        "content": "<p>I'd have to see it to judge</p>",
        "id": 202904541,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1593923039
    },
    {
        "content": "<p>first I'd need this mechanism of finding what case splits were unnecessary.</p>",
        "id": 202904582,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593923079
    },
    {
        "content": "<p>If you had access to the specification, that would be easier. Maybe we can add that to Lean's API</p>",
        "id": 202904588,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1593923125
    },
    {
        "content": "<p>ya, having the spec would be a lot better, indeed.</p>",
        "id": 202904590,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593923144
    },
    {
        "content": "<p>plus it'd give a canonical way for building <code>r</code>.</p>",
        "id": 202904628,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593923167
    },
    {
        "content": "<p>And we could make <code>r</code> even better like this:</p>",
        "id": 202904630,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593923187
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">inductive</span> <span class=\"n\">r</span>\n<span class=\"bp\">|</span> <span class=\"n\">case_1</span> <span class=\"o\">:</span> <span class=\"n\">T</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">r</span>\n<span class=\"bp\">|</span> <span class=\"n\">case_2</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"n\">T</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">U</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">r</span>\n<span class=\"bp\">|</span> <span class=\"n\">case_3</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"n\">T</span> <span class=\"bp\">-&gt;</span> <span class=\"bp\">¬</span><span class=\"n\">U</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">V</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">r</span>\n</code></pre></div>",
        "id": 202904645,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593923278
    },
    {
        "content": "<p>this kind of thing could make proofs potentially easier in some cases.</p>",
        "id": 202904683,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593923295
    },
    {
        "content": "<p>who parses the spec, btw? Is that written in c++ or lean?</p>",
        "id": 202904693,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593923365
    },
    {
        "content": "<p>That's written in C++. That part of the code is fresh in my mind. I've been playing with the equation compiler in the last couple of months. It might be good to see if we can make the feature without this addition though</p>",
        "id": 202904800,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1593923637
    },
    {
        "content": "<p>I could port my product set, potentially.</p>",
        "id": 202904980,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593923998
    },
    {
        "content": "<p>That thing would at least figure out what pairs of variables form cartesian products.</p>",
        "id": 202905030,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593924027
    },
    {
        "content": "<p>or maybe at least the core of that inference.</p>",
        "id": 202905034,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593924039
    },
    {
        "content": "<p>The rule is, that a union of two cartesian products is a cartesian product iff all but one dimensions agree.</p>",
        "id": 202905048,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593924103
    },
    {
        "content": "<p>so if each variable is a dimension, and each constructor a point, then you can think of each case as a bunch of points in an n-dimensional space.</p>",
        "id": 202905096,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593924154
    },
    {
        "content": "<p>and this inference allows you to merge things into bigger and bigger \"blocks\" which translates into more and more coarse patterns.</p>",
        "id": 202905107,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593924192
    },
    {
        "content": "<p>That could be useful. You might want to start with more basic stuff and build up to it</p>",
        "id": 202905259,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1593924482
    },
    {
        "content": "<p>Well, the product set is really just that. A representation of a set. But unlike a hash set or a binary search tree, is has a notion of dense and sparse and uses this to compress the representation.</p>",
        "id": 202905363,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593924637
    },
    {
        "content": "<p>you could think of it a bit like n-dimensional run-length encoding.</p>",
        "id": 202905369,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593924660
    },
    {
        "content": "<p>but it can be used for this kind of task where you need to figure out if you are \"dense\" over a region. In fact that was the very purpose we built it in the other project.</p>",
        "id": 202905382,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593924712
    },
    {
        "content": "<p>As for making a simpler cases, I really know what, to be honest.</p>",
        "id": 202905435,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593924755
    },
    {
        "content": "<p>My experience with lean is overall really, really nice.</p>",
        "id": 202905438,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593924768
    },
    {
        "content": "<p>It's just that it completely falls apart in case of these large-number case-splits.</p>",
        "id": 202905443,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593924791
    },
    {
        "content": "<p>So working on fixing that is extremely enticing, tbh.</p>",
        "id": 202905455,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593924816
    },
    {
        "content": "<p>Excellent :) It sounds like we'll get some nice automation to work with</p>",
        "id": 202905503,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1593924855
    },
    {
        "content": "<p>let me port the product set then. It's gonna take me a few days, but it's a purely functional persistent datastructure.</p>",
        "id": 202905518,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593924902
    },
    {
        "content": "<p>so it shouldn't be too bad.</p>",
        "id": 202905525,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593924910
    },
    {
        "content": "<p>For a more verification condition style of verification (a la F*), I built something that could be considered a further extension. It creates lemma stubs for you</p>",
        "id": 202905526,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1593924915
    },
    {
        "content": "<p>My original version is in typescript. So lean should have no trouble representing it.</p>",
        "id": 202905532,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593924946
    },
    {
        "content": "<p>and I was actually making a point to design it very flexibly. Thinking as inductive branches as exactly the kind of thing we might want.</p>",
        "id": 202905575,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593924986
    },
    {
        "content": "<p>Cool</p>",
        "id": 202905587,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1593925031
    },
    {
        "content": "<p>I'll be in touch ;-)</p>",
        "id": 202905594,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593925053
    },
    {
        "content": "<p>Please do</p>",
        "id": 202905641,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1593925109
    },
    {
        "content": "<p>I actually have a formal proof of the cartesian product properties in lean (was an exercise when I was learning)</p>",
        "id": 202905642,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593925113
    },
    {
        "content": "<p>I've got the first layer coded up. This is the bsp set. The idea is, that you provide a way of breaking the space into disjoint regions (however you want, e.g. one constructor at a time, or something like that). And then the bsp set lets you do efficient set operations like union, intersection, set difference and complement.</p>",
        "id": 202945851,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593997538
    },
    {
        "content": "<p><a href=\"https://gist.github.com/DanielFabian/9e1013582f7ce6e5563f204708a82e5d\">https://gist.github.com/DanielFabian/9e1013582f7ce6e5563f204708a82e5d</a></p>",
        "id": 202945852,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593997541
    },
    {
        "content": "<p>the next layer would be the product set. That's a multidimensional thing that lets us find these regions that form cartesian products. and they'd allow us to find an efficient handling of all the cases.</p>",
        "id": 202945900,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593997616
    },
    {
        "content": "<p>One challenge I see, though, is that even once we have these regions, unification of types is not really straightforward...</p>",
        "id": 202945908,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593997654
    },
    {
        "content": "<p>consider a case like this:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">left</span> <span class=\"o\">:</span> <span class=\"n\">sparse_node</span><span class=\"o\">),</span> <span class=\"n\">combine_children</span> <span class=\"o\">(</span><span class=\"n\">sparse</span> <span class=\"n\">left</span><span class=\"o\">)</span> <span class=\"n\">empty</span> <span class=\"bp\">=</span> <span class=\"n\">sparse</span> <span class=\"o\">(</span><span class=\"n\">left</span><span class=\"bp\">.</span><span class=\"n\">left_sparse</span> <span class=\"n\">empty</span><span class=\"o\">)</span>\n<span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">left</span> <span class=\"o\">:</span> <span class=\"n\">sparse_node</span><span class=\"o\">),</span> <span class=\"n\">combine_children</span> <span class=\"o\">(</span><span class=\"n\">sparse</span> <span class=\"n\">left</span><span class=\"o\">)</span> <span class=\"n\">dense</span> <span class=\"bp\">=</span> <span class=\"n\">sparse</span> <span class=\"o\">(</span><span class=\"n\">left</span><span class=\"bp\">.</span><span class=\"n\">left_sparse</span> <span class=\"n\">dense</span><span class=\"o\">)</span>\n<span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">left</span> <span class=\"n\">root</span> <span class=\"o\">:</span> <span class=\"n\">sparse_node</span><span class=\"o\">),</span> <span class=\"n\">combine_children</span> <span class=\"o\">(</span><span class=\"n\">sparse</span> <span class=\"n\">left</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">sparse</span> <span class=\"n\">root</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">sparse</span> <span class=\"o\">(</span><span class=\"n\">left</span><span class=\"bp\">.</span><span class=\"n\">left_sparse</span> <span class=\"o\">(</span><span class=\"n\">sparse</span> <span class=\"n\">root</span><span class=\"o\">))</span>\n</code></pre></div>\n\n\n<p>these three right-hand sides are supposed to be the same, modulo the case split <code>empty | dense | sparse root</code>. And we have to somehow reconstruct that based solely on the right-hand sides. But the problem is that the right-hand sides have all cases mixed together, so if there were multiple occurrences of <code>empty</code>, say, how would we know which one to turn into the forall case?</p>",
        "id": 202946096,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593997925
    },
    {
        "content": "<p>this here, again suggests that we might be better off having access to the spec, somehow.</p>",
        "id": 202946116,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593998012
    },
    {
        "content": "<p>I think this should not be your first focus. Using a more naive data structure first should help you understand the API better . It might even be that a naive data structure could provide sufficient performances. The size of the data structures is often not very big.</p>",
        "id": 202946651,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1593999011
    },
    {
        "content": "<p>One problem I see, is that the API I saw (expressions, declarations, theorems, etc.) are all essentially just lambda expressions.</p>",
        "id": 202946722,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593999159
    },
    {
        "content": "<p>but the high-level intent is lost.</p>",
        "id": 202946728,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593999171
    },
    {
        "content": "<p>It's almost like trying to reconstruct the meaning of a program from assembly</p>",
        "id": 202946736,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593999190
    },
    {
        "content": "<p>You'd be surprised how much can be done with nothing but terms. That's because you can restrict the shape of the terms that you consider</p>",
        "id": 202946847,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1593999372
    },
    {
        "content": "<p>I do see that <code>cases_on</code> could be potentially used to reconstruct pattern matches.</p>",
        "id": 202946920,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593999561
    },
    {
        "content": "<p>With <code>cases_on</code> or <code>rec_on</code>, you can verify that it's a recursor, you can check how many parameters and indices the type has and then select which argument is the subject</p>",
        "id": 202946985,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1593999661
    },
    {
        "content": "<p>sure, we get the arity from <code>cases_on</code></p>",
        "id": 202947037,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593999730
    },
    {
        "content": "<p>so that's the destructed things in the pattern match.</p>",
        "id": 202947040,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593999747
    },
    {
        "content": "<p>but how do you unify the resulting terms?</p>",
        "id": 202947046,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593999762
    },
    {
        "content": "<p>when they are clearly not the same.</p>",
        "id": 202947049,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593999771
    },
    {
        "content": "<p>even the most trivial case is not quite straight-forward: <code>fun x, x</code> for natural numbers could be something like <code>nat.cases_on zero (fun x, succ x)</code></p>",
        "id": 202947119,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593999866
    },
    {
        "content": "<p>Consider this type of <code>sum.cases_on : Π α β (C : sum α β → Sort u), sum α β → (Π x, C (sum.inl x)) → (Π x, C (sum.inr x)) : Π x : sum α β, C x</code>, you see that the first three arguments are not the branches and not the subject. That's why you need to use the API to get more meta information</p>",
        "id": 202947139,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1593999911
    },
    {
        "content": "<p>Do you have a concrete example of where the problem shows up?</p>",
        "id": 202947144,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1593999941
    },
    {
        "content": "<p>ya, sure. e.g. the generated functions for my own pattern match functions I wrote for the bsp set.</p>",
        "id": 202947205,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594000022
    },
    {
        "content": "<p>the three quoted lines above.</p>",
        "id": 202947209,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594000031
    },
    {
        "content": "<p>they all correspond to <code>sparse x</code></p>",
        "id": 202947217,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594000044
    },
    {
        "content": "<p>or were you talking about the fact, that not all arguments show up?</p>",
        "id": 202947297,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594000158
    },
    {
        "content": "<p>That's what I was referring to.</p>",
        "id": 202947306,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1594000190
    },
    {
        "content": "<p>For sparse node, is it supposed to be an example or is it a data structure for the tactic?</p>",
        "id": 202947358,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1594000229
    },
    {
        "content": "<p>Well, I ported the data structure, but the example is really showing the kind of thing, I don't really know how to address.</p>",
        "id": 202947379,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594000294
    },
    {
        "content": "<p>Pretty much all pattern-match defined functions have these equation lemmas.</p>",
        "id": 202947382,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594000311
    },
    {
        "content": "<p>and their rhs would very often be the same, module case split.</p>",
        "id": 202947423,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594000327
    },
    {
        "content": "<p>and the tactic we want is meant to somehow unify the cases that are same.</p>",
        "id": 202947426,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594000346
    },
    {
        "content": "<p>because that's how you get the number of cases down to the number of lines in the pattern match.</p>",
        "id": 202947432,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594000363
    },
    {
        "content": "<p>after all the RB-tree example has something like 5 cases in the source code, but 122 equations.</p>",
        "id": 202947438,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594000384
    },
    {
        "content": "<p>that means you have somthing like 30 equations each all coming from the same exact term in the source code.</p>",
        "id": 202947444,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594000410
    },
    {
        "content": "<p>I.e. they are identical modulo the case split.</p>",
        "id": 202947449,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594000419
    },
    {
        "content": "<p>but the substitution of terms is not an injective operation.</p>",
        "id": 202947499,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594000484
    },
    {
        "content": "<p>for now I haven't even tried doing more complicated cases like dependent pattern matching or recursion, just the simplest possible cases of straight, non-recursive, non-dependent pattern matching.</p>",
        "id": 202947562,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594000595
    },
    {
        "content": "<p>Ok so the plan so far is:</p>\n<ol>\n<li>generate an inductive relation</li>\n<li>generate the equivalence lemma</li>\n<li>automate the application of the lemma.</li>\n</ol>\n<p>Where would your issue become relevant?</p>",
        "id": 202947791,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1594000976
    },
    {
        "content": "<p>before step one. In order to create a relation that's somehow better than the 122 cases, we need a way to find out what cases are the same modulo the case split. And it is on those far fewer cases that we would want to create the inductive definition.</p>",
        "id": 202947892,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594001105
    },
    {
        "content": "<p>but since I don't know the spec, the best I can do is try and reconstruct the spec from the already existing equation lemmas.</p>",
        "id": 202947908,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594001159
    },
    {
        "content": "<p>on the bright side, the equation lemmas have a standard from: <code>forall x, f x = y</code>.</p>",
        "id": 202947957,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594001212
    },
    {
        "content": "<p>but then they get split into the various cases that the compiler happened to have generated.</p>",
        "id": 202947964,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594001231
    },
    {
        "content": "<p>so when there's a case split on <code>x</code>, then in <code>y</code> there'd be the substition from <code>x</code> to just the one constructor of the inductive type.</p>",
        "id": 202947973,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594001281
    },
    {
        "content": "<p>so now you get something like this:</p>",
        "id": 202948015,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594001297
    },
    {
        "content": "<p>Ok, yes now I see</p>",
        "id": 202948016,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1594001301
    },
    {
        "content": "<p><code>def id x := x</code> for nat turns into <code>id zero = zero</code> and <code>forall n, id (succ n) = succ n</code>.</p>",
        "id": 202948022,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594001327
    },
    {
        "content": "<p>and it's really not straight-forward how to unify this.</p>",
        "id": 202948027,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594001340
    },
    {
        "content": "<p>Let's say you have two branches:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"n\">c</span> <span class=\"n\">d</span><span class=\"o\">)</span> <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"n\">E0</span>\n<span class=\"n\">foo</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">D</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"n\">E1</span>\n</code></pre></div>\n\n\n<p>You start by comparing the patterns. The first argument is not broken up then same so you abstract it. You get:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">foo</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"n\">c</span> <span class=\"n\">d</span><span class=\"o\">)</span> <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"n\">E0</span> <span class=\"o\">[</span><span class=\"n\">C</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">x</span><span class=\"o\">]</span>\n<span class=\"n\">foo</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">D</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"n\">E1</span>\n</code></pre></div>\n\n\n<p>And you continue until all the patterns are the same, introducing fresh variables when necessary. </p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">foo</span> <span class=\"n\">x</span> <span class=\"n\">v</span> <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"n\">E0</span> <span class=\"o\">[</span><span class=\"n\">C</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">x</span><span class=\"o\">][</span><span class=\"n\">E</span> <span class=\"n\">c</span> <span class=\"n\">d</span> <span class=\"o\">:=</span> <span class=\"n\">v</span><span class=\"o\">]</span>\n<span class=\"n\">foo</span> <span class=\"n\">x</span> <span class=\"n\">v</span> <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"n\">E1</span><span class=\"o\">[</span><span class=\"n\">D</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">v</span><span class=\"o\">]</span>\n</code></pre></div>\n\n\n<p>Then you can compare the rhs. They should be syntactically equal. Definitionally equal should suffice though.</p>",
        "id": 202948174,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1594001626
    },
    {
        "content": "<p>what if <code>C a b</code> occurs multiple times?</p>",
        "id": 202948318,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594001808
    },
    {
        "content": "<p>I think if we have multiple occurrences we may end up with a term that's syntactically different from the original one, but at least it probably would be def equal.</p>",
        "id": 202948476,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594002043
    },
    {
        "content": "<p>The variables <code>a</code> and <code>b</code> will be distinct because they all can occur only once</p>",
        "id": 202948510,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1594002123
    },
    {
        "content": "<p>(in the syntax of a pattern)</p>",
        "id": 202948541,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1594002138
    },
    {
        "content": "<p>I mean something like this: <code>def two_times_plus_one x := 1 + x + x</code>. so we get <code>two_times_plus_one zero = succ zero + succ zero + succ zero</code> and <code>forall n, two_times_plus_one (succ n) = succ zero + succ n + succ n</code></p>",
        "id": 202948628,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594002323
    },
    {
        "content": "<p>how do we tell it's actually the same case?</p>",
        "id": 202948631,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594002340
    },
    {
        "content": "<p>I totally can see your procedure work nicely left to right.</p>",
        "id": 202948684,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594002412
    },
    {
        "content": "<p>I think it would work. If you find an occurrence of <code>succ n</code>, you know you must substitute it because <code>n</code> is a bound variable issue from the pattern <code>succ n</code>. That's the only way it can be introduced. We should even go further and, once <code>succ n</code> has been replaced, we should check that <code>n</code> is not still free in the right hand side</p>",
        "id": 202948904,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1594002797
    },
    {
        "content": "<p>in the second case, we'd introduce <code>1 + u + u</code> (u being fresh). In the first case, we'd do <code>v + v + v</code>. Then we need to use show that <code>forall n, u = succ n -&gt; 1 + u + u</code> and <code>v = zero, v + v + v </code> implies <code>forall k, 1 + k + k</code>.</p>",
        "id": 202949180,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594003262
    },
    {
        "content": "<p>You traverse the pattern two at a time so when you introduce a fresh variable in one, it gets introduced in the second as well. But if we didn't traverse them two by two, we could use de Bruijn variables to encode fresh variables. That way, we they are syntactically equal if they have to match</p>",
        "id": 202949285,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1594003457
    },
    {
        "content": "<p>ok, I'll give it a go.  I think I understand the idea now.</p>",
        "id": 202949375,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594003602
    },
    {
        "content": "<p>Cool. Looking forward to seeing how it turns out</p>",
        "id": 202949642,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1594004133
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">type</span> <span class=\"n\">mismatch</span> <span class=\"n\">at</span> <span class=\"n\">application</span>\n  <span class=\"bp\">_</span><span class=\"n\">eqn_1</span>\n<span class=\"n\">term</span>\n  <span class=\"n\">α</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"kt\">Type</span> <span class=\"n\">u_1</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">u_1</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"n\">Sort</span> <span class=\"n\">u_1</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span>\n<span class=\"n\">state</span><span class=\"o\">:</span>\n<span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">,</span>\n<span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">node</span> <span class=\"n\">α</span><span class=\"o\">,</span>\n<span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span>\n<span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">node</span> <span class=\"n\">α</span><span class=\"o\">,</span>\n<span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span>\n<span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">node</span> <span class=\"n\">α</span><span class=\"o\">,</span>\n<span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span>\n<span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">node</span> <span class=\"n\">α</span><span class=\"o\">,</span>\n<span class=\"bp\">_</span><span class=\"n\">eqn_6</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">Sort</span> <span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">left</span> <span class=\"o\">:</span> <span class=\"n\">node</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">val</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">right</span> <span class=\"o\">:</span> <span class=\"n\">node</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">node</span> <span class=\"n\">α</span><span class=\"o\">),</span>\n    <span class=\"n\">balance</span><span class=\"bp\">._</span><span class=\"n\">main</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">black</span> <span class=\"o\">(</span><span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">black</span> <span class=\"n\">left</span> <span class=\"n\">val</span> <span class=\"n\">right</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"n\">b</span> <span class=\"bp\">=</span>\n      <span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">black</span> <span class=\"o\">(</span><span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">black</span> <span class=\"n\">left</span> <span class=\"n\">val</span> <span class=\"n\">right</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"n\">b</span><span class=\"o\">,</span>\n<span class=\"bp\">_</span><span class=\"n\">eqn_5</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">Sort</span> <span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">left</span> <span class=\"o\">:</span> <span class=\"n\">node</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">val</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">right</span> <span class=\"o\">:</span> <span class=\"n\">node</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">val_1</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">right_1</span> <span class=\"o\">:</span> <span class=\"n\">node</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">node</span> <span class=\"n\">α</span><span class=\"o\">),</span>\n    <span class=\"n\">balance</span><span class=\"bp\">._</span><span class=\"n\">main</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">black</span> <span class=\"o\">(</span><span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">red</span> <span class=\"o\">(</span><span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">black</span> <span class=\"n\">left</span> <span class=\"n\">val</span> <span class=\"n\">right</span><span class=\"o\">)</span> <span class=\"n\">val_1</span> <span class=\"n\">right_1</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"n\">b</span> <span class=\"bp\">=</span>\n      <span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">black</span> <span class=\"o\">(</span><span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">red</span> <span class=\"o\">(</span><span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">black</span> <span class=\"n\">left</span> <span class=\"n\">val</span> <span class=\"n\">right</span><span class=\"o\">)</span> <span class=\"n\">val_1</span> <span class=\"n\">right_1</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"n\">b</span><span class=\"o\">,</span>\n<span class=\"bp\">_</span><span class=\"n\">eqn_4</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">Sort</span> <span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">node</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">node</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">node</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">node</span> <span class=\"n\">α</span><span class=\"o\">),</span>\n    <span class=\"n\">balance</span><span class=\"bp\">._</span><span class=\"n\">main</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">black</span> <span class=\"o\">(</span><span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">red</span> <span class=\"o\">(</span><span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">red</span> <span class=\"n\">a</span> <span class=\"n\">x</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">y</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"n\">z</span> <span class=\"n\">d</span> <span class=\"bp\">=</span>\n      <span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">red</span> <span class=\"o\">(</span><span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">black</span> <span class=\"n\">a</span> <span class=\"n\">x</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">y</span> <span class=\"o\">(</span><span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">black</span> <span class=\"n\">c</span> <span class=\"n\">z</span> <span class=\"n\">d</span><span class=\"o\">),</span>\n<span class=\"bp\">_</span><span class=\"n\">eqn_3</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">Sort</span> <span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">val</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">right</span> <span class=\"o\">:</span> <span class=\"n\">node</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">node</span> <span class=\"n\">α</span><span class=\"o\">),</span>\n    <span class=\"n\">balance</span><span class=\"bp\">._</span><span class=\"n\">main</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">black</span> <span class=\"o\">(</span><span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">red</span> <span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">leaf</span> <span class=\"n\">val</span> <span class=\"n\">right</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"n\">b</span> <span class=\"bp\">=</span>\n      <span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">black</span> <span class=\"o\">(</span><span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">red</span> <span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">leaf</span> <span class=\"n\">val</span> <span class=\"n\">right</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"n\">b</span><span class=\"o\">,</span>\n<span class=\"bp\">_</span><span class=\"n\">eqn_2</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">Sort</span> <span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">node</span> <span class=\"n\">α</span><span class=\"o\">),</span>\n    <span class=\"n\">balance</span><span class=\"bp\">._</span><span class=\"n\">main</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">black</span> <span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">leaf</span> <span class=\"n\">x</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">black</span> <span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">leaf</span> <span class=\"n\">x</span> <span class=\"n\">b</span><span class=\"o\">,</span>\n<span class=\"bp\">_</span><span class=\"n\">eqn_1</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">Sort</span> <span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">node</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">node</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">balance</span><span class=\"bp\">._</span><span class=\"n\">main</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">red</span> <span class=\"n\">a</span> <span class=\"n\">x</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">red</span> <span class=\"n\">a</span> <span class=\"n\">x</span> <span class=\"n\">b</span>\n<span class=\"err\">⊢</span> <span class=\"n\">balance</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">black</span> <span class=\"o\">(</span><span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">red</span> <span class=\"o\">(</span><span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">red</span> <span class=\"n\">a</span> <span class=\"n\">x</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">y</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"n\">z</span> <span class=\"n\">d</span> <span class=\"bp\">=</span>\n    <span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">red</span> <span class=\"o\">(</span><span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">black</span> <span class=\"n\">a</span> <span class=\"n\">x</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">y</span> <span class=\"o\">(</span><span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">black</span> <span class=\"n\">c</span> <span class=\"n\">z</span> <span class=\"n\">d</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 203033036,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594065210
    },
    {
        "content": "<p>I've got a first thing, that just pulls in the lemmas into the current context, but I can't really manipulate it.</p>",
        "id": 203033105,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594065243
    },
    {
        "content": "<p>Apprently I've got a mess with the universe levels, in particular I can not <code>specialize</code> by <code>alpha</code>.</p>",
        "id": 203033149,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594065287
    },
    {
        "content": "<p>And because they are implicit args in the declaration, I don't know how to apply it in the tactic, I tried</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"bp\">``</span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"err\">%%</span><span class=\"n\">body</span> <span class=\"n\">alpha</span><span class=\"o\">)</span>\n<span class=\"bp\">``</span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"o\">(</span><span class=\"err\">%%</span><span class=\"n\">body</span><span class=\"o\">)</span> <span class=\"n\">alpha</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 203033345,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594065393
    },
    {
        "content": "<p>alternatively, if I skip the implicits and instead try to pass a <code>node alpha</code>, then it doesn't see meta vars. Presumably, because it expects the quantified type to live in a lower universe?</p>",
        "id": 203033493,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594065482
    },
    {
        "content": "<p>Ok, I've managed to apply the type argument, but looks like it still isn't working. It just moved the universe level problem one level in. I think the root cause is, that the term <code>alpha</code> is a value in the next universe. But I need the sort, how do you do that?</p>",
        "id": 203035929,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594066744
    },
    {
        "content": "<p>Ok, <code>Type u</code> is the same as <code>Sort (u+1)</code>. When you add <code>_eqn_n</code>, you can specify which universe you want to put them in. How do you create them?</p>",
        "id": 203045364,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1594072519
    },
    {
        "content": "<p>I do this:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">meta</span> <span class=\"n\">def</span> <span class=\"n\">my_tac</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">parse</span> <span class=\"n\">ident</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">unit</span> <span class=\"o\">:=</span>\n<span class=\"n\">do</span>  <span class=\"n\">lemmas</span> <span class=\"err\">←</span> <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">get_eqn_lemmas_for</span> <span class=\"n\">ff</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n    <span class=\"n\">lemmas</span> <span class=\"err\">←</span> <span class=\"n\">mmap</span> <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">get_decl</span> <span class=\"n\">lemmas</span><span class=\"o\">,</span>\n    <span class=\"n\">h</span> <span class=\"err\">←</span> <span class=\"n\">get_local</span> <span class=\"bp\">``</span><span class=\"n\">α</span><span class=\"o\">,</span>\n    <span class=\"n\">lemmas</span><span class=\"bp\">.</span><span class=\"n\">for_each</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">lem</span><span class=\"o\">,</span> <span class=\"n\">do</span>\n        <span class=\"n\">body</span> <span class=\"err\">←</span> <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">instantiate_mvars</span> <span class=\"n\">lem</span><span class=\"bp\">.</span><span class=\"n\">value</span><span class=\"o\">,</span>\n        <span class=\"n\">body</span> <span class=\"err\">←</span> <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">head_beta</span> <span class=\"err\">$</span> <span class=\"n\">body</span><span class=\"bp\">.</span><span class=\"n\">app</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n        <span class=\"err\">«</span><span class=\"k\">have</span><span class=\"err\">»</span> <span class=\"o\">(</span><span class=\"n\">some</span> <span class=\"n\">lem</span><span class=\"bp\">.</span><span class=\"n\">to_name</span><span class=\"bp\">.</span><span class=\"n\">components</span><span class=\"bp\">.</span><span class=\"n\">ilast</span><span class=\"o\">)</span> <span class=\"n\">none</span> <span class=\"bp\">``</span><span class=\"o\">(</span><span class=\"err\">%%</span><span class=\"n\">body</span><span class=\"o\">))</span>\n</code></pre></div>",
        "id": 203045639,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594072686
    },
    {
        "content": "<p>using the beta reduction in the second but last line, it does specialize the <code>alpha</code> away, but I still can't use it, because the theorem lives presumably in a level too low.</p>",
        "id": 203045707,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594072737
    },
    {
        "content": "<p>ideally, I'd add the theorems to the local context in a way, though, that I can just apply the local <code>alpha</code>.</p>",
        "id": 203045778,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594072787
    },
    {
        "content": "<p>Instead of <code>have</code>, you can use <code>note</code>. It takes elaborated terms</p>",
        "id": 203045859,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1594072816
    },
    {
        "content": "<p>Also, instead of using <code>lem.value</code> (which gives you the proof term for the lemmas) use <code>const n ls</code> where <code>n</code> is the name of the lemma and <code>ls</code> is the list of universe parameters that you want to use</p>",
        "id": 203045986,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1594072918
    },
    {
        "content": "<p>is there a way to figure out what universe the current proof lives in? my type <code>alpha</code> gets a variable <code>u_1</code> and I need to tie the lemmas to that.</p>",
        "id": 203046306,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594073130
    },
    {
        "content": "<p>The way universes work, you have universe literals (0, 1, 2, 3), universe parameters (<code>u1</code>, <code>u2</code>, <code>u3</code>) and <br>\nuniverse expressions (e.g. <code>max u (v+1)</code>)</p>",
        "id": 203046773,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1594073422
    },
    {
        "content": "<p>right, that's the <code>level</code> inductive, right?</p>",
        "id": 203046829,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594073473
    },
    {
        "content": "<p>If <code>alpha : Sort u</code>, the type of alpha is an expression <code>sort l</code> where <code>l</code> is a universe level. You can use it to instantiate the universe parameters of a constant</p>",
        "id": 203046847,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1594073488
    },
    {
        "content": "<p>That's right</p>",
        "id": 203046855,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1594073494
    },
    {
        "content": "<p>so basically if I get the constant <code>alpha</code>, I know this is meant to be a type, so I'd go ahead and put the theorem one level above or below.</p>",
        "id": 203046967,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594073561
    },
    {
        "content": "<p>so hang on, this whole replacing bound variables business, would we do that by just building up more and more complex lambdas  that eventually just solve the question by just simple reduction to normal form or are we meant to do reasoning outside and rewriting the terms by hand?</p>",
        "id": 203047370,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594073836
    },
    {
        "content": "<p>A lot of reasoning can be automated. You should read up on <code>tactic.mk_mapp</code></p>",
        "id": 203047740,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1594074150
    },
    {
        "content": "<p>yes, sorry. I'm going through the code base learning the API and all.</p>",
        "id": 203047949,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594074352
    },
    {
        "content": "<p>it's a non-trivial amount of API to take in :P</p>",
        "id": 203047996,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594074367
    },
    {
        "content": "<p>and I think the automation I'm trying to implement is also fairly sophisticated.</p>",
        "id": 203048028,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594074396
    },
    {
        "content": "<p>For sure! One step at a time and don't be afraid to take on a much smaller problem first to get acquainted with the whole system</p>",
        "id": 203048557,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1594074795
    },
    {
        "content": "<p>this is a bit confusing... my <code>local_const</code> <code>alpha : Type u</code> shows up as <code>const 1 []</code>.</p>",
        "id": 203049044,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594075197
    },
    {
        "content": "<p>i.e. it says it has not universe params.</p>",
        "id": 203049093,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594075209
    },
    {
        "content": "<p>What did you do to get there?</p>",
        "id": 203049366,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1594075407
    },
    {
        "content": "<p>it's this block:</p>\n<div class=\"codehilite\"><pre><span></span><code>    <span class=\"n\">h</span> <span class=\"err\">←</span> <span class=\"n\">get_local</span> <span class=\"bp\">``</span><span class=\"n\">α</span><span class=\"o\">,</span>\n\n    <span class=\"n\">lemmas</span><span class=\"bp\">.</span><span class=\"n\">for_each</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">lem</span><span class=\"o\">,</span> <span class=\"n\">do</span>\n        <span class=\"k\">let</span> <span class=\"n\">bla</span> <span class=\"o\">:=</span> <span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">local_type</span><span class=\"o\">,</span>\n        <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">trace</span> <span class=\"n\">bla</span><span class=\"bp\">.</span><span class=\"n\">to_raw_fmt</span><span class=\"o\">,</span>\n        <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">trace</span> <span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">to_raw_fmt</span>\n</code></pre></div>",
        "id": 203049482,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594075469
    },
    {
        "content": "<p>so <code>h.local_type</code> is <code>const 1 []</code></p>",
        "id": 203049532,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594075521
    },
    {
        "content": "<p>so presumably <code>const 1 []</code> refers to <code>Type u_1</code></p>",
        "id": 203049628,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594075571
    },
    {
        "content": "<p>I'm trying to extract <code>u_1</code> so that I can instantiate the theorem at <code>u_1</code>.</p>",
        "id": 203049729,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594075648
    },
    {
        "content": "<p>but don't know how to get it from the local context.</p>",
        "id": 203049739,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594075657
    },
    {
        "content": "<p><code>const 1 []</code> is a sign to run. It's the internals leaking through the interface</p>",
        "id": 203049861,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1594075719
    },
    {
        "content": "<p>Instead of <code>local_type</code>, use <code>infer_type</code></p>",
        "id": 203049890,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1594075742
    },
    {
        "content": "<p>ok.</p>",
        "id": 203049907,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594075755
    },
    {
        "content": "<p>woot, now I see \"sort u+1\"</p>",
        "id": 203049994,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594075802
    },
    {
        "content": "<p>thx</p>",
        "id": 203050022,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594075808
    },
    {
        "content": "<p><span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span></p>",
        "id": 203050586,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1594076212
    },
    {
        "content": "<p>yay, it worked, now I can use the lemmas in the local context.</p>",
        "id": 203050715,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594076288
    },
    {
        "content": "<p>Nice!</p>",
        "id": 203050754,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1594076325
    },
    {
        "content": "<p>Ok, so now I've managed to build up a large conjunction of all the cases, so we can go and try unifying things. Here's an example:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">state</span><span class=\"o\">:</span>\n<span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"err\">?</span><span class=\"o\">,</span>\n<span class=\"n\">new_lemma</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"err\">?</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">node</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">node</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">balance</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">red</span> <span class=\"n\">a</span> <span class=\"n\">x</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">red</span> <span class=\"n\">a</span> <span class=\"n\">x</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">∧</span>\n    <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"err\">?</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">node</span> <span class=\"n\">α</span><span class=\"o\">),</span>\n         <span class=\"n\">balance</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">black</span> <span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">leaf</span> <span class=\"n\">x</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">black</span> <span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">leaf</span> <span class=\"n\">x</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">∧</span>\n      <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"err\">?</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">val</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">right</span> <span class=\"o\">:</span> <span class=\"n\">node</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">node</span> <span class=\"n\">α</span><span class=\"o\">),</span>\n           <span class=\"n\">balance</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">black</span> <span class=\"o\">(</span><span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">red</span> <span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">leaf</span> <span class=\"n\">val</span> <span class=\"n\">right</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"n\">b</span> <span class=\"bp\">=</span>\n             <span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">black</span> <span class=\"o\">(</span><span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">red</span> <span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">leaf</span> <span class=\"n\">val</span> <span class=\"n\">right</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">∧</span>\n        <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"err\">?</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">node</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">node</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">node</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">node</span> <span class=\"n\">α</span><span class=\"o\">),</span>\n             <span class=\"n\">balance</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">black</span> <span class=\"o\">(</span><span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">red</span> <span class=\"o\">(</span><span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">red</span> <span class=\"n\">a</span> <span class=\"n\">x</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">y</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"n\">z</span> <span class=\"n\">d</span> <span class=\"bp\">=</span>\n               <span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">red</span> <span class=\"o\">(</span><span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">black</span> <span class=\"n\">a</span> <span class=\"n\">x</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">y</span> <span class=\"o\">(</span><span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">black</span> <span class=\"n\">c</span> <span class=\"n\">z</span> <span class=\"n\">d</span><span class=\"o\">))</span> <span class=\"bp\">∧</span>\n          <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"err\">?</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">left</span> <span class=\"o\">:</span> <span class=\"n\">node</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">val</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">right</span> <span class=\"o\">:</span> <span class=\"n\">node</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">val_1</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">right_1</span> <span class=\"o\">:</span> <span class=\"n\">node</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n             <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">node</span> <span class=\"n\">α</span><span class=\"o\">),</span>\n               <span class=\"n\">balance</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">black</span> <span class=\"o\">(</span><span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">red</span> <span class=\"o\">(</span><span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">black</span> <span class=\"n\">left</span> <span class=\"n\">val</span> <span class=\"n\">right</span><span class=\"o\">)</span> <span class=\"n\">val_1</span> <span class=\"n\">right_1</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"n\">b</span> <span class=\"bp\">=</span>\n                 <span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">black</span> <span class=\"o\">(</span><span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">red</span> <span class=\"o\">(</span><span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">black</span> <span class=\"n\">left</span> <span class=\"n\">val</span> <span class=\"n\">right</span><span class=\"o\">)</span> <span class=\"n\">val_1</span> <span class=\"n\">right_1</span><span class=\"o\">)</span> <span class=\"n\">x</span>\n                   <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">∧</span>\n            <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"err\">?</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">left</span> <span class=\"o\">:</span> <span class=\"n\">node</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">val</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">right</span> <span class=\"o\">:</span> <span class=\"n\">node</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">node</span> <span class=\"n\">α</span><span class=\"o\">),</span>\n                 <span class=\"n\">balance</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">black</span> <span class=\"o\">(</span><span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">black</span> <span class=\"n\">left</span> <span class=\"n\">val</span> <span class=\"n\">right</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"n\">b</span> <span class=\"bp\">=</span>\n                   <span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">black</span> <span class=\"o\">(</span><span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">black</span> <span class=\"n\">left</span> <span class=\"n\">val</span> <span class=\"n\">right</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">∧</span>\n              <span class=\"n\">true</span>\n<span class=\"err\">⊢</span> <span class=\"n\">false</span>\n</code></pre></div>",
        "id": 203062289,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594089622
    },
    {
        "content": "<p>I still don't see how to unify the cases, though. </p>\n<ul>\n<li>The universal quantifiers are quite different between the cases</li>\n<li>And even if we manage to get the rhs to be syntactically (or at least definitionally) the same, it doesn't give us much, yet, because we still don't get the universal quantification.</li>\n</ul>",
        "id": 203062410,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594089907
    },
    {
        "content": "<p>in order to prove something like</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">def</span> <span class=\"n\">id</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"o\">:=</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">zero</span>\n</code></pre></div>\n\n\n<p>we get lemmas <code>id zero = zero + zero</code> and <code>forall n, id (succ n) = succ n + zero</code>. So in order to get the <code>forall n, id n = n</code>, we have to go ahead and apply the induction lemmas. All the whilst making sure that the rhs be the same <code>P n</code>.</p>",
        "id": 203062567,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594090148
    },
    {
        "content": "<p>Try and work with two equations at a time. No need for such a big conjunction. If you have two equations, remove the universals so that theirs bound variables become free variables. You should get something like this:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"n\">RHS0</span>\n<span class=\"n\">f</span> <span class=\"n\">d</span> <span class=\"n\">e</span> <span class=\"n\">g</span> <span class=\"bp\">=</span> <span class=\"n\">RHS1</span>\n</code></pre></div>\n\n\n<p>that is an equality whose lhs is a function applied to multiple arguments</p>",
        "id": 203062636,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1594090222
    },
    {
        "content": "<p>the idea of introducing fresh variables, however doesn't create the same <code>P</code>. The inferred <code>P n</code> from the case for zero is <code>P n = n + n</code>. (Because <code>n</code> is known to be <code>zero</code>, whereas the <code>succ</code> case comes up with <code>P n = n + zero</code>.</p>",
        "id": 203062643,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594090253
    },
    {
        "content": "<p>That's ok. I think you may have to accept that results may sometimes be imperfect. That can be improved over time but let's go with something simple first</p>",
        "id": 203062724,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1594090407
    },
    {
        "content": "<p>(I did the conjunction mostly so I can look at the term) Can you even add a term with free variables into the context?</p>",
        "id": 203062727,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594090412
    },
    {
        "content": "<p>Yes but don't always need to add your terms to the context. Oh and by free variables, I mean <code>local_const</code> not <code>var</code></p>",
        "id": 203062784,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1594090532
    },
    {
        "content": "<p>ok sure, that makes sense as the final form of how it's supposed to run. For now, I use the context as a debugging tool.</p>",
        "id": 203062833,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594090599
    },
    {
        "content": "<p>it does pretty-printing and I can use tactics to massage terms as needed to try things out.</p>",
        "id": 203062841,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594090618
    },
    {
        "content": "<p>That's reasonable</p>",
        "id": 203062849,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1594090644
    },
    {
        "content": "<p>but we do need to apply the induction principle, right?</p>",
        "id": 203062905,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594090697
    },
    {
        "content": "<p>or am I missing something?</p>",
        "id": 203062910,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594090702
    },
    {
        "content": "<p>The induction principle is not the next thing though</p>",
        "id": 203063003,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1594090918
    },
    {
        "content": "<p>sure, now we need to go and turn subterms into def_eq pairs.</p>",
        "id": 203063045,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594090951
    },
    {
        "content": "<p>(one nice things about doing all of them at once, btw, was that it means fewer substitutions overall)</p>",
        "id": 203063052,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594090977
    },
    {
        "content": "<p>That’s right. </p>\n<p>(Yes, but sometimes it’s easy to over-constrain your solution and make hard problems harder. And the additional constraints may not address the important bottleneck)</p>",
        "id": 203063608,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1594091927
    },
    {
        "content": "<p>I see. My intermediate strategy was basically to quantify over the conjunction. Creating an <code>forall [fresh_var], rest</code> at the root level, and specializing each quantifier away at the inner level. That way all the bound variables become free (under the global quantifiers).</p>",
        "id": 203063769,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594092237
    },
    {
        "content": "<p>Not quite sure how to do it without that whilst maintaining well-formed terms.</p>",
        "id": 203063811,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594092260
    },
    {
        "content": "<p>after that, I can star replacing the sub-expressions as you suggested.</p>",
        "id": 203063843,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594092341
    },
    {
        "content": "<p>and that'll unify the right-hand sides that should be unified.</p>",
        "id": 203063850,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594092360
    },
    {
        "content": "<p>I wonder if I could even just prove a lemma and use it as a simplifier rule... something like <code>(forall x, P x) /\\ Q &lt;-&gt; forall y, P y /\\ Q</code>.</p>",
        "id": 203063953,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594092537
    },
    {
        "content": "<p>If I use this as a lemma for the simplifier, that should help.</p>",
        "id": 203063959,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594092553
    },
    {
        "content": "<p>I wouldn’t go that route. The terms will be easier to manipulate and traverse without the forall (you can keep a list of variables on the side) and when you’re ready to generate definitions, lemmas and proofs, you add the forall and lambdas back in</p>",
        "id": 203064146,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1594092938
    },
    {
        "content": "<p>i see.</p>",
        "id": 203064152,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594092960
    },
    {
        "content": "<p>I’ll have to let you experiment with the idea now. My bed calls to me (and won’t leave a voicemail)</p>",
        "id": 203064202,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1594093026
    },
    {
        "content": "<p>same start, though, right? we just arbitrarily introduce fresh variables and quantify away each quantifier, right?</p>",
        "id": 203064203,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594093027
    },
    {
        "content": "<p>Of course, have a goodnight.</p>",
        "id": 203064206,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594093044
    },
    {
        "content": "<p>I'll go to bed soon too.</p>",
        "id": 203064208,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594093051
    },
    {
        "content": "<p>That’s right. When the constructors around arguments match you leave them in otherwise you replace them with a fresh variable</p>",
        "id": 203064265,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1594093198
    },
    {
        "content": "<p>not quite sure how much time I'll have tonight, but the next step I want to work on is introducing the new variables, so that we can show the RHS is equal. When looking at the equations, though I noticed, that the thing we're trying to prove is false. In the following sense:</p>",
        "id": 203140939,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594146548
    },
    {
        "content": "<p>given a definition like this</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">def</span> <span class=\"n\">balance</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">color</span> <span class=\"bp\">→</span> <span class=\"n\">node</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">node</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">node</span> <span class=\"n\">α</span>\n<span class=\"bp\">|</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">black</span> <span class=\"o\">(</span><span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">red</span> <span class=\"o\">(</span><span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">red</span> <span class=\"n\">a</span> <span class=\"n\">x</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">y</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"n\">z</span> <span class=\"n\">d</span> <span class=\"o\">:=</span>\n    <span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">red</span> <span class=\"o\">(</span><span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">black</span> <span class=\"n\">a</span> <span class=\"n\">x</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">y</span> <span class=\"o\">(</span><span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">black</span> <span class=\"n\">c</span> <span class=\"n\">z</span> <span class=\"n\">d</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">color</span> <span class=\"n\">a</span> <span class=\"n\">x</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span> <span class=\"n\">a</span> <span class=\"n\">x</span> <span class=\"n\">b</span>\n</code></pre></div>\n\n\n<p>we would like to prove <code>forall a x b y c z d, balance color.black (node.tree color.red (node.tree color.red a x b) y c) z d = node.tree color.red (node.tree color.black a x b) y (node.tree color.black c z d)</code>, which is true.</p>\n<p>but also <code>forall color a x b, balance color a x b = node.tree color a x b</code>, which is false.</p>",
        "id": 203141216,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594146692
    },
    {
        "content": "<p>The second case only becomes simple when considered in a context. We must know that the first case didn't hold.</p>",
        "id": 203141346,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594146740
    },
    {
        "content": "<p>So it turns out we need a proof like this: <code>forall x, first_case x</code>, <code>¬(forall x, first_case) -&gt; (forall x, second_case x)</code></p>",
        "id": 203141546,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594146844
    },
    {
        "content": "<p>So the idea of building a proposition is really nice, but we need to detect the order of the RHS, too.</p>",
        "id": 203141691,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594146935
    },
    {
        "content": "<p>That's right. The other thing that we can do is have predicates that correspond to constructors. We can have <code>is_cons</code> and <code>is_nil</code> for a list so that, when you unify two cases, you have to update an assumption:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">cons</span> <span class=\"n\">x</span> <span class=\"n\">xs</span><span class=\"o\">)</span> <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"n\">A</span>\n<span class=\"n\">foo</span> <span class=\"n\">nil</span> <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"n\">A</span>\n</code></pre></div>\n\n\n<p>would then be encoded as:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">is_cons</span> <span class=\"n\">y</span> <span class=\"bp\">\\/</span> <span class=\"n\">is_nil</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">foo</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">A</span>\n</code></pre></div>",
        "id": 203142054,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1594147136
    },
    {
        "content": "<p>And here, we can see that the disjunction is exhaustive and leave it out</p>",
        "id": 203142091,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1594147156
    },
    {
        "content": "<p>is there a convenient way of working with free variables? So far having things in the proof state was quite nice, because I could see the terms.</p>",
        "id": 203147278,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594149348
    },
    {
        "content": "<p>You'd have to keep printing your term but otherwise, it's straightforward. Anything specific you're unclear about?</p>",
        "id": 203147703,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1594149588
    },
    {
        "content": "<p>Not exactly, I just presume I can't add them to the local context, because I could potentially construct bogus info, so I'd have to work by just printing. Having them in the local context is really  just a convenience thing.</p>",
        "id": 203147911,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594149702
    },
    {
        "content": "<p>i suppose I could create fresh variables and prove them using sorry in the tactic.</p>",
        "id": 203147983,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594149727
    },
    {
        "content": "<p>that way the terms would at least be well-formed</p>",
        "id": 203148019,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594149744
    },
    {
        "content": "<p>I see what you mean. The proof state and the terms are not strictly controlled. You can do a whole lot of operations on them that could create an invalid proof. That's not really a problem because when you add a declaration, Lean makes sure that it type checks and that it has no meta variable. How you get there is your own business. It's good to stay close to something that constitutes a valid proof but if you need to take liberties, Lean won't keep you until you add a declaration</p>",
        "id": 203148346,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1594149901
    },
    {
        "content": "<p>ah, ok, thanks. I'll work on that.</p>",
        "id": 203148619,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594150011
    },
    {
        "content": "<p>random only semi-related question. Do we have a union-find data structure?</p>",
        "id": 203151271,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594151353
    },
    {
        "content": "<p>There is a specialized version of it for the <code>tfae</code> tactic (the following are equivalent, finds strongly connected components in a graph of implications)</p>",
        "id": 203194453,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1594151447
    },
    {
        "content": "<p>cool</p>",
        "id": 203195000,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594151753
    },
    {
        "content": "<p>hmm, having trouble doing a beta reduction. I've got the meta var, but it can't infer a type.</p>",
        "id": 203209100,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594159403
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">infer</span> <span class=\"n\">type</span> <span class=\"n\">failed</span><span class=\"o\">,</span> <span class=\"n\">function</span> <span class=\"n\">expected</span> <span class=\"n\">at</span>\n  <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"err\">?</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">left</span> <span class=\"o\">:</span> <span class=\"n\">node</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">val</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">right</span> <span class=\"o\">:</span> <span class=\"n\">node</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">node</span> <span class=\"n\">α</span><span class=\"o\">),</span>\n     <span class=\"n\">balance</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">black</span> <span class=\"o\">(</span><span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">black</span> <span class=\"n\">left</span> <span class=\"n\">val</span> <span class=\"n\">right</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"n\">b</span> <span class=\"bp\">=</span>\n       <span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">black</span> <span class=\"o\">(</span><span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">black</span> <span class=\"n\">left</span> <span class=\"n\">val</span> <span class=\"n\">right</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n    <span class=\"err\">?</span><span class=\"n\">m_1</span>\n<span class=\"n\">term</span>\n  <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"err\">?</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">left</span> <span class=\"o\">:</span> <span class=\"n\">node</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">val</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">right</span> <span class=\"o\">:</span> <span class=\"n\">node</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">node</span> <span class=\"n\">α</span><span class=\"o\">),</span>\n    <span class=\"n\">balance</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">black</span> <span class=\"o\">(</span><span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">black</span> <span class=\"n\">left</span> <span class=\"n\">val</span> <span class=\"n\">right</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"n\">b</span> <span class=\"bp\">=</span>\n      <span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">black</span> <span class=\"o\">(</span><span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">black</span> <span class=\"n\">left</span> <span class=\"n\">val</span> <span class=\"n\">right</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"n\">b</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"kt\">Prop</span>\n</code></pre></div>",
        "id": 203209202,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594159460
    },
    {
        "content": "<p>I shouldn't have to manually unfold the <code>Pi</code>, should I?</p>",
        "id": 203209280,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594159533
    },
    {
        "content": "<p>I think you're making a mistake here. You have a term which is <code>∀ {α : Type ?}, ...</code>, whose type is <code>Prop</code> and you're trying to use function application on it but you'd need a term of the form <code>λ {a}, ...</code>, whose type is <code>∀ {a}, ...</code>. Do you see the difference?</p>",
        "id": 203209454,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1594159634
    },
    {
        "content": "<p>sure I do, but I don't getit , because the lemma is a constant.</p>",
        "id": 203209490,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594159676
    },
    {
        "content": "<p>Is there a way for me to get the proof?</p>",
        "id": 203209541,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594159694
    },
    {
        "content": "<p>nevermind, I'm being silly, the constant of course does have that type...</p>",
        "id": 203209615,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594159757
    },
    {
        "content": "<p>so will the beta reduction then unfold the const?</p>",
        "id": 203209624,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594159768
    },
    {
        "content": "<p>omg, now it starts to dawn on me... I'm manipulating terms, but am trying to change the shape of the type... Why didn't I notice earlier, sorry about the confusion.</p>",
        "id": 203210062,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594160099
    },
    {
        "content": "<p>No worries, one lesson at a time :)</p>",
        "id": 203210347,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1594160284
    },
    {
        "content": "<p>it's one thing to prove things and a whole another level to write meta programs &gt;&lt;</p>",
        "id": 203210436,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594160361
    },
    {
        "content": "<p>but I am fully intent on making this work, anyway :)</p>",
        "id": 203210451,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594160373
    },
    {
        "content": "<p>I think that's a worthwhile exercise to go through</p>",
        "id": 203210726,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1594160560
    },
    {
        "content": "<p>yes. And also the knowledge will be quite useful for Lean 4, as there's more in lean code there and we can continue to make the lean story better.</p>",
        "id": 203210812,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594160635
    },
    {
        "content": "<p>For math I already really like it, for program verification this cases thing is still quite annoying.</p>",
        "id": 203210879,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594160659
    },
    {
        "content": "<p>Once we make a bit more automation, though... it'll be just awesome :D</p>",
        "id": 203210928,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594160686
    },
    {
        "content": "<p>That's my feeling too. There are too few people who care about software verification in Lean so it all falls on the few who do care about. Maybe, little by little, we can make it more appealing to computer scientists</p>",
        "id": 203211220,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1594160935
    },
    {
        "content": "<p>heh:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"err\">?</span><span class=\"o\">,</span>\n<span class=\"bp\">_</span><span class=\"n\">eqn_6</span> <span class=\"o\">:</span>\n  <span class=\"n\">balance</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">black</span> <span class=\"o\">(</span><span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">black</span> <span class=\"err\">?</span><span class=\"n\">m_2</span> <span class=\"err\">?</span><span class=\"n\">m_3</span> <span class=\"err\">?</span><span class=\"n\">m_4</span><span class=\"o\">)</span> <span class=\"err\">?</span><span class=\"n\">m_5</span> <span class=\"err\">?</span><span class=\"n\">m_6</span> <span class=\"bp\">=</span>\n    <span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">black</span> <span class=\"o\">(</span><span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">black</span> <span class=\"err\">?</span><span class=\"n\">m_2</span> <span class=\"err\">?</span><span class=\"n\">m_3</span> <span class=\"err\">?</span><span class=\"n\">m_4</span><span class=\"o\">)</span> <span class=\"err\">?</span><span class=\"n\">m_5</span> <span class=\"err\">?</span><span class=\"n\">m_6</span><span class=\"o\">,</span>\n<span class=\"bp\">_</span><span class=\"n\">eqn_5</span> <span class=\"o\">:</span>\n  <span class=\"n\">balance</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">black</span> <span class=\"o\">(</span><span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">red</span> <span class=\"o\">(</span><span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">black</span> <span class=\"err\">?</span><span class=\"n\">m_8</span> <span class=\"err\">?</span><span class=\"n\">m_9</span> <span class=\"err\">?</span><span class=\"n\">m_10</span><span class=\"o\">)</span> <span class=\"err\">?</span><span class=\"n\">m_11</span> <span class=\"err\">?</span><span class=\"n\">m_12</span><span class=\"o\">)</span> <span class=\"err\">?</span><span class=\"n\">m_13</span> <span class=\"err\">?</span><span class=\"n\">m_14</span> <span class=\"bp\">=</span>\n    <span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">black</span> <span class=\"o\">(</span><span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">red</span> <span class=\"o\">(</span><span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">black</span> <span class=\"err\">?</span><span class=\"n\">m_8</span> <span class=\"err\">?</span><span class=\"n\">m_9</span> <span class=\"err\">?</span><span class=\"n\">m_10</span><span class=\"o\">)</span> <span class=\"err\">?</span><span class=\"n\">m_11</span> <span class=\"err\">?</span><span class=\"n\">m_12</span><span class=\"o\">)</span> <span class=\"err\">?</span><span class=\"n\">m_13</span> <span class=\"err\">?</span><span class=\"n\">m_14</span><span class=\"o\">,</span>\n<span class=\"bp\">_</span><span class=\"n\">eqn_4</span> <span class=\"o\">:</span>\n  <span class=\"n\">balance</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">black</span> <span class=\"o\">(</span><span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">red</span> <span class=\"o\">(</span><span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">red</span> <span class=\"err\">?</span><span class=\"n\">m_16</span> <span class=\"err\">?</span><span class=\"n\">m_17</span> <span class=\"err\">?</span><span class=\"n\">m_18</span><span class=\"o\">)</span> <span class=\"err\">?</span><span class=\"n\">m_19</span> <span class=\"err\">?</span><span class=\"n\">m_20</span><span class=\"o\">)</span> <span class=\"err\">?</span><span class=\"n\">m_21</span> <span class=\"err\">?</span><span class=\"n\">m_22</span> <span class=\"bp\">=</span>\n    <span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">red</span> <span class=\"o\">(</span><span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">black</span> <span class=\"err\">?</span><span class=\"n\">m_16</span> <span class=\"err\">?</span><span class=\"n\">m_17</span> <span class=\"err\">?</span><span class=\"n\">m_18</span><span class=\"o\">)</span> <span class=\"err\">?</span><span class=\"n\">m_19</span> <span class=\"o\">(</span><span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">black</span> <span class=\"err\">?</span><span class=\"n\">m_20</span> <span class=\"err\">?</span><span class=\"n\">m_21</span> <span class=\"err\">?</span><span class=\"n\">m_22</span><span class=\"o\">),</span>\n<span class=\"bp\">_</span><span class=\"n\">eqn_3</span> <span class=\"o\">:</span>\n  <span class=\"n\">balance</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">black</span> <span class=\"o\">(</span><span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">red</span> <span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">leaf</span> <span class=\"err\">?</span><span class=\"n\">m_24</span> <span class=\"err\">?</span><span class=\"n\">m_25</span><span class=\"o\">)</span> <span class=\"err\">?</span><span class=\"n\">m_26</span> <span class=\"err\">?</span><span class=\"n\">m_27</span> <span class=\"bp\">=</span>\n    <span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">black</span> <span class=\"o\">(</span><span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">red</span> <span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">leaf</span> <span class=\"err\">?</span><span class=\"n\">m_24</span> <span class=\"err\">?</span><span class=\"n\">m_25</span><span class=\"o\">)</span> <span class=\"err\">?</span><span class=\"n\">m_26</span> <span class=\"err\">?</span><span class=\"n\">m_27</span><span class=\"o\">,</span>\n<span class=\"bp\">_</span><span class=\"n\">eqn_2</span> <span class=\"o\">:</span> <span class=\"n\">balance</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">black</span> <span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">leaf</span> <span class=\"err\">?</span><span class=\"n\">m_29</span> <span class=\"err\">?</span><span class=\"n\">m_30</span> <span class=\"bp\">=</span> <span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">black</span> <span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">leaf</span> <span class=\"err\">?</span><span class=\"n\">m_29</span> <span class=\"err\">?</span><span class=\"n\">m_30</span><span class=\"o\">,</span>\n<span class=\"bp\">_</span><span class=\"n\">eqn_1</span> <span class=\"o\">:</span> <span class=\"n\">balance</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">red</span> <span class=\"err\">?</span><span class=\"n\">m_32</span> <span class=\"err\">?</span><span class=\"n\">m_33</span> <span class=\"err\">?</span><span class=\"n\">m_34</span> <span class=\"bp\">=</span> <span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">red</span> <span class=\"err\">?</span><span class=\"n\">m_32</span> <span class=\"err\">?</span><span class=\"n\">m_33</span> <span class=\"err\">?</span><span class=\"n\">m_34</span>\n</code></pre></div>",
        "id": 203215950,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594164679
    },
    {
        "content": "<p>so next, I can go call-site by call-site introducing new variables, but this time round, we need to also replace sub-exprs in other equations.</p>",
        "id": 203216061,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594164754
    },
    {
        "content": "<p>I'm not sure if we have the same understanding. What I was suggesting was to take the equations, two by two, zip the argument list of their lhs and find a conservative generalization, i.e. if both are <code>cons ? ?</code> then you keep them as <code>cons ? ?</code>. If they are different constructors or that one is a constructor and the other is not, you introduce a new variable</p>",
        "id": 203216754,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1594165348
    },
    {
        "content": "<p>oh I do understand, but I can't do that under quantifiers.</p>",
        "id": 203216801,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594165402
    },
    {
        "content": "<p>so I first just replaced all quantifiers with free variables.</p>",
        "id": 203216812,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594165416
    },
    {
        "content": "<p>That's right, that's the right thing to do</p>",
        "id": 203216827,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1594165430
    },
    {
        "content": "<p>here now, e.g. m_6 and m_14 can be unified.</p>",
        "id": 203216887,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594165455
    },
    {
        "content": "<p>or m_14 and m_22</p>",
        "id": 203216897,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594165465
    },
    {
        "content": "<p>From which equations?</p>",
        "id": 203217075,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1594165661
    },
    {
        "content": "<p>eqn_6 and eqn_5 have m_6 and m_14, respectively at the same place.</p>",
        "id": 203217200,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594165775
    },
    {
        "content": "<p>but they do have different prefixes, though.</p>",
        "id": 203217209,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594165787
    },
    {
        "content": "<p>are the dependent types strictly left-to-right?</p>",
        "id": 203217267,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594165806
    },
    {
        "content": "<p>They are strictly left to right. I have not considered dependent types so far.</p>",
        "id": 203217360,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1594165910
    },
    {
        "content": "<p><code>eqn_1</code> and <code>eqn_2</code> are an interesting bunch, for instance.</p>",
        "id": 203217432,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594165970
    },
    {
        "content": "<p>How so?</p>",
        "id": 203217445,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1594165993
    },
    {
        "content": "<p>their rhs would become <code>node.tree u x y z</code>.</p>",
        "id": 203217458,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594166021
    },
    {
        "content": "<p>but that is in fact too general, we can't prove it.</p>",
        "id": 203217469,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594166038
    },
    {
        "content": "<p>they both are the same case in the code, but the equation only holds, because we have considered the other cases first in the pattern matching.</p>",
        "id": 203217555,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594166117
    },
    {
        "content": "<p>so this is an instance of the dependent case, really.</p>",
        "id": 203217563,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594166129
    },
    {
        "content": "<p>Is it because  <code>tree</code> is an inductive family? Can you show me the definition again?</p>",
        "id": 203217634,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1594166188
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">def</span> <span class=\"n\">balance</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">color</span> <span class=\"bp\">→</span> <span class=\"n\">node</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">node</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">node</span> <span class=\"n\">α</span>\n<span class=\"bp\">|</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">black</span> <span class=\"o\">(</span><span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">red</span> <span class=\"o\">(</span><span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">red</span> <span class=\"n\">a</span> <span class=\"n\">x</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">y</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"n\">z</span> <span class=\"n\">d</span> <span class=\"o\">:=</span>\n    <span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">red</span> <span class=\"o\">(</span><span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">black</span> <span class=\"n\">a</span> <span class=\"n\">x</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">y</span> <span class=\"o\">(</span><span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">black</span> <span class=\"n\">c</span> <span class=\"n\">z</span> <span class=\"n\">d</span><span class=\"o\">)</span>\n<span class=\"c1\">-- | color.black (node.tree color.red a x (node.tree color.red b y c)) z d :=</span>\n<span class=\"c1\">--     node.tree color.red (node.tree color.black a x b) y (node.tree color.black c z d)</span>\n<span class=\"c1\">-- | color.black a x (node.tree color.red (node.tree color.red b y c) z d) :=</span>\n<span class=\"c1\">--     node.tree color.red (node.tree color.black a x b) y (node.tree color.black c z d)</span>\n<span class=\"c1\">-- | color.black a x (node.tree color.red b y (node.tree color.red c z d)) :=</span>\n<span class=\"c1\">--      node.tree color.red (node.tree color.black a x b) y (node.tree color.black c z d)</span>\n<span class=\"bp\">|</span> <span class=\"n\">color</span> <span class=\"n\">a</span> <span class=\"n\">x</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span> <span class=\"n\">a</span> <span class=\"n\">x</span> <span class=\"n\">b</span>\n</code></pre></div>",
        "id": 203217651,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594166220
    },
    {
        "content": "<p>the problem is, that the second pattern match is <code>color</code> for arbitrary <code>color</code>.</p>",
        "id": 203217680,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594166249
    },
    {
        "content": "<p>But we know from the context, that it's either <code>red</code> and anything, or <code>black</code>, but not the previous case.</p>",
        "id": 203217740,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594166284
    },
    {
        "content": "<p>that's why the rhs becomes simple.</p>",
        "id": 203217749,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594166294
    },
    {
        "content": "<p>It's the fall-through between cases that simplifies it.</p>",
        "id": 203217755,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594166307
    },
    {
        "content": "<p>Yes I see</p>",
        "id": 203217937,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1594166498
    },
    {
        "content": "<p>I would do the unification from left to right and I would just give up (reject the unification) if generalizing one argument makes later arguments type incorrect</p>",
        "id": 203218040,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1594166586
    },
    {
        "content": "<p>i see</p>",
        "id": 203218067,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594166630
    },
    {
        "content": "<p>There might be a more aggressive solution but I think a simpler first solution will make it easier to get a testable prototype</p>",
        "id": 203218184,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1594166729
    },
    {
        "content": "<p>Ya, I'll work on it. At this point I have at least the general API down, so I more or less know how to construct terms. So soon I can think about the algorithm. The more we have coded up, the easier it is to criticize ;-)</p>",
        "id": 203218391,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594166947
    },
    {
        "content": "<p>Indeed :)</p>",
        "id": 203218414,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1594166981
    },
    {
        "content": "<p>Actually I don't think we can unify left to right. When I'm doing the transformation we want to code up by hand, It keeps smearing the wrong cases and thus make the theorem false. I think have to unify inside-out, keeping careful track of what's around in the context.</p>",
        "id": 203222957,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594172502
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 203227420,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594178438
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 203227507,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594178550
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 203228003,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594179192
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 203228066,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594179248
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 203228072,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594179260
    },
    {
        "content": "<p>At the end of the day, I think it may well be easiest to use the lambda in the definition itself and analyse its structure.</p>",
        "id": 203229439,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594181222
    },
    {
        "content": "<p>All the cases are already handled correctly. So the main question that remains, is if can have a better decision procedure by ordering the cases in the type better.</p>",
        "id": 203229465,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594181272
    },
    {
        "content": "<p>It's worth exploring when you have something that works. Feel free to put it up on a git repo. It will be easier to discuss</p>",
        "id": 203229578,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1594181442
    },
    {
        "content": "<p>yup will do.</p>",
        "id": 203229640,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594181563
    },
    {
        "content": "<p>I've made a good deal of progress on this, though not quite working yet.</p>",
        "id": 203340954,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594255837
    },
    {
        "content": "<p>I also changed the strategy a bit. instead of trying to infer the spec, I instead as the user for an equality to prove.</p>",
        "id": 203340992,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594255902
    },
    {
        "content": "<p>I can then use normal reduction until the reduction gets stuck, at which point I can then introduce the case split as need to construct a proof.</p>",
        "id": 203341047,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594255938
    },
    {
        "content": "<p>That sounds like a good plan. Do you have examples that show off what you've done so far?</p>",
        "id": 203341076,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1594255991
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">meta</span> <span class=\"n\">def</span> <span class=\"n\">inline_body</span> <span class=\"o\">:</span> <span class=\"n\">expr</span> <span class=\"bp\">→</span> <span class=\"n\">tactic</span> <span class=\"n\">expr</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">app</span> <span class=\"n\">l</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">inline_body</span> <span class=\"n\">l</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"bp\">λ</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">pure</span> <span class=\"err\">$</span> <span class=\"n\">app</span> <span class=\"n\">l</span> <span class=\"n\">r</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">const</span> <span class=\"n\">n</span> <span class=\"n\">ls</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">do</span>\n    <span class=\"n\">decl</span> <span class=\"err\">←</span> <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">get_decl</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n    <span class=\"n\">return</span> <span class=\"n\">decl</span><span class=\"bp\">.</span><span class=\"n\">value</span>\n<span class=\"bp\">|</span> <span class=\"n\">e</span> <span class=\"o\">:=</span> <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">trace</span> <span class=\"n\">e</span> <span class=\"bp\">&gt;&gt;</span> <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">failed</span>\n\n<span class=\"n\">meta</span> <span class=\"n\">def</span> <span class=\"n\">specialize_mvar</span> <span class=\"o\">:</span> <span class=\"n\">expr</span> <span class=\"bp\">→</span> <span class=\"n\">expr</span> <span class=\"bp\">→</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">option</span> <span class=\"n\">expr</span>\n<span class=\"bp\">|</span> <span class=\"n\">mv&#39;</span> <span class=\"n\">mv</span><span class=\"bp\">@</span><span class=\"o\">(</span><span class=\"n\">mvar</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"bp\">_</span> <span class=\"o\">:=</span> <span class=\"n\">some</span> <span class=\"err\">$</span> <span class=\"n\">mv</span><span class=\"bp\">.</span><span class=\"n\">app</span> <span class=\"n\">mv&#39;</span>\n<span class=\"bp\">|</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"o\">:=</span> <span class=\"n\">none</span>\n\n<span class=\"n\">meta</span> <span class=\"n\">mutual</span> <span class=\"n\">def</span> <span class=\"n\">break_case</span><span class=\"o\">,</span> <span class=\"n\">eq_proof</span>\n<span class=\"k\">with</span> <span class=\"n\">break_case</span> <span class=\"o\">:</span> <span class=\"n\">expr</span> <span class=\"bp\">→</span> <span class=\"n\">expr</span> <span class=\"bp\">→</span> <span class=\"n\">expr</span> <span class=\"bp\">→</span> <span class=\"n\">tactic</span> <span class=\"n\">expr</span>\n<span class=\"bp\">|</span> <span class=\"n\">eq</span> <span class=\"n\">e</span><span class=\"bp\">@</span><span class=\"o\">(</span><span class=\"n\">app</span> <span class=\"n\">x</span> <span class=\"n\">mv</span><span class=\"o\">)</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"n\">do</span>\n    <span class=\"n\">ty_next</span> <span class=\"err\">←</span> <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">infer_type</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n    <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">trace</span> <span class=\"n\">ty_next</span><span class=\"o\">,</span>\n    <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">trace</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n    <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">trace</span> <span class=\"n\">y</span><span class=\"o\">,</span>\n    <span class=\"bp\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">mv</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"bp\">⟩</span> <span class=\"err\">←</span>\n        <span class=\"k\">match</span> <span class=\"n\">ty_next</span><span class=\"bp\">.</span><span class=\"n\">is_pi</span> <span class=\"k\">with</span>\n        <span class=\"bp\">|</span> <span class=\"n\">tt</span> <span class=\"o\">:=</span> <span class=\"n\">do</span>\n            <span class=\"n\">mv&#39;</span> <span class=\"err\">←</span> <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">mk_mvar</span><span class=\"o\">,</span>\n            <span class=\"n\">return</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">replace</span> <span class=\"o\">(</span><span class=\"n\">specialize_mvar</span> <span class=\"n\">mv&#39;</span><span class=\"o\">),</span> <span class=\"n\">mv&#39;</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"bp\">.</span><span class=\"n\">replace</span> <span class=\"o\">(</span><span class=\"n\">specialize_mvar</span> <span class=\"n\">mv&#39;</span><span class=\"o\">))</span>\n        <span class=\"bp\">|</span> <span class=\"n\">ff</span> <span class=\"o\">:=</span> <span class=\"n\">pure</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">mv</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n        <span class=\"kn\">end</span><span class=\"o\">,</span>\n    <span class=\"n\">return</span> <span class=\"n\">e</span>\n<span class=\"bp\">|</span> <span class=\"n\">eq</span> <span class=\"n\">e</span> <span class=\"bp\">_</span> <span class=\"o\">:=</span> <span class=\"n\">do</span>\n    <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">trace</span> <span class=\"n\">e</span><span class=\"o\">,</span>\n    <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">fail</span> <span class=\"s2\">&quot;failed to break cases&quot;</span>\n<span class=\"k\">with</span> <span class=\"n\">eq_proof</span> <span class=\"o\">:</span> <span class=\"n\">expr</span> <span class=\"bp\">→</span> <span class=\"n\">expr</span> <span class=\"bp\">→</span> <span class=\"n\">expr</span> <span class=\"bp\">→</span> <span class=\"n\">tactic</span> <span class=\"n\">expr</span>\n<span class=\"bp\">|</span> <span class=\"n\">eq</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"n\">do</span>\n    <span class=\"n\">is_eq</span> <span class=\"err\">←</span> <span class=\"n\">succeeds</span> <span class=\"err\">$</span> <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">is_def_eq</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span>\n    <span class=\"k\">match</span> <span class=\"n\">is_eq</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">tt</span> <span class=\"o\">:=</span> <span class=\"n\">pure</span> <span class=\"err\">$</span> <span class=\"o\">(</span><span class=\"n\">eq</span><span class=\"bp\">.</span><span class=\"n\">app</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">app</span> <span class=\"n\">y</span>\n    <span class=\"bp\">|</span> <span class=\"n\">ff</span> <span class=\"o\">:=</span> <span class=\"n\">do</span>\n        <span class=\"n\">x</span> <span class=\"err\">←</span> <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">whnf</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n        <span class=\"n\">break_case</span> <span class=\"n\">eq</span> <span class=\"n\">x</span> <span class=\"n\">y</span>\n    <span class=\"kn\">end</span>\n    <span class=\"bp\">&gt;&gt;=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">pure</span> <span class=\"err\">$</span> <span class=\"o\">(</span><span class=\"n\">eq</span><span class=\"bp\">.</span><span class=\"n\">app</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">app</span> <span class=\"n\">y</span>\n\n<span class=\"n\">meta</span> <span class=\"n\">def</span> <span class=\"n\">pattern_match_proof</span> <span class=\"o\">:</span> <span class=\"n\">expr</span> <span class=\"bp\">→</span> <span class=\"n\">tactic</span> <span class=\"n\">expr</span>\n<span class=\"bp\">|</span> <span class=\"n\">e</span><span class=\"bp\">@</span><span class=\"o\">(</span><span class=\"n\">pi</span> <span class=\"n\">name</span> <span class=\"n\">bi</span> <span class=\"n\">ty</span> <span class=\"n\">body</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">do</span>\n    <span class=\"n\">body</span> <span class=\"err\">←</span> <span class=\"n\">pattern_match_proof</span> <span class=\"n\">body</span><span class=\"o\">,</span>\n    <span class=\"n\">return</span> <span class=\"err\">$</span> <span class=\"n\">lam</span> <span class=\"n\">name</span> <span class=\"n\">bi</span> <span class=\"n\">ty</span> <span class=\"n\">body</span>\n<span class=\"bp\">|</span> <span class=\"n\">e</span><span class=\"bp\">@</span><span class=\"o\">(</span><span class=\"n\">app</span> <span class=\"o\">(</span><span class=\"n\">app</span> <span class=\"n\">eq</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">do</span>\n    <span class=\"n\">mvars</span> <span class=\"err\">←</span> <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">mk_mvar_list</span> <span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">get_free_var_range</span><span class=\"o\">,</span>\n    <span class=\"n\">l</span> <span class=\"err\">←</span> <span class=\"n\">inline_body</span> <span class=\"o\">(</span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">instantiate_vars</span> <span class=\"n\">mvars</span><span class=\"o\">),</span>\n    <span class=\"n\">eq_proof</span> <span class=\"n\">eq</span> <span class=\"n\">l</span> <span class=\"o\">(</span><span class=\"n\">r</span><span class=\"bp\">.</span><span class=\"n\">instantiate_vars</span> <span class=\"n\">mvars</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">e</span> <span class=\"o\">:=</span> <span class=\"n\">do</span>\n    <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">trace</span> <span class=\"n\">e</span><span class=\"o\">,</span>\n    <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">fail</span> <span class=\"s2\">&quot;cannot synthesize equality proof.&quot;</span>\n\n<span class=\"n\">meta</span> <span class=\"n\">def</span> <span class=\"n\">my_tac2</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">unit</span> <span class=\"o\">:=</span>\n<span class=\"n\">do</span>  <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">target</span>\n    <span class=\"bp\">&gt;&gt;=</span> <span class=\"n\">pattern_match_proof</span>\n    <span class=\"bp\">&gt;&gt;=</span> <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">instantiate_mvars</span>\n    <span class=\"bp\">&gt;&gt;=</span> <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">exact</span>\n</code></pre></div>",
        "id": 203341166,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594256093
    },
    {
        "content": "<p>here's what I have so far. It takes care of quantifiers, can use whatever was already available in the context, so it doesn't have to match the spec exactly.</p>",
        "id": 203341182,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594256131
    },
    {
        "content": "<p>i'm at a point, where it doesn't  go further somewhere deeply nested.</p>",
        "id": 203341231,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594256171
    },
    {
        "content": "<p>I think, I need to pass the types along with meta vars.</p>",
        "id": 203341244,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594256199
    },
    {
        "content": "<p>because bound quantifiers turn to de Bruijn vars and I can't reduce using them.</p>",
        "id": 203341256,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594256224
    },
    {
        "content": "<p>Right but is there an example where you can use that, no matter how simple, that shows what it does?</p>",
        "id": 203341260,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1594256228
    },
    {
        "content": "<p>e.g this. Given the goal: </p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"err\">⊢</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">node</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">node</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">node</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">node</span> <span class=\"n\">α</span><span class=\"o\">),</span>\n    <span class=\"n\">balance</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">black</span> <span class=\"o\">(</span><span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">red</span> <span class=\"o\">(</span><span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">red</span> <span class=\"n\">a</span> <span class=\"n\">x</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">y</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"n\">z</span> <span class=\"n\">d</span> <span class=\"bp\">=</span>\n      <span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">red</span> <span class=\"o\">(</span><span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">black</span> <span class=\"n\">a</span> <span class=\"n\">x</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">y</span> <span class=\"o\">(</span><span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">tree</span> <span class=\"n\">color</span><span class=\"bp\">.</span><span class=\"n\">black</span> <span class=\"n\">c</span> <span class=\"n\">z</span> <span class=\"n\">d</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 203341331,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594256319
    },
    {
        "content": "<p>it infers the source code of balance, gets rid of quantifiers.</p>",
        "id": 203341364,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594256372
    },
    {
        "content": "<p>but it doesn't finish and so I dont get a proof, i.e. it doesn't type check.</p>",
        "id": 203341387,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594256402
    },
    {
        "content": "<p>lemme construct an example that should go through.</p>",
        "id": 203341449,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594256437
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">def</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"bp\">ℕ</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span>\n<span class=\"bp\">|</span> <span class=\"mi\">1</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span>\n<span class=\"bp\">|</span> <span class=\"n\">n</span> <span class=\"mi\">4</span> <span class=\"o\">:=</span> <span class=\"mi\">2</span>\n<span class=\"bp\">|</span> <span class=\"n\">n</span> <span class=\"mi\">3</span> <span class=\"o\">:=</span> <span class=\"mi\">2</span>\n<span class=\"bp\">|</span> <span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">foo</span> <span class=\"n\">x</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n    <span class=\"n\">my_tac2</span>\n<span class=\"kn\">end</span>\n</code></pre></div>",
        "id": 203341803,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594256781
    },
    {
        "content": "<p>this example, it does some work and gets stuck where I need to call rec</p>",
        "id": 203341813,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594256807
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">decidable</span> <span class=\"o\">(</span><span class=\"err\">?</span><span class=\"n\">m_1</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)),</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">decidable</span> <span class=\"o\">(</span><span class=\"err\">?</span><span class=\"n\">m_1</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)),</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"n\">n</span>\n<span class=\"n\">decidable</span><span class=\"bp\">.</span><span class=\"n\">rec</span>\n  <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">hnc</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"err\">?</span><span class=\"n\">m_1</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">),</span>\n     <span class=\"n\">ite</span> <span class=\"o\">(</span><span class=\"err\">?</span><span class=\"n\">m_1</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n       <span class=\"o\">(</span><span class=\"n\">ite</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">id_rhs</span> <span class=\"bp\">ℕ</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ite</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">4</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">id_rhs</span> <span class=\"bp\">ℕ</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ite</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">id_rhs</span> <span class=\"bp\">ℕ</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">id_rhs</span> <span class=\"bp\">ℕ</span> <span class=\"mi\">1</span><span class=\"o\">))))</span>\n       <span class=\"o\">(</span><span class=\"n\">ite</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">4</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">id_rhs</span> <span class=\"bp\">ℕ</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ite</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">id_rhs</span> <span class=\"bp\">ℕ</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">id_rhs</span> <span class=\"bp\">ℕ</span> <span class=\"mi\">1</span><span class=\"o\">))))</span>\n  <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">hc</span> <span class=\"o\">:</span> <span class=\"err\">?</span><span class=\"n\">m_1</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">),</span>\n     <span class=\"n\">ite</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">id_rhs</span> <span class=\"bp\">ℕ</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ite</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">4</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">id_rhs</span> <span class=\"bp\">ℕ</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ite</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">id_rhs</span> <span class=\"bp\">ℕ</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">id_rhs</span> <span class=\"bp\">ℕ</span> <span class=\"mi\">1</span><span class=\"o\">))))</span>\n<span class=\"mi\">1</span>\n</code></pre></div>",
        "id": 203341823,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594256822
    },
    {
        "content": "<p>so it does the unfolding, the quantifiers and introduces meta vars.</p>",
        "id": 203341857,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594256863
    },
    {
        "content": "<p>oh and btw all that from the prop.</p>",
        "id": 203341912,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594256891
    },
    {
        "content": "<p>what I'm not quite sure is a great idea is building the lambda terms directly by hand.</p>",
        "id": 203342102,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594257098
    },
    {
        "content": "<p>in a sense, it might be easier to use the local context.</p>",
        "id": 203342111,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594257117
    },
    {
        "content": "<p>What do you mean by \"building the lambda term by hand\" vs \"using the local context\"?</p>",
        "id": 203342426,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1594257480
    },
    {
        "content": "<p>the way how this works is done by a recursive descent through the lambda. The effect being, that I have to do all term manipulation myself. Whereas many other tactics define local constants, goals, etc.</p>",
        "id": 203342495,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594257558
    },
    {
        "content": "<p>Right so that's the difference between a stateful versus functional approach. Stateful is especially useful when you want to use pieces of the API like <code>induction</code>. Even that part of the API should become more functional in Lean 4</p>",
        "id": 203342574,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1594257678
    },
    {
        "content": "<p>In a sense, we've gone full circle at this point, lol. The whole discussion started with wanting to have a tactic that can solve these pattern match cases. Then we found that using some combinators you can script it and solve the problem, but it's somewhat unsatisfying.</p>",
        "id": 203342666,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594257811
    },
    {
        "content": "<p>Then we had the idea of an iductively defined prop which pretty much needs the low-level api</p>",
        "id": 203342677,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594257832
    },
    {
        "content": "<p>and now this approach is back to more like just a tactic script.</p>",
        "id": 203342728,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1594257850
    }
]
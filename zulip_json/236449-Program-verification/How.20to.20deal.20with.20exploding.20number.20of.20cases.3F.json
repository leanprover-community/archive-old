[
    {
        "content": "<p>I'm trying to port a proof I did about rb-tree earlier in F* to lean as an exercise. (<a href=\"https://github.com/FStarLang/FStar/blob/master/examples/data_structures/RBTreeIntrinsic.fst\">Original</a>)</p>\n<p>The main insertion algorithm is this</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">mutual</span> <span class=\"n\">def</span> <span class=\"n\">ins</span><span class=\"o\">,</span> <span class=\"n\">insB</span>\n<span class=\"k\">with</span> <span class=\"n\">ins</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">h</span> <span class=\"n\">col</span><span class=\"o\">},</span> <span class=\"bp\">ℤ</span> <span class=\"bp\">→</span> <span class=\"n\">rbnode&#39;</span> <span class=\"n\">h</span> <span class=\"n\">col</span> <span class=\"bp\">→</span> <span class=\"n\">almost_node</span> <span class=\"n\">h</span>\n<span class=\"bp\">|</span> <span class=\"bp\">._</span> <span class=\"bp\">._</span> <span class=\"n\">x</span> <span class=\"n\">E</span> <span class=\"o\">:=</span> <span class=\"n\">V</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">E</span> <span class=\"n\">x</span> <span class=\"n\">E</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"bp\">._</span> <span class=\"bp\">._</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"n\">a</span> <span class=\"n\">y</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n    <span class=\"k\">if</span> <span class=\"n\">x</span> <span class=\"bp\">&lt;</span> <span class=\"n\">y</span> <span class=\"k\">then</span>\n        <span class=\"k\">match</span> <span class=\"n\">balance_lb</span> <span class=\"o\">(</span><span class=\"n\">ins</span> <span class=\"n\">x</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">y</span> <span class=\"n\">b</span> <span class=\"k\">with</span>\n        <span class=\"bp\">|</span> <span class=\"n\">HR</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"n\">V</span> <span class=\"n\">r</span>\n        <span class=\"bp\">|</span> <span class=\"n\">HB</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">V</span> <span class=\"n\">b</span>\n        <span class=\"kn\">end</span>\n    <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span> <span class=\"k\">then</span> <span class=\"n\">V</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"n\">a</span> <span class=\"n\">y</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n    <span class=\"k\">else</span>\n        <span class=\"k\">match</span> <span class=\"n\">balance_rb</span> <span class=\"n\">a</span> <span class=\"n\">y</span> <span class=\"o\">(</span><span class=\"n\">ins</span> <span class=\"n\">x</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"k\">with</span>\n        <span class=\"bp\">|</span> <span class=\"n\">HR</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"n\">V</span> <span class=\"n\">r</span>\n        <span class=\"bp\">|</span> <span class=\"n\">HB</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">V</span> <span class=\"n\">b</span>\n        <span class=\"kn\">end</span>\n<span class=\"bp\">|</span> <span class=\"bp\">._</span> <span class=\"bp\">._</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">a</span> <span class=\"n\">y</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n    <span class=\"k\">if</span> <span class=\"n\">x</span> <span class=\"bp\">&lt;</span> <span class=\"n\">y</span> <span class=\"k\">then</span> <span class=\"n\">balance_lr</span> <span class=\"o\">(</span><span class=\"n\">insB</span> <span class=\"n\">x</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">y</span> <span class=\"n\">b</span>\n    <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span> <span class=\"k\">then</span> <span class=\"n\">V</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">a</span> <span class=\"n\">y</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n    <span class=\"k\">else</span> <span class=\"n\">balance_rr</span> <span class=\"n\">a</span> <span class=\"n\">y</span> <span class=\"o\">(</span><span class=\"n\">insB</span> <span class=\"n\">x</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n<span class=\"k\">with</span> <span class=\"n\">insB</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">h</span><span class=\"o\">},</span> <span class=\"bp\">ℤ</span> <span class=\"bp\">→</span> <span class=\"n\">rbnode&#39;</span> <span class=\"n\">h</span> <span class=\"n\">black</span> <span class=\"bp\">→</span> <span class=\"n\">hidden_tree</span> <span class=\"n\">h</span>\n<span class=\"bp\">|</span> <span class=\"bp\">._</span> <span class=\"n\">x</span> <span class=\"n\">E</span> <span class=\"o\">:=</span> <span class=\"n\">HR</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">E</span> <span class=\"n\">x</span> <span class=\"n\">E</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"bp\">._</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"n\">a</span> <span class=\"n\">y</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n    <span class=\"k\">if</span> <span class=\"n\">x</span> <span class=\"bp\">&lt;</span> <span class=\"n\">y</span> <span class=\"k\">then</span> <span class=\"n\">balance_lb</span> <span class=\"o\">(</span><span class=\"n\">ins</span> <span class=\"n\">x</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">y</span> <span class=\"n\">b</span>\n    <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span> <span class=\"k\">then</span> <span class=\"n\">HB</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"n\">a</span> <span class=\"n\">y</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n    <span class=\"k\">else</span> <span class=\"n\">balance_rb</span> <span class=\"n\">a</span> <span class=\"n\">y</span> <span class=\"o\">(</span><span class=\"n\">ins</span> <span class=\"n\">x</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n</code></pre></div>\n\n\n<p>the lemma i solved previously is this:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">mutual</span> <span class=\"kn\">theorem</span> <span class=\"n\">ins_mem</span><span class=\"o\">,</span> <span class=\"n\">insB_mem</span>\n<span class=\"k\">with</span> <span class=\"n\">ins_mem</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">h</span> <span class=\"n\">c</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">rbnode&#39;</span> <span class=\"n\">h</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">),</span>\n    <span class=\"n\">mem</span> <span class=\"n\">z</span> <span class=\"n\">s</span> <span class=\"bp\">∨</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"bp\">↔</span> <span class=\"n\">almost_node_mem</span> <span class=\"n\">z</span> <span class=\"o\">(</span><span class=\"n\">ins</span> <span class=\"n\">x</span> <span class=\"n\">s</span><span class=\"o\">)</span>\n<span class=\"bp\">...</span>\n<span class=\"k\">with</span> <span class=\"n\">insB_mem</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">h</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">rbnode&#39;</span> <span class=\"n\">h</span> <span class=\"n\">black</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">),</span>\n    <span class=\"n\">mem</span> <span class=\"n\">z</span> <span class=\"n\">s</span> <span class=\"bp\">∨</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"bp\">↔</span> <span class=\"n\">hidden_tree_mem</span> <span class=\"n\">z</span> <span class=\"o\">(</span><span class=\"n\">insB</span> <span class=\"n\">x</span> <span class=\"n\">s</span><span class=\"o\">)</span>\n</code></pre></div>\n\n\n<p>If you need the details, the full file is attached. But I do have a question; the proof is a real 200-line mess of dozens of trivial and semi-trivial cases and it takes half a minute just to typecheck. How are we meant to prove properties about programs realistically? Given that programs routinely have a good degree of cyclomatic complexity.</p>\n<p>The equivalent F* proof looks like this:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">val</span> <span class=\"n\">insB_mem</span> <span class=\"o\">:</span> <span class=\"bp\">#</span><span class=\"n\">h</span><span class=\"o\">:</span><span class=\"n\">nat</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">int</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">s</span><span class=\"o\">:</span><span class=\"n\">rbnode</span> <span class=\"n\">h</span> <span class=\"n\">Black</span> <span class=\"bp\">-&gt;</span>\n  <span class=\"n\">Lemma</span> <span class=\"o\">(</span><span class=\"n\">ensures</span> <span class=\"k\">forall</span> <span class=\"n\">y</span><span class=\"bp\">.</span> <span class=\"o\">(</span><span class=\"n\">mem</span> <span class=\"n\">y</span> <span class=\"n\">s</span> <span class=\"bp\">\\/</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">&lt;==&gt;</span> <span class=\"n\">hiddenTree_mem</span> <span class=\"n\">y</span> <span class=\"o\">(</span><span class=\"n\">insB</span> <span class=\"n\">x</span> <span class=\"n\">s</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">decreases</span> <span class=\"n\">s</span><span class=\"o\">)</span>\n\n<span class=\"k\">let</span> <span class=\"n\">rec</span> <span class=\"n\">ins_mem</span> <span class=\"bp\">#</span><span class=\"n\">h</span> <span class=\"bp\">#</span><span class=\"n\">c</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">function</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Leaf</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">()</span>\n  <span class=\"bp\">|</span> <span class=\"n\">B</span> <span class=\"n\">a</span> <span class=\"n\">y</span> <span class=\"n\">b</span> <span class=\"bp\">-&gt;</span>\n    <span class=\"k\">if</span> <span class=\"n\">x</span> <span class=\"bp\">&lt;</span> <span class=\"n\">y</span> <span class=\"k\">then</span> <span class=\"n\">ins_mem</span> <span class=\"n\">x</span> <span class=\"n\">a</span>\n    <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span> <span class=\"k\">then</span> <span class=\"o\">()</span>\n    <span class=\"k\">else</span> <span class=\"n\">ins_mem</span> <span class=\"n\">x</span> <span class=\"n\">b</span>\n  <span class=\"bp\">|</span> <span class=\"n\">R</span> <span class=\"n\">a</span> <span class=\"n\">y</span> <span class=\"n\">b</span> <span class=\"bp\">-&gt;</span>\n    <span class=\"k\">if</span> <span class=\"n\">x</span> <span class=\"bp\">&lt;</span> <span class=\"n\">y</span> <span class=\"k\">then</span> <span class=\"n\">insB_mem</span> <span class=\"n\">x</span> <span class=\"n\">a</span>\n    <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span> <span class=\"k\">then</span> <span class=\"o\">()</span>\n    <span class=\"k\">else</span> <span class=\"n\">insB_mem</span> <span class=\"n\">x</span> <span class=\"n\">b</span>\n<span class=\"n\">and</span> <span class=\"n\">insB_mem</span> <span class=\"bp\">#</span><span class=\"n\">h</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">function</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Leaf</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">()</span>\n  <span class=\"bp\">|</span> <span class=\"n\">B</span> <span class=\"n\">a</span> <span class=\"n\">y</span> <span class=\"n\">b</span> <span class=\"bp\">-&gt;</span>\n    <span class=\"k\">if</span> <span class=\"n\">x</span> <span class=\"bp\">&lt;</span> <span class=\"n\">y</span> <span class=\"k\">then</span> <span class=\"n\">ins_mem</span> <span class=\"n\">x</span> <span class=\"n\">a</span>\n    <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span> <span class=\"k\">then</span> <span class=\"o\">()</span>\n    <span class=\"k\">else</span> <span class=\"n\">ins_mem</span> <span class=\"n\">x</span> <span class=\"n\">b</span>\n</code></pre></div>\n\n\n<p>it still captures the relevant cases and shows how to recursively apply the IH and all. Now you'd of course expect a bit more automation from a Z3-backed theorem prover, but I think I'm doing something wrong that it would be 200+ lines.<br>\n<a href=\"/user_uploads/3121/eqEv3-I43TDr9iUphL0kdRHG/rbtree_intrinsic.lean\">rbtree_intrinsic.lean</a></p>",
        "id": 202208189,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593297424
    },
    {
        "content": "<p>I think it's a lot of different habits that would make your proofs shorter. For instance, <code>simp</code> is the swiss knife of Lean. Instead of calling <code>unfold</code> several times, you can use <code>simp</code> to unfold all of them (in one call). Actually you could also make only one <code>unfold</code> call. <code>simp</code> also does some rewriting using its arguments and with the <code>simp</code> list which is a good thing to cultivate. Tag some of your lemmas with <code>simp</code> to make your future proofs simpler</p>",
        "id": 202209406,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1593299692
    },
    {
        "content": "<p>For propositional reasoning, <code>tauto!</code> might be the first thing to consider but <code>finish</code> and <code>solve_by_elim</code> can also be useful. <code>solve_by_elim</code> does a more limited kind of reasoning but, unlike <code>tauto</code>, it brings in theorems</p>",
        "id": 202209423,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1593299762
    },
    {
        "content": "<p>interesting, I usually was trying to avoid calling <code>simp</code> on intermediate steps because I read it's meant to make proofs brittle. Would it be fine to do something like <code>simp</code>,..., <code>simp</code>, ..., <code>simp</code>?</p>",
        "id": 202210079,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593300948
    },
    {
        "content": "<p>I am sometimes a bit reckless with <code>simp</code> but I think the accepted practices is to write:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">suffices</span> <span class=\"o\">:</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">simp</span><span class=\"o\">,</span>\n</code></pre></div>",
        "id": 202210325,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1593301357
    },
    {
        "content": "<p>I think already <code>simp only</code> (for which <code>squeeze_simp</code> can help you come up with the right list of lemmas) makes things more robust.</p>",
        "id": 202210336,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1593301393
    },
    {
        "content": "<p>ah yes, that's better. thx</p>",
        "id": 202210391,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1593301486
    },
    {
        "content": "<p>It might also be that <code>by {[smt] eblast }</code> could be useful. We should ask <span class=\"user-mention\" data-user-id=\"116045\">@Jesse Michael Han</span> to write us a tutorial about how to choose <code>ematch</code> lemmas</p>",
        "id": 202247537,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1593367658
    }
]
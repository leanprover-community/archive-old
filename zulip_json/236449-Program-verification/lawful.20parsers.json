[
    {
        "content": "<p>Is there a parser (that is used) that violates this condition?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.nat.cast</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.fintype.card</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">parse_result</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">parser</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">cb</span> <span class=\"o\">:</span> <span class=\"n\">char_buffer</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"n\">n'</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">err</span> <span class=\"o\">:</span> <span class=\"n\">dlist</span> <span class=\"n\">string</span><span class=\"o\">)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">valid_parser_of_fail</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">err</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">cb</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">fail</span> <span class=\"n\">n'</span> <span class=\"n\">err</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">n'</span> <span class=\"bp\">≤</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</code></pre></div>",
        "id": 219419246,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1607560239
    },
    {
        "content": "<p>The larger <a href=\"https://en.wikipedia.org/wiki/XY_problem\">#xy</a> is trying to prove the following somewhat-definitional lemma about the alternative definition on parsers. I have the associated one done for <code>done</code> </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">orelse_eq_done</span> <span class=\"o\">{</span><span class=\"n\">n'</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">&lt;|&gt;</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"n\">cb</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">done</span> <span class=\"n\">n'</span> <span class=\"n\">a</span> <span class=\"bp\">↔</span>\n  <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">cb</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">done</span> <span class=\"n\">n'</span> <span class=\"n\">a</span> <span class=\"bp\">∨</span> <span class=\"o\">((</span><span class=\"bp\">∃</span> <span class=\"n\">err</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">cb</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">fail</span> <span class=\"n\">n</span> <span class=\"n\">err</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"n\">q</span> <span class=\"n\">cb</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">done</span> <span class=\"n\">n'</span> <span class=\"n\">a</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span>\n</code></pre></div>\n<p>but have hit a snag on the case shown below for the <code>fail</code> case. If this the validity statement above is true, the whole proof can be much simpler. But I've identified precisely where I hit a contradiction when there is no validity guarantee.</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>Longer proof</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.nat.cast</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.fintype.card</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">parse_result</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">parser</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">cb</span> <span class=\"o\">:</span> <span class=\"n\">char_buffer</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"n\">n'</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">err</span> <span class=\"o\">:</span> <span class=\"n\">dlist</span> <span class=\"n\">string</span><span class=\"o\">)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">valid_parser_of_fail</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">err</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">cb</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">fail</span> <span class=\"n\">n'</span> <span class=\"n\">err</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">n'</span> <span class=\"bp\">≤</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">orelse_eq_orelse</span> <span class=\"o\">:</span> <span class=\"n\">p.orelse</span> <span class=\"n\">q</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">&lt;|&gt;</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">orelse_eq_fail_le</span> <span class=\"o\">{</span><span class=\"n\">n'</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">&lt;|&gt;</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"n\">cb</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">fail</span> <span class=\"n\">n'</span> <span class=\"n\">err</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">n'</span> <span class=\"bp\">≤</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">contrapose</span><span class=\"bp\">!</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"bp\">←</span><span class=\"n\">orelse_eq_orelse</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">parser.orelse</span><span class=\"o\">,</span> <span class=\"n\">exists_and_distrib_left</span><span class=\"o\">],</span>\n  <span class=\"n\">set</span> <span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">parse_result</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">p</span> <span class=\"n\">cb</span> <span class=\"n\">n</span> <span class=\"k\">with</span> <span class=\"n\">hP</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">p</span> <span class=\"n\">cb</span> <span class=\"n\">n</span> <span class=\"k\">with</span> <span class=\"n\">posp</span> <span class=\"n\">resp</span> <span class=\"n\">posp</span> <span class=\"n\">errp</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">parser.orelse</span><span class=\"o\">,</span> <span class=\"n\">exists_false</span><span class=\"o\">,</span> <span class=\"n\">or_self</span><span class=\"o\">,</span> <span class=\"n\">and_false</span><span class=\"o\">,</span> <span class=\"n\">hP</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n  <span class=\"n\">by_cases</span> <span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"n\">posp</span> <span class=\"bp\">=</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">hp</span><span class=\"o\">,</span> <span class=\"n\">parser.orelse</span><span class=\"o\">,</span> <span class=\"n\">true_and</span><span class=\"o\">,</span> <span class=\"n\">eq_self_iff_true</span><span class=\"o\">,</span> <span class=\"n\">not_true</span><span class=\"o\">,</span> <span class=\"n\">if_false</span><span class=\"o\">,</span> <span class=\"n\">ne.def</span><span class=\"o\">,</span>\n               <span class=\"n\">and_true</span><span class=\"o\">,</span> <span class=\"n\">false_or</span><span class=\"o\">,</span> <span class=\"n\">exists_eq'</span><span class=\"o\">,</span> <span class=\"n\">false_and</span><span class=\"o\">,</span> <span class=\"n\">hP</span><span class=\"o\">],</span>\n    <span class=\"n\">cases</span> <span class=\"n\">q</span> <span class=\"n\">cb</span> <span class=\"n\">n</span> <span class=\"k\">with</span> <span class=\"n\">posq</span> <span class=\"n\">resq</span> <span class=\"n\">posq</span> <span class=\"n\">errq</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">parser.orelse</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">parser.orelse</span><span class=\"o\">],</span>\n      <span class=\"n\">split_ifs</span> <span class=\"k\">with</span> <span class=\"n\">H</span> <span class=\"n\">H'</span><span class=\"o\">,</span>\n      <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">ne_of_lt</span> <span class=\"n\">h</span><span class=\"o\">],</span> <span class=\"o\">},</span>\n      <span class=\"o\">{</span>\n        <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">posq</span> <span class=\"bp\">≠</span> <span class=\"n\">n'</span> <span class=\"o\">:=</span> <span class=\"n\">ne_of_lt</span> <span class=\"o\">(</span><span class=\"n\">lt_trans</span> <span class=\"n\">H'</span> <span class=\"n\">h</span><span class=\"o\">),</span>\n        <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">this</span><span class=\"o\">,</span> <span class=\"n\">iff_self</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n      <span class=\"o\">{</span> <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">posq</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">le_antisymm</span> <span class=\"o\">(</span><span class=\"n\">le_of_not_lt</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">le_of_not_lt</span> <span class=\"n\">H'</span><span class=\"o\">),</span>\n        <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">ne_of_lt</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">this</span><span class=\"o\">,</span> <span class=\"n\">false_and</span><span class=\"o\">],</span> <span class=\"o\">}</span> <span class=\"o\">}</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rcases</span> <span class=\"n\">lt_trichotomy</span> <span class=\"n\">posp</span> <span class=\"n\">n'</span> <span class=\"k\">with</span> <span class=\"n\">H</span><span class=\"bp\">|</span><span class=\"n\">H</span><span class=\"bp\">|</span><span class=\"n\">H</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">parser.orelse</span><span class=\"o\">,</span> <span class=\"n\">hp</span><span class=\"o\">,</span> <span class=\"n\">ne_of_lt</span> <span class=\"n\">H</span><span class=\"o\">,</span> <span class=\"n\">hP</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">parser.orelse</span><span class=\"o\">,</span> <span class=\"n\">hp</span><span class=\"o\">,</span> <span class=\"bp\">←</span><span class=\"n\">H</span><span class=\"o\">],</span>\n      <span class=\"c1\">-- this is the case where p cb n = p posp errp, and posp = n',</span>\n      <span class=\"c1\">-- so err should equal errp, since by defn of (p cb n &lt;|&gt;) propagates</span>\n      <span class=\"c1\">-- the errp to equal err when n ≠ posp</span>\n      <span class=\"c1\">-- this case needs valid_parser_if fail to show that the `err`s MUST match</span>\n      <span class=\"c1\">-- and somehow prove this false</span>\n      <span class=\"c1\">-- by already knowing that n' ≤ n</span>\n      <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">n'</span> <span class=\"bp\">≤</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n        <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"n\">valid_parser_of_fail</span> <span class=\"n\">p</span> <span class=\"n\">cb</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n          <span class=\"n\">use</span> <span class=\"n\">errp</span><span class=\"o\">,</span>\n          <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">H</span><span class=\"o\">,</span> <span class=\"bp\">←</span><span class=\"n\">hP</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n      <span class=\"n\">exact</span> <span class=\"n\">absurd</span> <span class=\"n\">this</span> <span class=\"o\">(</span><span class=\"n\">not_le_of_lt</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">parser.orelse</span><span class=\"o\">,</span> <span class=\"n\">hp</span><span class=\"o\">,</span> <span class=\"n\">ne_of_gt</span> <span class=\"n\">H</span><span class=\"o\">,</span> <span class=\"n\">hP</span><span class=\"o\">]</span> <span class=\"o\">}</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n</div></div>",
        "id": 219419387,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1607560367
    },
    {
        "content": "<p>If there is a more appropriate stream, like <a class=\"stream\" data-stream-id=\"239415\" href=\"/#narrow/stream/239415-metaprogramming-.2F-tactics\">#metaprogramming / tactics</a> , please let me know.</p>",
        "id": 219419541,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1607560500
    },
    {
        "content": "<p>The even larger <a href=\"https://en.wikipedia.org/wiki/XY_problem\">#xy</a> is trying to parse directly into subtypes, which requires proofs that a particular parser is unable to produce certain states.</p>",
        "id": 219419575,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1607560544
    },
    {
        "content": "<p>Of course, the subtype problem doesn't require a clear proof about how consistently <code>orelse</code> produces <code>fail</code> states, but I'm trying to be thorough in building out the theory.</p>",
        "id": 219419690,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1607560636
    },
    {
        "content": "<p>Of course <code>parser</code> has no such assumption, so there are parsers that fail it</p>",
        "id": 219446562,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607591241
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">not_valid_parser_of_fail</span> <span class=\"o\">:</span>\n  <span class=\"bp\">¬</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">parser</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">cb</span> <span class=\"o\">:</span> <span class=\"n\">char_buffer</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"n\">n'</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">err</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">cb</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">fail</span> <span class=\"n\">n'</span> <span class=\"n\">err</span><span class=\"o\">),</span> <span class=\"n\">n'</span> <span class=\"bp\">≤</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">H</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">cases</span> <span class=\"bp\">@</span><span class=\"n\">H</span> <span class=\"n\">unit</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">fail</span> <span class=\"mi\">1</span> <span class=\"n\">dlist.empty</span><span class=\"o\">)</span> <span class=\"n\">buffer.nil</span> <span class=\"mi\">0</span> <span class=\"mi\">1</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span>\n</code></pre></div>",
        "id": 219446991,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607591509
    },
    {
        "content": "<p>Thanks. So I have defined a separate Prop that can label a <code>parser</code> as <code>valid</code> in this way, and, for example, have that:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[simp]</span> <span class=\"kd\">def</span> <span class=\"n\">valid</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">∀</span> <span class=\"o\">⦃</span><span class=\"n\">cb</span> <span class=\"o\">:</span> <span class=\"n\">char_buffer</span><span class=\"o\">⦄</span> <span class=\"o\">⦃</span><span class=\"n\">n</span> <span class=\"n\">n'</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">⦄</span> <span class=\"o\">⦃</span><span class=\"n\">err</span> <span class=\"o\">:</span> <span class=\"n\">dlist</span> <span class=\"n\">string</span><span class=\"o\">⦄,</span> <span class=\"n\">p</span> <span class=\"n\">cb</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">fail</span> <span class=\"n\">n'</span> <span class=\"n\">err</span> <span class=\"bp\">→</span> <span class=\"n\">n'</span> <span class=\"bp\">≤</span> <span class=\"n\">n</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">orelse_valid</span> <span class=\"o\">(</span><span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"n\">p.valid</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hq</span> <span class=\"o\">:</span> <span class=\"n\">q.valid</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">&lt;|&gt;</span> <span class=\"n\">q</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">valid</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span>\n</code></pre></div>",
        "id": 219447362,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1607591730
    },
    {
        "content": "<p>But are there parsers that are in use often that break this assumption? <code>failure</code> is <code>valid</code>, for example. One could write a parser that always fails, and reports the error as having had occurred at a position greater than what was queried. But are such parsers useful, or are totally pathological?</p>",
        "id": 219447530,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1607591829
    },
    {
        "content": "<p>I was surprised to see that <code>decorate_error(s)</code> completely ignores where the error has occurred, and instead reports the error at the position of the query.</p>",
        "id": 219447577,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1607591864
    },
    {
        "content": "<p>er, actually that condition is the wrong way around, reasonable parsers do this all the time</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">not_valid_parser_of_fail</span> <span class=\"o\">:</span>\n  <span class=\"bp\">¬</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">parser</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">cb</span> <span class=\"o\">:</span> <span class=\"n\">char_buffer</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"n\">n'</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">err</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">cb</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">fail</span> <span class=\"n\">n'</span> <span class=\"n\">err</span><span class=\"o\">),</span> <span class=\"n\">n'</span> <span class=\"bp\">≤</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">H</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">cases</span> <span class=\"bp\">@</span><span class=\"n\">H</span> <span class=\"n\">unit</span> <span class=\"o\">(</span><span class=\"n\">parser.sat</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">true</span><span class=\"o\">)</span> <span class=\"bp\">&gt;&gt;</span> <span class=\"n\">failure</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"sc\">' '</span><span class=\"o\">]</span><span class=\"bp\">.</span><span class=\"n\">to_buffer</span> <span class=\"mi\">0</span> <span class=\"mi\">1</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span>\n</code></pre></div>",
        "id": 219447667,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607591898
    },
    {
        "content": "<p>So, for <code>decorate_error msg p cb n = fail n' err -&gt; n = n'</code></p>",
        "id": 219447736,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1607591947
    },
    {
        "content": "<p>It seems more likely that valid parsers satisfy <code> p cb n = fail n' err -&gt; n &lt;= n'</code></p>",
        "id": 219447826,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607591999
    },
    {
        "content": "<p>the return value is supposed to mean \"I was successful up to here\" so it makes sense that you wouldn't go before the start point</p>",
        "id": 219447973,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607592067
    },
    {
        "content": "<p>Yes, <code>valid</code> is not propagated across any <code>&gt;&gt;=</code> operation, because in a <code>p &gt;&gt;= f</code> situation, <code>p</code> can succeed and move the cursor forward, and then the failure is at <code>f</code>.</p>",
        "id": 219447999,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1607592090
    },
    {
        "content": "<p>Hmm.</p>",
        "id": 219448003,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1607592092
    },
    {
        "content": "<p>I have a proof of the following statement, so I need to think about how to modify it:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">orelse_eq_fail_lt</span> <span class=\"o\">(</span><span class=\"n\">hn</span> <span class=\"o\">:</span> <span class=\"n\">n'</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">&lt;|&gt;</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"n\">cb</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">fail</span> <span class=\"n\">n'</span> <span class=\"n\">err</span> <span class=\"bp\">↔</span>\n  <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">cb</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">fail</span> <span class=\"n\">n'</span> <span class=\"n\">err</span><span class=\"o\">)</span> <span class=\"bp\">∨</span>\n  <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"n\">cb</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">fail</span> <span class=\"n\">n'</span> <span class=\"n\">err</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">errp</span><span class=\"o\">),</span> <span class=\"n\">p</span> <span class=\"n\">cb</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">fail</span> <span class=\"n\">n</span> <span class=\"n\">errp</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span>\n</code></pre></div>",
        "id": 219448065,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1607592122
    },
    {
        "content": "<p>a valid parser should never have the hypothesis hn</p>",
        "id": 219448170,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607592180
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">protected</span> <span class=\"kd\">def</span> <span class=\"n\">orelse</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">parser</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">parser</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">input</span> <span class=\"n\">pos</span><span class=\"o\">,</span> <span class=\"k\">match</span> <span class=\"n\">p</span> <span class=\"n\">input</span> <span class=\"n\">pos</span> <span class=\"k\">with</span>\n<span class=\"bp\">|</span> <span class=\"n\">parse_result.fail</span> <span class=\"n\">pos₁</span> <span class=\"n\">expected₁</span> <span class=\"o\">:=</span>\n  <span class=\"k\">if</span> <span class=\"n\">pos₁</span> <span class=\"bp\">≠</span> <span class=\"n\">pos</span> <span class=\"k\">then</span> <span class=\"n\">parse_result.fail</span> <span class=\"n\">pos₁</span> <span class=\"n\">expected₁</span> <span class=\"k\">else</span>\n  <span class=\"k\">match</span> <span class=\"n\">q</span> <span class=\"n\">input</span> <span class=\"n\">pos</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">parse_result.fail</span> <span class=\"n\">pos₂</span> <span class=\"n\">expected₂</span> <span class=\"o\">:=</span>\n    <span class=\"k\">if</span> <span class=\"n\">pos₁</span> <span class=\"bp\">&lt;</span> <span class=\"n\">pos₂</span> <span class=\"k\">then</span>\n      <span class=\"n\">parse_result.fail</span> <span class=\"n\">pos₁</span> <span class=\"n\">expected₁</span>\n    <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"n\">pos₂</span> <span class=\"bp\">&lt;</span> <span class=\"n\">pos₁</span> <span class=\"k\">then</span>\n      <span class=\"n\">parse_result.fail</span> <span class=\"n\">pos₂</span> <span class=\"n\">expected₂</span> <span class=\"c1\">-- this is the case that you say should never be valid, correct?</span>\n    <span class=\"k\">else</span> <span class=\"c1\">-- pos₁ = pos₂</span>\n      <span class=\"n\">parse_result.fail</span> <span class=\"n\">pos₁</span> <span class=\"o\">(</span><span class=\"n\">expected₁</span> <span class=\"bp\">++</span> <span class=\"n\">expected₂</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">ok</span> <span class=\"o\">:=</span> <span class=\"n\">ok</span>\n  <span class=\"kd\">end</span>\n  <span class=\"bp\">|</span> <span class=\"n\">ok</span> <span class=\"o\">:=</span> <span class=\"n\">ok</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 219448367,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1607592319
    },
    {
        "content": "<p>I find it easier to understand after I rewrite <code>pos1</code> as <code>pos</code> in the <code>pos1 = pos</code> branch:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">protected</span> <span class=\"kd\">def</span> <span class=\"n\">orelse</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">parser</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">parser</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">input</span> <span class=\"n\">pos</span><span class=\"o\">,</span> <span class=\"k\">match</span> <span class=\"n\">p</span> <span class=\"n\">input</span> <span class=\"n\">pos</span> <span class=\"k\">with</span>\n<span class=\"bp\">|</span> <span class=\"n\">parse_result.fail</span> <span class=\"n\">pos₁</span> <span class=\"n\">expected₁</span> <span class=\"o\">:=</span>\n  <span class=\"k\">if</span> <span class=\"n\">pos₁</span> <span class=\"bp\">≠</span> <span class=\"n\">pos</span> <span class=\"k\">then</span> <span class=\"n\">parse_result.fail</span> <span class=\"n\">pos₁</span> <span class=\"n\">expected₁</span> <span class=\"k\">else</span>\n  <span class=\"k\">match</span> <span class=\"n\">q</span> <span class=\"n\">input</span> <span class=\"n\">pos</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">parse_result.fail</span> <span class=\"n\">pos₂</span> <span class=\"n\">expected₂</span> <span class=\"o\">:=</span>\n    <span class=\"k\">if</span> <span class=\"n\">pos</span> <span class=\"bp\">&lt;</span> <span class=\"n\">pos₂</span> <span class=\"k\">then</span>\n      <span class=\"n\">parse_result.fail</span> <span class=\"n\">pos₁</span> <span class=\"n\">expected₁</span>\n    <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"n\">pos₂</span> <span class=\"bp\">&lt;</span> <span class=\"n\">pos</span> <span class=\"k\">then</span>\n      <span class=\"n\">parse_result.fail</span> <span class=\"n\">pos₂</span> <span class=\"n\">expected₂</span> <span class=\"c1\">-- this is the case that you say should never be valid, correct?</span>\n    <span class=\"k\">else</span> <span class=\"c1\">-- pos = pos₂</span>\n      <span class=\"n\">parse_result.fail</span> <span class=\"n\">pos</span> <span class=\"o\">(</span><span class=\"n\">expected₁</span> <span class=\"bp\">++</span> <span class=\"n\">expected₂</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">ok</span> <span class=\"o\">:=</span> <span class=\"n\">ok</span>\n  <span class=\"kd\">end</span>\n  <span class=\"bp\">|</span> <span class=\"n\">ok</span> <span class=\"o\">:=</span> <span class=\"n\">ok</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 219448557,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1607592454
    },
    {
        "content": "<p>I suggest</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">parse_result.pos</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">parse_result</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">parse_result.done</span> <span class=\"n\">pos</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">pos</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">parse_result.fail</span> <span class=\"n\">pos</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">pos</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">parser.valid</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">parser</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"bp\">∀</span> <span class=\"o\">⦃</span><span class=\"n\">cb</span> <span class=\"o\">:</span> <span class=\"n\">char_buffer</span><span class=\"o\">⦄</span> <span class=\"o\">⦃</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">⦄,</span>\n<span class=\"k\">let</span> <span class=\"n\">res</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">cb</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">pos</span> <span class=\"k\">in</span> <span class=\"n\">n</span> <span class=\"bp\">≤</span> <span class=\"n\">res</span> <span class=\"bp\">∧</span> <span class=\"n\">res</span> <span class=\"bp\">≤</span> <span class=\"n\">cb.size</span>\n</code></pre></div>",
        "id": 219448570,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607592461
    },
    {
        "content": "<p>yes, that branch looks like it should not happen</p>",
        "id": 219448774,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607592560
    },
    {
        "content": "<p>But that's the core Lean definition, so in trying to write a simplifying iff lemma for <code>(p &lt;|&gt; q) cb n = fail n' err</code> I need to figure out how to represent that branch.</p>",
        "id": 219448872,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1607592605
    },
    {
        "content": "<p>Oh, another property you can claim is that the parser is extensional wrt values of the char_buffer before <code>n</code></p>",
        "id": 219448928,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607592641
    },
    {
        "content": "<p>Your simplification lemma should assume <code>p</code> and <code>q</code> are valid</p>",
        "id": 219448968,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607592661
    },
    {
        "content": "<p>as long as every core parser satisfies the validity predicate you are licensed to assume it even if it's not in the type</p>",
        "id": 219449029,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607592703
    },
    {
        "content": "<p>Thanks, this is very helpful.</p>",
        "id": 219449046,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1607592716
    },
    {
        "content": "<p>Worth PRing in some part of mathlib, or too program verification-y?</p>",
        "id": 219449104,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1607592736
    },
    {
        "content": "<p>I don't see why those are mutually exclusive</p>",
        "id": 219449123,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607592751
    },
    {
        "content": "<p>I think it would certainly be useful</p>",
        "id": 219449157,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607592778
    },
    {
        "content": "<p>Good to know</p>",
        "id": 219449160,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1607592780
    },
    {
        "content": "<p>I was surprised I couldn't find this anywhere:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">asum</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">alternative</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">α</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"n\">xs.foldl</span> <span class=\"o\">(</span><span class=\"bp\">&lt;|&gt;</span><span class=\"o\">)</span> <span class=\"n\">failure</span>\n</code></pre></div>",
        "id": 219449188,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1607592800
    },
    {
        "content": "<p>have you seen <code>data.hash_map</code>?</p>",
        "id": 219449192,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607592808
    },
    {
        "content": "<p>I think that's called <code>mfirst</code></p>",
        "id": 219449220,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607592829
    },
    {
        "content": "<p>Ah, so it is</p>",
        "id": 219449289,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1607592861
    },
    {
        "content": "<p>I'll take a look at <code>hash_map</code>.</p>",
        "id": 219449336,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1607592887
    },
    {
        "content": "<p>I would like to see more formalized data structures like that one in mathlib</p>",
        "id": 219449374,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607592916
    },
    {
        "content": "<p>there is a long-abandoned mathlib branch called <code>ordmap</code> which formalizes balanced 2-3 trees as an alternative to the broken <code>rbmap</code></p>",
        "id": 219449472,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607592981
    },
    {
        "content": "<p><code>asum = mfirst id</code></p>",
        "id": 219449475,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1607592982
    },
    {
        "content": "<p>But I guess it simplifies things like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">asum</span> <span class=\"o\">(</span><span class=\"n\">ch</span> <span class=\"bp\">&lt;$&gt;</span> <span class=\"o\">[</span><span class=\"sc\">'a'</span><span class=\"o\">,</span> <span class=\"sc\">'b'</span><span class=\"o\">])</span> <span class=\"bp\">=</span> <span class=\"n\">mfirst</span> <span class=\"n\">ch</span> <span class=\"o\">[</span><span class=\"sc\">'a'</span><span class=\"o\">,</span> <span class=\"sc\">'b'</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 219449546,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1607593033
    },
    {
        "content": "<p>it's also more efficient since you don't actually need to build up all the thunks</p>",
        "id": 219449647,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607593085
    },
    {
        "content": "<p>the list can just be the data itself instead of some monad things</p>",
        "id": 219449680,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607593111
    },
    {
        "content": "<p>While we're on this topic, do we have monads in mathlib where <code>&gt;&gt;</code> behaves more efficiently than <code>&gt;&gt;= (λ _, ...)</code>?</p>",
        "id": 219449894,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1607593254
    },
    {
        "content": "<p>Ah..., <code>pure</code> isn't <code>valid</code> by the definition that uses <code>cb.size</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">protected</span> <span class=\"kd\">def</span> <span class=\"n\">pure</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">parser</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">input</span> <span class=\"n\">pos</span><span class=\"o\">,</span> <span class=\"n\">parse_result.done</span> <span class=\"n\">pos</span> <span class=\"n\">a</span>\n</code></pre></div>",
        "id": 219452343,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1607594734
    },
    {
        "content": "<p>Oh, you have to assume <code>pos &lt;= cb.size</code></p>",
        "id": 219456770,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607597499
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">parser.valid</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">parser</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"bp\">∀</span> <span class=\"o\">⦃</span><span class=\"n\">cb</span> <span class=\"o\">:</span> <span class=\"n\">char_buffer</span><span class=\"o\">⦄</span> <span class=\"o\">⦃</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">⦄,</span>\n<span class=\"n\">n</span> <span class=\"bp\">≤</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">cb</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">pos</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">≤</span> <span class=\"n\">cb.size</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">cb</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">pos</span> <span class=\"bp\">≤</span> <span class=\"n\">cb.size</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 219456892,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607597556
    },
    {
        "content": "<p>I think it has to be the other way around in the implication:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">valid</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">cb</span> <span class=\"o\">:</span> <span class=\"n\">char_buffer</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">n</span> <span class=\"bp\">≤</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">cb</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">pos</span> <span class=\"bp\">∧</span> <span class=\"o\">((</span><span class=\"n\">p</span> <span class=\"n\">cb</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">pos</span> <span class=\"bp\">≤</span> <span class=\"n\">cb.size</span> <span class=\"bp\">→</span> <span class=\"n\">n</span> <span class=\"bp\">≤</span> <span class=\"n\">cb.size</span>\n</code></pre></div>",
        "id": 219735736,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1607819339
    }
]
[
    {
        "content": "<p>Is there a type for intervals in a lattice?  This is a way to model minors of a simple graph, where the lower bound is the contracted edges and the upper bound is the edges that haven't been deleted.</p>\n<p>This makes commutativity of contraction and deletion rather straightforward, since it's essentially the fact that inf and sup distribute.</p>\n<p>Then if it's needed, you can realize a minor as a <code>simple_graph</code> by quotienting the upper graph by the lower graph and removing isolated vertices and self loops.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">namespace</span> <span class=\"n\">simple_graph</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">minor</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">le</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">≤</span> <span class=\"n\">B</span><span class=\"o\">)</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"sd\">/-- The minors of a graph are those that are contained withn it. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">minors</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">minor</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"bp\">|</span> <span class=\"n\">M.B</span> <span class=\"bp\">≤</span> <span class=\"n\">G</span><span class=\"o\">}</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">minor</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">}</span>\n\n<span class=\"sd\">/-- The vertex type for the realization of a minor is the support of the</span>\n<span class=\"sd\">top graph modulo the adjacency relation of the bottom graph. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">realize_verts</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">minor</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">quot</span> <span class=\"n\">M.B.support</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"n\">M.A.adj</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- Realize the minor as a simple graph, deleting all isolated vertices and self-loops that would form. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">realize</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">minor</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">M.realize_verts</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">adj</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"n\">v</span> <span class=\"bp\">≠</span> <span class=\"n\">w</span> <span class=\"bp\">∧</span> <span class=\"bp\">∃</span> <span class=\"n\">v'</span> <span class=\"n\">w'</span><span class=\"o\">,</span> <span class=\"n\">quot.mk</span> <span class=\"n\">_</span> <span class=\"n\">v'</span> <span class=\"bp\">=</span> <span class=\"n\">v</span> <span class=\"bp\">∧</span> <span class=\"n\">quot.mk</span> <span class=\"n\">_</span> <span class=\"n\">w'</span> <span class=\"bp\">=</span> <span class=\"n\">w</span> <span class=\"bp\">∧</span> <span class=\"n\">M.A.adj</span> <span class=\"n\">v'</span> <span class=\"n\">w'</span><span class=\"o\">,</span>\n  <span class=\"n\">symm</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">intros</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">,</span>\n    <span class=\"n\">dsimp</span><span class=\"o\">,</span>\n    <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">h1</span><span class=\"o\">,</span> <span class=\"n\">h2</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">use</span> <span class=\"n\">ne.symm</span> <span class=\"n\">h1</span><span class=\"o\">,</span>\n    <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">v'</span><span class=\"o\">,</span> <span class=\"n\">w'</span><span class=\"o\">,</span> <span class=\"n\">hv'</span><span class=\"o\">,</span> <span class=\"n\">hw'</span><span class=\"o\">,</span> <span class=\"n\">ha</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">h2</span><span class=\"o\">,</span>\n    <span class=\"n\">use</span> <span class=\"o\">[</span><span class=\"n\">w'</span><span class=\"o\">,</span> <span class=\"n\">v'</span><span class=\"o\">,</span> <span class=\"n\">hw'</span><span class=\"o\">,</span> <span class=\"n\">hv'</span><span class=\"o\">,</span> <span class=\"n\">M.A.symm</span> <span class=\"n\">ha</span><span class=\"o\">],</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">loopless</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">rintros</span> <span class=\"n\">v</span> <span class=\"o\">⟨</span><span class=\"n\">h1</span><span class=\"o\">,</span> <span class=\"n\">h2</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">h1</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n  <span class=\"kd\">end</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">sup</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"n\">M'</span> <span class=\"o\">:</span> <span class=\"n\">minor</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">minor</span> <span class=\"n\">V</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">A</span> <span class=\"o\">:=</span> <span class=\"n\">M.A</span> <span class=\"bp\">⊔</span> <span class=\"n\">M'.A</span><span class=\"o\">,</span>\n  <span class=\"n\">B</span> <span class=\"o\">:=</span> <span class=\"n\">M.B</span> <span class=\"bp\">⊔</span> <span class=\"n\">M'.B</span><span class=\"o\">,</span>\n  <span class=\"n\">le</span> <span class=\"o\">:=</span> <span class=\"n\">sup_le_sup</span> <span class=\"n\">M.le</span> <span class=\"n\">M'.le</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">inf</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"n\">M'</span> <span class=\"o\">:</span> <span class=\"n\">minor</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">minor</span> <span class=\"n\">V</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">A</span> <span class=\"o\">:=</span> <span class=\"n\">M.A</span> <span class=\"bp\">⊓</span> <span class=\"n\">M'.A</span><span class=\"o\">,</span>\n  <span class=\"n\">B</span> <span class=\"o\">:=</span> <span class=\"n\">M.B</span> <span class=\"bp\">⊓</span> <span class=\"n\">M'.B</span><span class=\"o\">,</span>\n  <span class=\"n\">le</span> <span class=\"o\">:=</span> <span class=\"n\">inf_le_inf</span> <span class=\"n\">M.le</span> <span class=\"n\">M'.le</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">compl</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">minor</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">minor</span> <span class=\"n\">V</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">A</span> <span class=\"o\">:=</span> <span class=\"n\">M.B</span><span class=\"bp\">ᶜ</span><span class=\"o\">,</span>\n  <span class=\"n\">B</span> <span class=\"o\">:=</span> <span class=\"n\">M.A</span><span class=\"bp\">ᶜ</span><span class=\"o\">,</span>\n  <span class=\"n\">le</span> <span class=\"o\">:=</span> <span class=\"n\">compl_le_compl</span> <span class=\"n\">M.le</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">incl</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">minor</span> <span class=\"n\">V</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">A</span> <span class=\"o\">:=</span> <span class=\"bp\">⊥</span><span class=\"o\">,</span>\n  <span class=\"n\">B</span> <span class=\"o\">:=</span> <span class=\"n\">G</span><span class=\"o\">,</span>\n  <span class=\"n\">le</span> <span class=\"o\">:=</span> <span class=\"n\">bot_le</span> <span class=\"o\">}</span>\n\n<span class=\"c1\">-- now we have</span>\n<span class=\"c1\">-- 1. edge deletion = inf (incl G) (compl H), where H is the graph with the edges we want to delete</span>\n<span class=\"c1\">-- 2. edge contraction = sup (incl G) H, where H is the graph with the edges we want to contract</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">minor</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">simple_graph</span>\n</code></pre></div>",
        "id": 261159547,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636650342
    },
    {
        "content": "<p>Intervals in a lattice also form a lattice, right? (The operations are in the code block above.)</p>",
        "id": 261159952,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636650523
    },
    {
        "content": "<p>There's: <a href=\"https://leanprover-community.github.io/mathlib_docs/order/lattice_intervals.html\">https://leanprover-community.github.io/mathlib_docs/order/lattice_intervals.html</a></p>",
        "id": 261165195,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1636653018
    },
    {
        "content": "<p>Thanks, those at least give the lattice structure of a particular interval, which is helpful (in particular <a href=\"https://leanprover-community.github.io/mathlib_docs/find/set.Icc.bounded_lattice\">docs#set.Icc.bounded_lattice</a>), but there's additional structure on the set of intervals themselves (i.e., on the set of all morphisms of the poset category).</p>\n<p>I haven't actually checked carefully if there's a partial order on intervals that works, but I was guessing it'd be [a,b] &lt;= [c,d] iff a &lt;= c and b &lt;= d, which corresponds to [a,c] and [b,d] forming a commuting square in the category.</p>",
        "id": 261166734,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636653886
    }
]
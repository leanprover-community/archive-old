[
    {
        "content": "<p>Something that seems like a good definition for multigraphs is</p>\n<p>[Chou94] Chou, Ching-Tsun. \"A formal theory of undirected graphs in Higher-Order Logic.\" (1994) <a href=\"https://doi.org/10.1007/3-540-58450-1_40\">https://doi.org/10.1007/3-540-58450-1_40</a></p>\n<p>I remember there also being some things in</p>\n<p>Doczkal, Christian and Pous, Damien. (2019). Graph Theory in Coq: Minors, Treewidth, and Isomorphisms</p>\n<p>The Chou approach is to have a vertex type <code>V</code> and an edge type <code>E</code>, then take a set of <em>links</em> on <code>V × E × V</code> such that the projection onto <code>E</code> is surjective, such that the set of links is closed under swapping the two vertices, and such that if two links project to the same edge then they are the same up to swapping.</p>\n<p>Conceptually, a link is an edge orientation (for non-loop edges -- loop edges only have a single associated link).</p>\n<p>There's an implementation of it at <a href=\"https://github.com/leanprover-community/mathlib/tree/graphs/src/combinatorics/graphs\">https://github.com/leanprover-community/mathlib/tree/graphs/src/combinatorics/graphs</a> but I don't remember exactly what state the branch is in...</p>",
        "id": 207218181,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1597718099
    },
    {
        "content": "<p>There are many ways to define unoriented multigraphs, and one of the sticking points to using Chou's definition is that the definition of <code>degree</code> isn't very nice.  My educated opinion for the design: a single-vertex graph with a single loop edge should have degree 2, since there are two incident half edges (\"darts\").  Chou's definition has a single link per loop edge but two links per non-loop edge, so you can't just count incident links to get the degree.</p>\n<p>Here are five different definitions of multigraphs: <a href=\"https://gist.github.com/kmill/16257d58a662e570d4762723e762c7a8\">https://gist.github.com/kmill/16257d58a662e570d4762723e762c7a8</a></p>\n<p>I'm thinking something like <code>multigraph₄</code> is the best, though its disadvantage is that you don't have an edge set per se, but at least in my applications \"labeled edge\" tends to actually mean \"labeled dart.\" If you need labeled edges.</p>",
        "id": 222015077,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1610060997
    },
    {
        "content": "<p>Anyway, if you have any other ideas for the definition of a multigraph (along with test implementations for some basic accessor functions, especially the <code>degree</code> interface), please post them!</p>\n<p>It'd be good to also think about how sub-objects would work for each design.</p>",
        "id": 222015155,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1610061042
    },
    {
        "content": "<p>A commutative diagram for the structure of an unoriented multigraph along what the maps are supposed to mean:<br>\n<a href=\"/user_uploads/3121/j5WO7LbsrmxmQME97ZnmzhuR/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/j5WO7LbsrmxmQME97ZnmzhuR/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/j5WO7LbsrmxmQME97ZnmzhuR/image.png\"></a></div>",
        "id": 222019096,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1610064062
    },
    {
        "content": "<p>I've been thinking a little about multigraphs, since they are the right setting for graphic matroids. I think a quite important test is whether it is easy to contract a set of edges. If contraction isn't easy, you're closing off some of the deepest work in graph theory. </p>\n<p>I am in favour of a definition that eliminates the need for darts. Here is one in terms of a nat-valued 'incidence function', with math rather than code. A multigraph is a triple (V,E,inc), where V and E are sets, and inc is a function from V x E to nat, that sums to exactly 2 over each edge. If e has ends v1 and v2, then inc(v,e1) = inc(v,e2) = 1, and if e is a loop at v, then inc(v,e) = 2. Hence, the degree of v is just sum (inc( v, . )).  This correctly allows loops to contribute degree 2, and proves the handshake theorem by formally reversing the order of summation. </p>\n<p>Further, one can contract edges easily; to contract a set X of edges, you quotient V by the equivalence relation whose classes are the components of the subgraph G[X]; then the contraction G/X has this quotient as a vertex set, and its incidences come from summing inc over equivalence classes. This correctly turns nonloop edges into loops where appropriate, contracts non-parallel edges into parallel, etc etc.</p>",
        "id": 222079647,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1610116983
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"329425\">@Peter Nelson</span>,  that's a clever encoding, and it's worth trying it out.  I added my attempt at a formalization of that as <code>multigraph₆</code> in the gist.    One complexity is that the sum is over an infinite set, so I added in a <code>finset</code> support for the summation (I think it's important to be able to handle infinite multigraphs).  Another change I made was to have a special <code>inc_type</code> enumeration rather than a <code>nat</code> so that doing things by cases is easier.</p>\n<p>That's a good point about needing to support contractions (or, better, minors). I figured being able to define <code>degree</code> shows a basic amount of viability for a multigraph definition, and a definite next step would be to try to implement contraction/minors.</p>",
        "id": 222233539,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1610302352
    },
    {
        "content": "<p>(I'll try to get around to make a proper mathlib branch with the definitions under consideration, with one file per multigraph definition.  Doing a gist for now was just easier to try to get the conversation going.)</p>",
        "id": 222233630,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1610302529
    },
    {
        "content": "<p>Here's another entry for a multigraph definition, and it seems rather promising to me.  There's also a potential definition for graph minors that should have reasonable relationships between contraction and deletion.  A small difference from the usual notion of a graph minor is that if labels are re-used in the multigraph then when contracting edges might merge.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">multigraph</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">labels</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">sym</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"n\">labels</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"bp\">=</span> <span class=\"n\">labels</span> <span class=\"n\">w</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"c1\">-- flip labels = labels</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">multigraph</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">multigraph</span> <span class=\"n\">V</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[reducible]</span>\n<span class=\"kd\">def</span> <span class=\"n\">adj</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">G.labels</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">nonempty</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">adj_comm</span> <span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">G.adj</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"bp\">↔</span> <span class=\"n\">G.adj</span> <span class=\"n\">w</span> <span class=\"n\">v</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">adj</span><span class=\"o\">,</span> <span class=\"n\">G.sym</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">loopless</span> <span class=\"o\">:=</span> <span class=\"n\">irreflexive</span> <span class=\"n\">G.adj</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">to_simple_graph</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">G.loopless</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">adj</span> <span class=\"o\">:=</span> <span class=\"n\">G.adj</span><span class=\"o\">,</span>\n  <span class=\"n\">loopless</span> <span class=\"o\">:=</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">sym</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"n\">hvw</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">rwa</span> <span class=\"n\">adj_comm</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">labels'</span> <span class=\"o\">:</span> <span class=\"n\">sym2</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"n\">quotient.lift</span> <span class=\"o\">(</span><span class=\"n\">function.uncurry</span> <span class=\"n\">G.labels</span><span class=\"o\">)</span> <span class=\"kd\">begin</span>\n  <span class=\"n\">rintros</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">_</span><span class=\"bp\">|</span><span class=\"o\">⟨</span><span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">w</span><span class=\"o\">⟩),</span>\n  <span class=\"n\">refl</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">G.sym</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"sd\">/-- We go through this work to define it this way so that `mem_edge_set` is proved by `refl` -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">edge_set</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">sym2</span> <span class=\"n\">V</span> <span class=\"bp\">×</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">set_of</span> <span class=\"bp\">$</span> <span class=\"n\">function.uncurry</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">e</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">v</span> <span class=\"bp\">∈</span> <span class=\"n\">G.labels'</span> <span class=\"n\">e</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">incidence_set</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">sym2</span> <span class=\"n\">V</span> <span class=\"bp\">×</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">e</span> <span class=\"bp\">∈</span> <span class=\"n\">G.edge_set</span> <span class=\"bp\">|</span> <span class=\"n\">v</span> <span class=\"bp\">∈</span> <span class=\"n\">e.1</span><span class=\"o\">}</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">mem_edge_set</span> <span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">⟦</span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">w</span><span class=\"o\">)</span><span class=\"bp\">⟧</span><span class=\"o\">,</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">G.edge_set</span> <span class=\"bp\">↔</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">G.labels</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:=</span>\n<span class=\"n\">iff.rfl</span>\n\n<span class=\"sd\">/-- The degree where incident loop edges are counted once. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">degree'</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"o\">(</span><span class=\"n\">G.incidence_set</span> <span class=\"n\">v</span><span class=\"o\">)]</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span>\n<span class=\"n\">fintype.card</span> <span class=\"o\">(</span><span class=\"n\">G.incidence_set</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- The degree where incident loop edges are counted twice (once for each incident half edge).</span>\n<span class=\"sd\">  This satisfies the degree-sum formula `∑ (v : V), G.degree v = 2 * card G.edge_set`. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">degree</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"o\">(</span><span class=\"n\">G.incidence_set</span> <span class=\"n\">v</span><span class=\"o\">)]</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"o\">(</span><span class=\"n\">G.labels</span> <span class=\"n\">v</span> <span class=\"n\">v</span><span class=\"o\">)]</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span>\n<span class=\"n\">G.degree'</span> <span class=\"n\">v</span> <span class=\"bp\">+</span> <span class=\"n\">fintype.card</span> <span class=\"o\">(</span><span class=\"n\">G.labels</span> <span class=\"n\">v</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- A multigraph obtained from deleting vertices and contracting and deleting edges of a pre-existing multigraph.</span>\n<span class=\"sd\">We delete all edges outside `keep` and contract all edges inside `contr`. -/</span>\n<span class=\"kd\">structure</span> <span class=\"n\">minor</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">multigraph</span> <span class=\"n\">V</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">keep_verts</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">contr</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">sym2</span> <span class=\"n\">V</span> <span class=\"bp\">×</span> <span class=\"n\">α</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">keep</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">sym2</span> <span class=\"n\">V</span> <span class=\"bp\">×</span> <span class=\"n\">α</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">contr_sub</span> <span class=\"o\">:</span> <span class=\"n\">contr</span> <span class=\"bp\">⊆</span> <span class=\"n\">keep</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">keep_sub</span> <span class=\"o\">:</span> <span class=\"n\">keep</span> <span class=\"bp\">⊆</span> <span class=\"n\">G.edge_set</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">keep_has</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">e</span> <span class=\"n\">v</span><span class=\"o\">},</span> <span class=\"n\">e</span> <span class=\"bp\">∈</span> <span class=\"n\">keep</span> <span class=\"bp\">→</span> <span class=\"n\">v</span> <span class=\"bp\">∈</span> <span class=\"n\">prod.fst</span> <span class=\"n\">e</span> <span class=\"bp\">→</span> <span class=\"n\">v</span> <span class=\"bp\">∈</span> <span class=\"n\">keep_verts</span><span class=\"o\">)</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">G</span><span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">to_minor</span> <span class=\"o\">:</span> <span class=\"n\">G.minor</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">keep_verts</span> <span class=\"o\">:=</span> <span class=\"n\">set.univ</span><span class=\"o\">,</span>\n  <span class=\"n\">contr</span> <span class=\"o\">:=</span> <span class=\"bp\">∅</span><span class=\"o\">,</span>\n  <span class=\"n\">keep</span> <span class=\"o\">:=</span> <span class=\"n\">G.edge_set</span><span class=\"o\">,</span>\n  <span class=\"n\">contr_sub</span> <span class=\"o\">:=</span> <span class=\"n\">set.empty_subset</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">keep_sub</span> <span class=\"o\">:=</span> <span class=\"n\">set.subset.rfl</span><span class=\"o\">,</span>\n  <span class=\"n\">keep_has</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">set.mem_univ</span> <span class=\"n\">_</span> <span class=\"o\">}</span>\n\n<span class=\"sd\">/-- The relation that generates which vertices are identified -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">minor.rel</span> <span class=\"o\">(</span><span class=\"n\">G'</span> <span class=\"o\">:</span> <span class=\"n\">G.minor</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">G'.keep_verts</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"bp\">⟦</span><span class=\"o\">(</span><span class=\"n\">coe</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">coe</span> <span class=\"n\">w</span><span class=\"o\">)</span><span class=\"bp\">⟧</span><span class=\"o\">,</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">G'.contr</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">minor.verts</span> <span class=\"o\">(</span><span class=\"n\">G'</span> <span class=\"o\">:</span> <span class=\"n\">G.minor</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">quot</span> <span class=\"n\">G'.rel</span>\n\n<span class=\"sd\">/-- The labels on `G` itself after deleting those outside `keep` and inside `contr`. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">minor.labels'</span> <span class=\"o\">(</span><span class=\"n\">G'</span> <span class=\"o\">:</span> <span class=\"n\">G.minor</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">|</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">G.labels</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"bp\">⟦</span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">w</span><span class=\"o\">)</span><span class=\"bp\">⟧</span><span class=\"o\">,</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">G'.keep</span> <span class=\"bp\">\\</span> <span class=\"n\">G'.contr</span><span class=\"o\">}</span>\n\n<span class=\"sd\">/-- The labels of the minor. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">minor.labels</span> <span class=\"o\">(</span><span class=\"n\">G'</span> <span class=\"o\">:</span> <span class=\"n\">G.minor</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v'</span> <span class=\"n\">w'</span> <span class=\"o\">:</span> <span class=\"n\">G'.verts</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">|</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">G'.keep_verts</span><span class=\"o\">),</span> <span class=\"n\">v'</span> <span class=\"bp\">=</span> <span class=\"n\">quot.mk</span> <span class=\"n\">G'.rel</span> <span class=\"n\">v</span> <span class=\"bp\">∧</span> <span class=\"n\">w'</span> <span class=\"bp\">=</span> <span class=\"n\">quot.mk</span> <span class=\"n\">G'.rel</span> <span class=\"n\">w</span> <span class=\"bp\">∧</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">G'.labels'</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">minor.to_multigraph</span> <span class=\"o\">(</span><span class=\"n\">G'</span> <span class=\"o\">:</span> <span class=\"n\">G.minor</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">multigraph</span> <span class=\"n\">G'.verts</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">labels</span> <span class=\"o\">:=</span> <span class=\"n\">G'.labels</span><span class=\"o\">,</span>\n  <span class=\"n\">sym</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">v'</span> <span class=\"n\">w'</span><span class=\"o\">,</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">ext</span> <span class=\"n\">a</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">minor.labels</span><span class=\"o\">,</span> <span class=\"n\">minor.labels'</span><span class=\"o\">,</span> <span class=\"n\">set_coe.exists</span><span class=\"o\">,</span> <span class=\"n\">set.mem_diff</span><span class=\"o\">,</span>\n      <span class=\"n\">exists_and_distrib_right</span><span class=\"o\">,</span> <span class=\"n\">exists_and_distrib_left</span><span class=\"o\">,</span> <span class=\"n\">set.mem_set_of_eq</span><span class=\"o\">,</span> <span class=\"n\">subtype.coe_mk</span><span class=\"o\">],</span>\n    <span class=\"n\">split</span><span class=\"bp\">;</span>\n    <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">hv</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩,</span> <span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">hw</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩,</span> <span class=\"n\">h</span><span class=\"o\">⟩,</span>\n      <span class=\"n\">use</span> <span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"n\">use</span> <span class=\"n\">hw</span><span class=\"o\">,</span> <span class=\"n\">use</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">use</span> <span class=\"n\">hv</span><span class=\"o\">,</span> <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"n\">sym2.eq_swap</span><span class=\"o\">,</span> <span class=\"n\">G.sym</span><span class=\"o\">],</span> <span class=\"o\">},</span>\n  <span class=\"kd\">end</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">multigraph</span>\n</code></pre></div>",
        "id": 245568281,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1625947320
    },
    {
        "content": "<p>Comparing to the other versions in the gist a few messages up, this is like <code>multigraph₅</code> but easier to work with.  It's also nice how it mirrors the <code>simple_graph</code> definition as <code>multigraph V unit</code> (ignoring looplessness), and like <code>simple_graph</code> it could be split up so it extends a <code>multidigraph</code>.</p>",
        "id": 245568867,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1625948213
    },
    {
        "content": "<p>A <code>submultigraph</code> definition using this, mirroring the <code>simple_graph.subgraph</code> definition in <a href=\"https://github.com/leanprover-community/mathlib/issues/8223\">#8223</a>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">submultigraph</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">multigraph</span> <span class=\"n\">V</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">verts</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">labels</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">labels_sub</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">},</span> <span class=\"n\">labels</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"bp\">⊆</span> <span class=\"n\">G.labels</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">edge_vert</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">},</span> <span class=\"o\">(</span><span class=\"n\">labels</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">nonempty</span> <span class=\"bp\">→</span> <span class=\"n\">v</span> <span class=\"bp\">∈</span> <span class=\"n\">verts</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">sym</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">},</span> <span class=\"n\">labels</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"bp\">=</span> <span class=\"n\">labels</span> <span class=\"n\">w</span> <span class=\"n\">v</span> <span class=\"bp\">.</span> <span class=\"n\">obviously</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 245569126,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1625948554
    },
    {
        "content": "<p>Though a definition for homomorphisms of these kinds of multigraphs seems to be less nice than they might be.  Here's one avoiding any kinds of coercions:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- Homomorphisms of multigraphs.  Defined in such a way that they are extensional. -/</span>\n<span class=\"kd\">@[ext]</span>\n<span class=\"kd\">structure</span> <span class=\"n\">hom</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"n\">V'</span> <span class=\"n\">α</span> <span class=\"n\">α'</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">multigraph</span> <span class=\"n\">V</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">G'</span> <span class=\"o\">:</span> <span class=\"n\">multigraph</span> <span class=\"n\">V'</span> <span class=\"n\">α'</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">on_verts</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">V'</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">on_labels</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">G.labels</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"bp\">→</span> <span class=\"n\">α'</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">mem_labels</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">G.labels</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">),</span> <span class=\"n\">on_labels</span> <span class=\"n\">a</span> <span class=\"n\">h</span> <span class=\"bp\">∈</span> <span class=\"n\">G'.labels</span> <span class=\"o\">(</span><span class=\"n\">on_verts</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">on_verts</span> <span class=\"n\">w</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">sym</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hvw</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">G.labels</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hwv</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">G.labels</span> <span class=\"n\">w</span> <span class=\"n\">v</span><span class=\"o\">),</span> <span class=\"n\">on_labels</span> <span class=\"n\">a</span> <span class=\"n\">hvw</span> <span class=\"bp\">=</span> <span class=\"n\">on_labels</span> <span class=\"n\">a</span> <span class=\"n\">hwv</span><span class=\"o\">)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">mem_labels_comm</span> <span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">G.labels</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"bp\">↔</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">G.labels</span> <span class=\"n\">w</span> <span class=\"n\">v</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"n\">G.sym</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">hom.sym'</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"n\">V'</span> <span class=\"n\">α</span> <span class=\"n\">α'</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">multigraph</span> <span class=\"n\">V</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">G'</span> <span class=\"o\">:</span> <span class=\"n\">multigraph</span> <span class=\"n\">V'</span> <span class=\"n\">α'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">hom</span> <span class=\"n\">G</span> <span class=\"n\">G'</span><span class=\"o\">)</span>\n  <span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hvw</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">G.labels</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f.on_labels</span> <span class=\"n\">a</span> <span class=\"n\">hvw</span> <span class=\"bp\">=</span> <span class=\"n\">f.on_labels</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">G.mem_labels_comm.mp</span> <span class=\"n\">hvw</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">f.sym</span> <span class=\"n\">a</span> <span class=\"n\">_</span> <span class=\"n\">_</span>\n</code></pre></div>\n<p>It's probably silly writing the <code>sym</code> member that way, rather than using <code>sym'</code> directly, due to proof irrelevance.</p>",
        "id": 245578911,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1625962704
    },
    {
        "content": "<p>This is the \"more natural\" definition given the <code>multigraph</code> structure, but it might be considered to be slightly odd:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[ext]</span>\n<span class=\"kd\">structure</span> <span class=\"n\">hom'</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"n\">V'</span> <span class=\"n\">α</span> <span class=\"n\">α'</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">multigraph</span> <span class=\"n\">V</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">G'</span> <span class=\"o\">:</span> <span class=\"n\">multigraph</span> <span class=\"n\">V'</span> <span class=\"n\">α'</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">on_verts</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">V'</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">on_labels</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α'</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">mem_labels</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">},</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">G.labels</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"bp\">→</span> <span class=\"n\">on_labels</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">G'.labels</span> <span class=\"o\">(</span><span class=\"n\">on_verts</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">on_verts</span> <span class=\"n\">w</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>Though if each label is used exactly once, it's exactly the definition you want, so maybe it's ok.</p>",
        "id": 245579257,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1625963391
    },
    {
        "content": "<p>And also if a <code>simple_graph</code> is a loopless <code>multigraph V unit</code>, this <code>hom'</code> definition corresponds to homomorphisms of simple graphs.</p>",
        "id": 245579436,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1625963686
    },
    {
        "content": "<p>Hi. I'm new to Zulip and fairly new to Lean.  I've been coding up some definitions and theorems on (multi)graphs, morphisms and isomorphisms from my 3rd-year course with the vague aim of getting students to play with some of these (e.g. as a \"graphs game\" like the natural number game).  Thanks to all for the inspiring work you've done so far.</p>\n<p>Anyway, if anyone is interested my approach is here: <a href=\"https://github.com/barriecooper/lean-graphs/\">https://github.com/barriecooper/lean-graphs/</a>. Feedback is very welcome (like I said, I'm fairly new to Lean).  Thanks also to my colleague Gihan Marasingha for encouraging me to post something here.</p>",
        "id": 247711491,
        "sender_full_name": "Barrie Cooper",
        "timestamp": 1627653578
    },
    {
        "content": "<p>I would really encourage you with this stuff -- I have a bunch of positive feedback for the natural number game but the other \"games\" I made which weren't interactive (e.g. the complex number game, which just involves filling in sorrys in VS Code) are far less popular.</p>",
        "id": 247742561,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1627668309
    },
    {
        "content": "<p>Do you host preliminary versions anywhere? I used to put NNG experimental versions at <code>http:my_website/NNG_new_version</code> or whatever</p>",
        "id": 247742685,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1627668367
    },
    {
        "content": "<p>and I'd get Imperial kids to play them and watch them closely to see where they needed help.</p>",
        "id": 247742727,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1627668395
    },
    {
        "content": "<p>One reason NNG is popular around Imperial is that the 1st year students actually have to take an exam on this stuff at the end of October each year! Not on Lean but on the material.</p>",
        "id": 247742791,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1627668438
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> : I've got a rough draft here: <a href=\"https://barriecooper.github.io/html/index.html\">https://barriecooper.github.io/html/index.html</a>.  But that's basically my Lean file converted into the game.  I need to put better discussion and hints for the various theorems and tactics needed.</p>",
        "id": 247742816,
        "sender_full_name": "Barrie Cooper",
        "timestamp": 1627668454
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"429543\">@Barrie Cooper</span> Looks nice!  The definitions you've chosen seem good for a Graphs Game.</p>\n<p>Something that might be useful (but not essential), if you want to have exercises involving different graphs with the same vertices, is pulling out <code>vertices</code> like so:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">graph</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">edges</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">endpoints</span> <span class=\"o\">:</span> <span class=\"n\">edges</span> <span class=\"bp\">→</span> <span class=\"n\">sym2</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>That's at the cost of needing two hypotheses <code>(V : Type) (g : graph V)</code> when you want to introduce a graph, though.</p>\n<p>You can still talk about graphs with a particular vertex type with your definition:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">graph</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">vertices</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">edges</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">endpoints</span> <span class=\"o\">:</span> <span class=\"n\">edges</span> <span class=\"bp\">→</span> <span class=\"n\">sym2</span> <span class=\"n\">vertices</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">graph_on</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">graph</span> <span class=\"bp\">//</span> <span class=\"n\">g.vertices</span> <span class=\"bp\">=</span> <span class=\"n\">V</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>However, this can get complicated because equalities between types (as in <code>g.vertices = V</code>) can get very messy.</p>",
        "id": 247742858,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1627668482
    },
    {
        "content": "<p>If the only way you're comparing graphs is through graph homomorphisms, then you can ignore what I'm saying.</p>",
        "id": 247742989,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1627668548
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> .  I'm not sure how much I care about whether I want to use the same vertex/edge sets/types yet.  I guess that will emerge if/when I define subgraphs, contraction-deletion, spanning trees etc.  At one level, I'm perfectly happy to define subgraphs in terms of injective morphisms ...</p>\n<p>I'm only just getting to grips with what Lean thinks is obvious regarding types and what it can't figure out ... so probably you're many steps ahead of me in seeing the potential problems :)</p>",
        "id": 247743756,
        "sender_full_name": "Barrie Cooper",
        "timestamp": 1627668963
    },
    {
        "content": "<p>It's nice having subgraphs be a special type because then you get a bounded lattice.  You can still take \"unions\" and \"intersections\" of injective morphisms, but things like associativity of unions become more elaborate, needing an associator.</p>\n<p>Subgraphs can also a way to avoid the issues I was talking about -- you can have a <code>graph</code> that's complete in some sense (i.e., has a large edge type with as many edges as you need between every pair of vertices), and then you study subgraphs of this.  This way all the graphs under consideration have vertices and edges coming from the same types, which is a nice property when you want to rely on equality.</p>",
        "id": 247744778,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1627669474
    },
    {
        "content": "<p>Barrie, are you familiar with the concept of \"bundled morphisms\" and \"bundled equivalences\"? In mathlib, most things that encode bijections are phrased as explicitly encoding both the forward and inverse functions. Your theory has isomorphisms as Props, which will make it difficult to \"evaluate\" the inverse of an isomorphism. Similarly, bundling morphisms allows you to say things like <code>f.comp g</code> for your (f : H ↦ K) (g : G ↦ H) (modulo choice of argument/composition order)</p>",
        "id": 247744832,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1627669508
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"308899\">@Yakov Pechersky</span>: No, but <span class=\"user-mention\" data-user-id=\"233737\">@Gihan Marasingha</span> mentioned this when we had a video chat earlier today.</p>",
        "id": 247745107,
        "sender_full_name": "Barrie Cooper",
        "timestamp": 1627669681
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> : Yes, I see what you mean, but I'm also quite happy having an associator.  I think I'd rather \"H is a subgraph of G\" to mean \"there exists an injective morphism from H to G\".  Then a statement like \"$A_2$ is a subgraph of $A_3$\" is true irrespective of my constructions of $A_2$ and $A_3$.</p>\n<p>But maybe I'll change my mind tomorrow, or next month ...</p>",
        "id": 247746849,
        "sender_full_name": "Barrie Cooper",
        "timestamp": 1627670629
    },
    {
        "content": "<p>Would you more likely be using <code>is_subgraph X Y</code> as a hypothesis, or as something to be proven? Also, if you assume classical logic, you can always extract an injective morphism from a proof of \"there exists an injective morphism...\".</p>",
        "id": 247747730,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1627671093
    },
    {
        "content": "<p>I think both ... and yes, I'm thinking primarily in terms of classical logic.  That said, I'm interested to understand the alternatives and the advantages of the different approaches.</p>\n<p>I'm also mindful of the audience and whilst I love abstractions and generalisations of theories so that they become more universal, there's a potential trade-off with them becoming incomprehensible or impractical for the ordinary user .... and a fortiori to students.</p>",
        "id": 247748803,
        "sender_full_name": "Barrie Cooper",
        "timestamp": 1627671679
    },
    {
        "content": "<p>If I had a term of <code>H.is_subgraph_of G</code>, then that could also be interpreted as, for example, <code>Hv -&gt;_inj Gv</code>where <code>Hv</code> is the type of vertices of H (resp. G), and other generalizing coercions like <code>Hv -&gt; Gv</code>, where one forgets the injectivity. Coercions, when notated explicitly, can be confusing. However, we utilize them all the time implicitly in proofs and arguments when working in nonformal settings.</p>",
        "id": 247749121,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1627671884
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"429543\">Barrie Cooper</span> <a href=\"#narrow/stream/252551-graph-theory/topic/multigraph.20definition/near/247746849\">said</a>:</p>\n<blockquote>\n<p>Then a statement like \"$A_2$ is a subgraph of $A_3$\" is true irrespective of my constructions of $A_2$ and $A_3$.</p>\n</blockquote>\n<p>Note that another option is to define the same graph on different types, typically as a function <code>Π {α : Type*}, graph α</code>.</p>",
        "id": 247749863,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1627672356
    },
    {
        "content": "<p>I'm not sure I follow ...</p>\n<p><span class=\"user-mention\" data-user-id=\"308899\">@Yakov Pechersky</span> : Sure, but I've defined a morphism of graphs explicitly as a triple consisting of a vertex map, an edge map, and a compatability condition.  As such, no additional coercion is needed, right?</p>\n<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> : Sure, it's not the types I'm so concerned about.  If I construct A_2 with vertex set {1, 2} and A_3 with vertex set {3, 4, 5}, then \"subgraph of\" in terms of subsets doesn't work --- well, it's a lot more constrained than I'd want. I'd need to \"consistently\" define A_n on the set {1, ..., n}, say ... and I think I'd rather not do that (and I definitely don't want to force students to use any particular construction).</p>\n<p>Apologies if I've misunderstood your comments ...</p>",
        "id": 247754392,
        "sender_full_name": "Barrie Cooper",
        "timestamp": 1627675046
    },
    {
        "content": "<p>What I mean by coercion is not in the constructing or providing a morphism. Rather, given a morphism, utilizing it as an injective map from vertices to vertices, for example.</p>",
        "id": 247754719,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1627675219
    },
    {
        "content": "<p>... but that's part of the definition?  If a morphism contains both the vertex map and edge map, and by \"injective\" we mean that both are injective, then I don't see the issue.  Yes, the \"injective morphism\" is distinct from the \"injective vertex map\", but I'm never using the same notation/name/language.  (In fact, I wouldn't actually even use the term \"injective morphism\" ... with students I use the term \"embedding\" because a morphism of graphs is a pair of functions rather than a single function.)</p>\n<p>I don't see where any coercion happens ... in fact, I think I've been careful to define things so that I'm never having to worry about coercion.</p>",
        "id": 247755275,
        "sender_full_name": "Barrie Cooper",
        "timestamp": 1627675536
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"308899\">@Yakov Pechersky</span> This might be a difference between algebraic structures with a primary type of elements (like most things in algebra) and graphs.  The situation might be more similar to <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.functor\">docs#category_theory.functor</a>, which I don't think has a coercion to the <code>obj</code> function.</p>",
        "id": 247755710,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1627675788
    },
    {
        "content": "<p>OK, that makes sense to me. In my day-to-day life, where I have to construct data structures representing subgraph isos (molecular structure mapping), being able to utilize them to map between vertices implicitly improves usability.</p>",
        "id": 247756158,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1627676018
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"429543\">Barrie Cooper</span> <a href=\"#narrow/stream/252551-graph-theory/topic/multigraph.20definition/near/247755275\">said</a>:</p>\n<blockquote>\n<p>I use the term \"embedding\"</p>\n</blockquote>\n<p>For simple graphs, apparently when people talk about embeddings they mean the image is an induced subgraph, which surprised me.  (The notion that corresponds to the map on the graphs as topological spaces being an embedding is an injective homomorphism.)  It's like a discrete version of the difference between injective smooth maps and embedded submanifolds.</p>\n<p>I'm not sure how this embedding terminology correctly generalizes to multigraphs.  I'd hazard a guess that it would be something such that, for each pair of vertices v and w, f.edge induces a bijection between the edges with endpoints v and w and the edges with endpoints f.vert v and f.vert w.</p>",
        "id": 247757048,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1627676524
    },
    {
        "content": "<p>Then a function that's injective on both vertices and edges would be a monic morphism, I think.</p>\n<p>This seems pedagogically complicated...</p>",
        "id": 247757387,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1627676717
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> : Indeed ... these are precisely the sort of things I ask my students to play with to demonstrate they understand what's going on.</p>\n<p>Why do you say \"pedagogically complicated\"?  Just curious ... it's the way it all seems to make sense to me, but perhaps my approach is somewhat idiosyncratic ... which can certainly have its advantages, especially during the last 15 months of open book online exams ...</p>",
        "id": 247774346,
        "sender_full_name": "Barrie Cooper",
        "timestamp": 1627689421
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"429543\">@Barrie Cooper</span> I didn't mean about what you're doing! I was only referring to dealing with both monic morphisms and embeddings. (In particular, introducing category theory concepts at the same time as everything else.)</p>",
        "id": 247774449,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1627689569
    },
    {
        "content": "<p>Suppose I want to have my students play with concrete examples of graphs and morphisms.  How do I go about building such objects?  For example, I've tried and struggled to build an A2.</p>\n<p>Recall my definition of a graph:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">graph</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">vertices</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">edges</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">endpoints</span> <span class=\"o\">:</span> <span class=\"n\">edges</span> <span class=\"bp\">→</span> <span class=\"n\">sym2</span> <span class=\"n\">vertices</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>(and I can change <code>Type</code> to anything e.g. <code>Type*</code> if necessary).  What I've tried is to get hold of 3 distinct constants and define my endpoint map.  I've tried variations on the following and the below is the closest I've got ...</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">constants</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span>\n<span class=\"kd\">axiom</span> <span class=\"n\">ab</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≠</span> <span class=\"n\">b</span>\n<span class=\"kd\">axiom</span> <span class=\"n\">ac</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≠</span> <span class=\"n\">c</span>\n<span class=\"kd\">axiom</span> <span class=\"n\">bc</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">≠</span> <span class=\"n\">c</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">E₂</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">a</span> <span class=\"o\">}</span>\n<span class=\"kd\">def</span> <span class=\"n\">V₂</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">c</span><span class=\"o\">}</span>\n<span class=\"kd\">def</span> <span class=\"n\">ε₂</span> <span class=\"o\">:</span> <span class=\"n\">E₂</span> <span class=\"bp\">→</span> <span class=\"n\">sym2</span> <span class=\"n\">V₂</span>\n<span class=\"bp\">|</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"bp\">⟦</span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"n\">c</span><span class=\"o\">)</span><span class=\"bp\">⟧</span>\n</code></pre></div>\n<p>Lean complains that <code>b</code> and <code>c</code> have the wrong type (ℕ rather than V₂), which I understand but I'm not sure how to 'fix' it.  How do I do this properly (either by fixing my code, or via an alternative approach)?</p>",
        "id": 248966590,
        "sender_full_name": "Barrie Cooper",
        "timestamp": 1628594827
    },
    {
        "content": "<p>Functions in Lean are total. So you must provide a value for all inputs to <code>ε₂</code>. Yes, you indeed do because <code>E₂ := {a}</code>, but it's non-obvious to Lean that you've provided all cases.</p>",
        "id": 248967995,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1628595991
    },
    {
        "content": "<p>In that particular case, you can define <code>ε₂</code> as <code>λ _, ⟦(b,c)⟧</code>, the constant function whose value everywhere is <code>⟦(b,c)⟧</code>.</p>",
        "id": 248968145,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1628596109
    },
    {
        "content": "<p>Thanks ... that doesn't seem to fix the issue with the Type for b though.  (At least, I changed the a to _ in the function definition and Lean is still giving the same Type warning.)</p>",
        "id": 248968310,
        "sender_full_name": "Barrie Cooper",
        "timestamp": 1628596239
    },
    {
        "content": "<p>Better practice would be to not define <code>E₂</code> and <code>V₂</code> <em>at all</em> and instead use directly the correctly sized types for <code>vertices</code> and <code>edges</code>. So here I would do (untested)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">A₂</span> <span class=\"o\">:</span> <span class=\"n\">graph</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">vertices</span> <span class=\"o\">:=</span> <span class=\"n\">fin</span> <span class=\"mi\">2</span><span class=\"o\">,</span>\n  <span class=\"n\">edges</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"mi\">1</span><span class=\"o\">,</span>\n  <span class=\"n\">endpoints</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"bp\">⟦</span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"bp\">⟧</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 248968375,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1628596296
    },
    {
        "content": "<p>Or maybe, to avoid complications using <code>fin</code>,</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">A₂</span> <span class=\"o\">:</span> <span class=\"n\">graph</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">vertices</span> <span class=\"o\">:=</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span>\n  <span class=\"n\">edges</span> <span class=\"o\">:</span> <span class=\"n\">unit</span><span class=\"o\">,</span>\n  <span class=\"n\">endpoints</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"bp\">⟦</span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"bp\">⟧</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 248968496,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1628596366
    },
    {
        "content": "<p>Ok ... I'll try that, but typical exercises might be to use different labels for vertices and edges and get students to explicitly write down isomorphisms and morphisms between different concrete examples of graphs.</p>",
        "id": 248968504,
        "sender_full_name": "Barrie Cooper",
        "timestamp": 1628596376
    },
    {
        "content": "<p>Yeah, that's hard.</p>",
        "id": 248968524,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1628596391
    },
    {
        "content": "<p>Maybe I'm not the anticipated end user, but it feels to me that this is the stuff that Lean needs to be able to do if we're really going to be able to do all of undergraduate maths in it?</p>",
        "id": 248968633,
        "sender_full_name": "Barrie Cooper",
        "timestamp": 1628596459
    },
    {
        "content": "<p>Case-by-case analysis of concrete structures is tedious. For example, try simply proving that <code>x ∈ {a, b, c, d} ↔ x = a ∨ x = b ∨ x = c ∨ x = d</code>.</p>",
        "id": 248968708,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1628596525
    },
    {
        "content": "<p>I don't think there's really any anticipated end user <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span> but one definitely must overcome a few difficulties to do stuff the mathlib way.</p>",
        "id": 248968828,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1628596601
    },
    {
        "content": "<p>I don't mind tedium if it's fairly easy to code ... it's tedious checking that concrete examples of morphisms satisfy the compatability condition by hand, but it's good to get students to do it.</p>\n<p>And I thought that the way functions are defined means it should be simple (naively) to check all cases because you just work through the cases listed in the function definition?</p>",
        "id": 248968984,
        "sender_full_name": "Barrie Cooper",
        "timestamp": 1628596707
    },
    {
        "content": "<p>Yes, but there's a huge difference between exhausting a type and exhausting a set.</p>",
        "id": 248969023,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1628596741
    },
    {
        "content": "<p>I can make things sets if necessary ... I'm certainly not familiar enough with all the differences ...</p>",
        "id": 248969075,
        "sender_full_name": "Barrie Cooper",
        "timestamp": 1628596793
    },
    {
        "content": "<p>Nono, I mean it the other way around.</p>",
        "id": 248969138,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1628596811
    },
    {
        "content": "<p>You defined your <code>vertices</code> and <code>edges</code> as sets (coerced to <code>Type</code>). Lean has no clue how to exhaust those.</p>",
        "id": 248969151,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1628596816
    },
    {
        "content": "<p>Compare that with <code>ℕ</code> where the two constructors are explicit from the inductive definition of <code>ℕ</code>.</p>",
        "id": 248969242,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1628596862
    },
    {
        "content": "<p>Oh ok ... is there a way to avoid them being sets then?  Sorry ... really not sure what is the right/wrong way of doing these things.</p>",
        "id": 248969264,
        "sender_full_name": "Barrie Cooper",
        "timestamp": 1628596876
    },
    {
        "content": "<p>What are the graphs you're after?</p>",
        "id": 248969291,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1628596900
    },
    {
        "content": "<p>And do you really need to label the edges?</p>",
        "id": 248969398,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1628596948
    },
    {
        "content": "<p>If not, you can spare a huge amount of work by ripping of the labels and defining <code>edges : set (sym2 V)</code>.</p>",
        "id": 248969468,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1628597007
    },
    {
        "content": "<p>Then showing a graph isomorphism won't require you mapping explicitly the edges, which would have sounded a bit troublesome.</p>",
        "id": 248969565,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1628597059
    },
    {
        "content": "<p>But for (multi)graphs that's the point ... the vertex map doesn't determine the edge map.</p>",
        "id": 248969689,
        "sender_full_name": "Barrie Cooper",
        "timestamp": 1628597157
    },
    {
        "content": "<p>So you're multigraphs? That's much harder indeed!</p>",
        "id": 248969786,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1628597217
    },
    {
        "content": "<p>Indeed.</p>",
        "id": 248969833,
        "sender_full_name": "Barrie Cooper",
        "timestamp": 1628597255
    },
    {
        "content": "<p>I want my students to be able to make concrete examples of isomorphisms between different instances of say A4, D4, C4 and K4 and morphisms between these, or prove that morphisms don't exist.</p>\n<p>From the point of view of general theory, it would also be nice to be able to prove that embeddings (vertex and edge maps injective) don't necessarily have left inverses e.g. by constructing counterexamples.</p>",
        "id": 248970017,
        "sender_full_name": "Barrie Cooper",
        "timestamp": 1628597372
    },
    {
        "content": "<p>One way to do it would then be to define the ground types inductively. For example,</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">vert4</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">vert4</span>\n<span class=\"bp\">|</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">vert4</span>\n<span class=\"bp\">|</span> <span class=\"n\">c</span> <span class=\"o\">:=</span> <span class=\"n\">vert4</span>\n<span class=\"bp\">|</span> <span class=\"n\">d</span> <span class=\"o\">:=</span> <span class=\"n\">vert4</span>\n</code></pre></div>",
        "id": 248970309,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1628597569
    },
    {
        "content": "<p>Ah ... that seems like a nice approach :)</p>",
        "id": 248970329,
        "sender_full_name": "Barrie Cooper",
        "timestamp": 1628597592
    },
    {
        "content": "<p>For the edges, I don't really know. What's A4 already?</p>",
        "id": 248970362,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1628597630
    },
    {
        "content": "<p>4 vertices and 3 edges joined in a line.</p>",
        "id": 248970422,
        "sender_full_name": "Barrie Cooper",
        "timestamp": 1628597652
    },
    {
        "content": "<p>Sometimes called a path graph on 4 vertices.</p>",
        "id": 248970444,
        "sender_full_name": "Barrie Cooper",
        "timestamp": 1628597671
    },
    {
        "content": "<p>Ah yeah. And C4?</p>",
        "id": 248970525,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1628597747
    },
    {
        "content": "<p>Cycle graph on 4 vertices.</p>",
        "id": 248970754,
        "sender_full_name": "Barrie Cooper",
        "timestamp": 1628597893
    },
    {
        "content": "<p>I don't seem to be getting the <code>inductive</code> type definition right.  When I enter what you put, the first <code>:=</code> gets underlined with the message <code>command expected</code>.</p>",
        "id": 248971014,
        "sender_full_name": "Barrie Cooper",
        "timestamp": 1628598059
    },
    {
        "content": "<p>Actually there would be a neat way to build simple multigraphs by hand. Instead of having global labels, you have labels for each pair of vertices. Indexing them by <code>ℕ</code> should be enough for your purposes.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">edges</span> <span class=\"o\">(</span><span class=\"n\">vertices</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">sym2</span> <span class=\"n\">vertices</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">of_nat</span> <span class=\"o\">:</span> <span class=\"bp\">\\</span><span class=\"n\">for</span> <span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">sym2</span> <span class=\"n\">vertices</span><span class=\"o\">,</span> <span class=\"bp\">\\</span><span class=\"n\">for</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">n</span> <span class=\"bp\">&lt;</span> <span class=\"n\">f</span> <span class=\"n\">e</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">vert4</span>\n</code></pre></div>",
        "id": 248971081,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1628598094
    },
    {
        "content": "<p>the idea being that you set <code>f ⟦(a, b)⟧</code> to be the number of edges you want between <code>a</code> and <code>b</code>.</p>",
        "id": 248971201,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1628598164
    },
    {
        "content": "<p>Thanks - I'll have a play ...</p>",
        "id": 248971427,
        "sender_full_name": "Barrie Cooper",
        "timestamp": 1628598308
    },
    {
        "content": "<p>Based on your first approach <span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span>, I now seem to have an example that works ... many thanks!</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">vert</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">vert</span>\n<span class=\"bp\">|</span> <span class=\"n\">II</span> <span class=\"o\">:</span> <span class=\"n\">vert</span>\n<span class=\"bp\">|</span> <span class=\"n\">III</span> <span class=\"o\">:</span> <span class=\"n\">vert</span>\n<span class=\"bp\">|</span> <span class=\"n\">IV</span> <span class=\"o\">:</span> <span class=\"n\">vert</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">edge</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">edge</span>\n<span class=\"bp\">|</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">edge</span>\n<span class=\"bp\">|</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">edge</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">ε₄</span> <span class=\"o\">:</span> <span class=\"n\">edge</span> <span class=\"bp\">→</span> <span class=\"n\">sym2</span> <span class=\"n\">vert</span>\n<span class=\"bp\">|</span> <span class=\"n\">edge.a</span> <span class=\"o\">:=</span> <span class=\"bp\">⟦</span><span class=\"o\">(</span><span class=\"n\">vert.I</span><span class=\"o\">,</span><span class=\"n\">vert.II</span><span class=\"o\">)</span><span class=\"bp\">⟧</span>\n<span class=\"bp\">|</span> <span class=\"n\">edge.b</span> <span class=\"o\">:=</span> <span class=\"bp\">⟦</span><span class=\"o\">(</span><span class=\"n\">vert.II</span><span class=\"o\">,</span><span class=\"n\">vert.III</span><span class=\"o\">)</span><span class=\"bp\">⟧</span>\n<span class=\"bp\">|</span> <span class=\"n\">edge.c</span> <span class=\"o\">:=</span> <span class=\"bp\">⟦</span><span class=\"o\">(</span><span class=\"n\">vert.III</span><span class=\"o\">,</span><span class=\"n\">vert.IV</span><span class=\"o\">)</span><span class=\"bp\">⟧</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">A₄</span> <span class=\"o\">:=</span> <span class=\"n\">graph.mk</span> <span class=\"o\">(</span><span class=\"n\">vert</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">edge</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ε₄</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 248972446,
        "sender_full_name": "Barrie Cooper",
        "timestamp": 1628598974
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/252551-graph-theory/topic/multigraph.20definition/near/248968708\">said</a>:</p>\n<blockquote>\n<p>Case-by-case analysis of concrete structures is tedious. For example, try simply proving that <code>x ∈ {a, b, c, d} ↔ x = a ∨ x = b ∨ x = c ∨ x = d</code>.</p>\n</blockquote>\n<p>particularly bad example, it turns out:</p>\n<p><code>example : x ∈ ({a, b, c, d} : set α) ↔ x = a ∨ x = b ∨ x = c ∨ x = d := iff.rfl</code> (surprised me too!)</p>",
        "id": 248972465,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1628598989
    },
    {
        "content": "<p>Oh hmm... I had something similar which turned out to be a real pain.</p>",
        "id": 248972537,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1628599041
    },
    {
        "content": "<p>And great Barrie!</p>",
        "id": 248972554,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1628599053
    },
    {
        "content": "<p>Though note that this approach hardly scales. Hope you're not lurking on infinite graphs <span aria-label=\"stuck out tongue\" class=\"emoji emoji-1f61b\" role=\"img\" title=\"stuck out tongue\">:stuck_out_tongue:</span></p>",
        "id": 248972635,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1628599088
    },
    {
        "content": "<p>I think the solution here is using fintypes</p>",
        "id": 248973503,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1628599568
    },
    {
        "content": "<p>I'll settle for finite graphs for now, but it would be good to be able to do something similar for infinite graphs.  I like to give my students the example of edges = ℝ, vertices = ℤ, and the floor and ceiling functions as the endpoint map.  Sounds fun to try to get that working ...</p>",
        "id": 248973507,
        "sender_full_name": "Barrie Cooper",
        "timestamp": 1628599571
    },
    {
        "content": "<p>One can do @[derive fintype] on those inductive types</p>",
        "id": 248973531,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1628599593
    },
    {
        "content": "<p>And you could say<br>\nvariables {V : Type} [fintype V] (a b c : V) (h : (finset.univ : finset V) = {a, b, c}) (h' : fintype.card = 3)</p>",
        "id": 248973965,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1628599849
    },
    {
        "content": "<p>You'll probably want to do @[derive decidable_eq] on your inductive types too. That'll let you do case bash by \"dec_trivial\"</p>",
        "id": 248974230,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1628599976
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"308899\">Yakov Pechersky</span> <a href=\"#narrow/stream/252551-graph-theory/topic/multigraph.20definition/near/248973965\">said</a>:</p>\n<blockquote>\n<p>And you could say<br>\nvariables {V : Type} [fintype V] (a b c : V) (h : (finset.univ : finset V) = {a, b, c}) (h' : fintype.card = 3)</p>\n</blockquote>\n<p>But then you fall into the very problem I was trying to get out of: How do you define a map from <code>V</code>?</p>",
        "id": 248975040,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1628600386
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"429543\">Barrie Cooper</span> <a href=\"#narrow/stream/252551-graph-theory/topic/multigraph.20definition/near/248973507\">said</a>:</p>\n<blockquote>\n<p>I'll settle for finite graphs for now, but it would be good to be able to do something similar for infinite graphs.  I like to give my students the example of edges = ℝ, vertices = ℤ, and the floor and ceiling functions as the endpoint map.  Sounds fun to try to get that working ...</p>\n</blockquote>\n<p>Actually this one is easy</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">floor_ceil_graph</span> <span class=\"o\">:=</span> <span class=\"n\">graph.mk</span> <span class=\"n\">ℤ</span> <span class=\"n\">ℝ</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"bp\">⟦</span><span class=\"o\">(</span><span class=\"n\">floor</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">ceil</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">⟧</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 248999448,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1628611692
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"429543\">@Barrie Cooper</span> To save some typing tedium, when an inductive type is just an enumeration you don't need to specify the types of the constructors.  Also, you might like <code>{graph. vertices := ..., edges := ..., endpoints := ...}</code> notation.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.sym2</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">graph</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">vertices</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">edges</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">endpoints</span> <span class=\"o\">:</span> <span class=\"n\">edges</span> <span class=\"bp\">→</span> <span class=\"n\">sym2</span> <span class=\"n\">vertices</span><span class=\"o\">)</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">vert</span>\n<span class=\"bp\">|</span> <span class=\"n\">I</span> <span class=\"bp\">|</span> <span class=\"n\">II</span> <span class=\"bp\">|</span> <span class=\"n\">III</span> <span class=\"bp\">|</span> <span class=\"n\">IV</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">edge</span>\n<span class=\"bp\">|</span> <span class=\"n\">a</span> <span class=\"bp\">|</span> <span class=\"n\">b</span> <span class=\"bp\">|</span> <span class=\"n\">c</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">ε₄</span> <span class=\"o\">:</span> <span class=\"n\">edge</span> <span class=\"bp\">→</span> <span class=\"n\">sym2</span> <span class=\"n\">vert</span>\n<span class=\"bp\">|</span> <span class=\"n\">edge.a</span> <span class=\"o\">:=</span> <span class=\"bp\">⟦</span><span class=\"o\">(</span><span class=\"n\">vert.I</span><span class=\"o\">,</span><span class=\"n\">vert.II</span><span class=\"o\">)</span><span class=\"bp\">⟧</span>\n<span class=\"bp\">|</span> <span class=\"n\">edge.b</span> <span class=\"o\">:=</span> <span class=\"bp\">⟦</span><span class=\"o\">(</span><span class=\"n\">vert.II</span><span class=\"o\">,</span><span class=\"n\">vert.III</span><span class=\"o\">)</span><span class=\"bp\">⟧</span>\n<span class=\"bp\">|</span> <span class=\"n\">edge.c</span> <span class=\"o\">:=</span> <span class=\"bp\">⟦</span><span class=\"o\">(</span><span class=\"n\">vert.III</span><span class=\"o\">,</span><span class=\"n\">vert.IV</span><span class=\"o\">)</span><span class=\"bp\">⟧</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">A₄</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">graph.</span>\n  <span class=\"n\">vertices</span> <span class=\"o\">:=</span> <span class=\"n\">vert</span><span class=\"o\">,</span>\n  <span class=\"n\">edges</span> <span class=\"o\">:=</span> <span class=\"n\">edge</span><span class=\"o\">,</span>\n  <span class=\"n\">endpoints</span> <span class=\"o\">:=</span> <span class=\"n\">ε₄</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">A₄'</span> <span class=\"o\">:=</span> <span class=\"n\">graph.mk</span> <span class=\"n\">vert</span> <span class=\"n\">edge</span> <span class=\"n\">ε₄</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">A₄''</span> <span class=\"o\">:</span> <span class=\"n\">graph</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">vertices</span> <span class=\"o\">:=</span> <span class=\"n\">vert</span><span class=\"o\">,</span>\n  <span class=\"n\">edges</span> <span class=\"o\">:=</span> <span class=\"n\">edge</span><span class=\"o\">,</span>\n  <span class=\"n\">endpoints</span> <span class=\"o\">:=</span> <span class=\"n\">ε₄</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 249004165,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1628613911
    },
    {
        "content": "<p>Developing <span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span>'s idea, here's a way to create a multigraph using a specified number of edges between pairs of vertices:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">inc_edges</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">sym2</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">sym2</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">e</span><span class=\"o\">))</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">graph.of_inc</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">sym2</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">graph</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">vertices</span> <span class=\"o\">:=</span> <span class=\"n\">V</span><span class=\"o\">,</span>\n  <span class=\"n\">edges</span> <span class=\"o\">:=</span> <span class=\"n\">inc_edges</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n  <span class=\"n\">endpoints</span> <span class=\"o\">:=</span> <span class=\"n\">inc_edges.e</span> <span class=\"o\">}</span>\n\n<span class=\"c1\">-- path with n edges</span>\n<span class=\"kd\">def</span> <span class=\"n\">path</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">graph.of_inc</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">sym2.lift</span> <span class=\"o\">⟨(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)),</span>\n               <span class=\"k\">if</span> <span class=\"n\">v</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">w</span> <span class=\"bp\">∨</span> <span class=\"n\">w</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">v</span> <span class=\"k\">then</span> <span class=\"mi\">1</span> <span class=\"k\">else</span> <span class=\"mi\">0</span><span class=\"o\">),</span>\n            <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">or_comm</span><span class=\"o\">]⟩)</span>\n</code></pre></div>",
        "id": 249006475,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1628614881
    },
    {
        "content": "<p>(<code>sym2.lift</code> is a nice new function for defining functions whose domain is <code>sym2</code>)</p>",
        "id": 249006600,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1628614928
    },
    {
        "content": "<p>Another way to construct graphs, from a list of edges.  The second element in each pair is an edge label that you can use to distinguish edges (here I just used <code>unit</code> since I didn't need to distinguish edges).</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">graph.of_edge_spec</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">edges</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">sym2</span> <span class=\"n\">V</span> <span class=\"bp\">×</span> <span class=\"n\">α</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">graph</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">vertices</span> <span class=\"o\">:=</span> <span class=\"n\">V</span><span class=\"o\">,</span>\n  <span class=\"n\">edges</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"bp\">|</span> <span class=\"n\">s</span> <span class=\"bp\">∈</span> <span class=\"n\">edges</span><span class=\"o\">},</span>\n  <span class=\"n\">endpoints</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">prod.fst</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">sym2</span> <span class=\"n\">V</span> <span class=\"bp\">×</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">vert</span>\n<span class=\"bp\">|</span> <span class=\"n\">I</span> <span class=\"bp\">|</span> <span class=\"n\">II</span> <span class=\"bp\">|</span> <span class=\"n\">III</span> <span class=\"bp\">|</span> <span class=\"n\">IV</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">A₄</span> <span class=\"o\">:=</span> <span class=\"n\">graph.of_edge_spec</span> <span class=\"n\">vert</span> <span class=\"n\">unit</span>\n<span class=\"o\">[(</span><span class=\"bp\">⟦</span><span class=\"o\">(</span><span class=\"n\">vert.I</span><span class=\"o\">,</span> <span class=\"n\">vert.II</span><span class=\"o\">)</span><span class=\"bp\">⟧</span><span class=\"o\">,</span> <span class=\"o\">()),</span>\n <span class=\"o\">(</span><span class=\"bp\">⟦</span><span class=\"o\">(</span><span class=\"n\">vert.II</span><span class=\"o\">,</span> <span class=\"n\">vert.III</span><span class=\"o\">)</span><span class=\"bp\">⟧</span><span class=\"o\">,</span> <span class=\"o\">()),</span>\n <span class=\"o\">(</span><span class=\"bp\">⟦</span><span class=\"o\">(</span><span class=\"n\">vert.III</span><span class=\"o\">,</span> <span class=\"n\">vert.IV</span><span class=\"o\">)</span><span class=\"bp\">⟧</span><span class=\"o\">,</span> <span class=\"o\">())]</span>\n</code></pre></div>",
        "id": 249007897,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1628615537
    },
    {
        "content": "<p>Or, by instead using duplicates in a list to indicate multiple edges:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">graph.of_list</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">edges</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">sym2</span> <span class=\"n\">V</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">graph</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">vertices</span> <span class=\"o\">:=</span> <span class=\"n\">V</span><span class=\"o\">,</span>\n  <span class=\"n\">edges</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">×</span> <span class=\"n\">sym2</span> <span class=\"n\">V</span> <span class=\"bp\">|</span> <span class=\"n\">p</span> <span class=\"bp\">∈</span> <span class=\"n\">edges.map_with_index</span> <span class=\"n\">prod.mk</span><span class=\"o\">},</span>\n  <span class=\"n\">endpoints</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">prod.snd</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">×</span> <span class=\"n\">sym2</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">vert</span>\n<span class=\"bp\">|</span> <span class=\"n\">I</span> <span class=\"bp\">|</span> <span class=\"n\">II</span> <span class=\"bp\">|</span> <span class=\"n\">III</span> <span class=\"bp\">|</span> <span class=\"n\">IV</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">A₄</span> <span class=\"o\">:=</span> <span class=\"n\">graph.of_list</span> <span class=\"n\">vert</span>\n<span class=\"o\">[</span><span class=\"bp\">⟦</span><span class=\"o\">(</span><span class=\"n\">vert.I</span><span class=\"o\">,</span> <span class=\"n\">vert.II</span><span class=\"o\">)</span><span class=\"bp\">⟧</span><span class=\"o\">,</span>\n <span class=\"bp\">⟦</span><span class=\"o\">(</span><span class=\"n\">vert.II</span><span class=\"o\">,</span> <span class=\"n\">vert.III</span><span class=\"o\">)</span><span class=\"bp\">⟧</span><span class=\"o\">,</span>\n <span class=\"bp\">⟦</span><span class=\"o\">(</span><span class=\"n\">vert.III</span><span class=\"o\">,</span> <span class=\"n\">vert.IV</span><span class=\"o\">)</span><span class=\"bp\">⟧</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">konigsberg</span> <span class=\"o\">:=</span> <span class=\"n\">graph.of_list</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">4</span><span class=\"o\">)</span>\n<span class=\"o\">[</span><span class=\"bp\">⟦</span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"bp\">⟧</span><span class=\"o\">,</span>\n <span class=\"bp\">⟦</span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"bp\">⟧</span><span class=\"o\">,</span>\n <span class=\"bp\">⟦</span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">)</span><span class=\"bp\">⟧</span><span class=\"o\">,</span>\n <span class=\"bp\">⟦</span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"bp\">⟧</span><span class=\"o\">,</span> <span class=\"bp\">⟦</span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"bp\">⟧</span><span class=\"o\">,</span>\n <span class=\"bp\">⟦</span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">)</span><span class=\"bp\">⟧</span><span class=\"o\">,</span> <span class=\"bp\">⟦</span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">)</span><span class=\"bp\">⟧</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 249008692,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1628615957
    },
    {
        "content": "<p>Thanks :) Incidentally, what's the proof that these vertices/edges are distinct?  For example, that <code>vert.I ≠ vert.II</code>.  I'm guessing I might need those facts when proving that morphisms are embeddings etc.</p>",
        "id": 249011410,
        "sender_full_name": "Barrie Cooper",
        "timestamp": 1628617325
    },
    {
        "content": "<p>Here's one way to write a tactic proof:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">vert.I</span> <span class=\"bp\">≠</span> <span class=\"n\">vert.II</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">injection</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 249012334,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1628617767
    },
    {
        "content": "<p>(or digging into the weeds, a term-mode proof: <code>example : vert.I ≠ vert.II := λ h, vert.no_confusion h</code>)</p>",
        "id": 249012521,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1628617846
    },
    {
        "content": "<p>I didn't know this would work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">vert.I</span> <span class=\"bp\">≠</span> <span class=\"n\">vert.II</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">trivial</span>\n</code></pre></div>",
        "id": 249013024,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1628618110
    },
    {
        "content": "<p><code>trivial</code> seems to be doing this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"n\">vert.I</span> <span class=\"bp\">≠</span> <span class=\"n\">vert.II</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">contradiction</span>\n</code></pre></div>",
        "id": 249013270,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1628618198
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/tactics.html#contradiction\">tactic#contradiction</a></p>",
        "id": 249013408,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1628618261
    },
    {
        "content": "<p>not even that, <code>def foo : vert.I ≠ vert.II.</code> works</p>",
        "id": 249013645,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1628618384
    },
    {
        "content": "<p>it's equation compiler magic iirc</p>",
        "id": 249013652,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1628618390
    },
    {
        "content": "<p>That's not so useful in the middle of a proof, but it's always worth pointing out the power of the equation compiler.</p>",
        "id": 249013920,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1628618503
    },
    {
        "content": "<p>One more option:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[derive decidable_eq]</span>\n<span class=\"kd\">inductive</span> <span class=\"n\">vert</span>\n<span class=\"bp\">|</span> <span class=\"n\">I</span> <span class=\"bp\">|</span> <span class=\"n\">II</span> <span class=\"bp\">|</span> <span class=\"n\">III</span> <span class=\"bp\">|</span> <span class=\"n\">IV</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">vert.I</span> <span class=\"bp\">≠</span> <span class=\"n\">vert.II</span> <span class=\"o\">:=</span> <span class=\"n\">dec_trivial</span>\n</code></pre></div>\n<p>(If I understand how it works correctly, <code>derive decidable_eq</code> effectively defines a function <code>vert -&gt; vert -&gt; bool</code> that implements the equality check, and then <code>dec_trivial</code>evaluates it, making sure the value is false.  This isn't exactly how it works, because rather than <code>bool</code> it's using <code>decidable</code>, which more naturally connects the truth value with the <code>Prop</code>.)</p>",
        "id": 249013962,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1628618520
    },
    {
        "content": "<p>Thanks - I knew it would be something simple.</p>",
        "id": 249024572,
        "sender_full_name": "Barrie Cooper",
        "timestamp": 1628623675
    },
    {
        "content": "<p>So I'm now happy defining specific examples of (multi)graphs and morphisms, but I'm not sure of the syntax to do this <em>within</em> a proof.  For example, if I want to prove that there exists a morphism <code>A₂ → C₃</code>, I can set everything up in advance e.g.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">φ₁</span> <span class=\"o\">:</span> <span class=\"n\">A₂.vertices</span> <span class=\"bp\">→</span> <span class=\"n\">C₃.vertices</span>\n<span class=\"bp\">|</span> <span class=\"n\">vert₂.I</span> <span class=\"o\">:=</span> <span class=\"n\">vert₃.I</span>\n<span class=\"bp\">|</span> <span class=\"n\">vert₂.II</span> <span class=\"o\">:=</span> <span class=\"n\">vert₃.II</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">ψ₁</span> <span class=\"o\">:</span> <span class=\"n\">A₂.edges</span> <span class=\"bp\">→</span> <span class=\"n\">C₃.edges</span>\n<span class=\"bp\">|</span> <span class=\"n\">edge₁.a</span> <span class=\"o\">:=</span> <span class=\"n\">edge₃.a</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">comp₁</span> <span class=\"o\">:</span> <span class=\"n\">C₃.endpoints</span> <span class=\"bp\">∘</span> <span class=\"n\">ψ₁</span> <span class=\"bp\">=</span> <span class=\"n\">sym2.map</span> <span class=\"n\">φ₁</span> <span class=\"bp\">∘</span> <span class=\"n\">A₂.endpoints</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">apply</span> <span class=\"n\">funext</span><span class=\"o\">,</span>\n  <span class=\"n\">intro</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"n\">refl</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">α₁</span> <span class=\"o\">:=</span> <span class=\"n\">morphism.mk</span> <span class=\"o\">(</span><span class=\"n\">φ₁</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ψ₁</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">comp₁</span><span class=\"o\">)</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">nonempty</span> <span class=\"o\">(</span><span class=\"n\">A₂</span> <span class=\"bp\">↦</span> <span class=\"n\">C₃</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">use</span> <span class=\"n\">α₁</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>How can I do this 'on-the-fly' within the proof itself?  I've tried various combinations of things like <code>let</code>, but with no success ...</p>\n<p>(Heads up: I'll probably be back when I try to prove that there are no morphisms in the other direction.)</p>",
        "id": 251195760,
        "sender_full_name": "Barrie Cooper",
        "timestamp": 1630310385
    },
    {
        "content": "<p>You can do everything the equation compiler can do using recursors. Type <code>#print phi-whatever-the-next-character-is</code> (I'm on mobile and it's not displaying properly) to see how the equation compiler turned your definition into a lean term.</p>",
        "id": 251196641,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1630310898
    },
    {
        "content": "<p>It will have used a function called something.rec at the end of the day. But actually I think your approach of defining them outside is much more readable. You correctly observe that you can't use the equation compiler in the middle of a proof in lean 3 (maybe you can with <code>match</code>? Not sure). Maybe lean 4 is better in this regard?</p>",
        "id": 251196755,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1630310982
    },
    {
        "content": "<p>Thanks - yes, the result using <code>#print</code> and drilling down isn't very readable.  I'd like to set <code>nonempty (A₂ ↦ C₃)</code> as a proof to be completed in a lean game, say, so students would need to be able to define their own morphism on-the-fly within the proof (in an easy-to-read way).</p>",
        "id": 251197100,
        "sender_full_name": "Barrie Cooper",
        "timestamp": 1630311199
    },
    {
        "content": "<p>match should work for that</p>",
        "id": 251197124,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1630311226
    },
    {
        "content": "<p>I'd also rather that the definitions are local to the proof so I don't have to think up new names all the time (or clear the names I've used already so I can redefine them).</p>",
        "id": 251197193,
        "sender_full_name": "Barrie Cooper",
        "timestamp": 1630311254
    },
    {
        "content": "<p>Thanks Kevin, Mario - I think I've got it.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">nonempty</span> <span class=\"o\">(</span><span class=\"n\">A₂</span> <span class=\"bp\">↦</span> <span class=\"n\">C₃</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">let</span> <span class=\"n\">φ₁</span> <span class=\"o\">:</span> <span class=\"n\">A₂.vertices</span> <span class=\"bp\">→</span> <span class=\"n\">C₃.vertices</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">v</span><span class=\"o\">,</span>\n    <span class=\"k\">match</span> <span class=\"n\">v</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">vert₂.I</span> <span class=\"o\">:=</span> <span class=\"n\">vert₃.I</span>\n    <span class=\"bp\">|</span> <span class=\"n\">vert₂.II</span> <span class=\"o\">:=</span> <span class=\"n\">vert₃.II</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span>\n\n  <span class=\"k\">let</span> <span class=\"n\">ψ₁</span> <span class=\"o\">:</span> <span class=\"n\">A₂.edges</span> <span class=\"bp\">→</span> <span class=\"n\">C₃.edges</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">e</span><span class=\"o\">,</span>\n  <span class=\"k\">match</span> <span class=\"n\">e</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">edge₁.a</span> <span class=\"o\">:=</span> <span class=\"n\">edge₃.a</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span>\n\n  <span class=\"k\">let</span> <span class=\"n\">α₁</span> <span class=\"o\">:=</span> <span class=\"n\">morphism.mk</span> <span class=\"o\">(</span><span class=\"n\">φ₁</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ψ₁</span><span class=\"o\">)</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n\n  <span class=\"n\">use</span> <span class=\"n\">α₁</span><span class=\"o\">,</span>\n\n  <span class=\"n\">apply</span> <span class=\"n\">funext</span><span class=\"o\">,</span>\n  <span class=\"n\">intro</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"n\">refl</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>Is there a way to simplify those function definitions for <code>φ₁</code> and <code>ψ₁</code> or is this as close as it gets to my original <code>def</code> versions?</p>",
        "id": 251204095,
        "sender_full_name": "Barrie Cooper",
        "timestamp": 1630315627
    },
    {
        "content": "<p>you can also inline them into <code>α₁</code></p>",
        "id": 251205197,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1630316309
    },
    {
        "content": "<p>you can also prove the proof part using a <code>match</code> if you want to</p>",
        "id": 251205266,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1630316357
    },
    {
        "content": "<p>If I were writing this in a golfing mood I would do something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">nonempty</span> <span class=\"o\">(</span><span class=\"n\">A₂</span> <span class=\"bp\">↦</span> <span class=\"n\">C₃</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"k\">match</span> <span class=\"n\">v</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">vert₂.I</span> <span class=\"o\">:=</span> <span class=\"n\">vert₃.I</span>\n  <span class=\"bp\">|</span> <span class=\"n\">vert₂.II</span> <span class=\"o\">:=</span> <span class=\"n\">vert₃.II</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span>\n <span class=\"bp\">λ</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"k\">match</span> <span class=\"n\">e</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">edge₁.a</span> <span class=\"o\">:=</span> <span class=\"n\">edge₃.a</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span>\n <span class=\"n\">funext</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">cases</span> <span class=\"n\">x</span><span class=\"bp\">;</span> <span class=\"n\">refl</span><span class=\"o\">⟩</span>\n</code></pre></div>",
        "id": 251205452,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1630316472
    },
    {
        "content": "<p>or</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">nonempty</span> <span class=\"o\">(</span><span class=\"n\">A₂</span> <span class=\"bp\">↦</span> <span class=\"n\">C₃</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">vert₂.rec_on</span> <span class=\"n\">v</span> <span class=\"n\">vert₃.I</span> <span class=\"n\">vert₃.II</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">edge₃.a</span><span class=\"o\">,</span> <span class=\"n\">funext</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">cases</span> <span class=\"n\">x</span><span class=\"bp\">;</span> <span class=\"n\">refl</span><span class=\"o\">⟩</span>\n</code></pre></div>",
        "id": 251205521,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1630316517
    },
    {
        "content": "<p>(note - untested)</p>",
        "id": 251205572,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1630316530
    },
    {
        "content": "<p>After quite some time away, I've decided (along with <span class=\"user-mention\" data-user-id=\"303889\">@Alena Gusakov</span> ) to restart thinking about lean with a new approach to multigraphs, which is now in the <code>graph2</code> branch, all under <code>combinatorics.graph</code>. </p>\n<p>As a researcher in graph/matroid theory, I think it's quite important that the edges of a multigraph not be anonymous, instead being decoupled from the vertices as their own type. This will be important when defining minors, as well as things like surface embeddings, not to mention graphic matroids. </p>\n<p>When proving theorems in the wild, defining a graph as a set of vertex pairs is great for areas like colouring and induced subgraph theory, but when working with the minor order (and to an extent, the subgraph order), the edges having their own 'names' is often quite important for things to be clean. </p>\n<p>Anyway, the  approach first defines a <code>digraph</code> as follows (so each edge <code>e</code>  has a head <code>G.ends 0 e</code> and a tail <code>G.ends 1 e</code>): </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">digraph</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">ends</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"mi\">2</span> <span class=\"bp\">→</span> <span class=\"n\">E</span> <span class=\"bp\">→</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>then (after a bunch of lemmas), defines an equivalence relation stating when two digraphs are the same up to reorienting edges</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">orientation_equiv</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"n\">G'</span> <span class=\"o\">:</span> <span class=\"n\">digraph</span> <span class=\"n\">V</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">E</span><span class=\"o\">),</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"mi\">2</span> <span class=\"bp\">≃</span> <span class=\"n\">fin</span> <span class=\"mi\">2</span><span class=\"o\">),</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"mi\">2</span><span class=\"o\">),</span> <span class=\"n\">G.ends</span> <span class=\"n\">i</span> <span class=\"n\">e</span> <span class=\"bp\">=</span> <span class=\"n\">G'.ends</span> <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"n\">e</span>\n</code></pre></div>\n<p>and defines <code>graph</code> as a quotient of <code>digraph</code>  by this relation. The code gets as far as proving the handshake theorem (first in the directed setting and, via the quotient, in the undirected setting) without anything too horrible. Indeed, handshaking motivated this digraph/quotient approach - it seems like one of the only ways to prove things like the handshake theorem without making ugly special cases for loops, which should contribute degree 2  to their end.</p>\n<p>Another thing to note is that <code>deg</code> is defined noncomputably via <code>nat.card</code> to avoid the definition containing data. </p>\n<p>This is my first time writing anything involving <code>quot</code> and I'm currently trying to figure out how to make it work nicely with typeclasses (for instance, what is the right way to transfer the <code>locally_finite</code> typeclass from <code>digraph</code> to <code>graph</code>?) I'd be interested to hear any comments on this.</p>",
        "id": 283960549,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1653528668
    },
    {
        "content": "<p>(Direct link to the folder: <a href=\"https://github.com/leanprover-community/mathlib/tree/graphs2/src/combinatorics/graph\">https://github.com/leanprover-community/mathlib/tree/graphs2/src/combinatorics/graph</a>)</p>\n<p>That seems like a reasonable way to encode darts and to make it so that loop edges inherently get two. I like that these satisfy the degree-sum formula.</p>\n<p>Regarding <code>locally_finite</code>, I don't think you want that to be a typeclass but rather an abbreviation (or a <code>reducible</code> def). Take a look at <a href=\"https://leanprover-community.github.io/mathlib_docs/find/simple_graph.locally_finite\">docs#simple_graph.locally_finite</a>. To get this to work for multiple types of graphs, you'd want something like this set up:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">has_nhd</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"n\">out_param</span> <span class=\"bp\">$</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">nhd</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">deg</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">has_nhd</span> <span class=\"n\">α</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span>\n<span class=\"n\">nat.card</span> <span class=\"o\">(</span><span class=\"n\">has_nhd.nhd</span> <span class=\"n\">G</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I've been trying to see what kind of feature we could have in Lean 3 that would be supported in Lean 4 that would allow us to still write <code>G.deg v</code> with dot notation. Maybe writing abbreviations should be enough for now.</p>\n<p>I'll have more comments later.</p>",
        "id": 283965662,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1653534859
    },
    {
        "content": "<p>Is <code>fin 2</code> easier to use than <code>bool</code>?</p>\n<p>And is there any problem with using <code>E → V × V</code>?</p>",
        "id": 287192106,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1655991924
    },
    {
        "content": "<p>Or, better, <code>src tgt : E → V</code>.</p>",
        "id": 287200430,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1655995367
    },
    {
        "content": "<p>You can even <code>extends (E → V) × (E → V)</code> to access <code>prod.swap</code> (which corresponds to reversing the arrows).</p>",
        "id": 287200529,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1655995415
    },
    {
        "content": "<p>Heads up everyone that <span class=\"user-mention\" data-user-id=\"329754\">@Antoine Labelle</span> and I just PRed a definition of <code>multigraph</code> in <a href=\"https://github.com/leanprover-community/mathlib/pull/16100\">#16100</a>. This is very similar to <span class=\"user-mention\" data-user-id=\"329425\">@Peter Nelson</span>'s approach <a href=\"#narrow/stream/252551-graph-theory/topic/multigraph.20definition/near/283960549\">here</a> and works very well to define the Laplacian and Picard group as you can witness on <a href=\"https://github.com/leanprover-community/mathlib/tree/graph_riemann_roch\">branch#graph_riemann_roch</a>.</p>",
        "id": 293919267,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1660749962
    },
    {
        "content": "<p>The goal is to give the graph theoretic Riemann-Roch as a project to undergraduates at <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>'s workshop at the end of September.</p>",
        "id": 293919415,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1660750018
    },
    {
        "content": "<p>The main difference with Peter and Alena's definition is that we bundle the types of vertices and edges in the structure, rather than taking them as parameters. The reason being that there's no interesting structure to describe on multigraphs with vertices <code>V</code> and edges <code>E</code> and that this allows us to reuse the type of multigraphs as the category of multigraphs, with the hope of reducing boilerplate by using category theoretic machinery.</p>",
        "id": 293920289,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1660750302
    },
    {
        "content": "<p>I would be happy to rename our new definition to <code>indexed_multigraph</code> to contrast with <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span>'s definition in <a href=\"https://github.com/leanprover-community/mathlib/tree/multigraphs\">branch#multigraphs</a>, which more resembles <a href=\"https://leanprover-community.github.io/mathlib_docs/find/quiver\">docs#quiver</a>.</p>",
        "id": 293920582,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1660750385
    },
    {
        "content": "<p>Where are you getting the \"indexed multigraph\" terminology? As far as I know, this is a multigraph (except for the fact that it allows half loops, which I'm not so sure about -- we should either disallow them or require one at every vertex)</p>",
        "id": 293921202,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1660750592
    },
    {
        "content": "<p>I also think it would be good having <code>V</code> be exposed as a parameter, since it's worth thinking about different multigraph structures on the same vertex type. Not having <code>E</code> be exposed makes sense to me (there are some alternatives, but it's fine the way it is).</p>",
        "id": 293922017,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1660750865
    },
    {
        "content": "<p>Peter gives some reasons why it's useful to have an exposed type of vertices and edges above - it seems like this definition can struggle to do the things he mentions?</p>",
        "id": 293929282,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1660752966
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"246273\">@Bhavik Mehta</span> I believe Peter is talking about making sure the edges have individual identities, rather than necessarily exposing an edge type. In a previous version, Peter was considering multigraphs where there was a mere count of the number of edges between pairs of vertices.</p>",
        "id": 293930766,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1660753487
    },
    {
        "content": "<p>Ah I missed that context, thanks</p>",
        "id": 293933707,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1660754390
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/252551-graph-theory/topic/multigraph.20definition/near/293921202\">said</a>:</p>\n<blockquote>\n<p>Where are you getting the \"indexed multigraph\" terminology? As far as I know, this is a multigraph (except for the fact that it allows half loops, which I'm not so sure about -- we should either disallow them or require one at every vertex)</p>\n</blockquote>\n<p>About the half loops point - I think it wouldn't be too hard to extend this structure to disallow them or require them all, so it seems like this version generalises both in a relatively clean way?</p>",
        "id": 293935840,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1660755106
    },
    {
        "content": "<p>Yes, we can just have a typeclass <code>no_half_loops</code> that we put on a graph if we want to exclude them, right?</p>",
        "id": 293938028,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1660755760
    },
    {
        "content": "<p>I wouldn't use the word \"just\" there, but that's a possible solution. An issue is that when you're manipulating multigraphs you likely will need to help Lean with typeclass inference.</p>",
        "id": 293939180,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1660756151
    },
    {
        "content": "<p>One reason I'm not too keen on having the vertex and edge types be contained in the structure is that suggests we should never use <code>=</code> between multigraphs... Maybe this is ok, especially if it turns out it is sufficient working with subgraphs of a big enough multigraph.</p>",
        "id": 293939509,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1660756287
    },
    {
        "content": "<p>To be able to use <code>=</code> we would need both the vertex and the edge type out of the structure, right?</p>",
        "id": 293946915,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1660758789
    },
    {
        "content": "<p>Yes, but also making <code>E</code> be a parameter doesn't make much sense for this definition.</p>",
        "id": 293947166,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1660758882
    },
    {
        "content": "<p>I had to take some time to remember what was going on with <a href=\"https://github.com/leanprover-community/mathlib/tree/multigraphs\">branch#multigraphs</a>. It's a generalization to Chou's multigraph definition (see the reference at <a href=\"https://github.com/leanprover-community/mathlib/blob/multigraphs/src/combinatorics/multigraph/basic.lean\">multigraph/basic.lean</a>)</p>\n<p>It might look like it's paralleling the quiver definition, but the <code>labels</code> field has type <code>V → V → set α</code> so that the <code>symm</code> axiom can be stated in a clean way. That type is equivalent to <code>set (V × α × V)</code>, which is the set of \"links,\" using Chou's terminology. Having <code>α</code> be exposed gives you a good amount of flexibility, and this <code>multigraph</code> type enjoys extensional equality as well as a lattice structure.</p>",
        "id": 293947903,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1660759139
    },
    {
        "content": "<p>This version of a multigraph is a generalization of simple graphs in the sense that we could define <code>def simple_graph (V : Type u) := {G : multigraph V unit // G.loopless}</code></p>",
        "id": 293948136,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1660759204
    },
    {
        "content": "<p>Admittedly this multigraph definition is not completely compatible with the one in <a href=\"https://github.com/leanprover-community/mathlib/pull/16100\">#16100</a>.</p>\n<p>Here's a design question: for <a href=\"https://github.com/leanprover-community/mathlib/pull/16100\">#16100</a>, what would be the type for the edges of a multigraph?</p>",
        "id": 293949454,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1660759716
    },
    {
        "content": "<p>I'm not sure I understand the question. The type for the edges in <a href=\"https://github.com/leanprover-community/mathlib/pull/16100\">#16100</a> is <code>multigraph.E</code>.</p>",
        "id": 293962425,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1660764912
    },
    {
        "content": "<p>Wouldn't a graph with two vertices and a single edge between them have an <code>E</code> type with two terms?</p>",
        "id": 293967614,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1660766820
    },
    {
        "content": "<p>Oh yeah sorry, <code>multigraph.E</code> is the type of oriented edges. The set of unoriented edges would be the quotient of that by the <code>inv</code> involution.</p>",
        "id": 293968485,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1660767142
    },
    {
        "content": "<p>(At least in the case of no half-loops, I'm not sure what you would consider as an unoriented edge when there are half-loops).</p>",
        "id": 293968862,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1660767286
    },
    {
        "content": "<p>Nice job, <span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> ! </p>\n<p>I'm not sure I like the edge and vertex types being bundled, though. For instance, if G is a multigraph on edge set E, and G' is obtained from G by identifying vertices, then G' has edge set E, and one can show that the cycle space of G' is a subspace of the cycle space of G (the cycle space of a graph H on edge set E is the subspace of F_2^E spanned by the indicator vectors of cycles of H). This fact would be awkward to state without type equality if the type is bundled.</p>\n<p>I think there will be many issues of this sort when using the edges/vertices to do things like index rows/columns of matrices or the elements of a matroid; bundling will make it harder to talk about the relationship between different graphs that have vertex/edge sets in common.</p>",
        "id": 294155234,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1660850950
    },
    {
        "content": "<p>This is probably more of an issue for bundled vertices than for bundled edges, by the way.</p>",
        "id": 294155889,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1660851182
    },
    {
        "content": "<p>From my understanding, the only difference between having a given argument <code>foo</code> as a parameter or as a field to some structure <code>bar</code> is when the <code>bar</code> with fixed <code>foo</code> form a structure (like a <code>lattice</code> or a <code>group</code>).</p>\n<p>But here <code>multigraph V E</code> (having both parameters) certainly isn't a <code>lattice</code> or a <code>group</code> (what structure would you expect from the type of graphs with a fixed number of vertices and edges?), and <code>multigraph V</code> (having <code>V</code> a parameter and <code>E</code> a field) certainly isn't either because <code>E : Type*</code> as a field stops you from using equality.</p>\n<p>So there is no gain in having <code>V</code> and <code>E</code> out, so we might as well put them in, because that gives us a category, and all the machinery that goes with it.</p>",
        "id": 294158382,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1660852196
    },
    {
        "content": "<p>I suspect what you're missing is the fact that bundling the types doesn't stop them from having defeqs.</p>",
        "id": 294158532,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1660852247
    },
    {
        "content": "<p>Here's how I would translate your example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">identified</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">multigraph</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">multigraph</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">V</span> <span class=\"o\">:=</span> <span class=\"n\">some_quotient_of_G_V</span>\n  <span class=\"n\">E</span> <span class=\"o\">:=</span> <span class=\"n\">G.E</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">G.identified.E</span> <span class=\"bp\">=</span> <span class=\"n\">G.E</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span> <span class=\"c1\">-- works</span>\n</code></pre></div>\n<p>so you can still state whatever you were stating before.</p>",
        "id": 294158810,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1660852349
    },
    {
        "content": "<p>One fair concern is that <code>G.V</code> and <code>G.E</code> are not syntactically equal to their definitions, so instances don't go through. Typically, if you have a graph whose vertices are indexed by <code>ℕ</code>, then you might have to fiddle to add or multiply them. But I suspect this is circumventable by carefully stating all lemmas in terms of <code>ℕ</code> rather than <code>G.V</code>.</p>",
        "id": 294159152,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1660852484
    },
    {
        "content": "<p>The multigraphs on a fixed edge set E do form a lattice: the homomorphism lattice, where H \\le G if (up to renaming vertices), the graph H arises from G by identifying vertices. There are also a number of structures on [matroids on a ground set E], such as the lattices of weak/strong maps, that specialize to [multigraphs on edge set E] via graphic matroids.</p>",
        "id": 294272533,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1660917663
    },
    {
        "content": "<p>The \"up to renaming vertices\" is precisely what makes them not a lattice. What is a lattice is the quotient of multigraphs on a fixed edge set by equivalence of vertices. My point is that as soon as you put a type as a field, you will need to take a quotient to make equality meaningful. So the only two real options are <code>multigraph V E</code> (which still doesn't seem to form any algebraic structure) and <code>multigraph</code> (which forms a category).</p>",
        "id": 294273792,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1660918056
    },
    {
        "content": "<p>What about <code>multigraph E</code>?</p>",
        "id": 294273991,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1660918140
    },
    {
        "content": "<p>There's <code>V</code> as a field, right? So equality is meaningless.</p>",
        "id": 294274363,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1660918259
    },
    {
        "content": "<p>If I have <code>G_1 G_2 : multigraph E</code>, they may have defeq vertex sets, or we may have <code>G_1 \\le G_2</code> in the homomorphism lattice on <code>multigraph E</code>, or the corresponding <code>M_1 M_2 : matroid E</code> may be related by a weak map, etc etc. Wouldn't this be useful?</p>",
        "id": 294274911,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1660918445
    },
    {
        "content": "<p>Maybe, but you can't prove <code>lattice (multigraph E)</code> which I think you will need for anything remotely non trivial.</p>",
        "id": 294275081,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1660918507
    },
    {
        "content": "<p>Why not?</p>",
        "id": 294275120,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1660918522
    },
    {
        "content": "<p>Ah right, it's not a partial order.</p>",
        "id": 294275197,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1660918552
    },
    {
        "content": "<p>Still, it seems to me like for many purposes the quotient of multigraph by renaming vertices is a more natural structure than multigraph itself; will it be easy to work with this?</p>",
        "id": 294277860,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1660919373
    },
    {
        "content": "<p>I'd like to point out again that the multigraph definition in <a href=\"https://github.com/leanprover-community/mathlib/tree/multigraphs\">branch#multigraphs</a> forms a lattice, since this seems to have been overlooked.</p>\n<p>The way it works is that the alpha type corresponds to edge labels, between any pair of vertices an edge with a given label can appear at most once, and edge labels can otherwise be re-used.</p>",
        "id": 294289638,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1660923017
    },
    {
        "content": "<p>The main weakness with that definition is that loops only have a single dart (if you don't treat loops specially), which doesn't seem right to me -- I would think the number of orientations of a graph should double every time you subdivide an edge, but for loops it's a factor of four.</p>\n<p><a href=\"https://github.com/leanprover-community/mathlib/pull/16100\">#16100</a> allows either one or two darts per loop. This is the incompatibility I was meaning to refer to earlier.</p>",
        "id": 294291031,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1660923468
    },
    {
        "content": "<p>Yes I believe usual loops should have two darts and half-loops should have one.</p>",
        "id": 294294528,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1660924185
    },
    {
        "content": "<p>Sorry it took awhile to evaluate <a href=\"https://github.com/leanprover-community/mathlib/pull/16100\">#16100</a>. I've left a comment about the definition, and I'm leaving a message here so that people interested in multigraphs are aware (ping <span class=\"user-mention\" data-user-id=\"329425\">@Peter Nelson</span>).</p>\n<p>This week Floris helped me think through the plethora of multigraph definitions, and the one that has the most promise is one with an exposed vertex type <code>V</code>, containing an edge type <code>E</code>, and having a function <code>E → sym2 V</code> assigning each edge to its incident vertices. We also thought having an extra <code>sym2 V → set E</code> function would be useful for definitional convenience.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">multigraph</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">edge_verts</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">→</span> <span class=\"n\">sym2</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n<span class=\"c1\">-- The following is for definitional convenience</span>\n<span class=\"o\">(</span><span class=\"n\">edges</span> <span class=\"o\">:</span> <span class=\"n\">sym2</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"n\">E</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">mem_edges_iff</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">sym2</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">E</span><span class=\"o\">),</span> <span class=\"n\">e</span> <span class=\"bp\">∈</span> <span class=\"n\">edges</span> <span class=\"n\">z</span> <span class=\"bp\">↔</span> <span class=\"n\">edge_verts</span> <span class=\"n\">e</span> <span class=\"bp\">=</span> <span class=\"n\">z</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>This also has a natural homomorphism definition:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">multigraph.hom</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"n\">V'</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">multigraph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">G'</span> <span class=\"o\">:</span> <span class=\"n\">multigraph</span> <span class=\"n\">V'</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">on_vert</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">V'</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">on_edge</span> <span class=\"o\">:</span> <span class=\"n\">G.E</span> <span class=\"bp\">→</span> <span class=\"n\">G'.E</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">comm</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">G.E</span><span class=\"o\">),</span> <span class=\"n\">G'.edge_verts</span> <span class=\"o\">(</span><span class=\"n\">on_edge</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">sym2.map</span> <span class=\"n\">on_vert</span> <span class=\"o\">(</span><span class=\"n\">G.edge_verts</span> <span class=\"n\">e</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>and there are good conversions to and from simple graphs:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">simple_graph.to_multigraph</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">multigraph</span> <span class=\"n\">V</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">E</span> <span class=\"o\">:=</span> <span class=\"n\">G.edge_set</span><span class=\"o\">,</span>\n  <span class=\"n\">edge_verts</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">e</span><span class=\"o\">,</span>\n  <span class=\"n\">edges</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"o\">{</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">G.edge_set</span> <span class=\"bp\">|</span> <span class=\"bp\">↑</span><span class=\"n\">e</span> <span class=\"bp\">=</span> <span class=\"n\">z</span><span class=\"o\">},</span>\n  <span class=\"n\">mem_edges_iff</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">vs</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">iff.rfl</span> <span class=\"o\">}</span>\n\n<span class=\"sd\">/-- Create a simple graph by forgetting loop edges and multiple edges. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">multigraph.to_simple_graph</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">multigraph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span> <span class=\"o\">:=</span>\n<span class=\"n\">simple_graph.from_edge_set</span> <span class=\"o\">{</span><span class=\"n\">z</span> <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">G.edges</span> <span class=\"n\">z</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">nonempty</span><span class=\"o\">}</span>\n</code></pre></div>",
        "id": 311990316,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1669288008
    },
    {
        "content": "<p>There are more thoughts in the comment on <a href=\"https://github.com/leanprover-community/mathlib/pull/16100\">#16100</a>.</p>",
        "id": 311990435,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1669288063
    },
    {
        "content": "<p>But one thing that I think is important is that our first <code>multigraph</code> definition be one that corresponds to what we commonly mean by a multigraph. This definition is such that <code>E</code> actually is the edge type (instead of a type of darts in the PR), and there's no distinction between loops and half-loops, which I could see being useful in some contexts, but for basic material about multigraphs I think we'd rather not deal with this distinction.</p>",
        "id": 311990751,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1669288178
    },
    {
        "content": "<p>I'm not sure I understand your arguement against half-loops. Do you have an example where allowing half-loops would make things more complicated? My impression is that in practice you don't have to think too much about them, most definitions work basically the same way with or without half-loops, so we might as well have them allowed (since I'd say we definitely want them as soon as we're talking about quotient graphs).</p>",
        "id": 312006011,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1669293507
    },
    {
        "content": "<p>Also in my experience it's not that uncommon to say (oriented) edges to mean what you call darts, but that's probably very much a subfield-dependant thing. Anyway, in any case that's not really a fundamental problem of <a href=\"https://github.com/leanprover-community/mathlib/pull/16100\">#16100</a>, the field <code>E</code> there could always be renamed <code>darts</code>.</p>",
        "id": 312007164,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1669293898
    },
    {
        "content": "<p>My main argument against half-loops (at least for the main <code>multigraph</code> definition) is that multigraphs as they appear in the literature to not have them.</p>\n<p>Regarding using darts in the definition of a multigraph, it seems more straightforward to define a multigraph to be <code>E -&gt; sym2 V</code>. For example, an edge labeling is then any function <code>E -&gt; L</code> rather than a function <code>D -&gt; L</code> that is invariant under the dart involution.</p>",
        "id": 312007854,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1669294126
    },
    {
        "content": "<p>For the record, I'm currently trying to do some multigraph stuff with <span class=\"user-mention\" data-user-id=\"461830\">@Rémi Bottinelli</span> using quivers directly (there a few open PR about that currently). I think that can work, the biggest issue with that is dependant type hell due to edge types depending on vertices, but it's manageable using <code>cast</code>.</p>",
        "id": 312007921,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1669294148
    },
    {
        "content": "<p>The <code>E -&gt; sym2 V</code> definition is the one that's obviously multigraphs, and I think the burden of proof is not on whether <code>E -&gt; sym2 V</code> would be more or less complicated, but on the question of whether this alternative definition that diverges from the literature will always work out fine for standard stuff about multigraphs. I think it's easier and safer to go with <code>E -&gt; sym2 V</code>.</p>",
        "id": 312008765,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1669294393
    },
    {
        "content": "<p>Regarding quotients, I imagine you're talking about, for example, the case where you have a single-vertex graph with a self loop and you have Z/2Z acting on it by reflection, then you want to take the quotient. In geometric group theory I've seen this handled where you first subdivide each edge into two edges.</p>",
        "id": 312008989,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1669294466
    },
    {
        "content": "<p>It's not clear to me that it's worth ensuring there is always a quotient that coincides with the quotient of the topological realization if that means using a definition that's different from the usual one.</p>",
        "id": 312009145,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1669294531
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"329754\">Antoine Labelle</span> <a href=\"#narrow/stream/252551-graph-theory/topic/multigraph.20definition/near/312007921\">said</a>:</p>\n<blockquote>\n<p>For the record, I'm currently trying to do some multigraph stuff with <span class=\"user-mention silent\" data-user-id=\"461830\">Rémi Bottinelli</span> using quivers directly (there a few open PR about that currently). I think that can work, the biggest issue with that is dependant type hell due to edge types depending on vertices, but it's manageable using <code>cast</code>.</p>\n</blockquote>\n<p>Thanks for going on this expedition into dependent type hell! <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 312009434,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1669294622
    },
    {
        "content": "<blockquote>\n<p>For example, an edge labeling is then any function <code>E -&gt; L</code> rather than a function <code>D -&gt; L</code> that is invariant under the dart involution.</p>\n</blockquote>\n<p>But when talking about stuff like the graph laplacian, you need the vector space of function on D such that <code>f (inv e)=-f e</code>! You can't do that with unoriented edges without choosing an arbitrary orientation and then showing that everything you define is independant of that choice of orientation, which is quite annoying.</p>",
        "id": 312010690,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1669294956
    },
    {
        "content": "<p>I'm not convinced about <code>E -&gt; sym2 V</code> being \"the standard definition in the litterature\", personally I must have seen at least 10 different definitions of multigraphs by different people, so I don't feel like any of them is particularly standard.</p>",
        "id": 312012572,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1669295585
    },
    {
        "content": "<p>There's no need for arbitrary orientations. For example, here's one possible way to define a type of darts where every edge has two darts:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">multigraph.D</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">multigraph</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">dart</span> <span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">u</span> <span class=\"bp\">=</span> <span class=\"n\">v</span> <span class=\"bp\">→</span> <span class=\"n\">bool</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">G.edges</span> <span class=\"bp\">⟦</span><span class=\"o\">(</span><span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">v</span><span class=\"o\">)</span><span class=\"bp\">⟧</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">multigraph.D</span>\n</code></pre></div>\n<p>The <code>f</code> is a hack to get a type of size <code>2</code> or <code>1</code> depending on whether it's a loop or not.</p>",
        "id": 312012707,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1669295647
    },
    {
        "content": "<p>Definitely depends on the field at least, maybe your definition in standard in extremal combinatorics but I wouldn't say so in geometric group theory.</p>",
        "id": 312012840,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1669295706
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"329754\">Antoine Labelle</span> <a href=\"#narrow/stream/252551-graph-theory/topic/multigraph.20definition/near/312012572\">said</a>:</p>\n<blockquote>\n<p>personally I must have seen at least 10 different definitions of multigraphs by different people</p>\n</blockquote>\n<p>Yes, the plethora of definitions is what's been a stumbling block for defining multigraphs. While <code>E -&gt; sym2 V</code> is not <em>literally</em> standard, I think it captures what we mean by multigraphs in combinatorics. Of those 10 different definitions, did any admit half-loops?</p>",
        "id": 312013024,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1669295784
    },
    {
        "content": "<p>Yes I've seen definitions allowing normal loops and half-loops, allowing only normal loops or even allowing only half-loops <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 312013387,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1669295905
    },
    {
        "content": "<p>Geometric group theory cares more about the geometric realization of a multigraph I'd say, but the subdivision trick like the one I mentioned helps smooth over the difference. (Subdividing every edge yields a quasi-isometric graph, right?)</p>",
        "id": 312013405,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1669295914
    },
    {
        "content": "<p>Sure but the subdivision trick feels very hacky and definitely introduces some extra bookkeeping to work with the subdivided graph.</p>",
        "id": 312013635,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1669295997
    },
    {
        "content": "<p>Another important advantage of the dart-based definition in my opinion is that it can extend unoriented graphs, so it prevents a lot of code duplication between oriented and nonoriented graphs.</p>",
        "id": 312013896,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1669296079
    },
    {
        "content": "<p>Maybe graphs are too ubiquitous/basic for there to be one best definition covering everything, and we should accept to have a few different ones.</p>",
        "id": 312014255,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1669296196
    },
    {
        "content": "<p>Right, I said \"first definition of multigraph\" earlier very intentionally with this in mind</p>",
        "id": 312014456,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1669296249
    },
    {
        "content": "<p>In this optic, assuming the quiver-based approach is meant to be kept in the near/middle term, it might also be reasonable to have your proposed approach \"as far away\" as possible from it. I'm not sure I'm making much sense, but I mean that \"we\" might as well cover as much ground between the two implementations as possible.</p>",
        "id": 312014703,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1669296339
    },
    {
        "content": "<p>For what it's worth, the <a href=\"https://en.wikipedia.org/wiki/Multigraph\">wikipedia definition</a> of an unoriented multigraph is a triple <code>(V, E, E -&gt; sym2 V)</code>. The only variation in the handful of sources I rechecked this against were whether loops were allowed at all.</p>\n<p>(By the way, I was considering being so bold as to just call the type <code>graph</code>, but I'd rather not conflict with for example <code>function.graph</code> if someone does <code>open function</code>.)</p>",
        "id": 312017342,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1669297121
    },
    {
        "content": "<p>I've only seen half-loops before in very non-combinatorics settings. One was an explanation of using presheafs to represent graph structures, and I think I also saw it on ncatlab</p>",
        "id": 312017604,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1669297199
    },
    {
        "content": "<p>I like ncatlab, but I think it goes without saying that it has a particular point of view</p>",
        "id": 312017870,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1669297269
    },
    {
        "content": "<p>I've seen half-loops mostly when doing spectral graph theory, and I admit it was in somewhat number-theory/algebra oriented litterature.</p>",
        "id": 312018543,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1669297465
    },
    {
        "content": "<p>Just to check, you mean half-loops (and not just half-edges/darts) were in spectral graph theory literature?</p>",
        "id": 312019281,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1669297627
    },
    {
        "content": "<p>Yes</p>",
        "id": 312019407,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1669297672
    },
    {
        "content": "<p>(For darts but no half-loops, I'd say it's also standard in Bass-Serre theory).</p>",
        "id": 312019531,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1669297717
    },
    {
        "content": "<p>Maybe we have to admit that multigraphs and 1D cell complexes are just different things, and we normally confuse them because they have the same pictures.</p>",
        "id": 312019996,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1669297860
    },
    {
        "content": "<p>Maybe <span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span></p>",
        "id": 312022467,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1669298556
    },
    {
        "content": "<p>That would remind me of abstract simplicial complexes and lower sets.</p>",
        "id": 312024200,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1669299083
    },
    {
        "content": "<p>1D simplicial complexes are just simple graphs, no? Multigraphs are more like delta complexes (I don't think delta complexes allow half-loops, though I think I've seen a variant that allows them at some point).</p>",
        "id": 312025747,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1669299562
    },
    {
        "content": "<p>I said \"cell complex\" not \"simplicial complex,\" but yes, delta complexes or CW complexes</p>",
        "id": 312025969,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1669299617
    },
    {
        "content": "<p>delta complexes don't allow half-loops, at least in the version I learned in Hatcher's book</p>",
        "id": 312026054,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1669299644
    },
    {
        "content": "<blockquote>\n<p>I said \"cell complex\" not \"simplicial complex,\" but yes, delta complexes or CW complexes</p>\n</blockquote>\n<p>Yes, I was just answering to Yaël.</p>",
        "id": 312026460,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1669299768
    }
]
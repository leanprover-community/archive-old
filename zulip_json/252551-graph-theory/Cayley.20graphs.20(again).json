[
    {
        "content": "<p>Hey, i've decided it is time I get some version of Cayley graphs merged.<br>\nThe approach I settled with is to define graphs as soon as you have a <code>smul</code> and a subset of the \"action\" set, and then get Schreier graphs for free as given by the action of a group on a set, and similarly Cayley graphs for the self action.<br>\nAs of now, i've got the following:</p>\n<p>I'd like to have a basic \"core\" that I can merge and can nice enough to be reusable and extendable.<br>\nI'm therefore asking for preliminary feedback: is this an acceptable way to do Cayley/Schreier graphs? What would the minimal set of results needed here look like?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">combinatorics.simple_graph.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">combinatorics.simple_graph.subgraph</span>\n<span class=\"kn\">import</span> <span class=\"n\">combinatorics.simple_graph.connectivity</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.list</span>\n<span class=\"kn\">import</span> <span class=\"n\">group_theory.group_action.group</span>\n<span class=\"kn\">import</span> <span class=\"n\">group_theory.subgroup.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">group_theory.coset</span>\n<span class=\"kn\">import</span> <span class=\"n\">group_theory.quotient_group</span>\n<span class=\"kn\">import</span> <span class=\"n\">group_theory.group_action.quotient</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">function</span>\n\n<span class=\"kd\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">w</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">simple_graph</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">defs</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">has_smul</span> <span class=\"n\">M</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">M</span><span class=\"o\">)</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">schreier_graph.adj_gen</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"n\">mk</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">schreier_graph.adj_gen</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">m.val</span> <span class=\"bp\">•</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">schreier_graph.adj_gen_iff</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">schreier_graph.adj_gen</span> <span class=\"n\">X</span> <span class=\"n\">S</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">↔</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">S</span><span class=\"o\">),</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">m.val</span> <span class=\"bp\">•</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"o\">⟩,</span> <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩,</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩,</span> <span class=\"n\">constructor</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">schreier_graph</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"n\">simple_graph.from_rel</span> <span class=\"o\">(</span><span class=\"n\">schreier_graph.adj_gen</span> <span class=\"n\">X</span> <span class=\"n\">S</span><span class=\"o\">)</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">defs</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">schreier_graph</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">basic</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">has_smul</span> <span class=\"n\">M</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">M</span><span class=\"o\">)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">mono</span> <span class=\"o\">{</span><span class=\"n\">S</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">M</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">≤</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">schreier_graph</span> <span class=\"n\">X</span> <span class=\"n\">S</span> <span class=\"bp\">≤</span> <span class=\"n\">schreier_graph</span> <span class=\"n\">X</span> <span class=\"n\">T</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">apply</span> <span class=\"n\">simple_graph.from_rel_mono</span><span class=\"o\">,</span>\n  <span class=\"n\">rintros</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">⟨⟨</span><span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">mS</span><span class=\"o\">⟩,</span> <span class=\"n\">x</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">adj_gen.mk</span> <span class=\"o\">⟨</span><span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">h</span> <span class=\"n\">mS</span><span class=\"o\">⟩</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">adj_iff</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">schreier_graph</span> <span class=\"n\">X</span> <span class=\"n\">S</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">adj</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">≠</span> <span class=\"n\">y</span> <span class=\"bp\">∧</span> <span class=\"bp\">∃</span> <span class=\"n\">m</span> <span class=\"bp\">∈</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"n\">m</span> <span class=\"bp\">•</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span> <span class=\"bp\">∨</span> <span class=\"n\">m</span> <span class=\"bp\">•</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">schreier_graph</span><span class=\"o\">,</span> <span class=\"n\">adj_gen_iff</span><span class=\"o\">,</span> <span class=\"n\">from_rel_adj</span><span class=\"o\">,</span> <span class=\"n\">ne.def</span><span class=\"o\">,</span> <span class=\"n\">set_coe.exists</span><span class=\"o\">],</span>\n  <span class=\"n\">congr'</span><span class=\"o\">,</span> <span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintros</span> <span class=\"o\">(⟨</span><span class=\"n\">m</span><span class=\"o\">,</span><span class=\"n\">h</span><span class=\"o\">,</span><span class=\"n\">rfl</span><span class=\"o\">⟩</span><span class=\"bp\">|</span><span class=\"o\">⟨</span><span class=\"n\">m</span><span class=\"o\">,</span><span class=\"n\">h</span><span class=\"o\">,</span><span class=\"n\">rfl</span><span class=\"o\">⟩),</span> <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">m</span><span class=\"o\">,</span><span class=\"n\">h</span><span class=\"o\">,</span><span class=\"n\">or.inl</span> <span class=\"n\">rfl</span><span class=\"o\">⟩,</span> <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">m</span><span class=\"o\">,</span><span class=\"n\">h</span><span class=\"o\">,</span><span class=\"n\">or.inr</span> <span class=\"n\">rfl</span><span class=\"o\">⟩,</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintros</span> <span class=\"o\">⟨</span><span class=\"n\">m</span><span class=\"o\">,</span><span class=\"n\">h</span><span class=\"o\">,(</span><span class=\"n\">rfl</span><span class=\"bp\">|</span><span class=\"n\">rfl</span><span class=\"o\">)⟩,</span> <span class=\"n\">exact</span> <span class=\"n\">or.inl</span> <span class=\"o\">⟨</span><span class=\"n\">m</span><span class=\"o\">,</span><span class=\"n\">h</span><span class=\"o\">,</span><span class=\"n\">rfl</span><span class=\"o\">⟩,</span> <span class=\"n\">exact</span> <span class=\"n\">or.inr</span> <span class=\"o\">⟨</span><span class=\"n\">m</span><span class=\"o\">,</span><span class=\"n\">h</span><span class=\"o\">,</span><span class=\"n\">rfl</span><span class=\"o\">⟩,</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">neighbor_set_eq</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">schreier_graph</span> <span class=\"n\">X</span> <span class=\"n\">S</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">neighbor_set</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"n\">y</span> <span class=\"bp\">|</span> <span class=\"n\">x</span> <span class=\"bp\">≠</span> <span class=\"n\">y</span> <span class=\"bp\">∧</span> <span class=\"bp\">∃</span> <span class=\"n\">m</span> <span class=\"bp\">∈</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"n\">m</span> <span class=\"bp\">•</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span> <span class=\"bp\">∨</span> <span class=\"n\">m</span> <span class=\"bp\">•</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"o\">}</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">dsimp</span> <span class=\"o\">[</span><span class=\"n\">neighbor_set</span><span class=\"o\">,</span> <span class=\"n\">set_of</span><span class=\"o\">],</span> <span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"n\">adj_iff</span><span class=\"o\">,</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">neighbor_set_eq'</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">schreier_graph</span> <span class=\"n\">X</span> <span class=\"n\">S</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">neighbor_set</span> <span class=\"n\">x</span>\n<span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"n\">y</span> <span class=\"bp\">|</span> <span class=\"n\">x</span> <span class=\"bp\">≠</span> <span class=\"n\">y</span><span class=\"o\">}</span> <span class=\"bp\">∩</span> <span class=\"o\">({</span><span class=\"n\">y</span> <span class=\"bp\">|</span> <span class=\"bp\">∃</span> <span class=\"n\">m</span> <span class=\"bp\">∈</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"n\">m</span> <span class=\"bp\">•</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span><span class=\"o\">}</span> <span class=\"bp\">∪</span> <span class=\"o\">{</span><span class=\"n\">y</span> <span class=\"bp\">|</span> <span class=\"bp\">∃</span> <span class=\"n\">m</span> <span class=\"bp\">∈</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"n\">m</span> <span class=\"bp\">•</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"o\">})</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">schreier_graph</span><span class=\"o\">,</span> <span class=\"n\">ne.def</span><span class=\"o\">,</span> <span class=\"n\">exists_prop</span><span class=\"o\">],</span> <span class=\"n\">ext</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">mem_neighbor_set</span><span class=\"o\">,</span> <span class=\"n\">set.mem_inter_iff</span><span class=\"o\">,</span> <span class=\"n\">set.mem_set_of_eq</span><span class=\"o\">,</span> <span class=\"n\">set.mem_union</span><span class=\"o\">,</span>\n             <span class=\"n\">simple_graph.from_rel_adj</span><span class=\"o\">,</span> <span class=\"n\">adj_gen_iff</span><span class=\"o\">,</span> <span class=\"n\">ne.def</span><span class=\"o\">,</span> <span class=\"n\">set_coe.exists</span><span class=\"o\">,</span> <span class=\"n\">exists_prop</span><span class=\"o\">,</span>\n             <span class=\"n\">and.congr_right_iff</span><span class=\"o\">],</span>\n  <span class=\"n\">rintro</span><span class=\"o\">,</span> <span class=\"n\">congr'</span><span class=\"bp\">;</span> <span class=\"n\">ext</span><span class=\"bp\">;</span> <span class=\"n\">tauto</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">basic</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">group_action</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">mul_action</span> <span class=\"n\">G</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">eq_add_inverses_remove_one</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">schreier_graph</span> <span class=\"n\">X</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">schreier_graph</span> <span class=\"n\">X</span> <span class=\"bp\">$</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"bp\">∪</span> <span class=\"o\">(</span><span class=\"n\">set.image</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">⁻¹</span><span class=\"o\">)</span> <span class=\"n\">S</span><span class=\"o\">))</span> <span class=\"bp\">\\</span> <span class=\"o\">{(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)})</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">ext</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">adj_iff</span><span class=\"o\">,</span> <span class=\"n\">ne.def</span><span class=\"o\">,</span> <span class=\"n\">exists_prop</span><span class=\"o\">,</span> <span class=\"n\">set.mem_diff</span><span class=\"o\">,</span> <span class=\"n\">set.mem_union</span><span class=\"o\">,</span> <span class=\"n\">set.mem_image</span><span class=\"o\">,</span>\n             <span class=\"n\">set.mem_singleton_iff</span><span class=\"o\">,</span> <span class=\"n\">and.congr_right_iff</span><span class=\"o\">],</span>\n  <span class=\"n\">rintro</span> <span class=\"n\">ne</span><span class=\"o\">,</span> <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">m</span><span class=\"o\">,</span><span class=\"n\">mS</span><span class=\"o\">,(</span><span class=\"n\">l</span><span class=\"bp\">|</span><span class=\"n\">r</span><span class=\"o\">)⟩,</span>\n    <span class=\"o\">{</span> <span class=\"n\">use</span> <span class=\"o\">[</span><span class=\"n\">m</span><span class=\"o\">,</span><span class=\"n\">mS</span><span class=\"o\">],</span> <span class=\"n\">rintro</span> <span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">one_smul</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">ne</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">left</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">use</span> <span class=\"o\">[</span><span class=\"n\">m</span><span class=\"o\">,</span><span class=\"n\">mS</span><span class=\"o\">],</span> <span class=\"n\">rintro</span> <span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">one_smul</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">ne</span> <span class=\"n\">r.symm</span><span class=\"o\">,</span> <span class=\"n\">right</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">r</span><span class=\"o\">},</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintros</span> <span class=\"o\">⟨</span><span class=\"n\">m</span><span class=\"o\">,⟨⟨(</span><span class=\"n\">mS</span><span class=\"bp\">|</span><span class=\"o\">⟨</span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"n\">nS</span><span class=\"o\">,</span><span class=\"n\">rfl</span><span class=\"o\">⟩),</span><span class=\"n\">b</span><span class=\"o\">⟩,</span><span class=\"n\">e</span><span class=\"o\">⟩⟩,</span>\n    <span class=\"o\">{</span> <span class=\"n\">use</span> <span class=\"o\">[</span><span class=\"n\">m</span><span class=\"o\">,</span><span class=\"n\">mS</span><span class=\"o\">,</span><span class=\"n\">e</span><span class=\"o\">],</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">use</span> <span class=\"o\">[</span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"n\">nS</span><span class=\"o\">],</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">inv_smul_eq_iff</span><span class=\"o\">,</span> <span class=\"n\">inv_smul_eq_iff</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">tauto</span><span class=\"o\">,</span> <span class=\"o\">},</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">reachable_iff</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">schreier_graph</span> <span class=\"n\">X</span> <span class=\"n\">S</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">reachable</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">↔</span> <span class=\"bp\">∃</span> <span class=\"n\">g</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"n\">subgroup.closure</span> <span class=\"n\">S</span><span class=\"o\">),</span> <span class=\"n\">g</span> <span class=\"bp\">•</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">w</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">induction</span> <span class=\"n\">w</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">subgroup.one_mem</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">one_smul</span> <span class=\"n\">_</span> <span class=\"n\">w</span><span class=\"o\">⟩,</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">g</span><span class=\"o\">,</span><span class=\"n\">gS</span><span class=\"o\">,</span><span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">w_ih</span><span class=\"o\">,</span>\n      <span class=\"n\">rw</span> <span class=\"n\">adj_iff</span> <span class=\"n\">at</span> <span class=\"n\">w_h</span><span class=\"o\">,</span>\n      <span class=\"n\">rcases</span> <span class=\"n\">w_h</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">ne</span><span class=\"o\">,⟨</span><span class=\"n\">m</span><span class=\"o\">,</span><span class=\"n\">h</span><span class=\"o\">,(</span><span class=\"n\">rfl</span><span class=\"bp\">|</span><span class=\"n\">rfl</span><span class=\"o\">)⟩⟩,</span>\n      <span class=\"o\">{</span> <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">g</span><span class=\"bp\">*</span><span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">mul_smul</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n        <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">subgroup.closure</span> <span class=\"n\">S</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mul_mem</span> <span class=\"n\">gS</span> <span class=\"o\">(</span><span class=\"n\">subgroup.subset_closure</span> <span class=\"n\">h</span><span class=\"o\">),</span> <span class=\"o\">},</span>\n      <span class=\"o\">{</span> <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">g</span> <span class=\"bp\">*</span> <span class=\"n\">m</span> <span class=\"bp\">⁻¹</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span> <span class=\"n\">rotate</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">mul_smul</span><span class=\"o\">,</span> <span class=\"n\">inv_smul_eq_iff</span><span class=\"o\">,</span> <span class=\"n\">smul_left_cancel_iff</span><span class=\"o\">],</span>\n        <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">subgroup.closure</span> <span class=\"n\">S</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mul_mem</span> <span class=\"n\">gS</span>\n          <span class=\"o\">((</span><span class=\"n\">subgroup.closure</span> <span class=\"n\">S</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">inv_mem</span> <span class=\"bp\">$</span> <span class=\"n\">subgroup.subset_closure</span> <span class=\"n\">h</span><span class=\"o\">),</span> <span class=\"o\">},</span> <span class=\"o\">},</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">gS</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩,</span> <span class=\"n\">revert</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">subgroup.closure_induction</span> <span class=\"n\">gS</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"n\">g</span> <span class=\"n\">gS</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n      <span class=\"n\">by_cases</span> <span class=\"n\">h'</span> <span class=\"o\">:</span> <span class=\"n\">g</span> <span class=\"bp\">•</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n      <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">h'</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n      <span class=\"o\">{</span> <span class=\"n\">constructor</span><span class=\"o\">,</span>\n        <span class=\"n\">apply</span> <span class=\"n\">adj.to_walk</span><span class=\"o\">,</span>\n        <span class=\"n\">rw</span> <span class=\"n\">adj_iff</span><span class=\"o\">,</span> <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">ne.symm</span> <span class=\"n\">h'</span><span class=\"o\">,</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">gS</span><span class=\"o\">,</span> <span class=\"n\">or.inl</span> <span class=\"n\">rfl</span><span class=\"o\">⟩,</span> <span class=\"o\">},</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"n\">g₁</span> <span class=\"n\">g₂</span> <span class=\"n\">xg₁</span> <span class=\"n\">xg₂</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">mul_smul</span><span class=\"o\">],</span>\n      <span class=\"n\">apply</span> <span class=\"n\">reachable.trans</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">xg₂</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">xg₁</span> <span class=\"o\">(</span><span class=\"n\">g₂</span> <span class=\"bp\">•</span> <span class=\"n\">x</span><span class=\"o\">)),</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"n\">g</span> <span class=\"n\">xg</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n      <span class=\"n\">apply</span> <span class=\"n\">reachable.symm</span><span class=\"o\">,</span>\n      <span class=\"n\">convert</span> <span class=\"bp\">@</span><span class=\"n\">xg</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"bp\">⁻¹</span> <span class=\"bp\">•</span> <span class=\"n\">x</span><span class=\"o\">),</span>\n      <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">smul_inv_smul</span><span class=\"o\">],</span> <span class=\"o\">},</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">abbreviation</span> <span class=\"n\">schreier_coset_graph</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">subgroup</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">schreier_graph</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"bp\">⧸</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"n\">S</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">equiv_coset_graph_of_pretransitive</span> <span class=\"o\">[</span><span class=\"n\">mul_action.is_pretransitive</span> <span class=\"n\">G</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">x₀</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">schreier_coset_graph</span> <span class=\"n\">S</span> <span class=\"o\">(</span><span class=\"n\">mul_action.stabilizer</span> <span class=\"n\">G</span> <span class=\"n\">x₀</span><span class=\"o\">)</span> <span class=\"bp\">≃</span><span class=\"n\">g</span> <span class=\"n\">schreier_graph</span> <span class=\"n\">X</span> <span class=\"n\">S</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_equiv</span>     <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">mul_action.equiv_quotient_stabilizer</span> <span class=\"n\">G</span> <span class=\"n\">x₀</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">,</span>\n  <span class=\"n\">map_rel_iff'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"kd\">by</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">adj_iff</span><span class=\"o\">,</span> <span class=\"n\">mul_action.equiv_quotient_stabilizer</span><span class=\"o\">,</span> <span class=\"n\">equiv.symm_symm</span><span class=\"o\">,</span>\n               <span class=\"n\">equiv.of_bijective_apply</span><span class=\"o\">,</span> <span class=\"n\">ne.def</span><span class=\"o\">,</span> <span class=\"n\">exists_prop</span><span class=\"o\">,</span>\n               <span class=\"bp\">←</span><span class=\"n\">mul_action.of_quotient_stabilizer_smul</span><span class=\"o\">],</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">injective.eq_iff</span> <span class=\"o\">(</span><span class=\"n\">mul_action.injective_of_quotient_stabilizer</span> <span class=\"n\">G</span> <span class=\"n\">x₀</span><span class=\"o\">)],</span> <span class=\"o\">}</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">locally_finite</span> <span class=\"o\">(</span><span class=\"n\">schreier_graph</span> <span class=\"n\">X</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rintro</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"n\">neighbor_set_eq'</span><span class=\"o\">,</span>\n  <span class=\"n\">haveI</span> <span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"bp\">↥</span><span class=\"o\">{</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">|</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"bp\">∈</span> <span class=\"n\">S</span><span class=\"o\">),</span> <span class=\"n\">m</span> <span class=\"bp\">•</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span><span class=\"o\">},</span> <span class=\"kd\">by</span>\n  <span class=\"o\">{</span> <span class=\"n\">convert</span> <span class=\"n\">set.fintype_image</span> <span class=\"n\">S</span> <span class=\"o\">(</span><span class=\"bp\">•</span><span class=\"n\">x</span><span class=\"o\">),</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">exists_prop</span><span class=\"o\">],</span> <span class=\"o\">},</span>\n  <span class=\"n\">haveI</span> <span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"bp\">↥</span><span class=\"o\">{</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">|</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"bp\">∈</span> <span class=\"n\">S</span><span class=\"o\">),</span> <span class=\"n\">m</span> <span class=\"bp\">•</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"o\">},</span> <span class=\"kd\">by</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">eq_inv_smul_iff</span><span class=\"o\">],</span>\n    <span class=\"n\">convert</span> <span class=\"n\">set.fintype_image</span> <span class=\"n\">S</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">g</span><span class=\"bp\">⁻¹•</span><span class=\"n\">x</span><span class=\"o\">),</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">exists_prop</span><span class=\"o\">],</span>\n    <span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"n\">congr'</span><span class=\"o\">,</span> <span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"n\">tauto</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"n\">apply_instance</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">abbreviation</span> <span class=\"n\">cayley_graph</span> <span class=\"o\">:=</span> <span class=\"n\">schreier_graph</span> <span class=\"n\">G</span> <span class=\"n\">S</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">as_automorphism</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">cayley_graph</span> <span class=\"n\">S</span> <span class=\"bp\">≃</span><span class=\"n\">g</span> <span class=\"n\">cayley_graph</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_equiv</span> <span class=\"o\">:=</span> <span class=\"n\">equiv.mul_right</span> <span class=\"o\">(</span><span class=\"n\">g</span><span class=\"bp\">⁻¹</span><span class=\"o\">),</span>\n  <span class=\"n\">map_rel_iff'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"kd\">by</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">adj_iff</span><span class=\"o\">,</span> <span class=\"n\">equiv.coe_mul_right</span><span class=\"o\">,</span> <span class=\"n\">ne.def</span><span class=\"o\">,</span> <span class=\"n\">mul_left_inj</span><span class=\"o\">,</span> <span class=\"n\">smul_eq_mul</span><span class=\"o\">,</span> <span class=\"n\">exists_prop</span><span class=\"o\">,</span>\n               <span class=\"n\">and.congr_right_iff</span><span class=\"o\">],</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">mul_assoc</span><span class=\"o\">,</span> <span class=\"n\">injective.eq_iff</span> <span class=\"o\">(</span><span class=\"n\">group.mul_right_bijective</span> <span class=\"o\">(</span><span class=\"n\">g</span><span class=\"bp\">⁻¹</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">left</span><span class=\"o\">],</span>\n    <span class=\"n\">exact</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">iff.rfl</span><span class=\"o\">,</span> <span class=\"o\">}</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">as_automorphism_group</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">→*</span> <span class=\"o\">(</span><span class=\"n\">cayley_graph</span> <span class=\"n\">S</span> <span class=\"bp\">≃</span><span class=\"n\">g</span> <span class=\"n\">cayley_graph</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"n\">as_automorphism</span> <span class=\"n\">S</span><span class=\"o\">,</span>\n  <span class=\"n\">map_one'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">dsimp</span> <span class=\"o\">[</span><span class=\"n\">as_automorphism</span><span class=\"o\">],</span> <span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"n\">map_mul'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">g</span> <span class=\"n\">g'</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">dsimp</span> <span class=\"o\">[</span><span class=\"n\">as_automorphism</span><span class=\"o\">],</span> <span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"o\">}</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">injective_as_automorphism_group</span> <span class=\"o\">:</span> <span class=\"n\">function.injective</span> <span class=\"o\">(</span><span class=\"n\">as_automorphism_group</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rintro</span> <span class=\"n\">g</span> <span class=\"n\">g'</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">as_automorphism_group</span><span class=\"o\">,</span> <span class=\"n\">as_automorphism</span><span class=\"o\">,</span> <span class=\"n\">equiv.mul_right</span><span class=\"o\">,</span> <span class=\"n\">to_units</span><span class=\"o\">,</span> <span class=\"n\">units.mul_right</span><span class=\"o\">,</span>\n             <span class=\"n\">inv_inv</span><span class=\"o\">,</span> <span class=\"n\">units.inv_mk</span><span class=\"o\">,</span> <span class=\"n\">units.coe_mk</span><span class=\"o\">,</span> <span class=\"n\">mul_equiv.coe_mk</span><span class=\"o\">,</span> <span class=\"n\">monoid_hom.coe_mk</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">congr_fun</span> <span class=\"n\">h.left</span> <span class=\"mi\">1</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">group_action</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">schreier_graph</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">simple_graph</span>\n</code></pre></div>",
        "id": 308556911,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1667903502
    },
    {
        "content": "<p>Do you not want to use markings from <a href=\"https://github.com/leanprover-community/mathlib/tree/geometric_group_theory\">branch#geometric_group_theory</a>?</p>",
        "id": 308557172,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1667903601
    },
    {
        "content": "<p>Well, what I don't really like with markings is that they are assumed surjective</p>",
        "id": 308557314,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1667903654
    },
    {
        "content": "<p>My thought process was mostly like: there hasn't been much life on this <code>marking</code> code, and my understanding was that perhaps the GGT aspect should start with something even more general than markings, but I'm not sure exactly how to proceed. So instead of wait for it to happen, I should just work out a good enough \"combinatorial\" version of Cayley graphs that actually gets somewhere.</p>",
        "id": 308557634,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1667903799
    },
    {
        "content": "<p>Also, this one covers Schreier graphs, which is also useful and not \"natively\" covered by markings I believe.</p>",
        "id": 308557669,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1667903822
    },
    {
        "content": "<p>Okay sure</p>",
        "id": 308557698,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1667903836
    },
    {
        "content": "<p>I mean, I shared my progress here exactly to discuss this kind of thing, so I'm open to some other path if there is a reasonable argument for it.</p>",
        "id": 308557868,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1667903911
    },
    {
        "content": "<p>I suspect simple graphs are not the right data structure for Schreier graphs. They're fine for connectivity relations and for graph metrics, but, for example, you're not able to represent the fact that walks in a Schierer graph correspond to words in the given generating set (and you also have to artificially remove loops).</p>\n<p>I suspect we want a type of multigraphs with directed labeled edges for this -- this at least matches the definitions of Schreier and Cayley graphs that I know. There are some facts about automorphism groups of Schreier graphs that don't appear to be true when they are turned into simple graphs.</p>",
        "id": 308576302,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1667911339
    },
    {
        "content": "<p>mmh, yeah, that's a good point. For Cayley graphs and GGT, I think having <code>simple_graph</code>s is good enough since all we care about is the metric, really. But you're probably right about Schreier graphs: in this case the labelling is quite more important in general. <br>\nWell, let me reimplement it all on top of quivers then ?</p>",
        "id": 308577809,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1667911975
    },
    {
        "content": "<p>There's another fact about Schreier graphs, which is that if you have a finitely presented group G with a finitely normally generated subgroup H, then you can \"compute\" the Schreier graph for G acting on H by iteratively considering Scheier graphs associated to sequences of subgroups of H generated by finite unions of conjugates of the generating set, and these Scheier graphs converge to the true one in the sense that the vertices eventually stabilize (for each vertex, there is some step after which it will never be identified with another vertex). I wonder in which setting this is easiest to formalize? (Btw, I'm describing the Todd-Coxeter algorithm)</p>",
        "id": 308578910,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1667912365
    },
    {
        "content": "<p>I wonder what the best way to encode Cayley graphs as quivers would be. You'd want your quiver automorphisms to respect edge labelings, right?</p>",
        "id": 308579627,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1667912581
    },
    {
        "content": "<p>Yeah, that seems the most natural way to do it. I was thinking this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">section</span> <span class=\"n\">defs</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">has_smul</span> <span class=\"n\">M</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">→</span> <span class=\"n\">M</span><span class=\"o\">)</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">schreier_graph.arrow</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span>\n<span class=\"bp\">|</span> <span class=\"n\">mk</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">schreier_graph.arrow</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ι</span> <span class=\"n\">m</span> <span class=\"bp\">•</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">quiver</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">schreier_graph.arrow</span> <span class=\"n\">X</span> <span class=\"n\">ι</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">defs</span>\n</code></pre></div>",
        "id": 308580031,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1667912706
    },
    {
        "content": "<p><del>wait, scratch my inductive</del> oh no, let's keep it</p>",
        "id": 308580064,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1667912716
    },
    {
        "content": "<p>by the way, I was wondering if we could add infix notation for prefunctors and their composition</p>",
        "id": 308584020,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1667912805
    },
    {
        "content": "<p>Do we then define a special type of prefunctor that sends an <code>mk m _</code> to an <code>mk m _</code>?</p>\n<p>I think the sort of formal result that tests whether these are the correct notion of a schreier graph is if they are somehow equivalent to G-sets. So morphisms of G-sets &lt;-&gt; morphisms of Scheier graphs for G, if I've got this right.</p>",
        "id": 308584437,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1667912952
    },
    {
        "content": "<p>ah, I'm stupid, you're right, the coloring is kind of forgotten when building the quiver. let me think</p>",
        "id": 308584744,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1667913051
    },
    {
        "content": "<p>well, I guess the most natural way is to add <code>color {x y} : x --&gt; y -&gt; S</code> no?</p>",
        "id": 308585641,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1667913360
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">colored_quiver</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"o\">(</span><span class=\"n\">quiver</span> <span class=\"n\">V</span><span class=\"o\">)</span>  <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">coloring</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">X</span> <span class=\"n\">Y</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">to_quiver.hom</span> <span class=\"n\">X</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">S</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>what about this?</p>",
        "id": 308586555,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1667913720
    },
    {
        "content": "<p>I guess that sort of thing might work (except it'd be a class), though you'd still have to go and make sure you have color-preserving quiver homomorphisms</p>",
        "id": 308586966,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1667913852
    },
    {
        "content": "<p>Another possibility is to start developing the theory of labeled digraphs</p>",
        "id": 308587014,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1667913872
    },
    {
        "content": "<p>Here's a very small start:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">labeled_digraph</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">arrows</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"n\">S</span><span class=\"o\">)</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">labeled_digraph</span>\n\n<span class=\"sd\">/-- Label-preserving graph homomorphism. -/</span>\n<span class=\"kn\">protected</span> <span class=\"kd\">structure</span> <span class=\"n\">hom</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">labeled_digraph</span> <span class=\"n\">α</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">G'</span> <span class=\"o\">:</span> <span class=\"n\">labeled_digraph</span> <span class=\"n\">β</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">map_vert</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">map_arrow</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">∈</span> <span class=\"n\">G.arrows</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">),</span> <span class=\"n\">s</span> <span class=\"bp\">∈</span> <span class=\"n\">G'.arrows</span> <span class=\"o\">(</span><span class=\"n\">map_vert</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">map_vert</span> <span class=\"n\">y</span><span class=\"o\">))</span>\n\n<span class=\"kd\">notation</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">labeled_digraph.hom</span><span class=\"o\">)</span> <span class=\"n\">G</span> <span class=\"bp\">`</span> <span class=\"bp\">→</span><span class=\"n\">g</span> <span class=\"bp\">`</span> <span class=\"n\">G'</span> <span class=\"o\">:=</span> <span class=\"n\">hom</span> <span class=\"n\">G</span> <span class=\"n\">G'</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">labeled_digraph</span>\n</code></pre></div>",
        "id": 308587039,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1667913883
    },
    {
        "content": "<p>That's nice indeed. I'm just kind of saddened by the possibility to have one more graph-like definition (making it 3, and 4 if the directed graph PR of Yael gets merged)</p>",
        "id": 308587291,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1667913964
    },
    {
        "content": "<p>Honestly, for me it's more about settling down on one convention and actually getting at least one definition of cayley graphs in, and I figure we might as well cover schreier graphs in the same stroke</p>",
        "id": 308587637,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1667914090
    },
    {
        "content": "<p>What do you think are the fundamental theorems that can test whether it's the right definition?</p>",
        "id": 308588370,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1667914331
    },
    {
        "content": "<p>Given what I know about GGT, when groups act on graphs they're mostly simple graphs, so having a <code>simple_graph.schreier_graph</code> and a <code>simple_graph.cayley_graph</code> might not be so crazy, even if they're not <em>the</em> correct notions</p>",
        "id": 308588565,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1667914410
    },
    {
        "content": "<p>but I think it's important that definitions be proved by theorems</p>",
        "id": 308588712,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1667914450
    },
    {
        "content": "<p>yeah, mostly for cayley graphs I agree. But say <a href=\"https://www.semanticscholar.org/paper/Stallings-Foldings-and-Subgroups-of-Free-Groups-Kapovich-Myasnikov/480a69f59749d1aebcf50d060f0ec4bc887f560d\">this</a> might be nice to formalize for instance, and here the labelling is very important..</p>",
        "id": 308588782,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1667914477
    },
    {
        "content": "<p>I think you were spot on with the remark that forgetting labels and loops is kind of losing everything for schreier graphs.</p>",
        "id": 308588829,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1667914500
    },
    {
        "content": "<p>Yeah, I had Stallings foldings in mind earlier (not that I know much about their theory -- I've been to enough seminar talks about outer space)</p>",
        "id": 308588889,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1667914526
    },
    {
        "content": "<p>and e.g. the fact that a group is free iff it acts freely on a tree (iirc) needs to remember loops too I guess.</p>",
        "id": 308588921,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1667914542
    },
    {
        "content": "<p>or, more basic, the cayley graph of a group is a tree iff the generators generate it freely</p>",
        "id": 308589052,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1667914590
    },
    {
        "content": "<p>I think I remember in \"Office hours with a geometric group theorist\" that they work with simple graphs, subdividing edges of graphs as necessary</p>",
        "id": 308589162,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1667914626
    },
    {
        "content": "<p>without orientation you lose info about involutions, and without labelling you get that your group is not the full automorphism group of the graph, but just embeds in it.</p>",
        "id": 308589233,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1667914654
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/252551-graph-theory/topic/Cayley.20graphs.20.28again.29/near/308589162\">said</a>:</p>\n<blockquote>\n<p>I think I remember in \"Office hours with a geometric group theorist\" that they work with simple graphs, subdividing edges of graphs as necessary</p>\n</blockquote>\n<p>but that's kind of a hack, isn't it?</p>",
        "id": 308589267,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1667914668
    },
    {
        "content": "<p>now you've convinced me :)</p>",
        "id": 308589291,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1667914676
    },
    {
        "content": "<p>I guess it's like: if you take your cayley/schreier graphs to contain the full orientation+labelling information, you can always simply get the underlying <code>simple_graph</code> and everything you need should translate easily</p>",
        "id": 308589446,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1667914729
    },
    {
        "content": "<p>I think it's sort of like working with simplicial complexes (where simplices are identified with vertex subsets), how you need to do barycentric subdivisions to ensure different properties. Though I sometimes feel like this is a hack, since I like delta complexes (like in Hatcher's algebraic topology book)</p>",
        "id": 308589457,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1667914733
    },
    {
        "content": "<p>sounds right, yeah</p>",
        "id": 308590322,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1667915043
    },
    {
        "content": "<p>mmh, it's not so easy to map from <code>prefunctor</code> to <code>simple_graph.hom</code> because of the adjacency thing</p>",
        "id": 308591147,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1667915350
    },
    {
        "content": "<p>but I'm not sure this is such a big deal: we don't have to deal with graph morphisms that much on the <code>simple_graph</code> side</p>",
        "id": 308591326,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1667915404
    },
    {
        "content": "<p>So, to me, it makes sense to go first with the \"full information\" version, either based on quivers or on digraphs as you proposed.</p>",
        "id": 308593062,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1667915949
    },
    {
        "content": "<p>or, yeah, we could just try and push the dumb \"geometric\" approach and see how far this takes us</p>",
        "id": 308599094,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1667917758
    },
    {
        "content": "<p>Any idea why lean can't find the correct instance at the <code>bijective_color</code> line?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">combinatorics.quiver.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">group_theory.group_action.basic</span>\n\n\n<span class=\"kn\">open</span> <span class=\"n\">function</span>\n\n<span class=\"kd\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">w</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">quiver</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">defs</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">colored_quiver</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"o\">(</span><span class=\"n\">quiver</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">color</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">⦃</span><span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">⦄,</span> <span class=\"o\">(</span><span class=\"n\">hom</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">S</span><span class=\"o\">)</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">has_smul</span> <span class=\"n\">M</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">→</span> <span class=\"n\">M</span><span class=\"o\">)</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">schreier_graph.arrow</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span>\n<span class=\"bp\">|</span> <span class=\"n\">mk</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">schreier_graph.arrow</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ι</span> <span class=\"n\">m</span> <span class=\"bp\">•</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">schreier_graph_colored_quiver</span> <span class=\"o\">:</span> <span class=\"n\">colored_quiver</span> <span class=\"n\">V</span> <span class=\"n\">S</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">hom</span> <span class=\"o\">:=</span> <span class=\"n\">schreier_graph.arrow</span> <span class=\"n\">V</span> <span class=\"n\">ι</span><span class=\"o\">,</span>\n  <span class=\"n\">color</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span><span class=\"n\">apply</span> <span class=\"n\">schreier_graph.arrow.rec</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">s</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">s</span><span class=\"o\">)}</span> <span class=\"o\">}</span>\n\n\n<span class=\"kd\">set_option</span> <span class=\"n\">trace.class_instances</span> <span class=\"n\">true</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">bijective_color</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">function.bijective</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">⟶</span> <span class=\"n\">y</span><span class=\"o\">),</span> <span class=\"n\">colored_quiver.color</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">defs</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">quiver</span>\n</code></pre></div>",
        "id": 308613582,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1667921824
    },
    {
        "content": "<p>It looks like you're missing <code>[colored_quiver V S]</code> in the arguments</p>",
        "id": 308614719,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1667922179
    },
    {
        "content": "<p>but why doesn't it get it from the instance  just above?</p>",
        "id": 308615045,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1667922286
    },
    {
        "content": "<p>Oh, right. I think it's because it can't infer <code>S</code> from the <code>x --&gt; y</code> expression</p>",
        "id": 308615190,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1667922336
    },
    {
        "content": "<p>ah, let me try, thanks!</p>",
        "id": 308615307,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1667922367
    },
    {
        "content": "<p>If you think you'll only use a single <code>S</code> for a given <code>V</code> (and use term tagging tricks to change <code>S</code> when you need to), then you can safely make <code>S</code> an <code>out_param</code> in the <code>class</code>.</p>",
        "id": 308615311,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1667922369
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">colored_prefunctor</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"n\">S</span> <span class=\"n\">V'</span> <span class=\"n\">S'</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">colored_quiver</span> <span class=\"n\">V</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">colored_quiver</span> <span class=\"n\">V'</span> <span class=\"n\">S'</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">→</span> <span class=\"n\">S'</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">prefunctor</span> <span class=\"n\">V</span> <span class=\"n\">V'</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">color</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">⟶</span> <span class=\"n\">y</span><span class=\"o\">),</span> <span class=\"n\">σ</span> <span class=\"o\">(</span><span class=\"n\">color</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">color</span> <span class=\"o\">(</span><span class=\"n\">map</span> <span class=\"n\">f</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>Is it worth having a map of labelling as a parameter?</p>",
        "id": 308615479,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1667922417
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/252551-graph-theory/topic/Cayley.20graphs.20.28again.29/near/308615311\">said</a>:</p>\n<blockquote>\n<p>If you think you'll only use a single <code>S</code> for a given <code>V</code> (and use term tagging tricks to change <code>S</code> when you need to), then you can safely make <code>S</code> an <code>out_param</code> in the <code>class</code>.</p>\n</blockquote>\n<p>huh, that's above my technical expertise I fear!</p>",
        "id": 308615574,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1667922446
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"461830\">Rémi Bottinelli</span> <a href=\"#narrow/stream/252551-graph-theory/topic/Cayley.20graphs.20.28again.29/near/308615479\">said</a>:</p>\n<blockquote>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">colored_prefunctor</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"n\">S</span> <span class=\"n\">V'</span> <span class=\"n\">S'</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">colored_quiver</span> <span class=\"n\">V</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">colored_quiver</span> <span class=\"n\">V'</span> <span class=\"n\">S'</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">→</span> <span class=\"n\">S'</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">prefunctor</span> <span class=\"n\">V</span> <span class=\"n\">V'</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">color</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">⟶</span> <span class=\"n\">y</span><span class=\"o\">),</span> <span class=\"n\">σ</span> <span class=\"o\">(</span><span class=\"n\">color</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">color</span> <span class=\"o\">(</span><span class=\"n\">map</span> <span class=\"n\">f</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>Is it worth having a map of labelling as a parameter?</p>\n</blockquote>\n<p>Maybe I shouldn't rush with this. In your opinion, what should the way forward with this look like?</p>",
        "id": 308615917,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1667922531
    },
    {
        "content": "<p>I guess we have the following options:</p>\n<ul>\n<li>\n<p><code>simple_graph</code> for Cayley graphs, and potentially also for Schreier graphs, although it doesn't make as much sense.<br>\n  The upside is that it's quite easy to setup, and <code>simple_graph</code> has plenty of API to make things work. It should also cover everything we need for the \"coarse\" aspect of GGT.</p>\n</li>\n<li>\n<p><code>quiver</code>-based Schreier and Cayley graphs. Here the API is quite thin in comparison, but on the theoretical side, we stay close to what we really \"think of\" as Cayley and Schreier graphs, and, modulo glue code, we should be able to translate to <code>simple_graph</code>s. <br>\n  I guess basing this on quivers has a potential advantage that it may actually help getting a better API around those? more lemmas and stuff.</p>\n</li>\n<li>\n<p>A new primitive, which allows not having to deal with the idiosyncracies of either encodings, but then you also have to redo most everything from scratch.</p>\n</li>\n</ul>",
        "id": 308617144,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1667922873
    },
    {
        "content": "<p>Actually,  your <code>labelled_digraph</code> doesn't allow for multiple arrows with same label between the same endpoints, does it?</p>",
        "id": 308645039,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1667931584
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/252551-graph-theory/topic/Cayley.20graphs.20.28again.29/near/308588565\">said</a>:</p>\n<blockquote>\n<p>Given what I know about GGT, when groups act on graphs they're mostly simple graphs, so having a <code>simple_graph.schreier_graph</code> and a <code>simple_graph.cayley_graph</code> might not be so crazy, even if they're not <em>the</em> correct notions</p>\n</blockquote>\n<p>Even if they act on simple graphs, the quotient is often not simple!</p>",
        "id": 308660347,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1667936359
    },
    {
        "content": "<p>Also, what about defining the Cayley graphof G with generating set S is as a quiver that comes with a covering map to the quiver that has a single vertex and on edge for each element of S? Then G is the group of automorphisms of this covering map (I think it's a natural way to encode the coloring, and  it's personally how I think about Cayley graphs).</p>",
        "id": 308661515,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1667936754
    },
    {
        "content": "<p>I guess the advantage of this definition is that we don't even have to define any new kind of structure, in theory.</p>",
        "id": 308723227,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1667974604
    },
    {
        "content": "<p>Mmh, the quiver approach is much less fun to implement. The type dependences make everything quite a bit more painful</p>",
        "id": 308760215,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1667990717
    },
    {
        "content": "<p>I agree and I think that's the biggest issue with <code>quiver</code>. After making that comment I tried to see if I could define covering maps for quivers, and I quickly ran into issues of of the type \"I want to prove that an edge from a to c is equal to an edge from b to c, where a is equal (but not definitionally) to b, so the two edges don't live in defeq types\".</p>",
        "id": 308816493,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1668009171
    },
    {
        "content": "<p>That's why I like the approach of <a href=\"https://github.com/leanprover-community/mathlib/pull/16100\">#16100</a>, where we have a single type for all of the edges. It has the disadvantage of introducing a new type and thus requiring duplication of a lot of quiver API, but I feel like it's probably the best way to do multigraphs.</p>",
        "id": 308816881,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1668009286
    },
    {
        "content": "<p>Well, in this case at least we'd need to remove the involution. I'd be kind of sad to have to drop quivers, since that means a pretty big split, but maybe that's the best way… I'll work on this Schreier graph stuff a bit more using quivers and see how it fares</p>",
        "id": 308820944,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1668010526
    },
    {
        "content": "<p>Would defining something like <a href=\"https://leanprover-community.github.io/mathlib_docs/find/simple_graph.walk.copy\">docs#simple_graph.walk.copy</a> to move edges along some equalities help?</p>",
        "id": 308823988,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1668011468
    },
    {
        "content": "<p>As far as I know, quivers don't have this (yet) because once you get to category theory you can make do with composition with identities associated to equalities -- but quivers don't have composition of arrows so this trick doesn't work.</p>",
        "id": 308824125,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1668011509
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"461830\">Rémi Bottinelli</span> <a href=\"#narrow/stream/252551-graph-theory/topic/Cayley.20graphs.20.28again.29/near/308820944\">said</a>:</p>\n<blockquote>\n<p>Well, in this case at least we'd need to remove the involution. I'd be kind of sad to have to drop quivers, since that means a pretty big split, but maybe that's the best way… I'll work on this Schreier graph stuff a bit more using quivers and see how it fares</p>\n</blockquote>\n<p>Yes, we could have a directed version and an undirected version extending it with the involution added.</p>",
        "id": 308826297,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1668012147
    },
    {
        "content": "<p>Might try the <code>copy</code> trick, though I'm not sure I've needed it until now (well, I haven't been aware of its need, rather <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span> ).</p>",
        "id": 308845107,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1668018285
    },
    {
        "content": "<p>For the record, here's an example of a \"non-defeq types\" issue that arises when trying to define covering maps. I think it would be solved by <code>copy</code>, but this feels very hacky, it would be nicer if all edges had the same type. </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">combinatorics.quiver.path</span>\n\n<span class=\"kd\">universes</span> <span class=\"n\">v</span> <span class=\"n\">v₁</span> <span class=\"n\">v₂</span> <span class=\"n\">u</span> <span class=\"n\">u₁</span> <span class=\"n\">u₂</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">function</span> <span class=\"n\">quiver</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₁</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">W</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₂</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">quiver.</span><span class=\"o\">{</span><span class=\"n\">v₁</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">}</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">quiver.</span><span class=\"o\">{</span><span class=\"n\">v₂</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">}</span> <span class=\"n\">W</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">in_link</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">Σ</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">,</span> <span class=\"n\">w</span> <span class=\"bp\">⟶</span> <span class=\"n\">v</span>\n<span class=\"kd\">def</span> <span class=\"n\">out_link</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">Σ</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">,</span> <span class=\"n\">v</span> <span class=\"bp\">⟶</span> <span class=\"n\">w</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">in_link_map</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">prefunctor</span> <span class=\"n\">V</span> <span class=\"n\">W</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">in_link</span> <span class=\"n\">v</span> <span class=\"bp\">→</span> <span class=\"n\">in_link</span> <span class=\"o\">(</span><span class=\"n\">F.obj</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">F.obj</span> <span class=\"n\">e.1</span><span class=\"o\">,</span> <span class=\"n\">F.map</span> <span class=\"n\">e.2</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">out_link_map</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">prefunctor</span> <span class=\"n\">V</span> <span class=\"n\">W</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">out_link</span> <span class=\"n\">v</span> <span class=\"bp\">→</span> <span class=\"n\">out_link</span> <span class=\"o\">(</span><span class=\"n\">F.obj</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">F.obj</span> <span class=\"n\">e.1</span><span class=\"o\">,</span> <span class=\"n\">F.map</span> <span class=\"n\">e.2</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">is_covering_map</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">prefunctor</span> <span class=\"n\">V</span> <span class=\"n\">W</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">in_link_map_bijective</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">bijective</span> <span class=\"o\">(</span><span class=\"n\">in_link_map</span> <span class=\"n\">F</span> <span class=\"n\">v</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">out_link_map_bijective</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">bijective</span> <span class=\"o\">(</span><span class=\"n\">out_link_map</span> <span class=\"n\">F</span> <span class=\"n\">v</span><span class=\"o\">))</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">prefunctor</span> <span class=\"n\">V</span> <span class=\"n\">W</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">is_covering_map</span> <span class=\"n\">F</span><span class=\"o\">]</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">lift_edge</span> <span class=\"o\">(</span><span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">W</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hv</span> <span class=\"o\">:</span> <span class=\"n\">F.obj</span> <span class=\"n\">v</span> <span class=\"bp\">=</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">out_link</span> <span class=\"n\">w</span> <span class=\"bp\">→</span> <span class=\"n\">out_link</span> <span class=\"n\">v</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"bp\">←</span><span class=\"n\">hv</span><span class=\"o\">,</span> <span class=\"n\">intro</span> <span class=\"n\">e</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">surj_inv</span> <span class=\"o\">(</span><span class=\"n\">is_covering_map.out_link_map_bijective</span> <span class=\"n\">v</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"n\">e</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"c1\">-- Lean doesn't accept this statement since the RHS has type `out_link w` while the LHS</span>\n<span class=\"c1\">-- has type `out_link (F.obj v)`.</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">map_lift_edge</span> <span class=\"o\">(</span><span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">W</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hv</span> <span class=\"o\">:</span> <span class=\"n\">F.obj</span> <span class=\"n\">v</span> <span class=\"bp\">=</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">out_link</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">out_link_map</span> <span class=\"n\">F</span> <span class=\"n\">v</span> <span class=\"o\">(</span><span class=\"n\">lift_edge</span> <span class=\"n\">F</span> <span class=\"n\">w</span> <span class=\"n\">v</span> <span class=\"n\">hv</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">e</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 308871393,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1668027101
    },
    {
        "content": "<p>This one is one <code>rec</code> away from typechecking:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">map_lift_edge</span> <span class=\"o\">(</span><span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">W</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hv</span> <span class=\"o\">:</span> <span class=\"n\">F.obj</span> <span class=\"n\">v</span> <span class=\"bp\">=</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">out_link</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">out_link_map</span> <span class=\"n\">F</span> <span class=\"n\">v</span> <span class=\"o\">(</span><span class=\"n\">lift_edge</span> <span class=\"n\">F</span> <span class=\"n\">w</span> <span class=\"n\">v</span> <span class=\"n\">hv</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">hv.symm.rec_on</span> <span class=\"n\">e</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>and the copy trick should work, or maybe rephrasing as</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">map_lift_edge'</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">out_link</span> <span class=\"bp\">$</span> <span class=\"n\">F.obj</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">out_link_map</span> <span class=\"n\">F</span> <span class=\"n\">v</span> <span class=\"o\">(</span><span class=\"n\">lift_edge</span> <span class=\"n\">F</span> <span class=\"o\">(</span><span class=\"n\">F.obj</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"n\">v</span> <span class=\"n\">rfl</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">e</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>?</p>",
        "id": 308926754,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1668061312
    },
    {
        "content": "<p>Ah, and actually, the covering approach provides an example of the argument that working with quivers will improve their api and benefit other sides of mathlib: Covering of groupoids are quite useful (I vaguely started <a href=\"https://github.com/bottine/mathlib/blob/bottine/groupoid_dev/src/category_theory/groupoid/covering.lean\">there</a> but then turned to other things). If we had a good api around coverings and lifting of paths in quivers, etc, it would make working with covering of groupoids that much easier.</p>",
        "id": 308931949,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1668064891
    },
    {
        "content": "<p>Maybe before starting Schreier/Cayley graphs, we'd need some preliminary work on overhauling the quiver code, adding the notion of forests, reduced paths, <code>copy</code>, covering, etc, and only start with Schreier/Cayley graphs then</p>",
        "id": 308932305,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1668065114
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"329754\">@Antoine Labelle</span> Using your example, here's how <code>cast</code> (a better name for <code>copy</code>) could work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">out_link.cast</span> <span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">out_link</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">u</span> <span class=\"bp\">=</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">out_link</span> <span class=\"n\">v</span> <span class=\"o\">:=</span>\n<span class=\"n\">eq.rec</span> <span class=\"n\">e</span> <span class=\"n\">h</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">out_link.cast_rfl</span> <span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">out_link</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">e.cast</span> <span class=\"n\">rfl</span> <span class=\"bp\">=</span> <span class=\"n\">e</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">out_link.cast_cast</span> <span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">out_link</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hu</span> <span class=\"o\">:</span> <span class=\"n\">u</span> <span class=\"bp\">=</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hv</span> <span class=\"o\">:</span> <span class=\"n\">v</span> <span class=\"bp\">=</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">e.cast</span> <span class=\"n\">hu</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">cast</span> <span class=\"n\">hv</span> <span class=\"bp\">=</span> <span class=\"n\">e.cast</span> <span class=\"o\">(</span><span class=\"n\">hu.trans</span> <span class=\"n\">hv</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">subst_vars</span><span class=\"o\">,</span> <span class=\"n\">refl</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">map_lift_edge</span> <span class=\"o\">(</span><span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">W</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hv</span> <span class=\"o\">:</span> <span class=\"n\">F.obj</span> <span class=\"n\">v</span> <span class=\"bp\">=</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">out_link</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">out_link_map</span> <span class=\"n\">F</span> <span class=\"n\">v</span> <span class=\"o\">(</span><span class=\"n\">lift_edge</span> <span class=\"n\">F</span> <span class=\"n\">w</span> <span class=\"n\">v</span> <span class=\"n\">hv</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">e.cast</span> <span class=\"n\">hv.symm</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">subst</span> <span class=\"n\">hv</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">surj_inv_eq</span> <span class=\"o\">(</span><span class=\"n\">is_covering_map.out_link_map_bijective</span> <span class=\"n\">v</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"n\">e</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 308946856,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1668071792
    },
    {
        "content": "<p>I think this \"cast pattern\" should be considered to be a design pattern for working with dependent types. It provides a consistent interface for how you do rewrites on indices, which otherwise can get unweidly if you have unrestricted <code>eq.rec</code>s in your expressions.</p>",
        "id": 308947109,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1668071883
    },
    {
        "content": "<p>It might feel hacky because in category theory this is \"evil\" (you are not supposed to talk about equalities of objects, only isomorphisms), however quivers and graphs do not have isomorphisms, and maps between graphs (prefunctors) quickly reveal this to be an issue.</p>\n<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/simple_graph.walk.map_eq_of_eq\">docs#simple_graph.walk.map_eq_of_eq</a> is the type of lemma that revealed the need for an index cast</p>",
        "id": 308947773,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1668072126
    },
    {
        "content": "<p>Hey, so we've defined <a href=\"https://github.com/bottine/mathlib/blob/bb0f7d97b526ddbf98369a166c79285d467c09a1/src/combinatorics/quiver/covering.lean\">coverings of quivers here</a> and the goal is to define Schreier graphs as quivers + a covering onto a bouquet.</p>\n<p>After some discussions, I'm not sure whether we should bundle it as a struct containing the quiver and the covering, or just have the covering floating vaguely in the context. Similarly, we'll want to talk about covering morphisms and the automorphism group of Cayley graphs (probably), and it's becoming unclear the amount of bundling we should choose. A more basic question already leading to this is: how to define isomorphisms of quivers?</p>\n<p>What do people with more experience with this kind of things think?</p>",
        "id": 313953179,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1670243660
    }
]
[
    {
        "content": "<p>Question: I want to prove that, in any given graph  <code>G</code> over vertex set <code>V</code>, there exists a path of maximum length. The way I want to prove it is, since <code>path.length</code> maps to <code>ℕ</code>, I want to try to use Zorn's lemma to show that there is a maximum</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"nn\">.basic</span>\n\n<span class=\"n\">universes</span> <span class=\"n\">u</span>\n<span class=\"n\">variables</span> <span class=\"p\">{</span><span class=\"n\">V</span> <span class=\"p\">:</span> <span class=\"n\">Type</span> <span class=\"n\">u</span><span class=\"p\">}</span>\n\n<span class=\"n\">namespace</span> <span class=\"n\">simple_graph</span>\n<span class=\"n\">variables</span> <span class=\"p\">(</span><span class=\"n\">G</span> <span class=\"p\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"p\">)</span>\n\n<span class=\"o\">/--</span> <span class=\"n\">Morally</span><span class=\"p\">,</span> <span class=\"n\">a</span> <span class=\"n\">path</span> <span class=\"ow\">is</span> <span class=\"n\">an</span> <span class=\"n\">alternating</span> <span class=\"nb\">list</span> <span class=\"n\">of</span> <span class=\"n\">vertices</span> <span class=\"ow\">and</span> <span class=\"n\">edges</span><span class=\"p\">,</span>\n  <span class=\"k\">with</span> <span class=\"n\">incidences</span> <span class=\"n\">between</span> <span class=\"n\">adjacent</span> <span class=\"n\">objects</span> <span class=\"o\">-/</span>\n<span class=\"o\">@</span><span class=\"p\">[</span><span class=\"n\">ext</span><span class=\"p\">]</span> <span class=\"n\">structure</span> <span class=\"n\">path</span> <span class=\"o\">:=</span>\n<span class=\"p\">(</span><span class=\"n\">head</span> <span class=\"p\">:</span> <span class=\"n\">V</span><span class=\"p\">)</span>\n<span class=\"p\">(</span><span class=\"n\">tail</span> <span class=\"p\">:</span> <span class=\"nb\">list</span> <span class=\"n\">V</span><span class=\"p\">)</span>\n<span class=\"p\">(</span><span class=\"n\">edges</span> <span class=\"p\">:</span> <span class=\"nb\">list</span> <span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">E</span><span class=\"p\">)</span>\n<span class=\"p\">(</span><span class=\"n\">length_eq</span> <span class=\"p\">:</span> <span class=\"n\">edges</span><span class=\"o\">.</span><span class=\"n\">length</span> <span class=\"o\">=</span> <span class=\"n\">tail</span><span class=\"o\">.</span><span class=\"n\">length</span><span class=\"p\">)</span>\n<span class=\"p\">(</span><span class=\"n\">adj</span> <span class=\"p\">:</span> <span class=\"err\">∀</span> <span class=\"p\">(</span><span class=\"n\">n</span> <span class=\"p\">:</span> <span class=\"n\">ℕ</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"n\">hn</span> <span class=\"p\">:</span> <span class=\"n\">n</span> <span class=\"o\">&lt;</span> <span class=\"n\">edges</span><span class=\"o\">.</span><span class=\"n\">length</span><span class=\"p\">),</span>\n  <span class=\"n\">let</span> <span class=\"n\">u</span> <span class=\"o\">:=</span> <span class=\"p\">(</span><span class=\"nb\">list</span><span class=\"o\">.</span><span class=\"n\">cons</span> <span class=\"n\">head</span> <span class=\"n\">tail</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">nth_le</span> <span class=\"n\">n</span> <span class=\"p\">(</span><span class=\"n\">by</span> <span class=\"p\">{</span> <span class=\"n\">simp</span><span class=\"p\">;</span> <span class=\"n\">omega</span> <span class=\"p\">})</span> <span class=\"ow\">in</span>\n  <span class=\"n\">let</span> <span class=\"n\">v</span> <span class=\"o\">:=</span> <span class=\"p\">(</span><span class=\"nb\">list</span><span class=\"o\">.</span><span class=\"n\">cons</span> <span class=\"n\">head</span> <span class=\"n\">tail</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">nth_le</span> <span class=\"p\">(</span><span class=\"n\">n</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"n\">by</span> <span class=\"p\">{</span> <span class=\"n\">simp</span><span class=\"p\">,</span> <span class=\"n\">cc</span> <span class=\"p\">})</span> <span class=\"ow\">in</span>\n  <span class=\"n\">u</span> <span class=\"err\">≠</span> <span class=\"n\">v</span> <span class=\"err\">∧</span> <span class=\"n\">u</span> <span class=\"err\">∈</span> <span class=\"n\">edges</span><span class=\"o\">.</span><span class=\"n\">nth_le</span> <span class=\"n\">n</span> <span class=\"n\">hn</span> <span class=\"err\">∧</span> <span class=\"n\">v</span> <span class=\"err\">∈</span> <span class=\"n\">edges</span><span class=\"o\">.</span><span class=\"n\">nth_le</span> <span class=\"n\">n</span> <span class=\"n\">hn</span><span class=\"p\">)</span>\n\n\n<span class=\"n\">namespace</span> <span class=\"n\">path</span>\n<span class=\"n\">variables</span> <span class=\"p\">{</span><span class=\"n\">G</span><span class=\"p\">}</span>\n<span class=\"n\">variables</span> <span class=\"p\">(</span><span class=\"n\">p</span> <span class=\"p\">:</span> <span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">path</span><span class=\"p\">)</span>\n\n<span class=\"o\">/--</span> <span class=\"n\">The</span> <span class=\"n\">ordered</span> <span class=\"nb\">list</span> <span class=\"n\">of</span> <span class=\"nb\">all</span> <span class=\"n\">vertices</span> <span class=\"ow\">in</span> <span class=\"n\">p</span><span class=\"p\">,</span> <span class=\"n\">starting</span> <span class=\"n\">at</span> <span class=\"n\">p</span><span class=\"o\">.</span><span class=\"n\">head</span> <span class=\"ow\">and</span> <span class=\"n\">ending</span> <span class=\"n\">at</span> <span class=\"n\">p</span><span class=\"o\">.</span><span class=\"n\">sink</span><span class=\"o\">.</span> <span class=\"o\">-/</span>\n<span class=\"k\">def</span> <span class=\"nf\">vertices</span> <span class=\"p\">:</span> <span class=\"nb\">list</span> <span class=\"n\">V</span> <span class=\"o\">:=</span> <span class=\"n\">p</span><span class=\"o\">.</span><span class=\"n\">head</span> <span class=\"p\">::</span> <span class=\"n\">p</span><span class=\"o\">.</span><span class=\"n\">tail</span>\n\n<span class=\"o\">/--</span> <span class=\"n\">The</span> <span class=\"n\">number</span> <span class=\"n\">of</span> <span class=\"n\">edges</span> <span class=\"ow\">in</span> <span class=\"n\">p</span><span class=\"o\">.</span> <span class=\"o\">-/</span>\n<span class=\"k\">def</span> <span class=\"nf\">length</span> <span class=\"p\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"n\">p</span><span class=\"o\">.</span><span class=\"n\">tail</span><span class=\"o\">.</span><span class=\"n\">length</span>\n<span class=\"o\">--</span> <span class=\"n\">should</span> <span class=\"n\">probably</span> <span class=\"n\">make</span> <span class=\"n\">sure</span> <span class=\"n\">this</span> <span class=\"n\">doesn</span><span class=\"s1\">&#39;t become a problem if we run into infinite graphs?</span>\n\n<span class=\"n\">variables</span> <span class=\"p\">{</span><span class=\"n\">p</span><span class=\"p\">}</span>\n\n<span class=\"o\">/--</span> <span class=\"n\">p</span><span class=\"o\">.</span><span class=\"n\">vertex_mem</span> <span class=\"n\">v</span> <span class=\"n\">holds</span> <span class=\"k\">if</span> <span class=\"n\">v</span> <span class=\"ow\">is</span> <span class=\"n\">a</span> <span class=\"n\">vertex</span> <span class=\"n\">along</span> <span class=\"n\">path</span> <span class=\"n\">p</span><span class=\"o\">.</span> <span class=\"o\">-/</span>\n<span class=\"k\">def</span> <span class=\"nf\">vertex_mem</span> <span class=\"p\">(</span><span class=\"n\">v</span> <span class=\"p\">:</span> <span class=\"n\">V</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"n\">p</span> <span class=\"p\">:</span> <span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">path</span><span class=\"p\">)</span> <span class=\"p\">:</span> <span class=\"n\">Prop</span> <span class=\"o\">:=</span> <span class=\"n\">v</span> <span class=\"err\">∈</span> <span class=\"n\">p</span><span class=\"o\">.</span><span class=\"n\">vertices</span>\n<span class=\"n\">instance</span> <span class=\"n\">has_mem_vertices</span> <span class=\"p\">:</span> <span class=\"n\">has_mem</span> <span class=\"n\">V</span> <span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">path</span> <span class=\"o\">:=</span>\n<span class=\"p\">{</span> <span class=\"n\">mem</span> <span class=\"o\">:=</span> <span class=\"n\">vertex_mem</span> <span class=\"p\">}</span>\n<span class=\"n\">variables</span> <span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">)</span>\n\n<span class=\"o\">/--</span> <span class=\"n\">The</span> <span class=\"n\">empty</span> <span class=\"n\">path</span> <span class=\"n\">based</span> <span class=\"n\">at</span> <span class=\"n\">vertex</span> <span class=\"n\">v</span><span class=\"o\">.</span> <span class=\"o\">-/</span>\n<span class=\"o\">@</span><span class=\"p\">[</span><span class=\"n\">simps</span><span class=\"p\">]</span>\n<span class=\"k\">def</span> <span class=\"nf\">empty</span> <span class=\"p\">(</span><span class=\"n\">G</span> <span class=\"p\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"n\">v</span> <span class=\"p\">:</span> <span class=\"n\">V</span><span class=\"p\">)</span> <span class=\"p\">:</span> <span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">path</span> <span class=\"o\">:=</span>\n<span class=\"p\">{</span> <span class=\"n\">head</span> <span class=\"o\">:=</span> <span class=\"n\">v</span><span class=\"p\">,</span>\n  <span class=\"n\">tail</span> <span class=\"o\">:=</span> <span class=\"nb\">list</span><span class=\"o\">.</span><span class=\"n\">nil</span><span class=\"p\">,</span>\n  <span class=\"n\">edges</span> <span class=\"o\">:=</span> <span class=\"nb\">list</span><span class=\"o\">.</span><span class=\"n\">nil</span><span class=\"p\">,</span>\n  <span class=\"n\">length_eq</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span><span class=\"p\">,</span>\n  <span class=\"n\">adj</span> <span class=\"o\">:=</span> <span class=\"n\">by</span> <span class=\"n\">rintros</span> <span class=\"n\">_</span> <span class=\"err\">⟨</span><span class=\"n\">_</span><span class=\"err\">⟩</span> <span class=\"p\">}</span>\n\n<span class=\"n\">instance</span> <span class=\"p\">[</span><span class=\"n\">inhabited</span> <span class=\"n\">V</span><span class=\"p\">]</span> <span class=\"p\">:</span> <span class=\"n\">inhabited</span> <span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">path</span> <span class=\"o\">:=</span> <span class=\"p\">{</span> <span class=\"n\">default</span> <span class=\"o\">:=</span> <span class=\"n\">empty</span> <span class=\"n\">G</span> <span class=\"p\">(</span><span class=\"n\">arbitrary</span> <span class=\"n\">V</span><span class=\"p\">)</span> <span class=\"p\">}</span>\n\n<span class=\"o\">@</span><span class=\"p\">[</span><span class=\"n\">simp</span><span class=\"p\">]</span>\n<span class=\"n\">lemma</span> <span class=\"n\">empty_length</span> <span class=\"p\">(</span><span class=\"n\">v</span> <span class=\"p\">:</span> <span class=\"n\">V</span><span class=\"p\">)</span> <span class=\"p\">:</span> <span class=\"p\">(</span><span class=\"n\">empty</span> <span class=\"n\">G</span> <span class=\"n\">v</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">length</span> <span class=\"o\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">by</span> <span class=\"n\">refl</span>\n\n<span class=\"o\">/--</span> <span class=\"n\">p</span><span class=\"o\">.</span><span class=\"n\">is_tour</span> <span class=\"k\">if</span> <span class=\"n\">p</span> <span class=\"n\">has</span> <span class=\"n\">no</span> <span class=\"n\">repeated</span> <span class=\"n\">vertices</span><span class=\"o\">.</span> <span class=\"o\">-/</span>\n<span class=\"k\">def</span> <span class=\"nf\">is_tour</span> <span class=\"p\">:</span> <span class=\"n\">Prop</span> <span class=\"o\">:=</span> <span class=\"nb\">list</span><span class=\"o\">.</span><span class=\"n\">nodup</span> <span class=\"n\">p</span><span class=\"o\">.</span><span class=\"n\">vertices</span>\n<span class=\"o\">--</span> <span class=\"n\">maybe</span> <span class=\"n\">prove</span> <span class=\"n\">that</span> <span class=\"err\">`</span><span class=\"n\">is_tour</span> <span class=\"err\">→</span> <span class=\"n\">is_trail</span><span class=\"err\">`</span>\n\n<span class=\"o\">/--</span> <span class=\"n\">p</span><span class=\"o\">.</span><span class=\"n\">is_maximum</span> <span class=\"k\">if</span> <span class=\"n\">the</span> <span class=\"n\">length</span> <span class=\"n\">of</span> <span class=\"n\">p</span> <span class=\"ow\">is</span> <span class=\"n\">greater</span> <span class=\"n\">than</span> <span class=\"ow\">or</span> <span class=\"n\">equal</span> <span class=\"n\">to</span> <span class=\"n\">the</span> <span class=\"n\">length</span> <span class=\"n\">of</span> <span class=\"n\">every</span> <span class=\"n\">other</span> <span class=\"n\">path</span><span class=\"o\">.</span> <span class=\"o\">-/</span>\n<span class=\"k\">def</span> <span class=\"nf\">is_maximum</span> <span class=\"p\">:</span> <span class=\"n\">Prop</span> <span class=\"o\">:=</span> <span class=\"n\">p</span><span class=\"o\">.</span><span class=\"n\">is_tour</span> <span class=\"err\">∧</span> <span class=\"err\">∀</span> <span class=\"p\">(</span><span class=\"n\">q</span> <span class=\"p\">:</span> <span class=\"n\">path</span> <span class=\"n\">G</span><span class=\"p\">),</span> <span class=\"n\">q</span><span class=\"o\">.</span><span class=\"n\">length</span> <span class=\"err\">≤</span> <span class=\"n\">p</span><span class=\"o\">.</span><span class=\"n\">length</span>\n\n<span class=\"o\">/-</span> <span class=\"n\">there</span> <span class=\"n\">exists</span> <span class=\"n\">a</span> <span class=\"n\">path</span><span class=\"p\">,</span> <span class=\"n\">path</span><span class=\"o\">.</span><span class=\"n\">is_tour</span><span class=\"p\">,</span> <span class=\"n\">s</span><span class=\"o\">.</span><span class=\"n\">t</span><span class=\"o\">.</span> <span class=\"n\">path</span><span class=\"o\">.</span><span class=\"n\">is_maximal</span> <span class=\"o\">-/</span>\n<span class=\"o\">--</span> <span class=\"n\">CR</span> <span class=\"p\">:</span> <span class=\"n\">can</span> <span class=\"n\">be</span> <span class=\"n\">generalized</span> <span class=\"n\">to</span> <span class=\"n\">infinite</span> <span class=\"n\">graphs</span>\n<span class=\"n\">lemma</span> <span class=\"n\">fin_max_tour</span> <span class=\"p\">[</span><span class=\"n\">fintype</span> <span class=\"n\">V</span><span class=\"p\">]</span> <span class=\"p\">[</span><span class=\"n\">inhabited</span> <span class=\"n\">V</span><span class=\"p\">]:</span> <span class=\"err\">∃</span> <span class=\"p\">(</span><span class=\"n\">p</span> <span class=\"p\">:</span> <span class=\"n\">path</span> <span class=\"n\">G</span><span class=\"p\">),</span> <span class=\"n\">p</span><span class=\"o\">.</span><span class=\"n\">is_maximum</span> <span class=\"o\">:=</span>\n<span class=\"n\">begin</span>\n\n  <span class=\"n\">sorry</span><span class=\"p\">,</span>\n<span class=\"n\">end</span>\n\n<span class=\"n\">end</span> <span class=\"n\">path</span>\n\n<span class=\"n\">end</span> <span class=\"n\">simple_graph</span>\n</code></pre></div>",
        "id": 206740029,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1597260847
    },
    {
        "content": "<p>So this mwe is as minimal as it gets I think, as long as your definition of <code>simple_graph</code> isn't too far off from the one I'm using it should be fine</p>",
        "id": 206740131,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1597260913
    },
    {
        "content": "<p>Hopefully you don't need anything as powerful as Zorn.</p>",
        "id": 206740644,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597261162
    },
    {
        "content": "<p><code>is_maximum</code> is only based on the ranking by length, so I would look at the set of naturals that are the length of some path.</p>",
        "id": 206740783,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597261225
    },
    {
        "content": "<p>I sort of suspect I might :/ I think the proof of a maximum path needs to build on the existence of maximal paths (i.e. local maximum)</p>",
        "id": 206740801,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1597261234
    },
    {
        "content": "<p>My question is, how do I obtain that set exactly?</p>",
        "id": 206740851,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1597261269
    },
    {
        "content": "<p>I have the map into the naturals, it's just <code>length</code>, but I'm struggling to phrase the fact that there is some path that maps to the greatest number</p>",
        "id": 206741058,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1597261381
    },
    {
        "content": "<p>one approach would be <code>{n : ℕ | ∃ (p : G.path), p.length = n}</code></p>",
        "id": 206741070,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597261387
    },
    {
        "content": "<p>but I think also you could use the image API</p>",
        "id": 206741108,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597261408
    },
    {
        "content": "<p>and say something like <code>(length : G.path → ℕ) '' set.univ</code></p>",
        "id": 206741209,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597261448
    },
    {
        "content": "<p>Either way, your goal is to show that set is finite/bounded. Then there should be a lemma somewhere that says it has a maximum.</p>",
        "id": 206741332,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597261503
    },
    {
        "content": "<p>Ahh gotcha. Didn't know I could declare sets like that</p>",
        "id": 206741351,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1597261513
    },
    {
        "content": "<p>Yeah I'm working on another lemma that says path lengths can't go over the cardinality of <code>V</code> if we have <code>fintype V</code></p>",
        "id": 206741383,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1597261536
    },
    {
        "content": "<p>Once you have that maximum, you just look back at the preimage, and any of those paths should be a maximum path by your definition</p>",
        "id": 206741393,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597261541
    },
    {
        "content": "<p>I know that there exists something called <code>finset.max</code> and something called <code>finset.max'</code>, which should be useful</p>",
        "id": 206741497,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597261585
    },
    {
        "content": "<p>Great, thank you!</p>",
        "id": 206741526,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1597261606
    },
    {
        "content": "<p>and it'd be extra-useful to have a <code>fintype G.path</code> instance, because then your set of paths could be <code>(length : G.path → ℕ) '' finset.univ</code>, which is already a finset</p>",
        "id": 206741561,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597261626
    },
    {
        "content": "<p>We have that duplicate edges can't happen and we also have<code>fintype V</code>, that should be enough to prove <code>fintype G.path.is_tour</code> right? (I assume I can just say <code>G.path.is_tour</code> to refer to the collection of paths that don't repeat any vertices?)</p>",
        "id": 206741807,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1597261775
    },
    {
        "content": "<p><code>G.path</code> currently allows for paths to loop back on themselves</p>",
        "id": 206741899,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1597261807
    },
    {
        "content": "<p>Now that I think about it, proving and then using the fact that <code>fintype G.path.is_tour</code> is a good way of proving the lemma, though I think both that and the fact that the lengths are bounded above by <code>V.card</code> are useful in their own ways</p>",
        "id": 206742333,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1597262035
    },
    {
        "content": "<p>Knowing that a set of naturals is bounded above should be enough to show it has a maximum, I'm just not sure where in the API that is</p>",
        "id": 206743120,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597262342
    },
    {
        "content": "<p>Aha, nat has a <code>conditionally_complete_linear_order</code> instance</p>",
        "id": 206743345,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597262434
    },
    {
        "content": "<p>so you can take <code>Sup</code>s of arbitrary bounded sets of naturals</p>",
        "id": 206743422,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597262465
    },
    {
        "content": "<p>Perfect, thanks!</p>",
        "id": 206743503,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1597262492
    },
    {
        "content": "<p>The order library is disturbingly powerful, but also inscrutable at first, because nobody teaches much order theory notation in regular math classes</p>",
        "id": 206743656,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597262553
    },
    {
        "content": "<p>Also, if you don't mind me asking, what's wrong with using Zorn's lemma? Isn't it basically just an axiom? Or is the issue that we want to avoid assuming too much</p>",
        "id": 206744706,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1597263091
    },
    {
        "content": "<p>There's a general preference in math to use the minimum amount of choice you need</p>",
        "id": 206744880,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597263162
    },
    {
        "content": "<p>That's extra-true in computer formalization with constructive elements, because invoking choice is clunkier on a computer than our mathematician intuitions might guess</p>",
        "id": 206745017,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597263229
    },
    {
        "content": "<p>and some people in the community would probably prefer we didn't use it at all, but they've long lost that debate in mathlib</p>",
        "id": 206745196,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597263285
    },
    {
        "content": "<p>But the real reason is that Zorn kind of obscures what's really going on</p>",
        "id": 206745312,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597263326
    },
    {
        "content": "<p>what's really going on here is that bounded sets of natural numbers have maxima</p>",
        "id": 206745395,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597263356
    },
    {
        "content": "<p>and in order to invoke Zorn for paths, you need to first show that all chains of paths have upper bounds</p>",
        "id": 206745554,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597263411
    },
    {
        "content": "<p>but if you translate that into natural numbers, all sets of natural numbers are chains, so it's the same as showing your sets have maxima</p>",
        "id": 206745603,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597263442
    },
    {
        "content": "<p>Right, yeah that was my thought with maximal paths</p>",
        "id": 206745611,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1597263447
    },
    {
        "content": "<p>and then also, the result you get is about maximal paths, which are different than maximum paths as you've defined them</p>",
        "id": 206745654,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597263469
    },
    {
        "content": "<p>But I guess it is easier to just say bounded sets of natural numbers have maxima</p>",
        "id": 206745670,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1597263475
    },
    {
        "content": "<p>Yeah but I was saying I could use the maximal paths result for the maximum path lemma</p>",
        "id": 206745742,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1597263492
    },
    {
        "content": "<p>Yeah, it gets you the result you want, and you'd need to prove that anyway to invoke Zorn, so Zorn is just an extra step</p>",
        "id": 206745752,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597263498
    },
    {
        "content": "<p>I gotcha</p>",
        "id": 206745765,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1597263506
    },
    {
        "content": "<p>How would you get from maximal paths to maximum paths? I feel like you'd still be showing that a set of lengths has a maximum...</p>",
        "id": 206745807,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597263530
    },
    {
        "content": "<p>I was thinking that the chains would be like, \"sub\"-paths of larger paths</p>",
        "id": 206746054,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1597263623
    },
    {
        "content": "<p>So smaller paths whose edge sets intersect with the larger path</p>",
        "id": 206746097,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1597263644
    },
    {
        "content": "<p>I've was working through Dummit and Foote a couple of hours ago and there was a similar proof for maximal subgroups so I might be overcomplicating things</p>",
        "id": 206746237,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1597263714
    },
    {
        "content": "<p>Yeah, Zorn's lemma is a very specific recipe, which is great for making minimal and maximal algebraic widgets, because those things are a very specific sort of lattice really</p>",
        "id": 206746690,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597263899
    },
    {
        "content": "<p>I think I might've just misunderstood that recipe</p>",
        "id": 206746760,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1597263944
    },
    {
        "content": "<p>something something if you have a hammer everything looks like a nail</p>",
        "id": 206746869,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1597263982
    },
    {
        "content": "<p>There's a reason it took people ages to realize it was needed as a separate axiom...</p>",
        "id": 206746875,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597263987
    },
    {
        "content": "<p>I've definitely been guilty of looking for nails to hammer with Zorn, but I've also found myself on an algebra qual, trying to build a maximal widget, and then failed to find the right poset to do Zorn in, so I handwrote a 2 page transfinite induction proof instead...</p>",
        "id": 206747026,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597264072
    },
    {
        "content": "<p>Oh god lmao</p>",
        "id": 206747091,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1597264085
    },
    {
        "content": "<p>mercifully I'm in a department with enough logicians that that still got full credit, even if it's objectively worse than just modifying the poset slightly and hitting it with Zorn like some of my friends did</p>",
        "id": 206747153,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597264126
    },
    {
        "content": "<p>Yeah I probably should've thought out the difference between maximal/maximum more before starting with this lemma</p>",
        "id": 206747167,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1597264137
    },
    {
        "content": "<p>That distinction between maximal and maximum-size is gonna pop up all the time in graph theory...</p>",
        "id": 206747232,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597264185
    },
    {
        "content": "<p>Yeah my combinatorics professor mentioned it a lot, I probably should be more careful about it</p>",
        "id": 206747325,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1597264227
    },
    {
        "content": "<p>Especially since I'm now realizing that the next lemma that I wanted to prove only requires <em>maximal</em> paths and not maximum lol</p>",
        "id": 206747359,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1597264254
    },
    {
        "content": "<p>Maximum path is easier though</p>",
        "id": 206747433,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1597264290
    },
    {
        "content": "<p>TBH I think the easiest way to prove the existence of maximal paths here is by proving the existence of maximum paths, and observing that those are maximal</p>",
        "id": 206747441,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597264294
    },
    {
        "content": "<p>The next lemma is that trees contain two vertices of degree one, which means the existence of a maximal (or maximum) path</p>",
        "id": 206747546,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1597264325
    },
    {
        "content": "<p>Gotcha</p>",
        "id": 206747575,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1597264343
    },
    {
        "content": "<p>Yeah my professor used maximal paths in his proof but I'm not quite sure why now</p>",
        "id": 206747615,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1597264369
    },
    {
        "content": "<p>Verbally, it's easier to describe why maximal tours exist</p>",
        "id": 206747664,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597264397
    },
    {
        "content": "<p>just keep walking until you can't</p>",
        "id": 206747692,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597264408
    },
    {
        "content": "<p>This is true</p>",
        "id": 206747719,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1597264419
    },
    {
        "content": "<p>I don't think we ever proved the existence of maximal/maximum paths in class but I'm probably being overly nitpicky at this point</p>",
        "id": 206747898,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1597264514
    },
    {
        "content": "<p>Cause it's one of those things that's \"obvious\" I guess</p>",
        "id": 206747927,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1597264530
    },
    {
        "content": "<p>If I wanted to prove that the path lengths are all bounded above by <code>V.card</code>, would this be the right way to go about it? Or is it still overcomplicating things</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">instance</span> <span class=\"p\">:</span> <span class=\"n\">has_Sup</span> <span class=\"p\">{</span><span class=\"n\">n</span> <span class=\"p\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">|</span> <span class=\"err\">∃</span> <span class=\"p\">(</span><span class=\"n\">p</span> <span class=\"p\">:</span> <span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">path</span><span class=\"p\">),</span> <span class=\"n\">p</span><span class=\"o\">.</span><span class=\"n\">is_tour</span> <span class=\"err\">∧</span> <span class=\"n\">p</span><span class=\"o\">.</span><span class=\"n\">length</span> <span class=\"o\">=</span> <span class=\"n\">n</span><span class=\"p\">}</span> <span class=\"o\">:=</span>\n<span class=\"n\">begin</span>\n  <span class=\"n\">sorry</span><span class=\"p\">,</span>\n<span class=\"n\">end</span>\n</code></pre></div>",
        "id": 206750031,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1597265586
    },
    {
        "content": "<p>I also have this lemma </p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"o\">/-</span> <span class=\"n\">length</span> <span class=\"n\">of</span> <span class=\"n\">path</span><span class=\"o\">.</span><span class=\"n\">is_tour</span> <span class=\"ow\">is</span> <span class=\"n\">less</span> <span class=\"n\">than</span> <span class=\"ow\">or</span> <span class=\"n\">equal</span> <span class=\"n\">to</span> <span class=\"n\">the</span> <span class=\"n\">cardinality</span> <span class=\"n\">of</span> <span class=\"n\">V</span> <span class=\"o\">-/</span>\n<span class=\"n\">lemma</span> <span class=\"n\">tour_le_card</span> <span class=\"p\">[</span><span class=\"n\">fintype</span> <span class=\"n\">V</span><span class=\"p\">]</span> <span class=\"p\">:</span> <span class=\"err\">∀</span> <span class=\"p\">(</span><span class=\"n\">p</span> <span class=\"p\">:</span> <span class=\"n\">path</span> <span class=\"n\">G</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"n\">hp</span> <span class=\"p\">:</span> <span class=\"n\">p</span><span class=\"o\">.</span><span class=\"n\">is_tour</span><span class=\"p\">),</span> <span class=\"n\">p</span><span class=\"o\">.</span><span class=\"n\">length</span> <span class=\"o\">&lt;</span> <span class=\"n\">fintype</span><span class=\"o\">.</span><span class=\"n\">card</span> <span class=\"n\">V</span> <span class=\"o\">:=</span>\n<span class=\"n\">begin</span>\n  <span class=\"n\">intros</span><span class=\"p\">,</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">is_tour</span> <span class=\"n\">at</span> <span class=\"n\">hp</span><span class=\"p\">,</span>\n  <span class=\"n\">sorry</span><span class=\"p\">,</span>\n<span class=\"n\">end</span>\n</code></pre></div>",
        "id": 206750315,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1597265734
    },
    {
        "content": "<p>I've seen people prove lemmas and then use those lemmas in <code>instance</code>s so that the objects they're working with have the properties they need, so I'm trying to imitate that</p>",
        "id": 206750584,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1597265842
    },
    {
        "content": "<p>You want to use the <code>Sup</code> functionality of <code>conditionally_complete_lattice</code>, right?</p>",
        "id": 206752207,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597266564
    },
    {
        "content": "<p>The <code>Sup</code> function is defined there for all possible sets of naturals you might want to take <code>Sup</code>s of, but it only conditionally has the property of really being a supremum</p>",
        "id": 206752384,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597266642
    },
    {
        "content": "<p>If you look at the docs here <a href=\"https://leanprover-community.github.io/mathlib_docs/order/conditionally_complete_lattice.html\">https://leanprover-community.github.io/mathlib_docs/order/conditionally_complete_lattice.html</a></p>",
        "id": 206752423,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597266663
    },
    {
        "content": "<p>The relevant aspects of that structure are things like this: <code>le_cSup : ∀ (s : set α) (a : α), bdd_above s → a ∈ s → a ≤ conditionally_complete_lattice.Sup s</code></p>",
        "id": 206752480,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597266694
    },
    {
        "content": "<p>So what you want to show is <code>bdd_above set_of_relevant_paths</code></p>",
        "id": 206752564,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597266728
    },
    {
        "content": "<p>actually, what might be a better idea</p>",
        "id": 206752806,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597266820
    },
    {
        "content": "<p>is to look at how that <code>Sup</code> is defined</p>",
        "id": 206752820,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597266828
    },
    {
        "content": "<p>it's defined using <code>nat.find</code>, which might have even more convenient facts proved about it</p>",
        "id": 206752920,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597266865
    },
    {
        "content": "<p>I think you can do it with either one, so just take a look at the docs for both and see which you prefer</p>",
        "id": 206753394,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597267085
    },
    {
        "content": "<p><code>nat.find</code> takes in an exists statement, and finds you the minimum natural number satisfying that statement</p>",
        "id": 206753436,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597267108
    },
    {
        "content": "<p>I don't think I get how to use either method, but I'll poke around the docs and code to see if I can figure it out</p>",
        "id": 206753838,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1597267315
    },
    {
        "content": "<p>ok, let me know if you stay stuck, but either method should be able to get you from the lemma <code>tour_le_card</code> to the least upper bound, and then you prove that that least upper bound is the maximum, and that there exists a path that has that exact length, which is thus a maximum path</p>",
        "id": 206754160,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597267470
    },
    {
        "content": "<p>although with your naming, you might want to call that <code>tour_lt_card</code>, as <code>le</code> refers to \"Less than or Equal to\" while <code>lt</code> refers to \"Less Than\"</p>",
        "id": 206754221,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597267512
    },
    {
        "content": "<p>I keep switching back and forth between wanting to count the vertices vs the edges in the path lengths cause it seems like counting edges is the convention in the code I've copied, but I prefer vertices lol</p>",
        "id": 206754720,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1597267705
    },
    {
        "content": "<p>Hence not updating the name when I switched to counting edges for consistency</p>",
        "id": 206754778,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1597267729
    },
    {
        "content": "<p>hot take: maybe the definition of a path should be dependent on a natural number length</p>",
        "id": 206755085,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597267883
    },
    {
        "content": "<p>YEAH I've been thinking about that, I can't say I recall seeing anything that avoids infinitely long paths</p>",
        "id": 206755231,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1597267944
    },
    {
        "content": "<p>Uhh lists are finitely long, so these would be isomorphic</p>",
        "id": 206755266,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597267963
    },
    {
        "content": "<p>Ohh okay phew</p>",
        "id": 206755290,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1597267973
    },
    {
        "content": "<p>Misread then</p>",
        "id": 206755292,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1597267976
    },
    {
        "content": "<p>I thought you were saying the definition of a path should have the condition that the length is finite</p>",
        "id": 206755505,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1597268077
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"303889\">Alena Gusakov</span> <a href=\"#narrow/stream/252551-graph-theory/topic/maximal.20path/near/206755231\">said</a>:</p>\n<blockquote>\n<p>YEAH I've been thinking about that, I can't say I recall seeing anything that avoids infinitely long paths</p>\n</blockquote>\n<p>Speaking of infinitely long paths, one use of them is in Konig's lemma.  Should we consider infinitely long paths to be fundamentally different from finite paths?  It probably is nice enough having a map that gives finite truncations of an infinite path.</p>",
        "id": 206770376,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1597279479
    },
    {
        "content": "<p>If we define paths using maps from fin n, then it’s easier to generalize to N...</p>",
        "id": 206770586,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597279718
    },
    {
        "content": "<p>I wonder if it's worth not defining paths per se, but instead using graph homomorphisms (to be defined) from path graphs to a given graph.</p>",
        "id": 206770627,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1597279794
    },
    {
        "content": "<p>so you'd write <code>(n : nat) (p : P n \\embeds G)</code> as arguments, where <code>\\embeds</code> is some relevant arrow</p>",
        "id": 206770749,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1597279921
    },
    {
        "content": "<p>I’m tempted, but I’m not sure all the walky definitions are easy to describe that way</p>",
        "id": 206770827,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597280006
    },
    {
        "content": "<p>then there'd be the infinite path graph <code>Ray</code> along with embeddings <code>P n \\embeds Ray</code> for each <code>n</code>, and so you'd get these truncations as restrictions of <code>Ray \\embeds G</code></p>",
        "id": 206770833,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1597280021
    },
    {
        "content": "<p>It’s for sure better to define infinite paths that way</p>",
        "id": 206770904,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597280092
    },
    {
        "content": "<p>and a walk would be a non-embedding from <code>P n</code> to <code>G</code>.</p>\n<p>It seems like the complexity would be about the same as for the structures for walks given in the paths topic</p>",
        "id": 206770924,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1597280124
    },
    {
        "content": "<p>A loop is exactly a homomorphism from a cycle graph</p>",
        "id": 206770980,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597280165
    },
    {
        "content": "<p>We probably should move over to the paths topic</p>",
        "id": 206770993,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1597280194
    },
    {
        "content": "<p>Right</p>",
        "id": 206771485,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597280799
    },
    {
        "content": "<p>I'm still having trouble with finding Sup</p>",
        "id": 206773923,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1597284315
    },
    {
        "content": "<p>Bhavik helped me out with this</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">lemma</span> <span class=\"n\">finset_card_le_fintype_card</span> <span class=\"p\">{</span><span class=\"n\">α</span> <span class=\"p\">:</span> <span class=\"n\">Type</span><span class=\"o\">*</span><span class=\"p\">}</span> <span class=\"p\">[</span><span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"p\">]</span> <span class=\"p\">(</span><span class=\"n\">s</span> <span class=\"p\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"p\">)</span> <span class=\"p\">:</span> <span class=\"n\">s</span><span class=\"o\">.</span><span class=\"n\">card</span> <span class=\"err\">≤</span> <span class=\"n\">fintype</span><span class=\"o\">.</span><span class=\"n\">card</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"n\">finset</span><span class=\"o\">.</span><span class=\"n\">card_le_of_subset</span> <span class=\"p\">(</span><span class=\"n\">finset</span><span class=\"o\">.</span><span class=\"n\">subset_univ</span> <span class=\"n\">_</span><span class=\"p\">)</span>\n\n<span class=\"o\">/-</span> <span class=\"n\">length</span> <span class=\"n\">of</span> <span class=\"n\">path</span><span class=\"o\">.</span><span class=\"n\">is_tour</span> <span class=\"ow\">is</span> <span class=\"n\">less</span> <span class=\"n\">than</span> <span class=\"n\">the</span> <span class=\"n\">cardinality</span> <span class=\"n\">of</span> <span class=\"n\">V</span> <span class=\"o\">-/</span>\n<span class=\"n\">lemma</span> <span class=\"n\">tour_lt_card</span> <span class=\"p\">[</span><span class=\"n\">fintype</span> <span class=\"n\">V</span><span class=\"p\">]</span> <span class=\"p\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">V</span><span class=\"p\">]</span> <span class=\"p\">(</span><span class=\"n\">p</span> <span class=\"p\">:</span> <span class=\"n\">path</span> <span class=\"n\">G</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"n\">hp</span> <span class=\"p\">:</span> <span class=\"n\">p</span><span class=\"o\">.</span><span class=\"n\">is_tour</span><span class=\"p\">)</span> <span class=\"p\">:</span>\n  <span class=\"n\">p</span><span class=\"o\">.</span><span class=\"n\">length</span> <span class=\"o\">&lt;</span> <span class=\"n\">fintype</span><span class=\"o\">.</span><span class=\"n\">card</span> <span class=\"n\">V</span> <span class=\"o\">:=</span>\n<span class=\"n\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"p\">[</span><span class=\"n\">nat</span><span class=\"o\">.</span><span class=\"n\">lt_iff_add_one_le</span><span class=\"p\">,</span> <span class=\"err\">←</span> <span class=\"n\">vertices_length</span><span class=\"p\">,</span> <span class=\"err\">←</span> <span class=\"nb\">list</span><span class=\"o\">.</span><span class=\"n\">to_finset_card_of_nodup</span> <span class=\"n\">hp</span><span class=\"p\">],</span>\n  <span class=\"n\">apply</span> <span class=\"n\">finset_card_le_fintype_card</span><span class=\"p\">,</span>\n<span class=\"n\">end</span>\n</code></pre></div>",
        "id": 206773940,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1597284346
    },
    {
        "content": "<p>We have a new fintype lemma there too</p>",
        "id": 206774016,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1597284407
    },
    {
        "content": "<p>But with </p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">instance</span> <span class=\"p\">:</span> <span class=\"n\">has_Sup</span> <span class=\"p\">{</span><span class=\"n\">n</span> <span class=\"p\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">|</span> <span class=\"err\">∃</span> <span class=\"p\">(</span><span class=\"n\">p</span> <span class=\"p\">:</span> <span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">path</span><span class=\"p\">),</span> <span class=\"n\">p</span><span class=\"o\">.</span><span class=\"n\">is_tour</span> <span class=\"err\">∧</span> <span class=\"n\">p</span><span class=\"o\">.</span><span class=\"n\">length</span> <span class=\"o\">=</span> <span class=\"n\">n</span><span class=\"p\">}</span> <span class=\"o\">:=</span>\n<span class=\"n\">begin</span>\n  <span class=\"n\">sorry</span><span class=\"p\">,</span>\n<span class=\"n\">end</span>\n</code></pre></div>\n\n\n<p>I wasn't really able to figure out how to use either <code>nat.find</code> or <code>bdd_above</code></p>",
        "id": 206774094,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1597284488
    },
    {
        "content": "<p>I don't think you want to be using <code>has_Sup</code> to express this idea, I think that'd be awkward to use in practice</p>",
        "id": 206774113,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1597284517
    },
    {
        "content": "<p>What would you recommend using?</p>",
        "id": 206774156,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1597284588
    },
    {
        "content": "<p>one sec I'll type it out</p>",
        "id": 206774212,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1597284622
    },
    {
        "content": "<p><code>∃ (p : G.path), p.is_tour ∧ ∀ (q : G.path), q.is_tour → q.length ≤ p.length</code></p>",
        "id": 206774321,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1597284807
    },
    {
        "content": "<p>I think that's sort of what I have</p>",
        "id": 206774406,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1597284882
    },
    {
        "content": "<p>I have <code>python\ndef is_maximum : Prop := p.is_tour ∧ ∀ (q : path G), q.length ≤ p.length</code></p>",
        "id": 206774426,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1597284912
    },
    {
        "content": "<p>And the lemma I want to prove is the existence of such a path</p>",
        "id": 206774435,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1597284939
    },
    {
        "content": "<p>That definition isn't what  you want, since it doesn't restrict q to be a tour</p>",
        "id": 206774436,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1597284940
    },
    {
        "content": "<p>OH</p>",
        "id": 206774440,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1597284950
    },
    {
        "content": "<p>So nothing satisfies that predicate</p>",
        "id": 206774444,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1597284956
    },
    {
        "content": "<p>yeah okay I gotcha</p>",
        "id": 206774445,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1597284956
    },
    {
        "content": "<p>but  you can modify it to include that, and then the lemma you  want is just that such a thing exists</p>",
        "id": 206774493,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1597284973
    },
    {
        "content": "<p>At the moment, you  could just make a q going back and forth on two vertices (as long as there's at least one edge in the graph) so by  that definition there is never a maximum</p>",
        "id": 206774504,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1597285007
    },
    {
        "content": "<p>also that should probably be called maximal not maximum</p>",
        "id": 206774508,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1597285015
    },
    {
        "content": "<p>It's maximum, it's a global thing</p>",
        "id": 206774518,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1597285039
    },
    {
        "content": "<p>For all paths in G</p>",
        "id": 206774521,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1597285049
    },
    {
        "content": "<p>We had the back and forth over maximal/maximum earlier and decided on maximum cause it's easier</p>",
        "id": 206774526,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1597285065
    },
    {
        "content": "<p>maximum vs maximal isn't about being global though, it's about uniqueness</p>",
        "id": 206774573,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1597285088
    },
    {
        "content": "<p>Is it? Maximum = global and maximal = local is how it was defined for me</p>",
        "id": 206774589,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1597285113
    },
    {
        "content": "<p>Cause you can have a path that's a local maximum</p>",
        "id": 206774599,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1597285136
    },
    {
        "content": "<p>That's not how it's defined in <a href=\"https://en.wikipedia.org/wiki/Maximal_and_minimal_elements\">https://en.wikipedia.org/wiki/Maximal_and_minimal_elements</a> or <a href=\"https://www.math3ma.com/blog/maximal-not-maximum\">https://www.math3ma.com/blog/maximal-not-maximum</a></p>",
        "id": 206774641,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1597285167
    },
    {
        "content": "<p>In particular a graph can have multiple paths satisfying that definition, so none of them are \"the maximum\" but they all are maximal</p>",
        "id": 206774713,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1597285225
    },
    {
        "content": "<p><del>I think the blog has the same definitions as I do essentially</del> nope</p>",
        "id": 206774714,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1597285227
    },
    {
        "content": "<p>Yeah</p>",
        "id": 206774719,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1597285235
    },
    {
        "content": "<p>But we're not worried about uniqueness, we just need the existence of a path with maximum length</p>",
        "id": 206774725,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1597285251
    },
    {
        "content": "<p>maximum length is different to maximum path though</p>",
        "id": 206774727,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1597285261
    },
    {
        "content": "<p>Actually I guess it depends which order we're talking about</p>",
        "id": 206774744,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1597285286
    },
    {
        "content": "<p>I am referring to maximum length</p>",
        "id": 206774754,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1597285299
    },
    {
        "content": "<p>If we're talking about the partial order on paths by inclusion, then it's maximal</p>",
        "id": 206774759,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1597285309
    },
    {
        "content": "<p>Ah</p>",
        "id": 206774760,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1597285311
    },
    {
        "content": "<p>maybe call it is_maximum_length then</p>",
        "id": 206774764,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1597285317
    },
    {
        "content": "<p>Actually you know what, I do think I have the same definitions of maximal/maximum as the blog</p>",
        "id": 206774811,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1597285338
    },
    {
        "content": "<p>Like if you have a maximal path <code>p</code>, and it's a \"sub\"-path of another path <code>q</code>, then <code>q = p</code></p>",
        "id": 206774824,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1597285380
    },
    {
        "content": "<p>Right, but there's no guarantee that a maximum path exists under inclusion</p>",
        "id": 206774841,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1597285414
    },
    {
        "content": "<p>Even on a finite graph</p>",
        "id": 206774842,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1597285416
    },
    {
        "content": "<p>Sure but this isn't an inclusion argument, that's what I was trying to use before</p>",
        "id": 206774850,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1597285434
    },
    {
        "content": "<p>But under length, a maximum path does exist</p>",
        "id": 206774851,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1597285434
    },
    {
        "content": "<p>Like, you can have multiple maximum paths right?</p>",
        "id": 206774901,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1597285461
    },
    {
        "content": "<p>Right so I'm saying change the name to <code>is_maximum_length</code></p>",
        "id": 206774903,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1597285461
    },
    {
        "content": "<p>Because then it matches the def you had</p>",
        "id": 206774911,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1597285486
    },
    {
        "content": "<p>Yeah, gotcha</p>",
        "id": 206774927,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1597285509
    },
    {
        "content": "<p>Yeah okay I see what you were saying</p>",
        "id": 206774936,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1597285523
    },
    {
        "content": "<p>I was stepping back and forth between the idea of chains of paths and the lengths of paths</p>",
        "id": 206774946,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1597285538
    },
    {
        "content": "<p>Without realizing that they're not at all interchangeable lmao</p>",
        "id": 206775016,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1597285632
    },
    {
        "content": "<p>What I was suggesting to use Sup for was not to add any new instances of <code>has_Sup</code>, but to show that there exists a tour of length <code>Sup {n : ℕ | ∃ (p : G.path), p.is_tour ∧ p.length = n}</code></p>",
        "id": 206775561,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597286378
    },
    {
        "content": "<p>This should equal <code>nat.find (∃ n, \\ (p : G.path), ∀ (p : path G), p.length ≤ n)</code></p>",
        "id": 206775625,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597286428
    },
    {
        "content": "<p>so you could use that too</p>",
        "id": 206775644,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597286484
    },
    {
        "content": "<p>Let's say you use <code>nat.find</code>. Then what you want to show is that the output, a natural number, is actually the maximum path length.</p>",
        "id": 206775883,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597286841
    },
    {
        "content": "<p>To do that, you need to show that there is no longer path, and that should come from  <code>nat.​find_spec</code>, which basically says that your result is a witness to the <code>∃</code>-statement.</p>",
        "id": 206775930,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597286890
    },
    {
        "content": "<p>Then you also need to show that there is a path of that length, which you can get from <code>nat.​find_min</code>, which will tell you that <code>∀ (p : path G), p.length ≤ n - 1)</code> is false</p>",
        "id": 206775953,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597286970
    }
]
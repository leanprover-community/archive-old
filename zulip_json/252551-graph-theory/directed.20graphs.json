[
    {
        "content": "<p>This could potentially be a way (among others) to define simple directed graphs:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[ext]</span>\n<span class=\"kd\">structure</span> <span class=\"n\">simple_digraph</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">adj</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">loopless</span> <span class=\"o\">:</span> <span class=\"n\">irreflexive</span> <span class=\"n\">adj</span> <span class=\"bp\">.</span> <span class=\"n\">obviously</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[ext]</span>\n<span class=\"kd\">structure</span> <span class=\"n\">simple_graph</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">simple_digraph</span> <span class=\"n\">V</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">sym</span> <span class=\"o\">:</span> <span class=\"n\">symmetric</span> <span class=\"n\">adj</span> <span class=\"bp\">.</span> <span class=\"n\">obviously</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>You would then have to define a number of things having to do with edges of directed graphs (represented as pairs of vertices), and relate them to edges of simple graphs (represented as unordered pairs of vertices).  There is some precedent to call an ordered edge a \"dart,\" but it's probably fine (if potentially a name collision) to call them \"edges.\" (Maybe \"dedge\" for \"directed edge\" is an ok compromise?)</p>\n<p>There would be a 2-1 map from directed edges to edges.  All of this can be then used to simplify the <code>degree_sum</code> module.</p>",
        "id": 245350179,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1625767899
    },
    {
        "content": "<p>The digraph here allows a two vertex cycle. Is that desired?</p>",
        "id": 245355342,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1625770312
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"308899\">Yakov Pechersky</span> <a href=\"#narrow/stream/252551-graph-theory/topic/directed.20graphs/near/245355342\">said</a>:</p>\n<blockquote>\n<p>The digraph here allows a two vertex cycle. Is that desired?</p>\n</blockquote>\n<p>I'm not sure!</p>",
        "id": 245359186,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1625772178
    },
    {
        "content": "<p>Though I <em>believe</em> this follows the usual definition of a simple directed graph.</p>",
        "id": 245359672,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1625772417
    },
    {
        "content": "<p>Ah, I'm used to thinking about oriented graphs. Those are ones that have no such cycles.</p>",
        "id": 245360994,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1625773066
    },
    {
        "content": "<p>It seems like it would be nice having a predicate for whether a simple digraph is an oriented graph.  If there's also a function from digraphs to simple graphs by symmetrizing the relation, then there could be a recursion principle where you define/prove something about a simple graph given an oriented representative.</p>",
        "id": 245362252,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1625773680
    },
    {
        "content": "<p>Something like?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"kd\">@[ext]</span>\n<span class=\"kd\">structure</span> <span class=\"n\">simple_digraph</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">adj</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">loopless</span> <span class=\"o\">:</span> <span class=\"n\">irreflexive</span> <span class=\"n\">adj</span> <span class=\"bp\">.</span> <span class=\"n\">obviously</span><span class=\"o\">)</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">oriented</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_digraph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">uncycled</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">G.adj</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"bp\">→</span> <span class=\"bp\">¬</span> <span class=\"n\">G.adj</span> <span class=\"n\">w</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[ext]</span>\n<span class=\"kd\">structure</span> <span class=\"n\">simple_graph</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">simple_digraph</span> <span class=\"n\">V</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">sym</span> <span class=\"o\">:</span> <span class=\"n\">symmetric</span> <span class=\"n\">adj</span> <span class=\"bp\">.</span> <span class=\"n\">obviously</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">undi</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_digraph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">adj</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"n\">G.adj</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"bp\">∨</span> <span class=\"n\">G.adj</span> <span class=\"n\">w</span> <span class=\"n\">v</span><span class=\"o\">,</span>\n  <span class=\"n\">loopless</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">or.cases_on</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">G.loopless</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">G.loopless</span> <span class=\"n\">x</span><span class=\"o\">),</span>\n  <span class=\"n\">sym</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">or.cases_on</span> <span class=\"n\">h</span> <span class=\"n\">or.inr</span> <span class=\"n\">or.inl</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">orienting_induction</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">IH</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">g'</span> <span class=\"o\">:</span> <span class=\"n\">simple_digraph</span> <span class=\"n\">V</span><span class=\"o\">),</span> <span class=\"n\">C</span> <span class=\"o\">(</span><span class=\"n\">undi</span> <span class=\"n\">g'</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"n\">g</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 245372092,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1625778317
    },
    {
        "content": "<p>though you should be able to restrict to these oriented diagraphs for the induction hypothesis.  (Changed the <code>class</code> to a <code>def</code> to make it easier to state.)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"kd\">@[ext]</span>\n<span class=\"kd\">structure</span> <span class=\"n\">simple_digraph</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">adj</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">loopless</span> <span class=\"o\">:</span> <span class=\"n\">irreflexive</span> <span class=\"n\">adj</span> <span class=\"bp\">.</span> <span class=\"n\">obviously</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">simple_digraph.ori</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_digraph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">),</span> <span class=\"n\">G.adj</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"bp\">→</span> <span class=\"bp\">¬</span> <span class=\"n\">G.adj</span> <span class=\"n\">w</span> <span class=\"n\">v</span>\n<span class=\"c1\">-- this could also be stated as `antisymm G.adj` since `irreflexive G.adj`</span>\n\n<span class=\"kd\">@[ext]</span>\n<span class=\"kd\">structure</span> <span class=\"n\">simple_graph</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">simple_digraph</span> <span class=\"n\">V</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">sym</span> <span class=\"o\">:</span> <span class=\"n\">symmetric</span> <span class=\"n\">adj</span> <span class=\"bp\">.</span> <span class=\"n\">obviously</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">simple_digraph.to_simple_graph</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_digraph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">adj</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"n\">G.adj</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"bp\">∨</span> <span class=\"n\">G.adj</span> <span class=\"n\">w</span> <span class=\"n\">v</span><span class=\"o\">,</span>\n  <span class=\"n\">loopless</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">or.cases_on</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">G.loopless</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">G.loopless</span> <span class=\"n\">x</span><span class=\"o\">),</span>\n  <span class=\"n\">sym</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">or.cases_on</span> <span class=\"n\">h</span> <span class=\"n\">or.inr</span> <span class=\"n\">or.inl</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">simple_graph.ori_ind</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">IH</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">g'</span> <span class=\"o\">:</span> <span class=\"n\">simple_digraph</span> <span class=\"n\">V</span><span class=\"o\">),</span> <span class=\"n\">g'.ori</span> <span class=\"bp\">→</span> <span class=\"n\">C</span> <span class=\"n\">g'.to_simple_graph</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">C</span> <span class=\"n\">g</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 245373317,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1625778844
    },
    {
        "content": "<p>Another option is to have <code>simple_graph</code> be the quotient of <code>simple_digraph</code>.</p>",
        "id": 245379939,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1625783319
    },
    {
        "content": "<p>Because the induction you stated right now will only work if there is an according statement that for all <code>g : simple_graph</code> there is a <code>dg : simple_digraph</code> such that <code>dg.to_simple_graph = g</code>.</p>",
        "id": 245380144,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1625783480
    },
    {
        "content": "<p>Yeah, <code>simple_graph</code> is indeed a quotient of <code>simple_digraph</code> (and in fact a quotient of the subtype of <code>simple_digraph</code> satisfying <code>ori</code>), and you can say that <code>ori_ind</code> is part of the proof of this.</p>\n<p>It seems like it's better to explicitly construct quotient types if you can rather than using <code>quot</code>, and then providing the recursor, unless <code>quot</code> somehow makes everything more elegant.  I guess a principle is that something doesn't have to be represented as something to be something -- you just need the right universal properties.  Simple graphs are very concrete, so the question is whether the benefits of having the <code>quot</code> API would outweigh the loss of concreteness -- I suspect it wouldn't provide that much, but it's hard to say without experiments.</p>\n<p>(I'd thought about making multigraphs be quotients of directed multigraphs before, but I decided not to pursue it because at least initially it seemed difficult to work with.)</p>",
        "id": 245384880,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1625787264
    },
    {
        "content": "<p>This would be nicer with more library support, and it can be golfed, but proving <code>ori_ind</code> wasn't so bad:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.sym2</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"kd\">@[ext]</span>\n<span class=\"kd\">structure</span> <span class=\"n\">simple_digraph</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">adj</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">loopless</span> <span class=\"o\">:</span> <span class=\"n\">irreflexive</span> <span class=\"n\">adj</span> <span class=\"bp\">.</span> <span class=\"n\">obviously</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">simple_digraph.is_ori</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_digraph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">),</span> <span class=\"n\">G.adj</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"bp\">→</span> <span class=\"bp\">¬</span> <span class=\"n\">G.adj</span> <span class=\"n\">w</span> <span class=\"n\">v</span>\n<span class=\"c1\">-- this could also be stated as `antisymm G.adj` since `irreflexive G.adj`</span>\n\n<span class=\"kd\">@[ext]</span>\n<span class=\"kd\">structure</span> <span class=\"n\">simple_graph</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">simple_digraph</span> <span class=\"n\">V</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">sym</span> <span class=\"o\">:</span> <span class=\"n\">symmetric</span> <span class=\"n\">adj</span> <span class=\"bp\">.</span> <span class=\"n\">obviously</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">simple_digraph.to_simple_graph</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_digraph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">adj</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"n\">G.adj</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"bp\">∨</span> <span class=\"n\">G.adj</span> <span class=\"n\">w</span> <span class=\"n\">v</span><span class=\"o\">,</span>\n  <span class=\"n\">loopless</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">or.cases_on</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">G.loopless</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">G.loopless</span> <span class=\"n\">x</span><span class=\"o\">),</span>\n  <span class=\"n\">sym</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">or.cases_on</span> <span class=\"n\">h</span> <span class=\"n\">or.inr</span> <span class=\"n\">or.inl</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">simple_graph.exists_ori</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">G'</span> <span class=\"o\">:</span> <span class=\"n\">simple_digraph</span> <span class=\"n\">V</span><span class=\"o\">),</span> <span class=\"n\">G'.is_ori</span> <span class=\"bp\">∧</span> <span class=\"n\">G</span> <span class=\"bp\">=</span> <span class=\"n\">G'.to_simple_graph</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">sym2</span> <span class=\"n\">V</span><span class=\"o\">),</span> <span class=\"bp\">∃</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">v</span> <span class=\"bp\">∈</span> <span class=\"n\">e</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">intro</span> <span class=\"n\">e</span><span class=\"o\">,</span>\n    <span class=\"n\">refine</span> <span class=\"n\">quotient.ind</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">e</span><span class=\"o\">,</span>\n    <span class=\"n\">cases</span> <span class=\"n\">e</span> <span class=\"k\">with</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">sym2.mk_has_mem</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">⟩,</span> <span class=\"o\">},</span>\n  <span class=\"n\">choose</span> <span class=\"n\">f</span> <span class=\"n\">hf</span> <span class=\"n\">using</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">use</span> <span class=\"o\">{</span><span class=\"n\">adj</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"n\">G.adj</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"bp\">∧</span> <span class=\"n\">f</span> <span class=\"bp\">⟦</span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">w</span><span class=\"o\">)</span><span class=\"bp\">⟧</span> <span class=\"bp\">=</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">loopless</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">G.loopless</span> <span class=\"n\">_</span> <span class=\"n\">h.1</span><span class=\"o\">},</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintros</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">⟨</span><span class=\"n\">ha</span><span class=\"o\">,</span> <span class=\"n\">hv</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">hb</span><span class=\"o\">,</span> <span class=\"n\">hw</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">sym2.eq_swap</span> <span class=\"n\">at</span> <span class=\"n\">hw</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">hv</span> <span class=\"n\">at</span> <span class=\"n\">hw</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">hw</span> <span class=\"n\">at</span> <span class=\"n\">ha</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">G.loopless</span> <span class=\"n\">_</span> <span class=\"n\">ha</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">ext</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">,</span>\n    <span class=\"n\">dsimp</span> <span class=\"o\">[</span><span class=\"n\">simple_digraph.to_simple_graph</span><span class=\"o\">],</span>\n    <span class=\"n\">split</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n      <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">G.sym</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">true_and</span><span class=\"o\">],</span>\n      <span class=\"n\">rw</span> <span class=\"bp\">@</span><span class=\"n\">sym2.eq_swap</span> <span class=\"n\">_</span> <span class=\"n\">w</span><span class=\"o\">,</span>\n      <span class=\"n\">specialize</span> <span class=\"n\">hf</span> <span class=\"bp\">⟦</span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">w</span><span class=\"o\">)</span><span class=\"bp\">⟧</span><span class=\"o\">,</span>\n      <span class=\"n\">rwa</span> <span class=\"n\">sym2.mem_iff</span> <span class=\"n\">at</span> <span class=\"n\">hf</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"bp\">|</span><span class=\"n\">h</span><span class=\"o\">),</span>\n      <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">h.1</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n      <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">G.sym</span> <span class=\"n\">h.1</span><span class=\"o\">,</span> <span class=\"o\">}</span> <span class=\"o\">}</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">simple_graph.ori_ind</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">ih</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">G'</span> <span class=\"o\">:</span> <span class=\"n\">simple_digraph</span> <span class=\"n\">V</span><span class=\"o\">),</span> <span class=\"n\">G'.is_ori</span> <span class=\"bp\">→</span> <span class=\"n\">C</span> <span class=\"n\">G'.to_simple_graph</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"n\">C</span> <span class=\"n\">G</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intro</span> <span class=\"n\">G</span><span class=\"o\">,</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">G'</span><span class=\"o\">,</span> <span class=\"n\">hG'</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">G.exists_ori</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">ih</span> <span class=\"n\">G'</span> <span class=\"n\">hG'</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 245384911,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1625787300
    },
    {
        "content": "<p>This approach won't work for getting a computable <code>simple_graph.ori_rec</code>. If <code>simple_graph</code> were a <code>quot</code> then you should be able to make it computable, but I don't think this is high priority for mathlib.</p>",
        "id": 245385157,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1625787539
    },
    {
        "content": "<p>I made cycles a quotient of lists, using is_rotated as the relation. Most proofs and definitions ended up being two-liners with quotient.induction_on', and defs were either <a href=\"http://quotient.map\">quotient.map</a>' or quotient.hrec_on'. It's the ability to do dependent recursion that I really like from quotients. In this case, we'd get the lemmas \"by definition\" with exists_rep and the automatic recursors. But of course one has to make the boilerplate coe simp lemmas. Either way works!</p>",
        "id": 245386498,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1625788876
    },
    {
        "content": "<p>Cycles as quotients of lists makes a whole lot of sense to me, since there's no normal form for a cycle unless you have something like a total ordering on elements</p>",
        "id": 245386759,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1625789127
    },
    {
        "content": "<p>Oh, I guess the alternative is a <code>perm</code> with a single orbit</p>",
        "id": 245386775,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1625789145
    },
    {
        "content": "<p>A lot of recent work was done to show that that alternative holds!</p>",
        "id": 245387063,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1625789487
    },
    {
        "content": "<p>And a direct correspondence is not exactly correct, because an empty cycle, and a cycle of a single element both interpret as the trivial perm.</p>",
        "id": 245387118,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1625789530
    },
    {
        "content": "<p>And one could have a cycle with duplicates in it too.</p>",
        "id": 245387160,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1625789635
    },
    {
        "content": "<p>Oh, right, forgot about all that!</p>",
        "id": 245387362,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1625789846
    },
    {
        "content": "<p>I tried writing the <code>ori_rec</code>, but suspiciously (due to the use of the axiom of choice) it doesn't need the <code>h</code> hypothesis:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">noncomputable</span>\n<span class=\"kd\">def</span> <span class=\"n\">simple_graph.ori_rec</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">G'</span> <span class=\"o\">:</span> <span class=\"n\">simple_digraph</span> <span class=\"n\">V</span><span class=\"o\">},</span> <span class=\"n\">G'.is_ori</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"n\">G'.to_simple_graph</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">G'</span> <span class=\"n\">G''</span> <span class=\"o\">:</span> <span class=\"n\">simple_digraph</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hG'</span> <span class=\"o\">:</span> <span class=\"n\">G'.is_ori</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hG''</span> <span class=\"o\">:</span> <span class=\"n\">G''.is_ori</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">he</span> <span class=\"o\">:</span> <span class=\"n\">G'.to_simple_graph</span> <span class=\"bp\">=</span> <span class=\"n\">G''.to_simple_graph</span><span class=\"o\">),</span>\n    <span class=\"bp\">@</span><span class=\"n\">eq.rec</span> <span class=\"n\">_</span> <span class=\"n\">G'.to_simple_graph</span> <span class=\"n\">β</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">hG'</span><span class=\"o\">)</span> <span class=\"n\">G''.to_simple_graph</span> <span class=\"n\">he</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">hG''</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">Π</span> <span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"n\">β</span> <span class=\"n\">G</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intro</span> <span class=\"n\">G</span><span class=\"o\">,</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">G'</span><span class=\"o\">,</span> <span class=\"n\">hG'</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">classical.indefinite_description</span> <span class=\"n\">_</span> <span class=\"n\">G.exists_ori</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">f</span> <span class=\"n\">hG'</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>Though to reduce <code>ori_rec</code> you do use <code>h</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">}</span>\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">G'</span> <span class=\"o\">:</span> <span class=\"n\">simple_digraph</span> <span class=\"n\">V</span><span class=\"o\">},</span> <span class=\"n\">G'.is_ori</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"n\">G'.to_simple_graph</span><span class=\"o\">)</span>\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">G'</span> <span class=\"n\">G''</span> <span class=\"o\">:</span> <span class=\"n\">simple_digraph</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hG'</span> <span class=\"o\">:</span> <span class=\"n\">G'.is_ori</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hG''</span> <span class=\"o\">:</span> <span class=\"n\">G''.is_ori</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">he</span> <span class=\"o\">:</span> <span class=\"n\">G'.to_simple_graph</span> <span class=\"bp\">=</span> <span class=\"n\">G''.to_simple_graph</span><span class=\"o\">),</span>\n             <span class=\"bp\">@</span><span class=\"n\">eq.rec</span> <span class=\"n\">_</span> <span class=\"n\">G'.to_simple_graph</span> <span class=\"n\">β</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">hG'</span><span class=\"o\">)</span> <span class=\"n\">G''.to_simple_graph</span> <span class=\"n\">he</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">hG''</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">simple_graph.ori_rec.prop</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_digraph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hG</span> <span class=\"o\">:</span> <span class=\"n\">G.is_ori</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">G.to_simple_graph.ori_rec</span> <span class=\"bp\">@</span><span class=\"n\">f</span> <span class=\"bp\">@</span><span class=\"n\">h</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">hG</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">simple_graph.ori_rec</span><span class=\"o\">,</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">G'</span><span class=\"o\">,</span> <span class=\"n\">hG'</span><span class=\"o\">,</span> <span class=\"n\">he</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">classical.indefinite_description</span> <span class=\"n\">_</span> <span class=\"n\">G.to_simple_graph.exists_ori</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"bp\">←</span><span class=\"n\">h</span> <span class=\"n\">hG'</span> <span class=\"n\">hG</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 245388274,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1625790932
    },
    {
        "content": "<p>In any case, cycles can now help us define cyclic walks on graphs, if we redefine walks as chains on lists of vertices :-). That was one of the motivations for them.</p>",
        "id": 245388367,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1625791045
    },
    {
        "content": "<p>I'm wondering: what if <code>cycle</code> is generalized to accept any type that has a <code>rotate</code> function with certain properties?  The type <code>Σ (v : V), G.walk v v</code> would certainly support this.  It'd support a <code>reverse</code>, too.  For it to be useful, there should probably be a map to <code>list V</code> such that <code>rotate</code> and <code>reverse</code> commute with this map, so in this case there would be this walk cycle, but you could also view it as a cycle of vertices.</p>",
        "id": 245388775,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1625791548
    },
    {
        "content": "<p>This would be more useful for cycles in multigraphs.  Cycles in simple graphs are the same as their vertex cycles.  Though for multigraphs, oriented cycles are determined by a cycle of <code>(v, e)</code> pairs with <code>v</code> a vertex of edge <code>e</code>.</p>",
        "id": 245388860,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1625791661
    }
]
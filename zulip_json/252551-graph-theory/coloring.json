[
    {
        "content": "<p>this lemma can be very helpful to prove lower bounds for the chromatic number</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">chromatic_number_lower_bound</span> <span class=\"o\">(</span><span class=\"n\">G'</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">≤</span> <span class=\"n\">G'</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">G.chromatic_number</span> <span class=\"bp\">≤</span> <span class=\"n\">G'.chromatic_number</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"gr\">sorry</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 260715701,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636404003
    },
    {
        "content": "<p>That would follow from the fact that every coloring of <code>G'</code> gives a coloring of <code>G</code> by composing it with the (unimplemented?) induced graph homomorphism <code>G -&gt;g G'</code>.</p>",
        "id": 260717403,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636404813
    },
    {
        "content": "<p>I'm trying to prove this one:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">chromatic_number_le</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">G.proper_coloring</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">G.chromatic_number</span> <span class=\"bp\">≤</span> <span class=\"n\">fintype.card</span> <span class=\"n\">α</span>\n</code></pre></div>\n<p>But I couldn't find a simple example of how to deal with lattice infimums</p>",
        "id": 260718342,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636405287
    },
    {
        "content": "<p>When I unfold the definition of <code>chromatic_number</code> I get a goal to which I don't know how to move towards</p>",
        "id": 260718443,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636405325
    },
    {
        "content": "<p>I think you can <code>apply</code> <a href=\"https://leanprover-community.github.io/mathlib_docs/find/Inf_le\">docs#Inf_le</a></p>",
        "id": 260721141,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636406747
    },
    {
        "content": "<p>It says</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">invalid</span> <span class=\"n\">apply</span> <span class=\"n\">tactic</span><span class=\"o\">,</span> <span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">unify</span>\n  <span class=\"n\">Inf</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">|</span> <span class=\"n\">G.colorable</span> <span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"bp\">≤</span> <span class=\"n\">fintype.card</span> <span class=\"n\">α</span>\n<span class=\"k\">with</span>\n  <span class=\"n\">Inf</span> <span class=\"bp\">?</span><span class=\"n\">m_3</span> <span class=\"bp\">≤</span> <span class=\"bp\">?</span><span class=\"n\">m_4</span>\n<span class=\"n\">state</span><span class=\"o\">:</span>\n<span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">,</span>\n<span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">,</span>\n<span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">,</span>\n<span class=\"n\">_inst_1</span> <span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">,</span>\n<span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">G.proper_coloring</span> <span class=\"n\">α</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">Inf</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">|</span> <span class=\"n\">G.colorable</span> <span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"bp\">≤</span> <span class=\"n\">fintype.card</span> <span class=\"n\">α</span>\n</code></pre></div>",
        "id": 260722694,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636407596
    },
    {
        "content": "<p>Yup because it's <a href=\"https://leanprover-community.github.io/mathlib_docs/find/cInf_le\">docs#cInf_le</a> that you need here</p>",
        "id": 260724350,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1636408527
    },
    {
        "content": "<p>Baby step progress: <a href=\"https://github.com/leanprover-community/mathlib/blob/3998057d75c822c0e64824e3c446d923c3eb7426/src/combinatorics/simple_graph/coloring.lean\">https://github.com/leanprover-community/mathlib/blob/3998057d75c822c0e64824e3c446d923c3eb7426/src/combinatorics/simple_graph/coloring.lean</a></p>",
        "id": 260730245,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636411760
    },
    {
        "content": "<p>There seems to be an obvious step here:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">G.colorable</span> <span class=\"o\">(</span><span class=\"n\">fintype.card</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"bp\">⊢</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">|</span> <span class=\"n\">G.colorable</span> <span class=\"n\">n</span><span class=\"o\">}</span><span class=\"bp\">.</span><span class=\"n\">nonempty</span>\n</code></pre></div>",
        "id": 260748611,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636426944
    },
    {
        "content": "<p><code>{card α}</code> is not empty</p>",
        "id": 260748643,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636427027
    },
    {
        "content": "<p>Got it.</p>\n<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> some progress on the coloring as homomorphism branch: <a href=\"https://github.com/leanprover-community/mathlib/blob/dfacc1723b76a07129dc02ce34e5fbfc9076239e/src/combinatorics/simple_graph/coloring.lean\">https://github.com/leanprover-community/mathlib/blob/dfacc1723b76a07129dc02ce34e5fbfc9076239e/src/combinatorics/simple_graph/coloring.lean</a></p>",
        "id": 260749678,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636428424
    },
    {
        "content": "<p>I'm trying to produce a colored graph given the graph and a proper coloring for it (represented as a homomorphism)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n\n<span class=\"kd\">abbreviation</span> <span class=\"n\">proper_coloring</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">G</span> <span class=\"bp\">→</span><span class=\"n\">g</span> <span class=\"n\">complete_graph</span> <span class=\"n\">α</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">G</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">G.proper_coloring</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">proper_coloring.applied</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">simple_graph.from_rel</span>\n  <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">c₁</span> <span class=\"n\">c₂</span><span class=\"o\">,</span> <span class=\"n\">G.adj</span> <span class=\"bp\">...</span> <span class=\"bp\">...</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I'm not being able to express the relation that will form the same structure from <code>G</code> but with colored vertices (of type <code>α</code>). How to recover the original structure?</p>",
        "id": 260883369,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636503892
    },
    {
        "content": "<p>Oh, wait. Nevermind. The vertices can't be of type <code>α</code></p>",
        "id": 260884253,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636504507
    },
    {
        "content": "<p>Got this one</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">zero_le_chromatic_number</span> <span class=\"o\">[</span><span class=\"n\">nonempty</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">G.proper_coloring</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">G.chromatic_number</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">nat.lt_iff_add_one_le</span><span class=\"o\">,</span> <span class=\"n\">chromatic_number</span><span class=\"o\">,</span> <span class=\"n\">zero_add</span><span class=\"o\">],</span>\n  <span class=\"n\">apply</span> <span class=\"n\">le_cInf</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">use</span> <span class=\"n\">fintype.card</span> <span class=\"n\">α</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">exists_fin_coloring_then_colorable</span> <span class=\"n\">C</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">n</span> <span class=\"n\">hn</span><span class=\"o\">,</span>\n    <span class=\"n\">by_contra</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hn</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">colorable</span> <span class=\"n\">at</span> <span class=\"n\">hn</span><span class=\"o\">,</span>\n    <span class=\"n\">cases</span> <span class=\"n\">hn</span> <span class=\"k\">with</span> <span class=\"n\">α'</span> <span class=\"n\">hn</span><span class=\"o\">,</span>\n    <span class=\"n\">cases</span> <span class=\"n\">hn</span> <span class=\"k\">with</span> <span class=\"n\">hα'</span> <span class=\"n\">hn</span><span class=\"o\">,</span>\n    <span class=\"n\">cases</span> <span class=\"n\">hn</span> <span class=\"k\">with</span> <span class=\"n\">C'</span> <span class=\"n\">hf</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">hf</span><span class=\"o\">,</span>\n    <span class=\"k\">let</span> <span class=\"n\">v</span> <span class=\"o\">:=</span> <span class=\"n\">classical.arbitrary</span> <span class=\"n\">V</span><span class=\"o\">,</span> <span class=\"c1\">-- coloring this vertex requires at least 1 color</span>\n    <span class=\"k\">have</span> <span class=\"n\">c</span> <span class=\"o\">:=</span> <span class=\"n\">C'</span> <span class=\"n\">v</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"n\">hn</span> <span class=\"o\">:</span> <span class=\"n\">nonempty</span> <span class=\"n\">α'</span><span class=\"o\">,</span> <span class=\"n\">use</span> <span class=\"n\">c</span><span class=\"o\">,</span>\n    <span class=\"n\">tactic.unfreeze_local_instances</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">fintype.card_pos_iff</span> <span class=\"n\">at</span> <span class=\"n\">hn</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">hf</span> <span class=\"n\">at</span> <span class=\"n\">hn</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">nat.lt_asymm</span> <span class=\"n\">hn</span> <span class=\"n\">hn</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 260897284,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636511050
    },
    {
        "content": "<p>In what cases, meaning under which type class constraints etc, will <code>G.chromatic_number = 0</code>? You can like use that together with <code>nat.zero_le</code> to prove this easier.</p>",
        "id": 260942563,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1636516089
    },
    {
        "content": "<p>According to the definition Kyle wrote:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- If `G` isn't colorable with finitely many colors, this will be 0. -/</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">chromatic_number</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Inf</span> <span class=\"o\">{</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">|</span> <span class=\"n\">G.colorable</span> <span class=\"n\">n</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>But I guess if the graph has no vertices too</p>",
        "id": 260984172,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636548679
    },
    {
        "content": "<p>Actually it's weird to talk about coloring of empty graphs since we're using homomorphisms and I'm not sure we can define functions on empty domains</p>",
        "id": 260984345,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636548779
    },
    {
        "content": "<p>What do you mean by inability to define functions on empty domains?</p>",
        "id": 260984401,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1636548825
    },
    {
        "content": "<p>This is the proposed definition of proper coloring:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">abbreviation</span> <span class=\"n\">proper_coloring</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">G</span> <span class=\"bp\">→</span><span class=\"n\">g</span> <span class=\"n\">complete_graph</span> <span class=\"n\">α</span>\n</code></pre></div>\n<p>What happens if <code>G</code> has no vertices?</p>",
        "id": 260984529,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636548884
    },
    {
        "content": "<p>def f : fin 0 -&gt; real := fun x, fin.elim0 x</p>",
        "id": 260984763,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1636549043
    },
    {
        "content": "<p>there is a unique function <code>α → β</code> where α is empty, which is the elimination principle</p>",
        "id": 260984775,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1636549055
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">logic.is_empty</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">asda</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">is_empty</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"o\">:=</span> <span class=\"n\">h.elim</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">is_empty</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">asda</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intro</span><span class=\"o\">,</span> <span class=\"n\">funext</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">h.elim</span> <span class=\"n\">x</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 260984887,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1636549140
    },
    {
        "content": "<p>I see</p>",
        "id": 260984923,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636549168
    },
    {
        "content": "<p>So how would I state the condition for the chromatic number to be zero?<br>\n<code>G.chromatic_number = 0 ↔ empty V \\or ...</code></p>",
        "id": 260985394,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636549394
    },
    {
        "content": "<p>I mean, assuming <code>fintype</code> it's just <code>empty V</code>, and I can't think of a good condition on infinite graphs to have a finite colouring</p>",
        "id": 260985455,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1636549440
    },
    {
        "content": "<p>(off the top of my head)</p>",
        "id": 260985506,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1636549449
    },
    {
        "content": "<p>I wouldn't state it as an iff initially. Just one (or several) lemmas with some TC assumption, that says that <code>G.chromatic_number = 0</code>.</p>",
        "id": 260985549,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1636549477
    },
    {
        "content": "<p>Another helpful API lemma would be that <code>[subsingleton V]</code> should imply <code>chromatic_number &lt;= 1</code></p>",
        "id": 260985675,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1636549539
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"308899\">@Yakov Pechersky</span> how can I make use of <code>subsingleton V</code> to prove that <code>G</code> is colorable with at most 1 color?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">V</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span>\n<span class=\"n\">G</span><span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span>\n<span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span>\n<span class=\"n\">_inst_1</span><span class=\"o\">:</span> <span class=\"n\">subsingleton</span> <span class=\"n\">V</span>\n<span class=\"n\">C</span><span class=\"o\">:</span> <span class=\"n\">G.proper_coloring</span> <span class=\"n\">α</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">G.colorable</span> <span class=\"mi\">1</span>\n</code></pre></div>",
        "id": 260996425,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636554405
    },
    {
        "content": "<p>easy way is to case on <code>is_empty α</code> or <code>inhabited α</code></p>",
        "id": 260997516,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1636554783
    },
    {
        "content": "<p>Do you guys think it makes sense to define a graph with an applied coloring? I thought of a <code>simple_graph</code> whose vertices are 2-tuples of <code>V × α</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">proper_coloring.applied</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"bp\">×</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">simple_graph.from_rel</span>\n  <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">p₁</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">×</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p₂</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">×</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">p₁.2</span> <span class=\"bp\">=</span> <span class=\"n\">C</span> <span class=\"n\">p₁.1</span> <span class=\"bp\">∧</span> <span class=\"n\">p₂.2</span> <span class=\"bp\">=</span> <span class=\"n\">C</span> <span class=\"n\">p₂.1</span> <span class=\"bp\">∧</span> <span class=\"n\">G.adj</span> <span class=\"n\">p₁.1</span> <span class=\"n\">p₂.1</span><span class=\"o\">)</span>\n</code></pre></div>\n<p><code>C v</code> is the color of <code>v</code></p>",
        "id": 261013980,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636561379
    },
    {
        "content": "<p>This looks a bit like something the homomorphism API would provide <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>",
        "id": 261015349,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636561912
    },
    {
        "content": "<p>Alright, I think I got some nice progress this time.<br>\nPlease let me know what you think: <a href=\"https://github.com/leanprover-community/mathlib/blob/graph-coloring-homomorphism/src/combinatorics/simple_graph/coloring.lean\">https://github.com/leanprover-community/mathlib/blob/graph-coloring-homomorphism/src/combinatorics/simple_graph/coloring.lean</a></p>\n<p>Help is appreciated!</p>",
        "id": 261061093,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636581632
    },
    {
        "content": "<p>(Btw, I hadn't mentioned one motivation for homomorphisms, which is for <a href=\"https://en.wikipedia.org/wiki/Fractional_coloring\">fractional colorings</a>.  I guess they can be represented by graph homomorphisms to Kneser graphs, complete graphs being a special case, so with homomorphisms we easily get a fractional coloring from a coloring. Just leaving this comment here in case someone searches Zulip for \"fractional coloring\".)</p>",
        "id": 261062587,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636582338
    },
    {
        "content": "<p>For</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">coloring.valid</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">G.adj</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"n\">v</span> <span class=\"bp\">≠</span> <span class=\"n\">C</span> <span class=\"n\">w</span> <span class=\"o\">:=</span>\n  <span class=\"n\">C.map_rel</span> <span class=\"n\">h</span>\n</code></pre></div>\n<p>and</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">chromatic_number</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Inf</span> <span class=\"o\">{</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">|</span> <span class=\"n\">G.colorable</span> <span class=\"n\">n</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>the formatting rule is that types are indented, but bodies are not (something that took me a bit of getting used to.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">coloring.valid</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">G.adj</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"n\">v</span> <span class=\"bp\">≠</span> <span class=\"n\">C</span> <span class=\"n\">w</span> <span class=\"o\">:=</span>\n<span class=\"n\">C.map_rel</span> <span class=\"n\">h</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">chromatic_number</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span>\n<span class=\"n\">Inf</span> <span class=\"o\">{</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">|</span> <span class=\"n\">G.colorable</span> <span class=\"n\">n</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 261062854,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636582454
    },
    {
        "content": "<p>For the proof of <code>exists_fin_coloring_then_colorable</code>, it would be easier to use the definition of <code>colorable</code> directly and <code>use C</code> at the beginning.</p>",
        "id": 261063138,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636582615
    },
    {
        "content": "<p>For <code>empty_graph_trivially_colorable</code>, it might be worth pulling out a definition for a coloring of a graph with no vertices, like <code>def colorable_of_empty {V : Type*} (G : simple_graph V) (he : is_empty V) : G.coloring α := sorry</code></p>",
        "id": 261063463,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636582787
    },
    {
        "content": "<p>Another coloring that might help is the \"tautological\" coloring where vertices are colored by themselves.  <code>def self_coloring (G : simple_graph V) : G.coloring V</code>.  When <code>V</code> is a fintype this can be used to prove that <code>{n | G.colorable n}.nonempty</code>, which would also be a good lemma to have.</p>",
        "id": 261063932,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636583017
    },
    {
        "content": "<p>I think I was wrong to suggest defining <code>colorable</code> the way I did due to some universe variables reasons -- this shouldn't affect your work in the meantime, but I think I'll at some point soon do some refactoring of the branch to correct this.</p>",
        "id": 261064336,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636583203
    },
    {
        "content": "<p>(Thanks for pursuing this project!)</p>",
        "id": 261064362,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636583220
    },
    {
        "content": "<p>Thanks for the input!<br>\nOne thing I want to say is that since we're going straight into a definition of coloring as a graph homomorphism, it didn't make much sense to state intermediary definitions such as partial/complete/proper/feasible (because every coloring that we state is feasible according to Lewis' book). That's why I renamed every occurrence of \"proper_coloring\" to simply \"coloring\". Ultimately it's the coloring that we're always interested in anyways.</p>",
        "id": 261069871,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636586030
    },
    {
        "content": "<p>Oh right, I didn't notice the change (I usually call non-proper colorings \"vertex labelings\").  Make sure the doc strings mention that these are proper colorings, since some people do make a distinction.  (Also be prepared to rename it <code>proper_coloring</code> if consensus lands on that.)</p>",
        "id": 261070801,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636586586
    },
    {
        "content": "<p>Also, <a href=\"https://leanprover-community.github.io/mathlib_docs/find/complete_graph\">docs#complete_graph</a> has a reminder that the definition should be</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">abbreviation</span> <span class=\"n\">coloring</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">G</span> <span class=\"bp\">→</span><span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"bp\">⊤</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>That <code>⊤</code> is the \"top\" of the simple graph lattice.</p>",
        "id": 261071064,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636586761
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/252551-graph-theory/topic/coloring/near/261063138\">said</a>:</p>\n<blockquote>\n<p>For the proof of <code>exists_fin_coloring_then_colorable</code>, it would be easier to use the definition of <code>colorable</code> directly and <code>use C</code> at the beginning.</p>\n</blockquote>\n<p>I'm pretty sure I didn't understand what you meant here. If I do <code>rw colorable, use C,</code> Lean says </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">instantiate</span> <span class=\"n\">goal</span> <span class=\"k\">with</span> <span class=\"n\">C</span>\n<span class=\"n\">state</span><span class=\"o\">:</span>\n<span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">,</span>\n<span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">,</span>\n<span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">,</span>\n<span class=\"n\">_inst_1</span> <span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">,</span>\n<span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">G.coloring</span> <span class=\"n\">α</span>\n<span class=\"bp\">⊢</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">α_1</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">_inst_1_1</span> <span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"n\">α_1</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">G.coloring</span> <span class=\"n\">α_1</span><span class=\"o\">),</span> <span class=\"n\">fintype.card</span> <span class=\"n\">α_1</span> <span class=\"bp\">≤</span> <span class=\"n\">fintype.card</span> <span class=\"n\">α</span>\n</code></pre></div>",
        "id": 261071121,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636586780
    },
    {
        "content": "<p>Incidentally, this would be a vertex labeling (a non-proper coloring)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">abbreviation</span> <span class=\"n\">labeling</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">G</span> <span class=\"bp\">→</span><span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"bp\">⊥</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 261071192,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636586829
    },
    {
        "content": "<p>I meant <code>use</code> for the third part of the existential.  Start with <code>use α</code></p>",
        "id": 261071241,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636586866
    },
    {
        "content": "<p>The final goal will be <a href=\"https://leanprover-community.github.io/mathlib_docs/find/le_refl\">docs#le_refl</a></p>",
        "id": 261071337,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636586914
    },
    {
        "content": "<p>When I try <code>use α</code> it says </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">instantiate</span> <span class=\"n\">goal</span> <span class=\"k\">with</span> <span class=\"n\">α</span>\n<span class=\"n\">state</span><span class=\"o\">:</span>\n<span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">,</span>\n<span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">,</span>\n<span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">,</span>\n<span class=\"n\">_inst_1</span> <span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">,</span>\n<span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">G.coloring</span> <span class=\"n\">α</span>\n<span class=\"bp\">⊢</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">α_1</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">_inst_1_1</span> <span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"n\">α_1</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">G.coloring</span> <span class=\"n\">α_1</span><span class=\"o\">),</span> <span class=\"n\">fintype.card</span> <span class=\"n\">α_1</span> <span class=\"bp\">≤</span> <span class=\"n\">fintype.card</span> <span class=\"n\">α</span>\n</code></pre></div>",
        "id": 261071378,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636586954
    },
    {
        "content": "<p>Maybe it's related to the universe issues you mentioned?</p>",
        "id": 261071399,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636586972
    },
    {
        "content": "<p>Oh, indeed.  Ok, the quick fix is to use the <code>rw</code> you have already, then <code>rw</code> it backwards.</p>",
        "id": 261071483,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636587011
    },
    {
        "content": "<p>This will launder out the universe variable</p>",
        "id": 261071504,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636587028
    },
    {
        "content": "<p>Like this?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">rw</span> <span class=\"n\">colorable</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"bp\">←</span><span class=\"n\">colorable</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">colorable</span><span class=\"o\">,</span>\n</code></pre></div>",
        "id": 261071593,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636587107
    },
    {
        "content": "<p>Same issue as before</p>",
        "id": 261071607,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636587117
    },
    {
        "content": "<p>Sorry I wasn't specific enough, I meant the one that's still pushed to GitHub, with <code>rw colorable_iff_nonempty_fin_coloring</code></p>",
        "id": 261071779,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636587216
    },
    {
        "content": "<p>(That rewrites it into a form without the universe variable, and when you rewrite it back you're free to use any universe you want.)</p>",
        "id": 261071880,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636587260
    },
    {
        "content": "<p>Now it accepts <code>α</code></p>",
        "id": 261072006,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636587345
    },
    {
        "content": "<p>What's the right way to <code>use</code> this: <code>_inst_1: fintype α</code> without relying on those automatically provided names?</p>",
        "id": 261072137,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636587433
    },
    {
        "content": "<p>In other words, is there a way to do it that's not <code>use _inst_1</code>?</p>",
        "id": 261072167,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636587462
    },
    {
        "content": "<p>There are a few options. One is <code>fsplit, assumption</code></p>",
        "id": 261072175,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636587472
    },
    {
        "content": "<p>(<code>fsplit</code> is like <code>split</code> but it keeps things in order)</p>",
        "id": 261072238,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636587487
    },
    {
        "content": "<p><code>use</code> uses <code>fsplit</code> anyway, if I remember correctly</p>",
        "id": 261072263,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636587513
    },
    {
        "content": "<p>If the <code>fintype</code> is in the instance cache, you might be able to get away with <code>use [infer_instance]</code></p>",
        "id": 261072328,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636587567
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">exists_fin_coloring_then_colorable</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">G.coloring</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"n\">G.colorable</span> <span class=\"o\">(</span><span class=\"n\">fintype.card</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">colorable_iff_nonempty_fin_coloring</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">colorable_iff_nonempty_fin_coloring</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">colorable</span><span class=\"o\">,</span>\n  <span class=\"n\">use</span> <span class=\"n\">α</span><span class=\"o\">,</span>\n  <span class=\"n\">use</span> <span class=\"o\">[</span><span class=\"n\">infer_instance</span><span class=\"o\">],</span>\n  <span class=\"n\">use</span> <span class=\"n\">C</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>is accepted <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span></p>",
        "id": 261072436,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636587612
    },
    {
        "content": "<p><code>use [α, infer_instance, C]</code> is how you can do multiple <code>use</code>s</p>",
        "id": 261072496,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636587652
    },
    {
        "content": "<p>and you don't need to unfold the definition of <code>colorable</code>, so you can remove the third line</p>",
        "id": 261072518,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636587672
    },
    {
        "content": "<p>Nice</p>",
        "id": 261072565,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636587712
    },
    {
        "content": "<p>The formatting rule is that types get indented:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">exists_fin_coloring_then_colorable</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">G.coloring</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">G.colorable</span> <span class=\"o\">(</span><span class=\"n\">fintype.card</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"bp\">...</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 261072632,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636587737
    },
    {
        "content": "<p>About the \"coloring\" vs \"proper_coloring\" issue, what is your suggestion?</p>",
        "id": 261072676,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636587774
    },
    {
        "content": "<p>I say leave it until someone wants to put it up for a vote.  I'm fine with \"coloring\" myself.</p>",
        "id": 261072882,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636587910
    },
    {
        "content": "<p>Alright, I will just clarify it in the docstring eve further then</p>",
        "id": 261072922,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636587943
    },
    {
        "content": "<p>I'm gonna follow up on the other points you mentioned. Will get back soon</p>",
        "id": 261072999,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636587980
    },
    {
        "content": "<p>Done <a href=\"https://github.com/leanprover-community/mathlib/blob/graph-coloring-homomorphism/src/combinatorics/simple_graph/coloring.lean\">https://github.com/leanprover-community/mathlib/blob/graph-coloring-homomorphism/src/combinatorics/simple_graph/coloring.lean</a></p>\n<p>For the 3 last lemmas, I don't know how to proceed <span aria-label=\"sad\" class=\"emoji emoji-2639\" role=\"img\" title=\"sad\">:sad:</span></p>",
        "id": 261076693,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636590583
    },
    {
        "content": "<p>I guess we're able to state what the chromatic polynomial is now (modulo some instance definitions):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">noncomputable</span>\n<span class=\"kd\">def</span> <span class=\"n\">chromatic_poly</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">polynomial</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n<span class=\"bp\">∑</span> <span class=\"n\">G'</span> <span class=\"k\">in</span> <span class=\"n\">finset.univ.filter</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">G'</span><span class=\"o\">,</span> <span class=\"n\">G'</span> <span class=\"bp\">≤</span> <span class=\"n\">G</span><span class=\"o\">),</span>\n  <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"o\">(</span><span class=\"n\">G'.edge_finset.card</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">polynomial.X</span> <span class=\"bp\">^</span> <span class=\"n\">fintype.card</span> <span class=\"o\">(</span><span class=\"n\">quot</span> <span class=\"n\">G'.adj</span><span class=\"o\">)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">chromatic_poly_eq</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">polynomial.eval</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">G.chromatic_poly</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">fintype.card</span> <span class=\"o\">(</span><span class=\"n\">G.coloring</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>I think it should be possible to formalize something like the contradiction-deletion proof (even though we only have simple graphs) by making an auxiliary chromatic polynomial that takes two graphs and sums over the graphs between -- deletion corresponds to deleting an edge from the top graph, and contraction corresponds to adding an edge to the bottom graph.  You'd also define a version of coloring for a graph/subgraph pair, where adjacent vertices of the subgraph must get the same color, but vertices not adjacent in the subgraph must get different colors.  The auxiliary polynomial counts these kinds of colorings.</p>\n<p>Then you induct on the difference in the number of edges of the two graphs, choose an edge that's only in the top graph, and split the sum up into two, one for deletion and one for contraction. This is a difference, and you need to see this is actually the cardinality of the difference of two sets of colorings.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">noncomputable</span>\n<span class=\"kd\">def</span> <span class=\"n\">chromatic_poly.aux</span> <span class=\"o\">(</span><span class=\"n\">G₀</span> <span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"n\">polynomial</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n<span class=\"bp\">∑</span> <span class=\"n\">G'</span> <span class=\"k\">in</span> <span class=\"n\">finset.univ.filter</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">G'</span><span class=\"o\">,</span> <span class=\"n\">G₀</span> <span class=\"bp\">≤</span> <span class=\"n\">G'</span> <span class=\"bp\">∧</span> <span class=\"n\">G'</span> <span class=\"bp\">≤</span> <span class=\"n\">G</span><span class=\"o\">),</span>\n  <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"o\">((</span><span class=\"n\">G'.edge_finset</span> <span class=\"bp\">\\</span> <span class=\"n\">G₀.edge_finset</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">polynomial.X</span> <span class=\"bp\">^</span> <span class=\"n\">fintype.card</span> <span class=\"o\">(</span><span class=\"n\">quot</span> <span class=\"n\">G'.adj</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 261107231,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636620679
    },
    {
        "content": "<p>This auxiliary polynomial is actually has to do with mobius inversion on the lattice of spanning subgraphs, so maybe working out that theory of convolution products on lattices would be a useful. Henry Crapo has a couple of papers on that (including one on the Tutte polynomial) from 1968 and 1969.</p>",
        "id": 261108351,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636621436
    },
    {
        "content": "<p>For the instance, just leaving <code>_</code> in the <code>use</code>/<code>refine</code> should trigger typeclass inference.</p>",
        "id": 261109114,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1636622087
    },
    {
        "content": "<p>Kyle, I'm gonna read your changes in more detail and then try to move the things you suggested</p>",
        "id": 261192823,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636670902
    },
    {
        "content": "<p>(Regarding chromatic polynomials, those can wait until later.  There's a fair amount of work to develop them properly still.)</p>",
        "id": 261193092,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636671071
    },
    {
        "content": "<p>Do you think we could make a smaller PR without them? I think we've already got something worth merging</p>",
        "id": 261193348,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636671251
    },
    {
        "content": "<p>Yeah, just remove the things about chromatic polynomials for now.  (Including <code>open_locale big_operators</code> and the import for <code>algebra.big_operators.basic</code>)</p>",
        "id": 261193815,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636671613
    },
    {
        "content": "<p>My intuition is making me a bit reluctant about moving <code>complete_bipartite_graph</code> into <code>basic.lean</code></p>",
        "id": 261194508,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636672154
    },
    {
        "content": "<p>because it's a specific graph structure</p>",
        "id": 261194535,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636672179
    },
    {
        "content": "<p>(and there are many particular structures)</p>",
        "id": 261194718,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636672333
    },
    {
        "content": "<p>I'm gonna put it inside <code>basic.lean</code> and then we can decide later, when the PR is open</p>",
        "id": 261194792,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636672409
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/pull/10287\">https://github.com/leanprover-community/mathlib/pull/10287</a></p>",
        "id": 261195963,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636673487
    },
    {
        "content": "<p>Hey Kyle, would it be better if we had a separate <code>bipartite.lean</code> file in which we put the <code>complete_bipartite_graph</code> builder, a <code>is_bipartite</code> definition and a proof that a complete bipartite graph is bipartite?</p>\n<p>Then in the <code>coloring.lean</code> file we'd prove that the chromatic number of any bipartite graph is 2</p>",
        "id": 261244713,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636719920
    },
    {
        "content": "<p>Something like this:<br>\n<a href=\"https://github.com/leanprover-community/mathlib/pull/10301\">https://github.com/leanprover-community/mathlib/pull/10301</a></p>",
        "id": 261306962,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636749103
    },
    {
        "content": "<p>Eventually we can generalize this to n-partite graphs, but I think this structure is slightly better for a solid first step</p>",
        "id": 261307588,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636749442
    },
    {
        "content": "<p>Looks like you already kave k-colorable graphs, which is basically the same definition as being k-partite. Adding some functions to get the color classes (i.e., k-partition) out of a k-colorable graph and vice-versa should make it pretty comfortable to work with k-partite graphs.</p>",
        "id": 261311596,
        "sender_full_name": "Mauricio Collares",
        "timestamp": 1636751694
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"325367\">@Mauricio Collares</span> What I was thinking is how it's the equivalence between indexed families of types <code>\\iota -&gt; Type</code> and functions from a type to some labeling type <code>\\alpha -&gt; \\iota</code>. It's not hard going back and forth, but it's also not completely painless (you can't really round trip the transformation).</p>\n<p>It makes a lot of sense to define an <code>\\iota</code>-partition of a graph to be an <code>\\iota</code>-coloring (like <code>\\alpha -&gt; \\iota</code>), and that's even how we'd defined them in a very old branch, though maybe just with <code>fin 2</code> for bipartitions.</p>\n<p>It would be nice to have an interface for <code>\\iota -&gt; Type</code> style colorings, too (though as <code>\\iota -&gt; set V</code>).  I'm not sure how we write <code>\\iota</code>-indexed partitions of types in mathlib, but in any case it would be a function <code>c : \\iota -&gt; set V</code> whose images are disjoint and their union is all of <code>V</code>, and pairs of vertices in each <code>c i</code> are non-adjacent.</p>\n<p>The equivalence between <code>\\iota</code>-colorings and these sorts of partitions would implement color classes.</p>",
        "id": 261316871,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636754423
    },
    {
        "content": "<p>In \"paper math\" we'd have the coloring be a function <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>χ</mi><mspace></mspace><mspace width=\"0.1111111111111111em\"/><mo lspace=\"0em\" rspace=\"0.17em\"></mo><mtext> ⁣</mtext><mo lspace=\"0em\" rspace=\"0em\">:</mo><mspace width=\"0.3333333333333333em\"/><mi>V</mi><mo>→</mo><mi>ι</mi></mrow><annotation encoding=\"application/x-tex\">\\chi \\colon V \\to \\iota</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8777699999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">χ</span><span class=\"mspace nobreak\"></span><span class=\"mspace\" style=\"margin-right:0.1111111111111111em;\"></span><span class=\"mpunct\"></span><span class=\"mspace\" style=\"margin-right:-0.16666666666666666em;\"></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mrel\">:</span></span><span class=\"mspace\" style=\"margin-right:0.3333333333333333em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">ι</span></span></span></span> with some restriction that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>c</mi><mo stretchy=\"false\">(</mo><mi>u</mi><mo stretchy=\"false\">)</mo><mo mathvariant=\"normal\">≠</mo><mi>c</mi><mo stretchy=\"false\">(</mo><mi>v</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">c(u) \\neq c(v)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">c</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">u</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\"><span class=\"mrel\"><span class=\"mord vbox\"><span class=\"thinbox\"><span class=\"rlap\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"inner\"><span class=\"mord\"><span class=\"mrel\"></span></span></span><span class=\"fix\"></span></span></span></span></span><span class=\"mrel\">=</span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">c</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mclose\">)</span></span></span></span> whenever uv is an edge (or the equivalent thing stated as a homomorphism, like <span class=\"user-mention\" data-user-id=\"451983\">@Arthur Paulino</span> is doing) and your function <code>c</code> would associate to every <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi><mo>∈</mo><mi>ι</mi></mrow><annotation encoding=\"application/x-tex\">i \\in \\iota</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69862em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">ι</span></span></span></span> the inverse image <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>χ</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy=\"false\">(</mo><mi>i</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\chi^{-1}(i)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">χ</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">)</span></span></span></span>. So, a couple of naïve questions: This doesn't round trip for type theory-related reasons, I think? Or you're saying mathlib already has this sort of equivalence in greater generality somewhere, but it doesn't round trip in general? It would certanly be very useful to have some interface to be able to pass between the two forms easily.</p>",
        "id": 261318775,
        "sender_full_name": "Mauricio Collares",
        "timestamp": 1636755502
    },
    {
        "content": "<p>Speaking of which, I would like to try my hand at something math-simple like Turán's theorem in the near future, to get some practice. What's the protocol for that? On what branch do I base the work upon?</p>",
        "id": 261318835,
        "sender_full_name": "Mauricio Collares",
        "timestamp": 1636755561
    },
    {
        "content": "<p>(I know math-simple stuff can be very hard in Lean!)</p>",
        "id": 261319303,
        "sender_full_name": "Mauricio Collares",
        "timestamp": 1636755864
    },
    {
        "content": "<p>The round tripping failure's just when you have an actual indexed family of types, rather than subsets of the same type.  Having the indexed family be<code>set V</code> valued saves us here.  (Otherwise it's just that there's an equivalence of categories.)</p>",
        "id": 261321360,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636757363
    },
    {
        "content": "<p>Just for the record, the coloring as a homomorphism was Kyle's recommendation!</p>",
        "id": 261321634,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636757537
    },
    {
        "content": "<p>The way you go from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>c</mi><mo>:</mo><mi>ι</mi><mo>→</mo><mrow><mi mathvariant=\"normal\">T</mi><mi mathvariant=\"normal\">y</mi><mi mathvariant=\"normal\">p</mi><mi mathvariant=\"normal\">e</mi></mrow></mrow><annotation encoding=\"application/x-tex\">c:\\iota \\to \\mathrm{Type}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">c</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">ι</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8777699999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">Type</span></span></span></span></span> to an <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ι</mi></mrow><annotation encoding=\"application/x-tex\">\\iota</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">ι</span></span></span></span>-valued function to define <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><msub><mo>∑</mo><mrow><mi>i</mi><mo>∈</mo><mi>ι</mi></mrow></msub><mi>c</mi><mo stretchy=\"false\">(</mo><mi>i</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo><mo>→</mo><mi>ι</mi></mrow><annotation encoding=\"application/x-tex\">(\\sum_{i\\in\\iota} c(i))\\to \\iota</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.07708em;vertical-align:-0.32708000000000004em;\"></span><span class=\"mopen\">(</span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:-0.0000050000000000050004em;\">∑</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.16195399999999993em;\"><span style=\"top:-2.40029em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mrel mtight\">∈</span><span class=\"mord mathnormal mtight\">ι</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32708000000000004em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">c</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">))</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">ι</span></span></span></span> by <code>sigma.fst</code>, and to go back from a <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>χ</mi><mo>:</mo><mi>V</mi><mo>→</mo><mi>ι</mi></mrow><annotation encoding=\"application/x-tex\">\\chi:V\\to\\iota</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">χ</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">ι</span></span></span></span> you define <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>c</mi></mrow><annotation encoding=\"application/x-tex\">c</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">c</span></span></span></span> by <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>c</mi><mo stretchy=\"false\">(</mo><mi>i</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mo stretchy=\"false\">{</mo><mi>v</mi><mo>:</mo><mi>V</mi><mi mathvariant=\"normal\">/</mi><mi mathvariant=\"normal\">/</mi><mi>χ</mi><mo stretchy=\"false\">(</mo><mi>v</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>i</mi><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">c(i) = \\{v : V // \\chi( v) = i\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">c</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord\">//</span><span class=\"mord mathnormal\">χ</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">}</span></span></span></span>.  The <code>sigma</code> of all these <code>subtype</code>s isn't provably equal to <code>V</code> (and it's likely not equal).</p>",
        "id": 261321798,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636757666
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"325367\">Mauricio Collares</span> <a href=\"#narrow/stream/252551-graph-theory/topic/coloring/near/261318835\">said</a>:</p>\n<blockquote>\n<p>Speaking of which, I would like to try my hand at something math-simple like Turán's theorem in the near future, to get some practice. What's the protocol for that? On what branch do I base the work upon?</p>\n</blockquote>\n<p>It seems like you can base your work on the <code>master</code> branch for this, though it looks like you'll need cliques, which Yael seems to be working on.  You could probably define what you need and then post hoc try to merge things together.</p>\n<p>Once you have an invite for the mathlib repository (just ask, and an maintainer will bestow one) you can do development in your own branch, named something like <code>mauricio_turan</code></p>",
        "id": 261322209,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636757979
    },
    {
        "content": "<p>According to what Mauricio said, it seems like we don't need to define bipartite graphs at all. So instead have a raw definition for k-partitionable graphs and prove that k-partitionable graphs are k-colorable? And in the middle way provide the interchanging functions Mauricio mentioned?</p>",
        "id": 261322877,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636758370
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> do you think these can be useful?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">coloring.color_rel</span><span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"n\">C</span> <span class=\"n\">v</span> <span class=\"bp\">=</span> <span class=\"n\">C</span> <span class=\"n\">w</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">coloring.color_rel_reflexive</span> <span class=\"o\">:</span> <span class=\"n\">reflexive</span> <span class=\"o\">(</span><span class=\"n\">C.color_rel</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">obviously</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">coloring.color_rel_symmetric</span> <span class=\"o\">:</span> <span class=\"n\">symmetric</span> <span class=\"o\">(</span><span class=\"n\">C.color_rel</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span><span class=\"n\">intros</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">eq.symm</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">coloring.color_rel_transitive</span> <span class=\"o\">:</span> <span class=\"n\">transitive</span> <span class=\"o\">(</span><span class=\"n\">C.color_rel</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span><span class=\"n\">intros</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">hvw</span> <span class=\"n\">hvu</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">eq.trans</span> <span class=\"n\">hvw</span> <span class=\"n\">hvu</span><span class=\"o\">,</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">coloring.color_rel_equivalence</span> <span class=\"o\">:</span> <span class=\"n\">equivalence</span> <span class=\"n\">C.color_rel</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"n\">C.color_rel_reflexive</span><span class=\"o\">,</span> <span class=\"n\">C.color_rel_symmetric</span><span class=\"o\">,</span> <span class=\"n\">C.color_rel_transitive</span><span class=\"o\">⟩</span>\n</code></pre></div>",
        "id": 261332120,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636767861
    },
    {
        "content": "<p>I'm trying to build up what we might need to define a function that returns the partitions induced by a coloring</p>",
        "id": 261332154,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636767930
    },
    {
        "content": "<p>That happens to be <a href=\"https://leanprover-community.github.io/mathlib_docs/find/setoid.ker\">docs#setoid.ker</a> applied to <code>C</code></p>",
        "id": 261332248,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636768079
    },
    {
        "content": "<p>A setoid is a relation along with a proof that it's an equivalence relation</p>",
        "id": 261332301,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636768110
    },
    {
        "content": "<p>I also found <a href=\"https://leanprover-community.github.io/mathlib_docs/find/indexed_partition\">docs#indexed_partition</a> for indexed partitions, but it's not quite right since we don't want the <code>some</code> field</p>",
        "id": 261332403,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636768209
    },
    {
        "content": "<p>This is a way to define color classes:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">coloring.color_class</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">G.coloring</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">V</span> <span class=\"o\">:=</span> <span class=\"n\">C</span> <span class=\"bp\">⁻¹'</span> <span class=\"o\">{</span><span class=\"n\">c</span><span class=\"o\">}</span>  <span class=\"c1\">-- or equivalently {v | C v = c}</span>\n</code></pre></div>\n<p>(I don't know much about <code>setoid.ker</code> and the kinds of partitions it gives you.)</p>",
        "id": 261332546,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636768387
    },
    {
        "content": "<p>Maybe it makes sense to define <code>simple_graph.partition</code> like <code>indexed_partition</code> along with the requirement that vertices from the same partition are non-adjacent, and then we can define an equivalence between <code>G.partition \\alpha</code> and <code>G.coloring \\alpha</code>.</p>",
        "id": 261332610,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636768484
    },
    {
        "content": "<p>so, generalizing <code>bipartition</code> to this notion of partitioning a graph into an indexed set of vertices</p>",
        "id": 261332641,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636768536
    },
    {
        "content": "<p>I was expecting to have something that we could feed with an equivalence relation and a set and it would return the equivalence classes from that set</p>",
        "id": 261332725,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636768674
    },
    {
        "content": "<p>I guess there's another approach, which is to prove that the <code>color_classes</code> form a partition of <code>V</code> as a lemma, and then create a constructor for <code>coloring</code> that uses the indexed-family-of-sets interface (<code>def coloring.of_partition ...</code>).</p>\n<p>(One reason to have both <code>coloring</code> and <code>partition</code> would be to have some things be true by definitional equality, but I'm not sure when or where that might matter yet.)</p>",
        "id": 261332924,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636768846
    },
    {
        "content": "<p>The setoid interface also has something about getting the set of partitions, which you can get somehow from the  <code>setoid.ker C</code></p>",
        "id": 261333009,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636768948
    },
    {
        "content": "<p>There's a design question in all of this: in an n-partite graph, are the partitions distinguishable?</p>\n<p>I don't really have any theorems in mind where you need the partitions to be indistinguishable, so I've been thinking about indexed sets.</p>",
        "id": 261333083,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636769063
    },
    {
        "content": "<p>I'm not understanding the <code>setoid.ker</code> API very well</p>",
        "id": 261333192,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636769223
    },
    {
        "content": "<p>Supposing there's a reason for both, then the way it could work is <code>coloring</code> is specifically for distinguishable partitions of vertices and <code>partition</code> is specifically for indistinguishable partitions (so has a <code>set (set V)</code> to partition it).  There is a map from <code>coloring</code> to <code>partition</code> from forgetting colors and taking the color classes.</p>\n<p>(There's surprisingly a map from <code>partition</code> to <code>coloring</code> by coloring each vertex with the partition the vertex is a member of.)</p>",
        "id": 261333256,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636769306
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/setoid.ker\">docs#setoid.ker</a> is exactly the thing you proved, but wrapped up as a setoid.  <code>eq on C</code> is <code>\\lambda v w, C v = C w</code></p>",
        "id": 261333282,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636769377
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/setoid.ker_def\">docs#setoid.ker_def</a> proves that</p>",
        "id": 261333289,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636769399
    },
    {
        "content": "<p>But by saying <code>setoid.ker C</code>, I'm feeding it with something i've just built. How does it know <code>C</code> forms an equivalence relation?</p>",
        "id": 261333377,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636769500
    },
    {
        "content": "<p>It just checks this?<br>\n<code>(setoid.ker f).rel x y ↔ f x = f y</code></p>",
        "id": 261333438,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636769564
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">coloring.color_setoid</span> <span class=\"o\">:</span> <span class=\"n\">setoid</span> <span class=\"n\">V</span> <span class=\"o\">:=</span> <span class=\"n\">setoid.ker</span> <span class=\"n\">C</span>\n<span class=\"kd\">def</span> <span class=\"n\">coloring.color_rel</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">coloring.color_setoid</span> <span class=\"n\">C</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">rel</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">coloring.color_rel_equivalence</span> <span class=\"o\">:</span> <span class=\"n\">equivalence</span> <span class=\"n\">C.color_rel</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">coloring.color_setoid</span> <span class=\"n\">C</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">iseqv</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">coloring.color_rel_def</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">coloring.color_rel</span> <span class=\"n\">C</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"bp\">↔</span> <span class=\"n\">C</span> <span class=\"n\">v</span> <span class=\"bp\">=</span> <span class=\"n\">C</span> <span class=\"n\">w</span> <span class=\"o\">:=</span> <span class=\"n\">iff.rfl</span>\n</code></pre></div>",
        "id": 261333441,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636769567
    },
    {
        "content": "<p>The idea is that every function defines an equivalence relation given by whether things map to the same thing.</p>",
        "id": 261333462,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636769638
    },
    {
        "content": "<p>AAAAh!</p>",
        "id": 261333505,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636769672
    },
    {
        "content": "<p>I don't think you really need to go through equivalence relations, though, since for functions we call the partitions \"preimages\"</p>",
        "id": 261333506,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636769680
    },
    {
        "content": "<p>Yeah, not really. At least not for now. My motivation was just getting to the point of having an equivalence relation at hand, then search on mathlib API for something that would partition sets for me</p>",
        "id": 261333609,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636769873
    },
    {
        "content": "<p><span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span> </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">coloring.color_class</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">V</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">|</span> <span class=\"n\">C</span> <span class=\"n\">v</span> <span class=\"bp\">=</span> <span class=\"n\">c</span><span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">coloring.color_classes</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">{(</span><span class=\"n\">C.color_class</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"bp\">|</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n</code></pre></div>",
        "id": 261335780,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636772943
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> I'm trying to create a coloring from a partition with your idea of coloring every vertex in a subset of vertices with the subset itself but i'm not being able to figure out that last <code>sorry</code></p>\n<p><a href=\"https://github.com/leanprover-community/mathlib/pull/10321\">https://github.com/leanprover-community/mathlib/pull/10321</a></p>",
        "id": 261427406,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636909691
    },
    {
        "content": "<p><code>hn</code> states that <code>v</code> and <code>w</code> belong to the same subset:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">hn</span><span class=\"o\">:</span> <span class=\"n\">G.subset_of_vertex</span> <span class=\"n\">hp</span> <span class=\"n\">v</span> <span class=\"bp\">=</span> <span class=\"n\">G.subset_of_vertex</span> <span class=\"n\">hp</span> <span class=\"n\">w</span>\n</code></pre></div>\n<p>I also have <code>sv: set V</code>, <code>h_sv_in_P: sv ∈ P</code> and <code>h_v_in_sv: v ∈ sv</code></p>\n<p>The goal is to prove that <code>w ∈ sv</code></p>",
        "id": 261427521,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636909867
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">subset_of_vertex_spec</span> <span class=\"o\">(</span><span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"n\">G.is_partition</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">G.subset_of_vertex</span> <span class=\"n\">hp</span> <span class=\"n\">v</span> <span class=\"bp\">∈</span> <span class=\"n\">P</span> <span class=\"bp\">∧</span> <span class=\"n\">v</span> <span class=\"bp\">∈</span> <span class=\"n\">G.subset_of_vertex</span> <span class=\"n\">hp</span> <span class=\"n\">v</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨⟨</span><span class=\"n\">h1</span><span class=\"o\">,</span> <span class=\"n\">h2</span><span class=\"o\">⟩,</span> <span class=\"n\">h3</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">hp.valid.2</span> <span class=\"n\">v</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">some_spec</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">h1</span><span class=\"o\">,</span> <span class=\"n\">h2.1</span><span class=\"o\">⟩,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">different_subsets_of_adjacent</span> <span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"n\">G.is_partition</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">G.adj</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">G.subset_of_vertex</span> <span class=\"n\">hp</span> <span class=\"n\">v</span> <span class=\"bp\">≠</span> <span class=\"n\">G.subset_of_vertex</span> <span class=\"n\">hp</span> <span class=\"n\">w</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">have</span> <span class=\"n\">aa</span> <span class=\"o\">:=</span> <span class=\"n\">hp.valid.2</span><span class=\"o\">,</span>\n  <span class=\"n\">intro</span> <span class=\"n\">hn</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">hv</span> <span class=\"o\">:=</span> <span class=\"n\">G.subset_of_vertex_spec</span> <span class=\"n\">hp</span> <span class=\"n\">v</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">hw</span> <span class=\"o\">:=</span> <span class=\"n\">G.subset_of_vertex_spec</span> <span class=\"n\">hp</span> <span class=\"n\">w</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">h1</span> <span class=\"o\">:=</span> <span class=\"n\">hp.independent</span> <span class=\"n\">_</span> <span class=\"n\">hv.1</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"bp\">←</span><span class=\"n\">hn</span> <span class=\"n\">at</span> <span class=\"n\">hw</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">h1</span> <span class=\"n\">v</span> <span class=\"n\">hv.2</span> <span class=\"n\">w</span> <span class=\"n\">hw.2</span> <span class=\"o\">(</span><span class=\"n\">G.ne_of_adj</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 261427957,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636910427
    },
    {
        "content": "<p>Wow</p>",
        "id": 261427986,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636910492
    },
    {
        "content": "<p>Time to learn</p>",
        "id": 261428074,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636910603
    },
    {
        "content": "<p>Thank you very much!</p>",
        "id": 261428089,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636910637
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"451983\">@Arthur Paulino</span> I think in this case it would be better if <code>partition</code> were a struct that held the set, rather than being a predicate:</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">Copyright (c) 2021 Arthur Paulino. All rights reserved.</span>\n<span class=\"cm\">Released under Apache 2.0 license as described in the file LICENSE.</span>\n<span class=\"cm\">Authors: Arthur Paulino, Kyle Miller</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"kn\">import</span> <span class=\"n\">combinatorics.simple_graph.coloring</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.setoid.partition</span>\n<span class=\"kn\">import</span> <span class=\"n\">order.antichain</span>\n\n<span class=\"kd\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">simple_graph</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">partition</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">parts</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">V</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">is_partition</span> <span class=\"o\">:</span> <span class=\"n\">setoid.is_partition</span> <span class=\"n\">parts</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">independent</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">∈</span> <span class=\"n\">parts</span><span class=\"o\">),</span> <span class=\"n\">is_antichain</span> <span class=\"n\">G.adj</span> <span class=\"n\">s</span><span class=\"o\">)</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">partition</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">G</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">G.partition</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">part_of_vertex</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">V</span> <span class=\"o\">:=</span>\n<span class=\"n\">classical.some</span> <span class=\"o\">(</span><span class=\"n\">P.is_partition.2</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">part_of_vertex_mem</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">P.part_of_vertex</span> <span class=\"n\">v</span> <span class=\"bp\">∈</span> <span class=\"n\">P.parts</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"bp\">-</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">P.is_partition.2</span> <span class=\"n\">v</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">some_spec.1</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">mem_part_of_vertex</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">v</span> <span class=\"bp\">∈</span> <span class=\"n\">P.part_of_vertex</span> <span class=\"n\">v</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨⟨</span><span class=\"n\">h1</span><span class=\"o\">,</span> <span class=\"n\">h2</span><span class=\"o\">⟩,</span> <span class=\"n\">h3</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">P.is_partition.2</span> <span class=\"n\">v</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">some_spec</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">h2.1</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">part_of_vertex_ne_of_adj</span> <span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">G.adj</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">P.part_of_vertex</span> <span class=\"n\">v</span> <span class=\"bp\">≠</span> <span class=\"n\">P.part_of_vertex</span> <span class=\"n\">w</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">have</span> <span class=\"n\">aa</span> <span class=\"o\">:=</span> <span class=\"n\">P.is_partition.2</span><span class=\"o\">,</span>\n  <span class=\"n\">intro</span> <span class=\"n\">hn</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">hw</span> <span class=\"o\">:=</span> <span class=\"n\">P.mem_part_of_vertex</span> <span class=\"n\">w</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"bp\">←</span><span class=\"n\">hn</span> <span class=\"n\">at</span> <span class=\"n\">hw</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">h1</span> <span class=\"o\">:=</span> <span class=\"n\">P.independent</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">P.part_of_vertex_mem</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">P.mem_part_of_vertex</span> <span class=\"n\">v</span><span class=\"o\">),</span>\n  <span class=\"n\">exact</span> <span class=\"n\">h1</span> <span class=\"n\">w</span> <span class=\"n\">hw</span> <span class=\"o\">(</span><span class=\"n\">G.ne_of_adj</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">to_coloring</span> <span class=\"o\">:</span> <span class=\"n\">G.coloring</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">coloring.mk</span> <span class=\"n\">P.part_of_vertex</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intros</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">hvw</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">P.part_of_vertex_ne_of_adj</span> <span class=\"n\">hvw</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">partition</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">simple_graph</span>\n</code></pre></div>\n</div></div>",
        "id": 261428518,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636911200
    },
    {
        "content": "<p>Makes sense. It was my approach because if we have \"a coloring\" then we'd like to have \"a partition\"</p>",
        "id": 261429510,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636912260
    },
    {
        "content": "<p>I'm gonna try to create a <code>from_coloring</code> function</p>",
        "id": 261429657,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636912428
    },
    {
        "content": "<p>There's a stricter version of <code>to_coloring</code> by the way, where the target is <code>parts</code> coerced to a type.  You can use it to show that an n-partite graph is n-colorable:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">to_coloring</span> <span class=\"o\">:</span> <span class=\"n\">G.coloring</span> <span class=\"n\">P.parts</span> <span class=\"o\">:=</span>\n<span class=\"n\">coloring.mk</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">P.part_of_vertex</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">P.part_of_vertex_mem</span> <span class=\"n\">v</span><span class=\"o\">⟩)</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intros</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">hvw</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">ne.def</span><span class=\"o\">,</span> <span class=\"n\">subtype.mk_eq_mk</span><span class=\"o\">],</span>\n  <span class=\"n\">exact</span> <span class=\"n\">P.part_of_vertex_ne_of_adj</span> <span class=\"n\">hvw</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">to_colorable</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">P.parts</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"n\">G.colorable</span> <span class=\"o\">(</span><span class=\"n\">fintype.card</span> <span class=\"n\">P.parts</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">coloring.to_colorable</span> <span class=\"n\">P.to_coloring</span>\n</code></pre></div>",
        "id": 261432790,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636916291
    },
    {
        "content": "<p>Now I'm stuck with some <a href=\"https://github.com/leanprover-community/mathlib/blob/6baf7582817c2f1232a79d87ed02f679f9faeb5d/src/combinatorics/simple_graph/coloring.lean#L92\">(apparently simple) <code>sorry</code>s</a></p>",
        "id": 261438619,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636924429
    },
    {
        "content": "<p>I'm trying to prove that the set of color classes is a partition. I've successfully proved that it's an independent set w.r.t. <code>G.adj</code> tho</p>",
        "id": 261438679,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636924502
    },
    {
        "content": "<p>The second <code>sorry</code> can actually be replaced by <code>obviously</code></p>",
        "id": 261438991,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636925005
    },
    {
        "content": "<p>You might instead try proving <code>C.color_classes = (setoid.ker C).classes</code>, and then this partition lemma would be a quick consequence</p>",
        "id": 261439152,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636925236
    },
    {
        "content": "<p>(but don't let that stop you from proving this lemma directly since it's not a bad exercise in itself)</p>",
        "id": 261439200,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636925285
    },
    {
        "content": "<p>I'm struggling with things that I believe should be simple.<br>\nFor instance, in this state:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">V</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span>\n<span class=\"n\">G</span><span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span>\n<span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span>\n<span class=\"n\">C</span><span class=\"o\">:</span> <span class=\"n\">G.coloring</span> <span class=\"n\">α</span>\n<span class=\"n\">v</span><span class=\"o\">:</span> <span class=\"n\">V</span>\n<span class=\"bp\">⊢</span> <span class=\"bp\">¬</span><span class=\"o\">{</span><span class=\"n\">v_1</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">|</span> <span class=\"bp\">⇑</span><span class=\"n\">C</span> <span class=\"n\">v_1</span> <span class=\"bp\">=</span> <span class=\"bp\">⇑</span><span class=\"n\">C</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"bp\">=</span> <span class=\"bp\">∅</span>\n</code></pre></div>\n<p>That set on the left obviously contains <code>v</code> and thus is not empty</p>",
        "id": 261439314,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636925468
    },
    {
        "content": "<p>And on this state:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">V</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span>\n<span class=\"n\">G</span><span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span>\n<span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span>\n<span class=\"n\">C</span><span class=\"o\">:</span> <span class=\"n\">G.coloring</span> <span class=\"n\">α</span>\n<span class=\"n\">vw</span><span class=\"o\">:</span> <span class=\"n\">V</span>\n<span class=\"n\">hcvw</span><span class=\"o\">:</span> <span class=\"bp\">⇑</span><span class=\"n\">C</span> <span class=\"n\">v</span> <span class=\"bp\">=</span> <span class=\"bp\">⇑</span><span class=\"n\">C</span> <span class=\"n\">w</span>\n<span class=\"bp\">⊢</span> <span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">|</span> <span class=\"bp\">⇑</span><span class=\"n\">C</span> <span class=\"n\">v</span> <span class=\"bp\">=</span> <span class=\"bp\">⇑</span><span class=\"n\">C</span> <span class=\"n\">w</span><span class=\"o\">}</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"n\">v_1</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">|</span> <span class=\"bp\">⇑</span><span class=\"n\">C</span> <span class=\"n\">v_1</span> <span class=\"bp\">=</span> <span class=\"bp\">⇑</span><span class=\"n\">C</span> <span class=\"n\">v</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>I want to substitute <code>C v</code> by <code>C w</code> using <code>hcvw</code> but the <code>subst</code> tactic doesn't work when I do <code>subst hcvw,</code><br>\nIt says:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">subst</span> <span class=\"n\">tactic</span> <span class=\"n\">failed</span><span class=\"o\">,</span> <span class=\"n\">hypothesis</span> <span class=\"bp\">'</span><span class=\"n\">hcvw'</span> <span class=\"n\">is</span> <span class=\"n\">not</span> <span class=\"n\">of</span> <span class=\"n\">the</span> <span class=\"n\">form</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"n\">or</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 261439382,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636925569
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/set.ne_empty_iff_nonempty\">docs#set.ne_empty_iff_nonempty</a> helps with the first one, and just <code>rw hcvw</code> for the second?</p>",
        "id": 261439401,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1636925625
    },
    {
        "content": "<p>oh, it's under a binder maybe? <code>simp_rw [hcvw]</code>?</p>",
        "id": 261439447,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1636925657
    },
    {
        "content": "<p>I never know what is a binder and what isn't.</p>",
        "id": 261439458,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1636925674
    },
    {
        "content": "<p>(<code>subst</code> is a way to eliminate a variable completely, and neither <code>C v</code> nor <code>C w</code> are variables.)</p>",
        "id": 261439459,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636925678
    },
    {
        "content": "<p>It's tricksy, the <code>v</code> on the LHS of the goal is not the <code>v</code> in <code>hcvw</code>, btw.</p>",
        "id": 261439463,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1636925696
    },
    {
        "content": "<p>I guess <code>congr'</code> would also do it for the second one</p>",
        "id": 261439470,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1636925711
    },
    {
        "content": "<p>For set equality, good ole' <code>ext, simp</code> should work. With <code>ext, simp [hcvw]</code>.</p>",
        "id": 261439479,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1636925733
    },
    {
        "content": "<p>Basically all of your suggestion for the second one worked <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span></p>",
        "id": 261439532,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636925821
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>    <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">set.not_nonempty_iff_eq_empty</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">not_not</span><span class=\"o\">],</span>\n    <span class=\"n\">use</span> <span class=\"n\">v</span><span class=\"o\">,</span>\n    <span class=\"n\">obviously</span><span class=\"o\">,</span>\n</code></pre></div>\n<p>did the trick for the first one. thanks everyone!</p>",
        "id": 261439887,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636926441
    },
    {
        "content": "<p>Try using <code>dsimp</code> to see what that last goal is before <code>obviously</code> (which is more often written as <code>tidy</code>, by the way). There's a short proof that doesn't use such a heavy tactic.</p>\n<p>Also, the <code>simp only</code> can be replaced by <code>rw</code>, so you can merge the first two lines into a <code>rw [..., ...]</code></p>",
        "id": 261440237,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636927035
    },
    {
        "content": "<p><code>⇑C v = ⇑C v</code> so a <code>refl</code> did it</p>",
        "id": 261440405,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636927217
    },
    {
        "content": "<p>I didn't look into why exactly, but if you don't have <code>dsimp</code> it seems you need <code>exact rfl</code> rather than <code>refl</code>. (Maybe because the goal isn't syntactically a relation?)</p>",
        "id": 261440586,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636927443
    },
    {
        "content": "<p>that will do it</p>",
        "id": 261440622,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1636927514
    },
    {
        "content": "<p><code>refl</code> looks at the (syntactic) type of the expression to determine which reflexivity lemma to apply, it's not always <code>rfl</code></p>",
        "id": 261440640,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1636927553
    },
    {
        "content": "<p><code>exact rfl</code> worked too <span aria-label=\"tada\" class=\"emoji emoji-1f389\" role=\"img\" title=\"tada\">:tada:</span></p>",
        "id": 261441061,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636928079
    },
    {
        "content": "<p>Alright, the PR has been updated with content for partitions:<br>\n<a href=\"https://github.com/leanprover-community/mathlib/pull/10287\">https://github.com/leanprover-community/mathlib/pull/10287</a></p>",
        "id": 261443782,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636931781
    },
    {
        "content": "<p>Kyle do you think we could remove the formalization that's specifically about bipartite graphs since we have a generalization on k-partites on the roadmap?</p>",
        "id": 261883957,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1637208347
    }
]
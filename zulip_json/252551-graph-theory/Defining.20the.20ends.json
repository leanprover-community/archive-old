[
    {
        "content": "<p>Hey,</p>\n<p>I'm trying to define the ends of a graph and have written some code towards that <a href=\"https://github.com/bottine/mathlib/blob/abedaeec2d7edbd5a1cf9e9df74289e73a4e544b/src/combinatorics/simple_graph/ends.lean\">**here**</a>.<br>\nAs of now, there is a working (up to a few <code>sorry</code>s) definition of the ends, but nothing is proved about them.<br>\nI feel like the code structure is far from ideal, and would like to get some feedback in order to have a better base to work on.</p>\n<p>If anyone is up for having a look, here are a few questions I have:</p>\n<ul>\n<li>\n<p>I'm defining the set of ends manually as a set of functions satisfying some commutation properties, but it's really just a filtered (co?)limit. <br>\n  Are there built-ins I should use for that? In particular, at some point I'd like to say that this limit is entirely defined by any \"cofinal\" subdiagram, for which it would be easier to just pluck a lemma from somewhere else.</p>\n</li>\n<li>\n<p>At line 507, if I replace the <code>λ ⟨f,f_comm⟩,</code> by <code>λ f,</code>, then LEAN gets stuck at parsing this line, and I have no idea why.</p>\n</li>\n<li>Related to the bullet above, when defining functions by destructuring in a lambda like that, I get <code>_match</code> hypothesis in all the proofs and I'm not sure how to deal with them properly to prove things.</li>\n<li>I'm still mystified by the proper use of parameters and variables, which makes my code very dirty. Same thing for instances.</li>\n<li>Am I right assuming that <code>is_connected</code> is not built-in the simple_graph api yet?</li>\n</ul>\n<p>Thanks :)</p>",
        "id": 276010291,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1647843539
    },
    {
        "content": "<p><code>simple_graph.connected</code> is in <a href=\"https://github.com/leanprover-community/mathlib/pull/12574\">#12574</a>, which I think <span class=\"user-mention\" data-user-id=\"246273\">@Bhavik Mehta</span> is happy with, but it won't be in mathlib until that's merged</p>",
        "id": 276010749,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1647844175
    },
    {
        "content": "<p>Nice to see work on ends. Quite a while back I'd defined them as (effectively) a limit on subgraphs induced by cofinite vertex subsets, using the pi_0 functor (implemented specially for graphs). I didn't do much with it and didn't like how it was going, and it's probably safe to assume that particular code is lost.</p>",
        "id": 276010942,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1647844427
    },
    {
        "content": "<p>Maybe looking at some of the code around <a href=\"https://leanprover-community.github.io/mathlib_docs/find/nonempty_sections_of_fintype_inverse_system\">docs#nonempty_sections_of_fintype_inverse_system</a> might give ideas for how to put things in terms of (cofiltered) limits. I'm only pointing toward this one because I'm familiar with it.</p>",
        "id": 276011318,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1647844860
    },
    {
        "content": "<p>For line 507, if you're wanting to pattern match like that, it's usually better to use <code>match</code> directly or to use a definition's built-in match syntax:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">to_ends_for</span> <span class=\"o\">(</span><span class=\"n\">ℱ</span> <span class=\"bp\">⊆</span> <span class=\"n\">finsubsets</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ℱ_cofin</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"n\">finsubsets</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">ℱ</span><span class=\"o\">,</span> <span class=\"n\">K.val</span> <span class=\"bp\">⊆</span> <span class=\"n\">F.val</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">ends</span> <span class=\"bp\">→</span> <span class=\"n\">ends_for</span> <span class=\"n\">ℱ</span> <span class=\"n\">H</span> <span class=\"n\">ℱ_cofin</span>\n<span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">f_comm</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span>\n</code></pre></div>",
        "id": 276011418,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1647844992
    },
    {
        "content": "<p>Incidentally, you can write that whole definition as</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">to_ends_for</span> <span class=\"o\">(</span><span class=\"n\">ℱ</span> <span class=\"bp\">⊆</span> <span class=\"n\">finsubsets</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ℱ_cofin</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"n\">finsubsets</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">ℱ</span><span class=\"o\">,</span> <span class=\"n\">K.val</span> <span class=\"bp\">⊆</span> <span class=\"n\">F.val</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">ends</span> <span class=\"bp\">→</span> <span class=\"n\">ends_for</span> <span class=\"n\">ℱ</span> <span class=\"n\">H</span> <span class=\"n\">ℱ_cofin</span>\n<span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">f_comm</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">K</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"o\">⟨</span><span class=\"n\">K</span><span class=\"o\">,</span> <span class=\"n\">H</span> <span class=\"n\">K.property</span><span class=\"o\">⟩,</span> <span class=\"bp\">λ</span> <span class=\"n\">K</span> <span class=\"n\">L</span> <span class=\"n\">hKL</span><span class=\"o\">,</span>\n                  <span class=\"n\">f_comm</span> <span class=\"o\">(</span><span class=\"n\">set.inclusion</span> <span class=\"n\">H</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">set.inclusion</span> <span class=\"n\">H</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"n\">hKL</span><span class=\"o\">⟩</span>\n</code></pre></div>",
        "id": 276011600,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1647845197
    },
    {
        "content": "<p>Regarding parameters vs variables: I suggest that you use <code>variables</code> unless you know <code>parameters</code> would make things nicer. I don't think I've contributed code that's used <code>parameters</code>, for what it's worth. (You could search the mathlib repository for <code>parameter</code> to see how they're used.)</p>",
        "id": 276011689,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1647845357
    },
    {
        "content": "<p>I forgot to mention: one reason I pointed out <a href=\"https://leanprover-community.github.io/mathlib_docs/find/nonempty_sections_of_fintype_inverse_system\">docs#nonempty_sections_of_fintype_inverse_system</a> is that it might be useful for things about ends, since it's the category theory version of Konig's lemma, so for example given an end I think you can use it to prove there's an infinite ray to that end.</p>",
        "id": 276011919,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1647845600
    },
    {
        "content": "<p>Great, thanks for all the feedback :)</p>",
        "id": 276012602,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1647846302
    },
    {
        "content": "<p>Re. the <code>pi_0</code> approach: it might indeed be the case that a more high-level definition makes more sense… I'm not sure</p>",
        "id": 276012940,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1647846618
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/252551-graph-theory/topic/Defining.20the.20ends/near/276011600\">said</a>:</p>\n<blockquote>\n<p>Incidentally, you can write that whole definition as</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">to_ends_for</span> <span class=\"o\">(</span><span class=\"n\">ℱ</span> <span class=\"bp\">⊆</span> <span class=\"n\">finsubsets</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ℱ_cofin</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"n\">finsubsets</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">ℱ</span><span class=\"o\">,</span> <span class=\"n\">K.val</span> <span class=\"bp\">⊆</span> <span class=\"n\">F.val</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">ends</span> <span class=\"bp\">→</span> <span class=\"n\">ends_for</span> <span class=\"n\">ℱ</span> <span class=\"n\">H</span> <span class=\"n\">ℱ_cofin</span>\n<span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">f_comm</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">K</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"o\">⟨</span><span class=\"n\">K</span><span class=\"o\">,</span> <span class=\"n\">H</span> <span class=\"n\">K.property</span><span class=\"o\">⟩,</span> <span class=\"bp\">λ</span> <span class=\"n\">K</span> <span class=\"n\">L</span> <span class=\"n\">hKL</span><span class=\"o\">,</span>\n                  <span class=\"n\">f_comm</span> <span class=\"o\">(</span><span class=\"n\">set.inclusion</span> <span class=\"n\">H</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">set.inclusion</span> <span class=\"n\">H</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"n\">hKL</span><span class=\"o\">⟩</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>It seems that doing this, I can't unfold the def anymore. Why would that be?</p>",
        "id": 276013047,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1647846750
    },
    {
        "content": "<p>There's another PR for connected components in the works (<a href=\"https://github.com/leanprover-community/mathlib/pull/12766\">#12766</a>, <span class=\"user-mention\" data-user-id=\"246273\">@Bhavik Mehta</span> and I were just trying to decide how to set it up) and it would be nice to have a followup PR about functoriality properties. I think <span class=\"user-mention\" data-user-id=\"133584\">@Joseph Hua</span> was working on induced subgraphs. We will also have a way to map walks from a subgraph to a supergraph (I was planning on getting to that eventually). Once all that is in, then one way to organize a formalization of ends is in terms of the limit of connected components of induced subgraphs of cofinite vertex sets in a fairly direct way.</p>\n<p>That all said, it's probably better not to wait -- your being the vanguard is helpful to see what's missing and to see what kinds of theorems the library should support. I like to avoid PRing definitions unless they've proven themselves in theorems.</p>",
        "id": 276013153,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1647846860
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"461830\">Rémi Bottinelli</span> <a href=\"#narrow/stream/252551-graph-theory/topic/Defining.20the.20ends/near/276013047\">said</a>:</p>\n<blockquote>\n<p>It seems that doing this, I can't unfold the def anymore. Why would that be?</p>\n</blockquote>\n<p>It's because of the equation lemmas it generates are different. Try doing <code>#print prefix simple_graph.ends.to_ends_for</code> (I'm guessing the namespace there) before and after the change.</p>",
        "id": 276013229,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1647846959
    },
    {
        "content": "<p>If you <em>really</em> want to unfold, I think <a href=\"https://leanprover-community.github.io/mathlib_docs/tactics.html#delta\">tactic#delta</a> should work. But, if you're unfolding, you might instead think about what you're trying to accomplish by unfolding and write a lemma that accomplishes what you want directly.</p>",
        "id": 276013331,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1647847050
    },
    {
        "content": "<p>but aren't you going to unfold in the lemma in that case? As far as I managed, it seemed except for simple <code>simp</code> doing things for me, I always need one unfold.</p>",
        "id": 276013502,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1647847202
    },
    {
        "content": "<p>Yeah, you'll need to unfold things sometimes, it's just worth thinking about whether you're doing this because you're missing specialized lemmas.</p>\n<p>One I tried to write is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">to_ends_for_def</span> <span class=\"o\">(</span><span class=\"n\">ℱ</span> <span class=\"bp\">⊆</span> <span class=\"n\">finsubsets</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ℱ_cofin</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"n\">finsubsets</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">ℱ</span><span class=\"o\">,</span> <span class=\"n\">K.val</span> <span class=\"bp\">⊆</span> <span class=\"n\">F.val</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">ends</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">to_ends_for</span> <span class=\"n\">ℱ</span> <span class=\"n\">H</span> <span class=\"n\">ℱ_cofin</span> <span class=\"n\">e</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"bp\">=</span> <span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"n\">ℱ</span><span class=\"o\">),</span> <span class=\"n\">e.1</span> <span class=\"o\">⟨</span><span class=\"n\">K</span><span class=\"o\">,</span> <span class=\"n\">H</span> <span class=\"n\">K.property</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"gr\">sorry</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>but it seems to cause Lean to hang, and I'm not sure why.</p>",
        "id": 276014336,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1647848090
    },
    {
        "content": "<p>By the way, did you take a look at the equation lemmas?</p>\n<p>Abbreviated:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#print</span> <span class=\"kd\">prefix</span> <span class=\"n\">simple_graph.connected_outside.ends.to_ends_for.equations</span>\n\n<span class=\"n\">to_ends_for</span> <span class=\"n\">ℱ</span> <span class=\"n\">H</span> <span class=\"n\">ℱ_cofin</span> <span class=\"o\">⟨</span><span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">f_comm</span><span class=\"o\">⟩</span> <span class=\"bp\">=</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"bp\">↥</span><span class=\"n\">ℱ</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"o\">⟨</span><span class=\"bp\">↑</span><span class=\"n\">K</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span>\n</code></pre></div>\n<p>This means that when you unfold, you need the <code>ends</code> argument to be a constructor. One way to use it is to do cases on that argument first. For example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">to_of_ends_for_is_id</span>  <span class=\"o\">(</span><span class=\"n\">ℱ</span> <span class=\"bp\">⊆</span> <span class=\"n\">finsubsets</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ℱ_cofin</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"n\">finsubsets</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">ℱ</span><span class=\"o\">,</span> <span class=\"n\">K.val</span> <span class=\"bp\">⊆</span> <span class=\"n\">F.val</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">to_ends_for</span> <span class=\"n\">ℱ</span> <span class=\"n\">H</span> <span class=\"n\">ℱ_cofin</span><span class=\"o\">)</span> <span class=\"bp\">∘</span> <span class=\"o\">(</span><span class=\"n\">of_ends_for</span> <span class=\"n\">ℱ</span> <span class=\"n\">H</span> <span class=\"n\">ℱ_cofin</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">id</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">apply</span> <span class=\"n\">funext</span><span class=\"o\">,</span>\n  <span class=\"n\">rintros</span> <span class=\"o\">⟨</span><span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">hg</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">of_ends_for</span><span class=\"o\">,</span> <span class=\"n\">to_ends_for</span><span class=\"o\">],</span>\n  <span class=\"gr\">sorry</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 276014463,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1647848262
    },
    {
        "content": "<p>(You can collapse the <code>apply</code>/<code>rintros</code> lines into a single <code>ext1 ⟨g, hg⟩</code>)</p>",
        "id": 276014547,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1647848360
    },
    {
        "content": "<p>ah, it sort of makes sense that since the definition of <code>to_ends_for</code> is in terms of a constructor, you need to unfold it likwise.</p>",
        "id": 276014617,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1647848410
    },
    {
        "content": "<p>Re. equations lemmas: So, whenever I want to <code>unfold</code>/<code>simp</code> a def, if things don't go as well as I'd like, I should inspect <code>#print prefix path.to.def.equations</code> to see if there is one that applies?</p>",
        "id": 276014673,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1647848512
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">to_of_ends_for_is_id</span>  <span class=\"o\">(</span><span class=\"n\">ℱ</span> <span class=\"bp\">⊆</span> <span class=\"n\">finsubsets</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ℱ_cofin</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"n\">finsubsets</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">ℱ</span><span class=\"o\">,</span> <span class=\"n\">K.val</span> <span class=\"bp\">⊆</span> <span class=\"n\">F.val</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">to_ends_for</span> <span class=\"n\">ℱ</span> <span class=\"n\">H</span> <span class=\"n\">ℱ_cofin</span><span class=\"o\">)</span> <span class=\"bp\">∘</span> <span class=\"o\">(</span><span class=\"n\">of_ends_for</span> <span class=\"n\">ℱ</span> <span class=\"n\">H</span> <span class=\"n\">ℱ_cofin</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">id</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">apply</span> <span class=\"n\">funext</span><span class=\"o\">,</span>\n  <span class=\"n\">rintros</span> <span class=\"o\">⟨</span><span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">g_comm</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">of_ends_for</span><span class=\"o\">,</span> <span class=\"n\">to_ends_for</span><span class=\"o\">],</span>\n  <span class=\"n\">apply</span> <span class=\"n\">funext</span><span class=\"o\">,</span>\n  <span class=\"n\">rintros</span> <span class=\"n\">F</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">g_comm</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>Here we go, thanks!</p>",
        "id": 276014833,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1647848643
    },
    {
        "content": "<p>Yeah, that's what I usually do to debug definitions.</p>",
        "id": 276014839,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1647848647
    },
    {
        "content": "<p>Shorter but equivalent proof:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">begin</span>\n  <span class=\"n\">ext1</span> <span class=\"o\">⟨</span><span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">g_comm</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">of_ends_for</span><span class=\"o\">,</span> <span class=\"n\">to_ends_for</span><span class=\"o\">],</span>\n  <span class=\"n\">ext1</span> <span class=\"n\">F</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">g_comm</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 276014866,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1647848699
    },
    {
        "content": "<p>To make that mathlib-ready, you'd want to get rid of that \"non-terminal simp\". I replaced <code>simp</code> with <code>squeeze_simp</code> to get a suggestion:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">begin</span>\n  <span class=\"n\">ext1</span> <span class=\"o\">⟨</span><span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">g_comm</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">of_ends_for</span><span class=\"o\">,</span> <span class=\"n\">to_ends_for</span><span class=\"o\">,</span> <span class=\"n\">comp_app</span><span class=\"o\">,</span> <span class=\"n\">id.def</span><span class=\"o\">,</span> <span class=\"n\">subtype.mk_eq_mk</span><span class=\"o\">],</span>\n  <span class=\"n\">ext1</span> <span class=\"n\">F</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">g_comm</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 276014897,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1647848753
    },
    {
        "content": "<p>non-terminal simp means a simp which uses unknown assumptions?</p>",
        "id": 276014961,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1647848787
    },
    {
        "content": "<p>And both directions (<code>to_of</code> and <code>of_to</code>) work with the same proof, perfect!</p>",
        "id": 276015028,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1647848843
    },
    {
        "content": "<p>That, and also it's not the last tactic in a block. To make mathlib easier to maintain, every time you use <code>simp</code> you need to either use <code>simp only</code> or make it clear what it's supposed to simp into.</p>",
        "id": 276015107,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1647848890
    },
    {
        "content": "<p>This way, if someone adds or removes a <code>simp</code> lemma, in the first case it won't break your proof, and in the second they'll have an easier time fixing your proof.</p>",
        "id": 276015140,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1647848931
    },
    {
        "content": "<p>That makes sense, OK</p>",
        "id": 276015308,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1647849090
    },
    {
        "content": "<p>You'll probably find an application version of this lemma to be more useful, so you probably should factor it out:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[simp]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">to_of_ends_for_apply</span>  <span class=\"o\">(</span><span class=\"n\">ℱ</span> <span class=\"bp\">⊆</span> <span class=\"n\">finsubsets</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ℱ_cofin</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"n\">finsubsets</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">ℱ</span><span class=\"o\">,</span> <span class=\"n\">K.val</span> <span class=\"bp\">⊆</span> <span class=\"n\">F.val</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">ends_for</span> <span class=\"n\">ℱ</span> <span class=\"n\">H</span> <span class=\"n\">ℱ_cofin</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">to_ends_for</span> <span class=\"n\">ℱ</span> <span class=\"n\">H</span> <span class=\"n\">ℱ_cofin</span> <span class=\"o\">(</span><span class=\"n\">of_ends_for</span> <span class=\"n\">ℱ</span> <span class=\"n\">H</span> <span class=\"n\">ℱ_cofin</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">e</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">g_comm</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">e</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">of_ends_for</span><span class=\"o\">,</span> <span class=\"n\">to_ends_for</span><span class=\"o\">,</span> <span class=\"n\">comp_app</span><span class=\"o\">,</span> <span class=\"n\">id.def</span><span class=\"o\">,</span> <span class=\"n\">subtype.mk_eq_mk</span><span class=\"o\">],</span>\n  <span class=\"n\">ext1</span> <span class=\"n\">F</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">g_comm</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">to_of_ends_for_is_id</span>  <span class=\"o\">(</span><span class=\"n\">ℱ</span> <span class=\"bp\">⊆</span> <span class=\"n\">finsubsets</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ℱ_cofin</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"n\">finsubsets</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">ℱ</span><span class=\"o\">,</span> <span class=\"n\">K.val</span> <span class=\"bp\">⊆</span> <span class=\"n\">F.val</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">to_ends_for</span> <span class=\"n\">ℱ</span> <span class=\"n\">H</span> <span class=\"n\">ℱ_cofin</span><span class=\"o\">)</span> <span class=\"bp\">∘</span> <span class=\"o\">(</span><span class=\"n\">of_ends_for</span> <span class=\"n\">ℱ</span> <span class=\"n\">H</span> <span class=\"n\">ℱ_cofin</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">id</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">ext1</span> <span class=\"n\">e</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 276015520,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1647849259
    },
    {
        "content": "<p>But then again, even better would be to package these up using <a href=\"https://leanprover-community.github.io/mathlib_docs/find/equiv\">docs#equiv</a> so you get these sorts of lemmas \"for free\".</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">to_ends_for'</span> <span class=\"o\">(</span><span class=\"n\">ℱ</span> <span class=\"bp\">⊆</span> <span class=\"n\">finsubsets</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ℱ_cofin</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"n\">finsubsets</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">ℱ</span><span class=\"o\">,</span> <span class=\"n\">K.val</span> <span class=\"bp\">⊆</span> <span class=\"n\">F.val</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">ends</span> <span class=\"bp\">≃</span> <span class=\"n\">ends_for</span> <span class=\"n\">ℱ</span> <span class=\"n\">H</span> <span class=\"n\">ℱ_cofin</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"n\">to_ends_for</span> <span class=\"n\">ℱ</span> <span class=\"n\">H</span> <span class=\"n\">ℱ_cofin</span><span class=\"o\">,</span>\n  <span class=\"n\">inv_fun</span> <span class=\"o\">:=</span> <span class=\"n\">of_ends_for</span> <span class=\"n\">ℱ</span> <span class=\"n\">H</span> <span class=\"n\">ℱ_cofin</span><span class=\"o\">,</span>\n  <span class=\"n\">left_inv</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">g_comm</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">of_ends_for</span><span class=\"o\">,</span> <span class=\"n\">to_ends_for</span><span class=\"o\">,</span> <span class=\"n\">comp_app</span><span class=\"o\">,</span> <span class=\"n\">id.def</span><span class=\"o\">,</span> <span class=\"n\">subtype.mk_eq_mk</span><span class=\"o\">],</span>\n    <span class=\"n\">ext1</span> <span class=\"n\">F</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">g_comm</span><span class=\"o\">,</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">right_inv</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">g_comm</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">of_ends_for</span><span class=\"o\">,</span> <span class=\"n\">to_ends_for</span><span class=\"o\">,</span> <span class=\"n\">comp_app</span><span class=\"o\">,</span> <span class=\"n\">id.def</span><span class=\"o\">,</span> <span class=\"n\">subtype.mk_eq_mk</span><span class=\"o\">],</span>\n    <span class=\"n\">ext1</span> <span class=\"n\">F</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">g_comm</span><span class=\"o\">,</span>\n  <span class=\"kd\">end</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 276015821,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1647849528
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/252551-graph-theory/topic/Defining.20the.20ends/near/276013153\">said</a>:</p>\n<blockquote>\n<p>There's another PR for connected components in the works (<a href=\"https://github.com/leanprover-community/mathlib/pull/12766\">#12766</a>, <span class=\"user-mention silent\" data-user-id=\"246273\">Bhavik Mehta</span> and I were just trying to decide how to set it up) and it would be nice to have a followup PR about functoriality properties. I think <span class=\"user-mention silent\" data-user-id=\"133584\">Joseph Hua</span> was working on induced subgraphs. We will also have a way to map walks from a subgraph to a supergraph (I was planning on getting to that eventually). Once all that is in, then one way to organize a formalization of ends is in terms of the limit of connected components of induced subgraphs of cofinite vertex sets in a fairly direct way.</p>\n<p>That all said, it's probably better not to wait -- your being the vanguard is helpful to see what's missing and to see what kinds of theorems the library should support. I like to avoid PRing definitions unless they've proven themselves in theorems.</p>\n</blockquote>\n<p>About this. Can you ping me as soon as the necessary definitions for this approach are there, so that I can migrate when that makes sense?</p>",
        "id": 276015860,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1647849574
    },
    {
        "content": "<p>lol, if each of your new message results in a new piece of code like that, I'll have a fully fledged formalization by noon :)</p>",
        "id": 276016002,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1647849640
    },
    {
        "content": "<p>(I did have <code>equiv</code> in mind, but thought the two composites being the identity was somewhat of a necessary intermediary step anyway)</p>",
        "id": 276016031,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1647849685
    },
    {
        "content": "<p>Btw, I was wondering if some kind of \"inductive equational\" definition for the ends of a graph as</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">Ends</span><span class=\"o\">(</span><span class=\"bp\">\\</span><span class=\"n\">emptyset</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">\\</span><span class=\"n\">emptyset</span>\n  <span class=\"bp\">\\</span><span class=\"k\">forall</span> <span class=\"n\">K</span> <span class=\"n\">finite</span><span class=\"o\">,</span> <span class=\"bp\">\\</span><span class=\"n\">Ends</span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">\\</span><span class=\"n\">bigsqcup_</span><span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">components</span> <span class=\"n\">of</span> <span class=\"n\">X</span><span class=\"bp\">-</span><span class=\"n\">K</span><span class=\"o\">}</span> <span class=\"bp\">\\</span><span class=\"n\">Ends</span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>could make sense. This specific definition doesn't work since setting <code>Ends(X) = \\emptyset</code> for all <code>X</code> is a solution.</p>",
        "id": 276022653,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1647854064
    },
    {
        "content": "<p>Great news: the empty set has no ends:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">ends_empty_graph</span> <span class=\"o\">:</span> <span class=\"n\">is_empty</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">is_empty</span> <span class=\"o\">(</span><span class=\"n\">ends</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rintros</span> <span class=\"o\">⟨</span><span class=\"n\">no_V</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">is_empty.mk</span><span class=\"o\">,</span>\n  <span class=\"n\">rintros</span> <span class=\"o\">⟨</span><span class=\"n\">f</span><span class=\"o\">,</span><span class=\"n\">f_comm</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">f</span> <span class=\"o\">⟨</span><span class=\"bp\">∅</span><span class=\"o\">,</span><span class=\"n\">set.finite_empty</span><span class=\"o\">⟩</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,⟨</span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"n\">_</span><span class=\"o\">⟩,</span><span class=\"n\">is_inf</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">no_V</span> <span class=\"n\">b</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 276027659,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1647856883
    },
    {
        "content": "<p>Thinking about it some more, proving that <code>ends X = \\bigsqcup_{C : components of X-K} ends C</code>is going to require some back and forth and glue code for induced subgraphs, using the plain approach I chose, while the <code>pi₀</code> one is probably going to make it almost trivial.</p>",
        "id": 276030864,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1647858870
    },
    {
        "content": "<p>Hey, we (<span class=\"user-mention\" data-user-id=\"303675\">@Anand Rao</span>  and I) have refactored our definition of ends, and I've whipped up a PR <a href=\"https://github.com/leanprover-community/mathlib/pull/17857\">here</a>. Would very much welcome opinions on whether this is an agreeable formulation.</p>\n<p>The idea, instead of formalizing everything up to Freudenthal-Hopf, and then being hopeless to ever get  all of it in mathlib (which was the strategy until now), is to instead just make minimal PRs merged as soon as possible: this seems to work better in my limited experience.</p>",
        "id": 314674874,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1670505834
    }
]
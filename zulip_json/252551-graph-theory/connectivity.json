[
    {
        "content": "<p>Hi all, I'm thinking of doing some work on the graph theory library. Particularly I want to show that (vertex)-connectivity is less than or equal to edge-connectivity. I expected to find a definition for vertex-connectivity / k-connectivity  in <code>combinatorics/simple_graph/connectivity</code>, but it seems that its work in progress. Do people have a particular plan in mind that I can flesh out?</p>",
        "id": 272408682,
        "sender_full_name": "Joseph Hua",
        "timestamp": 1645194874
    },
    {
        "content": "<p>Hi, good timing :-) as a matter of fact I recently spent a lot of time formalizing Menger's theorem, and the proof first typechecked about an hour ago, but there is a huge amount of cleaning-up to be done. In particular, a nice definition of k-connectivity would be very useful.</p>",
        "id": 272410612,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1645195909
    },
    {
        "content": "<p>I've been (slowly) adding things from a branch about connectivity. <a href=\"https://github.com/leanprover-community/mathlib/pull/8737\">#8737</a></p>",
        "id": 272410852,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1645196012
    },
    {
        "content": "<p>The simplest basic version of connectivity would be</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">linked</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">relation.refl_trans_gen</span> <span class=\"n\">G.adj</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">connected</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">linked</span> <span class=\"n\">G</span> <span class=\"n\">x</span> <span class=\"n\">y</span>\n</code></pre></div>\n<p>plus a lemma like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">linked_iff</span> <span class=\"o\">:</span> <span class=\"n\">linked</span> <span class=\"n\">G</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">&lt;-&gt;</span> <span class=\"n\">nonempty</span> <span class=\"o\">(</span><span class=\"n\">walk</span> <span class=\"n\">G</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 272410861,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1645196016
    },
    {
        "content": "<p>This is the part most recently added: <a href=\"https://github.com/leanprover-community/mathlib/pull/11095\">#11095</a></p>",
        "id": 272410948,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1645196045
    },
    {
        "content": "<p><code>connected</code>: <a href=\"https://github.com/leanprover-community/mathlib/blob/8a46ed85b34a68d10b4f519416d11eb800b9dd28/src/combinatorics/simple_graph/connectivity.lean#L472\">https://github.com/leanprover-community/mathlib/blob/8a46ed85b34a68d10b4f519416d11eb800b9dd28/src/combinatorics/simple_graph/connectivity.lean#L472</a></p>\n<p>edge connectivity: <a href=\"https://github.com/leanprover-community/mathlib/blob/8a46ed85b34a68d10b4f519416d11eb800b9dd28/src/combinatorics/simple_graph/connectivity.lean#L491\">https://github.com/leanprover-community/mathlib/blob/8a46ed85b34a68d10b4f519416d11eb800b9dd28/src/combinatorics/simple_graph/connectivity.lean#L491</a><br>\n(this needs to be modified)</p>",
        "id": 272411135,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1645196136
    },
    {
        "content": "<p>Some of those constructions (especially <code>take_until</code> and <code>drop_until</code>) taste much better with a sigma type for paths, especially when you want to generalize to the first hitting point of a subset</p>",
        "id": 272411993,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1645196524
    },
    {
        "content": "<p>So I ended up building a lot of lemmas around such a sigma type, in a way that feels very sub-optimal ... In particular, I could not find a way to prevent <code>heq</code> from popping up all over the place (especially when using <code>ext</code>), so I ended up encapsulating <code>rec</code> from <code>walk</code> and using that to reprove many basic things.</p>",
        "id": 272413169,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1645197067
    },
    {
        "content": "<p>Nice! Thank you both for this. <span class=\"user-mention\" data-user-id=\"242586\">@Vincent Beffara</span> what kind of results would you be interested in having? <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> I'll probably try to build on this branch of mathlib</p>",
        "id": 272413566,
        "sender_full_name": "Joseph Hua",
        "timestamp": 1645197277
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"242586\">Vincent Beffara</span> <a href=\"#narrow/stream/252551-graph-theory/topic/connectivity/near/272411993\">said</a>:</p>\n<blockquote>\n<p>Some of those constructions (especially <code>take_until</code> and <code>drop_until</code>) taste much better with a sigma type for paths, especially when you want to generalize to the first hitting point of a subset</p>\n</blockquote>\n<p>what do you mean by \"hitting point\"?</p>",
        "id": 272413601,
        "sender_full_name": "Joseph Hua",
        "timestamp": 1645197303
    },
    {
        "content": "<p>This branch has unfortunately diverged from mathlib... I'm going to try getting the next batch of it into a PR the next couple days, though.</p>",
        "id": 272413701,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1645197362
    },
    {
        "content": "<p>I still think that walks are just list.chain over the sequence of vertices. And drop and take should use list API.</p>",
        "id": 272413778,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1645197394
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"242586\">@Vincent Beffara</span> I've not needed <code>heq</code> with theorems about trees being loopless connected graphs. I'd like to see what's happening with what you're doing at some point</p>",
        "id": 272413877,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1645197455
    },
    {
        "content": "<p>Maybe there's something missing from the library that would make everything nicer for you without all that extra work</p>",
        "id": 272413961,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1645197486
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133584\">Joseph Hua</span> <a href=\"#narrow/stream/252551-graph-theory/topic/connectivity/near/272413601\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"242586\">Vincent Beffara</span> <a href=\"#narrow/stream/252551-graph-theory/topic/connectivity/near/272411993\">said</a>:</p>\n<blockquote>\n<p>Some of those constructions (especially <code>take_until</code> and <code>drop_until</code>) taste much better with a sigma type for paths, especially when you want to generalize to the first hitting point of a subset</p>\n</blockquote>\n<p>what do you mean by \"hitting point\"?</p>\n</blockquote>\n<p>I mean, you take a walk <code>p</code> and a subset <code>X</code> of <code>V</code> with the assumption that <code>X \\cap p.support</code> is not empty, and you get the prefix of <code>p</code> until its first vertex that belongs to <code>X</code></p>",
        "id": 272414272,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1645197615
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"308899\">@Yakov Pechersky</span> I'm going to assume you think this until you say otherwise</p>",
        "id": 272414278,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1645197618
    },
    {
        "content": "<p>Ha! Good point.</p>",
        "id": 272414330,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1645197643
    },
    {
        "content": "<p>Whether or not it's implemented that way, I do draw inspiration from the list API in thinking about the API of finite ordered subsequences</p>",
        "id": 272414540,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1645197724
    },
    {
        "content": "<p>Not trying to bikeshed, but give color for Joseph's question.</p>",
        "id": 272414670,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1645197794
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/252551-graph-theory/topic/connectivity/near/272413877\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"242586\">Vincent Beffara</span> I've not needed <code>heq</code> with theorems about trees being loopless connected graphs. I'd like to see what's happening with what you're doing at some point</p>\n</blockquote>\n<p>Specifically: I define the pushforward and pullback of graphs and want that the pushforward of the pullback of a walk is the walk you started from. With sigma types it is just a version of <code>left_inverse</code>, with <code>G.walk a b</code> it is complicated to state so I gave up. But then in the proof, showing that the equality between sigma types holds, a natural step would be to say <code>ext</code> but then the issue pops up again because it turns equality of the sigma type members into <code>heq</code> of the <code>walk</code> members.</p>",
        "id": 272414847,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1645197895
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"308899\">@Yakov Pechersky</span>  Something I've imagined is having a <code>list.chain</code> interface on top so that you can manipulate things freely without all the dependent type constraints. The type constraints are useful for a lot of things, I've found, so I wouldn't want to lose that in general.</p>",
        "id": 272414926,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1645197946
    },
    {
        "content": "<p>For the heq stuff, you might get away with a helper lemma that uses the forgetfulness into just the underlying list of vertices, without the adjacency constraints.</p>",
        "id": 272415105,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1645198016
    },
    {
        "content": "<p>If two walks have pointwise exactly the same underlying sequence of vertices, then they must be equal (on a simple graph)</p>",
        "id": 272415168,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1645198055
    },
    {
        "content": "<p>Yes, that's certainly an option (and with the current API, that would mean using <code>walk.support</code> to get the list of vertices, but then one needs to take care of propagating the <code>list.chain</code> part, IIUC).</p>",
        "id": 272415431,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1645198170
    },
    {
        "content": "<p>The point I'm making about equality of walks is that it means equality of supports, so you lose needing to talk about the chain aspect</p>",
        "id": 272415914,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1645198433
    },
    {
        "content": "<p>Because whether or not they're \"chain\", iff the supports aren't equal, the walks aren't.</p>",
        "id": 272416002,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1645198465
    },
    {
        "content": "<p>Sure, I get that. I'm more worried about having some constructions ending up as a convoluted construction of a list of vertices, and then a proof that the list is a walk (which would look very much like the construction itself).</p>",
        "id": 272416290,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1645198617
    },
    {
        "content": "<p>Would it make sense to have two definitions, the current inductive one and another one based on lists of vertices, with a nice isomorphism between <code>G.walk a b</code> and <code>{p : chainy_walk G // p.start = a \\and p.end = b}</code> or is it looking for trouble?</p>",
        "id": 272416576,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1645198751
    },
    {
        "content": "<p>Then I didn't understand the use cases. Are you constructing walks or are proving two constructed walks are equal?</p>",
        "id": 272416599,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1645198763
    },
    {
        "content": "<p>Probably constructing the actual walk should be made relevant instead of going through the equiv to the subtype</p>",
        "id": 272416698,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1645198804
    },
    {
        "content": "<p>I do both, I constructed a walk and I wanted to show that it was equal to another one but in a situation where the equality of the endpoints was not defeq.</p>",
        "id": 272416802,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1645198866
    },
    {
        "content": "<p>Why would you want an equality between two graphs as oppose to an equivalence?</p>",
        "id": 272417077,
        "sender_full_name": "Joseph Hua",
        "timestamp": 1645198991
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"242586\">@Vincent Beffara</span> When you say the endpoints weren't defeq, were you able to do a rewrite to make the endpoints coincide? That usually works in some way to avoid heq</p>",
        "id": 272417280,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1645199067
    },
    {
        "content": "<p>I would need to fish around for a mwe because I ended up using my ad-hoc sigma type anyway, but it was something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">lift_path</span> <span class=\"o\">:</span> <span class=\"n\">walk</span> <span class=\"o\">(</span><span class=\"n\">push</span> <span class=\"n\">f</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"n\">x'</span> <span class=\"n\">y'</span> <span class=\"bp\">→</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">x'</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">y'</span> <span class=\"bp\">→</span> <span class=\"n\">walk</span> <span class=\"n\">G</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">def</span> <span class=\"n\">push_path</span> <span class=\"o\">:</span> <span class=\"n\">walk</span> <span class=\"n\">G</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">walk</span> <span class=\"o\">(</span><span class=\"n\">push</span> <span class=\"n\">f</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">walk</span> <span class=\"o\">(</span><span class=\"n\">push</span> <span class=\"n\">f</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"n\">x'</span> <span class=\"n\">y'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">x'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hy</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">y'</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">push_path</span> <span class=\"o\">(</span><span class=\"n\">lift_path</span> <span class=\"n\">p</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">hx</span> <span class=\"n\">hy</span><span class=\"o\">)</span> <span class=\"bp\">==</span> <span class=\"n\">p</span>\n</code></pre></div>\n<p>where the left-hand is a <code>G.walk (f x) (f y)</code> and the left-hand is a <code>G.walk x' y'</code>. I couldn't find a way to state the identity without either a <code>heq</code> or sigma type.</p>",
        "id": 272418296,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1645199529
    },
    {
        "content": "<p>In retrospect, my impression is that if walks had been defined from the start as lists with conditions, my life would have been easier at a few places. But that probably says more about my still limited lean abilities than about the <code>simple_graph</code> API.</p>\n<p>Anyway, my code is here, <a href=\"https://github.com/vbeffara/lean/blob/main/src/graph_theory/menger.lean\">https://github.com/vbeffara/lean/blob/main/src/graph_theory/menger.lean</a> and I would be very glad to get some comments (although there are many places where I already see changes to be made). <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> I will look around in your branch for things that I can use :-)</p>",
        "id": 272419624,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1645200126
    },
    {
        "content": "<p>Thanks, I'll take a look later. (It's good to hear what you're running into -- you're bound to have come up against limitations, and from what you've said so far there must be missing things, just not sure what yet.)</p>",
        "id": 272420243,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1645200433
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133584\">Joseph Hua</span> <a href=\"#narrow/stream/252551-graph-theory/topic/connectivity/near/272408682\">said</a>:</p>\n<blockquote>\n<p>vertex-connectivity</p>\n</blockquote>\n<p>I'm not sure what the best way is for this yet... One idea I'd considered is defining the removal of a subset of vertices from a <a href=\"https://leanprover-community.github.io/mathlib_docs/find/simple_graph.subgraph\">docs#simple_graph.subgraph</a> and then using connectedness of the subgraph coerced to a graph (<a href=\"https://leanprover-community.github.io/mathlib_docs/find/simple_graph.spanning_coe\">docs#simple_graph.spanning_coe</a>), but I'm not too keen on the fact the vertex types will be subtypes, but maybe that's just because we haven't built up ways to move walks back and forth from a subgraph yet.</p>",
        "id": 272420964,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1645200736
    },
    {
        "content": "<p>Did you have some theorem in mind when you asked about that?</p>",
        "id": 272421024,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1645200767
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/252551-graph-theory/topic/connectivity/near/272420243\">said</a>:</p>\n<blockquote>\n<p>Thanks, I'll take a look later. (It's good to hear what you're running into -- you're bound to have come up against limitations, and from what you've said so far there must be missing things, just not sure what yet.)</p>\n</blockquote>\n<p>One thing that I found useful was a type for walk steps (i.e. ordered pairs of adjacent vertices) as opposed to a type <code>sym2 V</code> for edges, in general I found that working with <code>G.edges</code> was not very pleasant. I was probably holding them wrong.</p>",
        "id": 272421554,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1645200973
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/252551-graph-theory/topic/connectivity/near/272421024\">said</a>:</p>\n<blockquote>\n<p>Did you have some theorem in mind when you asked about that?</p>\n</blockquote>\n<p>Yes, I was going to \"do my graph theory coursework properly\" by proving that <code>k-vertex-connectivity -&gt; k-edge-connectivity</code> I feel like taking the induced subgraph of a set of vertices is the right way to talk about k-vertex connectivity.  Alternatively maybe \"walks in the ambient graph that don't enter a subset\" could generalize the current definition of walks, though I feel like this is not as clean as making an API for the first option</p>",
        "id": 272422118,
        "sender_full_name": "Joseph Hua",
        "timestamp": 1645201226
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"133584\">@Joseph Hua</span> All we have right now regarding induced graphs is the predicate <a href=\"https://leanprover-community.github.io/mathlib_docs/find/simple_graph.subgraph.is_induced\">docs#simple_graph.subgraph.is_induced</a>. It would be great to have subgraphs induced by a vertex set</p>",
        "id": 272422404,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1645201394
    },
    {
        "content": "<p>and basic things surrounding that, like that if <code>A subset B</code> then <code>G.induced A &lt;= G.induced B</code>.</p>",
        "id": 272422519,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1645201452
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">induced_subgraph</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">G.subgraph</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">verts</span> <span class=\"o\">:=</span> <span class=\"n\">s</span><span class=\"o\">,</span>\n  <span class=\"n\">adj</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">G.adj</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"bp\">∧</span> <span class=\"n\">u</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">∧</span> <span class=\"n\">v</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">,</span>\n  <span class=\"n\">adj_sub</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">obviously</span><span class=\"o\">,</span>\n  <span class=\"n\">edge_vert</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">obviously</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">delete_vertices</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">G.subgraph</span> <span class=\"o\">:=</span>\n<span class=\"n\">induced_subgraph</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"bp\">ᶜ</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- A graph is *k-vertex-connected* if it remains connected whenever</span>\n<span class=\"sd\">fewer than k vertices are removed. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">vertex_connected</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">V</span><span class=\"o\">),</span> <span class=\"n\">s.card</span> <span class=\"bp\">&lt;</span> <span class=\"n\">k</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">G.delete_vertices</span> <span class=\"n\">s</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">connected</span>\n</code></pre></div>",
        "id": 272422561,
        "sender_full_name": "Joseph Hua",
        "timestamp": 1645201480
    },
    {
        "content": "<p>A design question: when inducing a subgraph, do we think we will do induced subgraphs of subgraphs, too? or  for applications would it be sufficient to have <code>simple_graph.induced</code>?</p>",
        "id": 272422586,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1645201496
    },
    {
        "content": "<p>(one answer is: that's sufficient for now, and we can revisit it later)</p>",
        "id": 272422628,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1645201522
    },
    {
        "content": "<p>The induced subgraph also defines an embedding into the original graph, and every embedding is onto an induced subgraph, I believe.</p>",
        "id": 272422788,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1645201604
    },
    {
        "content": "<p>In your definition of <code>adj</code>, there might be pre-existing definitions in the relations part of mathlib to restrict a relation to a set, which we should find.</p>",
        "id": 272422870,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1645201676
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/252551-graph-theory/topic/connectivity/near/272422586\">said</a>:</p>\n<blockquote>\n<p>A design question: when inducing a subgraph, do we think we will do induced subgraphs of subgraphs, too? or  for applications would it be sufficient to have <code>simple_graph.induced</code>?</p>\n</blockquote>\n<p>Yeah, I think I should generalize the above and the definition of <code>delete_edges</code> to take in a subgraph first</p>",
        "id": 272422873,
        "sender_full_name": "Joseph Hua",
        "timestamp": 1645201680
    },
    {
        "content": "<p>How about</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code> <span class=\"kd\">def</span> <span class=\"n\">pullback</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">V'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">G'</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V'</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">adj</span> <span class=\"o\">:=</span> <span class=\"n\">G'.adj</span> <span class=\"n\">on</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n  <span class=\"n\">symm</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">G'.symm</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">loopless</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">G'.loopless</span> <span class=\"n\">_</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>and <code>def induced (s : set V) (G : simple_graph V) : simple_graph s := pullback coe G</code>?</p>",
        "id": 272423054,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1645201782
    },
    {
        "content": "<p>Or do we really need the subgraph as a subgraph rather than as a graph with an embedding?</p>",
        "id": 272423170,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1645201820
    },
    {
        "content": "<p>Regarding where to put <code>induced</code>: I suppose we can always take the induced graph from the Top subgraph, and then define an abbreviation <code>simple_graph.induced</code> to do this</p>",
        "id": 272423181,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1645201827
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/252551-graph-theory/topic/connectivity/near/272423181\">said</a>:</p>\n<blockquote>\n<p>Regarding where to put <code>induced</code>: I suppose we can always take the induced graph from the Top subgraph, and then define an abbreviation <code>simple_graph.induced</code> to do this</p>\n</blockquote>\n<p><del>what do you mean by this? Doesn't <code>Top</code> just give the original graph back?</del><br>\nI see, you're making the version of <code>induced</code> that I gave using our generalization</p>",
        "id": 272423924,
        "sender_full_name": "Joseph Hua",
        "timestamp": 1645202196
    },
    {
        "content": "<p><code>(top : G.subgraph).induced s</code></p>",
        "id": 272424238,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1645202351
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"242586\">Vincent Beffara</span> <a href=\"#narrow/stream/252551-graph-theory/topic/connectivity/near/272423170\">said</a>:</p>\n<blockquote>\n<p>Or do we really need the subgraph as a subgraph rather than as a graph with an embedding?</p>\n</blockquote>\n<p>I think we want a subgraph, I think embeddings could get messy once we need to do something like \"remove F a set of edges and U a set of vertices\" where F and U might not have anything to do with each other</p>",
        "id": 272424255,
        "sender_full_name": "Joseph Hua",
        "timestamp": 1645202362
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"242586\">Vincent Beffara</span> <a href=\"#narrow/stream/252551-graph-theory/topic/connectivity/near/272421554\">said</a>:</p>\n<blockquote>\n<p>One thing that I found useful was a type for walk steps (i.e. ordered pairs of adjacent vertices) as opposed to a type <code>sym2 V</code> for edges, in general I found that working with <code>G.edges</code> was not very pleasant.</p>\n</blockquote>\n<p>Do you know about <a href=\"https://leanprover-community.github.io/mathlib_docs/find/simple_graph.dart\">docs#simple_graph.dart</a>?</p>",
        "id": 272424545,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1645202497
    },
    {
        "content": "<p>It's nice having this <code>V</code> type to sort of cohere all the different subgraphs into being part of the same graph.  For example, you'd want the elements of <code>s</code> to somehow be vertices of the induced graph without too much fanfare</p>",
        "id": 272424555,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1645202502
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/252551-graph-theory/topic/connectivity/near/272424545\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"242586\">Vincent Beffara</span> <a href=\"#narrow/stream/252551-graph-theory/topic/connectivity/near/272421554\">said</a>:</p>\n<blockquote>\n<p>One thing that I found useful was a type for walk steps (i.e. ordered pairs of adjacent vertices) as opposed to a type <code>sym2 V</code> for edges, in general I found that working with <code>G.edges</code> was not very pleasant.</p>\n</blockquote>\n<p>Do you know about <a href=\"https://leanprover-community.github.io/mathlib_docs/find/simple_graph.dart\">docs#simple_graph.dart</a>?</p>\n</blockquote>\n<p>I do now :-)</p>",
        "id": 272424803,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1645202618
    },
    {
        "content": "<p>It seems like it would make a lot of sense to add <code>walk.darts</code> and make <code>walk.edges</code> be defined in terms of it.</p>",
        "id": 272425031,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1645202721
    },
    {
        "content": "<p>Should we be using lemmas for subsets and then translating the results to finsets? (I'm going to only work with finsets for k-connectivity)</p>",
        "id": 272426292,
        "sender_full_name": "Joseph Hua",
        "timestamp": 1645203273
    },
    {
        "content": "<p>if definitions and lemmas don't need finsets, I'd suggest sticking with sets</p>",
        "id": 272428835,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1645204292
    },
    {
        "content": "<p>BTW, saying that two walks visiting the same list of vertices are equal is something we want on simple graphs, but not necessarily on multigraphs or weighted graphs or whatever in the hierarchy</p>",
        "id": 272431668,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1645205711
    },
    {
        "content": "<p>walks &lt;-&gt; lists of darts should work in general</p>",
        "id": 272433302,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1645206465
    },
    {
        "content": "<p>Yes if you know the starting point</p>",
        "id": 272436990,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1645208005
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"242586\">Vincent Beffara</span> <a href=\"#narrow/stream/252551-graph-theory/topic/connectivity/near/272424803\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/252551-graph-theory/topic/connectivity/near/272424545\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"242586\">Vincent Beffara</span> <a href=\"#narrow/stream/252551-graph-theory/topic/connectivity/near/272421554\">said</a>:</p>\n<blockquote>\n<p>One thing that I found useful was a type for walk steps (i.e. ordered pairs of adjacent vertices) as opposed to a type <code>sym2 V</code> for edges, in general I found that working with <code>G.edges</code> was not very pleasant.</p>\n</blockquote>\n<p>Do you know about <a href=\"https://leanprover-community.github.io/mathlib_docs/find/simple_graph.dart\">docs#simple_graph.dart</a>?</p>\n</blockquote>\n<p>I do now :-)</p>\n</blockquote>\n<p>Hmm, it is in <code>degree_sum.lean</code> which is not intuitive, I would have expected to find such a definition in <code>basic.lean</code></p>",
        "id": 272467588,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1645223678
    },
    {
        "content": "<p>There are a few more slices of <a href=\"https://github.com/leanprover-community/mathlib/pull/8737\">#8737</a>, if anyone wants to take a look:</p>\n<ul>\n<li><a href=\"https://github.com/leanprover-community/mathlib/pull/13304\">#13304</a> that nth powers of the adjacency matrix count walks of length n</li>\n<li><a href=\"https://github.com/leanprover-community/mathlib/pull/13306\">#13306</a> for deleting edges from a <code>simple_graph.subgraph</code></li>\n<li><a href=\"https://github.com/leanprover-community/mathlib/pull/13310\">#13310</a> for pushing walks forward through a graph homomorphism</li>\n</ul>\n<p>There's also <a href=\"https://github.com/leanprover-community/mathlib/pull/12766\">#12766</a> (connected components), which I think <span class=\"user-mention\" data-user-id=\"246273\">@Bhavik Mehta</span> wanted to do something with.</p>",
        "id": 278484679,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1649617975
    },
    {
        "content": "<p>There's also now <a href=\"https://github.com/leanprover-community/mathlib/pull/17213\">#17213</a> for acyclic graphs and trees (so finally got around to the \"trees\" part of the \"<code>walks_and_trees</code>\" branch)</p>",
        "id": 306506741,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1666893616
    },
    {
        "content": "<p>I defined acyclicity in terms of nonexistence of cyclic walks, though in the future we can also have a theorem characterizing it in terms of the non-existence of cyclic subgraphs. Cyclic subgraphs haven't been defined yet, though I have a tentative definition in a branch somewhere (as a subgraph that has the same vertices and edges as a cyclic walk).</p>",
        "id": 306507741,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1666893890
    },
    {
        "content": "<p>Would \"a tree is a maximal connected graph on its support\" fit there too?</p>",
        "id": 306509347,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1666894374
    },
    {
        "content": "<p>Yeah, that would be a nice additional theorem in this module (though with \"minimal\" of course!)</p>",
        "id": 306509983,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1666894573
    },
    {
        "content": "<p>I suppose (using the PR theorem names) you could use <code>is_acyclic_iff_forall_is_bridge</code> to say every edge in a tree is a bridge, then use the definition of <code>is_bridge</code> itself, which is that removing it makes two vertices become unreachable from one another (hence the graph is not connected).</p>",
        "id": 306510308,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1666894694
    },
    {
        "content": "<p>So one direction is easily covered (looks like a fun exercise, I might give it a try!)</p>",
        "id": 306510415,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1666894741
    },
    {
        "content": "<p>Just for completeness, I'm imagining the formulation <code>G.is_tree &lt;-&gt; for all H &lt;= G, H.is_tree -&gt; H = G</code> (or however we're supposed to say something is minimal with some property)</p>",
        "id": 306510564,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1666894796
    },
    {
        "content": "<p>Yeah, please do!</p>",
        "id": 306510638,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1666894807
    },
    {
        "content": "<p>still wrong I believe? Or maybe we just don't have the same definition in mind? I was thinking of the \"maximal tree = minimal connected subgraph\" equivalence.<br>\nWhat about <br>\n<code>G.is_tree &lt;-&gt; G.connected /\\ for all H &lt;= G, H.connected /\\ H.verts = univ -&gt; H = G</code> ?</p>",
        "id": 306511167,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1666895005
    },
    {
        "content": "<p>We don't need <code>H.verts</code> since this is for <code>H : simple_graph V</code> such that <code>H &lt;= G</code>, which has the fact it's a spanning subgraph built in</p>",
        "id": 306511521,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1666895151
    },
    {
        "content": "<p>This is the somewhat awkward (but still often convenient) thing that there are two notions of subgraphs</p>",
        "id": 306511649,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1666895190
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span>  This seems great! I was working on something similar actually. I've defined the number of connected components (as the card of connected_components) and was showing that it either goes up by 0 or 1 when removing an edge. There is a good overlap with what you have done here. I would just suggest is_bridge, is_bridge_iff_forall_walk_mem_edges, is_bridge_iff_forall_cycle_not_mem.aux, is_bridge_iff_forall_cycle_not_mem be put in the main connectivity file maybe? As they are more related with connectivity than trees in my opinion, and because I would like to use them there.</p>",
        "id": 306516730,
        "sender_full_name": "Jérémie Turcotte",
        "timestamp": 1666896885
    },
    {
        "content": "<p>I also have one concern about your definition for bridge. Under your current definition, even non edges of G could be bridges, right? I would add G.adj u v (or something else equivalent) in the definition. Let me know what you think.</p>",
        "id": 306518769,
        "sender_full_name": "Jérémie Turcotte",
        "timestamp": 1666897594
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"507101\">@Jérémie Turcotte</span> Yes, I had it so that non-adjacent vertices could be considered to be bridge edges, since I had felt it simplified a number of statements, since otherwise you need to add conjunctions with <code>G.adj v w</code>.</p>\n<p>In any case, I've change the definition in <a href=\"https://github.com/leanprover-community/mathlib/pull/17213\">#17213</a> to one on <code>sym2 V</code>, using a <code>sym2</code> function that was introduced since I'd first written this (<a href=\"https://leanprover-community.github.io/mathlib_docs/find/sym2.lift\">docs#sym2.lift</a>).</p>",
        "id": 306671573,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1666967990
    },
    {
        "content": "<p>I've also moved <code>is_bridge</code> to connectivity.lean, but I do worry that the file is getting rather long!</p>",
        "id": 306673653,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1666968584
    },
    {
        "content": "<p>Couldn't the walk,paths,circuit stuff be moved to <code>walks.lean</code>, and then perhaps even splitthe part about subgraphs?</p>",
        "id": 306674285,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1666968766
    },
    {
        "content": "<p>Yes, that probably makes sense</p>",
        "id": 306675449,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1666969086
    },
    {
        "content": "<p>It might also make sense to have <code>walk_defs.lean</code> for just the definitions of all the functions, though some of the functions depend on a handful of lemmas in their definitions.</p>",
        "id": 306675728,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1666969179
    },
    {
        "content": "<p>I think it's better to keep lemmas and definitions together</p>",
        "id": 306685934,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1666971231
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span>  Great thanks! Once your changes are accepted and are on the main branch, I'll add my stuff as well on the number of connected components, since I've rewritten it some of it to use what you did.</p>",
        "id": 306718524,
        "sender_full_name": "Jérémie Turcotte",
        "timestamp": 1666980239
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"507101\">@Jérémie Turcotte</span> It's only clicking now, but what's your aim with your code? With <span class=\"user-mention\" data-user-id=\"303675\">@Anand Rao</span> we've been working on the construction of ends of a graph and hence have very similar code to \"removing an edge only increases the number of connected component\".</p>",
        "id": 306723999,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1666981970
    },
    {
        "content": "<p>I'm now wondering how best to use what mathlib provides for our purposes, and whether/how we could piggyback on your work (I mean, our code works already for this, but we didn't figure a very convincing way to define it in a way that could be upstreamed to mathlib)</p>",
        "id": 306724192,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1666982035
    },
    {
        "content": "<p>In a broad sense our aim is to add the contents of a standard introductory graph theory class to mathlib. For this question specifically, I defined the number of connected components (using fintype.card) with the aim of showing the standard equivalences between definitions of cut edges (or bridges), such as removing a cut edge increases the number of connected components by exactly 1, and for non cut edges by 0 (the latter by just showing it doesnt affect reachability). Then, using this we have a standard inductive proof that in a forest the number of edges is equal to the number of vertices minus the number of connected components. We are mostly concerned about finite graphs (or at least, graphs with a finite number of components), so I'm not sure if this can be useful for you given you are working with ends. Let me know what you think.</p>",
        "id": 306725855,
        "sender_full_name": "Jérémie Turcotte",
        "timestamp": 1666982571
    },
    {
        "content": "<p>Ah, indeed, your applications seem quite independent from ours, too bad! I'm still wondering about/hoping for some construct that we could commonly build upon, but it's probably useless.<br>\n<a href=\"https://github.com/bottine/mathlib/blob/89719db2bf26bf96d32db52156a44bde1b9b8866/src/combinatorics/simple_graph/ends/comp_out.lean#L40\">Here</a> is our code, by the way.</p>",
        "id": 306727026,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1666982981
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"507101\">@Jérémie Turcotte</span> In the <code>walks_and_trees</code> branch there's a proof of that result about finite trees (but not forests) using the uniqueness of paths property</p>",
        "id": 306727899,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1666983245
    },
    {
        "content": "<p>Nice to hear you have the more general version.</p>",
        "id": 306727903,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1666983248
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 306727904,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1666983248
    },
    {
        "content": "<p>Isn't connected components antitone from graphs to partitions?</p>",
        "id": 306733518,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1666985317
    },
    {
        "content": "<p>Yes (though set or subgraph partitions, not <a href=\"https://leanprover-community.github.io/mathlib_docs/find/simple_graph.partition\">docs#simple_graph.partition</a>), which is consistent with how cutting an edge can increase the number of connected components by one. This contravariance is used (or can be used) for the definition of ends of a graph.</p>\n<p>Btw, I have the partition of a graph into connected subgraphs <a href=\"https://github.com/leanprover-community/mathlib/blob/kmill_hamiltonian/src/hamiltonian.lean#L499\">here</a> in a rather disorganized branch, though it doesn't explicitly have the partition or the fact the map is antitone.</p>",
        "id": 306735945,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1666986269
    },
    {
        "content": "<p>Mmh, I tried <code>check</code>ing <code>out</code> your pull request to play with it but it makes codium/lean crash. Is there anything particular to it that may cause that?</p>",
        "id": 306791816,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1667024447
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> I'm giving this characterization of trees a go <a href=\"https://github.com/bottine/mathlib/blob/cfe88e2f7096c9ff37010c79d91338ca22724530/src/combinatorics/simple_graph/acyclic.lean#L138\">here</a> and have a few questions:</p>\n<ul>\n<li>There is <code>delete_edges</code> in the API, but no <code>add_edges</code>. Could we add such a construction?</li>\n<li>\n<p>There is <code>to_delete_edges</code> to map a walk avoiding the deleted edges to a walk in the resulting graph.<br>\n  At some point I wrote <a href=\"https://github.com/bottine/mathlib/blob/89719db2bf26bf96d32db52156a44bde1b9b8866/src/combinatorics/simple_graph/ends/for_mathlib/connected.lean#L206\">this</a> to deal with mapping paths to subgraphs. Would it make sense to port this code so that <code>to_delete_edges</code> is actually just a special case of mapping to a subgraph? In my code here I didn't really use <code>.edges</code>, but I think it should be easy to port it to this kind of formulation, say:<br>\n<code>\n  def map_induced (H ≤ G) (w : G.walk x y) (disjonit w.edges H.edge_set) : H.walk x y := sorry\n  </code></p>\n</li>\n<li>\n<p>Finally, would the statements as written in my stub fit or were you looking for something else?</p>\n</li>\n</ul>",
        "id": 306962334,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1667137898
    },
    {
        "content": "<p>Here is what I have in mind for mapping <code>walk</code>s between graphs:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">combinatorics.simple_graph.connectivity</span>\n<span class=\"kn\">import</span> <span class=\"n\">combinatorics.simple_graph.basic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">function</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">simple_graph</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span>\n\n\n<span class=\"kn\">namespace</span> <span class=\"n\">walk</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">cons_is_cycle_iff</span> <span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">G.walk</span> <span class=\"n\">v</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">G.adj</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">p.cons</span> <span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">is_cycle</span> <span class=\"bp\">↔</span> <span class=\"n\">p.is_path</span> <span class=\"bp\">∧</span> <span class=\"bp\">¬</span> <span class=\"bp\">⟦</span><span class=\"o\">(</span><span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">v</span><span class=\"o\">)</span><span class=\"bp\">⟧</span> <span class=\"bp\">∈</span> <span class=\"n\">p.edges</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">walk.is_cycle_def</span><span class=\"o\">,</span> <span class=\"n\">walk.cons_is_trail_iff</span><span class=\"o\">,</span> <span class=\"n\">ne.def</span><span class=\"o\">,</span> <span class=\"n\">not_false_iff</span><span class=\"o\">,</span> <span class=\"n\">walk.support_cons</span><span class=\"o\">,</span>\n               <span class=\"n\">list.tail_cons</span><span class=\"o\">,</span> <span class=\"n\">true_and</span><span class=\"o\">,</span> <span class=\"n\">simple_graph.walk.is_path_def</span><span class=\"o\">],</span>\n    <span class=\"n\">tauto</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"bp\">λ</span> <span class=\"o\">⟨</span><span class=\"n\">hp</span><span class=\"o\">,</span><span class=\"n\">he</span><span class=\"o\">⟩,</span> <span class=\"n\">path.cons_is_cycle</span> <span class=\"o\">(⟨</span><span class=\"n\">p</span><span class=\"o\">,</span><span class=\"n\">hp</span><span class=\"o\">⟩</span> <span class=\"o\">:</span> <span class=\"n\">G.path</span> <span class=\"n\">v</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"n\">h</span> <span class=\"n\">he</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">walk</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">walk</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">def</span> <span class=\"n\">induce</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">G.walk</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">e</span> <span class=\"bp\">∈</span> <span class=\"n\">p.edges</span> <span class=\"bp\">→</span> <span class=\"n\">e</span> <span class=\"bp\">∈</span> <span class=\"n\">H.edge_set</span><span class=\"o\">),</span> <span class=\"n\">H.walk</span> <span class=\"n\">u</span> <span class=\"n\">v</span>\n<span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">walk.nil</span><span class=\"o\">)</span> <span class=\"n\">H</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"n\">walk.nil</span>\n<span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">walk.cons</span> <span class=\"n\">a</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"n\">H</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"o\">{</span> <span class=\"n\">refine</span> <span class=\"n\">walk.cons</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">p.induce</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">;</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">walk.edges_cons</span><span class=\"o\">,</span> <span class=\"n\">list.mem_cons_iff</span><span class=\"o\">,</span> <span class=\"n\">forall_eq_or_imp</span><span class=\"o\">,</span> <span class=\"n\">mem_edge_set</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">h.1</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">h.2</span><span class=\"o\">,</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">G.walk</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">G.walk</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">)</span>\n  <span class=\"o\">{</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">e</span> <span class=\"bp\">∈</span> <span class=\"n\">p.edges</span> <span class=\"bp\">→</span> <span class=\"n\">e</span> <span class=\"bp\">∈</span> <span class=\"n\">H.edge_set</span><span class=\"o\">)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">induce_id</span> <span class=\"o\">:</span> <span class=\"n\">p.induce</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">e</span> <span class=\"n\">ep</span><span class=\"o\">,</span> <span class=\"n\">edges_subset_edge_set</span> <span class=\"n\">p</span> <span class=\"n\">ep</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n<span class=\"o\">{</span> <span class=\"n\">induction</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">p_ih</span><span class=\"o\">],</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">induce_eq_map_spanning_subgraphs</span> <span class=\"o\">(</span><span class=\"n\">GH</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">≤</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">p.induce</span> <span class=\"n\">h</span> <span class=\"bp\">=</span> <span class=\"n\">p.map</span> <span class=\"o\">(</span><span class=\"n\">simple_graph.hom.map_spanning_subgraphs</span> <span class=\"n\">GH</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n<span class=\"o\">{</span> <span class=\"n\">induction</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">p_ih</span><span class=\"o\">],</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">induce_edges</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">p.induce</span> <span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">edges</span> <span class=\"bp\">=</span> <span class=\"n\">p.edges</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n<span class=\"o\">{</span> <span class=\"n\">induction</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">p_ih</span><span class=\"o\">],</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">induce_support</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">p.induce</span> <span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">support</span> <span class=\"bp\">=</span> <span class=\"n\">p.support</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n<span class=\"o\">{</span> <span class=\"n\">induction</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">p_ih</span><span class=\"o\">],</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">is_path_induce</span> <span class=\"o\">(</span><span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"n\">p.is_path</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">p.induce</span> <span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">is_path</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n<span class=\"o\">{</span> <span class=\"n\">induction</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">cons_is_path_iff</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hp</span> <span class=\"bp\">⊢</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">p_ih</span><span class=\"o\">,</span> <span class=\"n\">hp</span><span class=\"o\">],</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">is_cycle_induce</span> <span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">G.walk</span> <span class=\"n\">u</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">e</span> <span class=\"bp\">∈</span> <span class=\"n\">p.edges</span> <span class=\"bp\">→</span> <span class=\"n\">e</span> <span class=\"bp\">∈</span> <span class=\"n\">H.edge_set</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"n\">p.is_cycle</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">p.induce</span> <span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">is_cycle</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n<span class=\"o\">{</span> <span class=\"n\">cases</span> <span class=\"n\">p</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">hp</span> <span class=\"bp\">⊢</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">hp</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">cons_is_cycle_iff</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hp</span> <span class=\"bp\">⊢</span><span class=\"o\">,</span>\n    <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span><span class=\"n\">hp.right</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">is_path_induce</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">hp.left</span><span class=\"o\">,</span> <span class=\"o\">},</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">walk</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">simple_graph</span>\n</code></pre></div>",
        "id": 307045101,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1667199463
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"461830\">@Rémi Bottinelli</span> Some thoughts on PRs</p>\n<p>For <a href=\"https://github.com/bottine/mathlib/blob/bottine/trees_min_max/src/combinatorics/simple_graph/acyclic.lean\">this one</a>:</p>\n<ul>\n<li>\n<p>It would be great to have <code>is_acyclic.le</code> and <code>connected.le</code> (that could be a short PR). You might swap the <code>H ≤ G</code> with the property argument so that it's clearer to see how they're functorial (dot notation will still work), and I think Yael would suggest calling them <code>is_acyclic.anti</code> and <code>connected.mono</code>.</p>\n</li>\n<li>\n<p>The rest of the theorem statements look like something we would want too. I'm wondering if we want something more general, where rather than <code>min_connected</code> it's a predicate that means the subgraph's inclusion map induces a bijection on pi_1. That way <code>min_whatever_its_called</code> is equivalent to having an acyclic spanning subgraph.</p>\n</li>\n</ul>\n<p>Regarding <a href=\"https://github.com/bottine/mathlib/blob/89719db2bf26bf96d32db52156a44bde1b9b8866/src/combinatorics/simple_graph/ends/for_mathlib/connected.lean#L206\">mapping to subgraphs</a>, I think your idea to change <code>to_delete_edges</code> to be a special case is a good one. I have a bit of a different definition somewhere for a path being contained in a subgraph that I think would fit into existing API better (that <code>p.to_subgraph ≤ H</code>, where <code>to_subgraph</code> gives the subgraph with the same vertices and edges), and maybe I'll dust that off and merge in some of what you have in that file?</p>",
        "id": 307491741,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1667384790
    },
    {
        "content": "<p>Re. mapping to subgraphs, I've changed the definition to something more general <a href=\"https://github.com/bottine/mathlib/blob/bottine/trees_min_max/src/combinatorics/simple_graph/aux.lean#L66\">here</a>, and there is even a reimplementation of <code>to_delete_edges</code> (but <code>p.to_subgraph ≤ H</code>is pretty neat)</p>",
        "id": 307492549,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1667385070
    },
    {
        "content": "<p>Re. <code>is_acyclic.le</code> and <code>connected.le</code>, I guess <code>is_acyclic.le</code> is dependent on your PR in any case, so probably the easiest is for you to directly include that?</p>",
        "id": 307492903,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1667385207
    },
    {
        "content": "<p>One lemma I really needed here was <a href=\"https://github.com/bottine/mathlib/blob/bottine/trees_min_max/src/combinatorics/simple_graph/split_cycle.lean\">this one about extracting a path connecting two ends of an edge out of a cycle containing that edge</a>.<br>\nIs there code for it? how would it fit in mathlib if there isn't?</p>",
        "id": 307495595,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1667386131
    },
    {
        "content": "<p>I'm thinking of doing a PR with the <code>induce</code> code instead of lazily waiting for things to happen. Does that work for you <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span>  ?</p>",
        "id": 307755699,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1667489263
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"461830\">@Rémi Bottinelli</span> That seems like a reasonable way forward to get something to happen. Once you have it, at some point I might help and add enough to get <code>p.to_subgraph ≤ H</code> to work if you don't mind.</p>",
        "id": 307757726,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1667489766
    },
    {
        "content": "<p><del>OK, I might as well use that directly.</del> Let me give it a go, and I'll keep you updated!<br>\nActually, I'll stick with my method for now, <code>to_subgraph</code> might be more complicated than expected.</p>",
        "id": 307765324,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1667491716
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"461830\">@Rémi Bottinelli</span> Please write your PR as you're writing it, but I thought I'd let you know that I created a <code>walk.to_path</code> PR from what I had in a branch (<a href=\"https://github.com/leanprover-community/mathlib/pull/17325\">#17325</a>).</p>\n<p>It's worth you doing what you're doing so that we get a chance to evaluate multiple designs, and if we switch to <code>walk.to_path</code> I expect it to be quick to transform.</p>",
        "id": 307793702,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1667494839
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/pull/17326\">https://github.com/leanprover-community/mathlib/pull/17326</a><br>\nI'm done for today, but here is most of it I guess? I'll look more closely at getting correct names and what other lemmas should be added tomorrow.<br>\nIn the meantime, what's the correct way to handle my <code>private</code> lemmas here?</p>",
        "id": 307815529,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1667501547
    },
    {
        "content": "<p>Let me note that my code for number of connected components and all that is basically ready, but given it is dependant on the is_bridge PRs, I'll wait for those to be merged before PRing that (I don't have enough git experience to attempt making a PR dependent on those). We're going to work on other stuff in graph theory in the meantime.</p>",
        "id": 307881075,
        "sender_full_name": "Jérémie Turcotte",
        "timestamp": 1667535176
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"507101\">@Jérémie Turcotte</span> Feel free to create that PR. There aren't really any special features for PRs depending on others except for a way in the PR text to declare PRs that should be merged first. We can help get that right.</p>",
        "id": 307894544,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1667545405
    },
    {
        "content": "<p>Also, you and/or Remy might consider reviewing the PR(s) you're depending on, which should accelerate the process. There are not many combinatorics reviewers (and I shouldn't review my own PRs!), but maintainers with another expertise might be comfortable merging them if they've been reviewed.</p>",
        "id": 307895029,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1667545680
    },
    {
        "content": "<p>I can give reviewing a go, but am not sure I have the credentials/knowledge to be of any use. Is there any kind of checklist/guide to making useful reviews?</p>",
        "id": 307901692,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1667549269
    },
    {
        "content": "<p>Here are some general guidelines for reviewing (stolen from a list that Kyle put together at some point):</p>\n<blockquote>\n<ul>\n<li>Does it adhere to mathlib style?</li>\n<li>Do declarations follow the naming convention?</li>\n<li>Are declarations generally in the right files? Do they not already exist elsewhere under a different name or level of generality?</li>\n<li>Are there any obvious opportunities to split off supporting lemmas or definitions?</li>\n<li>Is it maintainable code that follows accepted practices?</li>\n<li>Does it provide a sensible API?</li>\n<li>Has it been generalized to support known future needs?</li>\n<li>Does it fit into the design and collective vision of the library?</li>\n<li>Is it formalizing something from the literature?</li>\n</ul>\n</blockquote>",
        "id": 307903177,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1667550049
    },
    {
        "content": "<p>Thanks!</p>",
        "id": 307903350,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1667550126
    },
    {
        "content": "<p>This is a bit <code>simp</code>-heavy, but would it be PR-able?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">cons_is_cycle_iff_nodup</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">G.adj</span> <span class=\"n\">v</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">G.walk</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">),</span>\n  <span class=\"o\">(</span><span class=\"n\">walk.cons</span> <span class=\"n\">a</span> <span class=\"n\">p</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">is_cycle</span> <span class=\"bp\">↔</span> <span class=\"mi\">2</span> <span class=\"bp\">≤</span> <span class=\"n\">p.length</span> <span class=\"bp\">∧</span> <span class=\"n\">p.support.nodup</span>\n<span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">a</span> <span class=\"n\">walk.nil</span> <span class=\"o\">:=</span>  <span class=\"o\">(</span><span class=\"n\">a.ne</span> <span class=\"n\">rfl</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">elim</span>\n<span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">walk.cons</span> <span class=\"n\">b</span> <span class=\"n\">walk.nil</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">cons_is_cycle_iff</span><span class=\"o\">,</span> <span class=\"n\">support_nil</span><span class=\"o\">,</span> <span class=\"n\">list.mem_singleton</span><span class=\"o\">,</span> <span class=\"n\">edges_cons</span><span class=\"o\">,</span> <span class=\"n\">edges_nil</span><span class=\"o\">,</span>\n               <span class=\"n\">quotient.eq</span><span class=\"o\">,</span> <span class=\"n\">sym2.rel_iff</span><span class=\"o\">,</span> <span class=\"n\">eq_self_iff_true</span><span class=\"o\">,</span> <span class=\"n\">or_true</span><span class=\"o\">,</span> <span class=\"n\">not_true</span><span class=\"o\">,</span> <span class=\"n\">and_false</span><span class=\"o\">,</span>\n               <span class=\"n\">length_cons</span><span class=\"o\">,</span> <span class=\"n\">length_nil</span><span class=\"o\">,</span> <span class=\"n\">zero_add</span><span class=\"o\">,</span> <span class=\"n\">support_cons</span><span class=\"o\">,</span> <span class=\"n\">list.nodup_cons</span><span class=\"o\">,</span> <span class=\"n\">list.not_mem_nil</span><span class=\"o\">,</span>\n               <span class=\"n\">not_false_iff</span><span class=\"o\">,</span> <span class=\"n\">list.nodup_nil</span><span class=\"o\">,</span> <span class=\"n\">and_true</span><span class=\"o\">,</span> <span class=\"n\">false_iff</span><span class=\"o\">,</span> <span class=\"n\">not_and</span><span class=\"o\">,</span> <span class=\"n\">not_not</span><span class=\"o\">],</span>\n    <span class=\"n\">rintro</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">exfalso</span><span class=\"o\">,</span>\n    <span class=\"n\">linarith</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">],</span> <span class=\"o\">}</span>\n<span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">walk.cons'</span> <span class=\"n\">x</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">b</span> <span class=\"o\">(</span><span class=\"n\">walk.cons'</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"n\">w</span> <span class=\"n\">c</span> <span class=\"n\">q</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">cons_is_cycle_iff</span><span class=\"o\">,</span> <span class=\"n\">is_path_def</span><span class=\"o\">,</span> <span class=\"n\">nat.succ_le_succ_iff</span><span class=\"o\">],</span>\n    <span class=\"n\">push_neg</span><span class=\"o\">,</span>\n    <span class=\"n\">rintros</span> <span class=\"o\">⟨</span><span class=\"n\">xny</span><span class=\"o\">,</span> <span class=\"n\">xnq</span><span class=\"o\">⟩</span> <span class=\"n\">ynq</span> <span class=\"n\">qnd</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">xny</span><span class=\"o\">,</span> <span class=\"n\">ne.def</span><span class=\"o\">,</span> <span class=\"n\">not_false_iff</span><span class=\"o\">,</span> <span class=\"n\">implies_true_iff</span><span class=\"o\">,</span> <span class=\"n\">true_and</span><span class=\"o\">,</span> <span class=\"n\">and_true</span><span class=\"o\">],</span>\n    <span class=\"k\">have</span> <span class=\"n\">wny</span> <span class=\"o\">:</span> <span class=\"n\">w</span> <span class=\"bp\">≠</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"kd\">by</span>\n    <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n      <span class=\"n\">simpa</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">end_mem_support</span><span class=\"o\">,</span> <span class=\"n\">not_true</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">ynq</span> <span class=\"o\">},</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">wny</span><span class=\"o\">,</span> <span class=\"n\">not_false_iff</span><span class=\"o\">,</span> <span class=\"n\">is_empty.forall_iff</span><span class=\"o\">,</span> <span class=\"n\">true_and</span><span class=\"o\">],</span>\n    <span class=\"n\">exact</span> <span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">xnq</span> <span class=\"o\">(</span><span class=\"n\">snd_mem_support_of_mem_edges</span> <span class=\"n\">_</span> <span class=\"n\">h</span><span class=\"o\">),</span>\n  <span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">is_cycle_iff_nodup</span> <span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">G.walk</span> <span class=\"n\">u</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">p.is_cycle</span> <span class=\"bp\">↔</span> <span class=\"mi\">3</span> <span class=\"bp\">≤</span> <span class=\"n\">p.length</span> <span class=\"bp\">∧</span> <span class=\"n\">p.support.tail.nodup</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">cases</span> <span class=\"n\">p</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">is_cycle.not_of_nil</span><span class=\"o\">,</span> <span class=\"n\">length_nil</span><span class=\"o\">,</span> <span class=\"n\">le_zero_iff</span><span class=\"o\">,</span> <span class=\"n\">nat.bit1_ne_zero</span><span class=\"o\">,</span> <span class=\"n\">false_and</span><span class=\"o\">],</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">nat.succ_le_succ_iff</span><span class=\"o\">,</span> <span class=\"n\">length_cons</span><span class=\"o\">,</span> <span class=\"n\">support_cons</span><span class=\"o\">,</span> <span class=\"n\">list.tail_cons</span><span class=\"o\">],</span>\n    <span class=\"n\">exact</span> <span class=\"n\">cons_is_cycle_iff_nodup</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 308237277,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1667730886
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/pull/17402\">https://github.com/leanprover-community/mathlib/pull/17402</a>  &lt;- Short PR to allow mapping walks to supergraphs as discussed with <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span>.<br>\nI didn't use the code you provided for <code>is_cycle_of_injective</code> mostly since this one was already working for me and was thus less work.</p>",
        "id": 308338424,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1667807112
    },
    {
        "content": "<p>By the way, the <code>connectivity</code> file actually takes quite a lot of time to check. How would <code>simp only</code> everywhere reduce compilation time?</p>",
        "id": 308409404,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1667834024
    },
    {
        "content": "<p>I'm not sure -- if it's a concern, probably the right thing to do is use the profiler to find the worst offenders and measure how much of an affect squeezed simps would have.</p>\n<p>It's also just a big module. I'd like for everything that's about walks/paths/trails/cycles to eventually go into a new module, maybe <code>combinatorics/simple_graph/walk.lean</code>. Then the connectivity module would pick up at the definition of <code>reachable</code>.</p>",
        "id": 308414701,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1667835556
    },
    {
        "content": "<p>I'm imagining the definitions of vertex connectivity and edge connectivity would eventually be in the connectivity module as well.</p>",
        "id": 308415047,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1667835661
    },
    {
        "content": "<p>Side note: I think we have <a href=\"https://leanprover-community.github.io/mathlib_docs/find/simple_graph.walk.copy\">docs#simple_graph.walk.copy</a> mis-named. Other examples of \"copy\" involve changing internal data, but this function is only changing the external data -- the indices. It's more analogous to <a href=\"https://leanprover-community.github.io/mathlib_docs/find/fin.cast\">docs#fin.cast</a>.</p>\n<p>I'm leaning toward renaming it to <code>simple_graph.walk.cast</code>. Are there any other possibilities?</p>",
        "id": 308415700,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1667835865
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"507101\">@Jérémie Turcotte</span> FYI, bridges, acyclic graphs, and trees are now all merged.</p>\n<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/simple_graph.is_bridge\">docs#simple_graph.is_bridge</a> <a href=\"https://leanprover-community.github.io/mathlib_docs/find/simple_graph.is_acyclic\">docs#simple_graph.is_acyclic</a> <a href=\"https://leanprover-community.github.io/mathlib_docs/find/simple_graph.is_tree\">docs#simple_graph.is_tree</a></p>",
        "id": 311054682,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1668882325
    },
    {
        "content": "<p>Great! I've done a PR, see <a href=\"https://github.com/leanprover-community/mathlib/pull/17654\">#17654</a> . This is the first time I PR anything, so please let me know if I'm going anything wrong. Thanks!</p>",
        "id": 311199479,
        "sender_full_name": "Jérémie Turcotte",
        "timestamp": 1668990688
    },
    {
        "content": "<p>(The result comparing the # of edges, vertices, components in forests still needs a bit of cleaning up but will be done soon.)</p>",
        "id": 311199602,
        "sender_full_name": "Jérémie Turcotte",
        "timestamp": 1668990806
    },
    {
        "content": "<p>I've finished a version of the characterization of trees as maximal acyclic/minimal connected <a href=\"https://github.com/leanprover-community/mathlib/compare/master...bottine/simple_graph/trees_min_max2\">here</a> but I'm not totally satisfied with the proofs: they look quite dirty. I would welcome some refactoring ideas if anyone wants to have a look!</p>",
        "id": 312451146,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1669546013
    },
    {
        "content": "<p>Side question: Why not make <code>connected</code> and <code>preconnected</code> into classes? That would be quite natural and allow to get <code>metric_space</code> as an instance for a graph too. No?</p>",
        "id": 316452420,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1671281673
    },
    {
        "content": "<p>If you've got <code>G : simple_graph V</code>, it's not clear how you'd automatically get a <code>metric_space V</code> instance -- by just looking at <code>V</code> you can't (and shouldn't) automatically figure out you should be considering <code>G</code>. I say \"shouldn't\" because there isn't a uniquely interesting simple graph structure on <code>V</code>.</p>",
        "id": 316768494,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1671463477
    },
    {
        "content": "<p>Mmh, so there is friction coming from the different perspective between metric spaces and graphs I guess.</p>",
        "id": 316778939,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1671466380
    },
    {
        "content": "<p>The solution is to make a type synonym of <code>V</code> depending on <code>G</code>. Then we could register a pseudo-metric space instance, and Rémi's suggestion would allow to register a metric space one.</p>",
        "id": 316819562,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1671479673
    },
    {
        "content": "<p>I didn't mention that because it's not clear it's the right thing to do, but it's certainly a valid design. To be clear, you wouldn't have <code>metric_space V</code>, but something like <code>metric_space G.verts</code>. A significant downside is that if you have <code>v w : V</code> then you can't use typeclass inference to immediately get the correct distance function; you'd have to have some mechanism to \"cast\" <code>v</code> and <code>w</code> to have the literal type <code>G.verts</code> for typeclass inference to get the correct distance function.</p>",
        "id": 316821463,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1671480285
    },
    {
        "content": "<p>That's inherent to having <code>simple_graph</code> not a class, I'm afraid.</p>",
        "id": 316821813,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1671480380
    },
    {
        "content": "<p>I already did something very similar for marked groups over at <a href=\"https://github.com/leanprover-community/mathlib/tree/geometric-group-theory\">branch#geometric-group-theory</a>, and the design I mentioned is painless.</p>",
        "id": 316821971,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1671480431
    }
]
[
    {
        "content": "<p>Something I've been wanting to understand better is the relationship between two different ways of thinking about directed graphs.</p>",
        "id": 214898332,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1603919550
    },
    {
        "content": "<p>The first is as an endomorphism in the category of spans, i.e.:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">dgraph</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">→</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n</code></pre></div>\n\n<p>(This point of view gives the funny definition of a category, which is a monad in the 2-category of spans <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span>)</p>",
        "id": 214898347,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1603919557
    },
    {
        "content": "<p>The second is using edge sets</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">dgraph'</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">edges</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 214898382,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1603919580
    },
    {
        "content": "<p>It's not hard going back and forth between these representations, and they seem to have their own strengths and weaknesses.  (The first is good for when it's useful having <code>E</code>, and the second is good for paths and subgraphs, it seems.)</p>",
        "id": 214898468,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1603919625
    },
    {
        "content": "<p>I was wondering (1) whether <code>dgraph'</code> is some sort of categorical construction like a span and (2) whether there is some generalized formal relationship between <code>dgraph</code> and <code>dgraph'</code>.  (All I know is that <code>dgraph'</code> isn't a cospan.  Well, as far as I can tell.)</p>",
        "id": 214898486,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1603919637
    },
    {
        "content": "<p>If it's not too basic of a question, can I ask what you mean by \"good for when it's useful having E\"?</p>",
        "id": 214900712,
        "sender_full_name": "Julian Berman",
        "timestamp": 1603920937
    },
    {
        "content": "<p>(Basically the first way is you have a collection of vertices and a collection of edges and some maps from edges that tell you which vertex is the \"start\" and which is the \"end\", yeah? And the second way is just edges are pairs of edges with some labels? And somehow the first way is more convenient when? When you have explicitly some E already?)</p>",
        "id": 214901014,
        "sender_full_name": "Julian Berman",
        "timestamp": 1603921089
    },
    {
        "content": "<p>It's easy to go back and forth, and the two approaches are equivalent (except for the universes involved).</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.equiv.basic</span>\n\n<span class=\"kd\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">dgraph</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">→</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">dgraph'</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">edges</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"n\">dgraph</span> <span class=\"bp\">≃</span> <span class=\"n\">dgraph'</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">X</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">V</span> <span class=\"o\">:=</span> <span class=\"n\">X.V</span><span class=\"o\">,</span>\n    <span class=\"n\">edges</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">A</span> <span class=\"n\">B</span><span class=\"o\">,</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X.E</span> <span class=\"bp\">//</span> <span class=\"n\">X.s</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">A</span> <span class=\"bp\">∧</span> <span class=\"n\">X.t</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">B</span> <span class=\"o\">}</span> <span class=\"o\">},</span>\n  <span class=\"n\">inv_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">X</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">V</span> <span class=\"o\">:=</span> <span class=\"n\">X.V</span><span class=\"o\">,</span>\n    <span class=\"n\">E</span> <span class=\"o\">:=</span> <span class=\"bp\">Σ</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">X.V</span><span class=\"o\">),</span> <span class=\"n\">X.edges</span> <span class=\"n\">A</span> <span class=\"n\">B</span><span class=\"o\">,</span>\n    <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">f.1</span><span class=\"o\">,</span>\n    <span class=\"n\">t</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">f.2.1</span> <span class=\"o\">},</span>\n  <span class=\"n\">left_inv</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">right_inv</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 214901453,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1603921387
    },
    {
        "content": "<p>Actually, those sorry's aren't that easy... (maybe even false?! The correct thing to do is define an equivalence of categories.)</p>",
        "id": 214901587,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1603921485
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321696\">Julian Berman</span> <a href=\"#narrow/stream/252551-graph-theory/topic/spans/near/214900712\">said</a>:</p>\n<blockquote>\n<p>If it's not too basic of a question, can I ask what you mean by \"good for when it's useful having E\"?</p>\n</blockquote>\n<p>One example is you can say <code>[fintype G.E]</code> to deal with directed graphs with finitely many edges -- it's awkward saying you only have finitely many edges in the <code>dgraph'</code> version.  Another is you can easily define edge labelings as functions <code>G.E -&gt; L</code>.  If you want a subset of edges that satisfy a given property, then <code>set G.E</code> avoids a bunch of dependent types.</p>\n<p>The <code>dgraph'</code> one can be convenient when you know what the edge sets are between pairs of vertices, though you can always use a sigma type like in <span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span>'s code to construct an edge set this way.  (The <code>dgraph'</code> one is also useful because it's compatible with how we think about morphism sets in categories.  It's the structure version of <code>has_hom</code>.)</p>",
        "id": 214903749,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1603922937
    },
    {
        "content": "<p>Thanks that's very helpful.</p>",
        "id": 214904213,
        "sender_full_name": "Julian Berman",
        "timestamp": 1603923241
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/252551-graph-theory/topic/spans/near/214901587\">said</a>:</p>\n<blockquote>\n<p>Actually, those sorry's aren't that easy... (maybe even false?! The correct thing to do is define an equivalence of categories.)</p>\n</blockquote>\n<p>Yeah, I think it needs some kind of equivalence that looks deeper into the types, and defining the categories and showing they're equivalent seems the right way to go.</p>\n<p>I got to trying to show this in <code>left_inv</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">(</span><span class=\"bp\">Σ</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">),</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">//</span> <span class=\"n\">s</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">A</span> <span class=\"bp\">∧</span> <span class=\"n\">t</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">B</span><span class=\"o\">})</span> <span class=\"bp\">=</span> <span class=\"n\">E</span>\n</code></pre></div>\n\n<p>and that doesn't seem to be provable (type theory's made me uncomfortable saying something like this is false!)</p>",
        "id": 214904341,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1603923314
    },
    {
        "content": "<p>Some time ago I played around with re-defining categories like this; that is with a type for the objects and another for the morphisms, and having source and target maps (and identity and all the other stuff you need) - the main thing I learnt from it was that working with sigma types for this sort of thing leads to a huge amount of pain very quickly. I did manage to get the 2-categorical equivalence between the two definitions, but it was unpleasant to do</p>",
        "id": 214904467,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1603923393
    },
    {
        "content": "<p>Do you have any thoughts on why this is?  I'm wondering if it's because the \"a category is a monad in the 2-category of spans\" approach needs all these pullbacks, and somehow the transformation to something like <code>dgraph'</code> bakes those in</p>",
        "id": 214904669,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1603923520
    },
    {
        "content": "<p>You can try to fill in the holes here:</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">category_theory.category</span>\n<span class=\"kn\">import</span> <span class=\"n\">category_theory.equivalence</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.equiv.basic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">category_theory</span>\n\n<span class=\"kd\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">dgraph</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">→</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">dgraph</span>\n\n<span class=\"kd\">@[ext]</span>\n<span class=\"kd\">structure</span> <span class=\"n\">hom</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">dgraph</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">mapV</span> <span class=\"o\">:</span> <span class=\"n\">A.V</span> <span class=\"bp\">→</span> <span class=\"n\">B.V</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">mapE</span> <span class=\"o\">:</span> <span class=\"n\">A.E</span> <span class=\"bp\">→</span> <span class=\"n\">B.E</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">maps</span> <span class=\"o\">{</span><span class=\"n\">e</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">mapV</span> <span class=\"o\">(</span><span class=\"n\">A.s</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">B.s</span> <span class=\"o\">(</span><span class=\"n\">mapE</span> <span class=\"n\">e</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">mapt</span> <span class=\"o\">{</span><span class=\"n\">e</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">mapV</span> <span class=\"o\">(</span><span class=\"n\">A.t</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">B.t</span> <span class=\"o\">(</span><span class=\"n\">mapE</span> <span class=\"n\">e</span><span class=\"o\">))</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">category</span> <span class=\"n\">dgraph</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">hom</span> <span class=\"o\">:=</span> <span class=\"n\">hom</span><span class=\"o\">,</span>\n  <span class=\"n\">id</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">X</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">mapV</span> <span class=\"o\">:=</span> <span class=\"n\">id</span><span class=\"o\">,</span>\n    <span class=\"n\">mapE</span> <span class=\"o\">:=</span> <span class=\"n\">id</span><span class=\"o\">,</span>\n    <span class=\"n\">maps</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">tauto</span><span class=\"o\">,</span>\n    <span class=\"n\">mapt</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">tauto</span> <span class=\"o\">},</span>\n  <span class=\"n\">comp</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"n\">Z</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">mapV</span> <span class=\"o\">:=</span> <span class=\"n\">g.mapV</span> <span class=\"bp\">∘</span> <span class=\"n\">f.mapV</span><span class=\"o\">,</span>\n    <span class=\"n\">mapE</span> <span class=\"o\">:=</span> <span class=\"n\">g.mapE</span> <span class=\"bp\">∘</span> <span class=\"n\">f.mapE</span><span class=\"o\">,</span>\n    <span class=\"n\">maps</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">f.maps</span><span class=\"o\">,</span> <span class=\"n\">g.maps</span><span class=\"o\">],</span>\n    <span class=\"n\">mapt</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">f.mapt</span><span class=\"o\">,</span> <span class=\"n\">g.mapt</span><span class=\"o\">]</span> <span class=\"o\">}</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">dgraph</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">dgraph'</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">edges</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">dgraph'</span>\n\n<span class=\"kd\">@[ext]</span>\n<span class=\"kd\">structure</span> <span class=\"n\">hom</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">dgraph'</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">mapV</span> <span class=\"o\">:</span> <span class=\"n\">A.V</span> <span class=\"bp\">→</span> <span class=\"n\">B.V</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">mapE</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">A.V</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">A.edges</span> <span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"bp\">→</span> <span class=\"n\">B.edges</span> <span class=\"o\">(</span><span class=\"n\">mapV</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">mapV</span> <span class=\"n\">Y</span><span class=\"o\">))</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">category</span> <span class=\"n\">dgraph'</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">hom</span> <span class=\"o\">:=</span> <span class=\"n\">hom</span><span class=\"o\">,</span>\n  <span class=\"n\">id</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">X</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">mapV</span> <span class=\"o\">:=</span> <span class=\"n\">id</span><span class=\"o\">,</span>\n    <span class=\"n\">mapE</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">id</span> <span class=\"o\">},</span>\n  <span class=\"n\">comp</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"n\">Z</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">mapV</span> <span class=\"o\">:=</span> <span class=\"n\">g.mapV</span> <span class=\"bp\">∘</span> <span class=\"n\">f.mapV</span><span class=\"o\">,</span>\n    <span class=\"n\">mapE</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">g.mapE</span> <span class=\"o\">(</span><span class=\"n\">f.mapE</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">}</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">dgraph'</span>\n\n<span class=\"kd\">@[simps]</span>\n<span class=\"kd\">def</span> <span class=\"n\">forward</span> <span class=\"o\">:</span> <span class=\"n\">dgraph</span> <span class=\"bp\">⥤</span> <span class=\"n\">dgraph'</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">obj</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">X</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">V</span> <span class=\"o\">:=</span> <span class=\"n\">X.V</span><span class=\"o\">,</span>\n      <span class=\"n\">edges</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">A</span> <span class=\"n\">B</span><span class=\"o\">,</span> <span class=\"o\">{</span> <span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">X.E</span> <span class=\"bp\">//</span> <span class=\"n\">X.s</span> <span class=\"n\">e</span> <span class=\"bp\">=</span> <span class=\"n\">A</span> <span class=\"bp\">∧</span> <span class=\"n\">X.t</span> <span class=\"n\">e</span> <span class=\"bp\">=</span> <span class=\"n\">B</span> <span class=\"o\">}</span> <span class=\"o\">},</span>\n    <span class=\"n\">map</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">mapV</span> <span class=\"o\">:=</span> <span class=\"n\">f.mapV</span><span class=\"o\">,</span>\n      <span class=\"n\">mapE</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">e</span><span class=\"o\">,</span>\n      <span class=\"o\">{</span> <span class=\"n\">val</span> <span class=\"o\">:=</span> <span class=\"n\">f.mapE</span> <span class=\"n\">e</span><span class=\"o\">,</span>\n        <span class=\"n\">property</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n          <span class=\"n\">split</span><span class=\"o\">,</span>\n          <span class=\"n\">conv_rhs</span> <span class=\"o\">{</span><span class=\"n\">rw</span> <span class=\"bp\">←</span><span class=\"n\">e.2.1</span><span class=\"o\">},</span>\n          <span class=\"n\">rw</span> <span class=\"n\">f.maps</span><span class=\"o\">,</span>\n          <span class=\"n\">refl</span><span class=\"o\">,</span>\n          <span class=\"n\">conv_rhs</span> <span class=\"o\">{</span><span class=\"n\">rw</span> <span class=\"bp\">←</span><span class=\"n\">e.2.2</span><span class=\"o\">},</span>\n          <span class=\"n\">rw</span> <span class=\"n\">f.mapt</span><span class=\"o\">,</span>\n          <span class=\"n\">refl</span><span class=\"o\">,</span>\n        <span class=\"kd\">end</span> <span class=\"o\">}</span> <span class=\"o\">}</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">@[simps]</span>\n<span class=\"kd\">def</span> <span class=\"n\">backward</span> <span class=\"o\">:</span> <span class=\"n\">dgraph'</span> <span class=\"bp\">⥤</span> <span class=\"n\">dgraph</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">obj</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">X</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">V</span> <span class=\"o\">:=</span> <span class=\"n\">X.V</span><span class=\"o\">,</span>\n      <span class=\"n\">E</span> <span class=\"o\">:=</span> <span class=\"bp\">Σ</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">X.V</span><span class=\"o\">),</span> <span class=\"n\">X.edges</span> <span class=\"n\">A</span> <span class=\"n\">B</span><span class=\"o\">,</span>\n      <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">e.1</span><span class=\"o\">,</span>\n      <span class=\"n\">t</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">e.2.1</span> <span class=\"o\">},</span>\n    <span class=\"n\">map</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">mapV</span> <span class=\"o\">:=</span> <span class=\"n\">f.mapV</span><span class=\"o\">,</span>\n      <span class=\"n\">mapE</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">f.mapV</span> <span class=\"n\">e.1</span><span class=\"o\">,</span> <span class=\"n\">f.mapV</span> <span class=\"n\">e.2.1</span><span class=\"o\">,</span> <span class=\"n\">f.mapE</span> <span class=\"n\">e.2.2</span><span class=\"o\">⟩,</span>\n      <span class=\"n\">maps</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">tauto</span><span class=\"o\">,</span>\n      <span class=\"n\">mapt</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">tauto</span> <span class=\"o\">}</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">AA</span> <span class=\"o\">:</span> <span class=\"n\">dgraph</span> <span class=\"bp\">≌</span> <span class=\"n\">dgraph'</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">functor</span> <span class=\"o\">:=</span> <span class=\"n\">forward</span><span class=\"o\">,</span>\n  <span class=\"n\">inverse</span> <span class=\"o\">:=</span> <span class=\"n\">backward</span><span class=\"o\">,</span>\n  <span class=\"n\">unit_iso</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span> <span class=\"n\">hom</span> <span class=\"o\">:=</span>\n    <span class=\"o\">{</span> <span class=\"n\">app</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">X</span><span class=\"o\">,</span>\n      <span class=\"o\">{</span> <span class=\"n\">mapV</span> <span class=\"o\">:=</span> <span class=\"n\">id</span><span class=\"o\">,</span>\n        <span class=\"n\">mapE</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">X.s</span> <span class=\"n\">e</span><span class=\"o\">,</span><span class=\"n\">X.t</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">tauto</span><span class=\"o\">⟩</span> <span class=\"o\">⟩,</span>\n        <span class=\"n\">maps</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">tauto</span><span class=\"o\">,</span>\n        <span class=\"n\">mapt</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">tauto</span> <span class=\"o\">},</span>\n      <span class=\"n\">naturality'</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span> <span class=\"o\">},</span>\n    <span class=\"n\">inv</span> <span class=\"o\">:=</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n    <span class=\"n\">hom_inv_id'</span> <span class=\"o\">:=</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n    <span class=\"n\">inv_hom_id'</span> <span class=\"o\">:=</span> <span class=\"n\">_</span> <span class=\"o\">},</span>\n  <span class=\"n\">counit_iso</span> <span class=\"o\">:=</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">functor_unit_iso_comp'</span> <span class=\"o\">:=</span> <span class=\"n\">_</span> <span class=\"o\">}</span>\n</code></pre></div>\n\n</div></div>",
        "id": 214904705,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1603923558
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/252551-graph-theory/topic/spans/near/214904669\">said</a>:</p>\n<blockquote>\n<p>Do you have any thoughts on why this is?  I'm wondering if it's because the \"a category is a monad in the 2-category of spans\" approach needs all these pullbacks, and somehow the transformation to something like <code>dgraph'</code> bakes those in</p>\n</blockquote>\n<p>This sounds reasonable, I think it's also that equality of sigma types means you get <code>heq</code> things floating about which creates a bunch of issues</p>",
        "id": 214904912,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1603923715
    },
    {
        "content": "<p>I think you mean that a category is an <strong>algebra</strong> for this monad, right?</p>",
        "id": 214905305,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1603923984
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/252551-graph-theory/topic/spans/near/214903749\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"321696\">Julian Berman</span> <a href=\"#narrow/stream/252551-graph-theory/topic/spans/near/214900712\">said</a>:</p>\n<blockquote>\n<p>If it's not too basic of a question, can I ask what you mean by \"good for when it's useful having E\"?</p>\n</blockquote>\n<p>One example is you can say <code>[fintype G.E]</code> to deal with directed graphs with finitely many edges -- it's awkward saying you only have finitely many edges in the <code>dgraph'</code> version.  Another is you can easily define edge labelings as functions <code>G.E -&gt; L</code>.  If you want a subset of edges that satisfy a given property, then <code>set G.E</code> avoids a bunch of dependent types.</p>\n</blockquote>\n<p>Is there something wrong with defining finitely many edges to be \"for every X,Y, <code>edges X Y</code> is a fintype\"? I can believe edge labellings aren't as pleasant as in <code>dgraph</code>; but I think the awkwardness of dependent types here is a lot less than the awkwardness of sigma equality you get with <code>dgraph</code> (plus we're in mathlib, dependent types are everywhere anyway :) )</p>",
        "id": 214905500,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1603924118
    },
    {
        "content": "<p>There's no issue with that notion of finiteness, I don't think.  It's when you want to talk about the cardinality of the edge set that it's more annoying.  (And when you want to do undirected graphs, I found it got even worse not having some kind of type of all edges.)</p>\n<p>I think <code>dgraph</code> vs <code>dgraph'</code> is a matter of application.  For categories, composition is important, so <code>dgraph'</code> seems (and seems to have proven) to be better there.</p>\n<p>Something I want to experiment sometime is <code>dgraph</code> along with this definition:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">dgraph.edges</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">dgraph.</span><span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">})</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">G.V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">G.E</span> <span class=\"bp\">//</span> <span class=\"n\">G.s</span> <span class=\"n\">e</span> <span class=\"bp\">=</span> <span class=\"n\">v</span> <span class=\"bp\">∧</span> <span class=\"n\">G.t</span> <span class=\"n\">e</span> <span class=\"bp\">=</span> <span class=\"n\">w</span><span class=\"o\">}</span>\n</code></pre></div>\n\n<p>which gives <code>dgraph</code> the <code>dgraph'</code> interface, and then using that definition as much as possible in the API.  It potentially seems like the best of both worlds, though taking spanning subgraphs won't be as nice as <code>dgraph'</code>.</p>",
        "id": 214906032,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1603924509
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/252551-graph-theory/topic/spans/near/214905305\">said</a>:</p>\n<blockquote>\n<p>I think you mean that a category is an <strong>algebra</strong> for this monad, right?</p>\n</blockquote>\n<p>I'm not too familiar with algebras for monads, but if you're thinking of a monad functorially, then I think that's equivalent (I'm imagining the functor of fiber-product-with? not completely sure though).  A Baez tweet led me to <a href=\"https://graphicallinearalgebra.net/2017/04/16/a-monoid-is-a-category-a-category-is-a-monad-a-monad-is-a-monoid/\">this article</a>, which describes monads in monoidal 2-categories, which is a monoid in an endomorphism category with some additional coherence laws.</p>",
        "id": 214906574,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1603924910
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> see the following:<br>\n<a href=\"https://ncatlab.org/nlab/show/internal+category\">https://ncatlab.org/nlab/show/internal+category</a></p>",
        "id": 214906930,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1603925196
    },
    {
        "content": "<p>Especially around the \"Alternative Definition\" section</p>",
        "id": 214906954,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1603925218
    },
    {
        "content": "<p>So yes they say it's a monad in spans</p>",
        "id": 214906982,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1603925252
    },
    {
        "content": "<p>I also realize I have no idea what I was talking about with that last message -- somehow I thought you were saying a module rather than algebra, but that doesn't seem to work.  What does it mean for a category to be an algebra for the monad?</p>",
        "id": 214907222,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1603925413
    },
    {
        "content": "<p>But I like to think of it like this: there is an obvious forgetful functor from the category of categories to dgraph. This has a left adjoint (the free category on a dgraph), and forgetting again yields a monad on dgraph. The algebras for this monad are categories, i.e. this forgetful functor is monadic (in the terminology around the Barr-Beck theorem)</p>",
        "id": 214907229,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1603925420
    },
    {
        "content": "<p>Essentially the data of an algebra for this monad is the data of a composition rule and identity morphisms, and the associativity condition tells you that the axioms of a category hold true</p>",
        "id": 214907460,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1603925600
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">AA</span> <span class=\"o\">:</span> <span class=\"n\">dgraph</span> <span class=\"bp\">≌</span> <span class=\"n\">dgraph'</span> <span class=\"o\">:=</span>\n<span class=\"n\">equivalence.mk</span> <span class=\"n\">forward</span> <span class=\"n\">backward</span>\n  <span class=\"o\">(</span><span class=\"kd\">begin</span>\n    <span class=\"n\">apply</span> <span class=\"o\">(</span><span class=\"n\">nat_iso.of_components</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">intro</span> <span class=\"n\">X</span><span class=\"o\">,</span>\n      <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n      <span class=\"o\">{</span> <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">id</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">e.2.2.1</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span><span class=\"bp\">;</span>\n        <span class=\"n\">tidy</span> <span class=\"o\">},</span>\n      <span class=\"o\">{</span> <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">id</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">X.s</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">X.t</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">tauto</span><span class=\"o\">⟩,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span><span class=\"bp\">;</span>\n        <span class=\"n\">tauto</span> <span class=\"o\">},</span>\n      <span class=\"o\">{</span> <span class=\"n\">apply_auto_param</span> <span class=\"o\">},</span>\n      <span class=\"o\">{</span> <span class=\"n\">apply_auto_param</span> <span class=\"o\">}</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">tidy</span> <span class=\"o\">}</span>\n  <span class=\"kd\">end</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"kd\">begin</span>\n    <span class=\"n\">apply</span> <span class=\"o\">(</span><span class=\"n\">nat_iso.of_components</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">intro</span> <span class=\"n\">E</span><span class=\"o\">,</span>\n      <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n      <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">id</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"o\">⟨⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">f</span><span class=\"o\">⟩,</span> <span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩⟩</span> <span class=\"o\">},</span>\n      <span class=\"o\">{</span> <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">id</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n        <span class=\"n\">rintro</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">⟨⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">e</span><span class=\"o\">⟩,</span> <span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩,</span>\n        <span class=\"n\">apply</span> <span class=\"n\">e</span> <span class=\"o\">},</span>\n      <span class=\"o\">{</span> <span class=\"n\">apply_auto_param</span> <span class=\"o\">},</span>\n      <span class=\"o\">{</span> <span class=\"n\">apply_auto_param</span> <span class=\"o\">}</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">tidy</span> <span class=\"o\">}</span>\n  <span class=\"kd\">end</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 214909508,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1603927099
    },
    {
        "content": "<p>Tangentially related to this, I'm trying to define the (arbitrary) coproduct of categories as a sigma-type, and it's turning out painful (much like virtually everything with sigma and categories in Lean), what was it like defining the disjoint union of <code>dgraph'</code>s?</p>",
        "id": 216699154,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1605320256
    }
]
[
    {
        "content": "<p>I think a lot of what we've done in <a href=\"https://github.com/leanprover-community/mathlib/issues/3458\">#3458</a> is good, but looking at <span class=\"user-mention\" data-user-id=\"246273\">@Bhavik Mehta</span>'s definitions, I'm pretty sure that we should refactor the references to <code>sym2</code> to use <code>powerset_len 2</code> instead. <a href=\"https://github.com/b-mehta/combinatorics/blob/graphs/src/handshaking.lean\">https://github.com/b-mehta/combinatorics/blob/graphs/src/handshaking.lean</a></p>",
        "id": 206658881,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597206319
    },
    {
        "content": "<p>There are already plenty of counting results proven about <code>powerset_len</code>, and in general, if we want to count finite things, it's better IMO to use something as ingrained in the <code>finset</code> library as possible.</p>",
        "id": 206658950,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597206437
    },
    {
        "content": "<p>There are some special properties about <code>sym2</code> (i.e., unordered pairs) that other powerset lengths don't have, which is why we thought it was worth having when we added it.  There is at least an equivalence to multigraphs of length 2 in the <code>sym2</code> library.  So, from another point of view, this means <code>sym2</code> should be better developed to have all the features of <code>powerset_len 2</code>.</p>",
        "id": 206763868,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1597273787
    },
    {
        "content": "<p>Isn't <code>sym2</code> just type-equivalent to <code>powerset_len 2</code>? I used powerset_len in particular because I had in mind the generalisation to hypergraphs rather than multigraphs</p>",
        "id": 206764029,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1597273892
    },
    {
        "content": "<p>They are not type-equivalent, because <code>sym2</code> includes the diagonal.</p>",
        "id": 206765257,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597274852
    },
    {
        "content": "<p>Graphs with loops need <code>sym2</code>, loopless graphs do not</p>",
        "id": 206765294,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597274882
    },
    {
        "content": "<p>Also, it'd be very hard to develop <code>sym2</code> to have all the features of <code>powerset_len 2</code>, because <code>powerset_len 2</code> is a subtype (actually a subset!) of <code>finset</code>, which has a colossal amount of API available</p>",
        "id": 206765513,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597275035
    },
    {
        "content": "<p>I also like the generalization to hypergraphs</p>",
        "id": 206765548,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597275073
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"302826\">Aaron Anderson</span> <a href=\"#narrow/stream/252551-graph-theory/topic/graph.20defs/near/206765257\">said</a>:</p>\n<blockquote>\n<p>They are not type-equivalent, because <code>sym2</code> includes the diagonal.</p>\n</blockquote>\n<p>ah of course, makes sense</p>",
        "id": 206765723,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1597275207
    },
    {
        "content": "<p>I think that a good model may be to have no data at all about the edge type E except for a function from E to <code>finset V</code></p>",
        "id": 206765809,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597275272
    },
    {
        "content": "<p>and a Prop that the image of that map always has a specified length (2 until we're ready to define hypergraphs)</p>",
        "id": 206765895,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597275346
    },
    {
        "content": "<p>Then we can define the <code>has_mem</code> instance in terms of that map, etc.</p>",
        "id": 206765962,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597275379
    },
    {
        "content": "<p>I would suggest defining <code>hypergraph</code> if you'd like to have this generalization.  It seems like a good one to have, but it's not clear there's much to be gained except for complexity by making all graphs hypergraphs with an additional restriction.</p>\n<p>One definition I'd used for graphs before was a pair of types <code>V</code> and <code>E</code> and a map <code>E -&gt; sym2 V</code>.  It was nice in some ways, but having to deal with quotient types all the time in proofs was annoying.  Another option is to define directed graphs using a map <code>E -&gt; V \\times V</code> and then taking the quotient of directed graphs by edge reversal to get unoriented graphs.</p>\n<p>If there is a type that is the disjoint union of all finite cartesian powers of <code>V</code> (let's call it <code>carpow V</code> temporarily) then you might consider having oriented hypergraphs using a map <code>E -&gt; carpow V</code>, and then taking the quotient by the symmetric group action on each hyperedge to get unoriented hypergraphs.  (This is a generalization of the <code>E -&gt; finset V</code> idea, because vertices are allowed to appear multiple times per simplex.  The problem with generalization is to figure out how far one should generalize.)</p>",
        "id": 206767907,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1597276742
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"302826\">Aaron Anderson</span> <a href=\"#narrow/stream/252551-graph-theory/topic/graph.20defs/near/206765513\">said</a>:</p>\n<blockquote>\n<p>Also, it'd be very hard to develop <code>sym2</code> to have all the features of <code>powerset_len 2</code>, because <code>powerset_len 2</code> is a subtype (actually a subset!) of <code>finset</code>, which has a colossal amount of API available</p>\n</blockquote>\n<p>That's true, but how much of the API for <code>finset</code> is really relevant to unordered pairs?</p>",
        "id": 206768037,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1597276832
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/252551-graph-theory/topic/graph.20defs/near/206767907\">said</a>:</p>\n<blockquote>\n<p>I would suggest defining <code>hypergraph</code> if you'd like to have this generalization.  It seems like a good one to have, but it's not clear there's much to be gained except for complexity by making all graphs hypergraphs with an additional restriction.</p>\n</blockquote>\n<p>From this perspective, why not define <code>multigraph</code> to use <code>sym2</code> if you care about multigraphs, and have <code>graph</code> to be normal graphs</p>",
        "id": 206768463,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1597277209
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/252551-graph-theory/topic/graph.20defs/near/206768037\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"302826\">Aaron Anderson</span> <a href=\"#narrow/stream/252551-graph-theory/topic/graph.20defs/near/206765513\">said</a>:</p>\n<blockquote>\n<p>Also, it'd be very hard to develop <code>sym2</code> to have all the features of <code>powerset_len 2</code>, because <code>powerset_len 2</code> is a subtype (actually a subset!) of <code>finset</code>, which has a colossal amount of API available</p>\n</blockquote>\n<p>That's true, but how much of the API for <code>finset</code> is really relevant to unordered pairs?</p>\n</blockquote>\n<p>The half of <code>big_operators</code> that pertains to sums</p>",
        "id": 206768556,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597277304
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"246273\">Bhavik Mehta</span> <a href=\"#narrow/stream/252551-graph-theory/topic/graph.20defs/near/206768463\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/252551-graph-theory/topic/graph.20defs/near/206767907\">said</a>:</p>\n<blockquote>\n<p>I would suggest defining <code>hypergraph</code> if you'd like to have this generalization.  It seems like a good one to have, but it's not clear there's much to be gained except for complexity by making all graphs hypergraphs with an additional restriction.</p>\n</blockquote>\n<p>From this perspective, why not define <code>multigraph</code> to use <code>sym2</code> if you care about multigraphs, and have <code>graph</code> to be normal graphs</p>\n</blockquote>\n<p>Sorry, I'm not understanding the suggestion.  I referring to <span class=\"user-mention\" data-user-id=\"302826\">@Aaron Anderson</span>'s idea of having graphs be hypergraphs specialized to having order-2 hyperedges.</p>\n<p>Hypergraph theorists: do you ever want hyperedges that contain a vertex multiple times?  I'm wondering this because it matters whether you define hyperedges using finsets or multisets.</p>",
        "id": 206768803,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1597277547
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/252551-graph-theory/topic/graph.20defs/near/206768803\">said</a>:</p>\n<blockquote>\n<p>Sorry, I'm not understanding the suggestion.  I referring to <span class=\"user-mention silent\" data-user-id=\"302826\">Aaron Anderson</span>'s idea of having graphs be hypergraphs specialized to having order-2 hyperedges.</p>\n</blockquote>\n<p>Your argument seems to be that it's not a good idea to define graphs as a special case of hypergraphs, but it is a good idea to define graphs as a special case of multigraphs - my question is why are multigraphs inherently more interesting to you than hypergraphs? In particular, your criticism of the hypergraph method as \"complexity by making all graphs hypergraphs with an additional restriction\" transfers exactly to multigraphs</p>",
        "id": 206768960,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1597277713
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"302826\">@Aaron Anderson</span> I see, that's a good point.  I sort of wish <code>big_operators</code> had some interface where you could sum over summable things, rather than feeling like everything needs to be a <code>finset</code>.</p>\n<p>One thing the multigraph interface will definitely have is a map <code>E -&gt; finset V</code>, so maybe this will solve this problem.</p>",
        "id": 206768963,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1597277716
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"246273\">Bhavik Mehta</span> <a href=\"#narrow/stream/252551-graph-theory/topic/graph.20defs/near/206768960\">said</a>:</p>\n<blockquote>\n<p>Your argument seems to be that it's not a good idea to define graphs as a special case of hypergraphs, but it is a good idea to define graphs as a special case of multigraphs</p>\n</blockquote>\n<p>Oh, no, I don't think it is good to define simple graphs as special cases of multigraphs.  In fact, I was thinking of not defining multigraphs, per se, but instead having a multigraph interface (through a class).  This is to be able to define things like the type of all subgraphs of a graph and such.</p>",
        "id": 206769055,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1597277831
    },
    {
        "content": "<p>This has seemed to be the cleanest way of dealing with this... but I still need to get the interface code reviewed, so we'll see...</p>",
        "id": 206769140,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1597277902
    },
    {
        "content": "<p>And, actually, it's possible that the simple  graph definition will eventually become a class, too.  Then the special case of hypergraphs with order-2 edges will be simple graphs through this interface.  Similarly, the current definition of a simple graph from a relation will have an instance imbuing it with the structure of a graph.</p>",
        "id": 206769291,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1597278100
    },
    {
        "content": "<p>I've been uncomfortable pushing this way of doing things because I don't feel like the technique has proven itself enough, so I was waiting to see how it was going to work with multigraphs first.</p>",
        "id": 206769358,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1597278154
    },
    {
        "content": "<blockquote>\n<p>I sort of wish big_operators had some interface where you could sum over summable things, rather than feeling like everything needs to be a finset.</p>\n</blockquote>\n<p>Patrick argued a while back that we should look carefully at the big operators library in mathcomp (in Coq), which apparently treat sums over various collectiony things more uniformly, but no one ever took him up on that. It looks like he ported some of it in the old mathlib repo: <a href=\"https://github.com/leanprover-fork/mathlib-backup/tree/bigop\">https://github.com/leanprover-fork/mathlib-backup/tree/bigop</a></p>",
        "id": 206769580,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1597278388
    },
    {
        "content": "<p>Why didn’t I make simple_graph extend rel?</p>",
        "id": 206771653,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597281026
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"302826\">Aaron Anderson</span> <a href=\"#narrow/stream/252551-graph-theory/topic/graph.20defs/near/206771653\">said</a>:</p>\n<blockquote>\n<p>Why didn’t I make simple_graph extend rel?</p>\n</blockquote>\n<p>i remember talking you out of it but not why</p>",
        "id": 206772722,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1597282672
    },
    {
        "content": "<p>Here's what I meant about how simple graphs might be a class (though it's not as compelling as the way it works for multigraphs):</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">combinatorics</span><span class=\"bp\">.</span><span class=\"n\">simple_graph</span>\n\n<span class=\"n\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span>\n\n<span class=\"n\">class</span> <span class=\"n\">simple_graphs</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">adj</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">V</span> <span class=\"n\">G</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"n\">G</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">sym</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">symmetric</span> <span class=\"o\">(</span><span class=\"n\">adj</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"bp\">.</span> <span class=\"n\">obviously</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">loopless</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">irreflexive</span> <span class=\"o\">(</span><span class=\"n\">adj</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"bp\">.</span> <span class=\"n\">obviously</span><span class=\"o\">)</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">simple_graphs</span> <span class=\"o\">(</span><span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">V</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"bp\">_</span> <span class=\"o\">,</span> <span class=\"n\">V</span><span class=\"o\">,</span>\n  <span class=\"n\">adj</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">adj</span><span class=\"o\">,</span>\n  <span class=\"n\">sym</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">sym</span><span class=\"o\">,</span>\n  <span class=\"n\">loopless</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">loopless</span> <span class=\"o\">}</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">simple_graphs</span>\n\n<span class=\"kn\">structure</span> <span class=\"n\">subgraph</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">simple_graphs</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">V&#39;</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"n\">G</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">E&#39;</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">sym2</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"n\">G</span><span class=\"o\">)))</span>\n<span class=\"o\">(</span><span class=\"n\">has_edges</span> <span class=\"o\">:</span> <span class=\"n\">E&#39;</span> <span class=\"err\">⊆</span> <span class=\"n\">sym2</span><span class=\"bp\">.</span><span class=\"n\">from_rel</span> <span class=\"o\">(</span><span class=\"n\">sym</span> <span class=\"n\">G</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">has_ends</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"err\">∈</span> <span class=\"n\">E&#39;</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"err\">∈</span> <span class=\"n\">e</span><span class=\"o\">),</span> <span class=\"n\">v</span> <span class=\"err\">∈</span> <span class=\"n\">V&#39;</span><span class=\"o\">)</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">simple_graphs</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">simple_graphs</span> <span class=\"o\">(</span><span class=\"n\">subgraph</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">V</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">G&#39;</span><span class=\"o\">,</span> <span class=\"n\">subgraph</span><span class=\"bp\">.</span><span class=\"n\">V&#39;</span> <span class=\"n\">G&#39;</span><span class=\"o\">,</span>\n  <span class=\"n\">adj</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">G&#39;</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"err\">⟦</span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">w</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"err\">⟧</span> <span class=\"err\">∈</span> <span class=\"n\">subgraph</span><span class=\"bp\">.</span><span class=\"n\">E&#39;</span> <span class=\"n\">G&#39;</span><span class=\"o\">,</span>\n  <span class=\"n\">sym</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">G&#39;</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">rwa</span> <span class=\"n\">sym2</span><span class=\"bp\">.</span><span class=\"n\">eq_swap</span><span class=\"o\">,</span>\n  <span class=\"n\">loopless</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">G&#39;</span> <span class=\"bp\">⟨</span><span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"bp\">_⟩</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">loopless</span> <span class=\"n\">G</span> <span class=\"n\">v</span> <span class=\"o\">(</span><span class=\"n\">sym2</span><span class=\"bp\">.</span><span class=\"n\">from_rel_prop</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"o\">(</span><span class=\"n\">subgraph</span><span class=\"bp\">.</span><span class=\"n\">has_edges</span> <span class=\"n\">G&#39;</span> <span class=\"n\">h</span><span class=\"o\">))</span> <span class=\"o\">}</span>\n</code></pre></div>\n\n\n<p>where <code>simple_graph</code> might be renamed <code>from_rel</code>.  It just seems a bit weird doing that.</p>",
        "id": 206772824,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1597282787
    },
    {
        "content": "<p>How is this different from an indexed family of graphs?</p>",
        "id": 206772937,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597282916
    },
    {
        "content": "<p>It's an indexed family of graphs, but the <code>simple_graphs (subgraph G)</code> instance is what makes it a bit more than that.</p>",
        "id": 206772997,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1597282972
    },
    {
        "content": "<p>so this isn't supposed to replace <code>simple_graph</code></p>",
        "id": 206773055,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597283075
    },
    {
        "content": "<p>I don't think I understand what <code>simple_graphs (subgraph G)</code> gets you</p>",
        "id": 206773131,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597283207
    },
    {
        "content": "<p>It lets you talk about <code>G' : subgraph G</code> as being a simple graph itself because of polymorphism</p>",
        "id": 206773148,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1597283248
    },
    {
        "content": "<p>Every proof and construction about <code>simple_graph</code> would be changed into one for <code>simple_graphs</code> to make this all work.</p>",
        "id": 206773198,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1597283304
    },
    {
        "content": "<p>Why don't we just define a coercion like with subgroups? We can already talk about a subgroup being a group</p>",
        "id": 206773201,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597283309
    },
    {
        "content": "<p>There are two parts to my understanding of this.</p>\n<p>(1) Other structures tend to have only a single carrier type that's used for synecdoche: you refer to a group by its carrier type, usually.   For graphs, you have both the vertex type and the edge type</p>\n<p>(2) The way substructures are implemented for other algebraic objects is to make, say, a group be a <code>class</code>, and then give a group instance to the subgroup <code>structure</code>.</p>",
        "id": 206773283,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1597283497
    },
    {
        "content": "<p>I'm pretty sure subgroups are already groups without needing a coercion.  (This is at least true with modules and submodules.)  There <em>is</em> a coercion from submodules to a carrier type.</p>",
        "id": 206773337,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1597283543
    },
    {
        "content": "<p>You're right that you don't need the coercion</p>",
        "id": 206773342,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597283554
    },
    {
        "content": "<p>There's a class resolution trick in here for algebraic structures: when you multiply terms together from a subgroup of a group, the elaborator sees that they are terms of the subgroup coerced into its carrier type, and this subgroup-as-carrier is what has the group implementation.  (I guess I wasn't correct about there being no coercion involved.)</p>",
        "id": 206773435,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1597283727
    },
    {
        "content": "<p>Going back to the idea that using the class approach means you're not constrained to a particular definition, here's another example:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">structure</span> <span class=\"n\">simple_graph&#39;</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">edges</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">→</span> <span class=\"n\">sym2</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">edge_inj</span> <span class=\"o\">:</span> <span class=\"n\">function</span><span class=\"bp\">.</span><span class=\"n\">injective</span> <span class=\"n\">edges</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">loopless</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">E</span><span class=\"o\">),</span> <span class=\"bp\">¬</span><span class=\"n\">sym2</span><span class=\"bp\">.</span><span class=\"n\">is_diag</span> <span class=\"o\">(</span><span class=\"n\">edges</span> <span class=\"n\">e</span><span class=\"o\">))</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">simple_graphs</span> <span class=\"o\">(</span><span class=\"n\">simple_graph&#39;</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">V</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"n\">V</span><span class=\"o\">,</span>\n  <span class=\"n\">adj</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">G</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"err\">⟦</span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">w</span><span class=\"o\">)</span><span class=\"err\">⟧</span> <span class=\"err\">∈</span> <span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">edges</span> <span class=\"err\">&#39;&#39;</span> <span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">univ</span><span class=\"o\">,</span>\n  <span class=\"n\">sym</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">G</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">rwa</span> <span class=\"n\">sym2</span><span class=\"bp\">.</span><span class=\"n\">eq_swap</span><span class=\"o\">,</span>\n  <span class=\"n\">loopless</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">G</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"k\">begin</span>\n    <span class=\"n\">rintro</span> <span class=\"bp\">⟨</span><span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">loopless</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">use</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">refl</span><span class=\"o\">,</span>\n  <span class=\"kn\">end</span> <span class=\"o\">}</span>\n</code></pre></div>\n\n\n<p>Now we can talk about subgraphs of a <code>simple_graph'</code>.</p>",
        "id": 206774158,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1597284590
    },
    {
        "content": "<p>You can also go on to prove that subgraphs form a complete lattice, as do simple graphs on a particular vertex set.  (Though you can't prove that for <code>simple_graph'</code> in a nice way because of the <code>edges</code> map.)</p>",
        "id": 206774335,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1597284830
    },
    {
        "content": "<p>we appear to be discussing how to implement subgraphs</p>",
        "id": 206775710,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597286564
    },
    {
        "content": "<p>how did we get here?</p>",
        "id": 206775711,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597286567
    },
    {
        "content": "<p>We should for sure have a function that sends a subgraph to a graph structure on a subtype, but does this require changing our definition of <code>simple_graph</code> at all?</p>",
        "id": 206775798,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597286671
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"252300\">Jalex Stark</span> <a href=\"#narrow/stream/252551-graph-theory/topic/graph.20defs/near/206772722\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"302826\">Aaron Anderson</span> <a href=\"#narrow/stream/252551-graph-theory/topic/graph.20defs/near/206771653\">said</a>:</p>\n<blockquote>\n<p>Why didn’t I make simple_graph extend rel?</p>\n</blockquote>\n<p>i remember talking you out of it but not why</p>\n</blockquote>\n<p>oops turns out <code>rel</code> isn't a structure</p>",
        "id": 206776347,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597287616
    },
    {
        "content": "<p>Spitballing some of the different definitions and how they could relate to each other: </p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">ext</span><span class=\"o\">]</span> <span class=\"kn\">structure</span> <span class=\"n\">simple_graph</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">adj</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">sym</span> <span class=\"o\">:</span> <span class=\"n\">symmetric</span> <span class=\"n\">adj</span> <span class=\"bp\">.</span> <span class=\"n\">obviously</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">loopless</span> <span class=\"o\">:</span> <span class=\"n\">irreflexive</span> <span class=\"n\">adj</span> <span class=\"bp\">.</span> <span class=\"n\">obviously</span><span class=\"o\">)</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">ext</span><span class=\"o\">]</span> <span class=\"kn\">structure</span> <span class=\"n\">multigraph</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">vertices_of</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">→</span> <span class=\"n\">finset</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">two_vertices</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">E</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">vertices_of</span> <span class=\"n\">e</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"bp\">.</span> <span class=\"n\">obviously</span><span class=\"o\">)</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">ext</span><span class=\"o\">]</span> <span class=\"kn\">structure</span> <span class=\"n\">hypergraph</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">edges</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">finset</span> <span class=\"n\">V</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">card_edge</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">V</span><span class=\"o\">,</span> <span class=\"n\">e</span> <span class=\"err\">∈</span> <span class=\"n\">edges</span> <span class=\"bp\">→</span> <span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"o\">)</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">V</span><span class=\"o\">}</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">simple_graph</span>\n<span class=\"n\">def</span> <span class=\"n\">to_multigraph</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">multigraph</span> <span class=\"n\">V</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">E</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">V</span> <span class=\"bp\">//</span> <span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"bp\">∧</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">),</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">e</span> <span class=\"bp\">∧</span> <span class=\"n\">y</span> <span class=\"err\">∈</span> <span class=\"n\">e</span> <span class=\"bp\">∧</span> <span class=\"n\">x</span> <span class=\"bp\">≠</span> <span class=\"n\">y</span> <span class=\"bp\">→</span> <span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">adj</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">},</span>\n  <span class=\"n\">vertices_of</span> <span class=\"o\">:=</span> <span class=\"n\">subtype</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"o\">}</span>\n\n<span class=\"kn\">instance</span> <span class=\"n\">has_coe_to_multigraph</span> <span class=\"o\">:</span> <span class=\"n\">has_coe</span> <span class=\"o\">(</span><span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">multigraph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">coe</span> <span class=\"o\">:=</span> <span class=\"n\">simple_graph</span><span class=\"bp\">.</span><span class=\"n\">to_multigraph</span> <span class=\"o\">}</span>\n\n<span class=\"n\">def</span> <span class=\"n\">to_hypergraph</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">hypergraph</span> <span class=\"mi\">2</span> <span class=\"n\">V</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">edges</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">e</span> <span class=\"bp\">|</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">),</span> <span class=\"n\">e</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">}</span> <span class=\"bp\">∧</span> <span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">adj</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">},</span>\n  <span class=\"n\">card_edge</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">e</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"o\">{</span> <span class=\"n\">rcases</span> <span class=\"n\">h</span> <span class=\"k\">with</span> <span class=\"bp\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"n\">xy</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">card_insert_of_not_mem</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">mem_singleton</span><span class=\"o\">,</span> <span class=\"n\">intro</span> <span class=\"n\">con</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"n\">con</span> <span class=\"n\">at</span> <span class=\"n\">xy</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">loopless</span> <span class=\"n\">y</span> <span class=\"n\">xy</span><span class=\"o\">,</span> <span class=\"o\">}}</span>\n\n<span class=\"kn\">instance</span> <span class=\"n\">has_coe_to_hypergraph</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">has_coe</span> <span class=\"o\">(</span><span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hypergraph</span> <span class=\"mi\">2</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">coe</span> <span class=\"o\">:=</span> <span class=\"n\">simple_graph</span><span class=\"bp\">.</span><span class=\"n\">to_hypergraph</span> <span class=\"o\">}</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">simple_graph</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">multigraph</span>\n<span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">multigraph</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">- Allows us to refer to a vertex being a member of an edge. -/</span>\n<span class=\"kn\">instance</span> <span class=\"n\">has_mem</span> <span class=\"o\">:</span> <span class=\"n\">has_mem</span> <span class=\"n\">V</span> <span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">E</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">mem</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">v</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">v</span> <span class=\"err\">∈</span> <span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">vertices_of</span> <span class=\"n\">e</span> <span class=\"o\">}</span>\n\n<span class=\"n\">def</span> <span class=\"n\">multigraph</span><span class=\"bp\">.</span><span class=\"n\">to_simple_graph</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">multigraph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">adj</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">E</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"err\">∈</span> <span class=\"n\">e</span> <span class=\"bp\">∧</span> <span class=\"n\">b</span> <span class=\"err\">∈</span> <span class=\"n\">e</span> <span class=\"bp\">∧</span> <span class=\"n\">a</span> <span class=\"bp\">≠</span> <span class=\"n\">b</span> <span class=\"o\">}</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">multigraph</span>\n</code></pre></div>",
        "id": 206779548,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597292591
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"302826\">Aaron Anderson</span> <a href=\"#narrow/stream/252551-graph-theory/topic/graph.20defs/near/206775711\">said</a>:</p>\n<blockquote>\n<p>how did we get here?</p>\n</blockquote>\n<p>Mathematicians speak about subobjects as if they are objects all the time.  We should set things up so we can do this in Lean, too, if it's possible.  The way I've demonstrated is the only reasonable way I've found to get this to work, given Lean's features, and given my experiments it seems to work quite well.  (If <code>G</code> is a graph and <code>G' : subgraph G</code>, then wouldn't you want to be able to write <code>v : V G'</code> and <code>degree v</code>?  This is what the technique lets you do.)</p>\n<p>Other algebraic structures in Lean have the nice property that there is some single type of terms that satisfy some axioms, but (multi)graphs unfortunately have two types: vertices and edges.  Because they use only a single type, you can refer to the type as if it were the algebraic structure itself (synecdoche).  For example, if <code>G' : subgroup G</code> for <code>G</code> a group, then because of Lean's automatic coercions, you can write <code>x y : G'</code> and then write <code>x * y</code> to use the subgroup's inherited group operation.  The trick the implementation uses is that <code>coe_to_sort (subgroup G)</code> is given a <code>group</code> instance, so class resolution can find how to multiply <code>x</code> and <code>y</code>.  This sort of trick does not seem to apply directly to the case of graphs because there is no place automatic coersion might happen.</p>\n<p>In principle, the way the group typeclass could have worked out is to declare that a given type consists of groups.  I think about it like you are declaring that a type is the set of objects of a category with a given property (neglecting, for now, the morphisms).  It's like you're pulling the typeclass back a level, so to speak, to the indexing set.  A benefit is that you can now have structures containing multiple types, the composite of which can be referred to by a letter (like being able to refer to a graph <code>G</code> rather than having a <code>V</code> and <code>E</code> floating around).  You can still define <code>coe_to_sort</code> instances if you want one of the sets to be primary.</p>\n<p>Subgraphs are just one example of a type of graphs.  Another substructure-like thing is graph minors, and this technique seems to let you define a type of all minors on a given graph, where each term may be regarded as a graph itself.</p>\n<blockquote>\n<p>but does this require changing our definition of <code>simple_graph</code> at all?</p>\n</blockquote>\n<p>No, it wouldn't, other than maybe lifting definitions and lemmas up to <code>simple_graphs</code>.  I'm not particularly motivated to change anything in the short term regarding this, but I figured I'd make a case for a seemingly workable design in case anyone wants to deal with subgraphs of simple graphs.</p>\n<p>Regarding the spitballed definitions, I worry about using quotient-based definitions for multigraphs.  One of the earliest definitions I used was, essentially, <code>vertices_of : E -&gt; sym2 V</code>, which should be simpler in some ways because of the image is, effectively, a quotient of a subtype rather than a subtype of quotients.  (By the way, <code>finset</code> is not correct because multigraphs can have self-loops; one fix is to make <code>two_vertices</code> say the cardinality is 1 or 2, and other is to use <code>multiset</code> instead).  However, <code>sym2</code> is still a quotient.  Switching to another definition that doesn't involve quotients (I've posted variations to Zulip a few times and the paper it's based on) seems to reduce the sizes of proofs by an appreciable amount.</p>\n<p>Take a look at <code>sym2.sym2_equiv_sym</code>, which is part of the proof that <code>sym2</code> is equivalent to cardinality-two multisets.  Granted, this only needs to be done once, but it's oddly complicated and makes me worried that similar problems would be pervasive for graph theory theorems that don't deal with hypergraphs.</p>\n<p>Yet another multigraph definition that is especially convenient for proving things like the degree-sum formula, is</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">structure</span> <span class=\"n\">multigraph</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">D</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">dart_opp</span> <span class=\"o\">:</span> <span class=\"n\">D</span> <span class=\"bp\">→</span> <span class=\"n\">D</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">dart_opp_inv</span> <span class=\"o\">:</span> <span class=\"n\">function</span><span class=\"bp\">.</span><span class=\"n\">involutive</span> <span class=\"n\">dart_opp</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">dart_vert</span> <span class=\"o\">:</span> <span class=\"n\">D</span> <span class=\"bp\">→</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">dart_edge</span> <span class=\"o\">:</span> <span class=\"n\">D</span> <span class=\"bp\">→</span> <span class=\"n\">E</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">dart_edge_surj</span> <span class=\"o\">:</span> <span class=\"n\">function</span><span class=\"bp\">.</span><span class=\"n\">surjective</span> <span class=\"n\">dart_edge</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">two_to_one</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">D</span><span class=\"o\">),</span> <span class=\"n\">dart_edge</span> <span class=\"n\">d</span> <span class=\"bp\">=</span> <span class=\"n\">dart_edge</span> <span class=\"o\">(</span><span class=\"n\">dart_opp</span> <span class=\"n\">d</span><span class=\"o\">))</span>\n</code></pre></div>\n\n\n<p>A <em>dart</em> is one of the two ends of an edge.  Or you can think of it as one of the two possible orientations of an edge.  This is a combinatorial map that has forgotten its vertex rotation.  (I'm partial to this definition because it's one step away from combinatorial maps, which would then immediately give us the definition of planar embeddings of (connected) graphs.)</p>",
        "id": 206787837,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1597304086
    },
    {
        "content": "<p>I just realized another perspective on this: if you have a structure <code>X</code> and a number of <code>has_coe a X</code> instances for varying <code>a</code>, perhaps it is better to define the structure as a class parameterized by <code>a</code> so you don't have to have coercion arrows everywhere.  This is exactly what the <code>simple_graphs</code> example is doing.</p>",
        "id": 206788042,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1597304331
    },
    {
        "content": "<p>A thing I find awkward about it is that there is always the tautological instance, since the class is a good enough definition in its own right.  Before, I was using <code>simple_graph</code> as the tautological instance, but you could also use <code>simple_graphs</code> itself, since a class is just a structure with the <code>@[class]</code> attribute.</p>",
        "id": 206788217,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1597304510
    },
    {
        "content": "<p>Beyond all the coercion arrows, I remember another awkwardness when I had tried the <code>has_coe</code> route earlier in the summer.  It's that when you have subgraphs and want to treat them as graphs parameterized by a vertex type, you have to specify the vertex type in the instance's type, and that makes it more difficult as a user of the API to get the class resolution to find the coercion.  This isn't an issue when the vertex type is not parameterized, but then that leads to a new fun issue that universe inference stops working as well.</p>",
        "id": 206788687,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1597304918
    },
    {
        "content": "<p>It's worth of course looking at how groups and subgroups are defined, to see the mathlib standard practice of how to deal with the sub-object problem, since this is a question others have already thought about in detail</p>",
        "id": 206808773,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1597321921
    },
    {
        "content": "<p>The second paragraph in what I wrote is about how mathlib deals with subobjects of things like groups.  The issue is that a group is referred to by the type of its elements (i.e., let G be a group and g an element of G), but a graph consists of two types (i.e., let G be a graph, v a vertex in V(G) and e and edge in E(G)).  Mathlib uses a trick involving <code>coe_to_sort</code> and class resolution so that subgroups are groups, too.  This trick does not apply to graphs, as far as I can tell: a group is a type, a graph is a term.</p>",
        "id": 206845409,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1597340112
    },
    {
        "content": "<p>I don't have much to say but I'd also like to throw in my vote in favor of treating subgraphs as their own objects lol</p>",
        "id": 206863900,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1597349274
    },
    {
        "content": "<p>That's something I was trying to do with my definition of subgraph/induced subgraph</p>",
        "id": 206864004,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1597349303
    },
    {
        "content": "<p>I've posted a message to #general about the subobject problem, and hopefully the experts will weigh in.  Ideally, if <code>G : graph</code> and <code>G' : subgraph G</code>, then you can use <code>G'</code> as if it were a graph.  For instance, write <code>degree v</code> for <code>v : V G'</code>.</p>",
        "id": 206864617,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1597349562
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"252300\">@Jalex Stark</span> <span class=\"user-mention\" data-user-id=\"302826\">@Aaron Anderson</span> As an experiment, I redid the simple graph interface so that subgraphs of simple graphs are simple graphs, too. It's in mathlib:simple_graphs (see <a href=\"https://github.com/leanprover-community/mathlib/blob/simple_graphs/src/combinatorics/simple_graph.lean\">https://github.com/leanprover-community/mathlib/blob/simple_graphs/src/combinatorics/simple_graph.lean</a>)</p>\n<p>I'd appreciate it if anyone might take it for a spin and see if anything goes wrong with the interface.  One change you have to make to use it is to not use dot notation since it's, unfortunately, not supported without some hacks.  Another is that you need <code>V G</code> rather than declaring the vertex type.</p>\n<p>There are potentially too many implicit arguments, but I have not run into issues myself yet.  Implicit arguments relieve us of the need to even mention <code>G</code>, for example in <code>degree v</code> for <code>v : V G</code>.  This uses the trick that <code>v</code> knows it's from a graph <code>G</code> because it is in its type.  Similar things go for <code>neighbor_set v</code> rather than <code>G.neighbor_set v</code>.</p>\n<p>The commit defines subgraphs, induced subgraphs, and the bounded lattice of subgraphs.  To construct a subgraph from a relation, you can use <code>simple_graph.from_rel</code> if you want, but the intended use is to write something like</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">simple_graphs</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n</code></pre></div>\n\n\n<p>to get an arbitrary simple graph <code>G</code>.  (There is a vague resemblance to section 3 of the paper <a href=\"https://hal.inria.fr/hal-00825074v1/document\">https://hal.inria.fr/hal-00825074v1/document</a> here.)</p>\n<p>If you want, you can declare</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">local</span> <span class=\"kn\">infix</span> <span class=\"bp\">`</span> <span class=\"bp\">~</span> <span class=\"bp\">`</span> <span class=\"o\">:=</span> <span class=\"n\">adj_rel</span>\n</code></pre></div>\n\n\n<p>to use <code>v ~ w</code> for the vertex adjacency relation for <code>v w : V G</code>.  (This uses <code>adj_rel</code> instead of <code>adj G</code> because of some implicit argument handling...)</p>",
        "id": 206889775,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1597368064
    },
    {
        "content": "<p>(One thing I've noticed is that it seems like it'll take some more work so that you can compare the degrees of a vertex relative to two different subgraphs.)</p>",
        "id": 206890469,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1597368923
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/252551-graph-theory/topic/graph.20defs/near/206845409\">said</a>:</p>\n<blockquote>\n<p>The second paragraph in what I wrote is about how mathlib deals with subobjects of things like groups.  The issue is that a group is referred to by the type of its elements (i.e., let G be a group and g an element of G), but a graph consists of two types (i.e., let G be a graph, v a vertex in V(G) and e and edge in E(G)).  Mathlib uses a trick involving <code>coe_to_sort</code> and class resolution so that subgroups are groups, too.  This trick does not apply to graphs, as far as I can tell: a group is a type, a graph is a term.</p>\n</blockquote>\n<p>You're correct of course - I should have read your messages more carefully!</p>",
        "id": 206951742,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1597424282
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"252300\">@Jalex Stark</span> <span class=\"user-mention\" data-user-id=\"302826\">@Aaron Anderson</span> Ok, here's my newest solution to the \"synecdoche problem.\"  I haven't really been happy with any of my proposals so far, hence all the discussion, but I think this one might finally be something that doesn't feel weird:</p>\n<p><a href=\"https://github.com/leanprover-community/mathlib/blob/simple_graphs2/src/combinatorics/simple_graph.lean\">https://github.com/leanprover-community/mathlib/blob/simple_graphs2/src/combinatorics/simple_graph.lean</a></p>\n<p>It's surprisingly simple:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">class</span> <span class=\"n\">simple_graph</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">adj</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">symm</span> <span class=\"o\">:</span> <span class=\"n\">symmetric</span> <span class=\"n\">adj</span> <span class=\"bp\">.</span> <span class=\"n\">obviously</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">loopless</span> <span class=\"o\">:</span> <span class=\"n\">irreflexive</span> <span class=\"n\">adj</span> <span class=\"bp\">.</span> <span class=\"n\">obviously</span><span class=\"o\">)</span>\n</code></pre></div>\n\n\n<p>You just say that a <em>term</em> has a <code>simple_graph</code> instance.  From then on you can write <code>V G</code> and so on.  This lets you define <code>simple_graph</code> instances for subgraphs easily:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">structure</span> <span class=\"n\">subgraph</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">V&#39;</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"n\">G</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">E&#39;</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">sym2</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"n\">G</span><span class=\"o\">)))</span>\n<span class=\"o\">(</span><span class=\"n\">edge_sub</span> <span class=\"o\">:</span> <span class=\"n\">E&#39;</span> <span class=\"err\">⊆</span> <span class=\"n\">edge_set</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">has_verts</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"err\">∈</span> <span class=\"n\">E&#39;</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"err\">∈</span> <span class=\"n\">e</span><span class=\"o\">),</span> <span class=\"n\">v</span> <span class=\"err\">∈</span> <span class=\"n\">V&#39;</span><span class=\"o\">)</span>\n\n<span class=\"kn\">instance</span> <span class=\"n\">subgraph</span><span class=\"bp\">.</span><span class=\"n\">simple_graph</span> <span class=\"o\">(</span><span class=\"n\">G&#39;</span> <span class=\"o\">:</span> <span class=\"n\">subgraph</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">G&#39;</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">V</span> <span class=\"o\">:=</span> <span class=\"n\">G&#39;</span><span class=\"bp\">.</span><span class=\"n\">V&#39;</span><span class=\"o\">,</span>\n  <span class=\"n\">adj</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"err\">⟦</span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"o\">,</span> <span class=\"n\">w</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"o\">)</span><span class=\"err\">⟧</span> <span class=\"err\">∈</span> <span class=\"n\">G&#39;</span><span class=\"bp\">.</span><span class=\"n\">E&#39;</span><span class=\"o\">,</span>\n  <span class=\"n\">symm</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">rwa</span> <span class=\"n\">sym2</span><span class=\"bp\">.</span><span class=\"n\">eq_swap</span><span class=\"o\">,</span>\n  <span class=\"n\">loopless</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"bp\">⟨</span><span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"bp\">_⟩</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">loopless</span> <span class=\"n\">v</span> <span class=\"o\">(</span><span class=\"n\">sym2</span><span class=\"bp\">.</span><span class=\"n\">from_rel_prop</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"o\">(</span><span class=\"n\">G&#39;</span><span class=\"bp\">.</span><span class=\"n\">edge_sub</span> <span class=\"n\">h</span><span class=\"o\">))</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 206961475,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1597429787
    },
    {
        "content": "<p>(Getting this right for simple graphs seems like a good test bed for other combinatorial objects that have subobjects and other derived objects.)</p>",
        "id": 206961635,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1597429860
    },
    {
        "content": "<p>(I feel really busy, but i've set myself a calendar event to give this a hard look tomorrow.)<br>\nI've gotten as far as being confused about which lines of code lead to  <code>V G</code> being the type of vertices of <code>G</code>. If whatever magic this is also makes it easier to talk about subgraphs, I'll be pretty happy with it :)</p>",
        "id": 206985275,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1597441253
    },
    {
        "content": "<p>I think I prefer this to the <code>simple_graphs</code> type, but I have another potentially dumb question:<br>\nWhy is this better than defining </p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">class</span> <span class=\"n\">simple_graph</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">adj</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">symm</span> <span class=\"o\">:</span> <span class=\"n\">symmetric</span> <span class=\"n\">adj</span> <span class=\"bp\">.</span> <span class=\"n\">obviously</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">loopless</span> <span class=\"o\">:</span> <span class=\"n\">irreflexive</span> <span class=\"n\">adj</span> <span class=\"bp\">.</span> <span class=\"n\">obviously</span><span class=\"o\">)</span>\n</code></pre></div>\n\n\n<p>and then just talking about <code>G.V</code> instead of <code>V G</code>?</p>",
        "id": 206985479,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597441401
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"252300\">@Jalex Stark</span>  Thanks -- I know how busy everyone is and how it can be a hard to find time to evaluate other people's work!</p>",
        "id": 206985514,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1597441437
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"302826\">@Aaron Anderson</span> That's a class with no parameters, right? How would you ever define instances?</p>\n<p>(Are there tricks to make <code>G.V</code> work? I think it only works if <code>G</code> has a type in the <code>simple_graph</code> namespace, but I could be wrong.  I've been trying hard to find <em>some</em> way to make it work...)</p>",
        "id": 206985661,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1597441532
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"252300\">Jalex Stark</span> <a href=\"#narrow/stream/252551-graph-theory/topic/graph.20defs/near/206985275\">said</a>:</p>\n<blockquote>\n<p>I've gotten as far as being confused about which lines of code lead to  <code>V G</code> being the type of vertices of <code>G</code>.</p>\n</blockquote>\n<p>The type of <code>simple_graph.V</code> is <code>Π {α : Type u} (G : α) [c : simple_graph G], Type v</code>.  The <code>G</code> parameter is automatically explicit because <code>V</code> needs to depend on something.</p>",
        "id": 206985951,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1597441746
    },
    {
        "content": "<p>Oh, thanks. I thought <code>V : Type u</code> but in fact it's something like <code>simple_graph.V : simple_graph \\to Type u</code></p>",
        "id": 206989939,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1597444591
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/252551-graph-theory/topic/graph.20defs/near/206985661\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"302826\">Aaron Anderson</span> That's a class with no parameters, right? How would you ever define instances?</p>\n<p>(Are there tricks to make <code>G.V</code> work? I think it only works if <code>G</code> has a type in the <code>simple_graph</code> namespace, but I could be wrong.  I've been trying hard to find <em>some</em> way to make it work...)</p>\n</blockquote>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">class</span> <span class=\"n\">simple_graph</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">adj</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">symm</span> <span class=\"o\">:</span> <span class=\"n\">symmetric</span> <span class=\"n\">adj</span> <span class=\"bp\">.</span> <span class=\"n\">obviously</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">loopless</span> <span class=\"o\">:</span> <span class=\"n\">irreflexive</span> <span class=\"n\">adj</span> <span class=\"bp\">.</span> <span class=\"n\">obviously</span><span class=\"o\">)</span>\n\n<span class=\"kn\">variable</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n\n<span class=\"n\">def</span> <span class=\"n\">complete_graph</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨</span><span class=\"n\">V</span><span class=\"o\">,</span> <span class=\"n\">ne</span><span class=\"bp\">⟩</span>\n</code></pre></div>",
        "id": 206993693,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597448423
    },
    {
        "content": "<p>I'm not sure how you'd say that every <code>subgraph</code> is a  <code>simple_graph</code>.  It looks like you're using a <code>class</code> as a <code>structure</code> here (which works because <code>class</code> is shorthand to declare a <code>structure</code> with the <code>class</code> attribute).</p>",
        "id": 206994357,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1597449258
    },
    {
        "content": "<p>I think I see what you mean</p>",
        "id": 206997577,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597453055
    },
    {
        "content": "<p>To be sure, do we really want one definition of subgraphs?</p>",
        "id": 206997644,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597453142
    },
    {
        "content": "<p>We want an <code>induced_subgraph</code> function for sure</p>",
        "id": 206997657,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597453166
    },
    {
        "content": "<p>But maybe then we just want a type for subgraphs on V</p>",
        "id": 206997716,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597453227
    },
    {
        "content": "<p>I'm not sure we want only a single definition -- I'd like to keep options open so that any number of derived objects can be defined.  However, what I was thinking about <code>induced_subgraph</code> is that it tends to be used within the lattice of subgraphs, so I made it a subgraph.</p>",
        "id": 206997728,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1597453254
    },
    {
        "content": "<p>That is, just changing the edge relation</p>",
        "id": 206997733,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597453264
    },
    {
        "content": "<p>The type for graphs on <code>V</code> is <code>subgraph (complete_graph V)</code>, I think</p>",
        "id": 206997794,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1597453324
    },
    {
        "content": "<p>Whether that's the best way to deal with it, I'm not sure, but at least that means it's a bounded lattice.</p>",
        "id": 206997817,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1597453381
    },
    {
        "content": "<p>Oh, I'm wrong.  You'd want <code>spanning_subgraph (complete_graph V)</code></p>",
        "id": 206997828,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1597453410
    },
    {
        "content": "<p>where a <code>spanning_subgraph</code> is a subgraph that contains all the vertices.  These are used in the definition of Tutte polynomials.</p>",
        "id": 206997886,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1597453450
    },
    {
        "content": "<p>Yeah, I guess what I’m asking for is whether we really want <code>subgraph</code> or just <code>spanning_subgraph</code></p>",
        "id": 206997887,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597453453
    },
    {
        "content": "<p>I'm under the impression that subgraphs with varying vertex sets are important, so I'd lean toward eventually having both.</p>",
        "id": 206997896,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1597453494
    },
    {
        "content": "<p>But I'm not sure.  The theorems will guide the way.</p>",
        "id": 206997920,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1597453557
    },
    {
        "content": "<p>Maybe what you're saying is that because every graph is a subgraph of the complete graph with the same vertex set, maybe subgraphs should always be within that particular bounded lattice?</p>",
        "id": 206998069,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1597453706
    },
    {
        "content": "<p>though I could imagine having the lattice have a specific <code>top</code> might be useful</p>",
        "id": 206998089,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1597453751
    },
    {
        "content": "<p>I meant that I would imagine having a <code>subgraph</code> type that’s actually <code>spanning_subgraph</code>, and any time we need the other kind, we talk about <code>{s: set G} subgraph s</code></p>",
        "id": 206998510,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597454318
    },
    {
        "content": "<p>No idea if this actually works until we have theorems about subgraphs to prove</p>",
        "id": 206998518,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597454339
    },
    {
        "content": "<p>And inductions to do</p>",
        "id": 206998523,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597454345
    },
    {
        "content": "<p>Oh right, this is why <code>subgraph G</code> is important as-is.  There are inductions where you add individual vertices or edges.</p>",
        "id": 206998577,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1597454412
    },
    {
        "content": "<p>and there are probably others where you only induct on adding edges, so you'd want <code>spanning_subgraph G</code> for that</p>",
        "id": 206998586,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1597454450
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"302826\">@Aaron Anderson</span> On this test branch, I added <code>incident_set</code> and showed it was equivalent to <code>neighbor_set</code>, hence they have the same cardinality, if you want to try incidence matrices again.  <a href=\"https://github.com/leanprover-community/mathlib/blob/simple_graphs2/src/combinatorics/simple_graph.lean#L106\">https://github.com/leanprover-community/mathlib/blob/simple_graphs2/src/combinatorics/simple_graph.lean#L106</a>  There's also <code>incident_finset</code>, but I haven't added any lemmas connecting it to <code>incident_set</code>.</p>\n<p>(This involved adding a decidable version of <code>sym2.mem.other</code> called <code>sym2.mem.other'</code>.  <span class=\"user-mention\" data-user-id=\"252300\">@Jalex Stark</span> if you want to code golf something you could take a look at that <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span>.  I'm thinking of removing <code>vmem</code> from <code>sym2</code> because it is extremely specialized compared to <code>sym2.mem.other'</code>.  Being able to prove <code>other'</code> is well-defined was outside my capabilities back when I defined <code>vmem</code>.)</p>\n<p>By the way, Jalex, what sorts of edge set cardinality issues are there?  I remember you mentioning something about that.</p>",
        "id": 207037849,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1597523252
    },
    {
        "content": "<p>This <code>simple_graphs2</code> branch now has the degree-sum formula and a number of new <code>sym2</code> lemmas to help out.  The degree-sum formula is mostly combinatorial in the sense that there is a new type, <code>darts</code>, with one term per orientation of each edge, and then each intermediate equality comes from some kind of bijection with this (I didn't explicitly construct these bijections all the time, though).</p>\n<p>This is what the statement looks like:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">simple_graph</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"n\">G</span><span class=\"o\">)]</span>\n<span class=\"c1\">-- and some decidable instances (not needed for classical locale)</span>\n<span class=\"kn\">variables</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"n\">G</span><span class=\"o\">)]</span> <span class=\"o\">[</span><span class=\"n\">decidable_rel</span> <span class=\"o\">(</span><span class=\"n\">adj_rel</span> <span class=\"n\">G</span><span class=\"o\">)]</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">degree_sum</span> <span class=\"o\">:</span> <span class=\"err\">∑</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"n\">degree</span> <span class=\"n\">v</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">edge_finset</span> <span class=\"n\">G</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">card</span>\n</code></pre></div>\n\n\n<p><a href=\"https://github.com/leanprover-community/mathlib/blob/simple_graphs2/src/combinatorics/simple_graph.lean#L686\">https://github.com/leanprover-community/mathlib/blob/simple_graphs2/src/combinatorics/simple_graph.lean#L686</a></p>\n<p>(<span class=\"user-mention\" data-user-id=\"246273\">@Bhavik Mehta</span> I think I remember you mentioning you had a proof of this for simple graphs. Maybe you might be interested in helping to refactor this one?)</p>",
        "id": 207096961,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1597623831
    },
    {
        "content": "<p>I think a path to getting a definitive answer about the right graph definition, without having to hold quite so much of a subjective notion about what's easy to program with in one's head, goes like:<br>\nImplement <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\"> n </annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> different APIs and prove that they are all equivalent. We should be able to extract a lot of information from the knowledge of which translations are hardest.</p>",
        "id": 207199012,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1597699377
    },
    {
        "content": "<p>Also \"write the translations\" is parallelizable (I guess you expect there to be like <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\"> n \\log n</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> of them), so maybe we get more of a return to the existence of this stream.</p>",
        "id": 207199130,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1597699477
    },
    {
        "content": "<p>I guess this is a special case of an idea of Mario, where \"graphs API\" is substituted with \"entire theorem-provers\"</p>",
        "id": 207199155,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1597699509
    },
    {
        "content": "<p>I guess Kyle had a neat idea on how to make a central simple_graph type together with a class <code>has_coe_to_simple_graph</code> which links graph implementations to graphs.</p>",
        "id": 207215857,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1597714695
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/252551-graph-theory/topic/graph.20defs/near/207096961\">said</a>:</p>\n<blockquote>\n<p>(<span class=\"user-mention silent\" data-user-id=\"246273\">Bhavik Mehta</span> I think I remember you mentioning you had a proof of this for simple graphs. Maybe you might be interested in helping to refactor this one?)</p>\n</blockquote>\n<p>Sure I can help out if needed but I'm pretty busy at the minute so I can't promise much</p>",
        "id": 207216210,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1597715180
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"252300\">Jalex Stark</span> <a href=\"#narrow/stream/252551-graph-theory/topic/graph.20defs/near/207215857\">said</a>:</p>\n<blockquote>\n<p>I guess Kyle had a neat idea on how to make a central simple_graph type together with a class <code>has_coe_to_simple_graph</code> which links graph implementations to graphs.</p>\n</blockquote>\n<p>To expand on this, the definition in the <code>simple_graphs2</code> branch sort of came out of the following design process.  Let's say you started with this definition of a simple graph:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">structure</span> <span class=\"n\">simple_graph</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">adj</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">symm</span> <span class=\"o\">:</span> <span class=\"n\">symmetric</span> <span class=\"n\">adj</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">loopless</span> <span class=\"o\">:</span> <span class=\"n\">irreflexive</span> <span class=\"n\">adj</span><span class=\"o\">)</span>\n</code></pre></div>\n\n\n<p>and then you define spanning subgraphs on a given graph (i.e., subgraphs with all the vertices) by something like</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">structure</span> <span class=\"n\">spanning_subgraph</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">adj</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">symm</span> <span class=\"o\">:</span> <span class=\"n\">symmetric</span> <span class=\"n\">adj</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">prop</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">),</span> <span class=\"n\">adj</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"bp\">→</span> <span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">adj</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">)</span>\n</code></pre></div>\n\n\n<p>One basic definition for simple graphs is the set of neighboring vertices:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">def</span> <span class=\"n\">neighbor_set</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">set_of</span> <span class=\"o\">(</span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">adj</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n</code></pre></div>\n\n\n<p>However, if you have a <code>spanning_subgraph G</code>, you cannot use <code>neighbor_set</code> directly -- you would need some coercion.  Let's define an interface for this.  While you could try using <code>has_coe</code>, there is a typeclass inference problem: <code>has_coe a b</code> is a function of both <code>a</code> and <code>b</code>, so you would need to specify type hints to get it to coerce correctly (plus, we won't gain any benefits from Lean's automatic coercion features).  This is not so bad for spanning subgraphs, but it is not so good for subgraphs since the vertex type needs to be referred to as the vertex subset coerced to a type.  To make it so <code>b</code> is a function of <code>a</code>, we can define our own coercion class:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">class</span> <span class=\"n\">has_coe_to_simple_graph</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">to_simple_graph</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">simple_graph</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"n\">G</span><span class=\"o\">))</span>\n</code></pre></div>\n\n\n<p>Then, for example,</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">instance</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">has_coe_to_simple_graph</span> <span class=\"o\">(</span><span class=\"n\">spanning_subgraph</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">V</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"n\">V</span><span class=\"o\">,</span>\n  <span class=\"n\">to_simple_graph</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">G&#39;</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">adj</span> <span class=\"o\">:=</span> <span class=\"n\">G&#39;</span><span class=\"bp\">.</span><span class=\"n\">adj</span><span class=\"o\">,</span>\n    <span class=\"n\">symm</span> <span class=\"o\">:=</span> <span class=\"n\">G&#39;</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">,</span>\n    <span class=\"n\">loopless</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">loopless</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">G&#39;</span><span class=\"bp\">.</span><span class=\"n\">prop</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">}</span> <span class=\"o\">}</span>\n</code></pre></div>\n\n\n<p>However, we cannot yet do <code>neighbor_set G' v</code> for <code>G' : spanning_subgraph G</code>, since it is not literally a graph.  Let's define some accessor functions to get some <code>simple_graph</code> fields for coerceable terms and use them to define the <code>neighbor_set</code>:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">has_coe_to_simple_graph</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n\n<span class=\"n\">def</span> <span class=\"n\">V</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">has_coe_to_simple_graph</span><span class=\"bp\">.</span><span class=\"n\">V</span> <span class=\"n\">G</span>\n<span class=\"n\">def</span> <span class=\"n\">adj</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">has_coe_to_simple_graph</span><span class=\"bp\">.</span><span class=\"n\">to_simple_graph</span> <span class=\"n\">G</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">adj</span>\n\n<span class=\"n\">def</span> <span class=\"n\">neighbor_set</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">set_of</span> <span class=\"o\">(</span><span class=\"n\">adj</span> <span class=\"n\">G</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n</code></pre></div>\n\n\n<p>While <code>spanning_subgraph G</code> is not a <code>simple_graph</code> <em>per se</em>, you can interact with it as if it were one.</p>\n<p>This might be an OK interface as it is, but there is a simplification to this.  If we were to take the fields of <code>simple_graph</code> and put them into <code>has_coe_to_simple_graph</code>, then we would have</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">class</span> <span class=\"n\">has_coe_to_simple_graph</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">adj</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">V</span> <span class=\"n\">G</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"n\">G</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">symm</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">symmetric</span> <span class=\"o\">(</span><span class=\"n\">adj</span> <span class=\"n\">G</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">loopless</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">irreflexive</span> <span class=\"o\">(</span><span class=\"n\">adj</span> <span class=\"n\">G</span><span class=\"o\">))</span>\n</code></pre></div>\n\n\n<p>This is the class <code>simple_graphs</code> that I had mentioned last week!  A weird thing about it, though, is how every field is a function.  What if we lifted the <code>G</code> argument out?  Let's also rename this class <code>simple_graph</code>.  We would obtain</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">class</span> <span class=\"n\">simple_graph</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">adj</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">symm</span> <span class=\"o\">:</span> <span class=\"n\">symmetric</span> <span class=\"n\">adj</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">loopless</span> <span class=\"o\">:</span> <span class=\"n\">irreflexive</span> <span class=\"n\">adj</span><span class=\"o\">)</span>\n</code></pre></div>\n\n\n<p>This is the definition in the <code>simple_graphs2</code> branch.  It is the result of  flattening the coercion class and the definition of the structure.  This lets us not have to redefine all the fields using accessor functions that depend on a coercion class: the members of this class <em>are</em> the accessor functions.  </p>\n<p>In the <code>has_coe_to_simple_graph</code> approach, note that to make things generic with respect to all things that are graph-like, lemmas and definitions would have to be in terms of the accessor functions anyway, so you would never refer to fields of <code>simple_graph</code>.  Thus, you lose nothing by folding it all in and defining this <code>simple_graph</code> class.</p>\n<p>One caveat is that to define a simple graph from a particular relation, you need a \"tautological\" instance:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">structure</span> <span class=\"n\">simple_graph_on</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">rel</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">symm</span> <span class=\"o\">:</span> <span class=\"n\">symmetric</span> <span class=\"n\">rel</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">irrefl</span> <span class=\"o\">:</span> <span class=\"n\">irreflexive</span> <span class=\"n\">rel</span><span class=\"o\">)</span>\n\n<span class=\"kn\">instance</span> <span class=\"n\">simple_graph_on</span><span class=\"bp\">.</span><span class=\"n\">simple_graph</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph_on</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">G</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">V</span> <span class=\"o\">:=</span> <span class=\"n\">V</span><span class=\"o\">,</span>\n  <span class=\"n\">adj</span> <span class=\"o\">:=</span> <span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">rel</span><span class=\"o\">,</span>\n  <span class=\"n\">symm</span> <span class=\"o\">:=</span> <span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">,</span>\n  <span class=\"n\">loopless</span> <span class=\"o\">:=</span> <span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">irrefl</span> <span class=\"o\">}</span>\n</code></pre></div>\n\n\n<p>Another caveat is that different graphs have vertex types that are referred to differently, even if the vertex types are definitionally equal.  For graphs on the same vertex type, you would probably want to use the type <code>simple_graph_on V</code>.  One could define a bounded lattice instance for this.</p>",
        "id": 207217832,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1597717526
    },
    {
        "content": "<p>Great write-up.</p>",
        "id": 207218436,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1597718513
    },
    {
        "content": "<p>This definition of graphs has some issues, but it's kind of amusing so I'll put it here.  It uses a bit of synecdoche, saying a graph <em>is</em> its adjacency relation.  To coerce something like a subgraph into being a graph, you use the <code>⇑</code> function coercion arrow.</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">class</span> <span class=\"n\">is_graph</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">adj</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">symm&#39;</span> <span class=\"o\">:</span> <span class=\"n\">symmetric</span> <span class=\"n\">adj</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">loopless&#39;</span> <span class=\"o\">:</span> <span class=\"n\">irreflexive</span> <span class=\"n\">adj</span><span class=\"o\">)</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">graph</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">accessors</span>\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">is_graph</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n\n<span class=\"n\">def</span> <span class=\"n\">adj</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">G</span> <span class=\"n\">v</span> <span class=\"n\">w</span>\n\n<span class=\"n\">def</span> <span class=\"n\">symm</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">is_graph</span><span class=\"bp\">.</span><span class=\"n\">symm&#39;</span> <span class=\"n\">V</span> <span class=\"n\">G</span>\n\n<span class=\"n\">def</span> <span class=\"n\">loopless</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">is_graph</span><span class=\"bp\">.</span><span class=\"n\">loopless&#39;</span> <span class=\"n\">V</span> <span class=\"n\">G</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">accessors</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"n\">def</span> <span class=\"n\">neighbor_set</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">is_graph</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">V</span> <span class=\"o\">:=</span> <span class=\"n\">set_of</span> <span class=\"o\">(</span><span class=\"n\">adj</span> <span class=\"n\">G</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">subgraphs</span>\n\n<span class=\"kn\">structure</span> <span class=\"n\">subgraph</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">is_graph</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">V&#39;</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">adj&#39;</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">adj_sub</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">⦃</span><span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">⦄,</span> <span class=\"n\">adj&#39;</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"bp\">→</span> <span class=\"n\">adj</span> <span class=\"n\">G</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">edge_vert</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">⦃</span><span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">⦄,</span> <span class=\"n\">adj&#39;</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"bp\">→</span> <span class=\"n\">v</span> <span class=\"err\">∈</span> <span class=\"n\">V&#39;</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">symm&#39;</span> <span class=\"o\">:</span> <span class=\"n\">symmetric</span> <span class=\"n\">adj&#39;</span><span class=\"o\">)</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">is_graph</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">has_coe_to_fun</span> <span class=\"o\">(</span><span class=\"n\">subgraph</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">F</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">G&#39;</span><span class=\"o\">,</span> <span class=\"n\">subtype</span> <span class=\"n\">G&#39;</span><span class=\"bp\">.</span><span class=\"n\">V&#39;</span> <span class=\"bp\">→</span> <span class=\"n\">subtype</span> <span class=\"n\">G&#39;</span><span class=\"bp\">.</span><span class=\"n\">V&#39;</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">,</span>\n  <span class=\"n\">coe</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">G&#39;</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"n\">G&#39;</span><span class=\"bp\">.</span><span class=\"n\">adj&#39;</span> <span class=\"n\">v</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"n\">w</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"o\">}</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">is_graph</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">G&#39;</span> <span class=\"o\">:</span> <span class=\"n\">subgraph</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">is_graph</span> <span class=\"n\">G&#39;</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">symm&#39;</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">G&#39;</span><span class=\"bp\">.</span><span class=\"n\">symm&#39;</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">loopless&#39;</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"bp\">⟨</span><span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"bp\">_⟩</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">loopless</span> <span class=\"n\">G</span> <span class=\"n\">v</span> <span class=\"o\">(</span><span class=\"n\">G&#39;</span><span class=\"bp\">.</span><span class=\"n\">adj_sub</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">subgraphs</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">graph</span>\n</code></pre></div>",
        "id": 208457417,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1598740738
    },
    {
        "content": "<p>but it seems to actually let you use a subgraph as if it were a graph:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">is_graph</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">G&#39;</span> <span class=\"o\">:</span> <span class=\"n\">subgraph</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">v</span> <span class=\"err\">∈</span> <span class=\"n\">G&#39;</span><span class=\"bp\">.</span><span class=\"n\">V&#39;</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">true</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"k\">let</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"n\">neighbor_set</span> <span class=\"n\">G&#39;</span> <span class=\"bp\">⟨</span><span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n</code></pre></div>\n\n\n<p>Lean automatically coerces <code>G'</code> into a function, so it's secretly <code>neighbor_set ⇑G' ⟨v, h⟩</code>.</p>",
        "id": 208457570,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1598740955
    },
    {
        "content": "<p>Isn't this the current situation with subgroups? You can use a subgroup as if it's a group.. I feel like I'm missing something here though</p>",
        "id": 208457802,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1598741287
    },
    {
        "content": "<p>Subgroups rely on <code>has_coe_to_sort</code> to work</p>",
        "id": 208457826,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1598741367
    },
    {
        "content": "<p>A curiosity (not related to the current discussion) is that nlab defines a graph as a set equipped with a symmetric reflexive relation, not a symmetric irreflexive relation!</p>",
        "id": 208457836,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1598741391
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/252551-graph-theory/topic/graph.20defs/near/208457826\">said</a>:</p>\n<blockquote>\n<p>Subgroups rely on <code>has_coe_to_sort</code> to work</p>\n</blockquote>\n<p>Sure, but you're using a coe to function instead to serve the same purpose?</p>",
        "id": 208457888,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1598741419
    },
    {
        "content": "<p>Exactly, it's something I hadn't thought about trying before</p>",
        "id": 208457891,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1598741432
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"246273\">Bhavik Mehta</span> <a href=\"#narrow/stream/252551-graph-theory/topic/graph.20defs/near/208457836\">said</a>:</p>\n<blockquote>\n<p>A curiosity (not related to the current discussion) is that nlab defines a graph as a set equipped with a symmetric reflexive relation, not a symmetric irreflexive relation!</p>\n</blockquote>\n<p>and this matters because it lets a quotient object in the category be a graph minor</p>",
        "id": 208457953,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1598741523
    },
    {
        "content": "<p>If Lean just had a way to let you define functions that auto-coerce an argument using a user-specified coercion typeclass, there'd be no need for this sort of hack</p>",
        "id": 208457955,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1598741526
    },
    {
        "content": "<p>Here, Lean knows that if an argument requires a function, then it'll try to coerce it for you using <code>has_coe_to_fun</code></p>",
        "id": 208457967,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1598741568
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"246273\">Bhavik Mehta</span> <a href=\"#narrow/stream/252551-graph-theory/topic/graph.20defs/near/208457836\">said</a>:</p>\n<blockquote>\n<p>A curiosity (not related to the current discussion) is that nlab defines a graph as a set equipped with a symmetric reflexive relation, not a symmetric irreflexive relation!</p>\n</blockquote>\n<p>Oh, I kept misreading this and now I understand what you're saying.  When you define it as irreflexive, then things like the neighborhood set in the graph theory sense are easy to define.  When it's a reflexive relation, you instead get what Bollobas defines to be the closed neighborhood set.</p>\n<p>Edge contractions certainly do not correspond to homomorphisms when they are defined as irreflexive relations...  You can change the definition of a homomorphism so that they do, but it's sort of ugly.</p>\n<p>In my research, I've been thinking of a generalization multigraphs as being like the usual multigraphs, except some edges are labeled as being contractible.  Two of these multigraphs are equivalent if they can be related by a sequence of contractions of contractible non-loop edges and deletions of contractible loop edges.  Then the operation of edge contraction corresponds to labeling an edge as contractible.  (This definition reduces to multigraphs with a special loop edge at each vertex, if you want.)  I was using this generalization for a few reasons, one being that both deletion and contraction are homomorphisms.</p>",
        "id": 208458567,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1598742571
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"246273\">Bhavik Mehta</span> <a href=\"#narrow/stream/252551-graph-theory/topic/graph.20defs/near/208457802\">said</a>:</p>\n<blockquote>\n<p>Isn't this the current situation with subgroups? You can use a subgroup as if it's a group.. I feel like I'm missing something here though</p>\n</blockquote>\n<p>But also, this new method is something to compare the <code>simple_graphs2</code> branch to.  There, I have subgraphs as graphs working just fine without needing any of these coercion hacks, though maybe it's less of a hack than I thought.</p>",
        "id": 208458701,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1598742782
    },
    {
        "content": "<p>Yeah, I was basically just describing the discussion <a href=\"https://ncatlab.org/nlab/show/graph+minor#categorical_pov\">here</a> which I hadn't considered before</p>",
        "id": 208458714,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1598742818
    },
    {
        "content": "<p>The other reason I was considering these graphs, by the way, is that you can define a symmetric monoidal category of multigraphs when you have these special contractible edges (objects are sets of points, morphisms are graphs between them).  You need contractible edges to have identity elements.  I haven't done enough with it, but I'm pretty sure you can define a 2-category of multigraphs in a similar way.  (I've been slowly writing a paper about these things, but then got distracted by Lean this summer...)</p>",
        "id": 208458943,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1598743140
    },
    {
        "content": "<p>Makes sense</p>",
        "id": 208459088,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1598743393
    },
    {
        "content": "<p>I found an interesting formalization of directed graphs in a gist by Nick Scheel here:<br>\n<a href=\"https://gist.github.com/MonoidMusician/1c8cc2ec787ebaf91b95d67cbc5c3498\">https://gist.github.com/MonoidMusician/1c8cc2ec787ebaf91b95d67cbc5c3498</a></p>\n<p>I adapted his gist to work with Lean 3.23.0 in a repo here:<br>\n<a href=\"https://github.com/NicolasRouquette/digraphs\">https://github.com/NicolasRouquette/digraphs</a></p>\n<p>As a newbie w/ lean, I ran into several questions: <a href=\"https://github.com/NicolasRouquette/digraphs#questions\">https://github.com/NicolasRouquette/digraphs#questions</a><br>\nI really would appreciate some guidance about this.</p>",
        "id": 215983435,
        "sender_full_name": "Nicolas Rouquette",
        "timestamp": 1604799857
    },
    {
        "content": "<p>For Q3, you can use <code>#print</code> to show the definition. <code>#check</code> only displays the type. Note that for definitions constructed using the equation compiler, you may see that the definition is just something like <code>blah._main1</code> and you'll have to do <code>#print blah._main1</code>, possibly a few times.</p>",
        "id": 216019318,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1604860729
    },
    {
        "content": "<p>Since it's decidable, an easy solution for Q1 is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">vt_mk</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">string</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">∈</span> <span class=\"n\">vs</span> <span class=\"bp\">.</span> <span class=\"n\">tactic.exact_dec_trivial</span><span class=\"o\">):</span> <span class=\"n\">vT</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span>\n<span class=\"kd\">def</span> <span class=\"n\">vt_a'</span> <span class=\"o\">:</span> <span class=\"n\">vT</span> <span class=\"o\">:=</span> <span class=\"n\">vt_mk</span> <span class=\"s2\">\"a\"</span>\n<span class=\"k\">#print</span> <span class=\"n\">vt_a'</span>\n</code></pre></div>\n<p>The binder style in <code>h</code> uses the tactic after the <code>.</code> to try and automatically make an argument of that type.</p>\n<p>Someone touched on Q2 in the thread in new_members, showing how to destructure subtypes with the equation compiler. I'm not sure why it doesn't like subtypes over strings, so I can't help with that.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">{</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">string</span> <span class=\"bp\">//</span> <span class=\"n\">s.length</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span> <span class=\"o\">}</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">bool</span>\n<span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"s2\">\"a\"</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">tt</span>\n<span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">ff</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">equation compiler failed (use 'set_option trace.eqn_compiler.elim_match true' for additional details)</span>\n<span class=\"cm\">nested exception message:</span>\n<span class=\"cm\">induction tactic failed, recursor 'or.dcases_on' can only eliminate into Prop</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>",
        "id": 216027670,
        "sender_full_name": "Chris B",
        "timestamp": 1604873062
    },
    {
        "content": "<p>Seems like you can work around it by just matching on the string after.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">phi2</span><span class=\"o\">:</span> <span class=\"n\">eT</span> <span class=\"bp\">→</span> <span class=\"n\">option</span> <span class=\"o\">(</span><span class=\"n\">arcT</span> <span class=\"n\">vT</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">s</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"s2\">\"e1\"</span> <span class=\"o\">:=</span> <span class=\"n\">some</span> <span class=\"bp\">$</span> <span class=\"n\">arc1</span>\n  <span class=\"bp\">|</span> <span class=\"s2\">\"e2\"</span> <span class=\"o\">:=</span> <span class=\"n\">some</span> <span class=\"bp\">$</span> <span class=\"n\">arc2</span>\n  <span class=\"bp\">|</span> <span class=\"s2\">\"e3\"</span> <span class=\"o\">:=</span> <span class=\"n\">some</span> <span class=\"bp\">$</span> <span class=\"n\">arc3</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">none</span>\n  <span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 216027786,
        "sender_full_name": "Chris B",
        "timestamp": 1604873277
    }
]
[
    {
        "content": "<p>Hi,</p>\n<p>So I rewrote a big part of what I had done on contractions in terms of pushforwards and pullbacks for graph structures, and I have questions about how to proceed. The pushforward operation for <code>simple_graph</code> is natural enough:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">push</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">V'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V'</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span>\n    <span class=\"n\">adj</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x'</span> <span class=\"n\">y'</span><span class=\"o\">,</span> <span class=\"n\">x'</span> <span class=\"bp\">≠</span> <span class=\"n\">y'</span> <span class=\"bp\">∧</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">x'</span> <span class=\"bp\">∧</span> <span class=\"n\">f</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">y'</span> <span class=\"bp\">∧</span> <span class=\"n\">G.adj</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span>\n    <span class=\"n\">symm</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x'</span> <span class=\"n\">y'</span> <span class=\"o\">⟨</span><span class=\"n\">h₀</span><span class=\"o\">,</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"n\">y</span><span class=\"o\">,</span><span class=\"n\">h₁</span><span class=\"o\">,</span><span class=\"n\">h₂</span><span class=\"o\">,</span><span class=\"n\">h₃</span><span class=\"o\">⟩,</span> <span class=\"o\">⟨</span><span class=\"n\">h₀.symm</span><span class=\"o\">,</span><span class=\"n\">y</span><span class=\"o\">,</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"n\">h₂</span><span class=\"o\">,</span><span class=\"n\">h₁</span><span class=\"o\">,</span><span class=\"n\">h₃.symm</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">loopless</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"o\">⟨</span><span class=\"n\">h₀</span><span class=\"o\">,</span><span class=\"n\">_</span><span class=\"o\">⟩,</span> <span class=\"n\">h₀</span> <span class=\"n\">rfl</span>\n<span class=\"o\">}</span>\n</code></pre></div>\n<p>(well, natural up to the presence of the <code>x' ≠ y'</code> which makes me feel that it would be more natural to push into a <code>graph</code> or <code>multigraph</code> and then restrict back to <code>simple_graph</code> but that will be for after the big transition). Then, a contraction is just a push by a function with connected cosets.</p>\n<p>On the other hand, for the pullback operation, there are two natural options, the first is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">pull</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">V'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">G'</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V'</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span>\n    <span class=\"n\">adj</span> <span class=\"o\">:=</span> <span class=\"n\">G'.adj</span> <span class=\"n\">on</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n    <span class=\"n\">symm</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">G'.symm</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">loopless</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">G'.loopless</span> <span class=\"n\">_</span>\n<span class=\"o\">}</span>\n</code></pre></div>\n<p>and the second is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">pull'</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">V'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">G'</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V'</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span>\n    <span class=\"n\">adj</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">≠</span> <span class=\"n\">y</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">y</span> <span class=\"bp\">∨</span> <span class=\"n\">G'.adj</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">y</span><span class=\"o\">)),</span>\n    <span class=\"n\">symm</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">⟨</span><span class=\"n\">h₁</span><span class=\"o\">,</span><span class=\"n\">h₂</span><span class=\"o\">⟩,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">h₁.symm</span><span class=\"o\">,</span><span class=\"n\">_</span><span class=\"o\">⟩,</span> <span class=\"n\">cases</span> <span class=\"n\">h₂</span><span class=\"o\">,</span> <span class=\"n\">left</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">h₂.symm</span><span class=\"o\">,</span> <span class=\"n\">right</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">h₂.symm</span> <span class=\"o\">},</span>\n    <span class=\"n\">loopless</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">push_neg</span><span class=\"o\">,</span> <span class=\"n\">intro</span><span class=\"o\">,</span> <span class=\"n\">contradiction</span> <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div>\n<p>(which is like the first except the cosets are filled with edges; somehow <code>pull</code> is the minimal version and <code>pull'</code> is maximal, still with the constraint that <code>x ≠ y</code> is needed for a <code>simple_graph</code>). The first one is easier to work with and feels more universal, the second one is sometimes more useful especially wrt contractions).</p>\n<p>The rest of the code is here: <a href=\"https://github.com/vbeffara/lean/blob/main/src/graph_theory/pushforward.lean\">https://github.com/vbeffara/lean/blob/main/src/graph_theory/pushforward.lean</a></p>\n<p>So, the question is: which one of these <code>pull</code>s should be <em>the</em> pullback?</p>\n<p>(BTW, this feels very much like reinventing the wheel, probably all of that is already somewhere in mathlib in a level of generality that is so high that I would not recognize it <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span>)</p>",
        "id": 270205198,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1643720648
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/relation.map\">docs#relation.map</a> and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/relation.comap\">docs#relation.comap</a> are the general versions, <del>with <code>α = {e : sym2 V // ¬e.is_diag}</code></del></p>",
        "id": 270811155,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1644045041
    },
    {
        "content": "<p>Ah, thanks! But unfortunately the image under <code>relation.map</code> is not right because for a <code>simple_graph</code> it needs to be irreflexive, so using it would mean saying <code>neq \\inf relation.map G.adj f f</code> or something, which I find more awkward than defining it by hand.</p>\n<p>The link to <code>comap</code> is broken <span aria-label=\"sad\" class=\"emoji emoji-2639\" role=\"img\" title=\"sad\">:sad:</span> ... probably because the most common use case is just <code>r on f</code> (or maybe precisely because there are several natural choices?)</p>",
        "id": 270816057,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1644052501
    },
    {
        "content": "<p>As far as I can tell, <code>(≠) ⊓ relation.map G.adj f f</code> is defeq to your definition, so might still be worth using as it makes it clear it's the same meaning of <code>map</code></p>",
        "id": 270822536,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1644062111
    },
    {
        "content": "<p>Yes, that's probably a good idea, I will do that (and rename to map then). But the difference means that really the push forward operation should be defined for graphs and not simple graphs, once the hierarchy is in place.</p>",
        "id": 270822706,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1644062329
    },
    {
        "content": "<p>It can be defined for both, just as we define composition of functions, continuous maps and homemorphisms separately and show they agree</p>",
        "id": 270823832,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1644063743
    },
    {
        "content": "<p>Yes but at the moment I think I would rather say that map sends graph to graph, that a simple graph is a graph, and that a graph can be turned into a simple graph in a canonical way. Because here they do not quite exactly agree...</p>",
        "id": 270826465,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1644067197
    },
    {
        "content": "<p>Anyway, this is probably a discussion to be had later.</p>",
        "id": 270826642,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1644067440
    }
]
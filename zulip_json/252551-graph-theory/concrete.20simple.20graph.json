[
    {
        "content": "<p>I am trying to understand how can I use the <code>simple_graph</code> to introduce some basic concepts of graph theory in my course on discrete math. In particular, I am trying to construct a concrete simple graph but I got a type error:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">combinatorics.simple_graph</span>\n<span class=\"kn\">open</span> <span class=\"n\">nat</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">e1</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n <span class=\"bp\">|</span> <span class=\"mi\">1</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"n\">true</span>\n <span class=\"bp\">|</span> <span class=\"mi\">2</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"n\">true</span>\n <span class=\"bp\">|</span> <span class=\"mi\">2</span> <span class=\"mi\">3</span> <span class=\"o\">:=</span> <span class=\"n\">true</span>\n <span class=\"bp\">|</span> <span class=\"mi\">3</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"n\">true</span>\n <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">false</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">g1</span> <span class=\"o\">:=</span> <span class=\"n\">simple_graph.mk</span> <span class=\"n\">e1</span>\n</code></pre></div>\n<p>What am I doing wrong?</p>",
        "id": 216417031,
        "sender_full_name": "Alexandre Rademaker",
        "timestamp": 1605143803
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/simple_graph\">docs#simple_graph</a> is a structure with 3 fields, the first is an edge relation, which you've provided with <code>e1</code>. The second and third are proofs that the edge relation is symmetric and irreflexive, respectively. If you don't provide them, the <code>. obviously</code> syntax in the definition means that Lean will try using <a href=\"https://leanprover-community.github.io/mathlib_docs/find/obviously\">docs#obviously</a> (I think this just calls <a href=\"https://leanprover-community.github.io/mathlib_docs/tactics.html#tidy\">tactic#tidy</a>) to provide proofs. The error message says that <code>obviously</code> isn't able to prove those goals, so you'll most likely have to provide proofs yourself.</p>",
        "id": 216417610,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1605144467
    },
    {
        "content": "<p>^^ What he said.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">g1</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">nat</span> <span class=\"o\">:=</span>\n  <span class=\"k\">have</span> <span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">symmetric</span> <span class=\"n\">e1</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">sorry</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"n\">irreflexive</span> <span class=\"n\">e1</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">simple_graph.mk</span> <span class=\"n\">e1</span> <span class=\"n\">h1</span> <span class=\"n\">h2</span>\n</code></pre></div>",
        "id": 216417697,
        "sender_full_name": "Chris B",
        "timestamp": 1605144556
    },
    {
        "content": "<p>Nice! Thank you, looks like I need a better definition for the edges, these proofs are not trivial for my definition  of <code>e1</code>.</p>",
        "id": 216418425,
        "sender_full_name": "Alexandre Rademaker",
        "timestamp": 1605145269
    },
    {
        "content": "<p>Ok, that is the complete boring step-by-step. I am probably missing some magic way to simplify the proof over finite data.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">combinatorics.simple_graph</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">node</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n <span class=\"bp\">|</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">node</span>\n <span class=\"bp\">|</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">node</span>\n <span class=\"bp\">|</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">node</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">node</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">e1</span> <span class=\"o\">:</span> <span class=\"n\">node</span> <span class=\"bp\">→</span> <span class=\"n\">node</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n <span class=\"bp\">|</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">true</span>\n <span class=\"bp\">|</span> <span class=\"n\">b</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">true</span>\n <span class=\"bp\">|</span> <span class=\"n\">a</span> <span class=\"n\">c</span> <span class=\"o\">:=</span> <span class=\"n\">true</span>\n <span class=\"bp\">|</span> <span class=\"n\">c</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">true</span>\n <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">false</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">g1</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">node</span> <span class=\"o\">:=</span>\n <span class=\"k\">have</span> <span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">symmetric</span> <span class=\"n\">e1</span><span class=\"o\">,</span> <span class=\"k\">from</span>\n <span class=\"kd\">begin</span>\n  <span class=\"n\">intros</span> <span class=\"n\">n</span> <span class=\"n\">m</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">node.cases_on</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">node.cases_on</span> <span class=\"n\">m</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">e1</span><span class=\"o\">,</span> <span class=\"n\">trivial</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">e1</span><span class=\"o\">,</span> <span class=\"n\">intro</span><span class=\"o\">,</span> <span class=\"n\">trivial</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">e1</span><span class=\"o\">,</span> <span class=\"n\">intro</span><span class=\"o\">,</span> <span class=\"n\">trivial</span><span class=\"o\">,</span>\n\n  <span class=\"n\">apply</span> <span class=\"n\">node.cases_on</span> <span class=\"n\">m</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">e1</span><span class=\"o\">,</span> <span class=\"n\">e1</span><span class=\"o\">],</span> <span class=\"n\">intro</span><span class=\"o\">,</span> <span class=\"n\">trivial</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">e1</span><span class=\"o\">,</span> <span class=\"n\">trivial</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">e1</span><span class=\"o\">,</span> <span class=\"n\">e1</span><span class=\"o\">],</span> <span class=\"n\">trivial</span><span class=\"o\">,</span>\n\n  <span class=\"n\">apply</span> <span class=\"n\">node.cases_on</span> <span class=\"n\">m</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">e1</span><span class=\"o\">,</span><span class=\"n\">e1</span><span class=\"o\">],</span> <span class=\"n\">intro</span><span class=\"o\">,</span> <span class=\"n\">trivial</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">e1</span><span class=\"o\">,</span> <span class=\"n\">trivial</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">e1</span><span class=\"o\">,</span> <span class=\"n\">trivial</span><span class=\"o\">,</span>\n <span class=\"kd\">end</span><span class=\"o\">,</span>\n <span class=\"k\">have</span> <span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"n\">irreflexive</span> <span class=\"n\">e1</span><span class=\"o\">,</span> <span class=\"k\">from</span>\n <span class=\"kd\">begin</span>\n  <span class=\"n\">intro</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">node.cases_on</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">e1</span><span class=\"o\">,</span> <span class=\"n\">trivial</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">e1</span><span class=\"o\">,</span> <span class=\"n\">trivial</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">e1</span><span class=\"o\">,</span> <span class=\"n\">trivial</span><span class=\"o\">,</span>\n <span class=\"kd\">end</span><span class=\"o\">,</span>\n <span class=\"n\">simple_graph.mk</span> <span class=\"n\">e1</span> <span class=\"n\">h1</span> <span class=\"n\">h2</span>\n</code></pre></div>\n<p>I could simplify to </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">g1</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">node</span> <span class=\"o\">:=</span>\n <span class=\"k\">have</span> <span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">symmetric</span> <span class=\"n\">e1</span><span class=\"o\">,</span> <span class=\"k\">from</span>\n <span class=\"kd\">begin</span>\n  <span class=\"n\">intros</span> <span class=\"n\">n</span> <span class=\"n\">m</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n  <span class=\"n\">repeat</span> <span class=\"o\">{</span>\n      <span class=\"n\">cases</span> <span class=\"n\">m</span><span class=\"o\">,</span>\n      <span class=\"n\">repeat</span> <span class=\"o\">{</span><span class=\"n\">repeat</span> <span class=\"o\">{</span><span class=\"n\">rw</span> <span class=\"n\">e1</span><span class=\"o\">},</span> <span class=\"n\">try</span> <span class=\"o\">{</span><span class=\"n\">intro</span><span class=\"o\">},</span> <span class=\"n\">trivial</span><span class=\"o\">}</span>\n  <span class=\"o\">},</span>\n <span class=\"kd\">end</span><span class=\"o\">,</span>\n <span class=\"k\">have</span> <span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"n\">irreflexive</span> <span class=\"n\">e1</span><span class=\"o\">,</span> <span class=\"k\">from</span>\n <span class=\"kd\">begin</span>\n  <span class=\"n\">intro</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n  <span class=\"n\">repeat</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">e1</span><span class=\"o\">,</span> <span class=\"n\">trivial</span> <span class=\"o\">},</span>\n <span class=\"kd\">end</span><span class=\"o\">,</span>\n <span class=\"n\">simple_graph.mk</span> <span class=\"n\">e1</span> <span class=\"n\">h1</span> <span class=\"n\">h2</span>\n</code></pre></div>",
        "id": 216420612,
        "sender_full_name": "Alexandre Rademaker",
        "timestamp": 1605147758
    },
    {
        "content": "<p>you can use <code>;</code> to apply to all created goals instead of repeat.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">g1</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">node</span> <span class=\"o\">:=</span>\n <span class=\"k\">have</span> <span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">symmetric</span> <span class=\"n\">e1</span><span class=\"o\">,</span> <span class=\"k\">from</span>\n <span class=\"kd\">begin</span>\n   <span class=\"n\">intros</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n   <span class=\"n\">cases</span> <span class=\"n\">x</span><span class=\"bp\">;</span>\n   <span class=\"n\">cases</span> <span class=\"n\">y</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n <span class=\"kd\">end</span><span class=\"o\">,</span>\n <span class=\"k\">have</span> <span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"n\">irreflexive</span> <span class=\"n\">e1</span><span class=\"o\">,</span> <span class=\"k\">from</span>\n <span class=\"kd\">begin</span>\n  <span class=\"n\">intro</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">n</span><span class=\"bp\">;</span> <span class=\"n\">rw</span> <span class=\"n\">e1</span><span class=\"bp\">;</span> <span class=\"n\">trivial</span><span class=\"o\">,</span>\n <span class=\"kd\">end</span><span class=\"o\">,</span>\n <span class=\"n\">simple_graph.mk</span> <span class=\"n\">e1</span> <span class=\"n\">h1</span> <span class=\"n\">h2</span>\n</code></pre></div>",
        "id": 216422032,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1605149417
    },
    {
        "content": "<p>thank you.</p>",
        "id": 216422167,
        "sender_full_name": "Alexandre Rademaker",
        "timestamp": 1605149617
    },
    {
        "content": "<p>It's much easier to work with an inductive:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">e1</span> <span class=\"o\">:</span> <span class=\"n\">node</span> <span class=\"bp\">→</span> <span class=\"n\">node</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"n\">ab</span> <span class=\"o\">:</span> <span class=\"n\">e1</span> <span class=\"n\">a</span> <span class=\"n\">b</span>\n<span class=\"bp\">|</span> <span class=\"n\">ba</span> <span class=\"o\">:</span> <span class=\"n\">e1</span> <span class=\"n\">b</span> <span class=\"n\">a</span>\n<span class=\"bp\">|</span> <span class=\"n\">ac</span> <span class=\"o\">:</span> <span class=\"n\">e1</span> <span class=\"n\">a</span> <span class=\"n\">c</span>\n<span class=\"bp\">|</span> <span class=\"n\">ca</span> <span class=\"o\">:</span> <span class=\"n\">e1</span> <span class=\"n\">c</span> <span class=\"n\">a</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">e1.symm</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">e1</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">e1</span> <span class=\"n\">y</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">cases</span> <span class=\"n\">h</span><span class=\"bp\">;</span> <span class=\"n\">constructor</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">e1.irrefl</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"n\">e1</span> <span class=\"n\">x</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">cases</span> <span class=\"n\">h</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">g1</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">node</span> <span class=\"o\">:=</span> <span class=\"n\">simple_graph.mk</span> <span class=\"n\">e1</span> <span class=\"bp\">@</span><span class=\"n\">e1.symm</span> <span class=\"n\">e1.irrefl</span>\n</code></pre></div>",
        "id": 216422231,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1605149691
    },
    {
        "content": "<p>you can also use a symmetric closure to cut down on the number of cases (although in this example it's not a very big deal, in a larger inductive it might be worth it)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">combinatorics.simple_graph</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">relation</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">symm_gen</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"n\">r</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">∨</span> <span class=\"n\">r</span> <span class=\"n\">y</span> <span class=\"n\">x</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">r</span><span class=\"o\">}</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">symm_gen.symm</span> <span class=\"o\">:</span> <span class=\"n\">symmetric</span> <span class=\"o\">(</span><span class=\"n\">symm_gen</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">or.symm</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">symm_gen.irrefl</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">irreflexive</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">irreflexive</span> <span class=\"o\">(</span><span class=\"n\">symm_gen</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">rintro</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"bp\">|</span><span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">H</span> <span class=\"n\">_</span> <span class=\"n\">h</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">relation</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">node</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">node</span>\n<span class=\"bp\">|</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">node</span>\n<span class=\"bp\">|</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">node</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">node</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">e1</span> <span class=\"o\">:</span> <span class=\"n\">node</span> <span class=\"bp\">→</span> <span class=\"n\">node</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"n\">ab</span> <span class=\"o\">:</span> <span class=\"n\">e1</span> <span class=\"n\">a</span> <span class=\"n\">b</span>\n<span class=\"bp\">|</span> <span class=\"n\">ac</span> <span class=\"o\">:</span> <span class=\"n\">e1</span> <span class=\"n\">a</span> <span class=\"n\">c</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">g1</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">node</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">adj</span> <span class=\"o\">:=</span> <span class=\"n\">relation.symm_gen</span> <span class=\"n\">e1</span><span class=\"o\">,</span>\n  <span class=\"n\">sym</span> <span class=\"o\">:=</span> <span class=\"n\">relation.symm_gen.symm</span><span class=\"o\">,</span>\n  <span class=\"n\">loopless</span> <span class=\"o\">:=</span> <span class=\"n\">relation.symm_gen.irrefl</span> <span class=\"bp\">$</span> <span class=\"kd\">by</span> <span class=\"n\">rintro</span> <span class=\"n\">_</span> <span class=\"o\">⟨⟩</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 216422630,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1605150161
    },
    {
        "content": "<p>Thank you <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>, I will try more tomorrow. It is a new world for me! I am trying to understand many things that I haven't played yet in Lean. It took me 30 min to understand how to obtain the neighbors of a node with <code>#reduce (simple_graph.neighbor_set g2 c)</code> that reduces to <code>e1 c</code>.</p>",
        "id": 216423079,
        "sender_full_name": "Alexandre Rademaker",
        "timestamp": 1605150723
    },
    {
        "content": "<p>I don't know that much about this graph library, but if you want to enumerate the values of <code>x</code> such that <code>e1 c x</code> you can do <code>cases (h : e1 c x)</code></p>",
        "id": 216423209,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1605150846
    },
    {
        "content": "<p>It's not particularly well developed, but you can create graphs from edge sets:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">combinatorics.simple_graph</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">simple_graph.from_edges</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">edges</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">sym2</span> <span class=\"n\">α</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">loopless</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">e</span> <span class=\"bp\">∈</span> <span class=\"n\">edges</span><span class=\"o\">,</span> <span class=\"bp\">¬</span><span class=\"n\">sym2.is_diag</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">simple_graph</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">adj</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"bp\">⟦</span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">w</span><span class=\"o\">)</span><span class=\"bp\">⟧</span> <span class=\"bp\">∈</span> <span class=\"n\">edges</span><span class=\"o\">,</span>\n  <span class=\"n\">sym</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">sym2.eq_swap</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n  <span class=\"n\">loopless</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">v</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"k\">have</span> <span class=\"n\">h'</span> <span class=\"o\">:=</span> <span class=\"n\">loopless</span> <span class=\"n\">_</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">h'</span> <span class=\"o\">}</span> <span class=\"o\">}</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">simple_graph</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">my_edges</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">sym2</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"bp\">⟦</span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"bp\">⟧</span><span class=\"o\">,</span>\n  <span class=\"bp\">⟦</span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">)</span><span class=\"bp\">⟧</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">my_graph</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span>\n<span class=\"n\">simple_graph.from_edges</span> <span class=\"n\">my_edges</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">dunfold</span> <span class=\"n\">my_edges</span><span class=\"o\">,</span> <span class=\"n\">finish</span> <span class=\"o\">})</span>\n</code></pre></div>",
        "id": 216427219,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1605156029
    },
    {
        "content": "<p>Part of it is that <code>data.sym2</code> is missing the inverse to <code>from_rel</code>, which would take a set of unordered pairs and produce a relation.  It should also have a lemma that if the set of unordered pairs has no diagonal elements, then the relation is irreflexive.</p>",
        "id": 216427363,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1605156250
    },
    {
        "content": "<p>If anyone wants to add <code>from_edges</code> to the simple graph library, here's an additional lemma:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[simp]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">edge_set_from_edges</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n  <span class=\"o\">{</span><span class=\"n\">edges</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">sym2</span> <span class=\"n\">α</span><span class=\"o\">)}</span> <span class=\"o\">{</span><span class=\"n\">loopless</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">e</span> <span class=\"bp\">∈</span> <span class=\"n\">edges</span><span class=\"o\">,</span> <span class=\"bp\">¬</span><span class=\"n\">sym2.is_diag</span> <span class=\"n\">e</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">simple_graph.from_edges</span> <span class=\"n\">edges</span> <span class=\"n\">loopless</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">edge_set</span> <span class=\"bp\">=</span> <span class=\"n\">edges</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">tidy</span>\n</code></pre></div>\n<p>(Maybe it would be better to be called <code>from_edge_set</code> rather than <code>from_edges</code>.)</p>",
        "id": 216427794,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1605156788
    },
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> , this is very interesting. The use of <code>sym2</code> instead of a function simplified the definition of the edges and the proofs necessary to construct the graph. I also learned about <code>dunfold</code> that I have never seen before.</p>\n<p>But thinking broadly, maybe I need to change my mindset to use lean to present basic graph theory. I am trying to compute with graphs as data structures and maybe the library as not developed with that purpose.</p>",
        "id": 216463351,
        "sender_full_name": "Alexandre Rademaker",
        "timestamp": 1605185774
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/252551-graph-theory/topic/concrete.20simple.20graph/near/216423209\">said</a>:</p>\n<blockquote>\n<p>I don't know that much about this graph library, but if you want to enumerate the values of <code>x</code> such that <code>e1 c x</code> you can do <code>cases (h : e1 c x)</code></p>\n</blockquote>\n<p>Hum, that would be an alternative to my tentative <code>#reduce</code> command. But I would need to create a context to use this tactic..</p>",
        "id": 216499113,
        "sender_full_name": "Alexandre Rademaker",
        "timestamp": 1605201475
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"121542\">@Alexandre Rademaker</span> The graph library isn't designed to be used for data structures directly, and I think of it more as an abstract interface to graphs: you might create specialty data structures for computation along with a function to <code>simple_graph</code> to prove things (though this idea hasn't been tested yet).  The library tries to make things decidable, at least, if the underlying relation is, though you have to implement <code>fintype</code> instances to get it to be able to <code>#reduce</code> the degree of a vertex, for example.  Instances like these are where you supply your own algorithms that depend on the specific data structure.</p>",
        "id": 216510084,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1605206492
    },
    {
        "content": "<p>Thank you <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span>, but I didn't get the point about the abstract interface to graphs. Now that I know how to construct a particular graph, I am back to see how Lean can help me in the introduction to graph theory.</p>\n<p>The majority of the courses/books about introduction to graphs have isomorphism as one of its first topics. It seems that providing examples like the ones described in <a href=\"https://www.youtube.com/watch?v=z-GfKbzvtBA&amp;feature=youtu.be\">https://www.youtube.com/watch?v=z-GfKbzvtBA&amp;feature=youtu.be</a> (possible following also the ideas of <a href=\"https://math.stackexchange.com/questions/2486944/how-to-tell-whether-two-graphs-are-isomorphic\">https://math.stackexchange.com/questions/2486944/how-to-tell-whether-two-graphs-are-isomorphic</a> would be nice.</p>\n<div class=\"youtube-video message_inline_image\"><a data-id=\"z-GfKbzvtBA\" href=\"https://www.youtube.com/watch?v=z-GfKbzvtBA&amp;feature=youtu.be\"><img src=\"https://i.ytimg.com/vi/z-GfKbzvtBA/default.jpg\"></a></div>",
        "id": 216966481,
        "sender_full_name": "Alexandre Rademaker",
        "timestamp": 1605588671
    },
    {
        "content": "<p>In an experimental branch, we have graph isomorphisms <a href=\"https://github.com/leanprover-community/mathlib/blob/simple_graphs2/src/combinatorics/simple_graph/hom.lean#L137\">https://github.com/leanprover-community/mathlib/blob/simple_graphs2/src/combinatorics/simple_graph/hom.lean#L137</a> (though no real examples except for the one on line 200).  An isomorphism of simple graphs is a bijection on vertex sets that preserves the adjacency relation in both directions.</p>",
        "id": 216967127,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1605589645
    },
    {
        "content": "<p>I thought that isomorphism would be a proposition not a type ... I would like to be able to provide two simple graphs and construct a prove of their isomorphism. That is, given an f , show that it is bijective and preserves adjacent relations</p>",
        "id": 217074190,
        "sender_full_name": "Alexandre Rademaker",
        "timestamp": 1605653331
    },
    {
        "content": "<p>Two graphs are <em>isomorphic</em> if there exists an isomorphism between them.  The best way to show two graphs are isomorphic is to provide an explicit isomorphism, which gives the exact correspondence between vertices in each graph.  If you want to turn it into a proposition, you could say <code>nonempty (G ≃g G')</code> (using the notation from that branch), but you'd only want to do that if for some reason you can't construct the isomorphism.</p>",
        "id": 217074610,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1605653611
    },
    {
        "content": "<p>But maybe you're asking for Lean to <em>compute</em> whether two graphs are isomorphic?  You could probably write a tactic to do this, if the graphs are presented suitably.  (Or maybe use a Mario-style trick where you do logic programming at the typeclass level?)</p>",
        "id": 217075081,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1605653921
    },
    {
        "content": "<p>I backported graph isomorphism from the experimental branch to what's currently in mathlib and then took the pair of isomorphic graphs from the beginning of the YouTube video and showed they're isomorphic by providing an explicit isomorphism (with inefficient proofs):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">combinatorics.simple_graph</span>\n\n<span class=\"kd\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">simple_graph</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">from_edges</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">edges</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">sym2</span> <span class=\"n\">α</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">loopless</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">e</span> <span class=\"bp\">∈</span> <span class=\"n\">edges</span><span class=\"o\">,</span> <span class=\"bp\">¬</span><span class=\"n\">sym2.is_diag</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">simple_graph</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">adj</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"bp\">⟦</span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">w</span><span class=\"o\">)</span><span class=\"bp\">⟧</span> <span class=\"bp\">∈</span> <span class=\"n\">edges</span><span class=\"o\">,</span>\n  <span class=\"n\">sym</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">sym2.eq_swap</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n  <span class=\"n\">loopless</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">v</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"k\">have</span> <span class=\"n\">h'</span> <span class=\"o\">:=</span> <span class=\"n\">loopless</span> <span class=\"n\">_</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">h'</span> <span class=\"o\">}</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">from_edges.edge_set</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n  <span class=\"o\">{</span><span class=\"n\">edges</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">sym2</span> <span class=\"n\">α</span><span class=\"o\">)}</span> <span class=\"o\">{</span><span class=\"n\">loopless</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">e</span> <span class=\"bp\">∈</span> <span class=\"n\">edges</span><span class=\"o\">,</span> <span class=\"bp\">¬</span><span class=\"n\">sym2.is_diag</span> <span class=\"n\">e</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">simple_graph.from_edges</span> <span class=\"n\">edges</span> <span class=\"n\">loopless</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">edge_set</span> <span class=\"bp\">=</span> <span class=\"n\">edges</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">tidy</span>\n\n<span class=\"n\">abbreviation</span> <span class=\"n\">iso</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">V'</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">G'</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V'</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">rel_iso</span> <span class=\"n\">G.adj</span> <span class=\"n\">G'.adj</span>\n\n<span class=\"kd\">infix</span> <span class=\"bp\">`</span> <span class=\"bp\">≃</span><span class=\"n\">g</span> <span class=\"bp\">`</span> <span class=\"o\">:</span> <span class=\"mi\">50</span> <span class=\"o\">:=</span> <span class=\"n\">iso</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">simple_graph</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">simple_graph</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">V1</span> <span class=\"bp\">|</span> <span class=\"n\">v1</span> <span class=\"bp\">|</span> <span class=\"n\">v2</span> <span class=\"bp\">|</span> <span class=\"n\">v3</span> <span class=\"bp\">|</span> <span class=\"n\">v4</span> <span class=\"bp\">|</span> <span class=\"n\">v5</span> <span class=\"bp\">|</span> <span class=\"n\">v6</span>\n<span class=\"kd\">inductive</span> <span class=\"n\">V2</span> <span class=\"bp\">|</span> <span class=\"n\">va</span> <span class=\"bp\">|</span> <span class=\"n\">vb</span> <span class=\"bp\">|</span> <span class=\"n\">vc</span> <span class=\"bp\">|</span> <span class=\"n\">vd</span> <span class=\"bp\">|</span> <span class=\"n\">ve</span> <span class=\"bp\">|</span> <span class=\"n\">vf</span>\n<span class=\"kn\">open</span> <span class=\"n\">V1</span> <span class=\"n\">V2</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V1</span> <span class=\"o\">:=</span>\n<span class=\"n\">simple_graph.from_edges</span>\n<span class=\"o\">{</span><span class=\"bp\">⟦</span><span class=\"o\">(</span><span class=\"n\">v1</span><span class=\"o\">,</span> <span class=\"n\">v4</span><span class=\"o\">)</span><span class=\"bp\">⟧</span><span class=\"o\">,</span>\n <span class=\"bp\">⟦</span><span class=\"o\">(</span><span class=\"n\">v1</span><span class=\"o\">,</span> <span class=\"n\">v5</span><span class=\"o\">)</span><span class=\"bp\">⟧</span><span class=\"o\">,</span>\n <span class=\"bp\">⟦</span><span class=\"o\">(</span><span class=\"n\">v1</span><span class=\"o\">,</span> <span class=\"n\">v6</span><span class=\"o\">)</span><span class=\"bp\">⟧</span><span class=\"o\">,</span>\n <span class=\"bp\">⟦</span><span class=\"o\">(</span><span class=\"n\">v2</span><span class=\"o\">,</span> <span class=\"n\">v4</span><span class=\"o\">)</span><span class=\"bp\">⟧</span><span class=\"o\">,</span>\n <span class=\"bp\">⟦</span><span class=\"o\">(</span><span class=\"n\">v2</span><span class=\"o\">,</span> <span class=\"n\">v5</span><span class=\"o\">)</span><span class=\"bp\">⟧</span><span class=\"o\">,</span>\n <span class=\"bp\">⟦</span><span class=\"o\">(</span><span class=\"n\">v2</span><span class=\"o\">,</span> <span class=\"n\">v6</span><span class=\"o\">)</span><span class=\"bp\">⟧</span><span class=\"o\">,</span>\n <span class=\"bp\">⟦</span><span class=\"o\">(</span><span class=\"n\">v3</span><span class=\"o\">,</span> <span class=\"n\">v4</span><span class=\"o\">)</span><span class=\"bp\">⟧</span><span class=\"o\">,</span>\n <span class=\"bp\">⟦</span><span class=\"o\">(</span><span class=\"n\">v3</span><span class=\"o\">,</span> <span class=\"n\">v5</span><span class=\"o\">)</span><span class=\"bp\">⟧</span><span class=\"o\">,</span>\n <span class=\"bp\">⟦</span><span class=\"o\">(</span><span class=\"n\">v3</span><span class=\"o\">,</span> <span class=\"n\">v6</span><span class=\"o\">)</span><span class=\"bp\">⟧</span><span class=\"o\">,</span>\n<span class=\"o\">}</span>\n<span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">finish</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V2</span> <span class=\"o\">:=</span>\n<span class=\"n\">simple_graph.from_edges</span>\n<span class=\"o\">{</span><span class=\"bp\">⟦</span><span class=\"o\">(</span><span class=\"n\">va</span><span class=\"o\">,</span> <span class=\"n\">vb</span><span class=\"o\">)</span><span class=\"bp\">⟧</span><span class=\"o\">,</span>\n <span class=\"bp\">⟦</span><span class=\"o\">(</span><span class=\"n\">va</span><span class=\"o\">,</span> <span class=\"n\">vd</span><span class=\"o\">)</span><span class=\"bp\">⟧</span><span class=\"o\">,</span>\n <span class=\"bp\">⟦</span><span class=\"o\">(</span><span class=\"n\">va</span><span class=\"o\">,</span> <span class=\"n\">vf</span><span class=\"o\">)</span><span class=\"bp\">⟧</span><span class=\"o\">,</span>\n <span class=\"bp\">⟦</span><span class=\"o\">(</span><span class=\"n\">vb</span><span class=\"o\">,</span> <span class=\"n\">vc</span><span class=\"o\">)</span><span class=\"bp\">⟧</span><span class=\"o\">,</span>\n <span class=\"bp\">⟦</span><span class=\"o\">(</span><span class=\"n\">vb</span><span class=\"o\">,</span> <span class=\"n\">ve</span><span class=\"o\">)</span><span class=\"bp\">⟧</span><span class=\"o\">,</span>\n <span class=\"bp\">⟦</span><span class=\"o\">(</span><span class=\"n\">vc</span><span class=\"o\">,</span> <span class=\"n\">vd</span><span class=\"o\">)</span><span class=\"bp\">⟧</span><span class=\"o\">,</span>\n <span class=\"bp\">⟦</span><span class=\"o\">(</span><span class=\"n\">vc</span><span class=\"o\">,</span> <span class=\"n\">vf</span><span class=\"o\">)</span><span class=\"bp\">⟧</span><span class=\"o\">,</span>\n <span class=\"bp\">⟦</span><span class=\"o\">(</span><span class=\"n\">vd</span><span class=\"o\">,</span> <span class=\"n\">ve</span><span class=\"o\">)</span><span class=\"bp\">⟧</span><span class=\"o\">,</span>\n <span class=\"bp\">⟦</span><span class=\"o\">(</span><span class=\"n\">ve</span><span class=\"o\">,</span> <span class=\"n\">vf</span><span class=\"o\">)</span><span class=\"bp\">⟧</span><span class=\"o\">,</span>\n<span class=\"o\">}</span>\n<span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">finish</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">GtoH_verts</span> <span class=\"o\">:</span> <span class=\"n\">V1</span> <span class=\"bp\">→</span> <span class=\"n\">V2</span>\n<span class=\"bp\">|</span> <span class=\"n\">v1</span> <span class=\"o\">:=</span> <span class=\"n\">vb</span>\n<span class=\"bp\">|</span> <span class=\"n\">v2</span> <span class=\"o\">:=</span> <span class=\"n\">vd</span>\n<span class=\"bp\">|</span> <span class=\"n\">v3</span> <span class=\"o\">:=</span> <span class=\"n\">vf</span>\n<span class=\"bp\">|</span> <span class=\"n\">v4</span> <span class=\"o\">:=</span> <span class=\"n\">vc</span>\n<span class=\"bp\">|</span> <span class=\"n\">v5</span> <span class=\"o\">:=</span> <span class=\"n\">ve</span>\n<span class=\"bp\">|</span> <span class=\"n\">v6</span> <span class=\"o\">:=</span> <span class=\"n\">va</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">HtoG_verts</span> <span class=\"o\">:</span> <span class=\"n\">V2</span> <span class=\"bp\">→</span> <span class=\"n\">V1</span>\n<span class=\"bp\">|</span> <span class=\"n\">vb</span> <span class=\"o\">:=</span> <span class=\"n\">v1</span>\n<span class=\"bp\">|</span> <span class=\"n\">vd</span> <span class=\"o\">:=</span> <span class=\"n\">v2</span>\n<span class=\"bp\">|</span> <span class=\"n\">vf</span> <span class=\"o\">:=</span> <span class=\"n\">v3</span>\n<span class=\"bp\">|</span> <span class=\"n\">vc</span> <span class=\"o\">:=</span> <span class=\"n\">v4</span>\n<span class=\"bp\">|</span> <span class=\"n\">ve</span> <span class=\"o\">:=</span> <span class=\"n\">v5</span>\n<span class=\"bp\">|</span> <span class=\"n\">va</span> <span class=\"o\">:=</span> <span class=\"n\">v6</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">GisoH</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">≃</span><span class=\"n\">g</span> <span class=\"n\">H</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"n\">GtoH_verts</span><span class=\"o\">,</span>\n  <span class=\"n\">inv_fun</span> <span class=\"o\">:=</span> <span class=\"n\">HtoG_verts</span><span class=\"o\">,</span>\n  <span class=\"n\">left_inv</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span> <span class=\"n\">intro</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">cases</span> <span class=\"n\">x</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">GtoH_verts</span><span class=\"o\">,</span> <span class=\"n\">HtoG_verts</span><span class=\"o\">],</span> <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">right_inv</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span> <span class=\"n\">intro</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">cases</span> <span class=\"n\">x</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">GtoH_verts</span><span class=\"o\">,</span> <span class=\"n\">HtoG_verts</span><span class=\"o\">],</span> <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">map_rel_iff'</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">intros</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span>\n    <span class=\"n\">dsimp</span> <span class=\"o\">[</span><span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"n\">H</span><span class=\"o\">,</span> <span class=\"n\">from_edges</span><span class=\"o\">],</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">set.mem_insert_iff</span><span class=\"o\">,</span> <span class=\"n\">set.mem_singleton_iff</span><span class=\"o\">,</span> <span class=\"n\">sym2.eq_iff</span><span class=\"o\">],</span>\n    <span class=\"n\">cases</span> <span class=\"n\">x</span><span class=\"bp\">;</span> <span class=\"n\">cases</span> <span class=\"n\">y</span><span class=\"bp\">;</span> <span class=\"n\">dsimp</span> <span class=\"o\">[</span><span class=\"n\">GtoH_verts</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"kd\">end</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 217076536,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1605654933
    },
    {
        "content": "<p>(There's probably some way to have <code>HtoG_verts</code> be automatically constructed from <code>GtoH_verts</code> since <code>V1</code> and <code>V2</code> are finite types, but I don't know how off the top of my head.)</p>",
        "id": 217076789,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1605655091
    },
    {
        "content": "<p>You can't construct <code>HtoG_verts</code> directly from <code>GtoH_verts</code> without leaving an important verification condition on the table: the goal is to show a bijection and if you just make a list of pairs you don't know it's bijective. Writing the functions in each direction ensures exhaustiveness, and checking that they are converses is easy (linear time)</p>",
        "id": 217082966,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1605659986
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> I was imagining something like this, but more automated (and also more computable since the types are decidable and finite).</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.fintype.basic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">fintype</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">V1</span> <span class=\"bp\">|</span> <span class=\"n\">v1</span> <span class=\"bp\">|</span> <span class=\"n\">v2</span> <span class=\"bp\">|</span> <span class=\"n\">v3</span> <span class=\"bp\">|</span> <span class=\"n\">v4</span> <span class=\"bp\">|</span> <span class=\"n\">v5</span> <span class=\"bp\">|</span> <span class=\"n\">v6</span>\n<span class=\"kd\">inductive</span> <span class=\"n\">V2</span> <span class=\"bp\">|</span> <span class=\"n\">va</span> <span class=\"bp\">|</span> <span class=\"n\">vb</span> <span class=\"bp\">|</span> <span class=\"n\">vc</span> <span class=\"bp\">|</span> <span class=\"n\">vd</span> <span class=\"bp\">|</span> <span class=\"n\">ve</span> <span class=\"bp\">|</span> <span class=\"n\">vf</span>\n<span class=\"kn\">open</span> <span class=\"n\">V1</span> <span class=\"n\">V2</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"n\">V1</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span> <span class=\"n\">use</span> <span class=\"o\">{</span><span class=\"n\">v1</span><span class=\"o\">,</span> <span class=\"n\">v2</span><span class=\"o\">,</span> <span class=\"n\">v3</span><span class=\"o\">,</span> <span class=\"n\">v4</span><span class=\"o\">,</span> <span class=\"n\">v5</span><span class=\"o\">,</span> <span class=\"n\">v6</span><span class=\"o\">},</span> <span class=\"n\">tidy</span><span class=\"o\">,</span> <span class=\"n\">cases</span> <span class=\"n\">x</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"kd\">end</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"n\">V2</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span> <span class=\"n\">use</span> <span class=\"o\">{</span><span class=\"n\">va</span><span class=\"o\">,</span> <span class=\"n\">vb</span><span class=\"o\">,</span> <span class=\"n\">vc</span><span class=\"o\">,</span> <span class=\"n\">vd</span><span class=\"o\">,</span> <span class=\"n\">ve</span><span class=\"o\">,</span> <span class=\"n\">vf</span><span class=\"o\">},</span> <span class=\"n\">tidy</span><span class=\"o\">,</span> <span class=\"n\">cases</span> <span class=\"n\">x</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"kd\">end</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">card_V1</span> <span class=\"o\">:</span> <span class=\"n\">card</span> <span class=\"n\">V1</span> <span class=\"bp\">=</span> <span class=\"mi\">6</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">tidy</span>\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">card_V2</span> <span class=\"o\">:</span> <span class=\"n\">card</span> <span class=\"n\">V2</span> <span class=\"bp\">=</span> <span class=\"mi\">6</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">tidy</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">V1</span> <span class=\"bp\">→</span> <span class=\"n\">V2</span>\n<span class=\"bp\">|</span> <span class=\"n\">v1</span> <span class=\"o\">:=</span> <span class=\"n\">vb</span>\n<span class=\"bp\">|</span> <span class=\"n\">v2</span> <span class=\"o\">:=</span> <span class=\"n\">vd</span>\n<span class=\"bp\">|</span> <span class=\"n\">v3</span> <span class=\"o\">:=</span> <span class=\"n\">vf</span>\n<span class=\"bp\">|</span> <span class=\"n\">v4</span> <span class=\"o\">:=</span> <span class=\"n\">vc</span>\n<span class=\"bp\">|</span> <span class=\"n\">v5</span> <span class=\"o\">:=</span> <span class=\"n\">ve</span>\n<span class=\"bp\">|</span> <span class=\"n\">v6</span> <span class=\"o\">:=</span> <span class=\"n\">va</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">f_inj</span> <span class=\"o\">:</span> <span class=\"n\">function.injective</span> <span class=\"n\">f</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">cases</span> <span class=\"n\">x</span><span class=\"bp\">;</span> <span class=\"n\">cases</span> <span class=\"n\">y</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">f_bij</span> <span class=\"o\">:</span> <span class=\"n\">function.bijective</span> <span class=\"n\">f</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">bijective_iff_injective_and_card</span> <span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mpr</span> <span class=\"o\">⟨</span><span class=\"n\">f_inj</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">noncomputable</span>\n<span class=\"kd\">def</span> <span class=\"n\">f_equiv</span> <span class=\"o\">:</span> <span class=\"n\">V1</span> <span class=\"bp\">≃</span> <span class=\"n\">V2</span> <span class=\"o\">:=</span>\n<span class=\"n\">equiv.of_bijective</span> <span class=\"n\">f</span> <span class=\"n\">f_bij</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">f_equiv_to_fun</span> <span class=\"o\">:</span> <span class=\"n\">f_equiv.to_fun</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">ext</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">f_equiv</span><span class=\"o\">]</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 217099770,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1605679837
    },
    {
        "content": "<p>this is way more expensive than the first version</p>",
        "id": 217099802,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1605679903
    },
    {
        "content": "<p>the injectivity check is O(n^2) while the back and forth check is O(n)</p>",
        "id": 217099844,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1605679928
    },
    {
        "content": "<p>it's also noncomputable</p>",
        "id": 217099852,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1605679965
    },
    {
        "content": "<p>Technically it's all O(1) since there are only 6 elements, but in any case I'm only looking for mathematical convenience to define an explicit bijection and I don't care too much about running time of the resulting function.</p>\n<p>How is this noncomputable?  There are only 6^6 possible functions, and you can check all of them to see what would be the inverse in a computable way.</p>",
        "id": 217099997,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1605680173
    },
    {
        "content": "<p>It's noncomputable in the sense that you wrote <code>noncomputable</code>?</p>",
        "id": 217102884,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1605684184
    },
    {
        "content": "<p>If you are looking for mathematical convenience, the example is too minimal. Almost all of the boilerplate can be removed but it needs to fit in some larger pattern of graph isomorphisms. This looks way too much like a toy example to draw general conclusions</p>",
        "id": 217103317,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1605684618
    },
    {
        "content": "<p>I was thinking about the current definition of simple graph. What is the motivation for this particular way to define graphs? In particular why carrying out the proofs as components of the structure?</p>",
        "id": 217556058,
        "sender_full_name": "Alexandre Rademaker",
        "timestamp": 1606058534
    },
    {
        "content": "<p>In part, in analogy to the way groups and such are defined.</p>",
        "id": 217559415,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1606063729
    },
    {
        "content": "<p>If you want to have a structure that has some data that follow some properties, the easiest way to do it seems to be to bundle together the data and the proofs of the properties.</p>",
        "id": 217559432,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1606063773
    },
    {
        "content": "<p>Another possible way to do it could have been by defining a set of edges, but if that was defined as say, a set of the type <code>sym2</code>, the symmetric square of the vertex type, then you’d still need to include a proof of the irreflexivity axiom.</p>",
        "id": 217559566,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1606063968
    },
    {
        "content": "<p>In what situations and how the proofs in the structure can or should be used?</p>",
        "id": 217639563,
        "sender_full_name": "Alexandre Rademaker",
        "timestamp": 1606144480
    },
    {
        "content": "<p>for \"how\" to use the proofs in a structure, use dot notation?</p>",
        "id": 217824115,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1606258094
    },
    {
        "content": "<p>Thank you <span class=\"user-mention\" data-user-id=\"252300\">@Jalex Stark</span>  and sorry, I know that we can access fields in a structure with the dot notation. The <code>how</code> is not a question about Lean syntax, it is more about the purpose of having this term in the structure and contexts that it would be useful. See </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">e1</span> <span class=\"o\">:</span> <span class=\"n\">node</span> <span class=\"bp\">→</span> <span class=\"n\">node</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n <span class=\"bp\">|</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">true</span>\n <span class=\"bp\">|</span> <span class=\"n\">b</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">true</span>\n <span class=\"bp\">|</span> <span class=\"n\">a</span> <span class=\"n\">c</span> <span class=\"o\">:=</span> <span class=\"n\">true</span>\n <span class=\"bp\">|</span> <span class=\"n\">c</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">true</span>\n <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">false</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">g2</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">node</span> <span class=\"o\">:=</span>\n <span class=\"k\">have</span> <span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">symmetric</span> <span class=\"n\">e1</span><span class=\"o\">,</span> <span class=\"k\">from</span>\n <span class=\"kd\">begin</span>\n  <span class=\"n\">intros</span> <span class=\"n\">n</span> <span class=\"n\">m</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n  <span class=\"n\">repeat</span> <span class=\"o\">{</span>\n      <span class=\"n\">cases</span> <span class=\"n\">m</span><span class=\"o\">,</span>\n      <span class=\"n\">repeat</span> <span class=\"o\">{</span><span class=\"n\">repeat</span> <span class=\"o\">{</span><span class=\"n\">rw</span> <span class=\"n\">e1</span><span class=\"o\">},</span> <span class=\"n\">try</span> <span class=\"o\">{</span><span class=\"n\">intro</span><span class=\"o\">},</span> <span class=\"n\">trivial</span><span class=\"o\">}</span>\n  <span class=\"o\">},</span>\n <span class=\"kd\">end</span><span class=\"o\">,</span>\n <span class=\"k\">have</span> <span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"n\">irreflexive</span> <span class=\"n\">e1</span><span class=\"o\">,</span> <span class=\"k\">from</span>\n <span class=\"kd\">begin</span>\n  <span class=\"n\">intro</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n  <span class=\"n\">repeat</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">e1</span><span class=\"o\">,</span> <span class=\"n\">trivial</span> <span class=\"o\">},</span>\n <span class=\"kd\">end</span><span class=\"o\">,</span>\n <span class=\"n\">simple_graph.mk</span> <span class=\"n\">e1</span> <span class=\"n\">h1</span> <span class=\"n\">h2</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">g2.sym</span>\n</code></pre></div>\n<p>This only reveals that <code>g2.sym</code> is a very unreadable term <code>g2.sym : auto_param (symmetric g2.adj) (name.mk_string \"obviously\" name.anonymous)</code> of type <code>symmetric e1</code> I hope.  But what is the benefits of carrying this proof with the structure?</p>",
        "id": 218004407,
        "sender_full_name": "Alexandre Rademaker",
        "timestamp": 1606399108
    },
    {
        "content": "<p>hmm so my understanding is a bit shaky here, too. I think that the  part matching <code>auto_param (_) (_ \"obviously\" _)</code> means that Lean did or will try to prove <code>symmetric e1</code> using the <code>obviously</code> tactic, which is currently the same as trying to prove it with <code>tidy</code></p>",
        "id": 218018869,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1606407484
    },
    {
        "content": "<p>Before seeing your code I had the impression that <code>g2.sym</code> would be of type <code>symmetric e1</code> or at least of some type that is defeq to <code>symmetric e1</code>.</p>",
        "id": 218019055,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1606407606
    },
    {
        "content": "<p>Maybe <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span>  or <span class=\"user-mention\" data-user-id=\"302826\">@Aaron Anderson</span> or <span class=\"user-mention\" data-user-id=\"303889\">@Alena Gusakov</span> can say something more helpful</p>",
        "id": 218019154,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1606407691
    },
    {
        "content": "<p>Often in mathlib we manage to build up a lot of theory without being very good at producing concrete examples. Thank you for trying to do that !</p>",
        "id": 218019254,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1606407741
    },
    {
        "content": "<p>When I first came to this server i was trying to prove any theorems about a certain finite group of cardinality <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>8</mn></mrow><annotation encoding=\"application/x-tex\">8</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">8</span></span></span></span> and I found the experience pretty disheartening</p>",
        "id": 218019305,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1606407779
    },
    {
        "content": "<p>The goal of the definition</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">simple_graph</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">adj</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">sym</span> <span class=\"o\">:</span> <span class=\"n\">symmetric</span> <span class=\"n\">adj</span> <span class=\"bp\">.</span> <span class=\"n\">obviously</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">loopless</span> <span class=\"o\">:</span> <span class=\"n\">irreflexive</span> <span class=\"n\">adj</span> <span class=\"bp\">.</span> <span class=\"n\">obviously</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>is to be functionally equivalent to the simpler definition</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">simple_graph</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">adj</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">sym</span> <span class=\"o\">:</span> <span class=\"n\">symmetric</span> <span class=\"n\">adj</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">loopless</span> <span class=\"o\">:</span> <span class=\"n\">irreflexive</span> <span class=\"n\">adj</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 218020516,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1606408581
    },
    {
        "content": "<p>To see what I mean by \"functionally equivalent\", check out the proofs that use <code>G.sym</code> and <code>G.loopless</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">ne_of_adj</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hab</span> <span class=\"o\">:</span> <span class=\"n\">G.adj</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≠</span> <span class=\"n\">b</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">G.loopless</span> <span class=\"n\">a</span> <span class=\"n\">hab</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>uses <code>G.loopless</code> <em>exactly</em> as if it was of type <code>irreflexive G.adj</code>, and</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">edge_symm</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">G.adj</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"bp\">↔</span> <span class=\"n\">G.adj</span> <span class=\"n\">v</span> <span class=\"n\">u</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">G.sym</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">G.sym</span> <span class=\"n\">x</span><span class=\"o\">⟩</span>\n</code></pre></div>\n<p>uses <code>G.sym</code> <em>exactly</em> as if it was of type <code>symmetric G.adj</code>.</p>",
        "id": 218020738,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1606408736
    },
    {
        "content": "<p>So when you are proving things using those properties, you can pretend it's just the simpler definition, and lean will make the necessary conversions for you.</p>",
        "id": 218020799,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1606408782
    },
    {
        "content": "<p>When you want to prove those properties, you have two choices:</p>",
        "id": 218021090,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1606408996
    },
    {
        "content": "<p>forget about the <code>. obviously</code>, and prove the two conditions by hand (what you've done)</p>",
        "id": 218021117,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1606409033
    },
    {
        "content": "<p>or try an abbreviated form.</p>",
        "id": 218021159,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1606409045
    },
    {
        "content": "<p>What I'd do in general is try what we did for the <code>complete_graph</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">complete_graph</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">adj</span> <span class=\"o\">:=</span> <span class=\"n\">ne</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>except with <code>adj := </code> whatever your relation is.</p>",
        "id": 218021196,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1606409098
    },
    {
        "content": "<p>Then lean will complain at you and say if it's missing one or both of the proofs, which you then just have to do the old-fashioned way.</p>",
        "id": 218021260,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1606409150
    },
    {
        "content": "<p>As to the other question you could be asking is <em>why have proofs as part of the structure at all?</em></p>",
        "id": 218021340,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1606409186
    },
    {
        "content": "<p>The answer I have to that is, if we didn't, objects of this type wouldn't be graphs!</p>",
        "id": 218021365,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1606409209
    },
    {
        "content": "<p>You could define it as</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">simple_graph</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">adj</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>but then you couldn't prove basic theorems that are true of graphs, because you'll have counterexamples to symmetry and irreflexitivity.</p>",
        "id": 218021499,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1606409341
    },
    {
        "content": "<p>I see, thank you <span class=\"user-mention\" data-user-id=\"302826\">@Aaron Anderson</span>  for the detailed explanation. So the instantiation of a simple_graph forces you to carry the proofs that certificate that the instance is a simple graph. The lemmas you provided using the proofs in the structure field also makes thing clear.</p>",
        "id": 218232408,
        "sender_full_name": "Alexandre Rademaker",
        "timestamp": 1606686584
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"121542\">@Alexandre Rademaker</span> <a href=\"https://leanprover.github.io/reference/expressions.html#implicit-arguments\">https://leanprover.github.io/reference/expressions.html#implicit-arguments</a> explains all the kinds of arguments that Lean supports -- these can appear both in argument lists to functions and to fields for structures.  The <code>auto_param</code> is an internal detail for the case of using a tactic to synthesize the optional argument (I think the documentation should say <em>optional</em> and not <em>implicit</em> in that last case)</p>",
        "id": 218350253,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1606772549
    },
    {
        "content": "<p>This is how I might write that proof (just changing things a little without changing the tactics really):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">node</span> <span class=\"bp\">|</span> <span class=\"n\">a</span> <span class=\"bp\">|</span> <span class=\"n\">b</span> <span class=\"bp\">|</span> <span class=\"n\">c</span>\n<span class=\"kn\">open</span> <span class=\"n\">node</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">e1</span> <span class=\"o\">:</span> <span class=\"n\">node</span> <span class=\"bp\">→</span> <span class=\"n\">node</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n <span class=\"bp\">|</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">true</span>\n <span class=\"bp\">|</span> <span class=\"n\">b</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">true</span>\n <span class=\"bp\">|</span> <span class=\"n\">a</span> <span class=\"n\">c</span> <span class=\"o\">:=</span> <span class=\"n\">true</span>\n <span class=\"bp\">|</span> <span class=\"n\">c</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">true</span>\n <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">false</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">g2</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">node</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">adj</span> <span class=\"o\">:=</span> <span class=\"n\">e1</span><span class=\"o\">,</span>\n  <span class=\"n\">sym</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">intros</span> <span class=\"n\">n</span> <span class=\"n\">m</span><span class=\"o\">,</span>\n    <span class=\"n\">cases</span> <span class=\"n\">n</span><span class=\"bp\">;</span> <span class=\"n\">cases</span> <span class=\"n\">m</span><span class=\"bp\">;</span> <span class=\"o\">{</span> <span class=\"n\">dunfold</span> <span class=\"n\">e1</span><span class=\"o\">,</span> <span class=\"n\">intro</span><span class=\"o\">,</span> <span class=\"n\">trivial</span> <span class=\"o\">},</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">loopless</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">intro</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n    <span class=\"n\">cases</span> <span class=\"n\">n</span><span class=\"bp\">;</span> <span class=\"o\">{</span> <span class=\"n\">dunfold</span> <span class=\"n\">e1</span><span class=\"o\">,</span> <span class=\"n\">trivial</span> <span class=\"o\">},</span>\n  <span class=\"kd\">end</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 218378880,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1606795661
    },
    {
        "content": "<p>The <code>tidy</code> tactic is able to prove it's a simple graph with a little help:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">g2</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">node</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">adj</span> <span class=\"o\">:=</span> <span class=\"n\">e1</span><span class=\"o\">,</span>\n  <span class=\"n\">sym</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">n</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">cases</span> <span class=\"n\">n</span><span class=\"bp\">;</span> <span class=\"n\">cases</span> <span class=\"n\">m</span><span class=\"bp\">;</span> <span class=\"n\">tidy</span><span class=\"o\">,</span>\n  <span class=\"n\">loopless</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">cases</span> <span class=\"n\">n</span><span class=\"bp\">;</span> <span class=\"n\">tidy</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>What <code>;</code> does is run the following tactics for each case generated by the first tactic.  So, for example, <code>cases n; cases m; tidy</code> ends up running tidy for each possibility for <code>n</code> and <code>m</code>.</p>",
        "id": 218382347,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1606800577
    },
    {
        "content": "<p>In the end, both proofs just do <code>cases</code> on each argument, so here's a way to compact it.  This should work in general to prove that other adjacency relations defined in a similar way are graphs:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">cases'</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">unit</span> <span class=\"o\">:=</span> <span class=\"bp\">`</span><span class=\"o\">[</span><span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">cases</span> <span class=\"n\">h</span><span class=\"bp\">;</span> <span class=\"o\">{</span> <span class=\"n\">trivial</span> <span class=\"bp\">&lt;|&gt;</span> <span class=\"n\">cases'</span> <span class=\"o\">}]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">g2</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">node</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">adj</span> <span class=\"o\">:=</span> <span class=\"n\">e1</span><span class=\"o\">,</span>\n  <span class=\"n\">sym</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">cases'</span><span class=\"o\">,</span>\n  <span class=\"n\">loopless</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">cases'</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 218382648,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1606800974
    }
]
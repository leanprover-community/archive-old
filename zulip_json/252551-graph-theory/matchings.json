[
    {
        "content": "<p>Is there anything else I need to do to get <a href=\"https://github.com/leanprover-community/mathlib/pull/5156\">#5156</a> approved? There were two suggestions that I put aside for later, should I just implement them now?</p>",
        "id": 218626699,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1606946724
    },
    {
        "content": "<p>Don't know where to ask this - do people typically keep working from a branch after a PR from it has been approved?</p>",
        "id": 218769240,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1607037894
    },
    {
        "content": "<p>github prefers that you don't</p>",
        "id": 218770267,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607038465
    },
    {
        "content": "<p>gotcha</p>",
        "id": 218770275,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1607038472
    },
    {
        "content": "<p>the UI gets a little wonky if you try to reopen a PR or reuse a PR branch</p>",
        "id": 218770296,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607038496
    },
    {
        "content": "<p>i was just thinking that it feels a bit wasteful to keep making new branches for PRs</p>",
        "id": 218770322,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1607038516
    },
    {
        "content": "<p>you can delete the old ones, you know</p>",
        "id": 218770342,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607038531
    },
    {
        "content": "<p>this is true, but does that delete the comment history?</p>",
        "id": 218770354,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1607038542
    },
    {
        "content": "<p>no</p>",
        "id": 218770361,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607038549
    },
    {
        "content": "<p>ah okay, then that works lol</p>",
        "id": 218770373,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1607038559
    },
    {
        "content": "<p>thanks</p>",
        "id": 218770415,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1607038571
    },
    {
        "content": "<p>although it may make it harder to track down the commits they are attached to</p>",
        "id": 218770416,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607038571
    },
    {
        "content": "<p>but if they have been squash merged in it's not particularly important to retain them</p>",
        "id": 218770443,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607038601
    },
    {
        "content": "<p>gotcha</p>",
        "id": 218770451,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1607038613
    },
    {
        "content": "<p>Bors deletes merged branches anyway, doesn't it?</p>",
        "id": 218770606,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1607038735
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/tree/simple_graph_matching\">https://github.com/leanprover-community/mathlib/tree/simple_graph_matching</a></p>",
        "id": 218770628,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1607038759
    },
    {
        "content": "<p>this one's still up</p>",
        "id": 218770630,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1607038762
    },
    {
        "content": "<p>what's the PR?</p>",
        "id": 218770656,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607038789
    },
    {
        "content": "<p>without realizing it i committed Eric's suggestion at the bottom, and that seems to have done something weird</p>",
        "id": 218770710,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1607038812
    },
    {
        "content": "<p>You sure you didn't put it back up after bors deleted it?</p>",
        "id": 218770717,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1607038821
    },
    {
        "content": "<p>I honestly have no clue</p>",
        "id": 218770751,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1607038846
    },
    {
        "content": "<p>20 commits ahead and 25 behind master sounds like a bad sign</p>",
        "id": 218770760,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607038850
    },
    {
        "content": "<p>Maybe I did some weird branching or something</p>",
        "id": 218770767,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1607038856
    },
    {
        "content": "<p>the original commit is still good</p>",
        "id": 218770772,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1607038861
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/pull/5156\">https://github.com/leanprover-community/mathlib/pull/5156</a></p>",
        "id": 218770903,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1607038964
    },
    {
        "content": "<p>here's the PR</p>",
        "id": 218770907,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1607038967
    },
    {
        "content": "<p>I find the bors way of rebasing all PRs at merge time makes it really hard to work with branches that build on top of multiple open PRs, as you then have no easy way to merge in master when the PRs you depend on get in</p>",
        "id": 218770956,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1607039007
    },
    {
        "content": "<p>Nevermind, it wasn't the commit. I genuinely have no idea what happened there</p>",
        "id": 218770957,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1607039007
    },
    {
        "content": "<p>I might've just done something wrong accidentally because I was jumping back and forth between the two PRs I had open</p>",
        "id": 218770986,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1607039028
    },
    {
        "content": "<p>I can delete the branch maybe?</p>",
        "id": 218771088,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1607039093
    },
    {
        "content": "<p>you can delete it, but make sure you have everything you want to keep from it first</p>",
        "id": 218771151,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607039140
    },
    {
        "content": "<p>Actually I think it's okay - it looks like the PR keeps the comment history</p>",
        "id": 218771266,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1607039219
    },
    {
        "content": "<p>To delete I mean</p>",
        "id": 218771279,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1607039235
    },
    {
        "content": "<p>There's some stuff about matchings here: <a href=\"https://github.com/leanprover-community/mathlib/blob/simple_graph_matching/src/combinatorics/simple_graph/matching.lean\">https://github.com/leanprover-community/mathlib/blob/simple_graph_matching/src/combinatorics/simple_graph/matching.lean</a></p>\n<p>For a perfect matching, it occurred to me that it might be useful to have an equivalence with this type:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">{</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"bp\">//</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">G.adj</span> <span class=\"n\">v</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">v</span><span class=\"o\">))</span> <span class=\"bp\">∧</span> <span class=\"n\">involutive</span> <span class=\"n\">g</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>(or rather, given a perfect matching, have a definition for the <code>V → V</code> function and a lemma for the property it satisfies).<br>\nI think there are some partial versions of this in there already.</p>\n<p><a href=\"https://en.wikipedia.org/wiki/Tutte_theorem\">Tutte's theorem</a> might be a good to prove to develop the matchings part of the library, if someone wants a graph theory project.</p>",
        "id": 243550397,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1624382780
    },
    {
        "content": "<p>oh true, i forgot about tutte's theorem</p>",
        "id": 243550467,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1624382817
    },
    {
        "content": "<p>that was gonna be my next goal</p>",
        "id": 243550486,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1624382825
    },
    {
        "content": "<p>I've stated it at <a href=\"#narrow/stream/116395-maths/topic/some.20newbie.20questions.20about.20following.20progress/near/243549319\">https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/some.20newbie.20questions.20about.20following.20progress/near/243549319</a> but it needs the \"right\" definitions of connected components in terms of walks, I think.</p>",
        "id": 243550607,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1624382880
    },
    {
        "content": "<p>oh neat, okay</p>",
        "id": 243550677,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1624382897
    },
    {
        "content": "<p>Ok, I hereby declare that <span class=\"user-mention\" data-user-id=\"303889\">@Alena Gusakov</span> has claimed the theorem</p>",
        "id": 243550678,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1624382898
    },
    {
        "content": "<p>Is there any generalisation of matchings we might want to consider?</p>",
        "id": 243555318,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1624384866
    },
    {
        "content": "<p>Alena, there's an ancient PR of yours I reviewed (what feels like) centuries ago. Are you still interested in that or should I just fix it up ^^</p>",
        "id": 243555942,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1624385121
    },
    {
        "content": "<p>I am very interested in understanding and playing with perfect matchings - mainly because I want to see how a proof like this (<a href=\"https://mathoverflow.net/questions/267002/graphs-with-only-disjoint-perfect-matchings\">https://mathoverflow.net/questions/267002/graphs-with-only-disjoint-perfect-matchings</a>) would be formalized.</p>\n<p>The reason behind is, that a generalization of this statement to weighted graph is an open question, and has important relevance in quantum mechanics (and it looks simple enough to be a good starting point to Lean). Do you think it is a reasonably simple project as a beginner of Lean? Curious about your thoughts. Thanks :)</p>",
        "id": 243560673,
        "sender_full_name": "Mario Krenn",
        "timestamp": 1624387171
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> I'm not sure of any real uses of it, but there's a weakened version of a perfect matching that you might call a function carried by a graph.  It's a subgraph of the graph that contains every vertex and which has been given an orientation such that each vertex has exactly one outgoing edge.  You can represent it by this type:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">{</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"bp\">//</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">G.adj</span> <span class=\"n\">v</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">v</span><span class=\"o\">))</span> <span class=\"bp\">∧</span> <span class=\"n\">injective</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"bp\">⟦</span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">g</span> <span class=\"n\">v</span><span class=\"o\">)</span><span class=\"bp\">⟧</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p><a href=\"https://arxiv.org/pdf/2101.00127.pdf\">Theorem 3.5.1</a></p>\n<p>Here it is formalized for current mathlib:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.finset</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.fintype.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">combinatorics.simple_graph.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">combinatorics.hall</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">function</span>\n<span class=\"kn\">open</span> <span class=\"n\">simple_graph</span>\n\n<span class=\"sd\">/-- A necessary and sufficient condition for there to be a \"function carried by a graph\" is that</span>\n<span class=\"sd\">the set of edges incident to each finite subset of k vertices has at least k edges, for each k. -/</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">exists_carried_fun_iff</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">decidable_rel</span> <span class=\"n\">G.adj</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">V</span><span class=\"o\">),</span> <span class=\"n\">U.card</span> <span class=\"bp\">≤</span> <span class=\"o\">(</span><span class=\"n\">U.bUnion</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">G.incidence_finset</span> <span class=\"n\">u</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"o\">)</span>\n  <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">V</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">G.adj</span> <span class=\"n\">v</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">v</span><span class=\"o\">))</span> <span class=\"bp\">∧</span> <span class=\"n\">injective</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"bp\">⟦</span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">g</span> <span class=\"n\">v</span><span class=\"o\">)</span><span class=\"bp\">⟧</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">convert</span> <span class=\"n\">finset.all_card_le_bUnion_card_iff_exists_injective</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">G.incidence_finset</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"n\">using</span> <span class=\"mi\">1</span><span class=\"o\">,</span>\n  <span class=\"n\">ext</span><span class=\"o\">,</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">ha</span><span class=\"o\">,</span> <span class=\"n\">hinj</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">use</span> <span class=\"bp\">λ</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"bp\">⟦</span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">g</span> <span class=\"n\">v</span><span class=\"o\">)</span><span class=\"bp\">⟧</span><span class=\"o\">,</span>\n    <span class=\"n\">use</span> <span class=\"n\">hinj</span><span class=\"o\">,</span>\n    <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">ha</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">hinj</span><span class=\"o\">,</span> <span class=\"n\">hi</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">mem_incidence_finset</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hi</span><span class=\"o\">,</span>\n    <span class=\"n\">use</span> <span class=\"bp\">λ</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">hi</span> <span class=\"n\">v</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"bp\">.</span><span class=\"n\">other</span><span class=\"o\">,</span>\n    <span class=\"n\">split</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">intro</span> <span class=\"n\">v</span><span class=\"o\">,</span>\n      <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">hi</span> <span class=\"n\">v</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"o\">,</span>\n      <span class=\"n\">rw</span> <span class=\"bp\">←</span><span class=\"n\">sym2.mem_other_spec</span> <span class=\"o\">(</span><span class=\"n\">hi</span> <span class=\"n\">v</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n      <span class=\"n\">rwa</span> <span class=\"n\">mem_edge_set</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">hinj</span><span class=\"o\">,</span> <span class=\"n\">sym2.mem_other_spec</span><span class=\"o\">]</span> <span class=\"o\">},</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 243562041,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1624387766
    },
    {
        "content": "<p>This also works for infinite graphs so long as the graph is locally finite, using the infinite version of Hall's theorem (infinite Hall is currently in a PR)</p>",
        "id": 243562704,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1624388056
    },
    {
        "content": "<p>Oh nice!</p>",
        "id": 243563257,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1624388329
    },
    {
        "content": "<p>Note that Bhavik and Alena's paper is a bit unclear about whether it's true for all functions or whether we choose it.</p>",
        "id": 243563372,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1624388388
    },
    {
        "content": "<p>Also I think this is exactly stating that G has a 2-factor. A perfect matching is a 1-factor.</p>",
        "id": 243563519,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1624388443
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"297962\">Mario Krenn</span> <a href=\"#narrow/stream/252551-graph-theory/topic/matchings/near/243560673\">said</a>:</p>\n<blockquote>\n<p>I want to see how a proof like this (<a href=\"https://mathoverflow.net/questions/267002/graphs-with-only-disjoint-perfect-matchings\">https://mathoverflow.net/questions/267002/graphs-with-only-disjoint-perfect-matchings</a>) would be formalized. [...] Do you think it is a reasonably simple project as a beginner of Lean?</p>\n</blockquote>\n<p>I think the usual advice is that beginners should prove things involving objects that are already defined -- making good definitions for formalization is tricky.  Also, combinatorics seems to be particularly tricky to formalize because proofs tend to appeal to intuition.</p>\n<p>Right now the simple graph library lacks walks, paths, cycles, and Hamiltonian cycles (and their supporting lemmas).  If you feel up to it, you can try your hand at these things and get help along the way here on Zulip.  In a way it shouldn't be hard, but I'm not sure it'll be a simple project.</p>",
        "id": 243564063,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1624388679
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/252551-graph-theory/topic/matchings/near/243563372\">said</a>:</p>\n<blockquote>\n<p>unclear about whether it's true for all functions or whether we choose it.</p>\n</blockquote>\n<p>It should have also said \"a graph <em>carries a function</em> if there exists a function <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> that the graph carries.\"  This is my fault.</p>\n<p>I don't think a graph carrying a function is equivalent to it having a 2-factor.  It's whether there's a spanning subgraph such that each component has exactly one cycle.  So, cycles with trees growing out of them.</p>",
        "id": 243564782,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1624389001
    },
    {
        "content": "<p>Ah I see</p>",
        "id": 243564904,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1624389053
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"297962\">Mario Krenn</span> <a href=\"#narrow/stream/252551-graph-theory/topic/matchings/near/243560673\">said</a>:</p>\n<blockquote>\n<p>Do you think it is a reasonably simple project as a beginner of Lean? Curious about your thoughts. Thanks :)</p>\n</blockquote>\n<p>My advice for you is to not work alone. Get someone to help you along the way. Stick yourself to an existing project you already understand mathematically.</p>",
        "id": 243565028,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1624389114
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"297962\">@Mario Krenn</span> By the way, in case it's useful, here's a potential formalization of the theorem statement:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">combinatorics.simple_graph.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">combinatorics.simple_graph.matching</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">classical</span>\n<span class=\"kd\">noncomputable theory</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">fintype</span>\n\n<span class=\"c1\">-- https://mathoverflow.net/questions/267002/graphs-with-only-disjoint-perfect-matchings</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">k4_if_three_disjoint_perfect_matchings</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">m₁</span> <span class=\"n\">m₂</span> <span class=\"n\">m₃</span> <span class=\"o\">:</span> <span class=\"n\">G.matching</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">m₁.is_perfect</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"n\">m₂.is_perfect</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₃</span> <span class=\"o\">:</span> <span class=\"n\">m₃.is_perfect</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">d₁₂</span> <span class=\"o\">:</span> <span class=\"n\">disjoint</span> <span class=\"n\">m₁.edges</span> <span class=\"n\">m₂.edges</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">d₁₃</span> <span class=\"o\">:</span> <span class=\"n\">disjoint</span> <span class=\"n\">m₁.edges</span> <span class=\"n\">m₃.edges</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">d₂₃</span> <span class=\"o\">:</span> <span class=\"n\">disjoint</span> <span class=\"n\">m₂.edges</span> <span class=\"n\">m₃.edges</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">card</span> <span class=\"n\">V</span> <span class=\"bp\">=</span> <span class=\"mi\">4</span> <span class=\"bp\">∧</span> <span class=\"n\">G</span> <span class=\"bp\">=</span> <span class=\"n\">complete_graph</span> <span class=\"n\">V</span> <span class=\"o\">:=</span>\n<span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 243572976,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1624392864
    },
    {
        "content": "<p>I must not have understood the theorem, because this is a counterexample to the formalized statement:<br>\n<a href=\"/user_uploads/3121/_J0KTlRGNEi5hRmxbdjrcRW3/image.png\">image.png</a> </p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/_J0KTlRGNEi5hRmxbdjrcRW3/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/_J0KTlRGNEi5hRmxbdjrcRW3/image.png\"></a></div><p>You can get such a counterexample from any face 3-coloring of a 3-regular graph cellularly embedded on a surface.  (In this case, a cube graph on a plane/sphere.)</p>",
        "id": 243574918,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1624393902
    },
    {
        "content": "<p>Actually, any 3-regular graph that's edge 3-colorable works as a counterexample.  Each set of edges of the same color forms a perfect matching, and these sets are disjoint.</p>",
        "id": 243575338,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1624394093
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"284160\">@Eric Rodriguez</span> sorry about that, i'll try to circle back to that PR this week or something</p>",
        "id": 243576637,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1624394777
    },
    {
        "content": "<p>i've just completely forgotten about it cause i started a class</p>",
        "id": 243576656,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1624394792
    },
    {
        "content": "<p>I think I've understood it now.  Corrected:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">combinatorics.simple_graph.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">combinatorics.simple_graph.matching</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">classical</span>\n<span class=\"kd\">noncomputable theory</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">fintype</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"n\">G.matching</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"c1\">-- https://mathoverflow.net/questions/267002/graphs-with-only-disjoint-perfect-matchings</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">k4_if_perfect_matchings_disjoint</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">hc</span> <span class=\"o\">:</span> <span class=\"n\">card</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">G.matching</span> <span class=\"bp\">|</span> <span class=\"n\">m.is_perfect</span><span class=\"o\">}</span> <span class=\"bp\">≥</span> <span class=\"mi\">3</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">hd</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">m'</span> <span class=\"o\">:</span> <span class=\"n\">G.matching</span><span class=\"o\">),</span> <span class=\"n\">m.is_perfect</span> <span class=\"bp\">→</span> <span class=\"n\">m'.is_perfect</span> <span class=\"bp\">→</span> <span class=\"n\">m</span> <span class=\"bp\">≠</span> <span class=\"n\">m'</span> <span class=\"bp\">→</span> <span class=\"n\">disjoint</span> <span class=\"n\">m.edges</span> <span class=\"n\">m'.edges</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">card</span> <span class=\"n\">V</span> <span class=\"bp\">=</span> <span class=\"mi\">4</span> <span class=\"bp\">∧</span> <span class=\"n\">G</span> <span class=\"bp\">=</span> <span class=\"n\">complete_graph</span> <span class=\"n\">V</span> <span class=\"o\">:=</span>\n<span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 243576742,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1624394845
    },
    {
        "content": "<p>I think this corrected theorem is still not correct, though, because there's another counterexample:<br>\n<a href=\"/user_uploads/3121/K5QWRWEXQEi_SER710aof8Ni/image.png\">image.png</a> </p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/K5QWRWEXQEi_SER710aof8Ni/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/K5QWRWEXQEi_SER710aof8Ni/image.png\"></a></div><p>This is the generalized Petersen graph G(9,2), which is uniquely edge 3-colorable (meaning, up to permutation of colors, there is only one edge 3-coloring).</p>\n<p>If you have a graph such that all its perfect matchings are disjoint, then you can take the subgraph consisting of edges that are members of one of the perfect matchings.  If there are at least three perfect matchings, then choose three of the perfect matchings and throw the rest of the edges out.  If you take each perfect matching as a distinct color, then you are left with an edge 3-coloring.  Conversely, given an edge 3-coloring you get three disjoint perfect matchings on the original graph.</p>",
        "id": 243578563,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1624395816
    },
    {
        "content": "<p>Their argument is to form a cycle from two matchings. What does it give here?</p>",
        "id": 243578804,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1624395937
    },
    {
        "content": "<p>Matsumoto, \"Conjectures on uniquely 3-edge colorable graphs\" in Contributions to Discrete Mathematics (2016) lists some conjectures.  Fiorini and Wilson conjecture that every nonplanar 3-regular uniquely edge 3-colorable graph is related to G(9,2) by a sequence of delta-wye moves, and that every planar 3-regular uniquely edge 3-colorable graph is related to K_4 by a sequence of delta-wye moves.</p>",
        "id": 243579636,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1624396440
    },
    {
        "content": "<p>Oh wow! That was quite a quick digging up</p>",
        "id": 243579806,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1624396524
    },
    {
        "content": "<p>I think I've made a silly mistake though.  Just because a graph is uniquely edge 3-colorable doesn't mean there are only three perfect matchings.  It's worth checking G(9,2) just to be sure...</p>",
        "id": 243579979,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1624396595
    },
    {
        "content": "<p>Did you see the recent AI graph counterexample paper?</p>",
        "id": 243580621,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1624396875
    },
    {
        "content": "<p>Oh what's that?</p>",
        "id": 243580722,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1624396923
    },
    {
        "content": "<p>Gowers tweeted about it a few weeks ago and it was discussed here too, maybe in one of the ML streams</p>",
        "id": 243580777,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1624396962
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/252551-graph-theory/topic/matchings/near/243574918\">said</a>:</p>\n<blockquote>\n<p>I must not have understood the theorem, because this is a counterexample to the formalized statement:<br>\n<a href=\"/user_uploads/3121/_J0KTlRGNEi5hRmxbdjrcRW3/image.png\">image.png</a> </p>\n<p>You can get such a counterexample from any face 3-coloring of a 3-regular graph cellularly embedded on a surface.  (In this case, a cube graph on a plane/sphere.)</p>\n</blockquote>\n<p>Thanks for the examples. However, this graph has more than 3 perfect matchings. <a href=\"/user_uploads/3121/7xSah6ATmDietyXnsj_BJTB-/grafik.png\">grafik.png</a> -- and thus not all PMs are disjoint sets of edges.</p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/7xSah6ATmDietyXnsj_BJTB-/grafik.png\" title=\"grafik.png\"><img src=\"/user_uploads/3121/7xSah6ATmDietyXnsj_BJTB-/grafik.png\"></a></div>",
        "id": 243583390,
        "sender_full_name": "Mario Krenn",
        "timestamp": 1624398691
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"297962\">@Mario Krenn</span> I also just counted the number of perfect matchings for G(9,2): 22</p>",
        "id": 243583519,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1624398774
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span>  Ah ok good. If you find a counter example, send me your bank account. I announced a 3000Euro prize for a counter example (or proof) of the generalization :D  (see <a href=\"https://mariokrenn.wordpress.com/graph-theory-question/\">https://mariokrenn.wordpress.com/graph-theory-question/</a> or <a href=\"https://mathoverflow.net/questions/311325/vertex-coloring-inherited-from-perfect-matchings-motivated-by-quantum-physics\">https://mathoverflow.net/questions/311325/vertex-coloring-inherited-from-perfect-matchings-motivated-by-quantum-physics</a>)</p>",
        "id": 243583714,
        "sender_full_name": "Mario Krenn",
        "timestamp": 1624398912
    },
    {
        "content": "<p>The cube example was from when I thought it was whether there existed three disjoint perfect matchings, and G(9,2) was when I mistakenly thought having three simultaneously disjoint perfect matchings in a cubic graph meant there couldn't be more perfect matchings.  The second formalized theorem statement seems to be correct so far.</p>",
        "id": 243583729,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1624398928
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/252551-graph-theory/topic/matchings/near/243572976\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"297962\">Mario Krenn</span> By the way, in case it's useful, here's a potential formalization of the theorem statement:<br>\n</p>\n</blockquote>\n<p>Wow thats so cool, thanks a lot, will try to go through it tomorrow in detail! thanks :)</p>",
        "id": 243584077,
        "sender_full_name": "Mario Krenn",
        "timestamp": 1624399193
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"303889\">Alena Gusakov</span> <a href=\"#narrow/stream/252551-graph-theory/topic/matchings/near/243576637\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"284160\">Eric Rodriguez</span> sorry about that, i'll try to circle back to that PR this week or something</p>\n</blockquote>\n<p>No worries, hadn't seen you around in forever so just wanted to remind you ^^ hope the class went well</p>",
        "id": 243584481,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1624399413
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/252551-graph-theory/topic/matchings/near/243580621\">said</a>:</p>\n<blockquote>\n<p>Did you see the recent AI graph counterexample paper?</p>\n</blockquote>\n<p>Do you mean this one: <a href=\"https://arxiv.org/abs/2104.14516\">https://arxiv.org/abs/2104.14516</a> ?</p>",
        "id": 243584966,
        "sender_full_name": "Mario Krenn",
        "timestamp": 1624399697
    },
    {
        "content": "<p>Yes that was it. Thanks for finding it -- was about to plough through Twitter to try and find the URL again!</p>",
        "id": 243585187,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1624399837
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/252551-graph-theory/topic/matchings/near/243585187\">said</a>:</p>\n<blockquote>\n<p>Yes that was it. Thanks for finding it -- was about to plough through Twitter to try and find the URL again!</p>\n</blockquote>\n<p>I just had a call with an AI expert (who works with Christian S.) about Lean and formal AI provers, he mentioned it, funny that 10mins later you mention it :D</p>",
        "id": 243585307,
        "sender_full_name": "Mario Krenn",
        "timestamp": 1624399925
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"297962\">Mario Krenn</span> <a href=\"#narrow/stream/252551-graph-theory/topic/matchings/near/243584966\">said</a>:</p>\n<blockquote>\n<p>Do you mean this one: <a href=\"https://arxiv.org/abs/2104.14516\">https://arxiv.org/abs/2104.14516</a> ?</p>\n</blockquote>\n<p>I just read it. This is insane!</p>",
        "id": 243746658,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1624516726
    },
    {
        "content": "<p>Maybe one day we will routinely use this kind of approach to check conjectures even before publishing.</p>",
        "id": 243746690,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1624516766
    },
    {
        "content": "<p>Not if they're conjectures about infinite-dimensional Banach spaces...</p>",
        "id": 243751222,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1624520464
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/252551-graph-theory/topic/matchings/near/243746690\">said</a>:</p>\n<blockquote>\n<p>Maybe one day we will routinely use this kind of approach to check conjectures even before publishing.</p>\n</blockquote>\n<p>As Kevin hinted at, the proportion of mathematics that could be treated like this is infinitesimal, although it gets a huge popular science press coverage because it's so much easier to talk about.</p>",
        "id": 243755738,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1624523649
    },
    {
        "content": "<p>Rob Kirby once suggested using AI to generate candidate exotic <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>S</mi><mn>4</mn></msup></mrow><annotation encoding=\"application/x-tex\">S^4</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">4</span></span></span></span></span></span></span></span></span></span></span>'s, which is not implausible because compact smooth 4-manifolds can be represented by, essentially, a graph -- a Kirby diagram. I've been skeptical, though, because it's unclear how you'd train something like this if there are no examples.</p>\n<p>The great thing about extremal graph theory for this seems to be that questions come with a natural choice of objective/reward function.  It would be cool if 4-manifolds had similar (computable) functions that measured how close to being an <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>S</mi><mn>4</mn></msup></mrow><annotation encoding=\"application/x-tex\">S^4</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">4</span></span></span></span></span></span></span></span></span></span></span> a diagram is and how exotic the manifold is.  Maybe, at least, an AI could learn how to simplify Kirby diagrams, since diagrams have a natural measure of complexity.</p>",
        "id": 243813541,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1624553107
    },
    {
        "content": "<p>I also remember seeing some papers doing something with Calabi Yau varieties using ML.</p>",
        "id": 243813929,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1624553294
    },
    {
        "content": "<p>I remember hearing about <a href=\"https://arxiv.org/abs/0906.5177\">this paper</a> which seems relevant. <span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> isn't subscribed to this stream though (and I'm not sure if I should forcibly subscribe him).</p>",
        "id": 243813931,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1624553294
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"123965\">@Bryan Gin-ge Chen</span> My understanding is that the current state-of-the-art in Kirby diagram simplification is Bob Gompf himself</p>",
        "id": 243814497,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1624553556
    },
    {
        "content": "<p>That could well be the case. I do remember being shown some papers of Akbulut with really amazing sequences of Kirby diagrams too.</p>",
        "id": 243826049,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1624558885
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/252551-graph-theory/topic/matchings/near/243814497\">said</a>:</p>\n<blockquote>\n<p>My understanding is that the current state-of-the-art in Kirby diagram simplification is Bob Gompf himself</p>\n</blockquote>\n<p>Don't you mean Akbulut?</p>",
        "id": 243833510,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1624562263
    },
    {
        "content": "<p>When I read your first message I immediately thought: OMG, he wants a artifical Akbulut...</p>",
        "id": 243833615,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1624562293
    },
    {
        "content": "<p>The Calabi Yau ML stuff is guessing data from equations and when the guy spoke about it at Imperial I asked a bunch of questions about the nature of the data (eg he's claiming that his AI can predict the dimension of some cohomology space with 90% accuracy and I asked whether the answer was 0 90% of the time and he said he never checked).</p>",
        "id": 243853984,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1624573320
    },
    {
        "content": "<p>I need help on this one: <a href=\"https://github.com/leanprover-community/mathlib/pull/10210\">https://github.com/leanprover-community/mathlib/pull/10210</a><br>\nI was able to prove the <code>is_perfect_iff</code> lemma (thanks <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> for the help with the right implication). But now I got stuck on the <code>is_perfect_then_even_card_vertices</code> lemma (and on the one above it).</p>",
        "id": 260609209,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636338373
    },
    {
        "content": "<p>I decided to make the PR smaller and just do the refactoring, defining matchings as subgraphs. It's ready for review!</p>",
        "id": 260651518,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636375470
    },
    {
        "content": "<p>I would like to know what people think of defining matchings vs having them as a special case of k-factors.</p>",
        "id": 260671818,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1636385202
    },
    {
        "content": "<p>Technically there's no definition of a matching, but rather a characterization of subgraphs that are matchings (according to the approach suggested by Kyle)</p>",
        "id": 260672491,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636385456
    },
    {
        "content": "<p>Sure, take my question as \"Should we spell it <code>G.is_matching H</code> or <code>G.is_factor 1 H</code>?\"</p>",
        "id": 260673838,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1636386006
    },
    {
        "content": "<p>We can have both of them and a lemma that proves their equivalence, wdyt?</p>",
        "id": 260674043,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636386094
    },
    {
        "content": "<p>Or we can just not have <code>is_matching</code>.&lt;insert Kyle's opinion here&gt;</p>",
        "id": 260674165,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1636386140
    },
    {
        "content": "<p>I am usually in favor of API richness that helps with usability. Ppl usually do study matchings in UG CS courses and thinking of them as 2-factors is not as straightforward</p>",
        "id": 260674659,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636386361
    },
    {
        "content": "<p>The more general we make the API, the more alien it will look to outcomers... it's a thin trade-off <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span> </p>\n<p>I'm not sure where to draw the line, but it's something to keep in mind</p>",
        "id": 260674915,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636386457
    },
    {
        "content": "<p>Each definition comes with a cost (the API), and each definition is one more thing for Lean to unfold, so there needs to be some sort of balance, but it's a bit of an art working out where it is. I was very frustrated over the weekend not being able to say <code>is_singleton</code> and instead having to keep asking for non-empty subsingletons, but I persevered because I didn't want to make a robust API for something which \"we have already\" in some sense.</p>",
        "id": 260675871,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1636386829
    },
    {
        "content": "<p>If the primary goal is to have everything as efficiently formalized as possible, then I am all in favor of dropping matchings. But if we're also targeting people without as much mathematical maturity and even less \"Lean maturity\", then it becomes a concern (not only for matchings, but for more general use cases of <code>mathlib</code>)</p>",
        "id": 260679917,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636388272
    },
    {
        "content": "<p>I'm not sure how many theorems about factors will apply to matchings, so it likely won't be a bad kind of API duplication.  Also, it seems very likely to me that, should it come to it, we can define <code>G.is_matching</code> in terms of <code>G.is_factor</code> without too much additional work, given how things are looking right now, so my opinion right now is to carry on.</p>\n<p>(I'll try to take more of a look at this matching PR later today.)</p>",
        "id": 260680620,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636388550
    },
    {
        "content": "<p>Regarding alien definitions: one thing to keep in mind is that once you have a definition, you can build out interfaces to it that look more normal.  This can be justified if the definition is more powerful somehow, or if it reduces maintenance costs for the relatively small team that develops mathlib.  (Defining colorings to be homomorphisms is an example of this -- this isn't an uncommon way for mathematicians to study colorings anyway, and it lets us reuse a bunch of machinery that had already been written (and it helped me notice that there are some missing things about homomorphisms). Also, we could create an API for it that looked like the obvious translation.)</p>",
        "id": 260681227,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636388796
    },
    {
        "content": "<p>(Even graph homomorphisms are defined in terms of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/rel_hom\">docs#rel_hom</a>, which is essentially the definition of a homomorphism for an undirected graph allowing self-loops.)</p>",
        "id": 260681650,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636388974
    },
    {
        "content": "<p>This is true. The PR that characterizes matchings as subgraphs ended up enriching the subgraph API</p>",
        "id": 260682060,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636389128
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"451983\">Arthur Paulino</span> <a href=\"#narrow/stream/252551-graph-theory/topic/matchings/near/260679917\">said</a>:</p>\n<blockquote>\n<p>If the primary goal is to have everything as efficiently formalized as possible, then I am all in favor of dropping matchings. But if we're also targeting people without as much mathematical maturity and even less \"Lean maturity\", then it becomes a concern (not only for matchings, but for more general use cases of <code>mathlib</code>)</p>\n</blockquote>\n<p>We have a very clear answer to this. <code>mathlib</code> tries to be a comprehensive library for professional mathematicians and computer scientists. Then you can build a teaching library out of it if you want. This is done in the tutorial project which uses a custom definition for limits of sequences of real numbers but then secretly hooks into mathlib behind the scene when it needs to use without proof the Bolzano-Weirstrass theorem.</p>",
        "id": 260682065,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1636389130
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/252551-graph-theory/topic/matchings/near/260673838\">said</a>:</p>\n<blockquote>\n<p>Sure, take my question as \"Should we spell it <code>G.is_matching H</code> or <code>G.is_factor 1 H</code>?\"</p>\n</blockquote>\n<p>Typically a \"factor\" of G is defined to be a spanning subgraph of G, and a k-factor of G is defined to be a k-regular factor of G. With this terminology, 1-factors correspond to perfect matchings only.</p>\n<p>If I understand correctly, the notion of <code>is_factor</code> proposed here says that the subgraph <code>H</code>, when coerced to a graph, is regular (but not necessarily spanning). If so, would adding <code>is_regular</code> and a coercion be enough?</p>",
        "id": 260686167,
        "sender_full_name": "Mauricio Collares",
        "timestamp": 1636390892
    },
    {
        "content": "<p>For a fixed graph H and a host graph G, a common definition is to say a graph G' is an H-factor of G if G' is a spanning subgraph of G isomorphic to a bunch of disjoint copies of H, as in <a href=\"https://arxiv.org/abs/0803.3406\">https://arxiv.org/abs/0803.3406</a> for example. This generalizes 1-factors (which are K_2-factors). It does not generalize k-factors as is, but it's easy to find a common generalization by replacing H by a family $\\mathcal{H}$ of graphs (which you could take as the family of $k$-regular graphs, say). I don't think it's useful to state it like this in mathlib right now, but it's certainly a concept people care about: as an indication, the aforementioned paper won the 2012 Fulkerson Prize.</p>",
        "id": 260688609,
        "sender_full_name": "Mauricio Collares",
        "timestamp": 1636391922
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"325367\">@Mauricio Collares</span> How would you organize the API to accommodate such generalization accounting for the fact that \"_-factor\" is used with _ replaced by an integer or by the name of a graph?</p>",
        "id": 260698445,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636395944
    },
    {
        "content": "<p>No idea, I guess another name would be necessary. But I wouldn't worry about the more general concept until someone decides to prove a result that uses it; I just couldn't resist mentioning it. Don't let that message interrupt you :) My main point was the first message (that is, I think \"factor\" usually implies \"spanning\" while \"matching\" doesn't)</p>",
        "id": 260699294,
        "sender_full_name": "Mauricio Collares",
        "timestamp": 1636396318
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"325367\">@Mauricio Collares</span> That's a good point that factors are spanning subgraphs.  Maybe the following seems reasonable then if it's formalized as a relation:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">simple_graph.is_factor_of</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"n\">G'</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">G</span> <span class=\"bp\">≤</span> <span class=\"n\">G'</span> <span class=\"bp\">∧</span> <span class=\"n\">G.is_regular_of_degree</span> <span class=\"n\">k</span>\n</code></pre></div>\n<p>Then you can write <code>G.is_factor_of 1 G'</code> for <code>G</code> being a perfect matching of <code>G'</code>.</p>",
        "id": 260702199,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636397745
    },
    {
        "content": "<p>(the order on <code>simple_graph V</code> is \"spanning subgraph of\")</p>",
        "id": 260702313,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636397790
    },
    {
        "content": "<p>(I'm very ignorant about k-factors beyond perfect matchings.)</p>",
        "id": 260702657,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636397958
    },
    {
        "content": "<p>Another possibility, maybe a bit awkward but shorter, is being able to state <code>H.factors G</code> (\"factors\" as a verb)</p>",
        "id": 260703349,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636398212
    },
    {
        "content": "<p>I think it's nice to access the factor number, so that you can tell \"is a 1-factor\"</p>",
        "id": 260709310,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1636401062
    },
    {
        "content": "<p>What do you think of my current definition at <a href=\"https://github.com/leanprover-community/mathlib/tree/quantum_graph\">branch#quantum_graph</a></p>",
        "id": 260709358,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1636401086
    },
    {
        "content": "<p>Shortcut url: <a href=\"https://github.com/leanprover-community/mathlib/blob/539d402cf61a48d4be60360930016d7e67fe827f/src/combinatorics/quantum/factor.lean#L18\">https://github.com/leanprover-community/mathlib/blob/539d402cf61a48d4be60360930016d7e67fe827f/src/combinatorics/quantum/factor.lean#L18</a></p>",
        "id": 260709567,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636401194
    },
    {
        "content": "<p>It's nice even though it's tightly related to k-regular graphs. As Mauricio said, if we need something more generic we can come up with it in the future</p>",
        "id": 260710604,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636401707
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> On the lemma that you proposed on the PR:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">is_matching_iff</span> <span class=\"o\">:</span> <span class=\"n\">M.is_matching</span> <span class=\"bp\">↔</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"bp\">∈</span> <span class=\"n\">M.support</span><span class=\"o\">),</span> <span class=\"bp\">∃!</span> <span class=\"o\">(</span><span class=\"n\">w</span> <span class=\"bp\">∈</span> <span class=\"n\">M.support</span><span class=\"o\">),</span> <span class=\"n\">M.adj</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"bp\">`</span>\n</code></pre></div>\n<p>I think it needs to be:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">is_matching_iff</span> <span class=\"o\">:</span> <span class=\"n\">M.is_matching</span> <span class=\"bp\">↔</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"bp\">∈</span> <span class=\"n\">M.verts</span><span class=\"o\">),</span> <span class=\"n\">v</span> <span class=\"bp\">∈</span> <span class=\"n\">M.support</span> <span class=\"bp\">∧</span> <span class=\"bp\">∃!</span> <span class=\"o\">(</span><span class=\"n\">w</span> <span class=\"bp\">∈</span> <span class=\"n\">M.support</span><span class=\"o\">),</span> <span class=\"n\">M.adj</span> <span class=\"n\">v</span> <span class=\"n\">w</span>\n</code></pre></div>",
        "id": 261170304,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636655980
    },
    {
        "content": "<p>There's a lemma you could add, which is that <code>M.support</code> is a subset of <code>M.verts</code></p>",
        "id": 261170764,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636656261
    },
    {
        "content": "<p>That's not the issue. The problem I'm experiencing is when I have to prove that there exists a <code>w</code> such that <code>M.adj v w</code> but I don't have the guarantee that <code>v ∈ M.support</code> (no guarantee that <code>v</code> has a neighbor)</p>",
        "id": 261171057,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636656445
    },
    {
        "content": "<p>The only guarantee that I have is that <code>v ∈ M.verts</code></p>",
        "id": 261171101,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636656476
    },
    {
        "content": "<p>This is the problematic state:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">V</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span>\n<span class=\"n\">G</span><span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span>\n<span class=\"n\">M</span><span class=\"o\">:</span> <span class=\"n\">G.subgraph</span>\n<span class=\"n\">v</span><span class=\"o\">:</span> <span class=\"n\">V</span>\n<span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">),</span> <span class=\"n\">v</span> <span class=\"bp\">∈</span> <span class=\"n\">M.support</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">M.support</span> <span class=\"bp\">∧</span> <span class=\"n\">M.adj</span> <span class=\"n\">v</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">),</span> <span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">M.support</span> <span class=\"bp\">→</span> <span class=\"n\">M.adj</span> <span class=\"n\">v</span> <span class=\"n\">y</span> <span class=\"bp\">→</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n<span class=\"n\">hv</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">),</span> <span class=\"n\">v</span> <span class=\"bp\">∈</span> <span class=\"n\">M.verts</span>\n<span class=\"bp\">⊢</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">),</span> <span class=\"n\">M.adj</span> <span class=\"n\">v</span> <span class=\"n\">x</span> <span class=\"bp\">∧</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">),</span> <span class=\"n\">M.adj</span> <span class=\"n\">v</span> <span class=\"n\">y</span> <span class=\"bp\">→</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">x</span>\n</code></pre></div>",
        "id": 261171183,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636656519
    },
    {
        "content": "<p>(Notice that I've strengthen the right side of the <code>Iff</code> on my modified lemma)</p>",
        "id": 261171381,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636656645
    },
    {
        "content": "<p>(Also I'm not proving <code>is_matching_iff</code> right now. I'm using it to prove <code>is_perfect_iff</code>)</p>",
        "id": 261171635,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636656828
    },
    {
        "content": "<p>Oh, right.  Maybe this is the true theorem:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">is_matching_iff</span> <span class=\"o\">:</span> <span class=\"n\">M.is_matching</span> <span class=\"bp\">↔</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"bp\">∈</span> <span class=\"n\">M.verts</span><span class=\"o\">),</span> <span class=\"bp\">∃!</span> <span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"n\">M.adj</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"bp\">`</span>\n</code></pre></div>\n<p>I think I confused <code>support</code> with <code>verts</code></p>",
        "id": 261171976,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636657002
    },
    {
        "content": "<p>That should work, yeah</p>",
        "id": 261172210,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636657159
    },
    {
        "content": "<p>Actually, let's make this (<code>∀ {{v}}, v ∈ M.verts -&gt; ∃! w, M.adj v w</code>) be the definition of <code>is_matching</code>, and then make the two properties in the <code>structure</code> I suggested be lemmas.</p>",
        "id": 261172212,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636657161
    },
    {
        "content": "<p>I guess <code>eq_of_adj</code> is unnecessary since it's that's part of exists-unique, but <code>M.verts = M.support</code> takes a little proof.</p>",
        "id": 261172459,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636657256
    },
    {
        "content": "<p>Alright let me dig into that</p>",
        "id": 261176298,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636659481
    },
    {
        "content": "<p>What does <code>{{v}}</code> mean?</p>",
        "id": 261176712,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636659740
    },
    {
        "content": "<p>It means \"implicit but left explicit in the type signature so long as the next explicit argument isn't fed in\"</p>",
        "id": 261179184,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1636661232
    },
    {
        "content": "<p>I used to dislike them but they've strongly grown on me</p>",
        "id": 261179312,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1636661299
    },
    {
        "content": "<p>I do think they're great.</p>",
        "id": 261179369,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1636661335
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> I got the definitions and lemmas you proposed to work:<br>\n<a href=\"https://github.com/leanprover-community/mathlib/pull/10210\">https://github.com/leanprover-community/mathlib/pull/10210</a></p>",
        "id": 261191418,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636669853
    },
    {
        "content": "<p>I think I noticed something we could benefit from: lemmas that prove that edges sets and incidence sets are finite if the vertices are finite</p>",
        "id": 261191539,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636669936
    },
    {
        "content": "<p>This would free us from the necessity of placing multiple <code>[fintype _]</code> restrictions when we could just derive them from <code>[fintype V]</code></p>",
        "id": 261191595,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636669980
    },
    {
        "content": "<p>Those exist, and they just depend on having enough decidable instances.  <code>[decidable_rel G.adj]</code> and potentially <code>[decidable_eq V]</code></p>",
        "id": 261191719,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636670070
    },
    {
        "content": "<p>Technically it's better for lemmas to use the most generic typeclass arguments, though, since they're easier to apply, rather ones derived from others.  (Even though it's a pain to write lemmas this way.)</p>",
        "id": 261191745,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636670100
    },
    {
        "content": "<p>Ah, you mean this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">edges_fintype</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">decidable_rel</span> <span class=\"n\">G.adj</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"n\">fintype</span> <span class=\"n\">G.edge_set</span> <span class=\"o\">:=</span> <span class=\"n\">subtype.fintype</span> <span class=\"n\">_</span>\n</code></pre></div>",
        "id": 261192084,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636670372
    },
    {
        "content": "<p>And we have those for subgraphs too. Nice :D</p>",
        "id": 261192225,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636670473
    },
    {
        "content": "<p>This is an example of how it's difficult to discover how to get wanted typeclass instances.</p>\n<p>It would be nice if there were a way to query the typeclass inference system while telling it the kind of typeclasses you're interested in (maybe <code>decidable</code> for example), and then it searches like usual, but whenever it's going to fail it looks at the list of wanted typeclasses, and if it's there it pretends it was satisfied.  Then for each instance it obtains at the end, it can give you the list of typeclasses you need to satisfy.</p>",
        "id": 261192235,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636670481
    },
    {
        "content": "<p>Do you mean something like <code>library_search</code> or something more interactive in the Lean infoview?</p>",
        "id": 261192359,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636670566
    },
    {
        "content": "<p>Maybe a version of this can be implemented by temporarily introducing priority-0 instances implemented by <code>sorry</code> for the ones you're interested in, and then walking through the instance's term at the end to discover which of these instances were used.</p>",
        "id": 261192383,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636670599
    },
    {
        "content": "<p>I'd imagine an interface like <code>library_search</code>/<code>suggest</code> or a command like <code>#find</code></p>",
        "id": 261192468,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636670661
    },
    {
        "content": "<p>This <code>sorry</code> version doesn't give you all instances though, just the first that might match.</p>\n<p>(The point of the having a kinds of typeclasses you're interested in is to keep this from having too many results.)</p>",
        "id": 261192564,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636670752
    },
    {
        "content": "<p>Ah, I forgot to say it explicitly: this PR is ready for review: <a href=\"https://github.com/leanprover-community/mathlib/pull/10210\">https://github.com/leanprover-community/mathlib/pull/10210</a></p>",
        "id": 261447878,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636937746
    },
    {
        "content": "<p>Oops <a href=\"https://github.com/leanprover-community/mathlib/pull/10210#discussion_r757640946\">https://github.com/leanprover-community/mathlib/pull/10210#discussion_r757640946</a></p>",
        "id": 262828998,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1637954958
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> It was merged after I removed it from the to do list</p>",
        "id": 262829022,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1637954981
    },
    {
        "content": "<p>Ah, whoops!</p>",
        "id": 262831887,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1637957738
    },
    {
        "content": "<p>My bad. You can just put it back in your next PR to this file</p>",
        "id": 262831953,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1637957775
    },
    {
        "content": "<p>I will just do it right away</p>",
        "id": 262834990,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1637960975
    },
    {
        "content": "<p>I decided to try to tackle some of the todo's regarding graph matchings and I'm not being able to state this lemma:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">is_matching_iff</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">subgraph</span> <span class=\"n\">G</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"n\">M.is_matching</span> <span class=\"bp\">↔</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">),</span> <span class=\"n\">M.degree</span> <span class=\"n\">v</span> <span class=\"bp\">≤</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"gr\">sorry</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>Lean says:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">synthesize</span> <span class=\"n\">type</span> <span class=\"kd\">class</span> <span class=\"kd\">instance</span> <span class=\"n\">for</span>\n<span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">,</span>\n<span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">,</span>\n<span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">G.subgraph</span><span class=\"o\">,</span>\n<span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">fintype</span> <span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"n\">M.neighbor_set</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>But how can I add a <code>[]</code>-like implicit parameter that suffices this need for every <code>v : V</code>?</p>",
        "id": 265327387,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1639760689
    },
    {
        "content": "<p>If you look at <a href=\"https://leanprover-community.github.io/mathlib_docs/find/simple_graph.neighbor_set_fintype\">docs#simple_graph.neighbor_set_fintype</a>, you see that you need <code>[fintype V] [decidable_rel G.adj]</code></p>",
        "id": 265327633,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1639760797
    },
    {
        "content": "<p>Theoretically, you only need <a href=\"https://leanprover-community.github.io/mathlib_docs/find/simple_graph.locally_finite\">docs#simple_graph.locally_finite</a>. But I guess we haven't quite worked out how to granularly require finiteness.</p>",
        "id": 265327761,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1639760859
    },
    {
        "content": "<p>Hmm, <code>locally_finite</code> would do the trick if we had something equivalent for subgraphs. I'm going to add it</p>",
        "id": 265328465,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1639761136
    },
    {
        "content": "<p>All this duplication between <code>simple_graph</code>, <code>simple_graph.subgraph</code>, and soon weighted graphs (see <a href=\"https://github.com/leanprover-community/mathlib/tree/quantum_graph\">branch#quantum_graph</a>) is getting annoying... I'll pull out a plan to refactor the graph library in the next few days.</p>",
        "id": 265328817,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1639761319
    },
    {
        "content": "<p>An option is to require that <code>G</code> is locally finite and prove that every subgraph of G must be locally finite. Another option is to define locally finiteness for subgraphs specifically and only require that</p>",
        "id": 265328846,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1639761337
    },
    {
        "content": "<p>Given the current state of things, I'd advise you against adding a specific predicate for subgraphs.</p>",
        "id": 265328943,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1639761370
    },
    {
        "content": "<p>Alright, to avoid unnecessary work (given your refactoring intent), I'm just going to get it going with <code>[fintype V] [decidable_rel M.adj]</code></p>",
        "id": 265329129,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1639761460
    },
    {
        "content": "<p>Because it's less restrictive than requiring locally finiteness for the entire supergraph <code>G</code></p>",
        "id": 265329241,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1639761498
    },
    {
        "content": "<p>Also please let me know if/when you start the refactoring. I want to see it closely <span aria-label=\"eyes\" class=\"emoji emoji-1f440\" role=\"img\" title=\"eyes\">:eyes:</span></p>",
        "id": 265329496,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1639761604
    },
    {
        "content": "<p>I will! I already started prototyping yesterday.</p>",
        "id": 265329562,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1639761635
    },
    {
        "content": "<p>huh, wait. the lemma is wrong</p>",
        "id": 265330767,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1639762099
    },
    {
        "content": "<p><em>This</em> is the lemma:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">is_matching_iff</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">subgraph</span> <span class=\"n\">G</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">decidable_rel</span> <span class=\"n\">M.adj</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"n\">M.is_matching</span> <span class=\"bp\">↔</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">),</span> <span class=\"n\">M.degree</span> <span class=\"n\">v</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 265330909,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1639762165
    },
    {
        "content": "<p>(not <code>≤ 1</code>... but <code>= 1</code>)</p>",
        "id": 265331035,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1639762206
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/252551-graph-theory/topic/matchings/near/265327761\">said</a>:</p>\n<blockquote>\n<p>Theoretically, you only need <a href=\"https://leanprover-community.github.io/mathlib_docs/find/simple_graph.locally_finite\">docs#simple_graph.locally_finite</a>. But I guess we haven't quite worked out how to granularly require finiteness.</p>\n</blockquote>\n<p>It's a reducible definition for <code>Π (v : V), fintype (G.neighbor_set v)</code>, mostly as a convenience for when you actually need every vertex to have finite degree.</p>",
        "id": 265337766,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1639764943
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"451983\">@Arthur Paulino</span> All you need is <code>[Π (v : V), fintype (G'.neighbor_set v)]</code> as a hypothesis.</p>",
        "id": 265338155,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1639765091
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"451983\">Arthur Paulino</span> <a href=\"#narrow/stream/252551-graph-theory/topic/matchings/near/265331035\">said</a>:</p>\n<blockquote>\n<p>(not <code>≤ 1</code>... but <code>= 1</code>)</p>\n</blockquote>\n<p>Oh, I see, it's still not right with <code>= 1</code>, though.  The <code>subgraph.degree</code> interface is defined so that vertices outside the subgraph have degree 0. <code>∀ (v : V), v \\in M.verts -&gt; M.degree v = 1</code> should do it.</p>",
        "id": 265338612,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1639765301
    },
    {
        "content": "<p><span aria-label=\"octopus\" class=\"emoji emoji-1f419\" role=\"img\" title=\"octopus\">:octopus:</span> Thanks!</p>",
        "id": 265338828,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1639765415
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> For weighted graphs, did you consider <code>with_bot</code> instead of <code>option</code>?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[ext]</span> <span class=\"kd\">structure</span> <span class=\"n\">weighted_graph</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">W</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">weight</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">option</span> <span class=\"n\">W</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">weight_self</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">weight</span> <span class=\"n\">a</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">none</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">weight_comm</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">weight</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">weight</span> <span class=\"n\">b</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Also, to cut down on all this code duplication, I strongly suggest renaming <code>weighted_graph.to_simple_graph</code> to <code>weighted_graph.coe</code> or something equally short and then using <code>G.coe.adj</code> instead of ever defining <code>G.adj</code>.</p>",
        "id": 265360423,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1639775183
    },
    {
        "content": "<p>The reason <code>simple_graph.subgraph</code> has some seemingly duplicated API is that they're giving forms of definitions and lemmas in terms of the underlying graph's <code>V</code> type (so for example allowing garbage values on vertices outside the subgraph).  The intent I had was that for things where avoiding <code>subtype</code>s isn't useful, you'd do <code>G'.coe.whatever</code>.</p>",
        "id": 265360908,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1639775420
    },
    {
        "content": "<p>I have a better idea than all of that, which would also apply to subgraphs. But I want to get a shiny prototype before showing it to you.</p>",
        "id": 265361192,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1639775600
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/252551-graph-theory/topic/matchings/near/265360423\">said</a>:</p>\n<blockquote>\n<p>For weighted graphs, did you consider <code>with_bot</code> instead of <code>option</code>?</p>\n</blockquote>\n<p>I actually did, and thought it would be a better choice given that the weight order come from lifting everything from <code>W</code> to <code>option W</code> to <code>α → option W</code> to <code>α → α → option W</code>.</p>",
        "id": 265361391,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1639775681
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/252551-graph-theory/topic/matchings/near/265361192\">said</a>:</p>\n<blockquote>\n<p>I have a better idea than all of that, which would also apply to subgraphs. But I want to get a shiny prototype before showing it to you.</p>\n</blockquote>\n<p>How mysterious. Can you describe the idea at least?</p>",
        "id": 265361617,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1639775785
    },
    {
        "content": "<p>Holds in two words, eleven letters: hom refactor.</p>",
        "id": 265361823,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1639775889
    },
    {
        "content": "<p>My proof came down to proving this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">degree_eq_one_of_unique_adj</span> <span class=\"o\">{</span><span class=\"n\">G'</span> <span class=\"o\">:</span> <span class=\"n\">subgraph</span> <span class=\"n\">G</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"o\">(</span><span class=\"n\">G'.neighbor_set</span> <span class=\"n\">v</span><span class=\"o\">)]</span> <span class=\"o\">:</span>\n  <span class=\"n\">G'.degree</span> <span class=\"n\">v</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"bp\">↔</span> <span class=\"bp\">∃!</span> <span class=\"o\">(</span><span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">),</span> <span class=\"n\">G'.adj</span> <span class=\"n\">v</span> <span class=\"n\">w</span>\n</code></pre></div>\n<p>But I'm kinda lost dealing with the definition of <code>degree</code>. Any hints?</p>",
        "id": 265362382,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1639776186
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span>  Ok, if I understand you, that's roughly one of the original designs I had for graphs, but there were complexities that weren't clear were worth it so kept things with the simpler design until we had a combinatorial explosion of combinatorial objects.</p>\n<p>Were you thinking something roughly like this <a href=\"#narrow/stream/113488-general/topic/Typeclasses.20for.20morphisms/near/258738465\">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses.20for.20morphisms/near/258738465</a> ?</p>\n<p>There are some ergonomics problems, and I find it to be a bit sad that you lose <code>G.adj v w</code> dot notation syntax, but it's worth looking into again.</p>",
        "id": 265363082,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1639776580
    },
    {
        "content": "<p>Yes, but not quite. I'm really thinking along the lines of <a href=\"https://github.com/leanprover-community/mathlib/pull/9888\">#9888</a></p>",
        "id": 265363283,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1639776680
    },
    {
        "content": "<p>Anyway, it seems like we're roughly on the same page. At some point I was going to try having a <code>has_adj</code> class along with <code>is_adj_loopless</code> and <code>is_adj_symm</code> property classes.</p>",
        "id": 265363852,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1639776994
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"451983\">Arthur Paulino</span> <a href=\"#narrow/stream/252551-graph-theory/topic/matchings/near/265362382\">said</a>:</p>\n<blockquote>\n<p>My proof came down to proving this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">degree_eq_one_of_unique_adj</span> <span class=\"o\">{</span><span class=\"n\">G'</span> <span class=\"o\">:</span> <span class=\"n\">subgraph</span> <span class=\"n\">G</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"o\">(</span><span class=\"n\">G'.neighbor_set</span> <span class=\"n\">v</span><span class=\"o\">)]</span> <span class=\"o\">:</span>\n  <span class=\"n\">G'.degree</span> <span class=\"n\">v</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"bp\">↔</span> <span class=\"bp\">∃!</span> <span class=\"o\">(</span><span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">),</span> <span class=\"n\">G'.adj</span> <span class=\"n\">v</span> <span class=\"n\">w</span>\n</code></pre></div>\n<p>But I'm kinda lost dealing with the definition of <code>degree</code>. Any hints?</p>\n</blockquote>\n<p>ping <span aria-label=\"big smile\" class=\"emoji emoji-1f604\" role=\"img\" title=\"big smile\">:big_smile:</span></p>",
        "id": 265364344,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1639777313
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"451983\">@Arthur Paulino</span> You need a lemma that the degree is 1 iff the <code>neighbor_set</code> is a singleton, I think.  This lemma doesn't seem to exist for either <code>simple_graph</code> or <code>subgraph</code> yet.</p>",
        "id": 265364487,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1639777404
    },
    {
        "content": "<p>I'm not immediately finding a mathlib theorem that <code>fintype s = 1 &lt;-&gt; exists x, s = {x}</code></p>",
        "id": 265364655,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1639777505
    },
    {
        "content": "<p>Do you mean finset there, Kyle? I'm fairly sure it exists</p>",
        "id": 265364774,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1639777560
    },
    {
        "content": "<p>Ah then it's not as straightforward as I expected (given the lemmas we currently have)</p>",
        "id": 265364912,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1639777597
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"284160\">@Eric Rodriguez</span> I think <code>degree</code> is defined using <code>fintype.card (G'.neighbor_set v)</code></p>",
        "id": 265365003,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1639777676
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"451983\">@Arthur Paulino</span> It's fairly straightforward, and you can patch together a few lemmas.  One is to turn this into <code>(G'.neighbor_set v).to_finset.card</code> using some lemmas from <code>data.set.finite</code></p>",
        "id": 265365108,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1639777722
    },
    {
        "content": "<p>Another seems to be <a href=\"https://leanprover-community.github.io/mathlib_docs/find/finset.card_le_one_iff_subset_singleton\">docs#finset.card_le_one_iff_subset_singleton</a></p>",
        "id": 265365129,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1639777727
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/252551-graph-theory/topic/matchings/near/265363852\">said</a>:</p>\n<blockquote>\n<p>Anyway, it seems like we're roughly on the same page. At some point I was going to try having a <code>has_adj</code> class along with <code>is_adj_loopless</code> and <code>is_adj_symm</code> property classes.</p>\n</blockquote>\n<p>Okay great! What I'm doing now is finding a way to clear up a few arrows in the instance graph that don't commute.</p>",
        "id": 265365164,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1639777733
    },
    {
        "content": "<p>Oh, never mind, this is better: <a href=\"https://leanprover-community.github.io/mathlib_docs/find/finset.card_eq_one\">docs#finset.card_eq_one</a></p>",
        "id": 265365197,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1639777756
    },
    {
        "content": "<p>It's a bit funny because it's done the exact opposite for <code>simple_graph</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/--</span>\n<span class=\"sd\">`G.degree v` is the number of vertices adjacent to `v`.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">def</span> <span class=\"n\">degree</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">G.neighbor_finset</span> <span class=\"n\">v</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">card</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">card_neighbor_set_eq_degree</span> <span class=\"o\">:</span> <span class=\"n\">fintype.card</span> <span class=\"o\">(</span><span class=\"n\">G.neighbor_set</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">G.degree</span> <span class=\"n\">v</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">set.to_finset_card</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n</code></pre></div>",
        "id": 265365437,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1639777885
    },
    {
        "content": "<p>I mean, starting with <code>finset.card</code> and then turning it into <code>fintype.card</code></p>",
        "id": 265365540,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1639777939
    },
    {
        "content": "<p>Is there something strange here or is my intuition fooling me?</p>",
        "id": 265365653,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1639778030
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"451983\">@Arthur Paulino</span> I've argued for removing <code>G.neighbor_finset v</code> before since it's just <code>(G.neighbor_set v).to_finset</code>, but I've done absolutely nothing about it.  Perhaps <code>simple_graph.subgraph.degree</code> should be defined as <code>(G.neighbor_set v).to_finset.degree</code> to match up with <code>simple_graph</code> better.</p>",
        "id": 265365696,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1639778044
    },
    {
        "content": "<p>I'll leave things as they are for now because there's a hope Yael's refactor might kill these</p>",
        "id": 265365883,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1639778185
    },
    {
        "content": "<p>On the other hand, maybe with these typeclasses Yael is talking about we'll be able to have <code>neighbor_finset</code> at lower cost.  The problem is that, even with the typeclasses, you need lemmas for both <code>neighbor_set</code> and <code>neighbor_finset</code>.</p>",
        "id": 265365916,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1639778208
    },
    {
        "content": "<p>Isn't it possible to design <code>neighbor_set</code> and <code>neighbor_finset</code> such that everything that works for <code>neighbor_set</code> works for <code>neighbor_finset</code>?</p>",
        "id": 265366085,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1639778317
    },
    {
        "content": "<p>And then just have more lemmas for <code>neighbor_finset</code> because it's more restricted</p>",
        "id": 265366138,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1639778353
    },
    {
        "content": "<p>Anyways, I'll try to get it going with your tips and what we have for now <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span></p>",
        "id": 265366415,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1639778478
    },
    {
        "content": "<p>This seems to be the main sort of use of <code>neighbor_finset</code>: <a href=\"https://github.com/leanprover-community/mathlib/blob/master/src/combinatorics/simple_graph/adj_matrix.lean#L187\">https://github.com/leanprover-community/mathlib/blob/master/src/combinatorics/simple_graph/adj_matrix.lean#L187</a> (it makes summation nicer looking).  Ideally, we could sum over <code>set</code> too.  Might be a use for a <code>finset_like</code> typeclass?</p>\n<p>Unfortunately you can't really have things work for both, since one is a <code>set</code> and one is a <code>finset</code>.</p>",
        "id": 265367396,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1639778990
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/252551-graph-theory/topic/matchings/near/265364487\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"451983\">Arthur Paulino</span> You need a lemma that the degree is 1 iff the <code>neighbor_set</code> is a singleton, I think.  This lemma doesn't seem to exist for either <code>simple_graph</code> or <code>subgraph</code> yet.</p>\n</blockquote>\n<p>Hm, I don't think the <code>iff</code> works because of the \"at most\" part:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- A set `s` is a `subsingleton`, if it has at most one element. -/</span>\n<span class=\"kn\">protected</span> <span class=\"kd\">def</span> <span class=\"n\">subsingleton</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"bp\">∀</span> <span class=\"o\">⦃</span><span class=\"n\">x</span><span class=\"o\">⦄</span> <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">⦃</span><span class=\"n\">y</span><span class=\"o\">⦄</span> <span class=\"o\">(</span><span class=\"n\">hy</span> <span class=\"o\">:</span> <span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">),</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span>\n</code></pre></div>",
        "id": 265372088,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1639781152
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"451983\">@Arthur Paulino</span> What's the problem you're running into? Are you still dealing with degree = 1?  (Be careful about difference between <code>singleton</code> and <code>subsingleton</code>, if that's helpful.)</p>",
        "id": 265372859,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1639781476
    },
    {
        "content": "<p>I indeed confused those</p>",
        "id": 265372967,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1639781534
    },
    {
        "content": "<p>Alright, I got it!</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">card_neighbor_finset_eq_degree</span> <span class=\"o\">{</span><span class=\"n\">G'</span> <span class=\"o\">:</span> <span class=\"n\">subgraph</span> <span class=\"n\">G</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"o\">(</span><span class=\"n\">G'.neighbor_set</span> <span class=\"n\">v</span><span class=\"o\">)]</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">G'.neighbor_set</span> <span class=\"n\">v</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_finset.card</span> <span class=\"bp\">=</span> <span class=\"n\">G'.degree</span> <span class=\"n\">v</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">degree</span><span class=\"o\">,</span> <span class=\"n\">set.to_finset_card</span><span class=\"o\">]</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">degree_eq_one_of_unique_adj</span> <span class=\"o\">{</span><span class=\"n\">G'</span> <span class=\"o\">:</span> <span class=\"n\">subgraph</span> <span class=\"n\">G</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"o\">(</span><span class=\"n\">G'.neighbor_set</span> <span class=\"n\">v</span><span class=\"o\">)]</span> <span class=\"o\">:</span>\n  <span class=\"n\">G'.degree</span> <span class=\"n\">v</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"bp\">↔</span> <span class=\"bp\">∃!</span> <span class=\"o\">(</span><span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">),</span> <span class=\"n\">G'.adj</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">card_neighbor_finset_eq_degree</span><span class=\"o\">,</span> <span class=\"n\">finset.card_eq_one</span><span class=\"o\">,</span> <span class=\"n\">finset.singleton_iff_unique_mem</span><span class=\"o\">],</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">set.mem_to_finset</span><span class=\"o\">,</span> <span class=\"n\">mem_neighbor_set</span><span class=\"o\">],</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">is_matching_iff</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">subgraph</span> <span class=\"n\">G</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">),</span> <span class=\"n\">fintype</span> <span class=\"o\">(</span><span class=\"n\">M.neighbor_set</span> <span class=\"n\">v</span><span class=\"o\">)]</span> <span class=\"o\">:</span>\n  <span class=\"n\">M.is_matching</span> <span class=\"bp\">↔</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">),</span> <span class=\"n\">v</span> <span class=\"bp\">∈</span> <span class=\"n\">M.verts</span> <span class=\"bp\">→</span> <span class=\"n\">M.degree</span> <span class=\"n\">v</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">h</span> <span class=\"n\">v</span> <span class=\"n\">hvm</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">degree_eq_one_of_unique_adj.mpr</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">hvm</span><span class=\"o\">),},</span>\n  <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">hv</span> <span class=\"n\">v</span> <span class=\"n\">hvm</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">degree_eq_one_of_unique_adj.mp</span> <span class=\"o\">(</span><span class=\"n\">hv</span> <span class=\"n\">v</span> <span class=\"n\">hvm</span><span class=\"o\">),</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 265376794,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1639784506
    },
    {
        "content": "<p>Ideas on how to golf <code>is_matching_iff</code> further?</p>",
        "id": 265376848,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1639784526
    },
    {
        "content": "<p>You could just write it in term mode with pointy brackets</p>",
        "id": 265378149,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1639785628
    },
    {
        "content": "<p>You should get something like that in the end. Golfed enough to my standards</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">h</span> <span class=\"n\">v</span> <span class=\"n\">hvm</span><span class=\"o\">,</span> <span class=\"n\">degree_eq_one_of_unique_adj.2</span> <span class=\"bp\">$</span> <span class=\"n\">h</span> <span class=\"n\">hvm</span><span class=\"o\">,</span>\n  <span class=\"bp\">λ</span> <span class=\"n\">hv</span> <span class=\"n\">v</span> <span class=\"n\">hvm</span><span class=\"o\">,</span> <span class=\"n\">degree_eq_one_of_unique_adj.1</span> <span class=\"bp\">$</span> <span class=\"n\">hv</span> <span class=\"n\">v</span> <span class=\"n\">hvm</span><span class=\"o\">⟩</span>\n</code></pre></div>",
        "id": 265378238,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1639785714
    },
    {
        "content": "<p>Does <code>simp [degree_eq_one_of_unique_adj]</code> work?</p>",
        "id": 265378276,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1639785723
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/252551-graph-theory/topic/matchings/near/265378276\">said</a>:</p>\n<blockquote>\n<p>Does <code>simp [degree_eq_one_of_unique_adj]</code> work?</p>\n</blockquote>\n<p>nope :/</p>",
        "id": 265378342,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1639785782
    },
    {
        "content": "<p>Definitely does, you just need to <code>refl</code> it at the end <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>\n<p><code>simpa</code> does that for you:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">is_matching_iff</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">subgraph</span> <span class=\"n\">G</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">),</span> <span class=\"n\">fintype</span> <span class=\"o\">(</span><span class=\"n\">M.neighbor_set</span> <span class=\"n\">v</span><span class=\"o\">)]</span> <span class=\"o\">:</span>\n  <span class=\"n\">M.is_matching</span> <span class=\"bp\">↔</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">),</span> <span class=\"n\">v</span> <span class=\"bp\">∈</span> <span class=\"n\">M.verts</span> <span class=\"bp\">→</span> <span class=\"n\">M.degree</span> <span class=\"n\">v</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"n\">degree_eq_one_of_unique_adj</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 265378518,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1639785931
    },
    {
        "content": "<p>Wow!</p>",
        "id": 265378660,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1639786013
    },
    {
        "content": "<p>PR: <a href=\"https://github.com/leanprover-community/mathlib/pull/10864\">#10864</a></p>",
        "id": 265379148,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1639786396
    },
    {
        "content": "<p>How could we prove that a matching is 2-colorable? Are these the only options?</p>\n<ul>\n<li>Redefine coloring for subgraphs</li>\n<li>Coerce the subgraph into a graph and state the lemma for the graph instead?</li>\n</ul>\n<p>I think both options are uneasy <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span><br>\nI'm starting to crave for a refactor that would allow us to say that a graph is a subgraph of another graph with a <code>Prop</code> <span aria-label=\"eyes\" class=\"emoji emoji-1f440\" role=\"img\" title=\"eyes\">:eyes:</span></p>",
        "id": 265489551,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1639933591
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"451983\">@Arthur Paulino</span> The second option is how I imagined it going.</p>\n<p>I started implementing it, but I can't keep working on it right now.  The idea here is that matchings have a function to their edge set, and then using the axiom of choice (via <a href=\"https://leanprover-community.github.io/mathlib_docs/find/function.surj_inv\">docs#function.surj_inv</a>) you can choose a vertex for each edge. The <code>bool</code>-valued coloring is whether or not the vertex was the chosen vertex.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- Given a vertex, give the unique edge of the matching it is incident to. -/</span>\n<span class=\"kd\">noncomputable</span>\n<span class=\"kd\">def</span> <span class=\"n\">is_matching.to_edge</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">subgraph</span> <span class=\"n\">G</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">M.is_matching</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">M.verts</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">M.edge_set</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"bp\">⟦</span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">v.property</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">some</span><span class=\"o\">)</span><span class=\"bp\">⟧</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">v.property</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">some_spec.1</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">is_matching.to_edge.surjective</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">subgraph</span> <span class=\"n\">G</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">M.is_matching</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">function.surjective</span> <span class=\"n\">h.to_edge</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">he</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">refine</span> <span class=\"n\">sym2.ind</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">he</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">e</span> <span class=\"n\">he</span><span class=\"o\">,</span>\n  <span class=\"n\">use</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">M.edge_vert</span> <span class=\"n\">he</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">is_matching.to_edge</span><span class=\"o\">,</span> <span class=\"n\">subtype.mk_eq_mk</span><span class=\"o\">,</span> <span class=\"n\">subtype.coe_mk</span><span class=\"o\">,</span> <span class=\"n\">sym2.congr_right</span><span class=\"o\">],</span>\n  <span class=\"n\">exact</span> <span class=\"o\">((</span><span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">M.edge_vert</span> <span class=\"n\">he</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">some_spec.2</span> <span class=\"n\">y</span> <span class=\"n\">he</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">is_matching.eq_to_edge_of_adj</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">subgraph</span> <span class=\"n\">G</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">M.is_matching</span><span class=\"o\">)</span>\n  <span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hv</span> <span class=\"o\">:</span> <span class=\"n\">v</span> <span class=\"bp\">∈</span> <span class=\"n\">M.verts</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hw</span> <span class=\"o\">:</span> <span class=\"n\">w</span> <span class=\"bp\">∈</span> <span class=\"n\">M.verts</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"n\">M.adj</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">h.to_edge</span> <span class=\"o\">⟨</span><span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">hv</span><span class=\"o\">⟩</span> <span class=\"bp\">=</span> <span class=\"n\">h.to_edge</span> <span class=\"o\">⟨</span><span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"n\">hw</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">is_matching.to_edge</span><span class=\"o\">,</span> <span class=\"n\">subtype.mk_eq_mk</span><span class=\"o\">,</span> <span class=\"n\">subtype.coe_mk</span><span class=\"o\">],</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">sym2.eq_swap</span><span class=\"o\">],</span>\n  <span class=\"n\">congr</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"o\">((</span><span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">M.edge_vert</span> <span class=\"n\">ha</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">some_spec.2</span> <span class=\"n\">w</span> <span class=\"n\">ha</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"o\">((</span><span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">M.edge_vert</span> <span class=\"o\">(</span><span class=\"n\">M.symm</span> <span class=\"n\">ha</span><span class=\"o\">)))</span><span class=\"bp\">.</span><span class=\"n\">some_spec.2</span> <span class=\"n\">v</span> <span class=\"o\">(</span><span class=\"n\">M.symm</span> <span class=\"n\">ha</span><span class=\"o\">)),</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">loopless</span> <span class=\"o\">(</span><span class=\"n\">G'</span> <span class=\"o\">:</span> <span class=\"n\">subgraph</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">G'.adj</span> <span class=\"n\">v</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">false</span> <span class=\"o\">:=</span>\n<span class=\"n\">G.loopless</span> <span class=\"n\">v</span> <span class=\"o\">(</span><span class=\"n\">G'.adj_sub</span> <span class=\"n\">h</span><span class=\"o\">)</span>\n\n<span class=\"kd\">noncomputable</span>\n<span class=\"kd\">def</span> <span class=\"n\">bicoloring_of_matching</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">subgraph</span> <span class=\"n\">G</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">M.is_matching</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">M.coe.coloring</span> <span class=\"n\">bool</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">let</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">function.surj_inv</span> <span class=\"o\">(</span><span class=\"n\">is_matching.to_edge.surjective</span> <span class=\"n\">h</span><span class=\"o\">),</span>\n  <span class=\"n\">classical</span><span class=\"o\">,</span>\n  <span class=\"k\">let</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">M.verts</span> <span class=\"bp\">→</span> <span class=\"n\">bool</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">h.to_edge</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">v</span><span class=\"o\">,</span>\n  <span class=\"n\">fsplit</span><span class=\"o\">,</span>\n  <span class=\"n\">use</span> <span class=\"n\">c</span><span class=\"o\">,</span>\n  <span class=\"n\">rintros</span> <span class=\"o\">⟨</span><span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">hv</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"n\">hw</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">intros</span> <span class=\"n\">ha</span> <span class=\"n\">h'</span><span class=\"o\">,</span>\n  <span class=\"n\">by_cases</span> <span class=\"n\">hc</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">h.to_edge</span> <span class=\"o\">⟨</span><span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">hv</span><span class=\"o\">⟩)</span> <span class=\"bp\">=</span> <span class=\"o\">⟨</span><span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">hv</span><span class=\"o\">⟩,</span>\n  <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">h.eq_to_edge_of_adj</span> <span class=\"n\">hw</span> <span class=\"n\">hv</span> <span class=\"o\">(</span><span class=\"n\">M.symm</span> <span class=\"n\">ha</span><span class=\"o\">)</span> <span class=\"n\">at</span> <span class=\"n\">h'</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">hc</span><span class=\"o\">,</span> <span class=\"n\">true_iff</span><span class=\"o\">,</span> <span class=\"n\">eq_self_iff_true</span><span class=\"o\">,</span> <span class=\"n\">subtype.mk_eq_mk</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h'</span><span class=\"o\">,</span>\n    <span class=\"n\">subst</span> <span class=\"n\">h'</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">M.loopless</span> <span class=\"n\">_</span> <span class=\"n\">ha</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">hc</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h'</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">h.eq_to_edge_of_adj</span> <span class=\"n\">hv</span> <span class=\"n\">hw</span> <span class=\"n\">ha</span> <span class=\"n\">at</span> <span class=\"n\">hc</span><span class=\"o\">,</span>\n    <span class=\"gr\">sorry</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 265495120,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1639941173
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> wanna start the PR and I can try to take over?</p>",
        "id": 265506399,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1639956547
    },
    {
        "content": "<p>I'm trying to take another <code>TODO</code> item down but I'm quite sure I'm doing something strange here.<br>\nI'm trying to prove that the existence of a perfect matching on a graph implies that the cardinality of the number of vertices is even. For that, I'm telling lean \"use the number of edges in the matching\", but the proof follows quite strangely from there.</p>\n<p><a href=\"https://github.com/leanprover-community/mathlib/blob/79ffe993a3023bc8c36dd1d08b2fbc4bc4804ca8/src/combinatorics/simple_graph/matching.lean#L75\">Here's the file with my current attempt</a>. Help is much appreciated <span aria-label=\"pray\" class=\"emoji emoji-1f64f\" role=\"img\" title=\"pray\">:pray:</span></p>",
        "id": 266203920,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1640638330
    },
    {
        "content": "<p>I suggest using <a href=\"https://leanprover-community.github.io/mathlib_docs/find/simple_graph.is_perfect_matching_iff\">docs#simple_graph.is_perfect_matching_iff</a> and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/Exist.some\">docs#Exist.some</a> to define a function <code>simple_graph.is_perfect_matching.other : V -&gt; V</code>, then prove it's <a href=\"https://leanprover-community.github.io/mathlib_docs/find/function.involutive\">docs#function.involutive</a> and without fixed points (not sure if a predicate exists for that), then use some lemma (that you might need to write, maybe something in <a href=\"https://leanprover-community.github.io/mathlib_docs/find/simple_graph.dart\">docs#simple_graph.dart</a> gives a hint) to show <code>fintype.card V</code> is even.</p>",
        "id": 266205863,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1640640087
    },
    {
        "content": "<p>Maybe the idea is that you get a map <code>to_edge : V -&gt; M.edge_set</code> that's 2-to-1, with <code>simple_graph.is_perfect_matching.other</code> being the map whose orbits partition <code>V</code> into the fibers of the <code>to_edge</code> map.</p>",
        "id": 266206072,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1640640279
    },
    {
        "content": "<p>so you should be able to take things rather directly from the module for  <code>simple_graph.dart</code></p>",
        "id": 266206110,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1640640318
    },
    {
        "content": "<p>What do you mean by \"without fixed points\"?</p>",
        "id": 266206134,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1640640356
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"451983\">@Arthur Paulino</span> By the way, a more streamlined argument is to apply <a href=\"https://leanprover-community.github.io/mathlib_docs/find/simple_graph.even_card_odd_degree_vertices\">docs#simple_graph.even_card_odd_degree_vertices</a> to <code>M.spanning_coe</code></p>",
        "id": 266207941,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1640642319
    },
    {
        "content": "<p>using an <code>is_perfect_matching</code> analogue of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/simple_graph.subgraph.is_matching_iff_forall_degree\">docs#simple_graph.subgraph.is_matching_iff_forall_degree</a> (one without the <code>v ∈ M.verts</code> hypothesis)</p>",
        "id": 266207997,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1640642397
    },
    {
        "content": "<p>This is the kind of thing I mean by without fixed points: <a href=\"https://leanprover-community.github.io/mathlib_docs/find/simple_graph.dart.rev_ne\">docs#simple_graph.dart.rev_ne</a></p>",
        "id": 266208131,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1640642433
    },
    {
        "content": "<p>It would still be nice to have <code>simple_graph.is_perfect_matching.other</code> and to prove some properties about it.</p>",
        "id": 266208171,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1640642464
    },
    {
        "content": "<p>For example, prove that <code>dart.fst</code> defines an equivalence between <code>M.spanning_coe.dart</code> and <code>V</code>, and that <code>dart.fst</code> is an isomorphism in the sense that <code>dart.fst d.rev = h.other (dart.fst d)</code> (where <code>h : M.is_perfect_matching</code>).</p>",
        "id": 266208473,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1640642686
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"451983\">@Arthur Paulino</span>, do you mind if I work on this branch? I have an idea of how the proof could go (and I think I'm gonna need the API surrounding that result very soon)</p>",
        "id": 266209667,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1640643417
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/252551-graph-theory/topic/matchings/near/266209667\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"451983\">Arthur Paulino</span>, do you mind if I work on this branch? I have an idea of how the proof could go (and I think I'm gonna need the API surrounding that result very soon)</p>\n</blockquote>\n<p>Not at all, you can go for it.<br>\nIf you don't take Kyle's suggestion as your route (defining <code>simple_graph.is_perfect_matching.other</code> and proving those results for it), you can also add it as a <code>TODO</code> and we can deal with it later <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span></p>",
        "id": 266209805,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1640643538
    },
    {
        "content": "<p>I'm first gonna prove the slightly more general result that the support of a matching is even.</p>",
        "id": 266209923,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1640643627
    },
    {
        "content": "<p>Are you going to use <code>even_card_odd_degree_vertices</code>? That seems potentially the most straightforward (though it would be for <code>M.coe</code> rather than <code>M.spanning_coe</code>)</p>",
        "id": 266209966,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1640643688
    },
    {
        "content": "<p>Given that this result is basically the handshaking lemma, I should probably use the handshaking lemma in the proof <span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span> But I'm not excluding finding a more convenient generalization/variation of <code>even_card_odd_degree_vertices</code> first.</p>",
        "id": 266210079,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1640643803
    },
    {
        "content": "<p>It could be helpful to have a function <code>is_perfect_matching.get_edge : V -&gt; sym2 V</code> which is guaranteed to have <code>other</code> and the given vertex, and to be an edge of the graph. (And probably the non-perfect generalisation)</p>",
        "id": 266210143,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1640643865
    },
    {
        "content": "<p>I thought the proof would go smooth with <code>sum_degrees_eq_twice_card_edges</code>. I still don't understand why it didn't work <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 266210155,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1640643883
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"246273\">Bhavik Mehta</span> <a href=\"#narrow/stream/252551-graph-theory/topic/matchings/near/266210143\">said</a>:</p>\n<blockquote>\n<p>It could be helpful to have a function <code>is_perfect_matching.get_edge : V -&gt; sym2 V</code> which is guaranteed to have <code>other</code> and the given vertex, and to be an edge of the graph. (And probably the non-perfect generalisation)</p>\n</blockquote>\n<p>Yeah that function seemed to be the start of Kyle's reasoning <a href=\"#narrow/stream/252551-graph-theory/topic/matchings/near/265495120\">here</a>.</p>",
        "id": 266210288,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1640644021
    },
    {
        "content": "<p>BTW, while the <code>simple_graph</code> vs <code>subgraph</code> definitions don't get refactored, some instances that carry some assumptions down from the simple graph to its subgraphs would be very useful. E.g.: locally finiteness of neighbors on a vertex, <code>rel</code> decidability of <code>subgraph.adj</code> etc</p>",
        "id": 266210670,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1640644370
    },
    {
        "content": "<p>Actually this one is already contemplated:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">finite_at</span> <span class=\"o\">{</span><span class=\"n\">G'</span> <span class=\"o\">:</span> <span class=\"n\">subgraph</span> <span class=\"n\">G</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">G'.verts</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">decidable_rel</span> <span class=\"n\">G'.adj</span><span class=\"o\">]</span>\n   <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"o\">(</span><span class=\"n\">G.neighbor_set</span> <span class=\"n\">v</span><span class=\"o\">)]</span> <span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"o\">(</span><span class=\"n\">G'.neighbor_set</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">set.fintype_subset</span> <span class=\"o\">(</span><span class=\"n\">G.neighbor_set</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">G'.neighbor_set_subset</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 266210799,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1640644480
    },
    {
        "content": "<p>For what it's worth, here's how to use <code>sum_degrees_eq_twice_card_edges</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">is_perfect_matching_iff_forall_degree</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">subgraph</span> <span class=\"n\">G</span><span class=\"o\">}</span>\n  <span class=\"o\">[</span><span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">),</span> <span class=\"n\">fintype</span> <span class=\"o\">(</span><span class=\"n\">M.neighbor_set</span> <span class=\"n\">v</span><span class=\"o\">)]</span> <span class=\"o\">:</span>\n  <span class=\"n\">M.is_perfect_matching</span> <span class=\"bp\">↔</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">),</span> <span class=\"n\">M.degree</span> <span class=\"n\">v</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">degree_eq_one_iff_unique_adj</span><span class=\"o\">,</span> <span class=\"n\">is_perfect_matching_iff</span><span class=\"o\">]</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">spanning_coe_degree</span> <span class=\"o\">{</span><span class=\"n\">G'</span> <span class=\"o\">:</span> <span class=\"n\">G.subgraph</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n  <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"o\">(</span><span class=\"n\">G'.neighbor_set</span> <span class=\"n\">v</span><span class=\"o\">)]</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"o\">(</span><span class=\"n\">G'.spanning_coe.neighbor_set</span> <span class=\"n\">v</span><span class=\"o\">)]</span> <span class=\"o\">:</span>\n  <span class=\"n\">G'.spanning_coe.degree</span> <span class=\"n\">v</span> <span class=\"bp\">=</span> <span class=\"n\">G'.degree</span> <span class=\"n\">v</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">card_neighbor_set_eq_degree</span><span class=\"o\">,</span> <span class=\"n\">subgraph.degree</span><span class=\"o\">],</span>\n  <span class=\"n\">congr</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">even_card_vertices_of_perfect_matching</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">subgraph</span> <span class=\"n\">G</span><span class=\"o\">}</span>\n  <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">decidable_rel</span> <span class=\"n\">G.adj</span><span class=\"o\">]</span>\n    <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">M.is_perfect_matching</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">even</span> <span class=\"o\">(</span><span class=\"n\">fintype.card</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">classical</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">is_perfect_matching_iff_forall_degree</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">M.spanning_coe.sum_degrees_eq_twice_card_edges</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">this</span><span class=\"o\">⟩,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 266210886,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1640644564
    },
    {
        "content": "<p>(I'd like the first two lemmas in the library somewhere anyway.)</p>",
        "id": 266210913,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1640644599
    },
    {
        "content": "<p>Oh it's done <span aria-label=\"rofl\" class=\"emoji emoji-1f923\" role=\"img\" title=\"rofl\">:rofl:</span></p>",
        "id": 266210955,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1640644671
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> I can just push those proofs that Kyle already did</p>",
        "id": 266211016,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1640644715
    },
    {
        "content": "<p>That doesn't have the more general one, though.</p>",
        "id": 266211023,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1640644728
    },
    {
        "content": "<p>I wonder if this can be used to prove the more general one - given a matching it is perfect on itself, so it has an even number of vertices</p>",
        "id": 266211056,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1640644788
    },
    {
        "content": "<p>Dang, just went to have a glass a water and here comes the proof <span aria-label=\"rofl\" class=\"emoji emoji-1f923\" role=\"img\" title=\"rofl\">:rofl:</span></p>",
        "id": 266211120,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1640644833
    },
    {
        "content": "<p>It's true tho. I think having the more general one and this one following it would be nicer</p>",
        "id": 266211133,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1640644860
    },
    {
        "content": "<p>I wonder if it's worth generalizing this lemma:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">is_matching_iff_forall_degree</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">subgraph</span> <span class=\"n\">G</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">),</span> <span class=\"n\">fintype</span> <span class=\"o\">(</span><span class=\"n\">M.neighbor_set</span> <span class=\"n\">v</span><span class=\"o\">)]</span> <span class=\"o\">:</span>\n  <span class=\"n\">M.is_matching</span> <span class=\"bp\">↔</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">),</span> <span class=\"n\">v</span> <span class=\"bp\">∈</span> <span class=\"n\">M.verts</span> <span class=\"bp\">→</span> <span class=\"n\">M.degree</span> <span class=\"n\">v</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span>\n</code></pre></div>\n<p>We don't need a <code>fintype</code> instance for every vertex, just the ones in the support.</p>",
        "id": 266211147,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1640644881
    },
    {
        "content": "<p>We currently handle finiteness quite badly, so I would be eager for a full rethink on how to do it.</p>",
        "id": 266211228,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1640644956
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> I'm going to push the proofs Kyle wrote and then you can improve it, okay?</p>",
        "id": 266211322,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1640645065
    },
    {
        "content": "<p>It's funny, being able to have varying finiteness at different vertices is something I think we managed to actually pull off, vs the alternative (which was <em>only</em> finite graphs).</p>",
        "id": 266211357,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1640645105
    },
    {
        "content": "<p>Maybe it's obvious in retrospect, since we have this API</p>",
        "id": 266211373,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1640645119
    },
    {
        "content": "<p>With all the kerfuffle of switching between finsets and sets? I saw Alena in pain writing the SRG branch back in March, and my medication was \"Take more finsets\".</p>",
        "id": 266211512,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1640645220
    },
    {
        "content": "<p>(I'm happy to hear constructive criticism about what could be improved, but general comments about API being \"bad\" I don't find to be particularly helpful.)</p>",
        "id": 266211561,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1640645264
    },
    {
        "content": "<p>I'm trying to come up with something <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 266211673,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1640645352
    },
    {
        "content": "<p>And sorry, I should stop insulting your APIs.</p>",
        "id": 266211831,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1640645444
    },
    {
        "content": "<p>okay <span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> you can go for it. in the meantime I'm going to define the <code>V -&gt; edge</code> function that Bhavik and Kyle were talking about</p>",
        "id": 266211838,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1640645450
    },
    {
        "content": "<p>Never use finsets at all and do everything with <code>set.finite</code> :-)</p>",
        "id": 266211854,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1640645467
    },
    {
        "content": "<p>Since the topic of graph API came up, I'm going to take the chance and make a question that I've been longing to ask for a while now :D</p>",
        "id": 266212014,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1640645622
    },
    {
        "content": "<p>Kevin, the finsect outcast <span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span></p>",
        "id": 266212017,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1640645626
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/252551-graph-theory/topic/matchings/near/266211357\">said</a>:</p>\n<blockquote>\n<p>It's funny, being able to have varying finiteness at different vertices is something I think we managed to actually pull off, vs the alternative (which was <em>only</em> finite graphs).</p>\n</blockquote>\n<p>I agree, but here's a particular thing which I think is missing?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">G'</span> <span class=\"o\">:</span> <span class=\"n\">subgraph</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">fintype</span> <span class=\"o\">(</span><span class=\"n\">G'.neighbor_set</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">apply_instance</span>\n</code></pre></div>",
        "id": 266213015,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1640646460
    },
    {
        "content": "<p>lol I was writing that instance just now</p>",
        "id": 266213087,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1640646510
    },
    {
        "content": "<p>Oh actually it's already there, never mind!</p>",
        "id": 266213107,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1640646543
    },
    {
        "content": "<p>The one I'm interested in takes <code>fintype M.support</code> instead.</p>",
        "id": 266213132,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1640646564
    },
    {
        "content": "<p>There are definitely some decidability instances missing for <code>subgraph</code></p>",
        "id": 266213134,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1640646564
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">decidable_pred</span> <span class=\"o\">(</span><span class=\"bp\">∈</span> <span class=\"n\">M.support</span><span class=\"o\">)]</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"n\">M.support</span> <span class=\"o\">:=</span> <span class=\"n\">set_fintype</span> <span class=\"n\">_</span>\n</code></pre></div>",
        "id": 266213137,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1640646567
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/252551-graph-theory/topic/matchings/near/266213132\">said</a>:</p>\n<blockquote>\n<p>The one I'm interested in takes <code>fintype M.support</code> instead.</p>\n</blockquote>\n<p>I was too <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 266213210,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1640646612
    },
    {
        "content": "<p>I'm not sure the decidability instance needed, but I'd started on this one:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">support_decidable_pred</span> <span class=\"o\">[</span><span class=\"n\">decidable_rel</span> <span class=\"n\">G.adj</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">decidable_pred</span> <span class=\"o\">(</span><span class=\"bp\">∈</span> <span class=\"n\">M.support</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>(I doubt I have the right hypotheses.)</p>",
        "id": 266213257,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1640646637
    },
    {
        "content": "<p>You also need <code>fintype V</code> I'm afraid, because <code>∈ M.support</code> is an existential.</p>",
        "id": 266213320,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1640646712
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> do you want to push to that branch or open a PR into it?</p>",
        "id": 266213424,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1640646810
    },
    {
        "content": "<p>I'll just push I think</p>",
        "id": 266213439,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1640646827
    },
    {
        "content": "<p>Alright (just wanted to check so we don't step on each other's toes)</p>",
        "id": 266213490,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1640646846
    },
    {
        "content": "<p>(I'm not working on this anymore -- just wanted to show how to use the lemma. No more toe stepping from me <span aria-label=\"footprints\" class=\"emoji emoji-1f463\" role=\"img\" title=\"footprints\">:footprints:</span>)</p>",
        "id": 266213520,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1640646890
    },
    {
        "content": "<p>Kyle do you mind if I push the <code>is_matching.to_edge</code> function and the following two lemmas that you proved about it <a href=\"#narrow/stream/252551-graph-theory/topic/matchings/near/265495120\">here</a>?</p>",
        "id": 266213643,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1640646990
    },
    {
        "content": "<p>Nope!</p>",
        "id": 266213789,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1640647126
    },
    {
        "content": "<p>Okay, got the instance.</p>",
        "id": 266213798,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1640647137
    },
    {
        "content": "<p>I'm also adding the <code>loopless</code> lemma into the subgraph API, but I changed it slightly:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">protected</span> <span class=\"kd\">lemma</span> <span class=\"n\">loopless</span> <span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">G'</span> <span class=\"o\">:</span> <span class=\"n\">subgraph</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"n\">G'.adj</span> <span class=\"n\">v</span> <span class=\"n\">v</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span><span class=\"n\">by_contra</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">G.loopless</span> <span class=\"n\">v</span> <span class=\"o\">(</span><span class=\"n\">G'.adj_sub</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 266214169,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1640647506
    },
    {
        "content": "<p>One thing we need to fix for the simple graph API is that many lemma statements use derived decidability and fintype instances, rather than having everything be taken as instance arguments. This is a Known Bug that causes some random problems.</p>\n<p>(A way I've wanted to solve this is to change how computability works in mathlib in general, but it would be nice if someone fixed these things sooner than whenever that might happen <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span>)</p>",
        "id": 266214250,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1640647570
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"451983\">Arthur Paulino</span> <a href=\"#narrow/stream/252551-graph-theory/topic/matchings/near/266214169\">said</a>:</p>\n<blockquote>\n<p>I'm also adding the <code>loopless</code> lemma into the subgraph API, but I changed it slightly:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">protected</span> <span class=\"kd\">lemma</span> <span class=\"n\">loopless</span> <span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">G'</span> <span class=\"o\">:</span> <span class=\"n\">subgraph</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"n\">G'.adj</span> <span class=\"n\">v</span> <span class=\"n\">v</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span><span class=\"n\">by_contra</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">G.loopless</span> <span class=\"n\">v</span> <span class=\"o\">(</span><span class=\"n\">G'.adj_sub</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p><code>adj_irrefl</code>!</p>",
        "id": 266214320,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1640647634
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/252551-graph-theory/topic/matchings/near/266214250\">said</a>:</p>\n<blockquote>\n<p>(A way I've wanted to solve this is to change how computability works in mathlib in general, but it would be nice if someone fixed these things sooner than whenever that might happen <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span>)</p>\n</blockquote>\n<p>I'm gonna ask the protocolary question: Will it change in Lean 4?</p>",
        "id": 266214410,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1640647690
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/252551-graph-theory/topic/matchings/near/266214320\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"451983\">Arthur Paulino</span> <a href=\"#narrow/stream/252551-graph-theory/topic/matchings/near/266214169\">said</a>:</p>\n<blockquote>\n<p>I'm also adding the <code>loopless</code> lemma into the subgraph API, but I changed it slightly:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">protected</span> <span class=\"kd\">lemma</span> <span class=\"n\">loopless</span> <span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">G'</span> <span class=\"o\">:</span> <span class=\"n\">subgraph</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"n\">G'.adj</span> <span class=\"n\">v</span> <span class=\"n\">v</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span><span class=\"n\">by_contra</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">G.loopless</span> <span class=\"n\">v</span> <span class=\"o\">(</span><span class=\"n\">G'.adj_sub</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p><code>adj_irrefl</code>!</p>\n</blockquote>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">adj_irrefl</span> <span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">G'</span> <span class=\"o\">:</span> <span class=\"n\">subgraph</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"n\">G'.adj</span> <span class=\"n\">v</span> <span class=\"n\">v</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">by_contra</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">G.loopless</span> <span class=\"n\">v</span> <span class=\"o\">(</span><span class=\"n\">G'.adj_sub</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 266214455,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1640647743
    },
    {
        "content": "<p>Because yeah clearly decidability management is a pain and shouldn't have to be dealt with. After all, why not a system which puts in the correct decidability assumptions on each lemma, unless it yucks in which case you do it by hand?</p>",
        "id": 266214475,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1640647781
    },
    {
        "content": "<p>Regarding <code>loopless</code> and <code>adj_irrefl</code> -- should we change <code>simple_graph.loopless</code> to <code>simple_graph.adj_irrefl</code> and add <code>simple_graph.loopless</code> as an alias?</p>",
        "id": 266214750,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1640648026
    },
    {
        "content": "<p>Yes please, that would be much more in line with the rest of mathlib <span aria-label=\"smiling face\" class=\"emoji emoji-263a\" role=\"img\" title=\"smiling face\">:smiling_face:</span></p>",
        "id": 266214800,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1640648055
    },
    {
        "content": "<p>At some level I feel like this is caving in to viewing simple graphs as just being relations.</p>",
        "id": 266214808,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1640648065
    },
    {
        "content": "<p>Exactly</p>",
        "id": 266214817,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1640648076
    },
    {
        "content": "<p>And <a href=\"https://github.com/leanprover-community/mathlib/pull/11000\">#11000</a> gives up on those custom names altogether.</p>",
        "id": 266214827,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1640648100
    },
    {
        "content": "<p>Yeah I've been thinking about this idea of being able to have graphs of whatever (not limiting the type of a vertex)</p>",
        "id": 266214862,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1640648144
    },
    {
        "content": "<p>Anyway, so long as it's still <code>simple_graph.loopless</code>, I think it ought to be called <code>simple_graph.subgraph.loopless</code>. I'm very open to <code>adj_irrefl</code> being an alias in both cases for now.</p>",
        "id": 266214926,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1640648198
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"451983\">@Arthur Paulino</span> If I understand you, the intent there is to use sigma types when you want graphs with any vertex type</p>",
        "id": 266214963,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1640648242
    },
    {
        "content": "<p>The next step is of course to drop the <code>subgraph.adj</code> spelling and only use the dot-less <code>graph.adj</code></p>",
        "id": 266214988,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1640648279
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/252551-graph-theory/topic/matchings/near/266214926\">said</a>:</p>\n<blockquote>\n<p>Anyway, so long as it's still <code>simple_graph.loopless</code>, I think it ought to be called <code>simple_graph.subgraph.loopless</code>. I'm very open to <code>adj_irrefl</code> being an alias in both cases for now.</p>\n</blockquote>\n<p>Can I just do a full refactor and stick to <code>adj_irrefl</code> all the way through?</p>",
        "id": 266215034,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1640648287
    },
    {
        "content": "<p>with dot notatable lemmas like <code>graph.adj.symm</code></p>",
        "id": 266215039,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1640648302
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> That's not an \"of course\" -- I really think we don't have to compromise and lose dot notation.</p>",
        "id": 266215042,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1640648303
    },
    {
        "content": "<p>Reread my message <span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span></p>",
        "id": 266215054,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1640648319
    },
    {
        "content": "<p>It's a matter of shifting what we're dot notating on.</p>",
        "id": 266215085,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1640648360
    },
    {
        "content": "<p>I know, and I mean I think we can still have dot notation on the object itself.</p>",
        "id": 266215099,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1640648376
    },
    {
        "content": "<p>But yeah, the dot notation on concrete structures has to be lost for the general lemmas. With the current state of things, this is what refactoring to a typeclass hierarchy entails.</p>",
        "id": 266215159,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1640648421
    },
    {
        "content": "<p>(It might take some small modifications to Lean, but I still need to make sure it can't be done without that.)</p>",
        "id": 266215161,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1640648423
    },
    {
        "content": "<p>If you're willing to dig into Lean itself, then yeah I'm sure you can fix that. But I don't think this is that important. And in particular we shouldn't delay the refactor because of loss of dot notation IMO</p>",
        "id": 266215237,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1640648511
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> I saw that you just pushed a commit. I'm gonna push a commit on top of it okay?</p>",
        "id": 266215311,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1640648576
    },
    {
        "content": "<p>(so you can pull before continuing)</p>",
        "id": 266215325,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1640648600
    },
    {
        "content": "<p>Go ahead. I'm off for the day</p>",
        "id": 266215329,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1640648605
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/252551-graph-theory/topic/matchings/near/266214800\">said</a>:</p>\n<blockquote>\n<p>Yes please, that would be much more in line with the rest of mathlib <span aria-label=\"smiling face\" class=\"emoji emoji-263a\" role=\"img\" title=\"smiling face\">:smiling_face:</span></p>\n</blockquote>\n<p>This isn't actually true, there is exactly one relation which uses <code>_irrefl</code>, namely <code>lt</code>, and exactly one instance of <code>less</code> to describe a property. The mathlib pattern is actually to use <code>irrefl</code> or <code>irrefl_of</code> together with the irreflexivity typeclass.</p>",
        "id": 266215336,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1640648618
    },
    {
        "content": "<p>Btw, today's brainstorming session was fun. Thanks! :D</p>",
        "id": 266218784,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1640651229
    },
    {
        "content": "<p>This is the current state of the PR: <a href=\"https://github.com/leanprover-community/mathlib/pull/11083\">#11083</a> (after <del>hopefully</del> everything we've discussed here)</p>",
        "id": 266219032,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1640651475
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> almost at the same time you posted on the PR, I finished <a href=\"https://github.com/leanprover-community/mathlib/blob/a0db8a91dc5abafe0a1777055c41a66aa3b211ee/src/combinatorics/simple_graph/matching.lean#L96\">Yael's proof</a></p>",
        "id": 266229973,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1640665538
    },
    {
        "content": "<p>It doesn't require any of the assumptions you mentioned on your comment.<br>\nNeither <code>[∀ v, fintype (M.neighbor_set v)]</code> nor <code>[∀ v, fintype (M.coe.neighbor_set v)]</code></p>",
        "id": 266230140,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1640665796
    },
    {
        "content": "<p>I have committed your suggestions as well as your alternative proof. Feel free to commit directly to the branch if you want to adjust details manually before we mark the PR as ready for review <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span></p>",
        "id": 266231004,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1640667055
    },
    {
        "content": "<p>(or just comment here or on the PR and I can commit the adjustments)</p>",
        "id": 266231013,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1640667086
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"451983\">@Arthur Paulino</span>  Oh right, not sure what I was thinking, those are definitely not necessary.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">noncomputable</span> <span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">G'</span> <span class=\"o\">:</span> <span class=\"n\">subgraph</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">G'.verts</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"o\">(</span><span class=\"n\">G'.neighbor_set</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">fintype.of_injective</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">G'.neighbor_set</span> <span class=\"n\">a</span><span class=\"o\">),</span> <span class=\"o\">(⟨</span><span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">G'.edge_vert</span> <span class=\"o\">(</span><span class=\"n\">G'.adj_symm</span> <span class=\"n\">v.2</span><span class=\"o\">)⟩</span> <span class=\"o\">:</span> <span class=\"n\">G'.verts</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"n\">convert</span> <span class=\"n\">congr_arg</span> <span class=\"n\">subtype.val</span> <span class=\"n\">h</span> <span class=\"o\">})</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">is_matching.even_card</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">subgraph</span> <span class=\"n\">G</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">hM</span> <span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"n\">M.verts</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">decidable_rel</span> <span class=\"n\">G.adj</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">M.is_matching</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">even</span> <span class=\"o\">(</span><span class=\"n\">M.verts.to_finset.card</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">classical</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">is_matching_iff_forall_degree</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">M.coe.sum_degrees_eq_twice_card_edges</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n  <span class=\"n\">use</span> <span class=\"n\">M.coe.edge_finset.card</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">this</span><span class=\"o\">,</span> <span class=\"n\">set.to_finset_card</span><span class=\"o\">],</span>\n  <span class=\"n\">refl</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 266231430,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1640667644
    },
    {
        "content": "<p>So we leave the two proofs?</p>",
        "id": 266232004,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1640668488
    },
    {
        "content": "<p>hmm, actually we have this lemma:<br>\n<code>lemma is_matching.support_eq_verts {M : subgraph G} (h : M.is_matching) : M.support = M.verts</code></p>",
        "id": 266232036,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1640668537
    },
    {
        "content": "<p>Exactly -- <code>even M.verts.to_finset.card</code> seems to me to be more basic than <code>even M.support.to_finset.card</code>.</p>",
        "id": 266232084,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1640668566
    },
    {
        "content": "<p>The proofs are basically the same, but when using <code>M.verts</code> you don't need the <code>unfreezingI</code> business.</p>",
        "id": 266232113,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1640668630
    },
    {
        "content": "<p>And now <code>is_perfect_matching.even_card</code> should be even simpler right?</p>",
        "id": 266232179,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1640668702
    },
    {
        "content": "<p>The PR is looking good for now. We can just golf it from here</p>",
        "id": 266233056,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1640670100
    },
    {
        "content": "<p>I've marked it as ready for review</p>",
        "id": 266233061,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1640670120
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/252551-graph-theory/topic/matchings/near/266232113\">said</a>:</p>\n<blockquote>\n<p>The proofs are basically the same, but when using <code>M.verts</code> you don't need the <code>unfreezingI</code> business.</p>\n</blockquote>\n<p>I used <code>M.support</code> precisely because some lemmas were already using it instead of <code>verts</code> and I didn't want to introduce disparity.</p>",
        "id": 266240165,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1640679105
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> Are you proposing to use <code>M.support</code> instead of <code>M.verts</code>? If you're instead explaining what led you to choose it, for what it's worth I forgot what \"the point\" of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/simple_graph.subgraph.is_matching.support_eq_verts\">docs#simple_graph.subgraph.is_matching.support_eq_verts</a> was until I looked at all the code hours later (I, too, had started writing an <code>M.support</code> version to see what might be challenging, but you finished that one first).</p>",
        "id": 266263576,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1640701672
    },
    {
        "content": "<p>IIRC, Yael's motivation was because he would need this result in a near future, but I think he was referring to <code>is_perfect_matching.even_card</code></p>",
        "id": 266265012,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1640702988
    },
    {
        "content": "<p>I am now trying to prove it this way:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">is_perfect_matching.even_card'</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">subgraph</span> <span class=\"n\">G</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">M.is_perfect_matching</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">even</span> <span class=\"o\">(</span><span class=\"n\">fintype.card</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">is_matching.even_card</span> <span class=\"n\">h.1</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">card_verts_eq_of_spanning</span> <span class=\"n\">h.2</span> <span class=\"n\">at</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>But now I need to prove these:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">G'</span> <span class=\"o\">:</span> <span class=\"n\">subgraph</span> <span class=\"n\">G</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"n\">G'.verts</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">card_verts_eq_of_spanning</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">G'</span> <span class=\"o\">:</span> <span class=\"n\">subgraph</span> <span class=\"n\">G</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">G'.is_spanning</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">G'.verts.to_finset.card</span> <span class=\"bp\">=</span> <span class=\"n\">fintype.card</span> <span class=\"n\">V</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 266265110,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1640703053
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">card_verts_eq_of_spanning</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">G'</span> <span class=\"o\">:</span> <span class=\"n\">subgraph</span> <span class=\"n\">G</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">G'.is_spanning</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">G'.verts.to_finset.card</span> <span class=\"bp\">=</span> <span class=\"n\">fintype.card</span> <span class=\"n\">V</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">congr</span><span class=\"o\">,</span> <span class=\"n\">ext1</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span> <span class=\"n\">solve_by_elim</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 266265715,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1640703588
    },
    {
        "content": "<p>For writing the lemma, it's better to include <code>fintype</code> instances for everything in sight:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">card_verts_eq_of_spanning</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">G'</span> <span class=\"o\">:</span> <span class=\"n\">subgraph</span> <span class=\"n\">G</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">G'.verts</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">G'.is_spanning</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">G'.verts.to_finset.card</span> <span class=\"bp\">=</span> <span class=\"n\">fintype.card</span> <span class=\"n\">V</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">is_spanning_iff</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">congr</span><span class=\"o\">,</span> <span class=\"n\">convert</span> <span class=\"n\">set.to_finset_univ</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>(Removed the non-terminal simp and used an existing lemma. There's a bit of magic here with <code>convert</code>; I think it runs <code>assumption</code> automatically?)</p>",
        "id": 266267271,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1640704525
    },
    {
        "content": "<p>There's already an instance <code>fintype G'.verts</code> from <code>fintype V</code> if you have the right decidability instances:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">G'</span> <span class=\"o\">:</span> <span class=\"n\">subgraph</span> <span class=\"n\">G</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_pred</span> <span class=\"o\">(</span><span class=\"bp\">∈</span> <span class=\"n\">G'.verts</span><span class=\"o\">)]:</span> <span class=\"n\">fintype</span> <span class=\"n\">G'.verts</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">apply_instance</span>\n</code></pre></div>",
        "id": 266267380,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1640704603
    },
    {
        "content": "<p>So you can get <code>even_card'</code> working by starting it with the <code>classical</code> tactic.</p>",
        "id": 266267427,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1640704666
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/252551-graph-theory/topic/matchings/near/266267271\">said</a>:</p>\n<blockquote>\n<p>For writing the lemma, it's better to include <code>fintype</code> instances for everything in sight</p>\n</blockquote>\n<p>Doesn't that make the lemma more restrictive?</p>",
        "id": 266267495,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1640704710
    },
    {
        "content": "<p>Then a little bit of golfing:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">is_perfect_matching.even_card'</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">subgraph</span> <span class=\"n\">G</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">M.is_perfect_matching</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">even</span> <span class=\"o\">(</span><span class=\"n\">fintype.card</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">classical</span><span class=\"o\">,</span> <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"n\">card_verts_eq_of_spanning</span> <span class=\"n\">h.2</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">is_matching.even_card</span> <span class=\"n\">h.1</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 266267507,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1640704720
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"451983\">Arthur Paulino</span> <a href=\"#narrow/stream/252551-graph-theory/topic/matchings/near/266267495\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/252551-graph-theory/topic/matchings/near/266267271\">said</a>:</p>\n<blockquote>\n<p>For writing the lemma, it's better to include <code>fintype</code> instances for everything in sight</p>\n</blockquote>\n<p>Doesn't that make the lemma more restrictive?</p>\n</blockquote>\n<p>It's the opposite: it makes sure you can apply it no matter which instances show up in the expression</p>",
        "id": 266267535,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1640704745
    },
    {
        "content": "<p>\"Be permissive in what you accept\": all the instances in the goal are universally quantified here</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">set_option</span> <span class=\"n\">pp.implicit</span> <span class=\"n\">true</span>\n<span class=\"k\">#check</span> <span class=\"bp\">@</span><span class=\"n\">card_verts_eq_of_spanning</span>\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">∀ {V : Type u_1} {G : simple_graph V} [_inst_1 : fintype V] {G' : G.subgraph} [_inst_2 : fintype ↥(G'.verts)],</span>\n<span class=\"cm\">G'.is_spanning → (@set.to_finset V G'.verts _inst_2).card = @fintype.card V _inst_1</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>",
        "id": 266267700,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1640704889
    },
    {
        "content": "<p>Now I'm confused <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 266267774,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1640704927
    },
    {
        "content": "<p>I thought that adding more <code>[]</code> parameters to my lemmas would restrict their usage</p>",
        "id": 266267792,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1640704949
    },
    {
        "content": "<p>Compare it to this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">card_verts_eq_of_spanning</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">G'</span> <span class=\"o\">:</span> <span class=\"n\">subgraph</span> <span class=\"n\">G</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_pred</span> <span class=\"o\">(</span><span class=\"bp\">∈</span> <span class=\"n\">G'.verts</span><span class=\"o\">)]</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">G'.is_spanning</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">G'.verts.to_finset.card</span> <span class=\"bp\">=</span> <span class=\"n\">fintype.card</span> <span class=\"n\">V</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">pp.implicit</span> <span class=\"n\">true</span>\n<span class=\"k\">#check</span> <span class=\"bp\">@</span><span class=\"n\">card_verts_eq_of_spanning</span>\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">∀ {V : Type u_1} {G : simple_graph V} [_inst_1 : fintype V] {G' : G.subgraph} [_inst_2 : @decidable_pred V (λ (_x : V), _x ∈ G'.verts)],</span>\n<span class=\"cm\">G'.is_spanning → (@set.to_finset V G'.verts (@verts.fintype V G _inst_1 G' (λ (a : V), _inst_2 a))).card = @fintype.card V _inst_1</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>",
        "id": 266267810,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1640704967
    },
    {
        "content": "<p>This <em>only</em> applies to the case when the <code>set.to_finset</code> expression's <code>fintype</code> instance is created using <code>set.fintype</code>.</p>",
        "id": 266267843,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1640704999
    },
    {
        "content": "<p>When we get this wrong, this is why we need <code>convert</code> sometimes.</p>",
        "id": 266267852,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1640705010
    },
    {
        "content": "<p>I will need to chew on this a little longer. Either way, this is the PR now: <a href=\"https://github.com/leanprover-community/mathlib/pull/11083\">#11083</a></p>",
        "id": 266268351,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1640705429
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"451983\">@Arthur Paulino</span> The situation is analogous to the difference between these lemmas:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">foo</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">unit</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"o\">()</span> <span class=\"o\">:=</span> <span class=\"n\">subsingleton.elim</span> <span class=\"n\">_</span> <span class=\"n\">_</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">foo'</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">()</span> <span class=\"bp\">=</span> <span class=\"o\">()</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>The first lemma is more general than the second.</p>",
        "id": 266268354,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1640705431
    },
    {
        "content": "<p><code>fintype</code> is also a subsingleton -- even though all <code>fintype</code> instances for the same type are equal, they're not definitionally equal, so it's better to let them be additional arguments.</p>",
        "id": 266268417,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1640705502
    },
    {
        "content": "<p>That's probably why I hit <a href=\"#narrow/stream/113489-new-members/topic/.E2.9C.94.20.60simpa.60.20not.20closing.20goal\">this wall</a></p>",
        "id": 266268599,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1640705661
    },
    {
        "content": "<p>If I remember correctly, that's a different issue (that I also ran into). I think one was <code>finset.univ : finset V</code> and the other was <code>finset.univ : finset (set.univ : set V)</code>.</p>",
        "id": 266268837,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1640705812
    },
    {
        "content": "<p>(In the second case, <code>set.univ</code> is being coerced to a type.)</p>",
        "id": 266268944,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1640705854
    },
    {
        "content": "<p>It would probably be useful having a lemma in mathlib that these have the same cardinality if one doesn't already exist.</p>",
        "id": 266269082,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1640705911
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">finset.univ</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"o\">(</span><span class=\"n\">set.univ</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">finset.univ</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 266269265,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1640706042
    },
    {
        "content": "<p>Would it make <code>card_verts_eq_of_spanning</code> trivial?</p>",
        "id": 266269281,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1640706064
    },
    {
        "content": "<p>(just to make sure I'm following)</p>",
        "id": 266269288,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1640706079
    },
    {
        "content": "<p>Ok, good, got the types right and it's true:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">finset.univ</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"o\">(</span><span class=\"n\">set.univ</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">finset.univ</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">classical</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">finset.card_image_of_injective</span> <span class=\"n\">finset.univ</span> <span class=\"n\">subtype.coe_injective</span><span class=\"o\">,</span>\n  <span class=\"n\">congr</span><span class=\"o\">,</span>\n  <span class=\"n\">ext</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">apply_instance</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 266269410,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1640706183
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"451983\">Arthur Paulino</span> <a href=\"#narrow/stream/252551-graph-theory/topic/matchings/near/266269281\">said</a>:</p>\n<blockquote>\n<p>Would it make <code>card_verts_eq_of_spanning</code> trivial?</p>\n</blockquote>\n<p>I don't know. It seems your proof of that lemma avoided this. I'm not completely sure if it's what you ran into yesterday, but it's definitely something I ran into.</p>",
        "id": 266269646,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1640706375
    },
    {
        "content": "<p>I'm going to post <a href=\"https://github.com/leanprover-community/mathlib/pull/11083\">#11083</a> on <a class=\"stream\" data-stream-id=\"144837\" href=\"/#narrow/stream/144837-PR-reviews\">#PR reviews</a> okay?</p>",
        "id": 266269948,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1640706660
    },
    {
        "content": "<p>My reasoning is just that <code>M.support</code> was already used while <code>M.verts</code> wasn't and <code>M.verts</code> is in general stronger than <code>M.support</code>.</p>",
        "id": 266279312,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1640714903
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/252551-graph-theory/topic/matchings/near/266269410\">said</a>:</p>\n<blockquote>\n<p>Ok, good, got the types right and it's true:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">finset.univ</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"o\">(</span><span class=\"n\">set.univ</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">finset.univ</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">classical</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">finset.card_image_of_injective</span> <span class=\"n\">finset.univ</span> <span class=\"n\">subtype.coe_injective</span><span class=\"o\">,</span>\n  <span class=\"n\">congr</span><span class=\"o\">,</span>\n  <span class=\"n\">ext</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">apply_instance</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Do you think this should go somewhere?</p>",
        "id": 266460705,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1640900752
    }
]
[
    {
        "content": "<p>Hey, I'd like to have a <code>simple_graph.add_edges</code> function mirroring the <code>delete_edges</code> one.<br>\nIt should probably use the newly merged <code>from_edge_set</code>, I understand. Two questions:</p>\n<ol>\n<li>Would <code>add_edges</code> be accepted? If not, should we not also remove <code>delete_edges</code> and only work with <code>from_edge_set</code> ?</li>\n<li>Why is it exactly that <code>delete_edges</code> was not reimplemented on top of <code>from_edge_set</code> ?</li>\n<li>Similarly for <code>.compl</code> ?</li>\n</ol>\n<p>Thanks!</p>",
        "id": 311957776,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1669275496
    },
    {
        "content": "<p>Made a PR here: <a href=\"https://github.com/leanprover-community/mathlib/pull/17704\">https://github.com/leanprover-community/mathlib/pull/17704</a></p>",
        "id": 311974062,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1669282317
    },
    {
        "content": "<p>There was a small difference in the definitions between <code>G.delete_edges s</code> and <code>G \\ from_edge_set s</code> where I thought it would be better to leave that for a future PR to resolve. (The second has an extra <code>ne</code> in there that's not necessary for <code>delete_edges</code>.) Arguably, we can remove <code>delete_edges</code> completely, which was one reason not to do much more than add <code>delete_edges_eq_sdiff_from_edge_set</code>.</p>\n<p>I think it would be better to work with <code>from_edge_set</code> directly rather than introducing <code>add_edges</code>. That way you get access to all the lattice lemmas. If you want to create a useful PR here, it would be great to have <code>from_edge_set_inf</code> and <code>from_edge_set_sup</code> for turning infima and suprema of <code>from_edge_set</code> into <code>from_edge_set</code> of intersections and unions.</p>\n<p>I'm not sure what you mean by defining <code>.compl</code> in terms of <code>from_edge_set</code>. The first uses the <code>adj</code> relation directly, but the second uses a <code>set (sym2 V)</code>.</p>",
        "id": 311974173,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1669282352
    },
    {
        "content": "<p>Mmh, isn't it good to have <code>add/delete_edges</code> as a \"thin layer\" above <code>from_edge_set</code> ?</p>",
        "id": 311974519,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1669282475
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"461830\">Rémi Bottinelli</span> <a href=\"#narrow/stream/252551-graph-theory/topic/.60from_edge_set.60.20and.20.60add_edges.60/near/311974062\">said</a>:</p>\n<blockquote>\n<p>Made a PR here: <a href=\"https://github.com/leanprover-community/mathlib/pull/17704\">https://github.com/leanprover-community/mathlib/pull/17704</a></p>\n</blockquote>\n<p>Ah, you created a PR right when I was writing. I don't think we should have this extra definition.</p>",
        "id": 311974530,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1669282484
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"461830\">Rémi Bottinelli</span> <a href=\"#narrow/stream/252551-graph-theory/topic/.60from_edge_set.60.20and.20.60add_edges.60/near/311974519\">said</a>:</p>\n<blockquote>\n<p>Mmh, isn't it good to have <code>add/delete_edges</code> as a \"thin layer\" above <code>from_edge_set</code> ?</p>\n</blockquote>\n<p>I think not, since this makes it just that much harder to use all the lattice lemmas.</p>",
        "id": 311974616,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1669282524
    },
    {
        "content": "<p>good point. <code>from_edge_set_sdiff</code> is harder because of the potential loops that make the \"lattice preservation\" not on the nose?</p>",
        "id": 311974925,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1669282656
    },
    {
        "content": "<p>I'm not exactly sure why I defined <code>delete_edges</code> rather than <code>from_edge_set</code>! I'm guessing I was too focused on certain arguments where I was transferring walks into subgraphs where you delete edges.</p>",
        "id": 311974940,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1669282661
    },
    {
        "content": "<p>I'm not sure I understand what you mean by lattice preservation exactly.</p>",
        "id": 311975442,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1669282836
    },
    {
        "content": "<p>OK, I'll close my PR <span aria-label=\"cry\" class=\"emoji emoji-1f622\" role=\"img\" title=\"cry\">:cry:</span> and see about the <code>inf/sup</code> thing. By the way, is my current practice of firing up PRs liberally OK?</p>",
        "id": 311975510,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1669282871
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/252551-graph-theory/topic/.60from_edge_set.60.20and.20.60add_edges.60/near/311975442\">said</a>:</p>\n<blockquote>\n<p>I'm not sure I understand what you mean by lattice preservation exactly.</p>\n</blockquote>\n<p>I meant  that we probably won't have anything nice like <code>from_edge_set (A \\ B) = from_edge_set A \\ from_edge_set B</code>, essentially</p>",
        "id": 311975729,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1669282954
    },
    {
        "content": "<p>Your PRs seem fine. Maybe a reasonable criterion they meet is that they're not surprising (they're about things that we'd expect to see a PR about, and they're incremental contributions, which is great).</p>",
        "id": 311976408,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1669283217
    },
    {
        "content": "<p>Is that <code>sdiff</code> lemma not true? Maybe not by <code>refl</code>, but it should be true still.</p>",
        "id": 311976469,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1669283243
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">sym2</span> <span class=\"n\">V</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">from_edge_set</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">\\</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">from_edge_set</span> <span class=\"n\">A</span> <span class=\"bp\">\\</span> <span class=\"n\">from_edge_set</span> <span class=\"n\">B</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">ext</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"n\">split</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">{</span> <span class=\"n\">contextual</span> <span class=\"o\">:=</span> <span class=\"n\">tt</span><span class=\"o\">}</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 311976976,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1669283435
    },
    {
        "content": "<p>huh, yeah, this is actually true… well, I'll try and attack all this then. Ideally, we'd have enough lemmas about <code>from_edge_set</code> that everything about <code>delete_edges</code> is covered, and we can gradually replace it?</p>",
        "id": 311977004,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1669283449
    },
    {
        "content": "<p>can you tell me again what the contextual trick does?</p>",
        "id": 311977053,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1669283471
    },
    {
        "content": "<p>The only bad thing about lattice preservation about <code>from_edge_set</code> is that it's non-injective precisely along the <code>is_diag</code> elements of <code>sym2 V</code></p>",
        "id": 311977055,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1669283472
    },
    {
        "content": "<p>Whenever there's an implication <code>a -&gt; b</code>, simp will use <code>a</code> when simplifying <code>b</code></p>",
        "id": 311977092,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1669283491
    },
    {
        "content": "<p>ah, I see, thanks!</p>",
        "id": 311977138,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1669283513
    },
    {
        "content": "<p>I could have probably also done <code>simp, tauto</code>, but this ensured the <code>simp</code>s were terminal rather than needing to squeeze the <code>simp</code></p>",
        "id": 311977272,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1669283552
    },
    {
        "content": "<p>yeah, I have a few <code>simp, tauto</code> in the above PR</p>",
        "id": 311977329,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1669283579
    },
    {
        "content": "<p>exactly where you had <code>contextual</code></p>",
        "id": 311977355,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1669283591
    },
    {
        "content": "<p><code>simp, tauto</code> is fine, though. <code>tauto</code> comes after <code>simp</code>, but it's a fancy tactic too.</p>",
        "id": 311980428,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1669284682
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/252551-graph-theory/topic/.60from_edge_set.60.20and.20.60add_edges.60/near/311980428\">said</a>:</p>\n<blockquote>\n<p><code>simp, tauto</code> is fine, though. <code>tauto</code> comes after <code>simp</code>, but it's a fancy tactic too.</p>\n</blockquote>\n<p>but mathlib-friendly, right?</p>",
        "id": 311980670,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1669284770
    },
    {
        "content": "<p>Not sure what you mean. It certainly is acceptable in mathlib.</p>",
        "id": 311986316,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1669286705
    },
    {
        "content": "<p>yeah, that's what I meant</p>",
        "id": 311988041,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1669287268
    },
    {
        "content": "<p>non-terminal simps are acceptable in mathlib in the sense that there exist non-terminal simps in mathlib. Doesn't always mean they're a good idea :-)</p>",
        "id": 312017306,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1669297109
    },
    {
        "content": "<p>Kevin, my point is that this is not a non-terminal simp. There are two types of tactics:</p>\n<ul>\n<li>rigid: These don't adapt to the context, or barely. Eg <code>exact</code>, <code>rw</code>, <code>simp_rw</code>, <code>congr</code></li>\n<li>fancy: These adapt to the context. Eg <code>simp</code>, <code>tauto</code>, <code>finish</code>, <code>linarith</code>.</li>\n</ul>\n<p>Any combination of tactics is allowed, so long as no rigid tactic call follows a fancy tactic call.</p>",
        "id": 312023840,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1669298964
    },
    {
        "content": "<p>In particular, <code>simp, tauto</code> is allowed.</p>",
        "id": 312023898,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1669298983
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> Would you accept changing <code>G.delete_edges s</code> for <code>from_edge_set G.edge_set \\ s</code>from your <code>acyclic</code> work? I'm trying to work with <code>from_edge_set</code> for adding edges, and the inconsistency makes stuff painful.</p>",
        "id": 312179930,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1669380559
    },
    {
        "content": "<p>Btw, I don't really get how <code>abbreviation delete_edges := …</code> wouldn't also work with the lattice lemmas ?</p>",
        "id": 312180325,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1669380691
    },
    {
        "content": "<p><code>abbreviation</code> isn't perfect:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">abbreviation</span> <span class=\"n\">my_add</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">my_add</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">my_add</span> <span class=\"n\">b</span> <span class=\"n\">a</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">add_comm</span><span class=\"o\">,</span> <span class=\"c1\">-- fails</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 312180992,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1669380920
    },
    {
        "content": "<p>I see, it's just not transparent enough for what you want</p>",
        "id": 312181359,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1669381023
    },
    {
        "content": "<p>My problem is that plenty of reasonable lemmas about <code>delete_edges</code>/<code>add_edges</code> become clunky to state in the more general context of <code>from_edge_set …</code></p>",
        "id": 312181569,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1669381083
    },
    {
        "content": "<p>For deleting edges, <code>from_edge_set (G.edge_set \\ s)</code> seems odd -- I would use <code>G \\ from_edge_set s</code></p>",
        "id": 312181735,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1669381144
    },
    {
        "content": "<p>ah, yes, dumb me</p>",
        "id": 312182008,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1669381223
    },
    {
        "content": "<p>and that's why the lemma is stated that way</p>",
        "id": 312182036,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1669381232
    },
    {
        "content": "<p>If there's not already a lemma relating the two, it'd be nice to have it!</p>",
        "id": 312182154,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1669381266
    },
    {
        "content": "<p>Still, would you be OK with me porting the acyclic stuff to <code>from_edge_set</code> ?</p>",
        "id": 312182248,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1669381298
    },
    {
        "content": "<p>Yeah, go ahead</p>",
        "id": 312182598,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1669381414
    },
    {
        "content": "<p>One thing you should try to do is get it so that the simp lemmas work together to give <code>(G \\ from_edge_set s).edge_set = G.edge_set \\ s</code>.</p>",
        "id": 312182809,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1669381478
    },
    {
        "content": "<p>isn't it the case already?</p>",
        "id": 312182910,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1669381528
    },
    {
        "content": "<p>One way is to add a simp lemma that <code>G.edge_set \\ {e ∈ s | ¬ e.is_diag} = G.edge_set \\ s</code>.</p>",
        "id": 312182914,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1669381530
    },
    {
        "content": "<p>how would you even call such a lemma: <code>edge_set_sdiff_off_diag_eq</code> ?</p>",
        "id": 312183073,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1669381579
    },
    {
        "content": "<p>The problem is that <code>(G \\ from_edge_set s).edge_set</code> could simplify to <code>G.edge_set \\ (from_edge_set s).edge_set</code>, but <code>(from_edge_set s).edge_set = {e ∈ s | ¬ e.is_diag}</code></p>",
        "id": 312183101,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1669381588
    },
    {
        "content": "<p>I guess while you're removing <code>delete_edges</code> you should evaluate whether I'm wrong about removing it. I hope this is the only real annoyance...</p>",
        "id": 312183527,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1669381715
    },
    {
        "content": "<p>I've got plenty of probably useless <code>from_edge_set</code> lemmas and will see which prove useful while using them:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">combinatorics.simple_graph.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.set.finite</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.sym.sym2</span>\n\n<span class=\"kd\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">w</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">simple_graph</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">from_edge_set_inf</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">sym2</span> <span class=\"n\">V</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n  <span class=\"n\">from_edge_set</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">∩</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">from_edge_set</span> <span class=\"n\">s</span> <span class=\"bp\">⊓</span> <span class=\"n\">from_edge_set</span> <span class=\"n\">t</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">ext</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">from_edge_set_adj</span><span class=\"o\">,</span> <span class=\"n\">set.mem_inter_iff</span><span class=\"o\">,</span> <span class=\"n\">ne.def</span><span class=\"o\">,</span> <span class=\"n\">inf_adj</span><span class=\"o\">],</span> <span class=\"n\">tauto</span><span class=\"o\">,</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">from_edge_set_sup</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">sym2</span> <span class=\"n\">V</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n  <span class=\"n\">from_edge_set</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">∪</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">from_edge_set</span> <span class=\"n\">s</span> <span class=\"bp\">⊔</span> <span class=\"n\">from_edge_set</span> <span class=\"n\">t</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">ext</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">set.mem_union</span><span class=\"o\">,</span> <span class=\"n\">or_and_distrib_right</span><span class=\"o\">],</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">from_edge_set_sdiff</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">sym2</span> <span class=\"n\">V</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n  <span class=\"n\">from_edge_set</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">\\</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">from_edge_set</span> <span class=\"n\">s</span> <span class=\"bp\">\\</span> <span class=\"n\">from_edge_set</span> <span class=\"n\">t</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">ext</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"n\">split</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">{</span> <span class=\"n\">contextual</span> <span class=\"o\">:=</span> <span class=\"n\">tt</span> <span class=\"o\">},</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">from_edge_set_mono</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">sym2</span> <span class=\"n\">V</span><span class=\"o\">)}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">⊆</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">from_edge_set</span> <span class=\"n\">s</span> <span class=\"bp\">≤</span> <span class=\"n\">from_edge_set</span> <span class=\"n\">t</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rintro</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">from_edge_set_adj</span><span class=\"o\">,</span> <span class=\"n\">ne.def</span><span class=\"o\">,</span> <span class=\"n\">not_false_iff</span><span class=\"o\">,</span> <span class=\"n\">and_true</span><span class=\"o\">,</span> <span class=\"n\">and_imp</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">contextual</span> <span class=\"o\">:=</span> <span class=\"n\">tt</span><span class=\"o\">},</span>\n  <span class=\"n\">exact</span> <span class=\"bp\">λ</span> <span class=\"n\">vws</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">h</span> <span class=\"n\">vws</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">from_edge_set_le_from_edge_set_iff</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">sym2</span> <span class=\"n\">V</span><span class=\"o\">)}</span> <span class=\"o\">:</span>\n  <span class=\"n\">from_edge_set</span> <span class=\"n\">s</span> <span class=\"bp\">≤</span> <span class=\"n\">from_edge_set</span> <span class=\"n\">t</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">\\</span> <span class=\"o\">(</span><span class=\"n\">set_of</span> <span class=\"n\">sym2.is_diag</span><span class=\"o\">))</span> <span class=\"bp\">⊆</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"bp\">\\</span> <span class=\"o\">(</span><span class=\"n\">set_of</span> <span class=\"n\">sym2.is_diag</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintros</span> <span class=\"n\">h</span> <span class=\"o\">⟨</span><span class=\"n\">u</span><span class=\"o\">,</span><span class=\"n\">v</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">change</span> <span class=\"bp\">⟦</span><span class=\"o\">(</span><span class=\"n\">u</span><span class=\"o\">,</span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"bp\">⟧</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">\\</span> <span class=\"n\">set_of</span> <span class=\"n\">sym2.is_diag</span> <span class=\"bp\">→</span> <span class=\"bp\">⟦</span><span class=\"o\">(</span><span class=\"n\">u</span><span class=\"o\">,</span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"bp\">⟧</span> <span class=\"bp\">∈</span> <span class=\"n\">t</span> <span class=\"bp\">\\</span> <span class=\"n\">set_of</span> <span class=\"n\">sym2.is_diag</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"o\">{</span> <span class=\"n\">contextual</span> <span class=\"o\">:=</span> <span class=\"n\">tt</span> <span class=\"o\">},</span>\n    <span class=\"n\">exact</span> <span class=\"bp\">λ</span> <span class=\"n\">uvs</span> <span class=\"n\">ne</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">⟨</span><span class=\"n\">uvs</span><span class=\"o\">,</span><span class=\"n\">ne</span><span class=\"o\">⟩)</span><span class=\"bp\">.</span><span class=\"n\">left</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"n\">h</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span><span class=\"n\">a.ne</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">refine</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">left</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">a.left</span><span class=\"o\">,</span><span class=\"n\">a.right</span><span class=\"o\">⟩,</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">from_edge_set_eq_from_edge_set_iff</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">sym2</span> <span class=\"n\">V</span><span class=\"o\">)}</span> <span class=\"o\">:</span>\n  <span class=\"n\">from_edge_set</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"n\">from_edge_set</span> <span class=\"n\">t</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">\\</span> <span class=\"o\">(</span><span class=\"n\">set_of</span> <span class=\"n\">sym2.is_diag</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"bp\">\\</span> <span class=\"o\">(</span><span class=\"n\">set_of</span> <span class=\"n\">sym2.is_diag</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">le_antisymm_iff</span><span class=\"o\">,</span> <span class=\"n\">from_edge_set_le_from_edge_set_iff</span><span class=\"o\">]</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">le_from_edge_set_iff</span>  <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">sym2</span> <span class=\"n\">V</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">G</span> <span class=\"bp\">≤</span> <span class=\"n\">from_edge_set</span> <span class=\"n\">s</span> <span class=\"bp\">↔</span> <span class=\"n\">G.edge_set</span> <span class=\"bp\">⊆</span> <span class=\"n\">s</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"n\">h</span> <span class=\"o\">⟨</span><span class=\"n\">u</span><span class=\"o\">,</span><span class=\"n\">v</span><span class=\"o\">⟩</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">left</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"n\">h</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">h</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">a.ne</span><span class=\"o\">⟩,</span> <span class=\"n\">exact</span> <span class=\"n\">a</span><span class=\"o\">,},</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">from_edge_set_le_iff</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">sym2</span> <span class=\"n\">V</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">from_edge_set</span> <span class=\"n\">s</span> <span class=\"bp\">≤</span> <span class=\"n\">G</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">\\</span> <span class=\"o\">(</span><span class=\"n\">set_of</span> <span class=\"n\">sym2.is_diag</span><span class=\"o\">))</span> <span class=\"bp\">⊆</span> <span class=\"n\">G.edge_set</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">nth_rewrite</span> <span class=\"mi\">0</span> <span class=\"bp\">←</span><span class=\"n\">from_edge_set_edge_set</span> <span class=\"n\">G</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">from_edge_set_le_from_edge_set_iff</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">G.edge_set</span> <span class=\"bp\">\\</span> <span class=\"n\">set_of</span> <span class=\"n\">sym2.is_diag</span> <span class=\"bp\">=</span> <span class=\"n\">G.edge_set</span><span class=\"o\">,</span> <span class=\"kd\">by</span>\n  <span class=\"o\">{</span> <span class=\"n\">ext</span> <span class=\"o\">⟨</span><span class=\"n\">u</span><span class=\"o\">,</span><span class=\"n\">v</span><span class=\"o\">⟩,</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">set.mem_diff</span><span class=\"o\">,</span> <span class=\"n\">set.mem_set_of_eq</span><span class=\"o\">,</span> <span class=\"n\">and_iff_left_iff_imp</span><span class=\"o\">],</span> <span class=\"n\">exact</span> <span class=\"n\">adj.ne</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"n\">rw</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">from_edge_set_eq_iff</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">sym2</span> <span class=\"n\">V</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">from_edge_set</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"n\">G</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">\\</span> <span class=\"o\">(</span><span class=\"n\">set_of</span> <span class=\"n\">sym2.is_diag</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"n\">G.edge_set</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">nth_rewrite</span> <span class=\"mi\">0</span> <span class=\"bp\">←</span><span class=\"n\">from_edge_set_edge_set</span> <span class=\"n\">G</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">from_edge_set_eq_from_edge_set_iff</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">G.edge_set</span> <span class=\"bp\">\\</span> <span class=\"n\">set_of</span> <span class=\"n\">sym2.is_diag</span> <span class=\"bp\">=</span> <span class=\"n\">G.edge_set</span><span class=\"o\">,</span> <span class=\"kd\">by</span>\n  <span class=\"o\">{</span> <span class=\"n\">ext</span> <span class=\"o\">⟨</span><span class=\"n\">u</span><span class=\"o\">,</span><span class=\"n\">v</span><span class=\"o\">⟩,</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">set.mem_diff</span><span class=\"o\">,</span> <span class=\"n\">set.mem_set_of_eq</span><span class=\"o\">,</span> <span class=\"n\">and_iff_left_iff_imp</span><span class=\"o\">],</span> <span class=\"n\">exact</span> <span class=\"n\">adj.ne</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"n\">rw</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">edge_set_sdiff_off_diag_eq</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">sym2</span> <span class=\"n\">V</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">G.edge_set</span> <span class=\"bp\">\\</span> <span class=\"o\">{</span><span class=\"n\">e</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">|</span> <span class=\"bp\">¬</span> <span class=\"n\">e.is_diag</span><span class=\"o\">}</span> <span class=\"bp\">=</span> <span class=\"n\">G.edge_set</span> <span class=\"bp\">\\</span> <span class=\"n\">s</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">simple_graph</span>\n</code></pre></div>",
        "id": 312183646,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1669381753
    },
    {
        "content": "<p>maybe <code>edge_set_sdiff_sep_not_is_diag_eq</code>? or without the <code>_eq</code>?</p>",
        "id": 312183658,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1669381758
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/252551-graph-theory/topic/.60from_edge_set.60.20and.20.60add_edges.60/near/312183527\">said</a>:</p>\n<blockquote>\n<p>I guess while you're removing <code>delete_edges</code> you should evaluate whether I'm wrong about removing it. I hope this is the only real annoyance...</p>\n</blockquote>\n<p>Well, for \"discoverability\", I quite liked having specified <code>add/delete</code> functions, and then you get nice lemmas about everything you might want, but I can see the point of reducing the api surface</p>",
        "id": 312183908,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1669381838
    },
    {
        "content": "<p>huh, what's the <code>sep</code> meant for?</p>",
        "id": 312184012,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1669381877
    },
    {
        "content": "<p>I see you're writing <code>s \\ (set_of sym2.is_diag)</code>. We should decide between writing that or <code>{e ∈ s | ¬ e.is_diag}</code>. I had chosen the second because (1) I didn't think of writing it the first way and (2) <code>z ∈ {e ∈ s | ¬ e.is_diag}</code> means <code>z ∈ s /\\ ¬ e.is_diag</code> definitionally in an obvious way (though both forms mean this)</p>",
        "id": 312184110,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1669381916
    },
    {
        "content": "<p><code>sep</code> is for this \"axiom of separation\" set notation</p>",
        "id": 312184180,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1669381930
    },
    {
        "content": "<p>Maybe <code>s \\ set_of sym2.is_diag</code> is better since it sticks with lattice operations</p>",
        "id": 312184378,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1669382000
    },
    {
        "content": "<p>so we should instead have <code>lemma edge_set_from_edge_set : (from_edge_set s).edge_set = s \\ set_of sym2.is_diag</code>?</p>",
        "id": 312184641,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1669382081
    },
    {
        "content": "<p>haha, I was finding your set comprehension version nicer to the eye</p>",
        "id": 312184769,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1669382117
    },
    {
        "content": "<p><code>set_of</code> looks quite more opaque, but the lattice argument makes sense, even more so since that's big part in your desire to drop <code>delete_edges</code></p>",
        "id": 312184958,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1669382181
    },
    {
        "content": "<p>One could make a case for defining <code>sym2.diag α := {z : sym2 α | z.is_diag}</code> (or <code>sym2.diagonal</code> to match <code>set.diagonal</code>)</p>",
        "id": 312185683,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1669382427
    },
    {
        "content": "<p>Note that you can write <code>{e : sym2 V | e.is_diag}</code> in place of <code>set_of sym2.is_diag</code>. It means the same thing.</p>",
        "id": 312185722,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1669382448
    },
    {
        "content": "<p>right, like that:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">edge_set_sdiff_sep_not_is_diag_eq</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">sym2</span> <span class=\"n\">V</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">G.edge_set</span> <span class=\"bp\">\\</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">\\</span> <span class=\"o\">{</span><span class=\"n\">e</span> <span class=\"bp\">|</span> <span class=\"n\">e.is_diag</span><span class=\"o\">})</span> <span class=\"bp\">=</span> <span class=\"n\">G.edge_set</span> <span class=\"bp\">\\</span> <span class=\"n\">s</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">ext</span> <span class=\"o\">⟨</span><span class=\"n\">u</span><span class=\"o\">,</span><span class=\"n\">v</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"n\">h</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">not_and</span><span class=\"o\">,</span> <span class=\"n\">not_not</span><span class=\"o\">,</span> <span class=\"n\">set.mem_diff</span><span class=\"o\">,</span> <span class=\"n\">set.mem_set_of_eq</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">es</span><span class=\"o\">,</span> <span class=\"n\">a.ne</span> <span class=\"bp\">$</span> <span class=\"n\">h</span> <span class=\"n\">es</span><span class=\"o\">⟩,</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"n\">ns</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">es</span><span class=\"o\">,</span> <span class=\"n\">ns</span> <span class=\"n\">es.left</span><span class=\"o\">⟩,</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 312186195,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1669382608
    },
    {
        "content": "<p>a mouthful of a name, I must say</p>",
        "id": 312186266,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1669382638
    },
    {
        "content": "<p>Alright, I'll start with those lemmas and probably make a small PR if things seem to work out well enough when converting your <code>acyclic</code> and <code>bridge</code> code</p>",
        "id": 312187145,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1669382890
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">not_is_diag_of_mem_edge_set</span> <span class=\"o\">{</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">sym2</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">e</span> <span class=\"bp\">∈</span> <span class=\"n\">G.edge_set</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"n\">e.is_diag</span> <span class=\"o\">:=</span>\n<span class=\"n\">sym2.ind</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"n\">h'</span><span class=\"o\">,</span> <span class=\"n\">adj.ne</span> <span class=\"n\">h'</span><span class=\"o\">)</span> <span class=\"n\">e</span> <span class=\"n\">h</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">edge_set_sdiff_sdiff_is_diag</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">sym2</span> <span class=\"n\">V</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">G.edge_set</span> <span class=\"bp\">\\</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">\\</span> <span class=\"o\">{</span><span class=\"n\">e</span> <span class=\"bp\">|</span> <span class=\"n\">e.is_diag</span><span class=\"o\">})</span> <span class=\"bp\">=</span> <span class=\"n\">G.edge_set</span> <span class=\"bp\">\\</span> <span class=\"n\">s</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">ext</span> <span class=\"n\">e</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">set.mem_diff</span><span class=\"o\">,</span> <span class=\"n\">set.mem_set_of_eq</span><span class=\"o\">,</span> <span class=\"n\">not_and</span><span class=\"o\">,</span> <span class=\"n\">not_not</span><span class=\"o\">,</span> <span class=\"n\">and.congr_right_iff</span><span class=\"o\">],</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">G.not_is_diag_of_mem_edge_set</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">imp_false</span><span class=\"o\">],</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 312187708,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1669383063
    },
    {
        "content": "<p>ah, yes, that's useful</p>",
        "id": 312187844,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1669383115
    },
    {
        "content": "<p>and I feel dumb, as always for bruteforcing stuff</p>",
        "id": 312187907,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1669383128
    },
    {
        "content": "<p>These are just tricks one picks up over time! I remember my lemmas for <code>sym2</code> looking like your <code>edge_set_sdiff_sep_not_is_diag_eq</code>. I know to reach for <code>sym2.ind</code> because it's solving pain points I've personally experienced.</p>",
        "id": 312189263,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1669383544
    },
    {
        "content": "<p>It's also easier to golf someone else's proofs than to write the proofs for the first time.</p>",
        "id": 312189332,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1669383570
    },
    {
        "content": "<p>Speaking of golfing, it looks like <code>sym2.ind (λ v w, adj.ne) e h</code> will do</p>",
        "id": 312189495,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1669383610
    },
    {
        "content": "<p>Any reason for this not to be included in <code>basic</code> ?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">edge_set_sdiff</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"bp\">\\</span> <span class=\"n\">H</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">edge_set</span> <span class=\"bp\">=</span> <span class=\"n\">G.edge_set</span> <span class=\"bp\">\\</span> <span class=\"n\">H.edge_set</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">ext</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"n\">y</span><span class=\"o\">⟩,</span> <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">id</span><span class=\"o\">,</span> <span class=\"n\">id</span><span class=\"o\">⟩</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">edge_set_inf</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"bp\">⊓</span> <span class=\"n\">H</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">edge_set</span> <span class=\"bp\">=</span> <span class=\"n\">G.edge_set</span> <span class=\"bp\">∩</span> <span class=\"n\">H.edge_set</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">ext</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"n\">y</span><span class=\"o\">⟩,</span> <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">id</span><span class=\"o\">,</span> <span class=\"n\">id</span><span class=\"o\">⟩</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">edge_set_sup</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"bp\">⊔</span> <span class=\"n\">H</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">edge_set</span> <span class=\"bp\">=</span> <span class=\"n\">G.edge_set</span> <span class=\"bp\">∪</span> <span class=\"n\">H.edge_set</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">ext</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"n\">y</span><span class=\"o\">⟩,</span> <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">id</span><span class=\"o\">,</span> <span class=\"n\">id</span><span class=\"o\">⟩</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 312217745,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1669392184
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/pull/17723\">https://github.com/leanprover-community/mathlib/pull/17723</a> &lt;- what about this?</p>",
        "id": 312225350,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1669394894
    },
    {
        "content": "<p>Those lattice lemmas seem good. May as well have these too:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">edge_set_injective</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">simple_graph.edge_set</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">sym2</span> <span class=\"n\">V</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">injective</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intros</span> <span class=\"n\">G</span> <span class=\"n\">G'</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">ext</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">mem_edge_set</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">mem_edge_set</span><span class=\"o\">],</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">edge_set_subset_iff</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"n\">G'</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"n\">G.edge_set</span> <span class=\"bp\">⊆</span> <span class=\"n\">G'.edge_set</span> <span class=\"bp\">↔</span> <span class=\"n\">G</span> <span class=\"bp\">≤</span> <span class=\"n\">G'</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">mono</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">intros</span> <span class=\"n\">h</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">,</span>\n  <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">mem_edge_set</span><span class=\"o\">],</span>\n  <span class=\"n\">exact</span> <span class=\"bp\">λ</span> <span class=\"n\">h'</span><span class=\"o\">,</span> <span class=\"n\">h</span> <span class=\"n\">h'</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>(and tag <code>edge_set_mono</code> with <code>@[mono]</code>)</p>",
        "id": 312225420,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1669394926
    },
    {
        "content": "<p>Proof of the quality of your code: I didn't even need to change <code>acyclic.lean</code> in the PR</p>",
        "id": 312225525,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1669394966
    },
    {
        "content": "<p>[Done] OK, I'll add those to the PR (I hope we can bypass splitting it, but if needed, I can first do one just for the lemmas, and one converting <code>is_bridge</code> and friends)</p>",
        "id": 312225747,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1669395045
    },
    {
        "content": "<p>Thanks for the comments, will update the PR tomorrow!</p>",
        "id": 312230540,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1669396915
    }
]
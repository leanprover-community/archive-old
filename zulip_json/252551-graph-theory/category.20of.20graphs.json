[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"303889\">@Alena Gusakov</span> and I started trying to define this together, but we detoured into doing Scott's lftcm exercises and don't have a definition</p>",
        "id": 208455719,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1598737831
    },
    {
        "content": "<p>I think there is a category file in <a href=\"https://github.com/leanprover-community/mathlib/tree/hedetniemi\">branch#hedetniemi</a> ?</p>",
        "id": 208455726,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1598737859
    },
    {
        "content": "<p>oh, maybe I'm wrong, they do have this, though</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">def</span> <span class=\"n\">as_graph</span> <span class=\"o\">(</span><span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">category_theory</span><span class=\"bp\">.</span><span class=\"n\">category</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">directed_multigraph</span> <span class=\"n\">C</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">edge</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"err\">⟶</span> <span class=\"n\">y</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 208455792,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1598737991
    },
    {
        "content": "<p>There are a few different definitions?</p>",
        "id": 208455795,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1598737998
    },
    {
        "content": "<p>In your attempts so far, are the morphisms homomorphisms or embeddings?</p>",
        "id": 208455804,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1598738029
    },
    {
        "content": "<p>I think that's the definition that takes a category and reinterprets it as a directed multigraph</p>",
        "id": 208455809,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1598738038
    },
    {
        "content": "<p>it's like the inverse of <code>has_hom</code> (but not quite)</p>",
        "id": 208455852,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1598738061
    },
    {
        "content": "<p>the category of homormorphisms is more interesting</p>",
        "id": 208455855,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1598738095
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"302826\">@Aaron Anderson</span> in your definition of embedding, why did you make it so that image must be an induced graph? I haven't checked, but I don't think that's what a monomorphism would be given your definition of a homomorphism.</p>",
        "id": 208455900,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1598738172
    },
    {
        "content": "<p>The real reason is that that's the definition of an embedding from model theory, but I can think of a few justifications</p>",
        "id": 208456038,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1598738436
    },
    {
        "content": "<p>It's not what I would expect from the word 'embedding'.  I'd like to be able to define a path as an embedding of a path graph, for example.  What's a use of your definition of an embedding with respect to graph theory?</p>",
        "id": 208456108,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1598738612
    },
    {
        "content": "<p>When showing the random graph is unique, you use an increasing chain of partial embeddings between two random graphs, and you want this definition</p>",
        "id": 208456234,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1598738829
    },
    {
        "content": "<p>Sometimes you do want an embedding to have to be an isomorphism onto its image</p>",
        "id": 208456285,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1598738901
    },
    {
        "content": "<p>According to nLab, my definition corresponds to a \"regular mono\"</p>",
        "id": 208456287,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1598738903
    },
    {
        "content": "<p>And they philosophically say \"A monomorphism is regular if it behaves like an embedding.\"</p>",
        "id": 208456294,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1598738926
    },
    {
        "content": "<p>I guess the analogue in topology is that this is the difference between a smooth embedding and an injective smooth map.  I tend to think of graphs as being topologically realized, which means arbitrary subdivisions of edges are equivalent, at least as far as maps are concerned.  However, if you cannot subdivide edges, then as a simplicial map the embedding really would need to have an image that's an induced subgraph.  (Topologically, you want the simplicial image to have a regular neighborhood.  Injective graph homomorphisms don't have these in general.)</p>",
        "id": 208456524,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1598739311
    },
    {
        "content": "<p>It's probably worth noting the nlab's definition of the category of graphs as well: <a href=\"https://ncatlab.org/nlab/show/category+of+simple+graphs\">https://ncatlab.org/nlab/show/category+of+simple+graphs</a></p>",
        "id": 208456578,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1598739396
    },
    {
        "content": "<p>Although there's also: <a href=\"https://ncatlab.org/nlab/show/the+category+of+simple+graphs+from+a+graph-theoretic+perspective\">https://ncatlab.org/nlab/show/the+category+of+simple+graphs+from+a+graph-theoretic+perspective</a></p>",
        "id": 208456642,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1598739535
    },
    {
        "content": "<p>Something I'd like to be true is that if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>G</mi><mo lspace=\"0em\" mathvariant=\"normal\" rspace=\"0em\">′</mo></msup></mrow><annotation encoding=\"application/x-tex\">G'</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.751892em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">G</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.751892em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span></span></span></span> is a subgraph of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span>, then there is some notion of an embedding <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>G</mi><mo lspace=\"0em\" mathvariant=\"normal\" rspace=\"0em\">′</mo></msup><mo>↪</mo><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G' \\hookrightarrow G</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.762892em;vertical-align:-0.011em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">G</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.751892em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">↪</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span>.</p>",
        "id": 208456765,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1598739737
    },
    {
        "content": "<p>\"monos in SimpGph are simple graph maps that are injective on vertices and edges,\"</p>",
        "id": 208456787,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1598739831
    },
    {
        "content": "<p>Pretty sure this matches what you want?</p>",
        "id": 208456812,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1598739843
    },
    {
        "content": "<p>Yeah, I’d be in favor of having bundled monos and regular monos, but I prefer the regular monos get the name and symbol of embeddings.</p>",
        "id": 208456856,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1598739911
    },
    {
        "content": "<p>Yeah, exactly.  I believe that regular monomorphisms are useful, too, but I'd like to make sure that there is notation for monomorphisms.</p>",
        "id": 208456857,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1598739912
    },
    {
        "content": "<p>In the category theory library, neither of these are bundled (which I think is a good thing) and they're all typeclasses (which I think <em>might</em> be a bad thing)</p>",
        "id": 208456894,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1598739962
    },
    {
        "content": "<p>I can certainly see the value of bundling them for graphs though</p>",
        "id": 208456917,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1598739981
    },
    {
        "content": "<p>It’s also nice that the regular mono version is available as an abbreviation</p>",
        "id": 208456924,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1598740010
    },
    {
        "content": "<p>I do add those abbreviations in <a href=\"https://github.com/leanprover-community/mathlib/issues/3946\">#3946</a></p>",
        "id": 208456938,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1598740052
    },
    {
        "content": "<p>Cycling this thread back around, I’d be happy to help define the category, as I think I understand how bundled categories work</p>",
        "id": 208456984,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1598740115
    },
    {
        "content": "<p>I wonder how horrible it'd be to define the category of graphs like this instead: <a href=\"https://ncatlab.org/nlab/show/category+of+simple+graphs#properties_of_\">https://ncatlab.org/nlab/show/category+of+simple+graphs#properties_of_</a></p>",
        "id": 208456996,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1598740172
    },
    {
        "content": "<p>so eventually we will have a theorem like </p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"err\">\\</span><span class=\"k\">forall</span> <span class=\"err\">\\</span><span class=\"n\">iota</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">Graph</span><span class=\"bp\">.</span><span class=\"n\">hom_of_embedding</span> <span class=\"err\">\\</span><span class=\"n\">iota</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">is_mono</span>\n</code></pre></div>\n\n\n<p>?</p>",
        "id": 208457051,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1598740217
    },
    {
        "content": "<p>uh, i hope you don't mean defining it via theorem 3.1</p>",
        "id": 208457056,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1598740236
    },
    {
        "content": "<p>I do mean that, but I'm not seriously suggesting it as the definition</p>",
        "id": 208457070,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1598740283
    },
    {
        "content": "<p>got it</p>",
        "id": 208457077,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1598740298
    },
    {
        "content": "<p>I think I do basically have all the language and theory built up to prove most of that though</p>",
        "id": 208457084,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1598740308
    },
    {
        "content": "<p>I expect it won't give results which aren't easier to prove directly but still!</p>",
        "id": 208457134,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1598740338
    },
    {
        "content": "<p>I'm in favor of the goal \"prove all of the theorems on the nlab page for which mathlib already has the categorical definitions\"</p>",
        "id": 208457152,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1598740388
    },
    {
        "content": "<p>and I think the same goal with \"mathlib\" replaced by \"bhavik's topos repo\" is interesting but I don't know enough math to contribute at all <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 208457246,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1598740482
    },
    {
        "content": "<p>Haha, entirely reasonable! Unless someone else is interested in helping me do it or there's a result which people who don't care about categories want out of it, I don't think I'll get to it any time soon either :)</p>",
        "id": 208457277,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1598740550
    },
    {
        "content": "<p>Oh, i just noticed what you said on the other topic about requiring reflexivity. The most natural category of graphs in my mind allows self-loops but doesn't force them. The graph with a single vertex and a single edge is a terminal object.</p>",
        "id": 208459384,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1598743978
    },
    {
        "content": "<p>But I want to express the property \"G is not 3-colorable\" as \"G does not have a homomorphism to K_3\", so I don't want K_3 to be pointed (where by \"pointed\" i mean \"have a map from the terminal object\", idk if that is a standard terminology)</p>",
        "id": 208459394,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1598744016
    },
    {
        "content": "<p>Yeah there's sometimes friction between the 'natural' category and the one with lots of good categorical properties</p>",
        "id": 208459649,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1598744498
    },
    {
        "content": "<p>Hope I didn't miss anything earlier about this - is there a reason why we're not defining things in a way similar to monoids, e.g. having <code>simple_graph</code> be a class and having bundled <code>structure graph_hom</code>? I'm running into some issues with trying to define the category of simple graphs cause I can't seem to bundle things in a way where we can derive stuff.</p>",
        "id": 208463627,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1598752414
    },
    {
        "content": "<p>So the basic idea is that we sometimes want to study multiple graphs on the same type</p>",
        "id": 208463670,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1598752463
    },
    {
        "content": "<p>And so we can’t just have a type with an instance on it, because multiple non-equal instances are hard to juggle between</p>",
        "id": 208463681,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1598752504
    },
    {
        "content": "<p>But somehow they pulled that off with <code>topological_space</code>, where sometimes it’s an instance, and sometimes it’s not</p>",
        "id": 208463688,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1598752548
    },
    {
        "content": "<p>Ohhhh okay gotcha. Sorry, I think I did actually have that conversation with someone and forgot about it</p>",
        "id": 208463691,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1598752552
    },
    {
        "content": "<p>We should probably study the topology library and see if we maybe could get away with graph instances sometimes after all</p>",
        "id": 208463743,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1598752644
    },
    {
        "content": "<p>I think it might be worth looking at options which don't use <code>bundled</code> then because it's designed for when the structure is a typeclass</p>",
        "id": 208464188,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1598753464
    },
    {
        "content": "<p>There's nothing that says the class has to be associated to a type, by the way -- it's just that most algebraic objects tend to be referred to by their carrier type.  You can associate it to the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi><mo>→</mo><mi>V</mi><mo>→</mo><mrow><mi mathvariant=\"normal\">P</mi><mi mathvariant=\"normal\">r</mi><mi mathvariant=\"normal\">o</mi><mi mathvariant=\"normal\">p</mi></mrow></mrow><annotation encoding=\"application/x-tex\">V \\to V \\to \\mathrm{Prop}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8777699999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">P</span><span class=\"mord mathrm\">r</span><span class=\"mord mathrm\">o</span><span class=\"mord mathrm\">p</span></span></span></span></span> relation if you wanted.  (See the graph defs thread from today.)  There is a very strong case to be made the adjacency relation <em>is</em> the graph.</p>\n<p>I think with topological spaces, most of the time the underlying set has a natural topology, so it still makes sense for a typeclass even if you need the occasional escape hatch.  I don't think anyone ever refers to the vertex set of a graph and assumes it has an associated graph structure.</p>\n<p>But, if you insist on typeclasses on the vertex type, the trick you can do is something like this:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"kn\">irreducible</span><span class=\"o\">]</span> <span class=\"n\">def</span> <span class=\"n\">complete_graph</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">V</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"o\">(</span><span class=\"n\">complete_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</code></pre></div>\n\n\n<p>but then you'd have to deal with the fact that the adjacency relation is defined on <code>complete_graph V</code> rather than <code>V</code> itself.</p>",
        "id": 208465388,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1598756039
    },
    {
        "content": "<p>Given what <span class=\"user-mention\" data-user-id=\"246273\">@Bhavik Mehta</span> pointed out on ncatlab, maybe this is a reasonable definition of the category?  Regarding what <span class=\"user-mention\" data-user-id=\"252300\">@Jalex Stark</span> was saying about colorability, it seems like you can define the notion of local injectivity (a function is locally injective if whenever f(v) = f(w), then v is not adjacent to w), and then a proper coloring is a locally injective graph homomorphism to a complete graph.</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">category_theory</span><span class=\"bp\">.</span><span class=\"n\">category</span>\n<span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">category_theory</span>\n\n<span class=\"n\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">w</span>\n\n<span class=\"kn\">structure</span> <span class=\"n\">simple_graph</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">adj&#39;</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">symm&#39;</span> <span class=\"o\">:</span> <span class=\"n\">symmetric</span> <span class=\"n\">adj&#39;</span> <span class=\"bp\">.</span> <span class=\"n\">obviously</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">refl&#39;</span> <span class=\"o\">:</span> <span class=\"n\">reflexive</span> <span class=\"n\">adj&#39;</span> <span class=\"bp\">.</span> <span class=\"n\">obviously</span><span class=\"o\">)</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">simple_graph</span>\n\n<span class=\"kn\">abbreviation</span> <span class=\"n\">adj</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}}</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">adj&#39;</span> <span class=\"n\">u</span> <span class=\"n\">v</span>\n\n<span class=\"kn\">infix</span> <span class=\"bp\">~</span> <span class=\"o\">:=</span> <span class=\"n\">adj</span>\n<span class=\"c1\">-- or infix ` ~g ` : 40 := adj</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">simple_graph</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">ext</span><span class=\"o\">]</span>\n<span class=\"kn\">structure</span> <span class=\"n\">hom</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">})</span> <span class=\"o\">(</span><span class=\"n\">G&#39;</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">})</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">to_fun</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">G&#39;</span><span class=\"bp\">.</span><span class=\"n\">V</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">map_adj</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">⦃</span><span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">V</span><span class=\"o\">⦄,</span> <span class=\"n\">v</span> <span class=\"bp\">~</span> <span class=\"n\">w</span> <span class=\"bp\">→</span> <span class=\"n\">to_fun</span> <span class=\"n\">v</span> <span class=\"bp\">~</span> <span class=\"n\">to_fun</span> <span class=\"n\">w</span><span class=\"o\">)</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">})</span> <span class=\"o\">(</span><span class=\"n\">G&#39;</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">})</span> <span class=\"o\">:</span> <span class=\"n\">has_coe_to_fun</span> <span class=\"o\">(</span><span class=\"n\">hom</span> <span class=\"n\">G</span> <span class=\"n\">G&#39;</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"bp\">⟨_</span><span class=\"o\">,</span> <span class=\"n\">hom</span><span class=\"bp\">.</span><span class=\"n\">to_fun</span><span class=\"bp\">⟩</span>\n\n<span class=\"n\">def</span> <span class=\"n\">hom</span><span class=\"bp\">.</span><span class=\"n\">id</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">})</span> <span class=\"o\">:</span> <span class=\"n\">hom</span> <span class=\"n\">G</span> <span class=\"n\">G</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"n\">id</span><span class=\"o\">,</span>\n  <span class=\"n\">map_adj</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">tidy</span> <span class=\"o\">}</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">hom</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}}</span> <span class=\"o\">{</span><span class=\"n\">G&#39;</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}}</span> <span class=\"o\">{</span><span class=\"n\">G&#39;&#39;</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">w</span><span class=\"o\">}}</span>\n\n<span class=\"n\">def</span> <span class=\"n\">hom</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">hom</span> <span class=\"n\">G</span> <span class=\"n\">G&#39;</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f&#39;</span> <span class=\"o\">:</span> <span class=\"n\">hom</span> <span class=\"n\">G&#39;</span> <span class=\"n\">G&#39;&#39;</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">hom</span> <span class=\"n\">G</span> <span class=\"n\">G&#39;&#39;</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"err\">⇑</span><span class=\"n\">f&#39;</span> <span class=\"err\">∘</span> <span class=\"err\">⇑</span><span class=\"n\">f</span><span class=\"o\">,</span>\n  <span class=\"n\">map_adj</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">repeat</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">function</span><span class=\"bp\">.</span><span class=\"n\">comp_app</span> <span class=\"o\">},</span> <span class=\"n\">exact</span> <span class=\"n\">f&#39;</span><span class=\"bp\">.</span><span class=\"n\">map_adj</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">map_adj</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">}</span> <span class=\"o\">}</span>\n\n<span class=\"n\">def</span> <span class=\"n\">hom</span><span class=\"bp\">.</span><span class=\"n\">locally_injective</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">hom</span> <span class=\"n\">G</span> <span class=\"n\">G&#39;</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"bp\">∀</span> <span class=\"o\">⦃</span><span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">V</span><span class=\"o\">⦄,</span> <span class=\"n\">f</span> <span class=\"n\">v</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">w</span> <span class=\"bp\">→</span> <span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"bp\">~</span> <span class=\"n\">w</span><span class=\"o\">)</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">hom</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_hom</span> <span class=\"o\">(</span><span class=\"n\">simple_graph</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">})</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">hom</span> <span class=\"o\">:=</span> <span class=\"n\">hom</span> <span class=\"o\">}</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">category_struct</span> <span class=\"o\">(</span><span class=\"n\">simple_graph</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">})</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">id</span> <span class=\"o\">:=</span> <span class=\"n\">hom</span><span class=\"bp\">.</span><span class=\"n\">id</span><span class=\"o\">,</span>\n  <span class=\"n\">comp</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">hom</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"o\">}</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">category</span> <span class=\"o\">(</span><span class=\"n\">simple_graph</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">})</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"o\">}</span>\n\n<span class=\"n\">def</span> <span class=\"n\">complete_graph</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">V</span> <span class=\"o\">:=</span> <span class=\"n\">V</span><span class=\"o\">,</span>\n  <span class=\"n\">adj&#39;</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"n\">true</span> <span class=\"o\">}</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">-</span>\n<span class=\"cm\">A coloring of the graph G by colors from α.</span>\n<span class=\"cm\">-/</span>\n<span class=\"kn\">structure</span> <span class=\"n\">coloring</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">})</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">hom</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"n\">complete_graph</span> <span class=\"n\">α</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">proper</span> <span class=\"o\">:</span> <span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">locally_injective</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 208467935,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1598761732
    },
    {
        "content": "<p>I tried being a little careful about universes, allowing a homomorphism to go between graphs in different universes.  The category itself only has graphs all in the same universe.</p>",
        "id": 208467984,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1598761804
    },
    {
        "content": "<p>Anyway, this category supports homomorphisms to edge contractions, which is kind of nice.</p>",
        "id": 208468002,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1598761906
    },
    {
        "content": "<p>(For subgraphs, you could define a category of subgraphs for each graph (morphisms are the poset of inclusions), then for each morphism in the category get an induced functor between subgraph categories.  There'd also be the inclusion functor from a subgraph category back to the graph category, each morphism in the image being monic.)</p>",
        "id": 208468103,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1598762105
    },
    {
        "content": "<p>Oh, I made a mistake with the definition of locally injective, and probably other things.  I'm not used to the adjacency relation being reflexive!</p>\n<p>One thing to remember is that you'd need the definition for <code>neighbor_set</code> to account for reflexivity:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}}</span>\n\n<span class=\"n\">def</span> <span class=\"n\">neighbor_set</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">V</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">V</span> <span class=\"bp\">|</span> <span class=\"n\">v</span> <span class=\"bp\">~</span> <span class=\"n\">w</span> <span class=\"bp\">∧</span> <span class=\"n\">v</span> <span class=\"bp\">≠</span> <span class=\"n\">w</span><span class=\"o\">}</span>\n\n<span class=\"n\">def</span> <span class=\"n\">closed_neighbor_set</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">V</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">V</span> <span class=\"bp\">|</span> <span class=\"n\">v</span> <span class=\"bp\">~</span> <span class=\"n\">w</span><span class=\"o\">}</span>\n</code></pre></div>",
        "id": 208468231,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1598762360
    },
    {
        "content": "<p>Another option is to define graphs as irreflexive symmetric relations then define homomorphisms in terms of the reflexive closure of the relation:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">category_theory</span><span class=\"bp\">.</span><span class=\"n\">category</span>\n<span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">category_theory</span>\n\n<span class=\"n\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">w</span>\n\n<span class=\"kn\">structure</span> <span class=\"n\">simple_graph</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">adj&#39;</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">symm&#39;</span> <span class=\"o\">:</span> <span class=\"n\">symmetric</span> <span class=\"n\">adj&#39;</span> <span class=\"bp\">.</span> <span class=\"n\">obviously</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">irrefl&#39;</span> <span class=\"o\">:</span> <span class=\"n\">irreflexive</span> <span class=\"n\">adj&#39;</span> <span class=\"bp\">.</span> <span class=\"n\">obviously</span><span class=\"o\">)</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">simple_graph</span>\n\n<span class=\"kn\">abbreviation</span> <span class=\"n\">adj</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}}</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">adj&#39;</span> <span class=\"n\">u</span> <span class=\"n\">v</span>\n\n<span class=\"kn\">infix</span> <span class=\"bp\">~</span> <span class=\"o\">:=</span> <span class=\"n\">adj</span>\n<span class=\"c1\">-- or infix ` ~g ` : 40 := adj</span>\n\n<span class=\"kn\">abbreviation</span> <span class=\"n\">rel</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">})</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"n\">u</span> <span class=\"bp\">~</span> <span class=\"n\">v</span> <span class=\"bp\">∨</span> <span class=\"n\">u</span> <span class=\"bp\">=</span> <span class=\"n\">v</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}}</span>\n\n<span class=\"n\">def</span> <span class=\"n\">neighbor_set</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">V</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">V</span> <span class=\"bp\">|</span> <span class=\"n\">v</span> <span class=\"bp\">~</span> <span class=\"n\">w</span><span class=\"o\">}</span>\n\n<span class=\"n\">def</span> <span class=\"n\">closed_neighbor_set</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">V</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">V</span> <span class=\"bp\">|</span> <span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">rel</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">}</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">simple_graph</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">ext</span><span class=\"o\">]</span>\n<span class=\"kn\">structure</span> <span class=\"n\">hom</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">})</span> <span class=\"o\">(</span><span class=\"n\">G&#39;</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">})</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">to_fun</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">G&#39;</span><span class=\"bp\">.</span><span class=\"n\">V</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">map_adj</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">⦃</span><span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">V</span><span class=\"o\">⦄,</span> <span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">rel</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"bp\">→</span> <span class=\"n\">G&#39;</span><span class=\"bp\">.</span><span class=\"n\">rel</span> <span class=\"o\">(</span><span class=\"n\">to_fun</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">to_fun</span> <span class=\"n\">w</span><span class=\"o\">))</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">})</span> <span class=\"o\">(</span><span class=\"n\">G&#39;</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">})</span> <span class=\"o\">:</span> <span class=\"n\">has_coe_to_fun</span> <span class=\"o\">(</span><span class=\"n\">hom</span> <span class=\"n\">G</span> <span class=\"n\">G&#39;</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"bp\">⟨_</span><span class=\"o\">,</span> <span class=\"n\">hom</span><span class=\"bp\">.</span><span class=\"n\">to_fun</span><span class=\"bp\">⟩</span>\n\n<span class=\"n\">def</span> <span class=\"n\">hom</span><span class=\"bp\">.</span><span class=\"n\">id</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">})</span> <span class=\"o\">:</span> <span class=\"n\">hom</span> <span class=\"n\">G</span> <span class=\"n\">G</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"n\">id</span><span class=\"o\">,</span>\n  <span class=\"n\">map_adj</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">tidy</span> <span class=\"o\">}</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">hom</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}}</span> <span class=\"o\">{</span><span class=\"n\">G&#39;</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}}</span> <span class=\"o\">{</span><span class=\"n\">G&#39;&#39;</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">w</span><span class=\"o\">}}</span>\n\n<span class=\"n\">def</span> <span class=\"n\">hom</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">hom</span> <span class=\"n\">G</span> <span class=\"n\">G&#39;</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f&#39;</span> <span class=\"o\">:</span> <span class=\"n\">hom</span> <span class=\"n\">G&#39;</span> <span class=\"n\">G&#39;&#39;</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">hom</span> <span class=\"n\">G</span> <span class=\"n\">G&#39;&#39;</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"err\">⇑</span><span class=\"n\">f&#39;</span> <span class=\"err\">∘</span> <span class=\"err\">⇑</span><span class=\"n\">f</span><span class=\"o\">,</span>\n  <span class=\"n\">map_adj</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">repeat</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">function</span><span class=\"bp\">.</span><span class=\"n\">comp_app</span> <span class=\"o\">},</span> <span class=\"n\">exact</span> <span class=\"n\">f&#39;</span><span class=\"bp\">.</span><span class=\"n\">map_adj</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">map_adj</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">}</span> <span class=\"o\">}</span>\n\n<span class=\"n\">def</span> <span class=\"n\">hom</span><span class=\"bp\">.</span><span class=\"n\">locally_injective</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">hom</span> <span class=\"n\">G</span> <span class=\"n\">G&#39;</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"bp\">∀</span> <span class=\"o\">⦃</span><span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">V</span><span class=\"o\">⦄,</span> <span class=\"n\">f</span> <span class=\"n\">v</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">w</span> <span class=\"bp\">→</span> <span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"bp\">~</span> <span class=\"n\">w</span><span class=\"o\">)</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">hom</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_hom</span> <span class=\"o\">(</span><span class=\"n\">simple_graph</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">})</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">hom</span> <span class=\"o\">:=</span> <span class=\"n\">hom</span> <span class=\"o\">}</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">category_struct</span> <span class=\"o\">(</span><span class=\"n\">simple_graph</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">})</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">id</span> <span class=\"o\">:=</span> <span class=\"n\">hom</span><span class=\"bp\">.</span><span class=\"n\">id</span><span class=\"o\">,</span>\n  <span class=\"n\">comp</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">hom</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"o\">}</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">category</span> <span class=\"o\">(</span><span class=\"n\">simple_graph</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">})</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"o\">}</span>\n\n<span class=\"n\">def</span> <span class=\"n\">complete_graph</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">V</span> <span class=\"o\">:=</span> <span class=\"n\">V</span><span class=\"o\">,</span>\n  <span class=\"n\">adj&#39;</span> <span class=\"o\">:=</span> <span class=\"n\">ne</span> <span class=\"o\">}</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">-</span>\n<span class=\"cm\">A coloring of the graph G by colors from α.</span>\n<span class=\"cm\">-/</span>\n<span class=\"kn\">structure</span> <span class=\"n\">coloring</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">})</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">hom</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"n\">complete_graph</span> <span class=\"n\">α</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">proper</span> <span class=\"o\">:</span> <span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">locally_injective</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 208468818,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1598763569
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/252551-graph-theory/topic/category.20of.20graphs/near/208468103\">said</a>:</p>\n<blockquote>\n<p>(For subgraphs, you could define a category of subgraphs for each graph (morphisms are the poset of inclusions), then for each morphism in the category get an induced functor between subgraph categories.  There'd also be the inclusion functor from a subgraph category back to the graph category, each morphism in the image being monic.)</p>\n</blockquote>\n<p>I'd hope also that the standard subobject lattice (as a poset) in the category would be the same as the poset of subgraphs as well, and the subobject lattice of an object in a category should be coming to mathlib in the next few days</p>",
        "id": 208485409,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1598794340
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/252551-graph-theory/topic/category.20of.20graphs/near/208465388\">said</a>:</p>\n<blockquote>\n<p>There's nothing that says the class has to be associated to a type, by the way -- it's just that most algebraic objects tend to be referred to by their carrier type.  You can associate it to the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi><mo>→</mo><mi>V</mi><mo>→</mo><mrow><mi mathvariant=\"normal\">P</mi><mi mathvariant=\"normal\">r</mi><mi mathvariant=\"normal\">o</mi><mi mathvariant=\"normal\">p</mi></mrow></mrow><annotation encoding=\"application/x-tex\">V \\to V \\to \\mathrm{Prop}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8777699999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">P</span><span class=\"mord mathrm\">r</span><span class=\"mord mathrm\">o</span><span class=\"mord mathrm\">p</span></span></span></span></span> relation if you wanted.  (See the graph defs thread from today.)  There is a very strong case to be made the adjacency relation <em>is</em> the graph.</p>\n<p>I think with topological spaces, most of the time the underlying set has a natural topology, so it still makes sense for a typeclass even if you need the occasional escape hatch.  I don't think anyone ever refers to the vertex set of a graph and assumes it has an associated graph structure.</p>\n<p>But, if you insist on typeclasses on the vertex type, the trick you can do is something like this:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"kn\">irreducible</span><span class=\"o\">]</span> <span class=\"n\">def</span> <span class=\"n\">complete_graph</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">V</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"o\">(</span><span class=\"n\">complete_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</code></pre></div>\n\n\n<p>but then you'd have to deal with the fact that the adjacency relation is defined on <code>complete_graph V</code> rather than <code>V</code> itself.</p>\n</blockquote>\n<p>Yeah, I don't think in this context it's a great idea to have typeclasses on the vertex type, which I think is an argument against using the <code>bundled</code> API rather than an argument for a different def of graphs or anything like that - the bundled category design is intended for algebraic structures like you mention, which are set up in a different way to this</p>",
        "id": 208485454,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1598794424
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"252300\">Jalex Stark</span> <a href=\"#narrow/stream/252551-graph-theory/topic/category.20of.20graphs/near/208459394\">said</a>:</p>\n<blockquote>\n<p>But I want to express the property \"G is not 3-colorable\" as \"G does not have a homomorphism to K_3\", so I don't want K_3 to be pointed (where by \"pointed\" i mean \"have a map from the terminal object\", idk if that is a standard terminology)</p>\n</blockquote>\n<p>if G and H have no points, then there's a natural bijection between between points of the exponential object <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>G</mi><mi>H</mi></msup></mrow><annotation encoding=\"application/x-tex\"> G^H </annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8413309999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">G</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413309999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.08125em;\">H</span></span></span></span></span></span></span></span></span></span></span> and actual morphisms <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>H</mi><mo>→</mo><mi>G</mi></mrow><annotation encoding=\"application/x-tex\"> H \\to G </annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span></p>",
        "id": 208577865,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1598889756
    },
    {
        "content": "<p>Regarding that ncatlab post <span class=\"user-mention\" data-user-id=\"246273\">@Bhavik Mehta</span> pointed out, it's worth knowing that this is the 1-dimensional version of the <a href=\"https://ncatlab.org/nlab/show/simplicial+complex\">category of simplicial complexes</a>.  A map of simplicial complexes is a function on vertex sets that sends simplices to simplices, but these simplices might be collapsed in different ways.  For edges (1-simplices), they can either be sent to other edges or collapsed to a vertex (a 0-simplex).</p>\n<p>Thinking forward to graphs as being 1-skeleta of arbitrary simplicial complexes, it is probably worth defining homomorphisms this way.  (Plus you get that nice characterization of graph minors as being subquotients.)</p>",
        "id": 208605557,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1598902679
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"302826\">Aaron Anderson</span> <a href=\"#narrow/stream/252551-graph-theory/topic/category.20of.20graphs/near/208456856\">said</a>:</p>\n<blockquote>\n<p>Yeah, I’d be in favor of having bundled monos and regular monos, but I prefer the regular monos get the name and symbol of embeddings.</p>\n</blockquote>\n<p>Regarding this, I've created a topic about (regular) monomorphisms: <a href=\"#narrow/stream/116395-maths/topic/embeddings.20and.20hook.20arrow.20notation.3A.20%28regular%29.20monomorphisms\">https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/embeddings.20and.20hook.20arrow.20notation.3A.20%28regular%29.20monomorphisms</a></p>\n<p>It would be nice to match the way notation works in other parts of mathlib for this, if there's any precedent.</p>",
        "id": 208605966,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1598902877
    },
    {
        "content": "<p>It might make sense using unadorned hook arrows for embeddings, but, for example, Lee's smooth manifolds book uses the hook arrow for smooth inclusion maps, and uses the word \"embedding\" as a modifier.</p>",
        "id": 208606740,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1598903331
    },
    {
        "content": "<p>I've pulled the graph maps out of my PR so we can keep discussing here.</p>",
        "id": 208607110,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1598903543
    },
    {
        "content": "<p>It seems that for topological purposes, it may just be better if we take the definition of a graph to be reflexive, instead of irreflexive, but for combinatorial purposes, we probably still want the usual edge-number formulas and stuff to be true.</p>",
        "id": 208607368,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1598903687
    },
    {
        "content": "<p>However, for those topological purposes, we'd probably rather be thinking about simplicial complexes anyway, and sometimes requiring they be only have 0 and 1 dimensional simplices.</p>",
        "id": 208607517,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1598903765
    },
    {
        "content": "<p>Is perhaps the solution to have the current irreflexive definition of graph, with its current definition of hom, as one category, and when we want to talk about that graph topologically, we use a function/functor from graphs to simplicial complexes, where there are a few more maps?</p>",
        "id": 208607653,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1598903857
    },
    {
        "content": "<p>I tried out the reflexive version, and I kept getting confused because I kept forgetting the relation no longer corresponded to edges...  This only really helps make the definitions of homomorphisms easier -- for this category it might be better to define it in terms of the reflexive closure of the relation.</p>",
        "id": 208607796,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1598903913
    },
    {
        "content": "<p>Though, it might be better still to define it like</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">structure</span> <span class=\"n\">hom</span> <span class=\"n\">G</span> <span class=\"n\">G&#39;</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">to_fun</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"n\">G</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">V</span> <span class=\"n\">G&#39;</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">map_prop</span> <span class=\"o\">:</span> <span class=\"k\">forall</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"n\">G</span><span class=\"o\">),</span> <span class=\"n\">v</span> <span class=\"bp\">~</span> <span class=\"n\">w</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">v</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">w</span> <span class=\"bp\">\\/</span> <span class=\"n\">f</span> <span class=\"n\">v</span> <span class=\"bp\">~</span> <span class=\"n\">f</span> <span class=\"n\">w</span><span class=\"o\">))</span>\n</code></pre></div>\n\n\n<p>since having the reflexive closure on the L.H.S. of the implication is unnecessary.  This matches the simplicial complex map definition.</p>",
        "id": 208608048,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1598904022
    },
    {
        "content": "<p>The fact that minors are subquotients using this <code>hom</code> definition is compelling, I think</p>",
        "id": 208608366,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1598904184
    },
    {
        "content": "<p>Do you know if there are any reasons to use the <code>rel_hom</code>-with-irreflexive-adjacency definition?</p>",
        "id": 208608596,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1598904310
    },
    {
        "content": "<p>Mostly for studying colorability</p>",
        "id": 208608937,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1598904514
    },
    {
        "content": "<p>that's really the only context where I've thought much about graph homomorphisms</p>",
        "id": 208608963,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1598904531
    },
    {
        "content": "<p>and tbh I think pretty much every definition we mention is going to be implemented eventually, it's just an issue of coming up for a name for each of the 18 categories we're gonna have</p>",
        "id": 208609035,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1598904573
    },
    {
        "content": "<p>locally injective homomorphisms cover that case, at least</p>",
        "id": 208609078,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1598904601
    },
    {
        "content": "<p>I haven't been able to determine whether that counts as an immersion or not</p>",
        "id": 208609148,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1598904629
    },
    {
        "content": "<p>What do you mean by locally injective?</p>",
        "id": 208609170,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1598904649
    },
    {
        "content": "<p>I mean</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">def</span> <span class=\"n\">locally_injective</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">hom</span> <span class=\"n\">G</span> <span class=\"n\">G&#39;</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">forall</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"n\">G</span><span class=\"o\">),</span> <span class=\"n\">v</span> <span class=\"bp\">~</span> <span class=\"n\">w</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">f</span> <span class=\"n\">v</span> <span class=\"bp\">!=</span> <span class=\"n\">f</span> <span class=\"n\">w</span>\n</code></pre></div>",
        "id": 208609251,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1598904703
    },
    {
        "content": "<p>it seems somewhat useful in other contexts, too, like for walks of length n.  It's a locally injective homomorphism of a path graph with n edges</p>",
        "id": 208609323,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1598904739
    },
    {
        "content": "<p>But anyway, I think I'd rather have <code>irrefl_hom</code> and <code>refl_hom</code>, with better names, and then have a theorem that says that a <code>refl_hom</code> is an <code>irrefl_hom</code> iff it's locally injective that have the definition of <code>irrefl_hom</code> be a function with the property <code>v ~ w -&gt; (f v = f w \\/ f v ~ f w) /\\ f v != f w</code></p>",
        "id": 208609472,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1598904827
    },
    {
        "content": "<p>As I view <code>irrefl_hom</code> as more basic, I'm inclined to call that just <code>hom</code> with the nomenclature <code>-&gt;g</code>, and call the <code>refl_hom</code> something like <code>top_hom</code> or <code>continuous</code> or something, with a different nomenclature, but I really don't care what the nomenclature is at the end of the day.</p>",
        "id": 208609930,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1598905045
    },
    {
        "content": "<p>Do you view it to be more basic because it's slightly easier to define?  Maybe it's because you're thinking of it as being a homomorphism of models of graphs?</p>\n<p>I'm having a hard time seeing it being that useful for anything other than graph coloring, and even for graph coloring I'd be more inclined to define graph colorings as their own thing since it's just a function that sends adjacent vertices to non-equal elements.</p>",
        "id": 208610284,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1598905214
    },
    {
        "content": "<p>It seems like a lemma that graph colorings correspond to (locally injective) homomorphisms to complete graphs</p>",
        "id": 208610394,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1598905279
    },
    {
        "content": "<p>I view it as more basic because</p>\n<ul>\n<li>I'm used to model theory</li>\n<li>For multigraphs, it coincides with a pair, consisting of a vertex map and an edge map, which agree</li>\n<li>The only applications that I personally have thought about in any depth are coloring and walks, and those use it</li>\n<li>I've looked up a few internet sources (although none seem authoritative), and all of them use the irreflexive definition, except for nLab, mentions the irreflexive definition as standard before deciding they'd rather study the reflexive version</li>\n</ul>",
        "id": 208611020,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1598905643
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"252300\">@Jalex Stark</span>, I have it in my head that you've spent some time getting comfortable with graph homomorphisms. Do you have a good source that could help us?</p>",
        "id": 208611142,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1598905703
    },
    {
        "content": "<p>I think I spent a long time with uh chapter 8? Of godsil's algebraic graph theory</p>",
        "id": 208611249,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1598905773
    },
    {
        "content": "<p>And asked a lot of dumb questions to william ballinger</p>",
        "id": 208611507,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1598905919
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"252300\">Jalex Stark</span> <a href=\"#narrow/stream/252551-graph-theory/topic/category.20of.20graphs/near/208611507\">said</a>:</p>\n<blockquote>\n<p>And asked a lot of dumb questions to william ballinger</p>\n</blockquote>\n<p>Really the best way to learn any subject</p>",
        "id": 208612884,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1598906760
    },
    {
        "content": "<p>Godsil also uses the irreflexive definition. I think it's standard for combinatorial settings, where the reflexive definition is standard for topological settings, so I really think those are not so much the \"homomorphisms\" of graph theory as the \"continuous maps\" of graph theory</p>",
        "id": 208613011,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1598906832
    },
    {
        "content": "<p>Ok, thanks for expanding on your inclinations.</p>\n<p>Re model theory: it might be that the definition of a simple graph we have matches intuition but is the wrong structure, so the notion of a homomorphism might need to be non-standard.</p>\n<p>Re multigraphs: there's a case to be made that they should be set up to allow edge contractions, but I don't have any idea how to do that cleanly. (I know how to do it, but no one, including me, would like using it.)</p>\n<p>If I'm not mistaken, while graph minors are subquotients in the ncatlab category, they are also quotients of subobjects in the irrefl category.  Edge contractions could correspond to a span of maps, rather than being a map itself.</p>\n<p>Re walks: I see value in making a length-n walk be exactly a homomorphism from an n-edge path, which unfortunately fails with this ncatlab definition of homomorphism.  (But for colorings, I'm not convinced homomorphisms to complete graphs are the basic definition.  That's not to say I don't see the utility; just that defining homomorphisms only for the sake of colorings doesn't seem right)</p>\n<p>I'm mostly undecided one way or the other at this point.  I think if we can verify that graph minors are quotients of subobjects in the irrefl category (pretty sure it's true), then I'm satisfied.</p>",
        "id": 208613059,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1598906870
    },
    {
        "content": "<p>Also, if we ever want to define graphs that have loops as actual information, and talk about homomorphisms in their context, I think the irreflexive one makes a lot more sense</p>",
        "id": 208613168,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1598906919
    },
    {
        "content": "<p>I don't think we have to really pick one, we just call one the category of graphs with homomorphisms, and one the category of graphs with continuous maps.</p>",
        "id": 208613234,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1598906959
    },
    {
        "content": "<p>It matters for which gets the simpler notation</p>",
        "id": 208613255,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1598906974
    },
    {
        "content": "<p>And also, if it turned out we might only use one of them, that'd keep maintenance down</p>",
        "id": 208613361,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1598907018
    },
    {
        "content": "<p>We could define them both with <code>rel_hom</code>, that might keep maintenance down... but the only way to find out if we only want to use one of them is to start using them</p>",
        "id": 208613770,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1598907263
    },
    {
        "content": "<p>Is the irrefl category an actual separate category, or is it merely the ncatlab category with the additional constraint that maps are locally injective?</p>",
        "id": 208613916,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1598907352
    },
    {
        "content": "<p>It's true, we'd need to use both to really know.</p>",
        "id": 208614014,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1598907397
    },
    {
        "content": "<p>It is indeed a subcategory of the refl category. I've also yet to see a source that defines graph homomorphisms as the refl definition without first pointing out that there's a choice.</p>",
        "id": 208614054,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1598907422
    },
    {
        "content": "<p>Yeah, I meant that as a design question.  If one is a subcategory of the other, is it worth having both as separate definitions?  I imagine many homomorphisms will be injective, where the distinction doesn't matter.</p>",
        "id": 208614468,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1598907618
    },
    {
        "content": "<p>(I'm pretty sure I was wrong about graph minors being the same as quotients of subobjects.  They are quotients of subobjects, but not conversely.)</p>",
        "id": 208614585,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1598907680
    },
    {
        "content": "<p>Anyway, if there is a precedent to studying the category from the irreflexive relation, then it seems reasonable just defining homomorphisms that way.  If anyone proves an excluded minors theorem at some point, this could be revisited.</p>",
        "id": 208614735,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1598907746
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/252551-graph-theory/topic/category.20of.20graphs/near/208614468\">said</a>:</p>\n<blockquote>\n<p>Yeah, I meant that as a design question.  If one is a subcategory of the other, is it worth having both as separate definitions?  I imagine many homomorphisms will be injective, where the distinction doesn't matter.</p>\n</blockquote>\n<p>Well, the continuous definition will be in mathlib sooner or later, as a full subcategory of simplicial sets</p>",
        "id": 208614972,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1598907861
    }
]
[
    {
        "content": "<p>I pushed an error fix that Kevin helped me out with</p>",
        "id": 207904497,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1598307872
    },
    {
        "content": "<blockquote>\n<p>Basically just got rid of the problem in <code>degree_le</code> where Lean didn't know why we were allowed to compare the degrees because it didn't know <code>degree (G'.in_subgraph hv)</code> is a <code>fintype</code></p>\n</blockquote>",
        "id": 207904514,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1598307886
    },
    {
        "content": "<p>just kidding, somehow there's still an error somewhere</p>",
        "id": 207907075,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1598309924
    },
    {
        "content": "<p>I'm going to take a look -- I had some troubles with these instances because they caused class resolution to not terminate.  (I'm trying to get my own changes to the branch in order so I can merge yours.)</p>",
        "id": 207907302,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1598310064
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"303889\">Alena Gusakov</span> <a href=\"#narrow/stream/252551-graph-theory/topic/simple_graphs2/near/207907075\">said</a>:</p>\n<blockquote>\n<p>just kidding, somehow there's still an error somewhere</p>\n</blockquote>\n<p>These instances are tricky, and I've been struggling with how to define these off and on for a while, but they might finally now be OK.  It turns out you can't actually have them as instances because they \"introduce metavariables\", which are caused by variables on the LHS of the colon that cannot be totally inferred by either class resolution or the usual implicit argument elaboration.</p>\n<p>Anyway, <code>degree_le</code> is now a lemma (with proof!), and it makes use of some new lemmas involving graph embeddings.  The idea is that it's not hard to prove that the neighbor set of a vertex in a subgraph embeds in the neighbor set of that vertex in a supergraph, and then <code>fintype.card_le_of_injective</code> does the rest.</p>\n<p>If you wanted, you could follow the same strategy with <code>embedding.map_edge_set</code> to show that the cardinality of an edge set of a subgraph is less than or equal to the cardinality of the supergraph's edge set.</p>",
        "id": 207935282,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1598343360
    },
    {
        "content": "<p>A couple of other sorry's:</p>\n<ul>\n<li><code>complete_graph_min_colors</code> is that a complete graph on <code>n</code> vertices needs at least <code>n</code> colors in a proper coloring.</li>\n<li><code>exists_path_eq_eqv_gen</code> should follow from a lemma that if there is a walk between two vertices then there is a path between them.</li>\n</ul>",
        "id": 207935495,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1598343527
    },
    {
        "content": "<p><del>it seems like there are other errors now though - namely in the proofs of all of the <code>map_edge_set</code> definitions</del> oops, restarted lean and the errors went away</p>",
        "id": 207960977,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1598361375
    },
    {
        "content": "<p>After some discussion with <span class=\"user-mention\" data-user-id=\"303889\">@Alena Gusakov</span>, the branch now has what seems to be an easier-to-work-with definition of subgraphs:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">structure</span> <span class=\"n\">subgraph</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">V&#39;</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"n\">G</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">adj&#39;</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"n\">G</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"n\">G</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">adj_sub</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">⦃</span><span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"n\">G</span><span class=\"o\">⦄,</span> <span class=\"n\">adj&#39;</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"bp\">→</span> <span class=\"n\">v</span> <span class=\"bp\">~</span><span class=\"n\">g</span> <span class=\"n\">w</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">edge_vert</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">⦃</span><span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"n\">G</span><span class=\"o\">⦄,</span> <span class=\"n\">adj&#39;</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"bp\">→</span> <span class=\"n\">v</span> <span class=\"err\">∈</span> <span class=\"n\">V&#39;</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">symm&#39;</span> <span class=\"o\">:</span> <span class=\"n\">symmetric</span> <span class=\"n\">adj&#39;</span><span class=\"o\">)</span>\n</code></pre></div>\n\n\n<p>(It has the correct extensionality property, which I had trouble getting right with this sort of formulation, that there is exactly one term per subgraph.  That's why the earlier definition used a subset of edges.)</p>\n<p>As an experiment in a technique to show two definitions are equivalent, I kept the old definition as a protected definition in the <code>simple_graph.subgraph</code> namespace:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">protected</span> <span class=\"kn\">structure</span> <span class=\"n\">of_edge_set&#39;</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">V&#39;</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"n\">G</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">edge_set&#39;</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">sym2</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"n\">G</span><span class=\"o\">)))</span>\n<span class=\"o\">(</span><span class=\"n\">edge_sub</span> <span class=\"o\">:</span> <span class=\"n\">edge_set&#39;</span> <span class=\"err\">⊆</span> <span class=\"n\">edge_set</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">has_verts</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">⦃</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">sym2</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"n\">G</span><span class=\"o\">)⦄</span> <span class=\"o\">⦃</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"n\">G</span><span class=\"o\">⦄,</span> <span class=\"n\">e</span> <span class=\"err\">∈</span> <span class=\"n\">edge_set&#39;</span> <span class=\"bp\">→</span> <span class=\"n\">v</span> <span class=\"err\">∈</span> <span class=\"n\">e</span> <span class=\"bp\">→</span> <span class=\"n\">v</span> <span class=\"err\">∈</span> <span class=\"n\">V&#39;</span><span class=\"o\">)</span>\n</code></pre></div>\n\n\n<p>Then I gave it a <code>simple_graphs</code> instance and proved two statements:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">protected</span> <span class=\"n\">def</span> <span class=\"n\">equiv_of_edge_set&#39;</span> <span class=\"o\">:</span> <span class=\"n\">subgraph</span> <span class=\"n\">G</span> <span class=\"err\">≃</span> <span class=\"n\">of_edge_set&#39;</span> <span class=\"n\">G</span>\n\n<span class=\"n\">def</span> <span class=\"n\">iso_of_edge_set&#39;</span> <span class=\"o\">(</span><span class=\"n\">G&#39;</span> <span class=\"o\">:</span> <span class=\"n\">subgraph</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">G&#39;</span> <span class=\"err\">≃</span><span class=\"n\">g</span> <span class=\"n\">subgraph</span><span class=\"bp\">.</span><span class=\"n\">equiv_of_edge_set&#39;</span> <span class=\"n\">G&#39;</span>\n</code></pre></div>\n\n\n<p>That is to say, the types are equivalent, and that equivalence carries graphs to isomorphic graphs.  (This is what I meant in the matroids topic -- matroids have multiple definitions, and this seems to be a structured way to formalize that the definitions are equivalent.)</p>",
        "id": 208053563,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1598418812
    },
    {
        "content": "<p>I've added formalizations of the first two theorems in Bollobas's book in this branch.</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"c1\">-- The type of all embedded cycles in a given graph</span>\n<span class=\"n\">def</span> <span class=\"n\">cycles</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"err\">Σ</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">//</span> <span class=\"mi\">3</span> <span class=\"bp\">≤</span> <span class=\"n\">n</span><span class=\"o\">}),</span> <span class=\"n\">cycle_graph</span> <span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"err\">↪</span><span class=\"n\">g</span> <span class=\"n\">G</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">-</span>\n<span class=\"cm\">Veblen 1912 (theorem 1 in book).  Every vertex has even degree iff there is a</span>\n<span class=\"cm\">partition of the graph into edge-disjoint cycles.</span>\n<span class=\"cm\">-/</span>\n<span class=\"kn\">theorem</span> <span class=\"n\">edge_partition_cycles</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"n\">G</span><span class=\"o\">)]</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"n\">degree</span> <span class=\"n\">v</span> <span class=\"err\">%</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">partition</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">cycles</span> <span class=\"n\">G</span><span class=\"o\">),</span>\n                                     <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">edge_set</span> <span class=\"n\">G</span><span class=\"o\">),</span> <span class=\"bp\">!∃</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">cycles</span> <span class=\"n\">G</span><span class=\"o\">),</span> <span class=\"n\">c</span> <span class=\"err\">∈</span> <span class=\"n\">partition</span> <span class=\"bp\">∧</span>\n                                       <span class=\"n\">e</span> <span class=\"err\">∈</span> <span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">image</span> <span class=\"o\">(</span><span class=\"n\">embedding</span><span class=\"bp\">.</span><span class=\"n\">map_edge_set</span> <span class=\"n\">c</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">univ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">sorry</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">-</span>\n<span class=\"cm\">Mantel 1907 (theorem 2 in book). If a graph with n vertices and m edges satisfies</span>\n<span class=\"cm\">floor(n^2 /4) &lt; m, then it contains a triangle.</span>\n<span class=\"cm\">-/</span>\n<span class=\"kn\">theorem</span> <span class=\"n\">has_triangle</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"n\">G</span><span class=\"o\">)]</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">fintype</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"n\">G</span><span class=\"o\">))</span><span class=\"bp\">^</span><span class=\"mi\">2</span> <span class=\"bp\">/</span> <span class=\"mi\">4</span> <span class=\"bp\">&lt;</span> <span class=\"o\">(</span><span class=\"n\">edge_finset</span> <span class=\"n\">G</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">nonempty</span> <span class=\"o\">(</span><span class=\"n\">cycle_graph</span> <span class=\"mi\">3</span> <span class=\"o\">(</span><span class=\"k\">by</span> <span class=\"n\">linarith</span><span class=\"o\">)</span> <span class=\"err\">↪</span><span class=\"n\">g</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">sorry</span>\n</code></pre></div>\n\n\n<p>(Proving these will take a good amount of theory building still.)</p>\n<p>For the first theorem, it's probably better to formalize cycles as being subgraphs that are isomorphic to a cycle graph, since with the current formulation every cyclic shift of a cycle is considered to be a different cycle.  It's probably also good to formalize the idea of edge-disjoint partitions by subgraphs.</p>",
        "id": 208143130,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1598473143
    },
    {
        "content": "<p>Changed it to be in terms of subgraphs that are cycles:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"c\">/-</span><span class=\"cm\">-</span>\n<span class=\"cm\">Veblen 1912 (theorem 1 in book). Every vertex has even degree iff there is a</span>\n<span class=\"cm\">partition of the graph into edge-disjoint cycles.</span>\n<span class=\"cm\">-/</span>\n<span class=\"kn\">theorem</span> <span class=\"n\">edge_partition_cycles</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"n\">G</span><span class=\"o\">)]</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"n\">degree</span> <span class=\"n\">v</span> <span class=\"err\">%</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">partition</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">subgraph</span> <span class=\"n\">G</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">G&#39;</span> <span class=\"err\">∈</span> <span class=\"n\">partition</span><span class=\"o\">,</span> <span class=\"n\">subgraph</span><span class=\"bp\">.</span><span class=\"n\">is_cycle</span> <span class=\"n\">G&#39;</span><span class=\"o\">)</span> <span class=\"bp\">∧</span>\n                                     <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"err\">∈</span> <span class=\"n\">edge_set</span> <span class=\"n\">G</span><span class=\"o\">),</span> <span class=\"bp\">!∃</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">subgraph</span> <span class=\"n\">G</span><span class=\"o\">),</span> <span class=\"n\">c</span> <span class=\"err\">∈</span> <span class=\"n\">partition</span> <span class=\"bp\">∧</span>\n                                       <span class=\"n\">e</span> <span class=\"err\">∈</span> <span class=\"n\">c</span><span class=\"bp\">.</span><span class=\"n\">edge_set&#39;</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">sorry</span>\n</code></pre></div>",
        "id": 208144703,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1598473948
    },
    {
        "content": "<p>so for the second implication here</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">lemma</span> <span class=\"n\">exists_path_eq_exists_walk</span> <span class=\"o\">:</span> <span class=\"n\">exists_path</span> <span class=\"n\">G</span> <span class=\"bp\">=</span> <span class=\"n\">exists_walk</span> <span class=\"n\">G</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">ext</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">,</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">h</span> <span class=\"k\">with</span> <span class=\"bp\">⟨</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"bp\">⟨</span><span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">hf</span><span class=\"bp\">⟩⟩</span><span class=\"o\">,</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"n\">use</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">walk</span><span class=\"o\">,</span>\n  <span class=\"n\">use</span> <span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">to_homomorphism</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">hf</span><span class=\"o\">,</span>\n\n  <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">h</span> <span class=\"k\">with</span> <span class=\"bp\">⟨</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"bp\">⟨</span><span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">hf</span><span class=\"bp\">⟩⟩</span><span class=\"o\">,</span>\n  <span class=\"n\">sorry</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n</code></pre></div>\n\n\n<p>would having <code>open_locale classical</code> and then contracting edges between repeated vertices be a good strategy? i'm kind of stumped with this one</p>",
        "id": 208494770,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1598807559
    },
    {
        "content": "<p>also, i wonder if it might be useful to define some notion of the image of a graph homomorphism (unless i'm missing something that's already defined)</p>",
        "id": 208495269,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1598808262
    },
    {
        "content": "<p>Feel free to make the lemma <code>noncomputable</code> and use the <code>classical</code> tactic for now.  (I think <code>classical</code> does the equivalent of <code>open_locale classical</code> inside a proof, but I'll have to check)</p>",
        "id": 208495361,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1598808394
    },
    {
        "content": "<p>I was imagining doing strong induction on the length of a walk.  If a walk isn't a path, then there must be a repeated vertex, and then if you cut out the portion of the walk that occurred between the two vertices, the walk length gets shorter, hence it has a corresponding path by induction</p>",
        "id": 208495395,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1598808479
    },
    {
        "content": "<p>Do you even need <code>noncomputable</code> if you're just using <code>classical</code> inside a proof of a <code>Prop</code>?</p>",
        "id": 208495440,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1598808495
    },
    {
        "content": "<p>Probably not</p>",
        "id": 208495447,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1598808521
    },
    {
        "content": "<p>also, is it possible to like, \"concatenate\" functions? like make a new function out of two that you already have</p>",
        "id": 208495563,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1598808689
    },
    {
        "content": "<p>The easiest-to-remember way is using lambda expressions</p>",
        "id": 208495649,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1598808735
    },
    {
        "content": "<p>There's a whole bunch of function combinators in the <code>function</code> namespace, too, but they don't seem to be used much</p>",
        "id": 208495663,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1598808766
    },
    {
        "content": "<p>I tried using <code>combine</code> in the definition of graph homomorphisms, but there were some type errors (I think because it involved Prop?) and I reconsidered.  It even has fancy notation: <code>(f -[h]- g) x y = h (f x y) (g x y)</code></p>",
        "id": 208495750,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1598808900
    },
    {
        "content": "<p>I don't know if <code>combine</code> is what I'm looking for - it looks like it takes functions with two arguments</p>",
        "id": 208496577,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1598809944
    },
    {
        "content": "<p>I'm currently working on the concatenation of walks definition</p>",
        "id": 208496753,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1598810252
    },
    {
        "content": "<p><code>combine</code> was just one of the many examples of combinators. i don't think it's useful for what you're doing.</p>\n<p>for walks, this is gluing walks together, right?  I'm not sure how gluing functions together works elsewhere in mathlib (how do the sheaf axioms glue functions? maybe that's to general to be useful here)</p>\n<p>(When you said \"contract\" earlier, this might be where it'd be nice to actually have a quotient construction, using the expanded notion of graph homomorphism that was in the ncatlab article)</p>",
        "id": 208497004,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1598810610
    },
    {
        "content": "<p>I think I might've found a way to do it, does this look legit?<br>\n<code>to_fun := λ x, if x ≤ n then p.1.to_fun x else q.1.to_fun x,</code></p>",
        "id": 208497211,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1598810945
    },
    {
        "content": "<p>context:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">def</span> <span class=\"n\">walk</span><span class=\"bp\">.</span><span class=\"n\">concat</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"n\">G</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">walk</span> <span class=\"n\">G</span> <span class=\"n\">n</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">walk</span> <span class=\"n\">G</span> <span class=\"n\">m</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">walk</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"n\">u</span> <span class=\"n\">w</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span> <span class=\"n\">val</span> <span class=\"o\">:=</span>\n    <span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"k\">if</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">n</span> <span class=\"k\">then</span> <span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"bp\">.</span><span class=\"n\">to_fun</span> <span class=\"n\">x</span> <span class=\"k\">else</span> <span class=\"n\">q</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"bp\">.</span><span class=\"n\">to_fun</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n    <span class=\"n\">map_adj&#39;</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span><span class=\"o\">},</span>\n  <span class=\"n\">property</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span><span class=\"o\">,</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 208497218,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1598810967
    },
    {
        "content": "<p>wait no it's not cause <code>x</code> is a vertex. I'll smooth that out I guess</p>",
        "id": 208497278,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1598811021
    },
    {
        "content": "<p>It seems like it would just be <code>to_fun := λ x, if x.1 ≤ n then p.1.to_fun x else q.1.to_fun x,</code></p>",
        "id": 208497366,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1598811137
    },
    {
        "content": "<p>I just realized that I have this partially defined in that file already, it's just too big and disorganized, sorry.  Take a look at <code>walk_join</code></p>",
        "id": 208497898,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1598811856
    },
    {
        "content": "<p>It still lacks the proof that the result is a walk</p>",
        "id": 208497923,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1598811936
    },
    {
        "content": "<p>(I'm assuming you're using <code>simple_graphs2</code> based on the <code>exists_path_eq_exists_walk</code> lemma)</p>",
        "id": 208497982,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1598812009
    },
    {
        "content": "<p>ohhh okay, ty</p>",
        "id": 208498058,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1598812162
    },
    {
        "content": "<p>we can't have paths on a single vertex right? that contradicts the definition of path</p>",
        "id": 208504753,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1598822378
    },
    {
        "content": "<p>should we have a lemma that explicitly states that?</p>",
        "id": 208504756,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1598822385
    },
    {
        "content": "<p>Are zero-length paths not ok?</p>",
        "id": 208504819,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1598822482
    },
    {
        "content": "<p>for compositions of walks, I thought those would be identity elements</p>",
        "id": 208504828,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1598822518
    },
    {
        "content": "<p>walks themselves should form a category (I forget the exact terminology, maybe a dagger category? some kind of category where objects are self-dual and morphisms have duals).  objects of the category are vertices of the graph, morphisms are walks from a vertex to another vertex, composition of walks is the concatenation of the walks, identities are the zero-length walks, and duals are parameterization reversal</p>",
        "id": 208504947,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1598822715
    },
    {
        "content": "<p>once you have all this set up, then \"there exists a morphism from x to y\" is an equivalence relation on objects of the category</p>",
        "id": 208504992,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1598822783
    },
    {
        "content": "<p>i.e., \"there exists a walk of any length from x to y\" is an equivalence relation.</p>",
        "id": 208505021,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1598822876
    },
    {
        "content": "<p>I remember writing path code that used <code>path.empty v</code> to be the empty path rooted at vertex v</p>",
        "id": 208509924,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1598831249
    },
    {
        "content": "<p>I'm having trouble working with <code>simple_graph_from_rel</code> - specifically, I can't seem to figure out how to treat the vertices in the graph as the original objects they were defined as</p>",
        "id": 208700103,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1598972656
    },
    {
        "content": "<p>One trick is you can use the <code>change</code> tactic to change the type to whatever it's actually equal to.</p>\n<p>Another is to add this missing lemma and use it to rewrite <code>V G</code>:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">lemma</span> <span class=\"n\">simple_graph_on</span><span class=\"bp\">.</span><span class=\"n\">verts_eq</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph_on</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"n\">G</span> <span class=\"bp\">=</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>\n\n\n<p>Yet another thing you could do, I think, is to use <code>erw</code> rather than <code>rw</code>.</p>",
        "id": 208718799,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1598980462
    },
    {
        "content": "<p>now i'm getting hung up on trying to coerce the numbers from <code>fin</code> to <code>nat</code></p>",
        "id": 208729735,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1598985786
    },
    {
        "content": "<p>should we add <code>nontrivial</code> to the definition of connected?</p>",
        "id": 208733260,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1598987265
    },
    {
        "content": "<p>actually wait no, i guess it's trivially true for...the trivial case</p>",
        "id": 208733360,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1598987297
    },
    {
        "content": "<p>I'm trying to prove that in a nontrivial connected graph, every vertex has degree at least one</p>",
        "id": 208733640,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1598987421
    },
    {
        "content": "<p>but it's an absolute nightmare</p>",
        "id": 208733654,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1598987426
    },
    {
        "content": "<p>I'm maybe behind the times on what definition of connected you're using, but perhaps it'd actually be easier to prove something more general: if you have a set of vertices, and no vertex in the set is adjacent to any vertex outside the set, then no vertex in the set is path-connected to any vertex outside the set</p>",
        "id": 208734303,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1598987735
    },
    {
        "content": "<p>My definition of connected is there exists a path between every vertex, but what I want to prove is that this means every vertex has at least one edge to it</p>",
        "id": 208735829,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1598988471
    },
    {
        "content": "<p>also currently having trouble proving that a subgraph of an acyclic graph is also acyclic</p>",
        "id": 208736000,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1598988573
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"303889\">Alena Gusakov</span> <a href=\"#narrow/stream/252551-graph-theory/topic/simple_graphs2/near/208736000\">said</a>:</p>\n<blockquote>\n<p>also currently having trouble proving that a subgraph of an acyclic graph is also acyclic</p>\n</blockquote>\n<p>This should be at least pretty easy if we're using an embedding or subgraph definition of acyclic</p>",
        "id": 208736186,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1598988656
    },
    {
        "content": "<p>I'm going over to <code>simple_graphs2</code> to check out what I've missed</p>",
        "id": 208736228,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1598988673
    },
    {
        "content": "<p>My current problem is when I say <code>is_acyclic (subgraph G)</code> it doesn't recognize the subgraph as a simple graph</p>",
        "id": 208736299,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1598988711
    },
    {
        "content": "<p>sorry, I should've said I'm having trouble stating it</p>",
        "id": 208736382,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1598988729
    },
    {
        "content": "<p>One note: <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span>, I know that we have good reasons to doubt whether graph homomorphisms should be modeled with <code>rel_hom</code>s, but I'm confused why <code>simple_graphs2</code> uses <code>rel_iso</code> to define isomorphisms, but doesn't use <code>rel_embedding</code> to define embeddings, when I'm pretty sure the custom structure for embeddings has the exact same information as <code>rel_embedding</code></p>",
        "id": 208737168,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1598989169
    },
    {
        "content": "<p>I was going to change it back eventually.  Your new PR wasn't there yet</p>",
        "id": 208737293,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1598989229
    },
    {
        "content": "<p>though my embedding was a mono, vs regular mono</p>",
        "id": 208737322,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1598989246
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/252551-graph-theory/topic/simple_graphs2/near/208737322\">said</a>:</p>\n<blockquote>\n<p>though my embedding was a mono, vs regular mono</p>\n</blockquote>\n<p>Ah right, sorry</p>",
        "id": 208737483,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1598989329
    },
    {
        "content": "<p>Anyway, the main advantage of a non-regular mono is that an arbitrary subgraph has an inclusion embedding</p>",
        "id": 208738387,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1598989791
    },
    {
        "content": "<p>Have we put that in lean yet?</p>",
        "id": 208738449,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1598989804
    },
    {
        "content": "<p>Because I'd imagine that's how you'd prove that a subgraph of an acyclic graph is acyclic</p>",
        "id": 208738478,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1598989820
    },
    {
        "content": "<p>or I guess you redefine/show that it's equivalent to nonexistent of a subgraph which is a cycle</p>",
        "id": 208738516,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1598989847
    },
    {
        "content": "<p>in which case you want to use transitivity of subgraph</p>",
        "id": 208738555,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1598989865
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"303889\">Alena Gusakov</span> <a href=\"#narrow/stream/252551-graph-theory/topic/simple_graphs2/near/208733640\">said</a>:</p>\n<blockquote>\n<p>I'm trying to prove that in a nontrivial connected graph, every vertex has degree at least one</p>\n</blockquote>\n<p>I think I have a sketch if you're willing to use the <code>eqv_gen</code> version, which is defined on <code>simple_graphs2</code>, but the equivalence is currently <code>sorry</code></p>",
        "id": 208740109,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1598990557
    },
    {
        "content": "<p>Say you have a set <code>S</code> of vertices. Then you define an equivalence relation (actually a <code>setoid</code>) where two vertices are equivalent iff they're both in <code>S</code> or both not in <code>S</code>.</p>",
        "id": 208740219,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1598990624
    },
    {
        "content": "<p>Then you want to use <a href=\"https://leanprover-community.github.io/mathlib_docs/data/setoid/basic.html#setoid.eqv_gen_le\">https://leanprover-community.github.io/mathlib_docs/data/setoid/basic.html#setoid.eqv_gen_le</a></p>",
        "id": 208740331,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1598990673
    },
    {
        "content": "<p>What this tells you is that if (for all <code>x y : V</code>, <code>x ~g y</code> implies <code>s.rel x y</code>), where <code>s.rel</code> is our new equivalence relation</p>",
        "id": 208740670,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1598990806
    },
    {
        "content": "<p>then <code>(eqv_gen G.adj) x y</code> implies <code>s.rel x y</code></p>",
        "id": 208740749,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1598990837
    },
    {
        "content": "<p>In other words, <code>x</code> being connected to <code>y</code> implies <code>x</code> and <code>y</code> are both in <code>S</code> or both not in <code>S</code></p>",
        "id": 208740840,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1598990868
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"302826\">Aaron Anderson</span> <a href=\"#narrow/stream/252551-graph-theory/topic/simple_graphs2/near/208738449\">said</a>:</p>\n<blockquote>\n<p>Have we put that in lean yet?</p>\n</blockquote>\n<p>This is in there:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">def</span> <span class=\"n\">subgraph</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">subgraph</span> <span class=\"n\">G</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"err\">↪</span><span class=\"n\">g</span> <span class=\"n\">y</span>\n</code></pre></div>",
        "id": 208740953,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1598990912
    },
    {
        "content": "<p>This basically proves the lemma that if a set <code>S</code> is closed under adjacency, that its vertices are not connected to outside vertices</p>",
        "id": 208740964,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1598990919
    },
    {
        "content": "<p>and to prove the exact theorem you wanted, <span class=\"user-mention\" data-user-id=\"303889\">@Alena Gusakov</span> , the only remaining step is to let <code>S</code> be a singleton. Then you find that if your singleton has degree 0, then it's closed under adjacency, so its one element is not connected to anything else, the contrapositive of what you wanted.</p>",
        "id": 208741059,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1598990975
    },
    {
        "content": "<p>Does that make sense?</p>",
        "id": 208741088,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1598990997
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/252551-graph-theory/topic/simple_graphs2/near/208740953\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"302826\">Aaron Anderson</span> <a href=\"#narrow/stream/252551-graph-theory/topic/simple_graphs2/near/208738449\">said</a>:</p>\n<blockquote>\n<p>Have we put that in lean yet?</p>\n</blockquote>\n<p>This is in there:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">def</span> <span class=\"n\">subgraph</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">subgraph</span> <span class=\"n\">G</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"err\">↪</span><span class=\"n\">g</span> <span class=\"n\">y</span>\n</code></pre></div>\n\n\n</blockquote>\n<p>Ok, so then it should be relatively easy to prove at least that if a subgraph <code>S</code> is NOT acyclic, then there is an embedding from a cycle graph into <code>S</code>, which you can then compose with <code>subgraph.map</code> to get an embedding from the cycle graph into the subgraph <code>top</code></p>",
        "id": 208741845,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1598991295
    },
    {
        "content": "<p>Then it's a matter of showing that a graph isomorphic to an acyclic graph is acyclic, which can also work by composing embeddings</p>",
        "id": 208741972,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1598991346
    },
    {
        "content": "<p>(Speaking of <code>eqv_gen G.adj</code>, one thing <span class=\"user-mention\" data-user-id=\"303889\">@Alena Gusakov</span> is helping with is showing that three different definitions of connectivity are equal: there exists a path between vertices, there exists a walk between vertices, and <code>eqv_gen G.adj</code>.)</p>",
        "id": 208749753,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1598994890
    },
    {
        "content": "<p>yeah i've been poking around those lemmas, they're also a nightmare</p>",
        "id": 208749891,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1598994951
    },
    {
        "content": "<p>I'm sure we'll figure out how to make it nice eventually <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 208749988,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1598994989
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"302826\">@Aaron Anderson</span> I was considering replacing <code>f : G ↪g G'</code> with <code>f : G →g G'</code> having some kind of <code>mono</code> instance, not sure the right name.  It's can't be the category theory one, unfortunately, for some of the usual reasons.  It would be nice if <code>injective</code> were a typeclass here, because <code>injective f</code> ends up being the correct notation, given the <code>has_coe_to_fun</code> instance for graph homomorphisms.</p>",
        "id": 208751991,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1598996137
    },
    {
        "content": "<p>I hesitate to do this, though, because <code>↪g</code> seems to have been convenient so far to mean monomorphism since it extends <code>function.embedding</code> so can find some immediate use in some cardinality arguments.  However, it seems possible to define a cast of a function with a <code>mono</code>-like instance to get a <code>function.embedding</code> as needed.</p>",
        "id": 208752408,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1598996389
    },
    {
        "content": "<p>I've reorganized the <code>simple_graphs2</code> repository in a number of ways:</p>\n<ul>\n<li>Now a simple graph is merely a term of <code>simple_graph</code>.  This is a bundled <code>simple_graph_on α</code> term, for simple graphs with vertex type <code>α</code>.</li>\n<li>To give the terms of a type the structure of a simple graph, one implements <code>has_coe_to_simple_graph</code>. This gives you access to a new coercion arrow, <code>↟</code>, which coerces graph-like things to simple graphs.  This circumvents an issue where typeclass resolution won't assert two universe metavariables are equal, so <code>has_coe</code> cannot work, but perhaps in a future version of Lean this will be resolved.  Until then, <code>↟</code> works well enough.</li>\n<li>The code has been broken up into multiple files in <a href=\"https://github.com/leanprover-community/mathlib/tree/simple_graphs2/src/combinatorics/simple_graph\">https://github.com/leanprover-community/mathlib/tree/simple_graphs2/src/combinatorics/simple_graph</a> so hopefully it's easier to follow now!</li>\n<li>Graph homomorphisms have been changed to use <code>order.rel_iso</code> exclusively.  Monomorphisms are graph homomorphisms that implement the<code>simple_graph.hom.mono</code> typeclass.</li>\n</ul>\n<p>More about <code>↟</code>: Of the many ways of organizing the simple graph library so that derived objects like subgraphs can be graphs, too, this seems to be the least-bad of all of them, and it has the benefit that, in the future, these arrows might disappear entirely.  While you might need to specify universe variables, like <code>(G : simple_graph.{u})</code>,  so far I don't think I've been required to do this and have only done so for clarity in definitions.</p>\n<p>When writing theorems about graphs in general, make sure to do it for terms of type <code>simple_graph</code>.  I think the way new types of graphs should work is, after defining the coercion, there needs to be a number of simp lemmas that specialize the generic definitions.</p>\n<p>I've also added walks to the library.  There are two ways they are represented, either as an inductive type that's essentially a list of adjacent vertices or as graph homomorphisms from path graphs into the graph.  There is a proof that these are structurally equivalent (I visited <code>heq</code> on the way, one of the circles of dependent typed hell, but that's all gone now, thankfully -- I have a special version of heterogeneous equality in the library still, which seems like it could be useful, but if it finds no use it'll be removed).  The <code>walk</code> type is essentially defining a category of walks, and it might be nice to actually give it a category structure, too.</p>\n<p><strong>Warning:</strong> not every definition makes sense and not every lemma with a <code>sorry</code> is provable -- I also, unfortunately, haven't necessarily fixed all errors.  The documentation is probably not up to date either!</p>",
        "id": 210694263,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1600650899
    },
    {
        "content": "<p>(The coercion arrow, by the way, didn't change the code much.  The previous version still was about coercions, and it was just a matter of changing who is responsible for inserting them, so to speak.)</p>",
        "id": 210694824,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1600652045
    },
    {
        "content": "<p>Wow! I guess there's a lot of shovel-ready work for filling in sorries and carving off PRs to mathlib.</p>",
        "id": 210821024,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1600739263
    },
    {
        "content": "<p>Do you think that the current definition of simple graphs in mathlib should be replaced or just given an instance of the new coercion arrow?</p>",
        "id": 210821045,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1600739284
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/252551-graph-theory/topic/simple_graphs2/near/210694263\">said</a>:</p>\n<blockquote>\n<p>When writing theorems about graphs in general, make sure to do it for terms of type <code>simple_graph</code>.  I think the way new types of graphs should work is, after defining the coercion, there needs to be a number of simp lemmas that specialize the generic definitions.</p>\n</blockquote>\n<p>I guess this implies that you think the current theorem statements should be rejiggered to be about terms of type <code>simple_graph</code>. But if we give the old simple graph type an instance of the new coercion arrow, then e.g. the proof of freek 83 in the mathlib archive won't need changes, except maybe to add some arrows?</p>",
        "id": 210821198,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1600739505
    },
    {
        "content": "<p>I am like 8000 messages in the hole in terms of staying up to date on the server... have you advertised this stuff on <a class=\"stream\" data-stream-id=\"116395\" href=\"/#narrow/stream/116395-maths\">#maths</a> or are you waiting until more of the sorries and errors are fixed?</p>",
        "id": 210821331,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1600739655
    },
    {
        "content": "<p>(small meta note, hopefully this is more helpful than annoying. if your big message were broken up into smaller messages, it would be easier to quote / emoji for more specific things)</p>",
        "id": 210821362,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1600739731
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"252300\">Jalex Stark</span> <a href=\"#narrow/stream/252551-graph-theory/topic/simple_graphs2/near/210821362\">said</a>:</p>\n<blockquote>\n<p>(small meta note, hopefully this is more helpful than annoying. if your big message were broken up into smaller messages, it would be easier to quote / emoji for more specific things)</p>\n</blockquote>\n<p>Like this? (Good point <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span>)</p>",
        "id": 210822618,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1600741430
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/252551-graph-theory/topic/simple_graphs2/near/210694263\">said</a>:</p>\n<blockquote>\n<p>Graph homomorphisms have been changed to use <code>order.rel_iso</code> exclusively.  Monomorphisms are graph homomorphisms that implement the<code>simple_graph.hom.mono</code> typeclass.</p>\n</blockquote>\n<p>I guess <span class=\"user-mention\" data-user-id=\"302826\">@Aaron Anderson</span> will be happy to hear this</p>",
        "id": 210822729,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1600741568
    },
    {
        "content": "<p>The conversion to using <code>simple_graph</code> is almost entirely just removing vertex type arguments and then doing <code>v : V G</code>.  It's pretty much painless.</p>",
        "id": 210822734,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1600741587
    },
    {
        "content": "<p>What do you think the next PR from this branch should be?</p>",
        "id": 210822743,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1600741665
    },
    {
        "content": "<p>It would be nice to sort out the coercion.  There's a little discussion in <a class=\"stream\" data-stream-id=\"217875\" href=\"/#narrow/stream/217875-Is-there-code-for-X.3F\">#Is there code for X?</a> (the auto-coercions thread) about how <code>has_coe</code> is almost but not quite sufficient, but it seems fixing this involves modifying Lean itself.</p>",
        "id": 210822807,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1600741771
    },
    {
        "content": "<p>But maybe making the arrow a local notation is good enough for now.</p>",
        "id": 210822818,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1600741790
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"252300\">Jalex Stark</span> <a href=\"#narrow/stream/252551-graph-theory/topic/simple_graphs2/near/210822743\">said</a>:</p>\n<blockquote>\n<p>What do you think the next PR from this branch should be?</p>\n</blockquote>\n<p>Most of <code>simple_graph/basic.lean</code> seems good, except for the incomplete stuff about graph operations.  Some simp lemmas relating <code>simple_graph_on</code> to <code>simple_graph</code> might not make sense.  Also <code>simple_graph_from_rel_adj</code> can probably wait.</p>\n<p>The definitions in <code>simple_graph/hom.lean</code> seem fine, but the lemmas should be reviewed since the api is underutilized and seems somewhat incomplete.</p>\n<p><code>simple_graph/subgraph.lean</code> seems good, except for things about cycles and maybe induced graphs.  Cardinality results should be reviewed -- there's no application of them yet so the design might not be good.</p>\n<p><code>simple_graph/simple_graph_on.lean</code> is fine enough. It could certainly be expanded, but it at least has a <code>bounded_lattice</code> instance.</p>\n<p><code>simple_graph/degree_sum.lean</code> is close, but I think it can still be simplified a lot given a person sufficiently competent with <code>big_operators</code>.  It also would be nice to have an explicit handshake lemma.</p>",
        "id": 210826149,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1600747215
    },
    {
        "content": "<p><code>simple_graph/adj_matrix.lean</code> is just the current <code>adj_matrix.lean</code> but modified to use this new <code>simple_graph</code> type.</p>",
        "id": 210826175,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1600747303
    },
    {
        "content": "<p>I think I completed the edge contraction definition</p>",
        "id": 212984260,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1602454644
    },
    {
        "content": "<p>I also created an edge deletion definition</p>",
        "id": 212984261,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1602454652
    },
    {
        "content": "<p>I tried messing around with paths and walks after that, as well as trees, but really didn't get anywhere</p>",
        "id": 212984270,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1602454665
    },
    {
        "content": "<p>I managed to prove the first direction of the statement <code>map_rel_iff'</code> in <code>fin.flip.invol</code></p>",
        "id": 212984324,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1602454737
    },
    {
        "content": "<p>but the other direction has me stumped</p>",
        "id": 212984327,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1602454744
    },
    {
        "content": "<p>Since it's an involution can't you just use the first direction and some equivalence properties?</p>",
        "id": 212984802,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1602455616
    },
    {
        "content": "<p>I might be misremembering what you're trying to prove though</p>",
        "id": 212984804,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1602455625
    },
    {
        "content": "<p>i think i got stuck trying to do exactly that</p>",
        "id": 212991036,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1602467717
    },
    {
        "content": "<p>Trying to figure out how to define matchings currently. I'm thinking some structure like</p>\n<div class=\"codehilite\" data-code-language=\"Python\"><pre><span></span><code><span class=\"n\">structure</span> <span class=\"n\">matching_on</span> <span class=\"p\">(</span><span class=\"n\">G</span> <span class=\"p\">:</span> <span class=\"n\">simple_graph</span><span class=\"p\">)</span> <span class=\"o\">:=</span>\n<span class=\"p\">(</span><span class=\"n\">disjoint</span> <span class=\"p\">:</span> <span class=\"p\">)</span>\n</code></pre></div>",
        "id": 212993404,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1602471568
    },
    {
        "content": "<p>where disjoint is the property that the edges are disjoint</p>",
        "id": 212993406,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1602471581
    },
    {
        "content": "<p>but I'm not quite sure how to get there</p>",
        "id": 212993441,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1602471604
    },
    {
        "content": "<p>maybe a <code>class</code>? something like</p>\n<div class=\"codehilite\" data-code-language=\"Python\"><pre><span></span><code><span class=\"k\">class</span> <span class=\"nc\">matching</span> <span class=\"p\">(</span><span class=\"n\">M</span> <span class=\"p\">:</span> <span class=\"nb\">set</span> <span class=\"p\">(</span><span class=\"n\">sym2</span> <span class=\"p\">(</span><span class=\"n\">V</span> <span class=\"n\">G</span><span class=\"p\">)))</span> <span class=\"o\">:=</span>\n<span class=\"p\">(</span><span class=\"n\">disjoint</span> <span class=\"p\">:</span> <span class=\"err\">∀</span> <span class=\"n\">e</span> <span class=\"n\">f</span> <span class=\"err\">∈</span> <span class=\"n\">M</span><span class=\"p\">,</span> <span class=\"err\">∀</span> <span class=\"n\">v</span> <span class=\"p\">:</span> <span class=\"n\">V</span> <span class=\"n\">G</span><span class=\"p\">,</span> <span class=\"n\">v</span> <span class=\"err\">∈</span> <span class=\"n\">e</span> <span class=\"err\">→</span> <span class=\"n\">v</span> <span class=\"err\">∉</span> <span class=\"n\">f</span><span class=\"p\">)</span>\n</code></pre></div>",
        "id": 212993456,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1602471609
    },
    {
        "content": "<p>A class seems like a reasonable approach.  I haven't tested it, but maybe this definition?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">matching</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">sym2</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"n\">G</span><span class=\"o\">)))</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">sub_edges</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">⊆</span> <span class=\"n\">E</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">disjoint</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"n\">f</span> <span class=\"bp\">∈</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"n\">G</span><span class=\"o\">),</span> <span class=\"n\">v</span> <span class=\"bp\">∈</span> <span class=\"n\">e</span> <span class=\"bp\">→</span> <span class=\"n\">v</span> <span class=\"bp\">∈</span> <span class=\"n\">f</span> <span class=\"bp\">→</span> <span class=\"n\">e</span> <span class=\"bp\">=</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">perfect_matching</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">sym2</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"n\">G</span><span class=\"o\">)))</span> <span class=\"kd\">extends</span> <span class=\"n\">matching</span> <span class=\"n\">P</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">cover</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">e</span> <span class=\"bp\">∈</span> <span class=\"n\">P</span><span class=\"o\">,</span> <span class=\"n\">v</span> <span class=\"bp\">∈</span> <span class=\"n\">e</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 213117800,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1602572285
    },
    {
        "content": "<p>There are upsides and downsides to classes for this, so you might need to experiment.  Structures would be fine too, but if you had a perfect matching, you'd need to use its <code>to_matching</code> function to turn it into a <code>matching</code> when necessary.</p>\n<p>Another thing to consider is predicates</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">matching</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">sym2</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"n\">G</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"n\">M</span> <span class=\"bp\">⊆</span> <span class=\"n\">E</span> <span class=\"n\">G</span> <span class=\"bp\">∧</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"n\">f</span> <span class=\"bp\">∈</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"n\">G</span><span class=\"o\">),</span> <span class=\"n\">v</span> <span class=\"bp\">∈</span> <span class=\"n\">e</span> <span class=\"bp\">→</span> <span class=\"n\">v</span> <span class=\"bp\">∈</span> <span class=\"n\">f</span> <span class=\"bp\">→</span> <span class=\"n\">e</span> <span class=\"bp\">=</span> <span class=\"n\">f</span>\n<span class=\"kd\">def</span> <span class=\"n\">perfect_matching</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">sym2</span> <span class=\"n\">V</span> <span class=\"n\">G</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"n\">matching</span> <span class=\"n\">P</span> <span class=\"bp\">∧</span> <span class=\"bp\">∀</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">e</span> <span class=\"bp\">∈</span> <span class=\"n\">P</span><span class=\"o\">,</span> <span class=\"n\">v</span> <span class=\"bp\">∈</span> <span class=\"n\">e</span>\n</code></pre></div>\n\n<p>but a downside here is that you can't access the sub-properties as easily.</p>",
        "id": 213118030,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1602572543
    },
    {
        "content": "<p>ah yeah thank you, the class definition you gave makes more sense</p>",
        "id": 213221093,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1602625557
    },
    {
        "content": "<p>forgot to add the part where the edges come from G</p>",
        "id": 213221178,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1602625591
    },
    {
        "content": "<p>I feel like you want a structure rather than a class (they can also extend) since you might want to consider multiple matchings on the same set</p>",
        "id": 213283507,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1602680117
    },
    {
        "content": "<p>I was thinking that too, but then I realized Alena's class was the matching itself, and all the fields are just propositions so the class is a subsingleton.  It seems like it's similar to using <code>mono</code>.</p>",
        "id": 213330791,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1602699117
    },
    {
        "content": "<p>I think <code>mono</code> should be a proposition though :) I think that change is gonna happen in the category theory library as soon as someone actually puts in the effort to make it</p>",
        "id": 213351611,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1602710183
    },
    {
        "content": "<p>Is there something we can do about the builds failing?</p>",
        "id": 213659625,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1602952685
    },
    {
        "content": "<p>I've been away for a bit so I'm a bit out of the loop, are we still trying to go with the definition <code>simple_graph_on</code> where we turn it into <code>simple_graph</code> later? Just looking at the file in mathlib and it doesn't seem to be the case right now</p>",
        "id": 217634617,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1606142213
    },
    {
        "content": "<p>If we are going to do that then I can start slicing off <code>simple_graphs2</code> into PRs</p>",
        "id": 217635042,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1606142404
    },
    {
        "content": "<p>Btw I think when I was initially trying to figure things out I muddled up a lot of the code in simple_graphs2 so I'm sorry if that caused anyone to step back</p>",
        "id": 217636315,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1606143009
    },
    {
        "content": "<p>I think the <code>simple_graph_on</code> proposal is still the best one, and I'd support you in making PRs about it</p>",
        "id": 217824044,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1606258054
    },
    {
        "content": "<p>I’d be happy to help a PR to refactor to <code>simple_graph_on</code> etc. if someone else gets it started</p>",
        "id": 217831437,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1606263599
    },
    {
        "content": "<p>(Mostly I’m volunteering to translate over the friendship graph material)</p>",
        "id": 217831569,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1606263703
    },
    {
        "content": "<p><del>I think we pretty much do have everything refactored</del> ah wait, forgot that we need to catch up to all of the mathlib changes since september</p>",
        "id": 217832817,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1606264807
    },
    {
        "content": "<p>Like, I didn't even need to do the work, it's already there in simple_graphs2</p>",
        "id": 217832831,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1606264825
    },
    {
        "content": "<p>But I'll pull the file into its own PR</p>",
        "id": 217832836,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1606264839
    },
    {
        "content": "<p>So I managed to adapt some of the lemmas and definitions from simple_graphs2 into a branch that doesn't rely on <code>simple_graph_on</code></p>",
        "id": 218616346,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1606941635
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"246273\">@Bhavik Mehta</span> just gonna pull you into this conversation cause I'm probably not going to be able to explain why I wasn't using <code>simple_graph_on</code> very well</p>",
        "id": 218616981,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1606941910
    },
    {
        "content": "<p>Also <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span></p>",
        "id": 218617180,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1606942008
    },
    {
        "content": "<p>I think it still makes sense to eventually have a PR that adds no new features, and just converts to <code>simple_graph_on</code>, because I think that conversion will cause enough discussion by itself.</p>",
        "id": 218617507,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1606942171
    },
    {
        "content": "<p>You could always have another PR that is blocked by that <code>simple_graph_on</code> PR, adding features on top of <code>simple_graph_on</code>, if you think that those features would be a good demonstration of why <code>simple_graph_on</code> is good.</p>",
        "id": 218617660,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1606942244
    },
    {
        "content": "<p>So far I haven't had any trouble switching everything from simple_graphs2 to the definition we currently have in mathlib</p>",
        "id": 218618231,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1606942529
    },
    {
        "content": "<p>The one annoying thing is not using <code>simple_graph_on</code> means we don't have the special notation for adjacency</p>",
        "id": 218618308,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1606942564
    },
    {
        "content": "<p>But if I do find problems/advantages I'll try to do that</p>",
        "id": 218618366,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1606942591
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"303889\">Alena Gusakov</span> <a href=\"#narrow/stream/252551-graph-theory/topic/simple_graphs2/near/218618231\">said</a>:</p>\n<blockquote>\n<p>So far I haven't had any trouble switching everything from simple_graphs2 to the definition we currently have in mathlib</p>\n</blockquote>\n<p>We haven't gotten to subgraphs in mathlib yet is why <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>\n<p>I think it's better to leave it as <code>simple_graph</code> for now and then do the refactor later when a <code>simple_graph_on</code> is clearly needed -- and since putting it off might cause more work, I'm willing to do it when it comes to that.  (I think it will actually be less work long-term to not change it now.)</p>",
        "id": 218621349,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1606944031
    },
    {
        "content": "<p>Got it, I'll try to do subgraphs in the next PR (assuming this first one gets approved)</p>",
        "id": 218621480,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1606944107
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"303889\">@Alena Gusakov</span> can I do a pull request  with subgraph.lean and hom.lean from the <a href=\"https://github.com/leanprover-community/mathlib/tree/simple_graph_subgraph/src/combinatorics/simple_graph\">simple_graph_subgraph</a>  branch? I would add a definition of graph isomorphism.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">abbreviation</span> <span class=\"n\">iso</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">G'</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">W</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">rel_iso</span> <span class=\"o\">(</span><span class=\"n\">G.adj</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">G'.adj</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 245079807,
        "sender_full_name": "Hunter Monroe",
        "timestamp": 1625596139
    },
    {
        "content": "<p>Go for it!</p>",
        "id": 245089475,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1625600715
    },
    {
        "content": "<p>I don't remember how much I did with that branch tbh</p>",
        "id": 245089887,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1625600906
    },
    {
        "content": "<p>For what it's worth, <span class=\"user-mention\" data-user-id=\"302826\">@Aaron Anderson</span> had written the following for a PR a while back.  It seems fine, though I think the definition of <code>embedding</code> is surprising for graphs (I think you'd want a result that every subgraph of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span> embeds in the graph <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span> -- so an embedding would be an injective homomorphism).   I think the terminology comes from model theory -- it's a useful concept, but I don't know the proper graph-theoretic terminology for it.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">section</span> <span class=\"n\">maps</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">W</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">W</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- A graph homomorphism maps adjacent vertices to adjacent vertices -/</span>\n<span class=\"kd\">abbreviation</span> <span class=\"n\">hom</span> <span class=\"o\">:=</span> <span class=\"n\">rel_hom</span> <span class=\"n\">G.adj</span> <span class=\"n\">H.adj</span>\n\n<span class=\"kd\">infix</span> <span class=\"bp\">`</span> <span class=\"bp\">→</span><span class=\"n\">g</span> <span class=\"bp\">`</span> <span class=\"o\">:</span> <span class=\"mi\">50</span> <span class=\"o\">:=</span> <span class=\"n\">hom</span>\n\n<span class=\"sd\">/-- A graph embedding is an embedding `f` such that for vertices `v w : V`,</span>\n<span class=\"sd\">  `G.adj f(v) f(w) ↔ G.adj v w `-/</span>\n<span class=\"kd\">abbreviation</span> <span class=\"n\">embedding</span> <span class=\"o\">:=</span> <span class=\"n\">rel_embedding</span> <span class=\"n\">G.adj</span> <span class=\"n\">H.adj</span>\n\n<span class=\"kd\">infix</span> <span class=\"bp\">`</span> <span class=\"bp\">↪</span><span class=\"n\">g</span> <span class=\"bp\">`</span> <span class=\"o\">:</span> <span class=\"mi\">50</span> <span class=\"o\">:=</span> <span class=\"n\">embedding</span>\n\n<span class=\"sd\">/-- A graph isomorphism is an equivalence that preserves adjacency-/</span>\n<span class=\"kd\">abbreviation</span> <span class=\"n\">iso</span> <span class=\"o\">:=</span> <span class=\"n\">rel_iso</span> <span class=\"n\">G.adj</span> <span class=\"n\">H.adj</span>\n\n<span class=\"kd\">infix</span> <span class=\"bp\">`</span> <span class=\"bp\">≃</span><span class=\"n\">g</span> <span class=\"bp\">`</span> <span class=\"o\">:</span> <span class=\"mi\">50</span> <span class=\"o\">:=</span> <span class=\"n\">iso</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">maps</span>\n</code></pre></div>",
        "id": 245094735,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1625603525
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 245094788,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1625603553
    },
    {
        "content": "<p>A relationship embedding <code>rel_embedding</code> maps G to an induced subgraph of H (a bijection for all edges of the involved vertices of H), right? Also, I want to be certain that all of these maps are injective, which is my reading of the definitions. </p>\n<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/252551-graph-theory/topic/simple_graphs2/near/245094735\">said</a>:</p>\n<blockquote>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">abbreviation</span> <span class=\"n\">embedding</span> <span class=\"o\">:=</span> <span class=\"n\">rel_embedding</span> <span class=\"n\">G.adj</span> <span class=\"n\">H.adj</span>\n</code></pre></div><br>\n</p>\n</blockquote>",
        "id": 245206328,
        "sender_full_name": "Hunter Monroe",
        "timestamp": 1625675020
    },
    {
        "content": "<p>I will leave out embedding which is an obscure concept within graph theory. The only reference I could find was to \"induced subgraph isomorphism\" within complexity theory.</p>",
        "id": 245207160,
        "sender_full_name": "Hunter Monroe",
        "timestamp": 1625675410
    },
    {
        "content": "<p>Embedding is by definition injective. An injective map can be called an embedding. Not all rel_homs will be injective.</p>",
        "id": 245210105,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1625676771
    },
    {
        "content": "<p>In topology an embedding is a specific kind of injective map  -- the words aren't entirely interchangeable</p>",
        "id": 245210200,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1625676823
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"397140\">Hunter Monroe</span> <a href=\"#narrow/stream/252551-graph-theory/topic/simple_graphs2/near/245207160\">said</a>:</p>\n<blockquote>\n<p>I will leave out embedding which is an obscure concept within graph theory. The only reference I could find was to \"induced subgraph isomorphism\" within complexity theory.</p>\n</blockquote>\n<p>embeddings essentially let you define induced subgraphs, which I'd argue aren't at all obscure, I think they should definitely be added</p>",
        "id": 245211021,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1625677169
    },
    {
        "content": "<p>Yeah, I didn't mean to suggest that <code>rel_embedding</code> was obscure, just that calling it an \"embedding\" seems to be.  I personally think hook arrow for \"injectively maps onto an induced subgraph\" would be surprising, but I'm happy to follow consensus.</p>\n<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> At least in this case, injective homomorphisms induce topological embeddings for the graphs' geometric realizations as CW complexes.</p>",
        "id": 245213295,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1625678198
    },
    {
        "content": "<p>There is a more general concept of injection where you're allowed to send adjacent vertices to non-adjacent vertices which are connected by a path I guess. I remember learning the statement (but not proof) of a theorem of perhaps Kuratowski saying that topological K5's and K(3,3)'s are the only obstruction to planarity</p>",
        "id": 245213886,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1625678464
    },
    {
        "content": "<p>The <code>rel_embedding</code> definition is a regular monomorphism, but the injective <code>rel_hom</code> definition is a monomorphism, in the category of simple graphs where maps have to preserve adjacency.  There are at least two different ways to define this category, however (and ncatlab describes both).  In the other one, maps can send adjacent pairs to adjacent pairs, or collapse them to a single vertex.</p>",
        "id": 245214336,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1625678657
    },
    {
        "content": "<p>Maybe this is why they deserve to be called embeddings, now that I've thought it through again in front of everyone.</p>",
        "id": 245214446,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1625678706
    },
    {
        "content": "<p>I have created a <a href=\"https://github.com/leanprover-community/mathlib/pull/8223\">pull request</a> for <code>subgraph</code> and maps (<code>homomorphism</code>, <code>isomorphism</code>, <code>embedding</code>).</p>",
        "id": 245261843,
        "sender_full_name": "Hunter Monroe",
        "timestamp": 1625705834
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"397140\">@Hunter Monroe</span> Just fyi, if you type <code>#8223</code> in Zulip, it will render as <a href=\"https://github.com/leanprover-community/mathlib/issues/8223\">#8223</a> and also link to your PR.</p>",
        "id": 245271535,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1625719311
    },
    {
        "content": "<p>I have incorporated review comments and reverted the formatting. Note one substantive change at <span class=\"user-mention\" data-user-id=\"246273\">@Bhavik Mehta</span>'s suggestion: <code>hom</code> and <code>iso</code> no longer assume that G and G' have vertices of the same type.</p>",
        "id": 245313688,
        "sender_full_name": "Hunter Monroe",
        "timestamp": 1625751551
    },
    {
        "content": "<p>Note that Kyle's suggestion above also did not have this assumption</p>",
        "id": 245315497,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1625752329
    },
    {
        "content": "<p>How do we want naming of lemmas for subgraphs to work?  There are a number of useful definitions and lemmas for subgraphs that reflect lemmas about simple graphs.  Right now in the PR, they use <code>'</code> to distinguish them.  For example, <code>simple_graph.edge_set</code> versus <code>subgraph.edge_set'</code>.  It seems like it would be sensible going for <code>subgraph.edge_set</code> since namespaces or dot notation can distinguish them.</p>",
        "id": 245337880,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1625761904
    },
    {
        "content": "<p>I'm also wondering about where <code>subgraph</code> should live.  It seems like the name will conflict with subgraphs of other types of graphs, like multigraphs.  Should it be put into the <code>simple_graph</code> namespace?</p>",
        "id": 245337998,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1625761955
    },
    {
        "content": "<p>My thought was to put subgraph under simple_graph, and in the next PR generalize to allow directed graphs, etc.</p>",
        "id": 245347476,
        "sender_full_name": "Hunter Monroe",
        "timestamp": 1625766656
    },
    {
        "content": "<p>Right now <code>subgraph</code> is not in the <code>simple_graph</code> namespace -- it might be the <code>combinatorics.simple_graph.subgraph</code> module, but inside the file you have to manage namespaces yourself.  I'm essentially suggesting that inside this module, there should be <code>namespace simple_graph</code> rather than <code>open simple_graph</code>, but I'm wondering what other graph theorists think.</p>",
        "id": 245348090,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1625766952
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"397140\">Hunter Monroe</span> <a href=\"#narrow/stream/252551-graph-theory/topic/simple_graphs2/near/245347476\">said</a>:</p>\n<blockquote>\n<p>in the next PR generalize to allow directed graphs, etc.</p>\n</blockquote>\n<p>Would you mind discussing this in a new topic here in the <a class=\"stream\" data-stream-id=\"252551\" href=\"/#narrow/stream/252551-graph-theory\">#graph theory</a> stream?  Even <code>simple_graph</code> went through a good amount of redesign before it made it into mathlib.</p>",
        "id": 245348494,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1625767163
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span>  I see two options for pursuing that issue: (1) put this version of <code>subgraph</code> in the <code>simple_graph</code> namespace since it clearly only applies to simple graphs given the presence of <code>sym'</code>, and delay broader discussions about a broader structure that encompasses multigraphs and directed graphs while wrapping up this PR (this is my preference), or (2) consider the broader structure including how subgraph fits in before wrapping up this PR. I am worried that we could get bogged down this way, and there is some history of that. We could get lost trying to build a subgraph concept for directed multi hypergraphs. If I have misunderstood the question you are asking, let me know.</p>",
        "id": 245356779,
        "sender_full_name": "Hunter Monroe",
        "timestamp": 1625770933
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"397140\">@Hunter Monroe</span> (1) is what I meant.  I had been expecting each notion of graph will have its own notion of subgraph, which is why I bring this up.</p>",
        "id": 245360087,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1625772610
    },
    {
        "content": "<p>(For some context, I had written about three or four different definitions of <code>subgraph</code>, and after some experimentation the one you've kindly PR'd seemed to be the best one.  There wasn't really anything that used subgraphs yet, so the work to polish it and PR it hadn't happened...)</p>",
        "id": 245360871,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1625772986
    },
    {
        "content": "<p>By the way, I <em>knew</em> that there was some place where I had developed it more (like when I mentioned there was a version when I had removed all the primes), and I just found it: <a href=\"https://github.com/leanprover-community/mathlib/blob/simple_graph_matching/src/combinatorics/simple_graph/subgraph.lean\">https://github.com/leanprover-community/mathlib/blob/simple_graph_matching/src/combinatorics/simple_graph/subgraph.lean</a>  (sorry)</p>",
        "id": 245361002,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1625773071
    },
    {
        "content": "<p>I also understand the purpose of <code>adj_symm</code> now.  It's that <code>symmetric</code> is a one-way implication, but it's nice to have it as an iff.</p>",
        "id": 245361118,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1625773120
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"397140\">@Hunter Monroe</span> By the way, I'm happy to help with merging this <code>subgraph.lean</code> with yours for the PR.</p>",
        "id": 245365523,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1625775124
    },
    {
        "content": "<p>I will give it a try.</p>",
        "id": 245368100,
        "sender_full_name": "Hunter Monroe",
        "timestamp": 1625776305
    },
    {
        "content": "<p>Feel free to defer as much as you want to a later PR. ( Also, I'm not sure all of it makes sense.)</p>\n<p>It turns out there's also a bunch of stuff about homomorphisms here <a href=\"https://github.com/leanprover-community/mathlib/blob/simple_graph_matching/src/combinatorics/simple_graph/hom.lean\">https://github.com/leanprover-community/mathlib/blob/simple_graph_matching/src/combinatorics/simple_graph/hom.lean</a> (This can also wait)</p>",
        "id": 245368852,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1625776674
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/252551-graph-theory/topic/simple_graphs2/near/245361118\">said</a>:</p>\n<blockquote>\n<p>I also understand the purpose of <code>adj_symm</code> now.  It's that <code>symmetric</code> is a one-way implication, but it's nice to have it as an iff.</p>\n</blockquote>\n<p>Then it should be called <code>adj_comm</code></p>",
        "id": 245369676,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1625777084
    },
    {
        "content": "<p>The rule is unfortunately quite lax, but having <code>symm</code>lemmas to be one-way and <code>comm</code> lemmas to be two-ways (so including equality) is pretty useful to the ear.</p>",
        "id": 245369777,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1625777155
    },
    {
        "content": "<p>I wasn't aware of this convention -- this should be fixed in <code>simple_graph/basic.lean</code> then with <code>edge_symm</code>, which probably should be called <code>adj_comm</code>. (I don't remember how it got the name <code>edge_symm</code> exactly.)</p>",
        "id": 245370302,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1625777413
    },
    {
        "content": "<p>Maybe it would make sense to rename <code>sym</code> in the <code>simple_graph</code> structure to <code>adj_symm</code>, add the <code>@[symm]</code> attribute to it, and delete the <code>edge_symm'</code> lemma.  (This might not all work due to the <code>obviously</code> autoparam.)</p>\n<p>(If I recall, it's <code>sym</code> rather than <code>symm</code> so it doesn't conflict with the <code>symm</code> in the root namespace, which isn't actually used by the library.)</p>",
        "id": 245370895,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1625777725
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> actually yes could you help with this? Merging <code>subgraph.lean</code> would also affect <code>basic.lean</code> including additional code from <code>hom.lean</code>.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/252551-graph-theory/topic/simple_graphs2/near/245365523\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"397140\">Hunter Monroe</span> By the way, I'm happy to help with merging this <code>subgraph.lean</code> with yours for the PR.</p>\n</blockquote>",
        "id": 245455230,
        "sender_full_name": "Hunter Monroe",
        "timestamp": 1625843275
    },
    {
        "content": "<p>Thanks for your work, <span class=\"user-mention\" data-user-id=\"397140\">@Hunter Monroe</span>, to get this PR together.  I think I'm done editing now.</p>",
        "id": 245487241,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1625859200
    },
    {
        "content": "<p>Oh, there are some linter errors and other errors to fix still.  I'll try to take care of those</p>",
        "id": 245487423,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1625859290
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/issues/8223\">#8223</a> seems ready for more review</p>\n<p>Part of this, I changed <code>edge_symm</code> to <code>adj_comm</code>, as suggested by <span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span></p>",
        "id": 245503883,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1625866277
    },
    {
        "content": "<p>Looks good, let's see what the reviewers think.</p>\n<p>Here is an approach for handling any type of graph in one framework. A typeclass <code>graph</code> has a set of vertices V, a type E for edges which is a multiset, and a function <code>incidence</code> that maps each edge to a subset of V. This is enough to define a generic approach to subgraphs and maps. An instance specifies what an edge is: an unordered pair of V without loops and without duplication (graph), an ordered pair of V with the same constraints (direct graph), edges with more than two vertices with the same constraints with permuting those vertices gives the same edge (hypergraph), without such permuting (directed hypergraph), and allow duplication (multigraph), etc. The condition for G' to be a subgraph of G is generic: given any subset VS of V, the multiset of edges of G' incident on VS is a submultiset of the multiset of edges of G incident on VS. The maps can also be defined generically. All the action happens in the definition of edge. The constraints can be stated generically: has_symm (permuting the vertices gives the same edge), no_loops, 2_edge (two vertices per edge), n_edge (hypergraphs), no_dups (does not hold for multigraphs).</p>",
        "id": 245514220,
        "sender_full_name": "Hunter Monroe",
        "timestamp": 1625870745
    },
    {
        "content": "<p>Here's a proposal along those lines (and similar to something I worked on for a while to try to make it so that submultigraphs could be used as if they were multigraphs):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">graph_like</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">incidence</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">E</span> <span class=\"n\">G</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"n\">G</span><span class=\"o\">))</span>\n\n<span class=\"c1\">-- Example instance</span>\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">graph_like</span> <span class=\"o\">(</span><span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">V</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"n\">V</span><span class=\"o\">,</span>\n  <span class=\"n\">E</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"n\">G.edge_set</span><span class=\"o\">,</span>\n  <span class=\"n\">incidence</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">G</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">|</span> <span class=\"n\">v</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">sym2</span> <span class=\"n\">V</span><span class=\"o\">)}</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>A tradeoff with this is that you lose dot notation if you only have generic code.</p>\n<p>There's also a question about whether having generic code will result in less code overall.</p>",
        "id": 245516336,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1625872735
    },
    {
        "content": "<p>Before the definition of subgraph that was in this PR, there was a definition involving a subset of the edge set of the simple graph, rather than a sub-relation of the adjacency relation.  This wasn't so easy to work with because there were levels of stuff you had to get through (like <code>sym2</code>).</p>",
        "id": 245517016,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1625873378
    },
    {
        "content": "<p>To be clear, I do like this idea of having something that would let there be generic definitions, and I like the ideas you have.  The design trick is figuring out how to do this in a way that is ergonomic and that definitely makes things simpler.  It's worth designing something generic, even right now, but also I think in the short term making non-generic things is a good way to inform a generic design.</p>\n<p>Re ergonomics: if anyone looks at that <code>directed_graph</code> definition I made, one annoying problem is that the adjacency relation <code>G.adj v w</code> renders as <code>G.to_directed_graph.adj v w</code>.  Maybe a reducible definition can fix this?  I was wanting to avoid a notation, but perhaps there will eventually a <code>v ~[G] w</code> defined by something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">notation</span> <span class=\"n\">v</span> <span class=\"bp\">`~</span><span class=\"o\">[</span><span class=\"bp\">`</span> <span class=\"n\">G</span> <span class=\"bp\">`</span><span class=\"o\">]</span><span class=\"bp\">`</span> <span class=\"n\">w</span> <span class=\"o\">:=</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">graph_like.E</span> <span class=\"n\">G</span><span class=\"o\">),</span> <span class=\"n\">graph_like.incidence</span> <span class=\"n\">G</span> <span class=\"n\">e</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">w</span><span class=\"o\">}</span>\n</code></pre></div>",
        "id": 245517244,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1625873583
    },
    {
        "content": "<p>Hunter are you sure this works that great with hypergraphs? Hypergraphs want <code>set V → Prop</code> and multigraphs want <code>V → V → Prop</code>.</p>",
        "id": 245534406,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1625900636
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/252551-graph-theory/topic/simple_graphs2/near/245516336\">said</a>:</p>\n<blockquote>\n<p>Here's a proposal along those lines (and similar to something I worked on for a while to try to make it so that submultigraphs could be used as if they were multigraphs):</p>\n</blockquote>\n<p>I actually kind of like this presentation! Not being a multigraph then becomes <code>injective incidence</code>. The problem I see is that <code>set (V G )</code> doesn't allow you to express oriented edges. Also, we don't have to use only generic code. We can redefine functions for every kind of graphs we care about and use the common API to avoid boilerplate.</p>",
        "id": 245534636,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1625900966
    },
    {
        "content": "<p>An unspoken idea here is that this is only giving a common interface.  A directed graph is free to peer into the <code>E</code> type, for example.</p>",
        "id": 245534715,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1625901065
    },
    {
        "content": "<p>I'm curious what you mean about <code>set V -&gt; Prop</code> and <code>V -&gt; V -&gt; Prop</code>.  What's the objection?</p>",
        "id": 245534796,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1625901153
    },
    {
        "content": "<p>Here's another multigraph definition along with a <code>graph_like</code> instance:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- Multigraphs as graphs with labeled edges. An edge is identified with the</span>\n<span class=\"sd\">unordered pair of endpoints and the label. -/</span>\n<span class=\"kd\">structure</span> <span class=\"n\">multigraph</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">links</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">V</span> <span class=\"bp\">×</span> <span class=\"n\">V</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">sym</span> <span class=\"o\">:</span> <span class=\"n\">prod.map</span> <span class=\"n\">id</span> <span class=\"n\">prod.swap</span> <span class=\"bp\">''</span> <span class=\"n\">links</span> <span class=\"bp\">=</span> <span class=\"n\">links</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">multigraph.is_simple</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">multigraph</span> <span class=\"n\">V</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">},</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"n\">v</span><span class=\"o\">,</span><span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">G.links</span> <span class=\"bp\">→</span> <span class=\"n\">v</span> <span class=\"bp\">≠</span> <span class=\"n\">w</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">multigraph.edges</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">multigraph</span> <span class=\"n\">V</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">sym2</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">V</span> <span class=\"bp\">×</span> <span class=\"n\">V</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">l.1</span><span class=\"o\">,</span> <span class=\"bp\">⟦</span><span class=\"o\">(</span><span class=\"n\">l.2.1</span><span class=\"o\">,</span> <span class=\"n\">l.2.2</span><span class=\"o\">)</span><span class=\"bp\">⟧</span><span class=\"o\">))</span> <span class=\"bp\">''</span> <span class=\"n\">G.links</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">graph_like</span> <span class=\"o\">(</span><span class=\"n\">multigraph</span> <span class=\"n\">V</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">V</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">V</span><span class=\"o\">,</span>\n  <span class=\"n\">E</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"n\">G.edges</span><span class=\"o\">,</span>\n  <span class=\"n\">incidence</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">G</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">|</span> <span class=\"n\">v</span> <span class=\"bp\">∈</span> <span class=\"n\">e.1.2</span><span class=\"o\">}}</span>\n</code></pre></div>",
        "id": 245536242,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1625903257
    },
    {
        "content": "<p>I like how this definition of <code>multigraph</code> exposes some useful parameters, lets you give edges identity, and is fairly simple.  It even would have a lattice instance.  (The seemingly unattainable property is to also have it so that the degree-sum formula will work with loop edges without special casing or having a significantly more complicated definition.  Here, there is a single element of <code>links</code> for loop edges, and two elements for non-loop edges.)  The \"links\" terminology comes from a paper by Chou, \"A formal theory of undirected graphs in higher-order logic\", 1994.  In that paper, there are additional constraints that each edge has its own unique label and all the labels are used.  I think that can be relaxed.</p>",
        "id": 245536538,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1625903727
    }
]
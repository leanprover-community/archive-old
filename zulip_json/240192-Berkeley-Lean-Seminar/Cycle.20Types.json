[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"302826\">@Aaron Anderson</span> Here are a few questions about cycle types:<br>\n1) Do you want to include 1's in the cycle type or not?<br>\n2) Should the cycle type be a partition, a multiset, a sorted list, or something else?</p>",
        "id": 232674603,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1617229305
    },
    {
        "content": "<p>There should certainly be a partition version of it, and I think there are advantages to including 1s.</p>",
        "id": 232674843,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1617229431
    },
    {
        "content": "<p>(If we include 1s, it should be very easy to make it a partition).</p>",
        "id": 232674909,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1617229450
    },
    {
        "content": "<p>I agree that there advantages to including 1's. One disadvantage of including 1's is that it makes it painful to state things like \"is_swap corresponds to this cycle type\" or \"an element of order p has a cycle type of this form\"</p>",
        "id": 232674940,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1617229467
    },
    {
        "content": "<p>Would it make sense to have two versions? A partition including 1's, and something (maybe a multiset or sorted list?) not including 1's.</p>",
        "id": 232675082,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1617229545
    },
    {
        "content": "<p>I'd probably say a multiset not including 1s and then a partition including 1s makes sense.</p>",
        "id": 232675157,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1617229568
    },
    {
        "content": "<p>If you derive it from <code>same_cycle</code>, you get 1s, and if you derive it from <code>cycle_factors</code>, you get no 1s.</p>",
        "id": 232675198,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1617229597
    },
    {
        "content": "<p>The advantage I see to including 1s is that it might make it easier to produce the bijection between cycles that I think you need for conjugacy.</p>",
        "id": 232675288,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1617229647
    },
    {
        "content": "<p>However, <span class=\"user-mention\" data-user-id=\"308899\">@Yakov Pechersky</span>'s work in <a href=\"https://github.com/leanprover-community/mathlib/issues/6959\">#6959</a> may obviate the need to consider the 1s at all in the conjugacy argument.</p>",
        "id": 232675481,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1617229749
    },
    {
        "content": "<p>I hadn't though about going from <code>same_cycle</code> (although I can't quite see how to do it nicely). If you go from <code>cycle_factors</code>, is there a nice way to avoid the <code>linear_order</code> assumption?</p>",
        "id": 232675630,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1617229830
    },
    {
        "content": "<p>On one of my recent PRs I threw in a <code>trunc</code> version...</p>",
        "id": 232675659,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1617229850
    },
    {
        "content": "<p>Yeah, <code>trunc_cycle_factors</code> in <a href=\"https://github.com/leanprover-community/mathlib/issues/6951\">#6951</a></p>",
        "id": 232675759,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1617229905
    },
    {
        "content": "<p>We should be able to use that to computably define a <code>cycle_type</code> multiset.</p>",
        "id": 232675818,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1617229928
    },
    {
        "content": "<p>Ok, I'll take a stab at this today, and I'll let you know when I've got something.</p>",
        "id": 232675944,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1617230009
    },
    {
        "content": "<p>As far as the partition, I might even suggest saving that for when we have conjugacy (and conjugacy classes, from <a href=\"https://github.com/leanprover-community/mathlib/issues/6896\">#6896</a>) and defining an <code>equiv</code> between <code>conj_classes</code> and partitions.</p>",
        "id": 232676092,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1617230080
    },
    {
        "content": "<p>As far as proving that the same cycle type implies conjugacy, I feel like we can maybe manage to prove it for cycles, and inductively for products of disjoint permutations.</p>",
        "id": 232676305,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1617230184
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"302826\">@Aaron Anderson</span> I've made a start at constructing <code>cycles_type</code> from <code>trunc_cycle_factors</code>, from which it shouldn't be too hard to make the partition. It look doable, but let me know if you see an easier to prove that the <code>cycle_type</code> doesn't depend on the choice of <br>\n<code>cycle_factors</code>.</p>",
        "id": 232818783,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1617308341
    },
    {
        "content": "<p>Where are you working on this?</p>",
        "id": 232824226,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1617310769
    },
    {
        "content": "<p>I think we want the lemma anyway that any two lists that satisfy the requirements of cycle factors are related by <code>list.perm</code>.</p>",
        "id": 232824375,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1617310822
    },
    {
        "content": "<p>That should be enough to appease the <code>trunc</code>, and it is a nicer place to put the <code>sorry</code>, but Idk how to prove it yet</p>",
        "id": 232824498,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1617310871
    },
    {
        "content": "<p>ah, sorry, I forgot the link: <a href=\"https://github.com/leanprover-community/mathlib/compare/cycle_type\">https://github.com/leanprover-community/mathlib/compare/cycle_type</a></p>",
        "id": 232825551,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1617311372
    },
    {
        "content": "<p>Good point that we should prove the permutation fact</p>",
        "id": 232825585,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1617311397
    },
    {
        "content": "<p>Actually, not that sure it does help, because we know the <code>list</code>s each satisfy <code>list.erase_dup</code>, so we can turn them into finsets and use <code>finset.ext</code>. I think we need to show that a member of one is a member of the other anyway.</p>",
        "id": 232829426,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1617313467
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"302826\">@Aaron Anderson</span> Would it make sense to prove something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">main_theorem</span>\n  <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">perm</span> <span class=\"n\">α</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"n\">perm</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">σ</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span> <span class=\"bp\">→</span> <span class=\"n\">σ.is_cycle</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"n\">l.pairwise</span> <span class=\"n\">disjoint</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">perm</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hc</span> <span class=\"o\">:</span> <span class=\"n\">c</span> <span class=\"n\">a</span> <span class=\"bp\">≠</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">c</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span> <span class=\"bp\">↔</span> <span class=\"n\">l.prod.cycle_of</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">c</span> <span class=\"o\">:=</span>\n</code></pre></div>",
        "id": 232833688,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1617315938
    },
    {
        "content": "<p>Yes, then you can just hit it with <code>list.perm_ext</code></p>",
        "id": 232839915,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1617320062
    },
    {
        "content": "<p>I just pushed this approach to the branch. There's just one sorry left, but it's a bit of a doozy.</p>",
        "id": 232839935,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1617320099
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">thm2</span>\n  <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"n\">τ</span> <span class=\"o\">:</span> <span class=\"n\">perm</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">disjoint</span> <span class=\"n\">σ</span> <span class=\"n\">τ</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">perm</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">hc</span> <span class=\"o\">:</span> <span class=\"n\">c</span> <span class=\"n\">a</span> <span class=\"bp\">≠</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"bp\">*</span> <span class=\"n\">τ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">cycle_of</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">c</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"n\">σ.cycle_of</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">c</span> <span class=\"bp\">∨</span> <span class=\"n\">τ.cycle_of</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"gr\">sorry</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 232839946,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1617320109
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"302826\">@Aaron Anderson</span> The branch now is now sorry-free<br>\n<a href=\"https://github.com/leanprover-community/mathlib/compare/cycle_type\">https://github.com/leanprover-community/mathlib/compare/cycle_type</a></p>",
        "id": 232869296,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1617348070
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/issues/6999\">#6999</a></p>",
        "id": 232870919,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1617349408
    },
    {
        "content": "<p>Check out <a href=\"https://github.com/leanprover-community/mathlib/tree/cycle_conj\">branch#cycle_conj</a></p>",
        "id": 233030789,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1617481858
    },
    {
        "content": "<p>I have a proof (although some things need to be cleaned up) that two cycles of the same size are conjugate</p>",
        "id": 233030801,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1617481881
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/issues/7024\">#7024</a></p>",
        "id": 233033744,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1617484625
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"302826\">@Aaron Anderson</span> Great! I'm wondering whether we can get the full conjugate/partition theorem from the induction lemma?</p>",
        "id": 233036225,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1617487331
    },
    {
        "content": "<p>If you look at my proof, it basically glues two <code>equiv</code>s together</p>",
        "id": 233036413,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1617487533
    },
    {
        "content": "<p>Actually, so I'm curious. Do you think that this result will be useful in proving the full theorem? I'm starting to get worried that a cycle induction strategy won't work.</p>",
        "id": 233036508,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1617487620
    },
    {
        "content": "<p>For two disjoint <code>perm</code>s, you could glue together <code>equiv</code>s between their supports with one between the rest of the elements</p>",
        "id": 233036522,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1617487635
    },
    {
        "content": "<p>I think it will work.</p>",
        "id": 233036524,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1617487641
    },
    {
        "content": "<p>Would that require passing permutations back and forth between subtypes? I'm worried that it might be a bit painful.</p>",
        "id": 233036605,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1617487685
    },
    {
        "content": "<p>Not more painful than the cycle proof, and I’m not sure I see a better option</p>",
        "id": 233036682,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1617487800
    },
    {
        "content": "<p>Is it conceivable that you could prove a lemma along these lines?</p>\n<p>Let a,b,c,d be permutations. Assume a and b are disjoint, c and d are disjoint, a is conjugate to c, b is conjugate to d. Then <code>a*b</code> is conjugate to <code>c*d</code>.</p>",
        "id": 233037036,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1617488165
    },
    {
        "content": "<p>Yes, that’s what I had in mind.</p>",
        "id": 233037051,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1617488188
    },
    {
        "content": "<p>If so, then you could make a plain induction work, without the need for any more subtype mess (outside of the proof of the lemma)</p>",
        "id": 233037071,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1617488206
    },
    {
        "content": "<p>I think the alternative is creating some other data structure that represents cycle notation</p>",
        "id": 233037096,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1617488255
    },
    {
        "content": "<p>I have that lemma proven at <a href=\"https://github.com/leanprover-community/mathlib/tree/disjoint_conj\">branch#disjoint_conj</a>.</p>",
        "id": 233113233,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1617570924
    },
    {
        "content": "<p>Again, messy, and I should really think more about how I'm going to organize all of these random permutation facts and long proofs, but the statement is there in case you want to <code>sorry</code> it and work on proving the <code>cycle_type</code> induction.</p>",
        "id": 233113407,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1617570986
    },
    {
        "content": "<p>Kevin just let me know about this stream! I've been doing some parallel/complementary work. I've been trying to make it possible to specify explicit perm cycles using lists. Here's a smattering of what I have:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">perm.commutes_of_disjoint</span> <span class=\"o\">(</span><span class=\"n\">e₁</span> <span class=\"n\">e₂</span> <span class=\"o\">:</span> <span class=\"n\">equiv.perm</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">_root_.disjoint</span> <span class=\"o\">(</span><span class=\"n\">function.fixed_points</span> <span class=\"n\">e₁</span><span class=\"o\">)</span><span class=\"bp\">ᶜ</span> <span class=\"o\">(</span><span class=\"n\">function.fixed_points</span> <span class=\"n\">e₂</span><span class=\"o\">)</span><span class=\"bp\">ᶜ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">commute</span> <span class=\"n\">e₁</span> <span class=\"n\">e₂</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">ext</span> <span class=\"n\">t</span><span class=\"o\">,</span>\n  <span class=\"n\">by_cases</span> <span class=\"n\">ht₁</span> <span class=\"o\">:</span> <span class=\"n\">function.is_fixed_pt</span> <span class=\"n\">e₁</span> <span class=\"n\">t</span><span class=\"bp\">;</span>\n  <span class=\"n\">by_cases</span> <span class=\"n\">ht₂</span> <span class=\"o\">:</span> <span class=\"n\">function.is_fixed_pt</span> <span class=\"n\">e₂</span> <span class=\"n\">t</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">ht₁.eq</span><span class=\"o\">,</span> <span class=\"n\">ht₂.eq</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">function.is_fixed_pt</span> <span class=\"n\">e₁</span> <span class=\"o\">(</span><span class=\"n\">e₂</span> <span class=\"n\">t</span><span class=\"o\">),</span>\n      <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">function.mem_fixed_points</span><span class=\"o\">,</span> <span class=\"bp\">←</span><span class=\"n\">set.not_mem_compl_iff</span><span class=\"o\">],</span>\n        <span class=\"n\">refine</span> <span class=\"n\">set.mem_disjoint_imp</span> <span class=\"n\">_</span> <span class=\"n\">h.symm</span><span class=\"o\">,</span>\n        <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">set.mem_compl_iff</span><span class=\"o\">,</span> <span class=\"n\">function.mem_fixed_points</span><span class=\"o\">],</span>\n        <span class=\"n\">contrapose</span><span class=\"bp\">!</span> <span class=\"n\">ht₂</span><span class=\"o\">,</span>\n        <span class=\"n\">rw</span> <span class=\"n\">function.is_fixed_pt</span> <span class=\"n\">at</span> <span class=\"n\">ht₂</span> <span class=\"bp\">⊢</span><span class=\"o\">,</span>\n        <span class=\"n\">apply</span> <span class=\"n\">e₂.injective</span><span class=\"o\">,</span>\n        <span class=\"n\">exact</span> <span class=\"n\">ht₂</span> <span class=\"o\">},</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">ht₁.eq</span><span class=\"o\">,</span> <span class=\"n\">this.eq</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"c1\">-- how does one use wlog to skip this?</span>\n    <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">function.is_fixed_pt</span> <span class=\"n\">e₂</span> <span class=\"o\">(</span><span class=\"n\">e₁</span> <span class=\"n\">t</span><span class=\"o\">),</span>\n      <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">function.mem_fixed_points</span><span class=\"o\">,</span> <span class=\"bp\">←</span><span class=\"n\">set.not_mem_compl_iff</span><span class=\"o\">],</span>\n        <span class=\"n\">refine</span> <span class=\"n\">set.mem_disjoint_imp</span> <span class=\"n\">_</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n        <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">set.mem_compl_iff</span><span class=\"o\">,</span> <span class=\"n\">function.mem_fixed_points</span><span class=\"o\">],</span>\n        <span class=\"n\">contrapose</span><span class=\"bp\">!</span> <span class=\"n\">ht₁</span><span class=\"o\">,</span>\n        <span class=\"n\">rw</span> <span class=\"n\">function.is_fixed_pt</span> <span class=\"n\">at</span> <span class=\"n\">ht₁</span> <span class=\"bp\">⊢</span><span class=\"o\">,</span>\n        <span class=\"n\">apply</span> <span class=\"n\">e₁.injective</span><span class=\"o\">,</span>\n        <span class=\"n\">exact</span> <span class=\"n\">ht₁</span> <span class=\"o\">},</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">ht₂.eq</span><span class=\"o\">,</span> <span class=\"n\">this.eq</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">exfalso</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">set.mem_inter</span> <span class=\"n\">ht₁</span> <span class=\"n\">ht₂</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">is_rotated</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"n\">l'</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"bp\">∃</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">l.rotate</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">l'</span>\n\n<span class=\"kd\">infixr</span> <span class=\"bp\">`</span> <span class=\"bp\">~</span><span class=\"n\">r</span> <span class=\"bp\">`</span><span class=\"o\">:</span><span class=\"mi\">1000</span> <span class=\"o\">:=</span> <span class=\"n\">is_rotated</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">cycle</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span> <span class=\"o\">:=</span> <span class=\"n\">quotient</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">is_rotated.setoid</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 233169334,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1617628039
    },
    {
        "content": "<p>With the goal of proving things like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">form_perm_rotation_invariant</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">nodup</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">form_perm</span> <span class=\"o\">(</span><span class=\"n\">l.rotate</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">form_perm</span> <span class=\"n\">l</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">is_cycle_form_perm</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">nodup</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">y</span> <span class=\"o\">::</span> <span class=\"n\">l</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n  <span class=\"n\">is_cycle</span> <span class=\"o\">(</span><span class=\"n\">form_perm</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">y</span> <span class=\"o\">::</span> <span class=\"n\">l</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 233169440,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1617628086
    },
    {
        "content": "<p>(not including a lot of API)</p>",
        "id": 233169457,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1617628096
    },
    {
        "content": "<p>Which, looking at your code, is similar to <code>cycle_type</code></p>",
        "id": 233169874,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1617628323
    },
    {
        "content": "<p>If you'd like any contribution or if you have any suggestions on refactoring, let me know!</p>",
        "id": 233171728,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1617629403
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/set.not_mem_compl_iff\">docs#set.not_mem_compl_iff</a> and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/set.mem_disjoint_imp\">docs#set.mem_disjoint_imp</a> seem not to exist</p>",
        "id": 233177150,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1617632199
    },
    {
        "content": "<p>Yeah, I just wanted to share a snippet of what I had.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">set.mem_disjoint_imp</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hd</span> <span class=\"o\">:</span> <span class=\"n\">disjoint</span> <span class=\"n\">s</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">x</span> <span class=\"bp\">∉</span> <span class=\"n\">t</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">ht</span><span class=\"o\">,</span> <span class=\"n\">hd</span> <span class=\"o\">(</span><span class=\"n\">set.mem_inter</span> <span class=\"n\">h</span> <span class=\"n\">ht</span><span class=\"o\">)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">set.not_mem_compl_iff</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∉</span> <span class=\"n\">s</span><span class=\"bp\">ᶜ</span> <span class=\"bp\">↔</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"n\">set.not_not_mem</span>\n</code></pre></div>",
        "id": 233178431,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1617632808
    },
    {
        "content": "<p>Hrm, I think that means we need to do a lot more coordination work, <span class=\"user-mention\" data-user-id=\"308899\">@Yakov Pechersky</span></p>",
        "id": 233182121,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1617634603
    },
    {
        "content": "<p>I'm not sure I see the benefit of this version of <code>perm.commutes_of_disjoint</code> over the existing proof of <code>perm.disjoint.mul_comm</code></p>",
        "id": 233182197,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1617634650
    },
    {
        "content": "<p>but if you can represent cycles as lists, then that probably means you can give a much more intuitive proof of the conjugacy results</p>",
        "id": 233182288,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1617634684
    },
    {
        "content": "<p>I haven't merged any of your branches -- just discovered them!</p>",
        "id": 233182479,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1617634800
    },
    {
        "content": "<p>Is there a particular PR or branch I should rebase on?</p>",
        "id": 233182635,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1617634822
    },
    {
        "content": "<p>I'm not sure, <code>equiv.perm.disjoint.mul_comm</code>is in master, just in the <code>group_theory.perm.sign</code> file, where it maybe shouldn't be</p>",
        "id": 233182818,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1617634856
    },
    {
        "content": "<p>Most of my random-helpful-lemmas are in <a href=\"https://github.com/leanprover-community/mathlib/tree/card_support_perm\">branch#card_support_perm</a></p>",
        "id": 233182938,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1617634879
    },
    {
        "content": "<p>which is <a href=\"https://github.com/leanprover-community/mathlib/issues/6951\">#6951</a></p>",
        "id": 233183139,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1617634920
    },
    {
        "content": "<p>but the work on <a href=\"https://github.com/leanprover-community/mathlib/tree/cycle_conj\">branch#cycle_conj</a> (<a href=\"https://github.com/leanprover-community/mathlib/issues/7024\">#7024</a>) which I've improved at <a href=\"https://github.com/leanprover-community/mathlib/tree/disjoint_conj\">branch#disjoint_conj</a> involves some subtype shenanigans and long composition chains of <code>equiv</code>s</p>",
        "id": 233183596,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1617635004
    },
    {
        "content": "<p>and the goal is just to prove the result that two permutations with the same cycle type are conjugate</p>",
        "id": 233183647,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1617635021
    },
    {
        "content": "<p>which is a 1-line proof on paper</p>",
        "id": 233183748,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1617635045
    },
    {
        "content": "<p>and it might be possible to get closer to that 1-line proof, and perhaps skip the induction, if you have both permutations represented as products of disjoint cycles which are represented as lists</p>",
        "id": 233183908,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1617635097
    },
    {
        "content": "<p>Yeah, and a perm cycle should be representable as </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">form_perm</span> <span class=\"o\">:</span> <span class=\"n\">equiv.perm</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">zip_with</span> <span class=\"n\">equiv.swap</span> <span class=\"n\">l</span> <span class=\"o\">(</span><span class=\"n\">l.rotate</span> <span class=\"mi\">1</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">tail.prod</span>\n</code></pre></div>",
        "id": 233184261,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1617635198
    },
    {
        "content": "<p>Where it behave as expected if <code>nodup l</code></p>",
        "id": 233184302,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1617635209
    },
    {
        "content": "<p>(Or just define it with <code>erase_dup</code> in there)</p>",
        "id": 233184351,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1617635224
    },
    {
        "content": "<p>Then disjointedness has to do with a statement about some sublists being disjoint or not</p>",
        "id": 233184423,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1617635247
    },
    {
        "content": "<p>I guess my question is</p>",
        "id": 233184579,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1617635287
    },
    {
        "content": "<p>If I give you two lists of disjoint cycles, with the cycles represented as lists, and the lists of the lengths of the cycles are the same, how hard might it be to define the equiv mapping from the ith element of the jth cycle of one list to the ith element of the jth cycle of the other list?</p>",
        "id": 233184985,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1617635404
    },
    {
        "content": "<p>Do you know that each of the cycle elements are paired in length?</p>",
        "id": 233185362,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1617635514
    },
    {
        "content": "<p>Yes, but I did a bad job of describing that condition.</p>",
        "id": 233185429,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1617635527
    },
    {
        "content": "<p>Then it's just a stacked zip_with</p>",
        "id": 233185440,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1617635535
    },
    {
        "content": "<p>I'm not sure I follow.  <code>list.zip_with</code> seems to be a tool for applying a binary function pointwise to two lists to get a third list.</p>",
        "id": 233185681,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1617635649
    },
    {
        "content": "<p>I'm trying to find a permutation <code>f</code> such that when I apply <code>list.map f</code> to every cycle element in the first list, I get the second list</p>",
        "id": 233185784,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1617635705
    },
    {
        "content": "<p>Because <code>list.map</code> will correspond to conjugation for a given cycle, as in lemma <code>conjugation_of_cycle</code> at <a href=\"https://isabelle.in.tum.de/website-Isabelle2018/dist/library/HOL/HOL-Algebra/Cycles.html\">https://isabelle.in.tum.de/website-Isabelle2018/dist/library/HOL/HOL-Algebra/Cycles.html</a></p>",
        "id": 233186004,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1617635790
    },
    {
        "content": "<p>My first question is when you say \"list of cycles\" you mean <code>{ l : list (equiv.perm α) // ∀ p ∈ l, is_cycle p }</code>?</p>",
        "id": 233186761,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1617636018
    },
    {
        "content": "<p>I mean an element of that, yes, or else a list of lists, such that each element represents a disjoint cycle (so I suppose, a list such that if you concatenated all the elements it'd be <code>nodup</code>)</p>",
        "id": 233186926,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1617636088
    },
    {
        "content": "<p>Right. So I think trying to map element to element will be wonky because of the rotational invariance</p>",
        "id": 233186982,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1617636123
    },
    {
        "content": "<p>So, if you have to map element to element, then you have to escape the rotational invariance, probably via choosing the lexicographically smallest representation of that cycle</p>",
        "id": 233187066,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1617636158
    },
    {
        "content": "<p>I think we can get around that. I don't need this to be computable, although having a computable version under extra assumptions would potentially be useful.</p>",
        "id": 233187186,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1617636224
    },
    {
        "content": "<p>Ah. My goal has precisely been computability here, which is why I've been building \"bottom-up\" from lists</p>",
        "id": 233187458,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1617636323
    },
    {
        "content": "<p>Yeah, I can tell... that's why I tried to phrase it in terms of assuming we already have two lists of lists, rather than two lists of cycles.</p>",
        "id": 233187543,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1617636363
    },
    {
        "content": "<p>Assuming we've already got past that choice hurdle.</p>",
        "id": 233187610,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1617636375
    },
    {
        "content": "<p>There's still going to have to be choice involved, in order to map the fixed points of one permutation to the other.</p>",
        "id": 233187675,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1617636398
    },
    {
        "content": "<p>One conclusion I have is that I should probably recall (or reduce the scope of) <a href=\"https://github.com/leanprover-community/mathlib/issues/7024\">#7024</a></p>",
        "id": 233188007,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1617636556
    },
    {
        "content": "<p>I'm not too familiar with HOL syntax. Is this describing that conjugating a [perm represented by disjoint cycles] by a perm is equal to [perm represented by disjoint cycles, [each trans that perm]]?</p>",
        "id": 233188597,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1617636816
    },
    {
        "content": "<p>I believe it’s more like [perm represented by disjoint cycles, [each <code>list.map</code>ped by that perm]</p>",
        "id": 233189211,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1617637079
    },
    {
        "content": "<p>Proving that should probably be easy enough, but proving sufficient conditions for there to exist a perm that does that particular conjugation is harder</p>",
        "id": 233189415,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1617637177
    },
    {
        "content": "<p>Right, each of the disjoint cycles is conjugated by that perm, if I understand correctly</p>",
        "id": 233189790,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1617637337
    },
    {
        "content": "<p>So can't you prove that it's the case for one, so it's the care for all?</p>",
        "id": 233189822,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1617637356
    },
    {
        "content": "<p>(which is your \"easy to prove\" statement)</p>",
        "id": 233189855,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1617637368
    },
    {
        "content": "<p>Actually, I have an idea for how to do the harder statement. To construct such a permutation, we first concatenate both lists of lists, and then pad them both with all the fixed points (using <code>list.filter</code> or something) so that the domain of our permutations is listed out twice. Then, using <code>fintype.equiv_fin.of_forall_mem_list</code>, we can construct a permutation that sends the <code>i</code>th entry of one list to the <code>i</code>th entry of the other.</p>",
        "id": 233205059,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1617644857
    },
    {
        "content": "<p>Why should <code>perm.support</code> be defined solely for <code>fintype</code>?</p>",
        "id": 233251623,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1617670501
    },
    {
        "content": "<p>Because re-reading the code, I see that my <code>commute</code> lemma above works for non-fintype too.</p>",
        "id": 233252212,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1617671029
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"308899\">@Yakov Pechersky</span> In general, the support of a permutation won't be a finset. But I suppose you could try to refactor support to be a set.</p>",
        "id": 233264799,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1617682850
    },
    {
        "content": "<p>Yes, agreed that it can often be nonfinite. I have already started on the refactor</p>",
        "id": 233264904,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1617682950
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"253861\">@Thomas Browning</span>,  I have just one sorry at <a href=\"https://github.com/leanprover-community/mathlib/tree/disjoint_conj\">branch#disjoint_conj</a> required to prove that the same cycle type implies conjugacy.</p>",
        "id": 234251207,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1618274202
    },
    {
        "content": "<p>We just need to show that if the cycle type of a permutation is <code>m1 + m2</code>, then it can be expressed as a product of disjoint permutations with cycle types <code>m1</code> and <code>m2</code>.</p>",
        "id": 234251267,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1618274240
    },
    {
        "content": "<p>Given as you wrote up <code>cycle_type</code>, do you have any insight into what kind of (possibly induction) we want to do?</p>",
        "id": 234251282,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1618274264
    },
    {
        "content": "<p>Can you induct on sigma, after reverting m1 and m2?</p>",
        "id": 234252292,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1618275087
    },
    {
        "content": "<p>I think I’m finding that <code>cycle_induction_on</code> should allow you to assume that one of your two disjoint permutations is a cycle. I keep trying to use <code>trunc_cycle_factors</code> to get that...</p>",
        "id": 234351068,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1618328707
    },
    {
        "content": "<p>Ah, so would changing the induction lemma to this be better:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[elab_as_eliminator]</span> <span class=\"kd\">lemma</span> <span class=\"n\">cycle_induction_on</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">perm</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"n\">perm</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">base_one</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">base_cycles</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"n\">perm</span> <span class=\"n\">β</span><span class=\"o\">,</span> <span class=\"n\">σ.is_cycle</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"n\">σ</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">induction_disjoint</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">σ</span> <span class=\"n\">τ</span> <span class=\"o\">:</span> <span class=\"n\">perm</span> <span class=\"n\">β</span><span class=\"o\">,</span> <span class=\"n\">σ.is_cycle</span> <span class=\"bp\">→</span> <span class=\"n\">disjoint</span> <span class=\"n\">σ</span> <span class=\"n\">τ</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"n\">σ</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"n\">τ</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"bp\">*</span> <span class=\"n\">τ</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n  <span class=\"n\">P</span> <span class=\"n\">σ</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">suffices</span> <span class=\"o\">:</span>\n    <span class=\"bp\">∀</span> <span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">perm</span> <span class=\"n\">β</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">τ</span> <span class=\"o\">:</span> <span class=\"n\">perm</span> <span class=\"n\">β</span><span class=\"o\">,</span> <span class=\"n\">τ</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span> <span class=\"bp\">→</span> <span class=\"n\">τ.is_cycle</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">l.pairwise</span> <span class=\"n\">disjoint</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"n\">l.prod</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">classical</span><span class=\"o\">,</span>\n    <span class=\"k\">let</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">σ.trunc_cycle_factors.out</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">congr_arg</span> <span class=\"n\">P</span> <span class=\"n\">x.2.1</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"o\">(</span><span class=\"n\">this</span> <span class=\"n\">x.1</span> <span class=\"n\">x.2.2.1</span> <span class=\"n\">x.2.2.2</span><span class=\"o\">)</span> <span class=\"o\">},</span>\n  <span class=\"n\">intro</span> <span class=\"n\">l</span><span class=\"o\">,</span>\n  <span class=\"n\">induction</span> <span class=\"n\">l</span> <span class=\"k\">with</span> <span class=\"n\">σ</span> <span class=\"n\">l</span> <span class=\"n\">ih</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">base_one</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">h1</span> <span class=\"n\">h2</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">list.prod_cons</span><span class=\"o\">,</span>\n    <span class=\"n\">refine</span> <span class=\"n\">induction_disjoint</span> <span class=\"n\">σ</span> <span class=\"n\">l.prod</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"n\">σ</span> <span class=\"o\">(</span><span class=\"n\">l.mem_cons_self</span> <span class=\"n\">σ</span><span class=\"o\">))</span>\n      <span class=\"o\">(</span><span class=\"n\">disjoint_prod_list_of_disjoint</span> <span class=\"o\">(</span><span class=\"n\">list.pairwise_cons.mp</span> <span class=\"n\">h2</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n      <span class=\"o\">(</span><span class=\"n\">base_cycles</span> <span class=\"n\">σ</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"n\">σ</span> <span class=\"o\">(</span><span class=\"n\">l.mem_cons_self</span> <span class=\"n\">σ</span><span class=\"o\">)))</span>\n      <span class=\"o\">(</span><span class=\"n\">ih</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">τ</span> <span class=\"n\">hτ</span><span class=\"o\">,</span> <span class=\"n\">h1</span> <span class=\"n\">τ</span> <span class=\"o\">(</span><span class=\"n\">list.mem_cons_of_mem</span> <span class=\"n\">σ</span> <span class=\"n\">hτ</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">list.pairwise_of_pairwise_cons</span> <span class=\"n\">h2</span><span class=\"o\">))</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 234359803,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1618331792
    },
    {
        "content": "<p>Yeah, I think so.</p>",
        "id": 234377470,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1618338508
    },
    {
        "content": "<p>I've made a lot of headway on constructable cycles via lists, like proving</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">is_cycle_form_perm</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">nodup</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">y</span> <span class=\"o\">::</span> <span class=\"n\">xs</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n  <span class=\"n\">is_cycle</span> <span class=\"o\">(</span><span class=\"n\">form_perm</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">y</span> <span class=\"o\">::</span> <span class=\"n\">xs</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n</code></pre></div>\n<p><a href=\"https://github.com/leanprover-community/mathlib/commit/e7ffca5fffc981a097e0fdf1285977aae78216d9#diff-9c65c703978eccccaa9dcbcc614d775ffe4a39aac3347edb1f88c5c12b403cd4R784\">https://github.com/leanprover-community/mathlib/commit/e7ffca5fffc981a097e0fdf1285977aae78216d9#diff-9c65c703978eccccaa9dcbcc614d775ffe4a39aac3347edb1f88c5c12b403cd4R784</a></p>",
        "id": 234412450,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1618353345
    },
    {
        "content": "<p>As well as</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">form_perm_reverse</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">nodup</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">form_perm</span> <span class=\"n\">l.reverse</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">form_perm</span> <span class=\"n\">l</span><span class=\"o\">)</span><span class=\"bp\">⁻¹</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">form_perm_rotate</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">nodup</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">form_perm</span> <span class=\"o\">(</span><span class=\"n\">l.rotate</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">form_perm</span> <span class=\"n\">l</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">support_form_perm_of_nodup</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">nodup</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h'</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">l</span> <span class=\"bp\">≠</span> <span class=\"o\">[</span><span class=\"n\">x</span><span class=\"o\">])</span> <span class=\"o\">:</span>\n  <span class=\"n\">support</span> <span class=\"o\">(</span><span class=\"n\">form_perm</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">l.to_finset</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 234412578,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1618353406
    }
]
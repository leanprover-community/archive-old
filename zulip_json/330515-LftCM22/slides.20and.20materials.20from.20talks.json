[
    {
        "content": "<p>Link for the Natural Number Game:<br>\n<a href=\"https://www.ma.imperial.ac.uk/~buzzard/xena/natural_number_game/\">https://www.ma.imperial.ac.uk/~buzzard/xena/natural_number_game/</a></p>",
        "id": 289199313,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1657550058
    },
    {
        "content": "<p>Here's the lean file that I used for my introductory presentation: <br>\n<a href=\"/user_uploads/3121/FH-WjYCqNEU72KOyUvz6qt5q/introduction.lean\">introduction.lean</a><br>\nIf you have a Lean project installed (for example, the Mathematics in Lean repository), you can just drop it in the <code>src</code> folder and then open it in VS Code.</p>",
        "id": 289199815,
        "sender_full_name": "Jeremy Avigad",
        "timestamp": 1657550284
    },
    {
        "content": "<p>After Kevin's talk, we’ll arrange Zoom breakout rooms for any virtual participants who would like to work on the Natural Number Game with a partner and/or tutor.  Let me know if you would like to be put in a breakout room.</p>",
        "id": 289203307,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1657551641
    },
    {
        "content": "<p>Oops, the Zoom room closed. If anyone is watching, it will be back shortly!</p>",
        "id": 289210490,
        "sender_full_name": "Jake Levinson",
        "timestamp": 1657554323
    },
    {
        "content": "<p>Sorry everyone, the Zoom meeting was briefly cut off, bringing it back!</p>",
        "id": 289210504,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1657554327
    },
    {
        "content": "<p>(for breakout rooms)</p>",
        "id": 289210510,
        "sender_full_name": "Jake Levinson",
        "timestamp": 1657554329
    },
    {
        "content": "<p>Zoom meeting is live again but you'll need to log in.</p>",
        "id": 289210818,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1657554440
    },
    {
        "content": "<p>Somebody can explain how to get the demos 02_Basics that Johan is using on screen on his talk right now ?</p>",
        "id": 289320102,
        "sender_full_name": "Alba Marina MÁLAGA SABOGAL",
        "timestamp": 1657631144
    },
    {
        "content": "<p>The file we see now will be put here later. But you should definitely get the Mathematics in Lean book.</p>",
        "id": 289320364,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1657631258
    },
    {
        "content": "<p>see <a href=\"#narrow/stream/330515-LftCM22/topic/Installation/near/289244517\">https://leanprover.zulipchat.com/#narrow/stream/330515-LftCM22/topic/Installation/near/289244517</a></p>",
        "id": 289320411,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1657631282
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 289342018,
        "sender_full_name": "Ryan McCorvie",
        "timestamp": 1657639856
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"513544\">@Alba Marina MÁLAGA SABOGAL</span> I pushed it here: <a href=\"#narrow/stream/330515-LftCM22/topic/Basics.20Demo\">https://leanprover.zulipchat.com/#narrow/stream/330515-LftCM22/topic/Basics.20Demo</a></p>",
        "id": 289342084,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1657639882
    },
    {
        "content": "<p>Here are the slides from the logic session:<br>\n<a href=\"/user_uploads/3121/7C-nI41ocD88dBwtFlQDQMzS/logic.lean\">logic.lean</a></p>",
        "id": 289342429,
        "sender_full_name": "Jeremy Avigad",
        "timestamp": 1657640035
    },
    {
        "content": "<p>Oh sorry! Here are my slides from yesterday. Sorry not to post them earlier. <a href=\"/user_uploads/3121/dH5FiTmu6FYTwdK7YMc5iIe9/talk.pdf\">talk.pdf</a> </p>\n<p>and here are the files I used in the demo:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- import all the tactics</span>\n<span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n<span class=\"c1\">-- import the definition of the degree of a polynomial</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.polynomial.degree</span>\n\n<span class=\"c1\">-- use the usual notation `k[X]` for polynomials over `k`</span>\n<span class=\"n\">open_locale</span> <span class=\"n\">polynomial</span>\n\n<span class=\"c1\">-- want to type `degree` not `polynomial.degree`</span>\n<span class=\"kn\">open</span> <span class=\"n\">polynomial</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">degree</span> <span class=\"o\">((</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">])</span><span class=\"bp\">^</span><span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">library_search</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- comment out the below lines to see various other ways that lean can display info</span>\n\n<span class=\"c1\">--set_option pp.notation false</span>\n\n<span class=\"c1\">--set_option pp.parens true</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">z</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span> <span class=\"bp\">+</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span> <span class=\"bp\">+</span> <span class=\"n\">y</span> <span class=\"bp\">↔</span> <span class=\"mi\">2</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"mi\">5</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">h3</span> <span class=\"o\">:</span> <span class=\"n\">y</span> <span class=\"bp\">+</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">h4</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span> <span class=\"bp\">+</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">z</span> <span class=\"bp\">→</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span> <span class=\"bp\">+</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span> <span class=\"bp\">+</span> <span class=\"n\">y</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"c1\">-- you can experiment with rewrites here</span>\n  <span class=\"gr\">sorry</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"c1\">-- composite of injective functions is injective</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"n\">Z</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">Y</span> <span class=\"bp\">→</span> <span class=\"n\">Z</span><span class=\"o\">)</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">function</span>\n\n<span class=\"c1\">-- example to show that `apply` is like arguing backwards.</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">injective</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">hg</span> <span class=\"o\">:</span> <span class=\"n\">injective</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">injective</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"bp\">∘</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"c1\">-- What's the maths proof?</span>\n  <span class=\"c1\">-- x₁ and x₂ in X</span>\n  <span class=\"c1\">-- know g(f(x₁))=g(f(x₂))</span>\n  <span class=\"c1\">-- injectivity of g implies f(x₁)=f(x₂)</span>\n  <span class=\"c1\">-- injectivity of f says x₁ = x₂</span>\n  <span class=\"c1\">-- so done</span>\n  <span class=\"c1\">-- Mathematicians move a hypothesis towards the goal.</span>\n  <span class=\"n\">intros</span> <span class=\"n\">x₁</span> <span class=\"n\">x₂</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">hf</span><span class=\"o\">,</span> <span class=\"c1\">-- apply injectivity of f first??</span>\n  <span class=\"n\">apply</span> <span class=\"n\">hg</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"c1\">-- We moved the goal towards the hypothesis with `apply`</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.real.basic</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">refl</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"c1\">-- refl, -- fails because it's not definitional this way around!</span>\n  <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">z</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n<span class=\"c1\">--  rw h, -- fails because rw works up to syntactic equality</span>\n  <span class=\"n\">change</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"c1\">-- change works up to definitional equality</span>\n<span class=\"c1\">--  rw add_zero at h, -- would also work; note that the proof of `add_zero` is `refl`.</span>\n  <span class=\"n\">rw</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"c1\">-- now it works</span>\n  <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 289346807,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1657641647
    },
    {
        "content": "<p>I had actually prepared a few more examples for my talk, including some power-user moves. I added the examples to the file <code>logic.lean</code> attached here, as well as cut-and-pasted here. <br>\n<a href=\"/user_uploads/3121/lVvaXUkQo2OPY3pZw506iGlL/logic.lean\">logic.lean</a></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">More examples.</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"kn\">section</span>\n<span class=\"kd\">variables</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n<span class=\"kd\">variables</span> <span class=\"n\">r</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">∧</span> <span class=\"n\">q</span> <span class=\"bp\">→</span> <span class=\"n\">q</span> <span class=\"bp\">∧</span> <span class=\"n\">p</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">h</span> <span class=\"k\">with</span> <span class=\"n\">h1</span> <span class=\"n\">h2</span><span class=\"o\">,</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">h2</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">h1</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">∧</span> <span class=\"n\">q</span> <span class=\"bp\">→</span> <span class=\"n\">q</span> <span class=\"bp\">∧</span> <span class=\"n\">p</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">h.right</span><span class=\"o\">,</span> <span class=\"n\">h.left</span><span class=\"o\">⟩</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">∧</span> <span class=\"n\">q</span> <span class=\"bp\">→</span> <span class=\"n\">q</span> <span class=\"bp\">∧</span> <span class=\"n\">p</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">and.intro</span> <span class=\"n\">h.right</span> <span class=\"n\">h.left</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">∧</span> <span class=\"n\">q</span> <span class=\"bp\">→</span> <span class=\"n\">q</span> <span class=\"bp\">∧</span> <span class=\"n\">p</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rintros</span> <span class=\"o\">⟨</span><span class=\"n\">h1</span><span class=\"o\">,</span> <span class=\"n\">h2</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">h2</span><span class=\"o\">,</span> <span class=\"n\">h1</span><span class=\"o\">⟩</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">∧</span> <span class=\"n\">q</span> <span class=\"bp\">→</span> <span class=\"n\">q</span> <span class=\"bp\">∧</span> <span class=\"n\">p</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"o\">⟨</span><span class=\"n\">h1</span><span class=\"o\">,</span> <span class=\"n\">h2</span><span class=\"o\">⟩,</span> <span class=\"o\">⟨</span><span class=\"n\">h2</span><span class=\"o\">,</span> <span class=\"n\">h1</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">∧</span> <span class=\"n\">q</span> <span class=\"bp\">→</span> <span class=\"n\">q</span> <span class=\"bp\">∧</span> <span class=\"n\">p</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">rwa</span> <span class=\"n\">and_comm</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">∧</span> <span class=\"n\">q</span> <span class=\"bp\">→</span> <span class=\"n\">q</span> <span class=\"bp\">∧</span> <span class=\"n\">p</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">tauto</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">∧</span> <span class=\"n\">q</span> <span class=\"bp\">→</span> <span class=\"n\">q</span> <span class=\"bp\">∧</span> <span class=\"n\">p</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">finish</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"n\">q</span> <span class=\"bp\">→</span> <span class=\"n\">q</span> <span class=\"bp\">∨</span> <span class=\"n\">p</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">h</span> <span class=\"k\">with</span> <span class=\"n\">hp</span> <span class=\"n\">hq</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">right</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">hp</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">left</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">hq</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"n\">x</span> <span class=\"bp\">∧</span> <span class=\"n\">s</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">s</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">h</span> <span class=\"k\">with</span> <span class=\"n\">x</span> <span class=\"n\">hx</span><span class=\"o\">,</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">use</span> <span class=\"o\">[</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hx.left</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">use</span> <span class=\"o\">[</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hx.right</span><span class=\"o\">]</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"n\">x</span> <span class=\"bp\">∧</span> <span class=\"n\">s</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">s</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rintros</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hx1</span><span class=\"o\">,</span> <span class=\"n\">hx2</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">use</span> <span class=\"o\">[</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hx1</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hx2</span><span class=\"o\">]</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"n\">x</span> <span class=\"bp\">∧</span> <span class=\"n\">s</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">s</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">finish</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"n\">x</span> <span class=\"bp\">∧</span> <span class=\"n\">s</span> <span class=\"n\">y</span> <span class=\"bp\">∧</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"n\">x</span> <span class=\"bp\">∧</span> <span class=\"n\">s</span> <span class=\"n\">z</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rintros</span> <span class=\"n\">z</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">rx</span><span class=\"o\">,</span> <span class=\"n\">sy</span><span class=\"o\">,</span> <span class=\"n\">heq</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">use</span> <span class=\"o\">[</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">rx</span><span class=\"o\">],</span>\n  <span class=\"n\">rwa</span> <span class=\"bp\">←</span><span class=\"n\">heq</span>\n  <span class=\"c1\">-- or:</span>\n  <span class=\"c1\">-- rw ←heq</span>\n  <span class=\"c1\">-- exact sy</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"n\">x</span> <span class=\"bp\">∧</span> <span class=\"n\">s</span> <span class=\"n\">y</span> <span class=\"bp\">∧</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"n\">x</span> <span class=\"bp\">∧</span> <span class=\"n\">s</span> <span class=\"n\">z</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rintros</span> <span class=\"n\">z</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">rx</span><span class=\"o\">,</span> <span class=\"n\">sy</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">use</span> <span class=\"o\">[</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">rx</span><span class=\"o\">,</span> <span class=\"n\">sy</span><span class=\"o\">]</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"n\">x</span> <span class=\"bp\">∧</span> <span class=\"n\">s</span> <span class=\"n\">y</span> <span class=\"bp\">∧</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"n\">x</span> <span class=\"bp\">∧</span> <span class=\"n\">s</span> <span class=\"n\">z</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">finish</span>\n\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 289348632,
        "sender_full_name": "Jeremy Avigad",
        "timestamp": 1657642422
    },
    {
        "content": "<p>I'm talking about structures and classes in 12 minutes. My goal is to keep the talk short and let you work on exercises, so here's a problem sheet! I'll post my finished demo code after the talk -- most of it will be filled in as I go. <a href=\"/user_uploads/3121/0wKWfJb7X3uwVvYGOViibyH_/structures_exercises.lean\">structures_exercises.lean</a></p>",
        "id": 289453803,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1657716532
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.rat.defs</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.nat.parity</span>\n<span class=\"kn\">import</span> <span class=\"n\">tactic.basic</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">!</span>\n\n<span class=\"cm\">Most of these exercises are adapted from the LftCM 2020 exercises:</span>\n<span class=\"cm\">&lt;https://github.com/leanprover-community/lftcm2020/blob/master/src/exercises_sources/wednesday/structures.lean&gt;</span>\n\n\n<span class=\"cm\">-/</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">nat</span>\n\n<span class=\"kd\">noncomputable theory</span> <span class=\"c1\">-- definitions are allowed to not compute in this file</span>\n<span class=\"n\">open_locale</span> <span class=\"n\">classical</span> <span class=\"c1\">-- use classical logic in this file</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">!</span>\n<span class=\"cm\">## Structures and Classes</span>\n\n<span class=\"cm\">In this session we will discuss structures together,</span>\n<span class=\"cm\">and then you can solve the exercises yourself.</span>\n\n\n<span class=\"cm\">### Declaring a Structure</span>\n<span class=\"cm\">-/</span>\n\n\n\n<span class=\"c\">/-</span><span class=\"cm\">!</span>\n<span class=\"cm\">  ### Exercise: a simple structure</span>\n<span class=\"cm\">  * Define a structure of eventually constant sequences `ℕ → ℕ`. The first field will be</span>\n<span class=\"cm\">    `seq : ℕ → ℕ`, and the second field will be the statement that `seq` is eventually constant.</span>\n<span class=\"cm\">  * Define a structure of a type with 2 points that are unequal.</span>\n<span class=\"cm\">    (hint: omit the type of the structure, Lean might complain if you give it explicitly)</span>\n\n<span class=\"cm\">  Lean will not tell you if you got the right definition, but it will complain if you make a syntax</span>\n<span class=\"cm\">  error. If you are unsure, ask a mentor to check whether your solution is correct.</span>\n<span class=\"cm\">-/</span>\n\n\n<span class=\"c\">/-</span><span class=\"cm\">!</span>\n<span class=\"cm\">  ### Exercise: manipulating structure elements</span>\n\n<span class=\"cm\">Here we give the upper bounds for a function `f`. We can omit the type of the structure. -/</span>\n<span class=\"kd\">structure</span> <span class=\"n\">bounds</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">bound</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">le_bound</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"n\">n</span> <span class=\"bp\">≤</span> <span class=\"n\">bound</span><span class=\"o\">)</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">! You can use `#print` to print the type and all fields of a structure. -/</span>\n\n<span class=\"k\">#print</span> <span class=\"n\">bounds</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">!</span>\n<span class=\"cm\">  * Define `bounds` (given above) again, but now using a the subtype notation `{ _ : _ // _ }`.</span>\n<span class=\"cm\">  * Define functions back and forth from the structure `bounds` given above and `bounds` given here.</span>\n<span class=\"cm\">    Try different variations using the anonymous constructor and the projection notation.</span>\n<span class=\"cm\">-/</span>\n\n\n<span class=\"kd\">def</span> <span class=\"n\">bounds'</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span>\n<span class=\"gr\">sorry</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">bounds</span> <span class=\"n\">f</span> <span class=\"bp\">→</span> <span class=\"n\">bounds'</span> <span class=\"n\">f</span> <span class=\"o\">:=</span>\n<span class=\"gr\">sorry</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> In the example below, replace the `sorry` by an underscore `_`.</span>\n<span class=\"cm\">  A small yellow lightbulb will appear. Click it, and then select</span>\n<span class=\"cm\">  `Generate skeleton for the structure under construction`.</span>\n<span class=\"cm\">  This will automatically give an outline of the structure for you. -/</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">bounds'</span> <span class=\"n\">f</span> <span class=\"bp\">→</span> <span class=\"n\">bounds</span> <span class=\"n\">f</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"gr\">sorry</span>\n\n\n\n\n<span class=\"c\">/-</span><span class=\"cm\">! ### Exercise: Bijections and equivalences -/</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">bijections</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">function</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">An important structure is the type of equivalences, which gives an equivalence (bijection)</span>\n<span class=\"cm\">between two types:</span>\n</code></pre></div>\n<p>structure equiv (α β : Type*) :=<br>\n(to_fun    : α → β)<br>\n(inv_fun   : β → α)<br>\n(left_inv  : left_inverse inv_fun to_fun)<br>\n(right_inv : right_inverse inv_fun to_fun)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">In</span> <span class=\"n\">this</span> <span class=\"kn\">section</span> <span class=\"n\">we</span> <span class=\"k\">show</span> <span class=\"n\">that</span> <span class=\"n\">this</span> <span class=\"n\">is</span> <span class=\"n\">the</span> <span class=\"n\">same</span> <span class=\"n\">as</span> <span class=\"n\">the</span> <span class=\"n\">bijections</span> <span class=\"k\">from</span> <span class=\"bp\">`</span><span class=\"n\">α</span><span class=\"bp\">`</span> <span class=\"n\">to</span> <span class=\"bp\">`</span><span class=\"n\">β</span><span class=\"bp\">`.</span>\n<span class=\"bp\">-/</span>\n<span class=\"k\">#print</span> <span class=\"n\">equiv</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">bijection</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">to_fun</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">injective</span> <span class=\"o\">:</span> <span class=\"n\">injective</span> <span class=\"n\">to_fun</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">surjective</span> <span class=\"o\">:</span> <span class=\"n\">surjective</span> <span class=\"n\">to_fun</span><span class=\"o\">)</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> We declare a *coercion*. This allows us to treat `f` as a function if `f : bijection α β`. -/</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_coe_to_fun</span> <span class=\"o\">(</span><span class=\"n\">bijection</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">f.to_fun</span><span class=\"o\">⟩</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">! To show that two bijections are equal, it is sufficient that the underlying functions are</span>\n<span class=\"cm\">  equal on all inputs. We mark it as `@[ext]` so that we can later use the tactic `ext` to show that</span>\n<span class=\"cm\">  two bijections are equal. -/</span>\n<span class=\"kd\">@[ext]</span> <span class=\"kd\">def</span> <span class=\"n\">bijection.ext</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">bijection</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hfg</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">cases</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">cases</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">congr</span><span class=\"o\">,</span> <span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">hfg</span> <span class=\"n\">x</span> <span class=\"o\">}</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">! This lemma allows `simp` to reduce the application of a bijection to an argument. -/</span>\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">coe_mk</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">h1f</span> <span class=\"o\">:</span> <span class=\"n\">injective</span> <span class=\"n\">f</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">h2f</span> <span class=\"o\">:</span> <span class=\"n\">surjective</span> <span class=\"n\">f</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"o\">{</span> <span class=\"n\">bijection</span> <span class=\"bp\">.</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">injective</span> <span class=\"o\">:=</span> <span class=\"n\">h1f</span><span class=\"o\">,</span> <span class=\"n\">surjective</span> <span class=\"o\">:=</span> <span class=\"n\">h2f</span> <span class=\"o\">}</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> There is a lemma in the library that almost states this.</span>\n<span class=\"cm\">  You can use the tactic `suggest` to get suggested lemmas from Lean</span>\n<span class=\"cm\">  (the one you want has `bijective` in the name). -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">equiv_of_bijection</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">bijection</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">≃</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"gr\">sorry</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">bijection_of_equiv</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">≃</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">bijection</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n<span class=\"gr\">sorry</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">! Show that bijections are the same (i.e. equivalent) to equivalences. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">bijection_equiv_equiv</span> <span class=\"o\">:</span> <span class=\"n\">bijection</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"bp\">≃</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">≃</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"gr\">sorry</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">bijections</span>\n\n\n\n<span class=\"c\">/-</span><span class=\"cm\">! ### Exercise: Bundled groups -/</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">! Below is a possible definition of a group in Lean.</span>\n<span class=\"cm\">  It's not the definition we use use in mathlib. The actual definition uses classes. -/</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">Group</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">→</span> <span class=\"n\">G</span> <span class=\"bp\">→</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"kd\">infix</span> <span class=\"bp\">*</span> <span class=\"o\">:=</span> <span class=\"n\">op</span><span class=\"o\">)</span> <span class=\"c1\">-- temporary notation `*` for `op`, just inside this structure declaration</span>\n  <span class=\"o\">(</span><span class=\"n\">op_assoc'</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"bp\">*</span> <span class=\"n\">z</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">id</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"kd\">notation</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"n\">id</span><span class=\"o\">)</span> <span class=\"c1\">-- temporary notation `1` for `id`, just inside this structure declaration</span>\n  <span class=\"o\">(</span><span class=\"n\">id_op'</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">),</span> <span class=\"mi\">1</span> <span class=\"bp\">*</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">inv</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">→</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"kd\">postfix</span> <span class=\"bp\">⁻¹</span> <span class=\"o\">:=</span> <span class=\"n\">inv</span><span class=\"o\">)</span> <span class=\"c1\">-- temporary notation `⁻¹` for `inv`, just inside this structure declaration</span>\n  <span class=\"o\">(</span><span class=\"n\">op_left_inv'</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">),</span> <span class=\"n\">x</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">*</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">! You can use the `extend` command to define a structure that adds fields</span>\n<span class=\"cm\">  to one or more existing structures. -/</span>\n<span class=\"kd\">structure</span> <span class=\"n\">CommGroup</span> <span class=\"kd\">extends</span> <span class=\"n\">Group</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"kd\">infix</span> <span class=\"bp\">*</span> <span class=\"o\">:=</span> <span class=\"n\">op</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">op_comm</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">),</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">y</span> <span class=\"bp\">*</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> Here is an example: the rationals form a group under addition. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">rat_Group</span> <span class=\"o\">:</span> <span class=\"n\">Group</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">G</span> <span class=\"o\">:=</span> <span class=\"n\">ℚ</span><span class=\"o\">,</span>\n  <span class=\"n\">op</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">+</span><span class=\"o\">),</span> <span class=\"c1\">-- you can put parentheses around an infix operation to talk about the operation itself.</span>\n  <span class=\"n\">op_assoc'</span> <span class=\"o\">:=</span> <span class=\"n\">add_assoc</span><span class=\"o\">,</span>\n  <span class=\"n\">id</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span><span class=\"o\">,</span>\n  <span class=\"n\">id_op'</span> <span class=\"o\">:=</span> <span class=\"n\">zero_add</span><span class=\"o\">,</span>\n  <span class=\"n\">inv</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"bp\">-</span><span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"n\">op_left_inv'</span> <span class=\"o\">:=</span> <span class=\"n\">neg_add_self</span> <span class=\"o\">}</span>\n\n<span class=\"sd\">/-- You can extend an object of a structure by using the structure notation and using</span>\n<span class=\"sd\">  `..&lt;existing object&gt;`. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">rat_CommGroup</span> <span class=\"o\">:</span> <span class=\"n\">CommGroup</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">G</span> <span class=\"o\">:=</span> <span class=\"n\">ℚ</span><span class=\"o\">,</span> <span class=\"n\">op_comm</span> <span class=\"o\">:=</span> <span class=\"n\">add_comm</span><span class=\"o\">,</span> <span class=\"bp\">..</span><span class=\"n\">rat_Group</span> <span class=\"o\">}</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">Group</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">Group</span><span class=\"o\">}</span> <span class=\"c\">/-</span><span class=\"cm\"> Let `G` be a group -/</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> The following line declares that if `G : Group`, then we can also view `G` as a type. -/</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_coe_to_sort</span> <span class=\"n\">Group</span> <span class=\"o\">(</span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">Group.G</span><span class=\"o\">⟩</span>\n<span class=\"c\">/-</span><span class=\"cm\"> The following lines declare the notation `*`, `⁻¹` and `1` for the fields of `Group`. -/</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_mul</span> <span class=\"n\">G</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">G.op</span><span class=\"o\">⟩</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_inv</span> <span class=\"n\">G</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">G.inv</span><span class=\"o\">⟩</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_one</span> <span class=\"n\">G</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">G.id</span><span class=\"o\">⟩</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> the axioms for groups are satisfied -/</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">op_assoc</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"bp\">*</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">G.op_assoc'</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">id_op</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">*</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">G.id_op'</span> <span class=\"n\">x</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">op_left_inv</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">*</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"n\">G.op_left_inv'</span> <span class=\"n\">x</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> Use the axioms `op_assoc`, `id_op` and `op_left_inv` to prove the following lemma.</span>\n<span class=\"cm\">  The fields `op_assoc'`, `id_op'` and `op_left_inv'` should not be used directly, nor can you use</span>\n<span class=\"cm\">  any lemmas from the library about `mul`. -/</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">eq_id_of_op_eq_self</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">Group</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"gr\">sorry</span>\n<span class=\"kd\">end</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> Apply the previous lemma to show that `⁻¹` is also a right-sided inverse. -/</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">op_right_inv</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">Group</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">x</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"gr\">sorry</span>\n<span class=\"kd\">end</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> we can prove that `1` is also a right identity. -/</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">op_id</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">Group</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"gr\">sorry</span>\n<span class=\"kd\">end</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">!</span>\n<span class=\"cm\">  However, it is inconvenient to use this group instance directly.</span>\n<span class=\"cm\">  One reason is that to use these group operations we now have to write</span>\n<span class=\"cm\">  `(x y : rat_Group)` instead of `(x y : ℚ)`.</span>\n<span class=\"cm\">  That's why in Lean we use classes for algebraic structures.</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> show that the cartesian product of two groups is a group. The underlying type will be `G × H`. -/</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">prod_Group</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">Group</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Group</span> <span class=\"o\">:=</span>\n<span class=\"gr\">sorry</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">Group</span>\n\n\n<span class=\"c\">/-</span><span class=\"cm\">!</span>\n\n<span class=\"cm\">### Exercise: type classes</span>\n\n<span class=\"cm\">We'll see the true power of type classes in later lectures today.</span>\n<span class=\"cm\">Remember that, normally, a type class has the appearance</span>\n<span class=\"cm\">```lean</span>\n<span class=\"cm\">class new_structure {α : Type} {β : Type} :=</span>\n<span class=\"cm\">(data_name : data_type)</span>\n<span class=\"cm\">(property_name : property_type)</span>\n</code></pre></div>\n<p>That is, it is a structure with one or more type parameters,<br>\nzero or more data fields, <br>\nand zero or more property fields. </p>\n<p>We think of an instance <code>new_structure A B</code> as saying \"<code>A</code> and <code>B</code> have a canonical <code>new_structure</code> structure.\"<br>\nFor instance, <code>int.add_group : add_group ℤ</code> says that the integers have a canonical <code>group</code> structure.</p>\n<p>What other examples of \"structured sets\" can you think of that could be represented as type classes?<br>\nCan you write them down in Lean, in real or mock-up syntax?<br>\n-/</p>\n<p>/-!</p>\n<h3>Exercise: a finite group</h3>\n<p>We're going to show that the two-element type <code>{z, o}</code> has a group structure.</p>\n<p>-/</p>\n<p>-- First we define this type, and call it <code>two</code>. Its elements are <code>z</code> and <code>o</code>.<br>\ninductive two <br>\n| z | o </p>\n<p>open two </p>\n<p>#check z <br>\n#check o</p>\n<p>-- Now we define addition on the type <code>two</code>, by cases.<br>\ndef two.add : two → two → two <br>\n| o o := z <br>\n| z z := z<br>\n| _ _ := o</p>\n<p>-- Do this one yourself! Define negation on the type <code>two</code>.<br>\ndef two.neg : two → two <br>\n| o := sorry<br>\n| z := sorry</p>\n<p>-- Once you fill in <code>two.neg</code>, most proofs about <code>o</code> and <code>z</code> are by definition!<br>\nexample : two.add o (two.neg z) = o := <br>\nrfl</p>\n<p>-- With our addition and negation operators, <code>two</code> should form an additive group.<br>\n-- Fill in the missing fields. <br>\n-- Hint: if you have <code>a : two</code>, the tactic <code>cases a</code> might be useful. <br>\ninstance : add_group two :=<br>\n{ add := two.add,<br>\n  neg := two.neg,<br>\n  add_assoc := sorry,<br>\n  zero := sorry,<br>\n  zero_add := sorry,<br>\n  add_zero := sorry,<br>\n  add_left_neg := sorry }</p>\n<p>-- And with this instance, you can use familiar group operations (and lemmas) on <code>two</code>. </p>\n<p>example : o + -z = o := <br>\nrfl </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>\n</code></pre></div>",
        "id": 289453852,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1657716551
    },
    {
        "content": "<p>And here's the result of my talk (belated, sorry):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.real.basic</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n\n<span class=\"cm\"># Structures and type classes</span>\n\n<span class=\"cm\">References:</span>\n<span class=\"cm\">* Mathematics in Lean section 6.1</span>\n<span class=\"cm\">* Theorem Proving in Lean chapters 9--10</span>\n<span class=\"cm\">* [Hitchhiker's Guide to Logical Verification](https://cs.brown.edu/courses/cs1951x/static_files/main.pdf)</span>\n<span class=\"cm\">  sections 4.5--4.6</span>\n\n<span class=\"cm\">You've seen a bunch of talks about tools to prove things about objects that are</span>\n<span class=\"cm\">  already defined.</span>\n\n<span class=\"cm\">How do we define our own new things?</span>\n\n<span class=\"cm\">A thought, especially if you've done some programming:</span>\n<span class=\"cm\">  data types are often a *conjunction* of fields or a *disjunction* of constructors.</span>\n\n<span class=\"cm\">Conjunction: a complex number is a pair of a real and imaginary part, both real</span>\n<span class=\"cm\">  numbers.</span>\n<span class=\"cm\">Disjunction: a propositional formula is either a variable p,</span>\n<span class=\"cm\">  or an application of a binary connective ∧ ∨ → to two formulas,</span>\n<span class=\"cm\">  or an application of ¬ to one formula</span>\n\n<span class=\"cm\">Heuristic claim: mathematicians use the conjunction pattern much more often.</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">R3</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> What is the type of `R3`? -/</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">R3</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> How do you create a `R3`? -/</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">R3.mk</span> <span class=\"mi\">1</span> <span class=\"mi\">2</span> <span class=\"mi\">3</span>\n\n<span class=\"k\">#check</span> <span class=\"o\">({</span><span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"mi\">3</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">R3</span><span class=\"o\">)</span>\n\n<span class=\"k\">#check</span> <span class=\"o\">(⟨</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">⟩</span> <span class=\"o\">:</span> <span class=\"n\">R3</span><span class=\"o\">)</span>\n<span class=\"bp\">.</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> When are two `R3`s equal? -/</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">R3</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">cases</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">cases</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n\n<span class=\"c\">/-</span><span class=\"cm\"> If you have a `R3`, how do you extract the coordinates? -/</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">R3</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">⟩</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">v.z</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">R3.x</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">You can do this in most programming languages. What's special in Lean:</span>\n<span class=\"cm\">  we can add *propositional* fields to our structures.</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">R3_plus</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">x_pos</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">y_pos</span> <span class=\"o\">:</span> <span class=\"n\">y</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">z_pos</span> <span class=\"o\">:</span> <span class=\"n\">z</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">R3_plus.mk</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> When are two `R3_plus`es equal? -/</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">R3_plus</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">cases</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">cases</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"n\">only</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">Structures can take *parameters*.</span>\n<span class=\"cm\">It feels kind of like adding another field, but there are practical and moral</span>\n<span class=\"cm\">  differences.</span>\n<span class=\"cm\">There's an art to choosing which to use.</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">Rn_plus</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">coeff</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">coeff_pos</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">coeff</span> <span class=\"n\">k</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">Rn_plus'</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">coeff</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span>\n\n\n<span class=\"k\">#check</span> <span class=\"n\">Rn_plus</span>\n\n<span class=\"k\">#check</span> <span class=\"bp\">@</span><span class=\"n\">Rn_plus.mk</span>\n\n<span class=\"c1\">-- #check (⟨![0,0,0,0,0]⟩ : Rn_plus 5)</span>\n\n\n<span class=\"k\">#check</span> <span class=\"n\">Rn_plus'.mk</span> <span class=\"mi\">5</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Rn_plus</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Rn_plus</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">≠</span> <span class=\"n\">y</span> <span class=\"o\">:=</span>\n<span class=\"gr\">sorry</span>\n\n\n\n<span class=\"c\">/-</span><span class=\"cm\"> So: let's define a group. -/</span>\n\n\n\n\n<span class=\"kd\">structure</span> <span class=\"n\">Group</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">one</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">mul</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">→</span> <span class=\"n\">G</span> <span class=\"bp\">→</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">inv</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">→</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">one_mul</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"n\">mul</span> <span class=\"n\">one</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n<span class=\"c1\">-- ...</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">Group</span> <span class=\"n\">ℤ</span>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">To bundle, or not to bundle? How are we going to use them?</span>\n<span class=\"cm\">These algebraic structures are a bit of a special situation.</span>\n<span class=\"cm\">Sometimes we think of a group as an object itself. (Category of groups, ...)</span>\n<span class=\"cm\">Other times we work *within* a particular group.</span>\n<span class=\"cm\">  (A particular type has a single familiar group structure.)</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">-</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"n\">add_left_neg</span> <span class=\"n\">x</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">`add_left_neg` is a generic theorem about (additive) groups.</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"k\">#check</span> <span class=\"bp\">@</span><span class=\"n\">add_left_neg</span>\n<span class=\"bp\">.</span>\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">Read this as: \"for any type `G` with an additive group structure, for every `a : G`, `-a + a = 0`.\"</span>\n\n<span class=\"cm\">What are those `+`, `-`, `0`? They come from that group structure on `G`.</span>\n\n<span class=\"cm\">There's some magic going on here when we write our example.</span>\n<span class=\"cm\">Lean has automatically found a group structure on `ℤ`.</span>\n<span class=\"cm\">This is done with a process called *type class inference*.</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"k\">#print</span> <span class=\"n\">add_group</span>\n<span class=\"k\">#print</span> <span class=\"n\">int.add_group</span>\n<span class=\"bp\">.</span>\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">Ignore the actual definitions here, but notice some information at the beginnings.</span>\n\n<span class=\"cm\">* `add_group` is a *type class*. This is a special kind of structure:</span>\n<span class=\"cm\">  approximately, \"this structure bundles additional features into a type.\"</span>\n<span class=\"cm\">* `int.add_group` is an *instance* of this type class.</span>\n<span class=\"cm\">  It shows that `ℤ` has the extra features described by `add_group`.</span>\n<span class=\"cm\">  Furthermore, it registers this fact for *type class inference*.</span>\n<span class=\"cm\">* `add_left_neg` takes an argument `[inst_1 : add_group G]`.</span>\n<span class=\"cm\">  The square brackets tell Lean to fill in this argument automatically using the</span>\n<span class=\"cm\">  registered instances.</span>\n\n\n<span class=\"cm\">Type class inference is more than a lookup table: it's recursive.</span>\n<span class=\"cm\">-/</span>\n\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">add_group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">×</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">-</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"n\">add_left_neg</span> <span class=\"n\">_</span>\n\n<span class=\"k\">#check</span> <span class=\"bp\">@</span><span class=\"n\">prod.add_group</span>\n<span class=\"bp\">.</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">Type classes are used *everywhere* in Lean to do all the bookkeeping you don't</span>\n<span class=\"cm\">  want to think about.</span>\n<span class=\"cm\">You'll see examples from topology, algebra, analysis, ... over the next few days.</span>\n<span class=\"cm\">But let's do a very basic example together as practice: nonempty types.</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">my_nonempty</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">has_val</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"n\">true</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">my_nonempty</span> <span class=\"n\">ℤ</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">has_val</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">trivial</span><span class=\"o\">⟩</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">whatever</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"n\">my_nonempty</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">hb</span> <span class=\"o\">:</span> <span class=\"n\">my_nonempty</span> <span class=\"n\">B</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"n\">my_nonempty</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">×</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">cases</span> <span class=\"n\">ha.has_val</span> <span class=\"k\">with</span> <span class=\"n\">a</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">hb.has_val</span> <span class=\"k\">with</span> <span class=\"n\">b</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">my_nonempty.mk</span><span class=\"o\">,</span>\n  <span class=\"n\">use</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">),</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">pp.implicit</span> <span class=\"n\">true</span>\n<span class=\"kd\">def</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">my_nonempty</span> <span class=\"o\">(</span><span class=\"n\">ℤ</span> <span class=\"bp\">×</span> <span class=\"n\">ℤ</span> <span class=\"bp\">×</span> <span class=\"n\">ℤ</span> <span class=\"bp\">×</span> <span class=\"n\">ℕ</span> <span class=\"bp\">×</span> <span class=\"n\">ℤ</span> <span class=\"bp\">×</span> <span class=\"n\">ℤ</span> <span class=\"bp\">×</span> <span class=\"n\">ℤ</span> <span class=\"bp\">×</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"c1\">--</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">apply</span> <span class=\"bp\">@</span><span class=\"n\">whatever</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">apply_instance</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"bp\">@</span><span class=\"n\">whatever</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">apply_instance</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"bp\">@</span><span class=\"n\">whatever</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">apply_instance</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"bp\">@</span><span class=\"n\">whatever</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">use</span> <span class=\"o\">⟨⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">trivial</span><span class=\"o\">⟩⟩,</span>\n  <span class=\"n\">apply_instance</span>\n<span class=\"kd\">end</span>\n<span class=\"c1\">--by apply_instance</span>\n<span class=\"k\">#print</span> <span class=\"n\">k</span>\n</code></pre></div>",
        "id": 289472109,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1657724495
    },
    {
        "content": "<p>Slides from the topology talk are <a href=\"/user_uploads/3121/YFJj9O6IfV_u4W2T59CC-C49/topology.pdf\">here</a>.</p>",
        "id": 289506014,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1657739151
    },
    {
        "content": "<p>The graph from the algebraic hierarchy talk is here: <a href=\"#narrow/stream/330515-LftCM22/topic/algebraic.20hierarchy\">https://leanprover.zulipchat.com/#narrow/stream/330515-LftCM22/topic/algebraic.20hierarchy</a></p>",
        "id": 289508947,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1657740575
    },
    {
        "content": "<p>Here are the exercises from the <a href=\"/user_uploads/3121/rKnkQcSCBtFiDyLZNj_lpj78/elementary_number_theory.lean\">elementary number theory talk</a> starting soon.</p>",
        "id": 289586806,
        "sender_full_name": "María Inés de Frutos Fernández",
        "timestamp": 1657802617
    },
    {
        "content": "<p>Some relevant links from my part in the teaching panel:</p>\n<ul>\n<li>my teaching page: <a href=\"https://www.imo.universite-paris-saclay.fr/~pmassot/enseignement/\">https://www.imo.universite-paris-saclay.fr/~pmassot/enseignement/</a> (in French) where you can download bundles having VScode + Lean + mathlib + my tactics and exercises. You can also play on Gitpod at <a href=\"https://gitpod.io/#/https://github.com/PatrickMassot/MDD154/\">https://gitpod.io/#/https://github.com/PatrickMassot/MDD154/</a></li>\n<li>a rough translation of the natural language tactics as they were one year ago is at: <a href=\"https://github.com/PatrickMassot/lean-verbose/\">https://github.com/PatrickMassot/lean-verbose/</a> It is less polished and much less tested than the French version, and it lacks the help tactic.</li>\n<li>the thing used to create lecture notes mixing text and lean as in <a href=\"https://www.imo.universite-paris-saclay.fr/~pmassot/mdd154/\">https://www.imo.universite-paris-saclay.fr/~pmassot/mdd154/</a> is <a href=\"https://leanprover-community.github.io/format_lean/\">https://leanprover-community.github.io/format_lean/</a></li>\n</ul>\n<p>I also had slides that are a slightly updated version of slides from <a href=\"https://www.youtube.com/watch?v=mTLuON5eRZI\">https://www.youtube.com/watch?v=mTLuON5eRZI</a>: <a href=\"/user_uploads/3121/Aqm1hII6ZjtcDXGxIvkJCkU1/teaching.pdf\">teaching.pdf</a></p>\n<div class=\"youtube-video message_inline_image\"><a data-id=\"mTLuON5eRZI\" href=\"https://www.youtube.com/watch?v=mTLuON5eRZI\"><img src=\"https://uploads.zulipusercontent.net/44e9b2e3c48d42541821d7cfd5a2706afd8a0bdc/68747470733a2f2f692e7974696d672e636f6d2f76692f6d544c754f4e3565525a492f64656661756c742e6a7067\"></a></div>",
        "id": 289615942,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1657816455
    },
    {
        "content": "<p>Thanks so much for this discussion! Inspiring.<br>\nI took some (very rough!) notes that I put <a href=\"https://samvang.github.io/lftcm2022-teaching-panel-discussion.md.html\">here</a> in case anyone else finds them useful.</p>",
        "id": 289622207,
        "sender_full_name": "Sam van G",
        "timestamp": 1657819329
    },
    {
        "content": "<p>Here are the most recent versions of the courses I'm teaching:</p>\n<ul>\n<li>1st year undergraduate intro to proof course: <a href=\"https://github.com/ImperialCollegeLondon/M40001_lean\">here</a></li>\n<li>final year project-assessed course: <a href=\"https://www.ma.imperial.ac.uk/~buzzard/xena/formalising-mathematics-2022/index.html\">here</a></li>\n<li>grad student course: <a href=\"https://github.com/ImperialCollegeLondon/formalising-mathematics\">here</a></li>\n</ul>",
        "id": 289640198,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1657828000
    }
]
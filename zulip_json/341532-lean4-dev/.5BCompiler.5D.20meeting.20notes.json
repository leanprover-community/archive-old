[
    {
        "content": "<p>I think one source of confusion is the keyword name: <code>partial</code>. Perhaps, we should pick a new name that makes clear the semantics we are using. BTW, I think the current name is also responsible for the following recurrent question: \"why is <code>f</code> not marked as <code>partial</code> if it is using a partial function?\"</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">partial</span> <span class=\"kd\">def</span> <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">g</span> <span class=\"n\">x</span>\n<span class=\"kd\">def</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">g</span> <span class=\"n\">x</span>\n</code></pre></div>",
        "id": 299639464,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1663619169
    },
    {
        "content": "<p>I feel like I'm starting to regret not making the meeting :) . Was there a specific use case that triggered this discussion?</p>",
        "id": 299639919,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1663619360
    },
    {
        "content": "<p>the first half of the meeting was discussing Leo's proposed semantics for partiality <a href=\"#narrow/stream/341532-lean4-dev/topic/.5BCompiler.5D.20first.20meeting.20notes/near/299227178\">https://leanprover.zulipchat.com/#narrow/stream/341532-lean4-dev/topic/.5BCompiler.5D.20first.20meeting.20notes/near/299227178</a> and potential issues and consequences of this decision</p>",
        "id": 299640551,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1663619592
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span> The topic appeared in the last two meetings. I brought it up because of the issue <a href=\"https://github.com/leanprover/lean4/issues/1529\">https://github.com/leanprover/lean4/issues/1529</a>. The issue is triggered by a static analyzer that does not take into account the semantics we have for <code>partial</code>. Then, while preparing material to discuss this issue last Friday, I created a few examples (posted above) that show how the compiler simplifier can eliminate non-termination too using: inlining, dead code elimination, and cases on constructor reduction.</p>",
        "id": 299640733,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1663619654
    },
    {
        "content": "<p>During today's meeting, we also discussed the possibility of having a <code>Partial</code> monad. I think this is useful for users that want the \"non-termination\" effect. However, we have many instances of <code>partial</code> in Lean's own implementation, and I don't want to have this extra overhead there.</p>",
        "id": 299641408,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1663619897
    },
    {
        "content": "<p>Ahh, it looks like I missed quite a few messages. Though I have to say that to me there is a profound difference between the examples in this thread, where non-termination is eliminated as dead code, and the linked issue, where non-termination is eliminated solely because it is non-termination. The former seems generally agreeable, the latter is a bit more surprising but somewhat understandable from an implementation perspective.</p>",
        "id": 299643646,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1663620875
    },
    {
        "content": "<p>Though what the Boxing pass does in the linked issue could of course be seen as DCE as well, so I can see how the fuel proposal could be the most sensible consistent semantics</p>",
        "id": 299644749,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1663621340
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span> Yes, they are different. The examples in this thread suggest we have to make it clear to users the semantics of the <code>partial</code> keyword used by the compiler. The issue on GitHub is a reminder that we (the developers) should take the same semantics into account when implementing static analyzers and other transformations. I agree with <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> that assuming an arbitrary opaque value is the simplest solution when implementing and justifying code transformations.</p>",
        "id": 299644940,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1663621415
    },
    {
        "content": "<p>what, concretely, would happen to Gabriel's <code>swipc</code> example though? Would it just not be changed, or would it be replaced by <code>def swipc := lcLoop</code> and then <code>lcLoop</code> replaced for an infinite loop in codegen?</p>",
        "id": 299645305,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1663621558
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes/near/299645305\">said</a>:</p>\n<blockquote>\n<p>what, concretely, would happen to Gabriel's <code>swipc</code> example though? Would it just not be changed, or would it be replaced by <code>def swipc := lcLoop</code> and then <code>lcLoop</code> replaced for an infinite loop in codegen?</p>\n</blockquote>\n<p>It will not change. The fix will affect the static analyzer which will now return <code>Top</code> (\"any\") for <code>swipc</code>, and with this information, no simplification will be performed.</p>",
        "id": 299645747,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1663621794
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes/near/299627062\">said</a>:</p>\n<blockquote>\n<p>Thinking about this semantics a bit more, I think it should be legal to optimize</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">partial</span> <span class=\"kd\">def</span> <span class=\"n\">dontTerminate</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">dontTerminate</span> <span class=\"n\">x</span>\n</code></pre></div>\n<p>to</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">partial</span> <span class=\"kd\">def</span> <span class=\"n\">dontTerminate</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">default</span>\n</code></pre></div>\n<p>because the compiler can see that the only possible return value of the function is <code>default</code> (after a <code>hugeFuel</code> number of iterations of a side-effect-free function)</p>\n</blockquote>\n<p>This transformation is problematic precisely because of the <code>Nonempty</code>-issue that Mario mentioned.  Recall that we're intentionally allowing <code>Nonempty</code> as a witness for <code>partial def</code> to support FFI values, which do not have a (VM-computable) default value.</p>\n<p>What should the reference returned by <code>dontTerminate (x : Nat) : IO.Ref</code> point to?  Should <code>dontTerminate (x : Nat) : FS.Handle</code> return an invalid handle?</p>",
        "id": 299700174,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1663660533
    },
    {
        "content": "<p>Another fun quiz: what do the following functions compile to?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">function1</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Id.run</span> <span class=\"k\">do</span> <span class=\"n\">StateT.run'</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"k\">do</span>\n    <span class=\"n\">repeat</span> <span class=\"n\">modify</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n    <span class=\"n\">get</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">function2</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Id.run</span> <span class=\"k\">do</span> <span class=\"n\">StateT.run'</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"k\">do</span>\n    <span class=\"n\">repeat</span> <span class=\"n\">modify</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n    <span class=\"n\">pure</span> <span class=\"mi\">42</span>\n</code></pre></div>",
        "id": 299701097,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1663660972
    },
    {
        "content": "<p>Broadly speaking, my preferences for the semantics of <code>dontTerminate</code> are:<br>\nruntime error message &gt; nontermination &gt; crash &gt; returning a made-up value</p>",
        "id": 299705793,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1663663056
    },
    {
        "content": "<p>You say \"runtime error message\" but this would probably be detected at compile time. If it makes it to runtime then it will almost certainly manifest as nontermination because the compiler wasn't able to solve the halting problem in this case</p>",
        "id": 299730325,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1663673583
    },
    {
        "content": "<p>also, is this a <code>panic!</code> like message where something else happens after the message, and if so, what?</p>",
        "id": 299730564,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1663673691
    },
    {
        "content": "<p>It can't be like <code>panic!</code> because we don't necessarily have a default value.  It would have to be stack unwinding, but we don't do that anywhere else.</p>\n<blockquote>\n<p>but this would probably be detected at compile time.</p>\n</blockquote>\n<p>Yes, however the compiler shouldn't fail because it has detected nonterminating code.  I would imagine that this can easily happen in generic code, and it is perfectly fine to have a nonterminating function, as long as it is never called.</p>",
        "id": 299731420,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1663674044
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes/near/299730564\">said</a>:</p>\n<blockquote>\n<p>also, is this a <code>panic!</code> like message where something else happens after the message, and if so, what?</p>\n</blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110043\">Gabriel Ebner</span> <a href=\"#narrow/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes/near/299731420\">said</a>:</p>\n<blockquote>\n<p>It can't be like <code>panic!</code> because we don't necessarily have a default value.  It would have to be stack unwinding, but we don't do that anywhere else.</p>\n</blockquote>\n<p>Could we use a a variant of <code>panic!</code> defined with <code>Nonempty</code> instead of <code>Inhabited</code> that always aborts so that the physical default value does not matter?</p>",
        "id": 299744692,
        "sender_full_name": "Mac",
        "timestamp": 1663679049
    },
    {
        "content": "<p>It could also loop instead of abort</p>",
        "id": 299744796,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1663679083
    },
    {
        "content": "<p>or deadlock if you want to be good to the planet</p>",
        "id": 299744995,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1663679157
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> Sure, though I imagine aborting would generally be desired over a loop in most use cases. Except, I guess, if it is in a separate thread and the user just wants that thread to stall rather than killing the whole program.</p>",
        "id": 299745395,
        "sender_full_name": "Mac",
        "timestamp": 1663679286
    },
    {
        "content": "<p>Looping would also be more semantically correct in the sense that this alternate <code>panic!</code> is meant for nonterminating functions which are technically suppose to loop.</p>",
        "id": 299745518,
        "sender_full_name": "Mac",
        "timestamp": 1663679330
    },
    {
        "content": "<blockquote>\n<p>This transformation is problematic precisely because of the Nonempty-issue that Mario mentioned. Recall that we're intentionally allowing Nonempty as a witness for partial def to support FFI values, which do not have a (VM-computable) default value.</p>\n</blockquote>\n<p>I believe <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> suggested the transformation as a hypothetical one. One that would be correct based on the semantics we discussed yesterday. That being said, I want to make it clear that the compiler old and new is not going to do that.</p>",
        "id": 299750916,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1663681034
    },
    {
        "content": "<blockquote>\n<p>What should the reference returned by dontTerminate (x : Nat) : IO.Ref point to? Should dontTerminate (x : Nat) : FS.Handle return an invalid handle?</p>\n</blockquote>\n<p>After yesterday's discussion, we are moving towards using an opaque value instead of the default because of the <code>Nonempty</code>. <br>\nNote that the information is only used by the static analyzers.</p>",
        "id": 299751190,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1663681161
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110043\">Gabriel Ebner</span> <a href=\"#narrow/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes/near/299701097\">said</a>:</p>\n<blockquote>\n<p>Another fun quiz: what do the following functions compile to?</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">function1</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Id.run</span> <span class=\"k\">do</span> <span class=\"n\">StateT.run'</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"k\">do</span>\n    <span class=\"n\">repeat</span> <span class=\"n\">modify</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n    <span class=\"n\">get</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">function2</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Id.run</span> <span class=\"k\">do</span> <span class=\"n\">StateT.run'</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"k\">do</span>\n    <span class=\"n\">repeat</span> <span class=\"n\">modify</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n    <span class=\"n\">pure</span> <span class=\"mi\">42</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Note that both examples are instances of <a href=\"https://github.com/leanprover/lean4/issues/1529\">https://github.com/leanprover/lean4/issues/1529</a><br>\nThe static analyzer is saying that the code corresponding to <code>repeat modify (.+1)</code> returns nothing (<code>bottom</code>). This is incorrect. <br>\nThe new static analyzer will say they return \"any\" (<code>top</code>), and the continuation will not be removed, and both will loop.</p>",
        "id": 299751857,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1663681384
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112857\">Leonardo de Moura</span> <a href=\"#narrow/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes/near/299750916\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>This transformation is problematic precisely because of the Nonempty-issue that Mario mentioned. Recall that we're intentionally allowing Nonempty as a witness for partial def to support FFI values, which do not have a (VM-computable) default value.</p>\n</blockquote>\n<p>I believe <span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> suggested the transformation as a hypothetical one. One that would be correct based on the semantics we discussed yesterday. That being said, I want to make it clear that the compiler old and new is not going to do that.</p>\n</blockquote>\n<p>I prefer to avoid this kind of thing though when possible. If our semantics justifies the transformation and it's an \"optimization\" then we should always be licensed to do it, or our semantics needs revision</p>",
        "id": 299752092,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1663681447
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110043\">Gabriel Ebner</span> <a href=\"#narrow/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes/near/299705793\">said</a>:</p>\n<blockquote>\n<p>Broadly speaking, my preferences for the semantics of <code>dontTerminate</code> are:<br>\nruntime error message &gt; nontermination &gt; crash &gt; returning a made-up value</p>\n</blockquote>\n<p>In the new code generator, nontermination may be eliminated if it is dead code, or may loop at runtime.</p>",
        "id": 299752289,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1663681504
    },
    {
        "content": "<blockquote>\n<p>I prefer to avoid this kind of thing though when possible. If our semantics justifies the transformation and it's an \"optimization\" then we should always be licensed to do it, or our semantics needs revision</p>\n</blockquote>\n<p>I am open to suggestions. My main constraint is: the code generator at the LCNF level should be able to treat code as pure.</p>",
        "id": 299753088,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1663681737
    },
    {
        "content": "<blockquote>\n<p>Yes, however the compiler shouldn't fail because it has detected nonterminating code. I would imagine that this can easily happen in generic code, and it is perfectly fine to have a nonterminating function, as long as it is never called.</p>\n</blockquote>\n<p>I agree, the compiler should not fail.</p>",
        "id": 299753479,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1663681850
    },
    {
        "content": "<blockquote>\n<p>Could we use a a variant of panic! defined with Nonempty instead of Inhabited that always aborts so that the physical default value does not matter?</p>\n</blockquote>\n<p>This is an important topic, and we should create a thread for it. We have discussed <code>panic!</code> many times and never reached a consensus. <br>\nIn the current system, we have flags to control its behavior: aborting, disabling error message, etc. The flags represent different views about what <code>panic</code> should do.</p>",
        "id": 299753963,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1663682023
    },
    {
        "content": "<p>Here's an elaboration of the semantics for nontermination, a more abstract version of Leo's fuel semantics, that I was discussing with <span class=\"user-mention\" data-user-id=\"130575\">@Siddharth Bhat</span> :</p>\n<p>Fix a (large) natural number <code>C</code>. We consider a nondeterministic model for computation of lean expressions as follows: Each call to a partial function uses up one \"recursion token\". Prior to consuming <code>C</code> recursion tokens all partial functions must be called as normal. Once the model has used up <code>C</code> recursion tokens starting from <code>main</code>, a subsequent call to a partial function has the following nondeterministic options: it can either call the function again, or return any value of the target type (even a noncomputable one).</p>\n<p>Larger values of <code>C</code> yield less nondeterminism in the model, but even the intersection of all choices of <code>C</code> yields nondeterminism where <code>def loop : A := loop</code> returns any value of type <code>A</code>.</p>\n<p>The compiler fixes a choice for <code>C</code> (this is a fixed constant in the vicinity of 2^2^64, which is allowed to be compiler and architecture dependent) and promises that it will produce an execution consistent with <em>every</em> possible nondeterministic outcome of the <code>C</code>-model. In the event that different nondeterministic executions disagree, the compiler is required to exhaust resources or output a looping computation.</p>",
        "id": 299756652,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1663682799
    },
    {
        "content": "<p>I am happy with this semantics.</p>",
        "id": 299815849,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1663696497
    },
    {
        "content": "<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>Jitsi links 2022-09-23</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<p>Siddharth Bhat<br>\nSiddharth Bhat says:<br>\n<a href=\"http://www.cse.chalmers.se/~peterd/papers/Inductive_Families.pdf\">http://www.cse.chalmers.se/~peterd/papers/Inductive_Families.pdf</a></p>\n<p>19:03<br>\nHenrik Boeving<br>\nHenrik Boeving says:<br>\n<a href=\"https://reader.elsevier.com/reader/sd/pii/S0167642397000294?token=86635F7D899212AD0A6A793EDAAD9E7416F713F7DA2DB1ED2DA63F292FE7B57415E27D28D657785EEBC0DB36963E3152&amp;originRegion=us-east-1&amp;originCreation=20220808183502\">https://reader.elsevier.com/reader/sd/pii/S0167642397000294?token=86635F7D899212AD0A6A793EDAAD9E7416F713F7DA2DB1ED2DA63F292FE7B57415E27D28D657785EEBC0DB36963E3152&amp;originRegion=us-east-1&amp;originCreation=20220808183502</a></p>\n<p><a href=\"https://citeseerx.ist.psu.edu/viewdoc/download;jsessionid=DB7AF69CF92D72308A6609FB71056D6B?doi=10.1.1.51.3123&amp;rep=rep1&amp;type=pdf\">https://citeseerx.ist.psu.edu/viewdoc/download;jsessionid=DB7AF69CF92D72308A6609FB71056D6B?doi=10.1.1.51.3123&amp;rep=rep1&amp;type=pdf</a></p>\n<p><a href=\"http://www.cin.ufpe.br/~alms/ps/thesis.ps.gz\">http://www.cin.ufpe.br/~alms/ps/thesis.ps.gz</a></p>\n<p><a href=\"https://www.microsoft.com/en-us/research/wp-content/uploads/2016/11/compiling-without-continuations.pdf\">https://www.microsoft.com/en-us/research/wp-content/uploads/2016/11/compiling-without-continuations.pdf</a></p>\n<p>19:19<br>\nTom<br>\nTom says:<br>\n<a href=\"https://hackage.haskell.org/package/recursion-schemes\">https://hackage.haskell.org/package/recursion-schemes</a></p>\n<p><a href=\"https://deque.blog/2017/01/20/catamorph-your-dsl-deep-dive/\">https://deque.blog/2017/01/20/catamorph-your-dsl-deep-dive/</a></p>\n<p>Tom says:Not necessarily:</p>\n<p><a href=\"https://compilers.cs.uni-saarland.de/papers/lkh15_cgo.pdf\">https://compilers.cs.uni-saarland.de/papers/lkh15_cgo.pdf</a></p>\n</div></div>\n<p>I didn't want to include any other messages without asking.</p>",
        "id": 300425318,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1663956932
    },
    {
        "content": "<p>A few of the links I posted regarding the composition of passes/optimizations:</p>\n<p><a href=\"https://hackage.haskell.org/package/recursion-schemes\">https://hackage.haskell.org/package/recursion-schemes</a></p>\n<p>Here's a good intro article:<br>\n<a href=\"https://deque.blog/2017/01/20/catamorph-your-dsl-deep-dive/\">https://deque.blog/2017/01/20/catamorph-your-dsl-deep-dive/</a></p>\n<p>Also, during the discussion about the deep nested lets for lists, I remembered this.  This is not applicable because the IR is different but thought it may be interesting nonetheless:</p>\n<p><a href=\"https://compilers.cs.uni-saarland.de/papers/lkh15_cgo.pdf\">https://compilers.cs.uni-saarland.de/papers/lkh15_cgo.pdf</a></p>",
        "id": 300425384,
        "sender_full_name": "Tom",
        "timestamp": 1663956961
    },
    {
        "content": "<p>Some additional notes</p>\n<ul>\n<li>We mentioned \"confluence\" during the meeting. <a href=\"https://en.wikipedia.org/wiki/Confluence_(abstract_rewriting)\">https://en.wikipedia.org/wiki/Confluence_(abstract_rewriting)</a> Knuth-Bendix is an algorithm for transforming a rewriting system into a confluent one: <a href=\"https://www.cs.tufts.edu/~nr/cs257/archive/don-knuth/knuth-bendix.pdf\">https://www.cs.tufts.edu/~nr/cs257/archive/don-knuth/knuth-bendix.pdf</a>  Remark: I don't think we need this in the near future.</li>\n<li>The data structure used in the new code generator is based on the one use in GHC. The paper \"Compiling  without continuations\" <a href=\"https://www.microsoft.com/en-us/research/wp-content/uploads/2016/11/compiling-without-continuations.pdf\">https://www.microsoft.com/en-us/research/wp-content/uploads/2016/11/compiling-without-continuations.pdf</a> I am very happy with this data structure.</li>\n</ul>",
        "id": 300427553,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1663957740
    },
    {
        "content": "<p>We have also discussed whether we want to support big list/array/matrix literals in the code generator. We also don't have good support for them in the kernel. That is, we may get a stack overflow in the kernel when type checking this kind of literal. I hope we don't have real use-cases for this feature, and if we do, then we can work around by loading them from a data file. If this is not a satisfactory solution, I think an option is to extend the <code>Literal</code> type we have at <code>src/Lean/Expr.lean</code>.</p>",
        "id": 300435619,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1663960683
    },
    {
        "content": "<p>Recall that we need more tests that make heavy use of dependent types and/or may confuse the code generator. For example,  <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> mentioned functions that may return data or proofs depending on the input arguments. This is a great example. Here is another example that triggered a bug earlier this week in the new cod generator: <a href=\"https://github.com/leanprover/lean4/blob/master/tests/lean/run/fieldTypeBug.lean\">https://github.com/leanprover/lean4/blob/master/tests/lean/run/fieldTypeBug.lean</a></p>",
        "id": 300437436,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1663961411
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130575\">@Siddharth Bhat</span> You mentioned issues in GHC when one is using rewriting rules as optimization rules. I have assumed the issue was due to the fact that the rewriting rules are probably not confluent, but I am now not sure whether this is the problem you were referring to. Do you have a link where we can read more about these issues?</p>",
        "id": 300439173,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1663962183
    },
    {
        "content": "<p>Regarding big literals and stack overflow: One thing that the rust compiler does to handle big / deep expressions is to use <a href=\"https://docs.rs/stacker/latest/stacker/\"><code>stacker</code></a> to spill the C stack onto the heap when it gets too large. The interface for this is fairly light: you just wrap any recursive functions that you think are subject to deep recursion and stack overflow in a call to the <code>maybe_grow</code> function which takes a callback where you put the body of the function. I think we could do something like this for lean, and it comes up in enough cases that it would probably be worthwhile. It's certainly a lot easier than rewriting everything to be tail recursive.</p>",
        "id": 300483278,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1663994134
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes/near/300483278\">said</a>:</p>\n<blockquote>\n<p>Regarding big literals and stack overflow: One thing that the rust compiler does to handle big / deep expressions is to use <a href=\"https://docs.rs/stacker/latest/stacker/\"><code>stacker</code></a> to spill the C stack onto the heap when it gets too large. The interface for this is fairly light: you just wrap any recursive functions that you think are subject to deep recursion and stack overflow in a call to the <code>maybe_grow</code> function which takes a callback where you put the body of the function. I think we could do something like this for lean, and it comes up in enough cases that it would probably be worthwhile. It's certainly a lot easier than rewriting everything to be tail recursive.</p>\n</blockquote>\n<p>It is worth investigating how the APIs are implemented. I am assuming they need special code for different platforms. </p>\n<blockquote>\n<p>It's certainly a lot easier than rewriting everything to be tail recursive.</p>\n</blockquote>\n<p>YES! </p>\n<p>BTW, when we started the Lean project we added support for \"-fsplit_stack\" (<a href=\"https://github.com/leanprover/lean4/blob/master/src/CMakeLists.txt#L184\">https://github.com/leanprover/lean4/blob/master/src/CMakeLists.txt#L184</a>). Not sure whether it still works. At the time, only gcc / linux had support for this. The C compiler generates code that uses the heap to implement the call stack. This was almost 10 years ago, I am assuming the support should be much better today.</p>",
        "id": 300542981,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1664028486
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112857\">@Leonardo de Moura</span> I was thinking of a general class of performance bug, where rewrite rules break across compiler versions, and across syntactic changes of code. causing performance problems: </p>\n<ul>\n<li><a href=\"https://gitlab.haskell.org/ghc/ghc/-/issues/19557\">https://gitlab.haskell.org/ghc/ghc/-/issues/19557</a></li>\n<li>How do we test fusion <a href=\"https://github.com/haskell/vector/issues/229\">issue at <code>haskell/vector</code></a>. </li>\n<li>Haskell's <code>Data.Text</code> <a href=\"https://github.com/haskell/text/pull/348\">moved away from using rewrite rules entirely</a>.</li>\n</ul>",
        "id": 300562161,
        "sender_full_name": "Siddharth Bhat",
        "timestamp": 1664038872
    },
    {
        "content": "<p>Regarding the testing of fusion that should just be trivially possible by inserting a test pass that looks for cases that could have been fused shouldn't it?</p>",
        "id": 300563419,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1664039661
    },
    {
        "content": "<p>Looking it up, it seems like <code>-fsplit_stack</code> requires recompiling everything with that option, including possibly the standard library, which sounds like it's making some global changes which affect all function calls. The stacker approach doesn't suffer from this issue, since it is explicitly put on individual functions and everything else is unaffected</p>",
        "id": 300577656,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1664048942
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130575\">Siddharth Bhat</span> <a href=\"#narrow/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes/near/300562161\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"112857\">Leonardo de Moura</span> I was thinking of a general class of performance bug, where rewrite rules break across compiler versions, and across syntactic changes of code. causing performance problems: </p>\n<ul>\n<li><a href=\"https://gitlab.haskell.org/ghc/ghc/-/issues/19557\">https://gitlab.haskell.org/ghc/ghc/-/issues/19557</a></li>\n<li>How do we test fusion <a href=\"https://github.com/haskell/vector/issues/229\">issue at <code>haskell/vector</code></a>. </li>\n<li>Haskell's <code>Data.Text</code> <a href=\"https://github.com/haskell/text/pull/348\">moved away from using rewrite rules entirely</a>.</li>\n</ul>\n</blockquote>\n<p>Thanks for posting the links. The Haskell thread is huge. Could you please summarize the issue? How could it happen in Lean? Here are some issues we aware of:</p>\n<ul>\n<li>The optimization rules may form a non-confluent rewriting system. </li>\n<li>Local vs global optimum. That is some transformations improve the code locally, but may make things worse overall (e.g., destroying sharing).</li>\n</ul>\n<p>Is is the Haskell issue an instance of one of these? I skimmed through the thread and they mention <code>Text</code> a lot.</p>",
        "id": 300578394,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1664049485
    },
    {
        "content": "<p>The <code>Data.Text</code> issue is about something a bit more concrete: the composition of two O(1) rules got rewritten into an O(n) stream/unstream thing. The problem here seems to be more that \"stream fusion\" in haskell refers to a specific pattern where things are rewritten into stream operations and combined with the hope that the overheads will be removed when all is said and done</p>",
        "id": 300579024,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1664049964
    },
    {
        "content": "<p>Needless to say, I don't think it would be a good idea for lean to rewrite all operations into \"transform to list -&gt; apply operation -&gt; transform back\"</p>",
        "id": 300579095,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1664050052
    },
    {
        "content": "<p>this is a library design question though, it's not an indictment of rewrite rules altogether AFAICT</p>",
        "id": 300579170,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1664050100
    },
    {
        "content": "<p>-fsplit-stack will cause a lot of issues, esp with calling into native C/C++ code.  <br>\nActually, originally Rust also used this approach but abandoned it because it was too complicated and causing performance problems.</p>",
        "id": 300589792,
        "sender_full_name": "Tom",
        "timestamp": 1664059344
    },
    {
        "content": "<p>Found a reference; interestingly the claim is that Go also abandoned segmented stacks but I can’t confirm that: </p>\n<p><a href=\"https://news.ycombinator.com/item?id=6679918\">https://news.ycombinator.com/item?id=6679918</a></p>",
        "id": 300590076,
        "sender_full_name": "Tom",
        "timestamp": 1664059600
    },
    {
        "content": "<p>Constant Folder: <a href=\"https://github.com/leanprover/lean4/pull/1652\">https://github.com/leanprover/lean4/pull/1652</a></p>\n<p>CC <span class=\"user-mention\" data-user-id=\"130575\">@Siddharth Bhat</span></p>",
        "id": 300912777,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1664233191
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112857\">@Leonardo de Moura</span> I got a response from Ocaml:</p>\n<p>Hello Henrik, thanks for your email about your interest in using inlining heuristics similar to Flambda in Lean 4.  I'm replying from my work account and have copied in two colleagues, Pierre Chambart and Leo White, who were really the original designers of the actual heuristics themselves (Pierre for the version of Flambda that is released in upstream OCaml and Leo for the forthcoming Flambda 2 version, which is developed here: <a href=\"https://github.com/ocaml-flambda/flambda-backend\">https://github.com/ocaml-flambda/flambda-backend</a>)</p>\n<p>I'm not sure there exists any documentation as to the actual heuristics except for the code.  We tried to simplify the heuristics for Flambda 2 and it's pretty straightforward to see the implementation of those here:</p>\n<p><a href=\"https://github.com/ocaml-flambda/flambda-backend/blob/main/middle_end/flambda2/simplify/inlining/call_site_inlining_decision.ml\">https://github.com/ocaml-flambda/flambda-backend/blob/main/middle_end/flambda2/simplify/inlining/call_site_inlining_decision.ml</a><br>\n<a href=\"https://github.com/ocaml-flambda/flambda-backend/blob/main/middle_end/flambda2/simplify/inlining/function_decl_inlining_decision.ml\">https://github.com/ocaml-flambda/flambda-backend/blob/main/middle_end/flambda2/simplify/inlining/function_decl_inlining_decision.ml</a></p>\n<p>The decision code for Flambda 1 is here:</p>\n<p><a href=\"https://github.com/ocaml/ocaml/blob/trunk/middle_end/flambda/inlining_decision.ml\">https://github.com/ocaml/ocaml/blob/trunk/middle_end/flambda/inlining_decision.ml</a></p>\n<p>Please let us know if there are any specific questions...</p>\n<p>Best regards<br>\nMark</p>",
        "id": 301059287,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1664297106
    },
    {
        "content": "<p>Semi-related: I recompiled OCaml with flambda support (...one-line change thanks to Nix <span aria-label=\"big smile\" class=\"emoji emoji-1f604\" role=\"img\" title=\"big smile\">:big_smile:</span>) for our RC paper evaluation, but found that it did not beat the standard optimizer at that point. Maybe I should try again when flambda 2 is released <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span> ... would also be nice to test a version of <code>binarytrees</code> that uses Multicore OCaml instead of interprocess communication <span aria-label=\"grimacing\" class=\"emoji emoji-1f62c\" role=\"img\" title=\"grimacing\">:grimacing:</span> .</p>",
        "id": 301059982,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1664297331
    },
    {
        "content": "<p>MLIR + Lean paper by <span class=\"user-mention\" data-user-id=\"130575\">@Siddharth Bhat</span> &amp; <span class=\"user-mention\" data-user-id=\"122318\">@Tobias Grosser</span> : <a href=\"https://grosser.science/static/0b1eb3ff397733a16e3f3e0e2429cab5/bhat-2022-Lambda-the-Ultimate-SSA.pdf\">https://grosser.science/static/0b1eb3ff397733a16e3f3e0e2429cab5/bhat-2022-Lambda-the-Ultimate-SSA.pdf</a></p>",
        "id": 302909594,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1665166438
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130575\">@Siddharth Bhat</span> and <span class=\"user-mention\" data-user-id=\"122318\">@Tobias Grosser</span> really interesting read! I think there might be a typo on page 171 in the Code Duplication example, the <code>// 0 2 _ -&gt; 40 </code> comment is on the wrong switch statement</p>",
        "id": 302945250,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1665182929
    },
    {
        "content": "<p>Thank you.</p>",
        "id": 302975161,
        "sender_full_name": "Tobias Grosser",
        "timestamp": 1665213321
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"395550\">@Henrik Böving</span> Here's a proof of that theorem you mentioned:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">log2_le_self</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat.log2</span> <span class=\"n\">n</span> <span class=\"bp\">≤</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">Nat.log2</span><span class=\"bp\">;</span> <span class=\"n\">split</span>\n  <span class=\"bp\">·</span> <span class=\"n\">next</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">log2_le_self</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">/</span> <span class=\"mi\">2</span><span class=\"o\">)</span>\n    <span class=\"n\">exact</span> <span class=\"n\">Nat.lt_of_le_of_lt</span> <span class=\"n\">this</span> <span class=\"o\">(</span><span class=\"n\">Nat.div_lt_self</span> <span class=\"o\">(</span><span class=\"n\">Nat.le_of_lt</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">decide</span><span class=\"o\">))</span>\n  <span class=\"bp\">·</span> <span class=\"n\">apply</span> <span class=\"n\">Nat.zero_le</span>\n<span class=\"n\">decreasing_by</span> <span class=\"n\">exact</span> <span class=\"n\">Nat.log2_terminates</span> <span class=\"n\">_</span> <span class=\"o\">‹</span><span class=\"n\">_</span><span class=\"o\">›</span>\n</code></pre></div>",
        "id": 311448886,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1669057586
    },
    {
        "content": "<p>That's gonna be the first time i saw a decreasing_by on a theorem.</p>",
        "id": 311448951,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1669057614
    },
    {
        "content": "<p>it's often convenient to prove theorems about definitions by well founded recursion, also by well founded recursion with the same metric</p>",
        "id": 311449019,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1669057647
    },
    {
        "content": "<p>Because it more closely resembles the recursion that is actually going on I guess?</p>",
        "id": 311449077,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1669057679
    },
    {
        "content": "<p>yeah, the inductive hypothesis talks about the same term that appears in the definition body</p>",
        "id": 311449171,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1669057711
    },
    {
        "content": "<p>That makes sense, thank you. I'll just steal this then if you allow :P</p>",
        "id": 311449509,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1669057862
    },
    {
        "content": "<p>This is the \"fast Lua interpreter\" blog post btw <a href=\"https://sillycross.github.io/2022/11/22/2022-11-22/\">https://sillycross.github.io/2022/11/22/2022-11-22/</a></p>",
        "id": 313135193,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1669835664
    },
    {
        "content": "<p>This reminds me of HolyJit: <a href=\"https://github.com/nbp/holyjit\">https://github.com/nbp/holyjit</a> and <a href=\"https://yoric.github.io/post/holyjit/\">https://yoric.github.io/post/holyjit/</a></p>",
        "id": 313185562,
        "sender_full_name": "Mauricio Collares",
        "timestamp": 1669855721
    },
    {
        "content": "<p><a href=\"https://v2.ocaml.org/manual/flambda.html\">https://v2.ocaml.org/manual/flambda.html</a> it seems flambda finally got some documentation on top of the code the OCaml folk sent us the other day, I'll try to get something going with the optimizations they are describing in the coming days.</p>",
        "id": 314792470,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1670542331
    },
    {
        "content": "<p>Also I won't be able to attend Wednesday's meeting because of a Christmas event. If <span class=\"user-mention\" data-user-id=\"221921\">@Marc Huisinga</span> ends up doing his presentation it would be cool if you could post the slides somewhere (If there are slides :P) or alternatively at least a little summary!</p>",
        "id": 315428241,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1670868511
    },
    {
        "content": "<p>As I am currently sick with a flu, I don't think I'll be able to present anything this wednesday either :(</p>",
        "id": 315433487,
        "sender_full_name": "Marc Huisinga",
        "timestamp": 1670870074
    },
    {
        "content": "<p>I won't be able to attend tomorrow, FWIW.</p>",
        "id": 315661123,
        "sender_full_name": "Yuri de Wit",
        "timestamp": 1670957401
    },
    {
        "content": "<p>So that's another one dropped? :D</p>",
        "id": 315661517,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1670957520
    },
    {
        "content": "<p>I am sitting on (what I believe to be) the meeting link and no one is here. <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span>  I am mistaken about the link, was the meeting cancelled, or was everyone (except me) just unable to make it?</p>",
        "id": 315881127,
        "sender_full_name": "Mac",
        "timestamp": 1671041149
    },
    {
        "content": "<p>Ah yeah, like Henrik I assumed it was basically cancelled</p>",
        "id": 315884442,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1671041423
    },
    {
        "content": "<p>Ah, okay.</p>",
        "id": 315884569,
        "sender_full_name": "Mac",
        "timestamp": 1671041469
    },
    {
        "content": "<p>Are there plans for the meeting next week yet? Will we drop it because of Christmas or w/e? I'm free.</p>",
        "id": 316099257,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1671125762
    },
    {
        "content": "<p>My time for lean-fun has been cut shorter, so slower progress on my part but I will be able to attend</p>",
        "id": 316250439,
        "sender_full_name": "Yuri de Wit",
        "timestamp": 1671192848
    },
    {
        "content": "<p>I'm free too</p>",
        "id": 316250995,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1671193045
    },
    {
        "content": "<p>Is there a meeting today? It seems the room is empty</p>",
        "id": 317009001,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1671559877
    },
    {
        "content": "<p>Meetings are on Wednesdays</p>",
        "id": 317209183,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1671643524
    },
    {
        "content": "<p>aka today</p>",
        "id": 317209210,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1671643530
    },
    {
        "content": "<p>Riiight? <span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span> <span class=\"user-mention\" data-user-id=\"130575\">@Siddharth Bhat</span></p>",
        "id": 317216610,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1671645666
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"395550\">@Henrik Böving</span> Let's restart the compiler meetings Wednesday next week <time datetime=\"2023-01-11T18:00:00Z\">2023-01-11T10:00:00-08:00</time></p>",
        "id": 319286531,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1672783045
    },
    {
        "content": "<p>Alright <span aria-label=\"thumbs up\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"thumbs up\">:thumbs_up:</span></p>",
        "id": 319286832,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1672783169
    },
    {
        "content": "<p>I am sorry, but I am currently overwhelmed and have to interrupt the weekly compiler meetings.</p>",
        "id": 320585464,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1673407483
    },
    {
        "content": "<p>Do other people have something they want to talk about? Otherwise I think we can just drop the meeting for today.</p>",
        "id": 320613184,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1673420155
    },
    {
        "content": "<p>I would be curious to talk about the LLVM annotations, but happy to do that next week.</p>",
        "id": 320618721,
        "sender_full_name": "Tobias Grosser",
        "timestamp": 1673421655
    },
    {
        "content": "<p>I'd wanted to see what the upcoming plans are, but happy to wait till next week as well!</p>",
        "id": 320754463,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1673457333
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"395550\">@Henrik Böving</span> we're at the meeting at <a href=\"https://meet.jit.si/moderated/d0b396c2c5c4b52a8c56808a0e0496708721485296975d95f40ebf1a17b58890\">https://meet.jit.si/moderated/d0b396c2c5c4b52a8c56808a0e0496708721485296975d95f40ebf1a17b58890</a></p>",
        "id": 320764329,
        "sender_full_name": "Siddharth Bhat",
        "timestamp": 1673460350
    },
    {
        "content": "<p>Oh I'm sorry I got caught up with work today.</p>",
        "id": 320793373,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1673469741
    },
    {
        "content": "<p>There was nothing new on my side though</p>",
        "id": 320793409,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1673469753
    },
    {
        "content": "<p>No worries! I was interested to describe a possible way to implement inline LLVM, but we can do that on chat as well :)</p>",
        "id": 320794403,
        "sender_full_name": "Siddharth Bhat",
        "timestamp": 1673470105
    },
    {
        "content": "<p>I'm flying to India today, so I won't make it to the meeting I'm afraid.</p>",
        "id": 321972463,
        "sender_full_name": "Siddharth Bhat",
        "timestamp": 1674017093
    }
]
[
    {
        "content": "<p>What is the mathlib way of encoding the following problem statement involving discrete probabilities:<br>\n<a href=\"/user_uploads/3121/WLY4VQuu1bCHJUaSlKm-KAio/aime-2021-day1-p1.png\">aime-2021-day1-p1.png</a> (the probability part, not the <em>find</em> part)</p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/WLY4VQuu1bCHJUaSlKm-KAio/aime-2021-day1-p1.png\" title=\"aime-2021-day1-p1.png\"><img src=\"/user_uploads/3121/WLY4VQuu1bCHJUaSlKm-KAio/aime-2021-day1-p1.png\"></a></div>",
        "id": 233675841,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1617896146
    },
    {
        "content": "<p>The closest existing definition in mathlib is probably <a href=\"https://leanprover-community.github.io/mathlib_docs/find/pmf\">docs#pmf</a> for finite probability distributions. However, that takes values in the nonnegative reals, and here you really want to use the fact that the probabilities are rational, so maybe the best encoding is just to define the probability function as a function into <code>ℚ</code> (without the additional info that it is a probability distribution)?</p>",
        "id": 233694615,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1617902939
    },
    {
        "content": "<p>Here is a way to state this problem by hand:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.rat.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.big_operators.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">tactic.derive_fintype</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">big_operators</span>\n\n<span class=\"kd\">abbreviation</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"mi\">6</span>\n\n<span class=\"kd\">@[derive [decidable_eq, fintype]</span><span class=\"o\">]</span> <span class=\"kd\">inductive</span> <span class=\"n\">racers</span>\n<span class=\"bp\">|</span> <span class=\"n\">Zou</span>\n<span class=\"bp\">|</span> <span class=\"n\">Chou</span>\n\n<span class=\"kn\">export</span> <span class=\"n\">racers</span>\n\n<span class=\"kd\">abbreviation</span> <span class=\"n\">races</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">racers</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">number_of_times_Zou_won</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">races</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">finset.univ.filter</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">Zou</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">card</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">probability_distribution</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">races</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span> <span class=\"o\">:=</span>\n<span class=\"k\">if</span> <span class=\"n\">r</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"n\">Chou</span> <span class=\"k\">then</span> <span class=\"mi\">0</span> <span class=\"k\">else</span>\n  <span class=\"bp\">∏</span> <span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"n\">finset.univ.erase</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">),</span> <span class=\"k\">if</span> <span class=\"n\">r</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">r</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"k\">then</span> <span class=\"mi\">2</span> <span class=\"bp\">/</span> <span class=\"mi\">3</span> <span class=\"k\">else</span> <span class=\"mi\">1</span> <span class=\"bp\">/</span> <span class=\"mi\">3</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">probability</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span> <span class=\"o\">:=</span>\n<span class=\"bp\">∑</span> <span class=\"n\">r</span> <span class=\"k\">in</span> <span class=\"n\">finset.univ.filter</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">races</span><span class=\"o\">,</span> <span class=\"n\">number_of_times_Zou_won</span> <span class=\"n\">r</span> <span class=\"bp\">=</span> <span class=\"mi\">5</span><span class=\"o\">),</span> <span class=\"n\">probability_distribution</span> <span class=\"n\">r</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">AIME2021_1</span> <span class=\"o\">:</span> <span class=\"n\">probability.num</span> <span class=\"bp\">+</span> <span class=\"n\">probability.denom</span> <span class=\"bp\">=</span> <span class=\"gr\">sorry</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>I don't think current mathlib will help you all that much simplifying the problem statement. We have finitary products of measures (not yet the fact that the product of probability measures is a probability measure, though that is trivial to add), but we don't have that for discrete probabilities.<br>\nFuture mathlib could have better support for <code>pmf</code>, including iterated events like here. However, when writing a formal proof for a problem like this, it is probably convenient to stay in <code>ℚ</code> and never mention real numbers.</p>",
        "id": 233700421,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1617904820
    },
    {
        "content": "<p>Thinking about it more, I think we can generalize <code>pmf</code> to a more general setting if we wanted, something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">pmf</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">linear_ordered_field</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">//</span> <span class=\"n\">has_sum</span> <span class=\"n\">f</span> <span class=\"mi\">1</span> <span class=\"bp\">∧</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>If we develop the theory <code>pmf</code> a bit more, we could also compute the probability using <code>pmf</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic.derive_fintype</span>\n<span class=\"kn\">import</span> <span class=\"n\">measure_theory.probability_mass_function</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">big_operators</span> <span class=\"n\">nnreal</span>\n\n<span class=\"kd\">noncomputable theory</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">pmf</span>\n<span class=\"sd\">/-- probability of a set `s` under a pmf `p`. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">prob</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">pmf</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"bp\">≥</span><span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"bp\">∑'</span> <span class=\"n\">i</span> <span class=\"o\">,</span> <span class=\"n\">s.indicator</span> <span class=\"n\">p</span> <span class=\"n\">i</span>\n\n<span class=\"sd\">/-- The pmf when iterating events. The pmf at event `i` can depend on the results of `j &lt; i`. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">iterate</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">ι</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">partial_order</span> <span class=\"n\">ι</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">Π</span> <span class=\"n\">j</span> <span class=\"bp\">&lt;</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">β</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">pmf</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">pmf</span> <span class=\"o\">(</span><span class=\"bp\">Π</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">β</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"bp\">∏</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">i</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">j</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">),</span> <span class=\"gr\">sorry</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">pmf</span>\n<span class=\"kn\">open</span> <span class=\"n\">pmf</span>\n\n<span class=\"kd\">abbreviation</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"mi\">6</span>\n\n<span class=\"kd\">abbreviation</span> <span class=\"n\">racers</span> <span class=\"o\">:=</span> <span class=\"n\">bool</span> <span class=\"c1\">-- we now define racers to be `bool`, so that we can use `bernoulli` below</span>\n<span class=\"kd\">abbreviation</span> <span class=\"n\">Zou</span> <span class=\"o\">:=</span> <span class=\"n\">tt</span>\n<span class=\"kd\">abbreviation</span> <span class=\"n\">Chou</span> <span class=\"o\">:=</span> <span class=\"n\">ff</span>\n\n<span class=\"kd\">abbreviation</span> <span class=\"n\">races</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">racers</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">number_of_times_Zou_won</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">races</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">finset.univ.filter</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">Zou</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">card</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">fin.sub_one_lt_self</span> <span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)}</span> <span class=\"o\">(</span><span class=\"n\">hi</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span> <span class=\"bp\">&lt;</span> <span class=\"n\">i</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">probability_distribution</span> <span class=\"o\">:</span> <span class=\"n\">pmf</span> <span class=\"n\">races</span> <span class=\"o\">:=</span>\n<span class=\"n\">iterate</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">i</span> <span class=\"n\">r</span><span class=\"o\">,</span>\n  <span class=\"n\">bernoulli</span> <span class=\"o\">(</span><span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">i</span>\n      <span class=\"k\">then</span> <span class=\"k\">if</span> <span class=\"n\">r</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fin.sub_one_lt_self</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">Zou</span> <span class=\"k\">then</span> <span class=\"mi\">2</span> <span class=\"bp\">/</span> <span class=\"mi\">3</span> <span class=\"k\">else</span> <span class=\"mi\">1</span> <span class=\"bp\">/</span> <span class=\"mi\">3</span>\n      <span class=\"k\">else</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">split_ifs</span><span class=\"bp\">;</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">nnreal.coe_le_coe</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">norm_num</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">probability</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"bp\">≥</span><span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"n\">probability_distribution.prob</span> <span class=\"o\">{</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">races</span> <span class=\"bp\">|</span> <span class=\"n\">number_of_times_Zou_won</span> <span class=\"n\">r</span> <span class=\"bp\">=</span> <span class=\"mi\">5</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>If anyone wants to make a PR to mathlib generalizing <code>pmf</code> or proving basic properties of <code>pmf.prob</code> and <code>pmf.iterate</code>, that would definitely be welcome.</p>",
        "id": 233713720,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1617909884
    },
    {
        "content": "<p>Is this probability computable by <code>#eval</code>? It seems like it would be</p>",
        "id": 233758290,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617934390
    },
    {
        "content": "<p>At least with the first one, it seems so:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#eval</span> <span class=\"n\">probability.num</span> <span class=\"bp\">+</span> <span class=\"n\">probability.denom</span> <span class=\"c1\">-- 97 :)</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">AIME2021_1</span> <span class=\"o\">:</span> <span class=\"n\">probability.num</span> <span class=\"bp\">+</span> <span class=\"n\">probability.denom</span> <span class=\"bp\">=</span> <span class=\"mi\">97</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span> <span class=\"c1\">-- fails :(</span>\n</code></pre></div>",
        "id": 233758539,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617934565
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"111080\">@Floris van Doorn</span> Thank you! Some of the <code>pmf</code> abstractions are indeed nice (<code>iterate</code>, <code>bernoulli</code>, <code>prob</code>). I am not sure if they are worth the cost of proofs-inside-the-statements though. At least in this simple example, the first-principles statement you gave first seems like a fine compromise.</p>",
        "id": 233763026,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1617938976
    }
]
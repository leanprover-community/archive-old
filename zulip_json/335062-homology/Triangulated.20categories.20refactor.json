[
    {
        "content": "<p>While working on localization of triangulated categories, I had some ideas about some refactors that would make the API more convenient:</p>\n<ul>\n<li>\n<p>Namespaces: move <code>category_theory.triangulated.pretriangulated</code> to <code>category_theory.pretriangulated</code> and introduce <code>category.triangulated</code> for triangulated categories (i.e. pretriangulated categories which satisfy the octahedron axiom)</p>\n</li>\n<li>\n<p>Remove some unnecessary explicit parameters like for <code>triangle.mk</code> which is currently <code>Π (C : Type u_2) [_inst_1 : category C] [_inst_2 : has_shift C ℤ] {X Y Z : C}, (X ⟶ Y) → (Y ⟶ Z) → (Z ⟶ (shift_functor C 1).obj X) → triangle C</code>, where <code>(C)</code> should be <code>{C}</code>.</p>\n</li>\n<li>\n<p>Shift functors are automatically additive. Currently, working with triangulated categories requires the following variables:<br>\n<code>variables {C : Type*} [category C] [preadditive C] [has_zero_object C] [has_shift C ℤ] [∀ (n : ℤ), functor.additive (shift_functor C n)] [pretriangulated C]</code><br>\nThe assumption that the shift functors are additive could be removed, if one observes that they are equivalences of categories (automatic because the shift is indexed by the group <code>ℤ</code>), and that an equivalence of categories between preadditive categories is additive (this is not yet in mathlib?).</p>\n</li>\n<li>\n<p>Triangulated functors:</p>\n<ul>\n<li>Currently, the commutation with the shift is stated only for <code>⟦1⟧</code>: it should be stated for all <code>⟦n⟧</code>, <code>n : ℤ</code> with some coherence properties. (I have draft code which shows that the datum of a series of such isos is equivalent to the datum of the commutation with <code>⟦1⟧</code>.)</li>\n<li>The definition of triangulated is currently bundled. This is obviously ok for the definition of the category of triangulated functors between two pretriangulated categories, but I would think it would be more convenient to consider them as ordinary functors <code>F : C ⥤ D</code> with a class instance <code>[functor.triangulated F]</code> which would say that for a certain series of commutation iso with the shift, <code>F</code> preserves distinguished triangles.</li>\n</ul>\n</li>\n</ul>\n<p>Any comments about these possible changes?</p>",
        "id": 303578008,
        "sender_full_name": "Joël Riou",
        "timestamp": 1665561930
    },
    {
        "content": "<blockquote>\n<p>equivalence of categories between preadditive categories is additive</p>\n</blockquote>\n<p>Is this true? Over a category with a single object, this seems to suggest that multiplicative morphisms between rings are automatically ring homomorphisms.</p>",
        "id": 303578503,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1665562123
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"439483\">Andrew Yang</span> <a href=\"#narrow/stream/335062-homology/topic/Triangulated.20categories.20refactor/near/303578503\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>equivalence of categories between preadditive categories is additive</p>\n</blockquote>\n<p>Is this true? Over a category with a single object, this seems to suggest that multiplicative morphisms between rings are automatically ring homomorphisms.</p>\n</blockquote>\n<p>Ah, I have forgotten to say that pretriangulated categories have finite coproducts. A better suggestion would be to assume <code>[has_finite_biproducts C]</code> instead of requiring that shift functors are additive. (I do not think that there is any case where checking the existence of finite biproducts would be harder than verifying that shift functors are additive.)</p>",
        "id": 303581197,
        "sender_full_name": "Joël Riou",
        "timestamp": 1665563396
    }
]
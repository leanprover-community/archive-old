[
    {
        "content": "<p>I have been thinking about the homology refactor, basically how to import in mathlib3/4 some constructions done in the LTE. One of the constructions I introduced was that of \"short complexes\" in a category <code>C</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- A short complex in a category `C` with zero morphisms is the datum</span>\n<span class=\"sd\">of two composable morphisms `f : X₁ ⟶ X₂` and `g : X₂ ⟶ X₃` such that</span>\n<span class=\"sd\">`f ≫ g = 0`. -/</span>\n<span class=\"kd\">structure</span> <span class=\"n\">short_complex</span> <span class=\"o\">[</span><span class=\"n\">has_zero_morphisms</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span><span class=\"n\">X₁</span> <span class=\"n\">X₂</span> <span class=\"n\">X₃</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span>\n<span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X₁</span> <span class=\"bp\">⟶</span> <span class=\"n\">X₂</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">X₂</span> <span class=\"bp\">⟶</span> <span class=\"n\">X₃</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">zero</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">≫</span> <span class=\"n\">g</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>All the API for homology should be adapted using <code>S : short_complex C</code> as an input, and then, when we want to apply this to homological complexes, we only have to consider complexes of the form <code>K.X (prev i) ⟶ K.X i ⟶ K.X (next i)</code>.</p>\n<p>Another innovation in the LTE was the <code>has_homology</code> structure. I introduced a more basic datum <code>homology_iso_datum</code>. Following both Adam's ideas and mine, I ended up defining a <code>left_homology_datum</code> for a short complex <code>S</code> :</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">left_homology_data</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">K</span> <span class=\"bp\">⟶</span> <span class=\"n\">S.X₂</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">π</span> <span class=\"o\">:</span> <span class=\"n\">K</span> <span class=\"bp\">⟶</span> <span class=\"n\">H</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">hi₀</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">≫</span> <span class=\"n\">S.g</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">hi</span> <span class=\"o\">:</span> <span class=\"n\">is_limit</span> <span class=\"o\">(</span><span class=\"n\">kernel_fork.of_ι</span> <span class=\"n\">i</span> <span class=\"n\">hi₀</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">hπ₀</span> <span class=\"o\">:</span> <span class=\"n\">hi.lift</span> <span class=\"o\">(</span><span class=\"n\">kernel_fork.of_ι</span> <span class=\"n\">_</span> <span class=\"n\">S.zero</span><span class=\"o\">)</span> <span class=\"bp\">≫</span> <span class=\"n\">π</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">hπ</span> <span class=\"o\">:</span> <span class=\"n\">is_colimit</span> <span class=\"o\">(</span><span class=\"n\">cokernel_cofork.of_π</span> <span class=\"n\">π</span> <span class=\"n\">hπ₀</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>This basically consists of the datum of a kernel <code>K</code> of <code>S.X₂ ⟶ S.X₃</code> and a cokernel <code>H</code> of the induced map <code>S.X₁ ⟶ K</code>.</p>\n<p>Dually, a <code>right_homology_datum</code> can be defined as a similar datum using a cokernel <code>Q</code> of <code>S.X₁ ⟶ S.X₂</code> and a kernel <code>H</code> of the induced map <code>Q ⟶ S.X₃</code>.</p>\n<p>Then, in a similar spirit as the <code>homology_gadget</code> suggested by Adam at <a href=\"#narrow/stream/267928-condensed-mathematics/topic/homology.20refactor/near/290844887\">https://leanprover.zulipchat.com/#narrow/stream/267928-condensed-mathematics/topic/homology.20refactor/near/290844887</a> (this is similar to the <code>has_homology</code> that is in the LTE), I define an <code>homology_data</code> for <code>S</code> as :</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">homology_data</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">left</span> <span class=\"o\">:</span> <span class=\"n\">S.left_homology_data</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">right</span> <span class=\"o\">:</span> <span class=\"n\">S.right_homology_data</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">iso</span> <span class=\"o\">:</span> <span class=\"n\">left.H</span> <span class=\"bp\">≅</span> <span class=\"n\">right.H</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">comm</span> <span class=\"o\">:</span> <span class=\"n\">left.π</span> <span class=\"bp\">≫</span> <span class=\"n\">iso.hom</span> <span class=\"bp\">≫</span> <span class=\"n\">right.ι</span> <span class=\"bp\">=</span> <span class=\"n\">left.i</span> <span class=\"bp\">≫</span> <span class=\"n\">right.p</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Then, one may define <code>[has_homology S]</code> when there exists such an <code>homology data</code>, and define the homology of <code>S</code> as the <code>left.H</code> field of such a data. By construction, this notion of homology is self-dual. From that, one may define a good self-dual notion of (short) exact sequences, etc. Recently, I was able to get the snake lemma (in a slightly easier manner than in the LTE). I have developed these ideas in a (draft) branch<br>\n<a href=\"https://github.com/leanprover-community/mathlib/tree/homology_refactor\">https://github.com/leanprover-community/mathlib/tree/homology_refactor</a></p>\n<p>The relevant code is in <code>algebra/homology/short_complex/</code>. Apart from the proof that short complexes in abelian categories have homology data, most of this code is quite straightforward and very boring, and when I tried to use this <code>short_complex</code> API in order to redefine the homology of homological complexes, etc, the transition was quite easy, and many definitions became shorter. Besides the self-dual notions of homology and exactness we<br>\nget, this allows to define exact sequences without assuming <code>[has_images C] [has_kernels C]</code>: for example, split short exact sequences in preadditive categories (with a zero object) are exact with my definition, but it does not make sense with the current definition in mathlib.</p>\n<p>I would rather do this refactor before the actual port of <code>mathlib</code> to <code>mathlib4</code> is done, so that I guess the best would be to introduce this in <code>mathlib</code> first. Then, I would like to do this refactor (which would start with the introduction of tidied versions of some of the files in <code>algebra/homology/short_complex/</code>, as a sequence of small PRs, followed with a large PR when the notions of homology currently in mathlib are replaced by this API). Any comments?</p>",
        "id": 312613608,
        "sender_full_name": "Joël Riou",
        "timestamp": 1669637532
    },
    {
        "content": "<p>It's great that you could simplify the snake lemma! I think that's a good test case.</p>",
        "id": 312616376,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1669638502
    }
]
[
    {
        "content": "<p>Just a quick message to kick off the discussion concerning the impending refactor of chain complexes and homology.</p>\n<p>What do people think about the following manuscript?<br>\n<a href=\"https://arxiv.org/pdf/2208.13282.pdf\">https://arxiv.org/pdf/2208.13282.pdf</a></p>",
        "id": 296325171,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1661952678
    },
    {
        "content": "<p>And the paper that this depends on: <a href=\"https://arxiv.org/abs/2101.06176\">https://arxiv.org/abs/2101.06176</a></p>",
        "id": 296326270,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1661952993
    },
    {
        "content": "<p>Interesting. I couldn't find any discussion about \"change of Q\". Would this framework make it easy to \"extend a complex by 0\" or to restrict to a subcomplex (eg from <code>int</code>-indexed to <code>nat</code>-indexed)?</p>",
        "id": 296327250,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1661953314
    },
    {
        "content": "<p>presumably those would boil down to whiskering!</p>",
        "id": 296327792,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1661953465
    },
    {
        "content": "<p>for \"restricting\" I can believe that.</p>",
        "id": 296327841,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1661953486
    },
    {
        "content": "<p>But extending is less trivial, I think</p>",
        "id": 296327868,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1661953497
    },
    {
        "content": "<p>maybe extending is an adjoint of restricting?</p>",
        "id": 296328007,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1661953533
    },
    {
        "content": "<p>not exactly</p>",
        "id": 296329098,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1661953895
    },
    {
        "content": "<p>at least not with naive resticting/extending</p>",
        "id": 296329267,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1661953941
    },
    {
        "content": "<p>Let <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span> be a nat-indexed cochain complex and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>X</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup></mrow><annotation encoding=\"application/x-tex\">X&#x27;</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7519em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span></span></span></span> its extension to a Z-cochain complex, and let <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>Y</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup></mrow><annotation encoding=\"application/x-tex\">Y&#x27;</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7519em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span></span></span></span> be any Z-cochain complex and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">Y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span></span></span></span> its restriction to N. Is it not the case that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>H</mi><mi>o</mi><mi>m</mi><mo stretchy=\"false\">(</mo><mi>X</mi><mo separator=\"true\">,</mo><mi>Y</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>H</mi><mi>o</mi><mi>m</mi><mo stretchy=\"false\">(</mo><msup><mi>X</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mo separator=\"true\">,</mo><msup><mi>Y</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">Hom(X,Y) = Hom(X&#x27;,Y&#x27;)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">Ho</span><span class=\"mord mathnormal\">m</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0019em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">Ho</span><span class=\"mord mathnormal\">m</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>?</p>",
        "id": 296329605,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1661954056
    },
    {
        "content": "<p>You need the square in indices <code>-1</code> and <code>0</code> to commute.</p>",
        "id": 296329659,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1661954081
    },
    {
        "content": "<p>But the path via <code>X' _{-1}</code> is always <code>0</code>.</p>",
        "id": 296329711,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1661954102
    },
    {
        "content": "<p>whereas the other one has no reason to be <code>0</code>.</p>",
        "id": 296329736,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1661954111
    },
    {
        "content": "<p>Other point: Those two papers are going full model category. They only ever talk about the homotopy category, but I didn't find a hands-on notion of homotopy between two complexes. I'm not sure what to make of that.</p>",
        "id": 296329935,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1661954178
    },
    {
        "content": "<p>I'm confused. <code>X'_{-1}</code> is zero, so any map originating from it would be zero.</p>",
        "id": 296330075,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1661954231
    },
    {
        "content": "<p>Ooh, maybe I want chain complexes</p>",
        "id": 296330276,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1661954284
    },
    {
        "content": "<p>Or whatever. A little variation on this situation will cause a problem.</p>",
        "id": 296330339,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1661954298
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">X_</span><span class=\"o\">{</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">}</span> <span class=\"c1\">---&gt; X_0</span>\n  <span class=\"bp\">|</span>          <span class=\"bp\">|</span>\n  <span class=\"n\">v</span>          <span class=\"n\">v</span>\n  <span class=\"mi\">0</span> <span class=\"c1\">------&gt; Y_0</span>\n</code></pre></div>",
        "id": 296330629,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1661954399
    },
    {
        "content": "<p>I'm extending X not Y</p>",
        "id": 296330752,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1661954426
    },
    {
        "content": "<p>So</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"mi\">0</span>  <span class=\"c1\">---&gt; X_0</span>\n   <span class=\"bp\">|</span>           <span class=\"bp\">|</span>\n  <span class=\"n\">v</span>          <span class=\"n\">v</span>\n<span class=\"n\">Y_</span><span class=\"o\">{</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">}</span> <span class=\"c1\">-----&gt; Y_0</span>\n</code></pre></div>",
        "id": 296330858,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1661954462
    },
    {
        "content": "<p>clearly I'm an expert at ASCII art</p>",
        "id": 296330936,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1661954495
    },
    {
        "content": "<p>Sure, but if you flip the direction of the differentials then you are in trouble.</p>",
        "id": 296330965,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1661954506
    },
    {
        "content": "<p>Which means that you need specific conditions on your <code>Q -&gt; Q'</code> before you can extend/restrict from one to the other with an adjunction.</p>",
        "id": 296331133,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1661954546
    },
    {
        "content": "<p>okay, yes, but if you flip for the extension, you also need to flip for the restriction</p>",
        "id": 296331162,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1661954554
    },
    {
        "content": "<p>Take the inclusion of <code>fin n</code> into <code>int</code>. You will either get problems close to <code>0</code> or close to <code>n</code>, depending on the direction of the differentials.</p>",
        "id": 296331303,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1661954606
    },
    {
        "content": "<p>right in this case there will be an issue at n for the cochain direction</p>",
        "id": 296331611,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1661954702
    },
    {
        "content": "<p>well, this is not much of an issue since we can define some extension functor in a similar way to what we do now, by saying that \"everything which is not in the image should be set to zero\"</p>",
        "id": 296331952,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1661954817
    },
    {
        "content": "<p>this is still something that can be checked on the quiver level</p>",
        "id": 296332029,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1661954841
    },
    {
        "content": "<p>So what about homotopies? Do they admit a clean definition?</p>",
        "id": 296332598,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1661955012
    },
    {
        "content": "<p>They need a theorem to describe the weak equivalences <span aria-label=\"grumpy\" class=\"emoji emoji-1f621\" role=\"img\" title=\"grumpy\">:grumpy:</span></p>",
        "id": 296337851,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1661956473
    },
    {
        "content": "<p>Right. That seems like a downside.</p>",
        "id": 296338053,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1661956539
    },
    {
        "content": "<p>The first idea that occurred to me when forming a derived category of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi><mo>:</mo><mo>=</mo><mi mathvariant=\"normal\">Fun</mi><mo>⁡</mo><mo stretchy=\"false\">(</mo><mi>Q</mi><mo separator=\"true\">,</mo><mi>A</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">F := \\operatorname{Fun}(Q,A)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\"><span class=\"mord mathrm\">Fun</span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">Q</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mclose\">)</span></span></span></span> for some abelian category was something a'la <a href=\"https://preprints.ihes.fr/2009/M/M-09-20.pdf\">Positselski</a></p>",
        "id": 296338400,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1661956662
    },
    {
        "content": "<p>You start with the pointwise abelian category structure on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">F</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span></p>",
        "id": 296338775,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1661956765
    },
    {
        "content": "<p>Then you quotient by the subcategory of objects coming from totalizations of exact sequences.</p>",
        "id": 296338983,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1661956813
    },
    {
        "content": "<p>You call the result your derived category</p>",
        "id": 296339036,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1661956832
    },
    {
        "content": "<p>It relates to the usual derived category because totalizations of exact sequences of complexes are acyclic, hence <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span> when inverting quasi-isomorphisms</p>",
        "id": 296339206,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1661956884
    },
    {
        "content": "<p>But in general it is not the same</p>",
        "id": 296339235,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1661956895
    },
    {
        "content": "<p>But generally in either of these approaches is there really a notion of 'homology'?</p>",
        "id": 296339546,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1661956967
    },
    {
        "content": "<p>At least of an object itself</p>",
        "id": 296339708,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1661957011
    },
    {
        "content": "<p>In both papers, the authors assume for most of the results that Q has a Serre functor (some abstract version of Q being selfinjective). This should not be satisfied for the N-indexed version of complexes. It lets the authors however deal with things like \"circular\" complexes, or even N-complexes, in the sense that d^N=0 in a uniform fashion.</p>",
        "id": 296400050,
        "sender_full_name": "Julian Külshammer",
        "timestamp": 1661962895
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/335062-homology/topic/Ideas.20for.20refactor/near/296329935\">said</a>:</p>\n<blockquote>\n<p>Other point: Those two papers are going full model category. They only ever talk about the homotopy category, but I didn't find a hands-on notion of homotopy between two complexes. I'm not sure what to make of that.</p>\n</blockquote>\n<p>I did not go into the details of these two papers, but there are ways to do computations in derived categories by using model category structures as it seems they do. For example, the category of bounded above complexes in an abelian category with enough projectives has a model category structure whose weak equivalences are the quasi-isomorphisms, cofibrant objects are complexes that are degreewise projective and all objects are fibrant. Then, for this model category, the fundamental lemma of homotopical algebra (which I have implemented in Lean and [some previous version of...] mathlib) precisely says that in the derived category, morphisms from a degreewise projective complex can be computed as \"homotopy classes\" of actual morphisms of complexes. There, \"homotopy classes\" of morphisms is to be understood in the context of Quillen's homotopical algebra, using cylinders or path objects. In the case of complexes, there are natural constructions of cylinders which makes it so that the homotopy relation using such a cylinder is almost by definition equiv to the usual notion of homotopy of morphisms of complexes.</p>\n<p>Then, using my work on homotopical algebra, we could do computations in the derived category (<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>D</mi><mo>−</mo></msup></mrow><annotation encoding=\"application/x-tex\">D^-</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7713em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7713em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">−</span></span></span></span></span></span></span></span></span></span></span>) in Lean/Mathlib if we could also show the axioms of model categories in the case I have mentionned above. I have done a significant part of the work for this, and some of the missing lemmas are presumably in some form or another in the LTE.</p>\n<p>However, if this would give a good first example of model category, I do not think that it would be the right way to do homological algebra with in Lean/Mathlib. I would think a better approach is to develop the notion of triangulated category, e.g. showing it is possible to localize a triangulated with respect to a triangulated subcategory, e.g. when we formally invert quasimorphisms in the homotopy category of an abelian category, the morphisms in the localized category can be described by a certain calculus of fractions. Then, the derived category of an abelian category (defined by localization) would be additive, triangulated, etc, and we could redefine <code>Ext</code> group using these, show we can compute them using projective or injective resolutions, etc.</p>\n<p>If \"homology\" could certainly be refactored, I do not think we need to consider significant changes to the definitions of complexes or homotopies.<br>\nAnyway, I would favour approaches which are based on standard \"mainstream\" mathematical works that have passed the test of time.</p>",
        "id": 296698473,
        "sender_full_name": "Joël Riou",
        "timestamp": 1662065844
    },
    {
        "content": "<p>Yes, I agree that we should make an effort to stay \"mainstream\".</p>",
        "id": 296748244,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1662091614
    },
    {
        "content": "<p>Also, thanks for explaining some of the abstract machinery. I'm not <em>that</em> familiar with it, so that's very helpful.</p>",
        "id": 296748272,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1662091664
    }
]
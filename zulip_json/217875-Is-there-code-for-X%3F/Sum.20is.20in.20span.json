[
    {
        "content": "<p>Do we have that if a number of elements is in a set <code>s</code>, then their sum is in the span? (Coincidentally, this was also just asked for linear combinations <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/linear.20combination.20is.20in.20span\">here</a> ). If not, maybe it'd be worth adding? I'm envisioning something like this: </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">linear_algebra.span</span>\n<span class=\"kn\">import</span> <span class=\"n\">logic.equiv.fin</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">mem_span_of_sum</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">d</span> <span class=\"bp\">→</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hm</span> <span class=\"o\">:</span> <span class=\"n\">set.range</span> <span class=\"n\">m</span> <span class=\"bp\">⊆</span> <span class=\"n\">s</span><span class=\"o\">)</span>\n  <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">∑</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">m</span> <span class=\"n\">i</span> <span class=\"bp\">∈</span> <span class=\"n\">submodule.span</span> <span class=\"n\">R</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">induction</span> <span class=\"n\">d</span> <span class=\"k\">with</span> <span class=\"n\">k</span> <span class=\"n\">hk</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">fintype.sum_equiv</span> <span class=\"n\">fin_zero_equiv</span><span class=\"o\">],</span>\n    <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">fintype.sum_empty</span><span class=\"o\">],</span>\n      <span class=\"n\">exact</span> <span class=\"n\">submodule.zero_mem</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">fin_zero_elim</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">empty.elim</span><span class=\"o\">,</span> <span class=\"o\">},</span> <span class=\"o\">},</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">equiv.sum_comp</span> <span class=\"o\">(</span><span class=\"n\">fin_succ_equiv</span> <span class=\"n\">k</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">fintype.sum_option</span><span class=\"o\">],</span>\n  <span class=\"n\">refine</span> <span class=\"n\">submodule.add_mem</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">fin_succ_equiv_symm_none</span><span class=\"o\">],</span>\n    <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">set.mem_of_subset_of_mem</span> <span class=\"n\">hm</span> <span class=\"o\">(</span><span class=\"n\">set.mem_range_self</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">k.succ</span><span class=\"o\">))),</span>\n    <span class=\"n\">exact</span> <span class=\"n\">set_like.mem_coe.mp</span> <span class=\"o\">(</span><span class=\"n\">set.mem_of_subset_of_mem</span> <span class=\"n\">submodule.subset_span</span> <span class=\"n\">this</span><span class=\"o\">),</span> <span class=\"o\">},</span>\n  <span class=\"n\">apply</span> <span class=\"n\">hk</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">fin_succ_equiv_symm_some</span><span class=\"o\">],</span>\n  <span class=\"n\">apply</span> <span class=\"n\">set.subset.trans</span> <span class=\"n\">_</span> <span class=\"n\">hm</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">set.range_comp_subset_range</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">k</span><span class=\"o\">),</span> <span class=\"n\">x.succ</span><span class=\"o\">)</span> <span class=\"n\">m</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>Of course, one might also allow maps from an arbitrary finite type etc.</p>",
        "id": 288227363,
        "sender_full_name": "Nikolas Kuhn",
        "timestamp": 1656711990
    },
    {
        "content": "<p>It would be simpler to prove if stated more generally instead of a sum over a fintype used for indexing, you used sum over a finset</p>",
        "id": 288229013,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1656713350
    },
    {
        "content": "<p>It follows trivially from <a href=\"https://leanprover-community.github.io/mathlib_docs/find/sum_mem\">docs#sum_mem</a>, doesn't it?</p>",
        "id": 288230986,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1656714978
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">linear_algebra.span</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">big_operators</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">mem_span_of_sum</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hm</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"bp\">⊆</span> <span class=\"n\">f</span> <span class=\"bp\">⁻¹'</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∑</span> <span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"bp\">∈</span> <span class=\"n\">submodule.span</span> <span class=\"n\">R</span> <span class=\"n\">s</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">refine</span> <span class=\"n\">sum_mem</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">intros</span> <span class=\"n\">x</span> <span class=\"n\">hx</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">submodule.mem_span</span><span class=\"o\">,</span>\n  <span class=\"n\">intros</span> <span class=\"n\">p</span> <span class=\"n\">hp</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"bp\">←</span><span class=\"n\">set.image_subset_iff</span> <span class=\"n\">at</span> <span class=\"n\">hm</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">hm.trans</span> <span class=\"n\">hp</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hx</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">mem_span_of_sum'</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">d</span> <span class=\"bp\">→</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hm</span> <span class=\"o\">:</span> <span class=\"n\">set.range</span> <span class=\"n\">m</span> <span class=\"bp\">⊆</span> <span class=\"n\">s</span><span class=\"o\">)</span>\n  <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">∑</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">m</span> <span class=\"n\">i</span> <span class=\"bp\">∈</span> <span class=\"n\">submodule.span</span> <span class=\"n\">R</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">refine</span> <span class=\"n\">mem_span_of_sum</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">set.image_subset_iff</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">hm</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 288232139,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1656716093
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Sum.20is.20in.20span/near/288230986\">said</a>:</p>\n<blockquote>\n<p>It follows trivially from <a href=\"https://leanprover-community.github.io/mathlib_docs/find/sum_mem\">docs#sum_mem</a>, doesn't it?</p>\n</blockquote>\n<p>Ah, great! Somehow I missed that.</p>",
        "id": 288233135,
        "sender_full_name": "Nikolas Kuhn",
        "timestamp": 1656716934
    },
    {
        "content": "<p>I like your solution, Yakov! Maybe you could think making it a PR? (I'm still new, so you can probably better judge whether you think it's suitable)</p>",
        "id": 288233620,
        "sender_full_name": "Nikolas Kuhn",
        "timestamp": 1656717471
    },
    {
        "content": "<p>Since you're new, you making a PR on this would be a great way to get familiar with the process.</p>",
        "id": 288233729,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1656717595
    },
    {
        "content": "<p>I'm not convinced either lemma is really worth having vs just using the existing API. Does using <a href=\"https://leanprover-community.github.io/mathlib_docs/find/submodule.subset_span\">docs#submodule.subset_span</a> make the first proof even shorter?</p>",
        "id": 288253622,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1656744905
    },
    {
        "content": "<p>Using the suggestion, I got the first one down to </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">mem_span_of_sum</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hm</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">''</span> <span class=\"n\">t</span> <span class=\"bp\">⊆</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∑</span> <span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"bp\">∈</span> <span class=\"n\">submodule.span</span> <span class=\"n\">R</span> <span class=\"n\">s</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">refine</span> <span class=\"n\">sum_mem</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">intros</span> <span class=\"n\">x</span> <span class=\"n\">hx</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">set.mem_of_mem_of_subset</span> <span class=\"n\">_</span> <span class=\"n\">submodule.subset_span</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">set.mem_of_mem_of_subset</span> <span class=\"o\">(</span><span class=\"n\">set.mem_image_of_mem</span> <span class=\"n\">f</span> <span class=\"n\">hx</span><span class=\"o\">)</span> <span class=\"n\">hm</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>(note the change to <code> (hm : f '' t ⊆ s)</code> in the hyothesis, I'm not sure either one is better). <br>\nI agree that this is probably too close to <code>sum_mem</code> to be worth it, but I find the version using a sum over a fintype the most natural, so it might be nice to have it.</p>",
        "id": 288273934,
        "sender_full_name": "Nikolas Kuhn",
        "timestamp": 1656773122
    },
    {
        "content": "<p>I think <code>apply subset_span</code> directly would work after the <code>intros</code>?</p>",
        "id": 288274224,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1656773596
    },
    {
        "content": "<p>It does! So <code>apply</code> knows about <code>set.mem_of_mem_of subset</code>?!</p>",
        "id": 288275103,
        "sender_full_name": "Nikolas Kuhn",
        "timestamp": 1656774673
    },
    {
        "content": "<p>Have a look at how <a href=\"https://leanprover-community.github.io/mathlib_docs/find/set.mem_of_mem_of_subset/src\">src#set.mem_of_mem_of_subset</a> is proved</p>",
        "id": 288275304,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1656774959
    },
    {
        "content": "<p>Those are very good hints: </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">mem_span_of_sum</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hm</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">''</span> <span class=\"n\">t</span> <span class=\"bp\">⊆</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∑</span> <span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"bp\">∈</span> <span class=\"n\">submodule.span</span> <span class=\"n\">R</span> <span class=\"n\">s</span> <span class=\"o\">:=</span>\n  <span class=\"n\">sum_mem</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">hx</span><span class=\"o\">,</span> <span class=\"n\">submodule.subset_span</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">(</span><span class=\"n\">set.mem_image_of_mem</span> <span class=\"n\">f</span> <span class=\"n\">hx</span><span class=\"o\">)))</span>\n</code></pre></div>",
        "id": 288276219,
        "sender_full_name": "Nikolas Kuhn",
        "timestamp": 1656776185
    },
    {
        "content": "<p>And by taking the same proof term, you can make the other version a one-liner, too (not depending on this one):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">mem_span_of_sum'</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">M</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">d</span> <span class=\"bp\">→</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">set.range</span> <span class=\"n\">f</span> <span class=\"bp\">⊆</span> <span class=\"n\">s</span><span class=\"o\">)</span>\n  <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"bp\">∑</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"bp\">∈</span> <span class=\"n\">submodule.span</span> <span class=\"n\">R</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">sum_mem</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">hx</span><span class=\"o\">,</span> <span class=\"n\">submodule.subset_span</span>  <span class=\"bp\">$</span> <span class=\"n\">hf</span> <span class=\"bp\">$</span> <span class=\"n\">set.mem_range_self</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I see what you mean now.</p>",
        "id": 288276715,
        "sender_full_name": "Nikolas Kuhn",
        "timestamp": 1656776913
    }
]
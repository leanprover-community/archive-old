[
    {
        "content": "<p>I was trying to write a program in the latest version of lean 3, and here are certain things I couldn’t find documentation for, causing a bunch of errors.<br>\n-creating and casting vectors as lists<br>\n-casting option a’s as a‘s<br>\n-inhabiting a predicate as the input to a function, such as list.nth_le, that calls for it<br>\n-taking apart ordered pairs<br>\n-using list.foldr<br>\n-syntax for lambdas giving something of type a -&gt; b rather than \\Pi (x:a) : b<br>\n-syntax for let expressions<br>\n-syntax for quantifiers<br>\n-a function to do the same thing to a list of lists each the same length as is done to a matrix when it is transposed<br>\n-a higher order function to apply a given function an arbitrary number of times<br>\n-syntax for declaring refinement types and creating elements thereof<br>\n-expressing and proving worst case asymptotic runtimes for a program written in the purely functional language, according to the tm2 model(this is part of my ultimate goal)</p>",
        "id": 257203859,
        "sender_full_name": "Jared green",
        "timestamp": 1634045880
    },
    {
        "content": "<blockquote>\n<p>-creating and casting vectors as lists</p>\n</blockquote>\n<p>Create a vector with <a href=\"https://leanprover-community.github.io/mathlib_docs/find/vector.nil\">docs#vector.nil</a> and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/vector.cons\">docs#vector.cons</a>, convert it to a list with <code>vec.1</code></p>\n<blockquote>\n<p>-casting option a’s as a‘s</p>\n</blockquote>\n<p>Can't do it, that's unsound. But <a href=\"https://leanprover-community.github.io/mathlib_docs/find/option.get\">docs#option.get</a> will get the value if it is not none, and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/option.iget\">docs#option.iget</a> will get the value or a default value of the type</p>\n<blockquote>\n<p>-inhabiting a predicate as the input to a function, such as list.nth_le, that calls for it</p>\n</blockquote>\n<p>The easiest way is <code>dec_trivial</code>, although it doesn't always apply. In general, well it's a proof goal</p>\n<blockquote>\n<p>-taking apart ordered pairs</p>\n</blockquote>\n<p>You can use <code>let (a, b) := pair in ...</code> or <code>pair.1</code> and <code>pair.2</code> (which are short for <a href=\"https://leanprover-community.github.io/mathlib_docs/find/prod.fst\">docs#prod.fst</a> and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/prod.snd\">docs#prod.snd</a>)</p>\n<blockquote>\n<p>-using list.foldr</p>\n</blockquote>\n<p>It folds a function from right to left, i.e. <code>foldr f z [1, 2, 3] = f 1 (f 2 (f 3 z))</code></p>\n<blockquote>\n<p>-syntax for lambdas giving something of type a -&gt; b rather than \\Pi (x:a) : b</p>\n</blockquote>\n<p><code>a -&gt; b</code> is the same as <code>\\Pi (x:a) : b</code>, and there is only one lambda</p>\n<blockquote>\n<p>-syntax for let expressions</p>\n</blockquote>\n<p><code>let x : type := value in expr</code></p>\n<blockquote>\n<p>-syntax for quantifiers</p>\n</blockquote>\n<p><code>\\forall x : type, prop</code>, <code>\\exists x : type, prop</code></p>\n<blockquote>\n<p>-a function to do the same thing to a list of lists each the same length as is done to a matrix when it is transposed</p>\n</blockquote>\n<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/list.transpose\">docs#list.transpose</a></p>\n<blockquote>\n<p>-a higher order function to apply a given function an arbitrary number of times</p>\n</blockquote>\n<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/nat.iterate\">docs#nat.iterate</a></p>\n<blockquote>\n<p>-syntax for declaring refinement types and creating elements thereof</p>\n</blockquote>\n<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/subtype\">docs#subtype</a>, <a href=\"https://leanprover-community.github.io/mathlib_docs/find/subtype.mk\">docs#subtype.mk</a>. The syntax is <code>{x // p x}</code> for the type, <code>⟨x, h⟩</code> for creating an element of the type, and <code>p.1</code> and <code>p.2</code> for extracting the components</p>\n<blockquote>\n<p>-expressing and proving worst case asymptotic runtimes for a program written in the purely functional language, according to the tm2 model(this is part of my ultimate goal)</p>\n</blockquote>\n<p>It's not possible to prove runtime bounds on programs written in pure lean, because runtime is not preserved by lean equality. But for functions which are deeply embedded i.e. in the TM2 model it is possible. Unfortunately the infrastructure isn't there yet</p>",
        "id": 257205653,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1634046551
    },
    {
        "content": "<p>dec_trivial isn’t working.<br>\n vec.l isn’t working. <br>\nProd.and and <a href=\"http://prod.fast\">prod.fast</a> works in some places, but where it doesn’t, neither does pair.1 and pair.2 . <br>\nI have a universal quantifier that looks like as follows, where apparently d is an unknown identifier:<br>\n\\forall a, b, c, d : \\nat, &lt;pred&gt; <br>\nIs it in fact valid to use the \\in symbol to check for the presence of a given value in a list?<br>\nIs there a function to find where it is afterward?<br>\nWhen using foldr, and the function I’m using is &amp;&amp; or +(nat), how do i do that?<br>\nAnd, in some places lean seems to expect a (Type: Type 1) rather than an element of the type i thought it should. Why?</p>",
        "id": 257224306,
        "sender_full_name": "Jared green",
        "timestamp": 1634053462
    },
    {
        "content": "<p>*thats prod.snd and prod.fst</p>",
        "id": 257227797,
        "sender_full_name": "Jared green",
        "timestamp": 1634054694
    },
    {
        "content": "<p>It's hard to help you without seeing your code. Would you mind providing a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>?</p>",
        "id": 257228808,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1634055096
    },
    {
        "content": "<p>I think that instead of asking 100 questions it might be easier to ask fewer questions and back them all up with a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> . Nobody can debug \"dec_trivial isn't working\" with no further information -- it works for me</p>",
        "id": 257228933,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1634055135
    },
    {
        "content": "<p>this is the nearly first 250 of nearly 500  lines i have written. not sure if it counts as an mwe, for it doesnt in fact work. the rest in the next comment:</p>\n<p>import data.list<br>\nimport data.vector.basic<br>\nimport <a href=\"http://data.prod\">data.prod</a><br>\nopen classical</p>\n<p>variables a b c: Type</p>\n<p>structure bitnode := <br>\n  mk :: (value : bool)<br>\n  (indices : list (ℕ × ℕ)) --these pointers indicate what it is connected to<br>\n  (isconstant : bool)<br>\n  (considered : bool)</p>\n<p>structure gatenode :=<br>\n  mk :: (valence : ℕ)<br>\n  (possib : list ( vector bool valence))--i dont know how to create vectors or cast them as lists<br>\n  (state : bool × (vector (bool) valence)) --the fst of this indicates that the front of consideration has passed the node<br>\n  (indices : vector ℕ valence)</p>\n<p>def reversible (a : gatenode) : Prop :=<br>\n  (∀ b c d : ℕ, (b &lt; a.possib.length → c &lt; a.possib.length → d &lt; a.valence<br>\n    → (<br>\n          --the entry is fully determined by all but one bit. represented in haskell like so:<br>\n      --(<br>\n                --remove_nth <br>\n                --((a.possib))!!b  d<br>\n                --== <br>\n                --remove_nth<br>\n                --( (a.possib))!!c  d<br>\n            --)<br>\n            --&lt;-&gt;<br>\n            (<br>\n                (((a.possib))!!b)!!d<br>\n                == <br>\n                ((a.possib))!!c)!!d<br>\n            )<br>\n      )</p>\n<div class=\"codehilite\"><pre><span></span><code>)\n</code></pre></div>\n\n<p>)<br>\n  )<br>\n--the types of gates: not, and 3-unique, which is complete<br>\n----an AND gate can be constructed as follows:<br>\n            -- bits 1-8. inputs to bit 3,7. output bit 5. 3unique(1,2,3), 3unique(4,5,6), NOT(7,8), 3unique(1,4,7), 3unique(2,5,8), NOT(3,6)<br>\n            -- the OR gate can be constructed the same way, with the output put through a NOT, and the inputs at 6,8.<br>\n            --therefore 3-unique is functionally complete.<br>\ndef mknot (c: vector ℕ 2) : gatenode :=<br>\n  {valence := 2, possib := [vector.cons ff (vector.cons tt vector.nil),vector.cons tt (vector.cons ff vector.nil)],<br>\n  state := (ff,vector.cons ff (vector.cons tt vector.nil)), indices := c}</p>\n<p>def mk3unique (c: vector ℕ 3) : gatenode :=<br>\n{valence := 3, possib := [vector.cons ff(vector.cons ff (vector.cons tt vector.nil)),<br>\nvector.cons ff(vector.cons tt(vector.cons ff vector.nil)),<br>\nvector.cons tt(vector.cons ff(vector.cons ff vector.nil))],<br>\n  state := (ff,(vector.cons ff(vector.cons ff(vector.cons tt vector.nil)))), indices := c}</p>\n<p>structure satnet :=  --i use an undirected graph representation of a sat instance, <br>\n                     --implemented as lists with indices as pointers<br>\nmk:: (bts : list bitnode)(gts : list gatenode)<br>\n(nextbits : list ℕ)(nextgates : list ℕ)(table : list ℕ × list (list bool))<br>\n(tablesequence: list (list ℕ × list (list bool)))</p>\n<p>--all indices must be within range.<br>\n--the corresponding function is implemented in haskell like so:</p>\n<p>--vetnet :: satnet -&gt; bool<br>\n--vetnet a =  <br>\n    --fold &amp;&amp; map (\\x-&gt;(fold &amp;&amp; map (\\y-&gt;(bts a !!(indices((gts a) !! (fst y))!! (snd y))== y))(indices x))) (bts a) <br>\n    --&amp;&amp; <br>\n    --fold &amp;&amp; map (\\x-&gt;(fold &amp;&amp; map (\\y-&gt;(fold || map (\\z-&gt;(((gts a)!! (fst z)) == x &amp;&amp; (indices((gts b)!! (fst z))!! <br>\n  --(snd z))== y)) (indices y)!! y )) indices x))(gts a)  </p>\n<p>def solv1 (s : satnet) :satnet := --start by, if possible, considering the bits that are constant<br>\nlet cond:Prop := (--should be a true prop if there are no nodes satisfying the lambda expression<br>\n    list.length <br>\n    (<br>\n      list.filter <br>\n      (λx,(<br>\n         ((bitnode.isconstant x) = tt)<br>\n      ))<br>\n      s.bts<br>\n    ) = 0<br>\n  ) ,<br>\n  set:list ℕ  := <a href=\"http://list.map\">list.map</a> prod.fst  <br>\n  (list.filter                      <br>\n  (<br>\n    (λx,( <br>\n       ((bitnode.isconstant x) = tt) <br>\n    )) ∘ prod.snd<br>\n  ) <br>\n  (<br>\n    list.zip <br>\n    (<br>\n      list.range <br>\n      (<br>\n        list.length s.bts<br>\n      )<br>\n    )<br>\n    s.bts<br>\n  )) in<br>\n{bts := s.bts,<br>\ngts := s.gts,<br>\n  nextbits := <br>\n  if cond <br>\n  then [0] <br>\n  else set,<br>\n  nextgates := s.nextgates,<br>\n  table := s.table, <br>\n  tablesequence:= []<br>\n  }</p>\n<p>def solv2 (s: satnet) : satnet := --get the first gate and table on the list<br>\nlet set:list ℕ := list.erase_dup  --actually leaves in the last copy of the set of duplicates, but is nonetheless consistent<br>\n  ( <a href=\"http://list.map\">list.map</a><br>\n    (<br>\n      list.foldr <br>\n      (<br>\n        list.append <br>\n        (<br>\n<a href=\"http://list.map\">list.map</a> prod.fst ∘ bitnode.indices <br>\n          (<br>\n            list.filter (λx,( ¬ (bitnode.considered x) = tt))<br>\n            (<br>\n<a href=\"http://list.map\">list.map</a> <br>\n              (λx,(<br>\n                list.nth_le s.bts x (dec_trivial)<br>\n              ))<br>\n              s.nextbits<br>\n            )<br>\n          )<br>\n        )<br>\n      )<br>\n    )<br>\n  )<br>\n  in<br>\n{ bts := s.bts, <br>\ngts := s.gts, <br>\nnextbits := s.nextbits, <br>\nnextgates:= <br>\n  if list.length s.nextgates = 0 then if list.length set = 0 then [0] else [list.head set] else s.nextgates,<br>\n  table := if list.length s.nextgates = 0 then if list.length set = 0 then <br>\n   (vec.l gatenode.indices (list.nth_le  s.gts (list.head set) dec_trivial ),<br>\n<a href=\"http://list.map\">list.map</a> vec.l (gatenode.possib (list.nth_le s.gts (list.head set) dec_trivial) ))<br>\n  else (vec.l gatenode.indices (list.nth_le s.gts (list.head set) dec_trivial),<br>\n<a href=\"http://list.map\">list.map</a> vec.l (gatenode.possib (list.nth_le s.gts (list.head set) dec_trivial))) else s.table,</p>\n<p>tablesequence := if list.length s.nextgates = 0 <br>\n  then if list.length set = 0 <br>\n  then [(vec.l (gatenode.indices (list.head s.gts)), <a href=\"http://list.map\">list.map</a> vec.l (gatenode.possib (list.head s.gts)))] <br>\n  else [(vec.l (gatenode.indices (list.nth_le s.gts (list.head set) dec_trivial)),<br>\n<a href=\"http://list.map\">list.map</a> vec.l (gatenode.possib (list.nth_le s.gts (list.head set) dec_trivial)))] <br>\n  else s.tablesequence<br>\n}</p>\n<p>def solv3 (s:satnet) : satnet :=  --remove those bits that the front of consideration has passed from nextbits<br>\n{<br>\n  bts := s.bts, gts := s.gts, nextbits := <br>\n  list.filter <br>\n  (λy,(<br>\n     ((<br>\n      list.foldr <br>\n      (λz,λw,(z &amp;&amp; w))<br>\n      (<a href=\"http://list.map\">list.map</a> <br>\n        (λx:ℕ,(<br>\n          pair.1  --im not sure what im doing wrong when it comes to taking ordered pairs apart,<br>\n                    -- as that seems to be the source of most of the errors in the file0<br>\n          gatenode.state <br>\n          (list.nth<br>\n          s.gts<br>\n          x<br>\n        ))<br>\n          (<br>\n<a href=\"http://list.map\">list.map</a> <br>\n            prod.fst <br>\n            (<br>\n              bitnode.indices <br>\n              y<br>\n            )<br>\n          ) = tt<br>\n        )<br>\n      )<br>\n    ))<br>\n  ))<br>\n  (list.erase_dup<br>\n  (<br>\n    list.foldr <br>\n    (<br>\n      list.append <br>\n      (<br>\n<a href=\"http://list.map\">list.map</a> (λx:gatenode,(vec.l gatenode.indices x)) <br>\n        (<br>\n          list.filter <br>\n          (λx,( ¬ (<br>\n            prod.fst (gatenode.state x)<br>\n          ) = tt)) <br>\n          (<br>\n<a href=\"http://list.map\">list.map</a> --how to turn an option a to an a?<br>\n            (λx,(<br>\n              list.nth_le s.gts x dec_trivial<br>\n            ))<br>\n            s.nextbits<br>\n          )<br>\n        )<br>\n      )<br>\n    )<br>\n  ))<br>\n  , nextgates := s.nextgates,<br>\n  table := s.table,<br>\n  tablesequence := s.tablesequence<br>\n}</p>\n<p>def size (l: list (list a)) : ℕ :=<br>\n (list.foldr (λx,λy,(nat.add x y)) (<a href=\"http://list.map\">list.map</a> list.length l)) </p>\n<p>def tables (s:satnet)(g: ℕ ) : list ℕ × list (list bool) :=  --make a table listing all the ways that nextbits could be, <br>\n                                                              --given the last table in s.tablesequence and the gate at index g<br>\nlet set: list ℕ  := <br>\nlist.erase_dup (list.append s.nextbits (vec.l gatenode.indices (list.nth_le s.gts g dec_trivial)) <br>\nin <br>\n  (set,(<br>\n    --implement like so:<br>\n    --intersect set with that of nth tablesequence length - 1<br>\n    let <br>\n    --the states that are compatible<br>\n    subset : list list bool := <br>\n    list.filter (λx,(        --why is d unknown?<br>\n      ∀ a, b, c, d : ℕ, a &lt; (list.length s.bts) → b &lt; gatenode.valence (list.nth_le s.gts g dec_trivial) → c &lt; list.length prod.fst <br>\n        (list.nth s.tablesequence (nat.sub (list.length s.tablesequence) 1))<br>\n         → list.nth_le (gatenode.indices list.nth s.gts) b dec_trivial =  list.nth_le (prod.fst <br>\n         (list.nth_le s.tablesequence (nat.sub (list.length s.tablesequence) 1) dec_trivial)) c dec_trivial<br>\n         → d &lt; list.length (prod.snd <br>\n         (list.nth_le s.tablesequence (nat.sub (list.length s.tablesequence) 1) dec_trivial)) <br>\n         → ¬ list.nth_le (list.nth_le (prod.snd <br>\n         (list.nth s.tablesequence (nat.sub (list.length s.tablesequence) 1))) c dec_trivial) d dec_trivial = vector.nth_le x b dec_trivial<br>\n        )</p>",
        "id": 257230802,
        "sender_full_name": "Jared green",
        "timestamp": 1634055833
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code>\n</code></pre></div>\n\n<p>and here is the rest:</p>\n<p>) (gatenode.possib (list.nth s.gts g)),<br>\n    expset : list list bool := list.foldr λz,(list.concat z) (<a href=\"http://list.map\">list.map</a> λx,( <a href=\"http://list.map\">list.map</a> λy,(list.append x y))  <br>\n    (prod.snd (list.nth s.tablesequence (nat.sub (list.length s.tablesequence) 1))) (subset))<br>\n    in list.erase_dup (<br>\n      list.transpose --by transpose, i mean like matrix transposition<br>\n      (<br>\n<a href=\"http://list.map\">list.map</a> prod.snd <br>\n        (<br>\n          list.erase_dup <br>\n          ( list.filter (λx,( (list.fst x ∈ (set))))<br>\n            list.zip <br>\n            ( list.append<br>\n              prod.fst <br>\n              (<br>\n                list.nth s.tablesequence <br>\n                (<br>\n                  nat.sub <br>\n                  (<br>\n                    list.length s.tablesequence<br>\n                  ) <br>\n                  1<br>\n                )<br>\n              ) <br>\n              (gatenode.indices (list.nth s.gts g))<br>\n            ) <br>\n            list.transpose <br>\n            (<br>\n              list.erase_dup expset<br>\n            )<br>\n          )<br>\n        )<br>\n      )<br>\n    )<br>\n  ))</p>\n<p>def solv4 (s:satnet) : satnet := --construct the smallest table for any choice in how the front of consideration is to advance<br>\n{bts := s.bts,<br>\n gts := s.gts,<br>\n nextbits := s.nextbits,<br>\n  nextgates := list.concat <br>\n  s.nextgates <br>\n  (<br>\n    list.argmin <br>\n    (<br>\n     size (prod.snd<br>\n      (λx,(tables s x)))<br>\n    ) <br>\n    (<br>\n      list.filter <br>\n      (λx,(¬ ((prod.fst (gatenode.state (list.nth_le s.gts x dec_trivial))= tt) ∨  x ∈ s.nextgates))) <br>\n      (list.range (list.length s.gts))<br>\n    )<br>\n  ),                                      <br>\n   table := list.argmin λx,(size (prod.snd x)) (<a href=\"http://list.map\">list.map</a> (λx,(tables s x)) (list.range (list.length s.gts))), <br>\n  --the one thing i'm not sure on, <br>\n  --the maximum number of entries in this table, if im correct,<br>\n  -- grows no faster than the number of gates <br>\n  --sketch:<br>\n  --initially, the front of consideration is fully determined until it reaches the edge of a bubble<br>\n  -- a bubble is here defined as a subset of the satnet s where determination on the outside has no bearing on the inside, though not necessarily vice versa<br>\n  --the edge of a bubble is formed by one ore more cycles of gates connected to bits on the inside, and each one has a single line outwards<br>\n  --for each cycle, there are at most two distinct states the whole cycle can be in<br>\n  -- the most efficient traversal through that is to consider the consequences of one cycle at a time, <br>\n  --as that keeps the number of entries below some constant<br>\n  --it will take an automated proof search to prove that this is always possible</p>\n<p>--though i do know that it is definitely subexponential,<br>\n  -- at most 2^(sqrt(n))<br>\n  --sketch:<br>\n  --the width of the front of consideration grows linearly and then shrinks linearly<br>\n  -- from one gate to its maximum than back down to just one again<br>\n  --for the maximum to be the absolute worst case, the system must approximate a square with the disjoint subsets that the front passes through in layers<br>\n  --the maximum width then is sqrt(2n)<br>\n  --the maximum number of states that can take on is O(2^(sqrt(2n)))<br>\n  --qed, therefore the exponential time hypothesis is false<br>\n  tablesequence := s.tablesequence<br>\n}</p>\n<p>def solv5 (s:satnet) : satnet :=   --place the new table in the squence<br>\n{bts := s.bts, <br>\ngts := s.gts, <br>\nnextbits := s.nextbits,<br>\nnextgates := s.nextgates,<br>\ntable := s.table,<br>\ntablesequence := list.concat s.tablesequence s.table<br>\n}</p>\n<p>--say that the bitnodes and gatenodes that the front of consideration has passed are considered<br>\ndef reconsider (s:satnet)(b:ℕ ) : bitnode :=<br>\n  {<br>\n    value := bitnode.value (list.nth_le s.bts b dec_trivial),<br>\n    indices := bitnode.indices (list.nth_le s.bts b dec_trivial),<br>\n    isconstant := bitnode.isconstant (list.nth_le s.bts b dec_trivial),<br>\n    considered := <br>\n    if <br>\n    list.foldr <br>\n    (λz,λw,(z &amp;&amp; w)) <br>\n    (<a href=\"http://list.map\">list.map</a> <br>\n    (λx,(<br>\n     prod.fst x ∈ s.nextgates <br>\n    )) <br>\n    (<br>\n      bitnode.indices <br>\n      (list.nth_le s.bts b dec_trivial)<br>\n    ) )<br>\n    then <br>\n    tt <br>\n    else <br>\n    bitnode.considered <br>\n    (list.nth_le s.bts b dec_trivial)<br>\n  }</p>\n<p>def solv6 (s:satnet) : satnet := <br>\n{bts := <a href=\"http://list.map\">list.map</a> (λx,(reconsider s x)) (list.range (list.length s.bts)),<br>\ngts := s.gts,<br>\nnextbits := s.nextbits,<br>\nnextgates := s.nextgates,<br>\ntable := s.table,<br>\ntablesequence := s.tablesequence<br>\n}</p>\n<p>def greconsider (s:satnet)(g:ℕ )(c:bool) : gatenode :=<br>\n{valence := gatenode.valence (list.nth_le s.gts g dec_trivial),<br>\npossib := gatenode.possib (list.nth_le s.gts g dec_trivial),<br>\nindices := gatenode.indices (list.nth_le s.gts g dec_trivial),<br>\nstate := <br>\n(<br>\n  (<br>\n    if <br>\n    c <br>\n    then <br>\n    tt <br>\n    else <br>\n    (<br>\n      prod.fst <br>\n      (gatenode.state (list.nth_le s.gts g dec_trivial))<br>\n    )<br>\n  ), <br>\n  (<br>\n    prod.snd <br>\n    (gatenode.state (list.nth_le s.gts g dec_trivial))<br>\n  )<br>\n)<br>\n}</p>\n<p>def solv7 (s:satnet) : satnet :=<br>\nlet set:list ℕ  := list.filter<br>\n(λy,(<br>\n  ((<br>\n    list.foldr <br>\n    (λz,λw,(z &amp;&amp; w)) <br>\n    (<a href=\"http://list.map\">list.map</a><br>\n      (λx,(<br>\n        bitnode.considered x<br>\n      ) = tt) <br>\n      (vec.l (gatenode.indices (list.nth_le s.gts y dec_trivial)))<br>\n    )<br>\n  ) )<br>\n))<br>\n(<br>\n  list.range<br>\n  (list.length s.gts)<br>\n)<br>\nin<br>\n{bts := s.bts, <br>\ngts := <a href=\"http://list.map\">list.map</a> (λx,(greconsider s x (x ∈ set))) (list.range (list.length s.gts))<br>\n,nextbits := s.nextbits,<br>\nnextgates := list.filter (λx,(¬ (x ∈ set))) s.nextgates,<br>\ntable := s.table,<br>\ntablesequence := s.tablesequence<br>\n}</p>\n<p>def solvcycle : satnet -&gt; satnet := --the cycle starts in solv3.<br>\n solv7 ∘ solv6 ∘ solv5 ∘ solv4 ∘ solv3 </p>\n<p>def solvcert (s:satnet ): satnet := --this is the information required to 'certify' satisfiability without a witness<br>\n(nat.iterate  solvcycle (nat.sub (list.length s.gts) 1)) ((solv2 ∘ solv1) s)</p>\n<p>def solvdecide (s:satnet): bool := list.length (prod.snd (satnet.table (solvcert s))) &gt; 0  --this 'solves the decision problem'</p>\n<p>def solvretract1 (s:satnet) : satnet :=    --pick an entry, possibly random, in the last table and commit to it<br>\n-- choose a nat in 0..length (snd (last table), maybe randomly<br>\nlet choicen : ℕ :=<br>\nrandom  (0, list.length prod.snd s.table)<br>\nin<br>\n{bts :=<br>\n--set the value of each bitnode to that in the entry corresponding to the number previously chosen<br>\n<a href=\"http://list.map\">list.map</a> <br>\n(λx:ℕ,<br>\n{value := if x ∈ prod.fst s.table <br>\nthen list.nth_le (list.nth_le (prod.snd s.table) choicen dec_trivial) (list.indexof x (prod.fst s.table)) dec_trivial --surely there is a function that does this<br>\nelse bitnode.value (list.nth_le s.bts x dec_trivial),<br>\nindices := bitnode.indices (list.nth_le s.bts x dec_trivial),<br>\nisconstant:= bitnode.isconstant (list.nth_le s.bts x dec_trivial),<br>\nconsidered := bitnode.considered (list.nth_le s.bts x dec_trivial)}) <br>\n(list.range (list.length s.bts)),</p>\n<p>gts := --same here<br>\n --placeholder<br>\n s.gts<br>\n-- if all the bits connected to a gate are in the last table then set the state to the values in the table entry</p>\n<p>,<br>\nnextbits := s.nextbits, nextgates := s.nextgates,<br>\ntable := (prod.fst s.table, list.nth_le (pair.2 s.table) choicen dec_trivial),<br>\ntablesequence := s.tablesequence<br>\n}</p>\n<p>def solvretract2 (s:satnet ) : satnet :=  -- remove the entries incompatible with the table from which we are puuling back<br>\n{bts := s.bts,<br>\ngts := s.gts,<br>\nnextbits := s.nextbits,<br>\nnextgates := s.nextgates,<br>\ntable := s.table,<br>\ntablesequence := <br>\n  (<br>\n    list.concat <br>\n    (list.remove_nth (s.tablesequence) <br>\n    ( nat.sub (list.length (s.tablesequence)) 1)),<br>\n    list.filter<br>\n    (<br>\n      λx,(<br>\n         (<br>\n          ∀ b, c, d : ℕ , <br>\n          b &lt; list.length (prod.fst s.table) <br>\n          → c &lt; list.length x<br>\n          →  list.nth x c = d<br>\n          → list.nth_le (prod.fst s.table) b dec_trivial = d <br>\n          → list.nth_le (prod.snd s.table) b dec_trivial = list.nth_le x c dec_trivial<br>\n        )<br>\n      )<br>\n    ) <br>\n    (list.nth_le s.tablesequence (nat.sub (list.length s.tablesequence) 1) dec_trivial)<br>\n  )<br>\n}</p>\n<p>def solvretract3 (s:satnet) : satnet := --pop the last table in the sequence off<br>\n{bts := s.bts,<br>\ngts := s.gts,<br>\nnextbits := s.nextbits,<br>\nnextgates := s.nextgates,<br>\ntable := list.nth_le s.tablesequence ( nat.sub (list.length s.tablesequence) 1) dec_trivial,<br>\ntablesequence := list.remove_nth s.tablesequence (nat.sub (list.length s.tablesequence) 1)}</p>\n<p>def solvwitness (s:satnet): satnet := --this solves the 'function problem'<br>\n(nat.iterate (λx,(solvretract3 (solvretract2 ( solvretract1 x))))(list.length s.gts) ) ((solvcert) s)</p>",
        "id": 257230983,
        "sender_full_name": "Jared green",
        "timestamp": 1634055895
    },
    {
        "content": "<p>Use <a href=\"https://github.com/leanprover-community/mathlib/wiki/Code-in-backticks\">#backticks</a> so that the formatting will be preserved (you can edit your messages).</p>",
        "id": 257231336,
        "sender_full_name": "Reid Barton",
        "timestamp": 1634056030
    },
    {
        "content": "<p>trying it again:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.list</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.vector.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.prod</span>\n<span class=\"kn\">open</span> <span class=\"n\">classical</span>\n\n<span class=\"kd\">variables</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">d</span><span class=\"o\">:</span> <span class=\"kt\">Type</span>\n\n\n\n<span class=\"kd\">structure</span> <span class=\"n\">bitnode</span> <span class=\"o\">:=</span>\n  <span class=\"n\">mk</span> <span class=\"o\">::</span> <span class=\"o\">(</span><span class=\"n\">value</span> <span class=\"o\">:</span> <span class=\"n\">bool</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">indices</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">ℕ</span> <span class=\"bp\">×</span> <span class=\"n\">ℕ</span><span class=\"o\">))</span> <span class=\"c1\">--these pointers indicate what it is connected to</span>\n  <span class=\"o\">(</span><span class=\"n\">isconstant</span> <span class=\"o\">:</span> <span class=\"n\">bool</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">considered</span> <span class=\"o\">:</span> <span class=\"n\">bool</span><span class=\"o\">)</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">gatenode</span> <span class=\"o\">:=</span>\n  <span class=\"n\">mk</span> <span class=\"o\">::</span> <span class=\"o\">(</span><span class=\"n\">valence</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">possib</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"o\">(</span> <span class=\"n\">vector</span> <span class=\"n\">bool</span> <span class=\"n\">valence</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">state</span> <span class=\"o\">:</span> <span class=\"n\">bool</span> <span class=\"bp\">×</span> <span class=\"o\">(</span><span class=\"n\">vector</span> <span class=\"o\">(</span><span class=\"n\">bool</span><span class=\"o\">)</span> <span class=\"n\">valence</span><span class=\"o\">))</span> <span class=\"c1\">--the fst of this indicates that the front of consideration has passed the node</span>\n  <span class=\"o\">(</span><span class=\"n\">indices</span> <span class=\"o\">:</span> <span class=\"n\">vector</span> <span class=\"n\">ℕ</span> <span class=\"n\">valence</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">reversible</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">gatenode</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a.possib.length</span> <span class=\"bp\">→</span> <span class=\"n\">c</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a.possib.length</span> <span class=\"bp\">→</span> <span class=\"n\">d</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a.valence</span>\n    <span class=\"bp\">→</span> <span class=\"o\">(</span>\n          <span class=\"c1\">--the entry is fully determined by all but one bit. represented in haskell like so:</span>\n      <span class=\"c1\">--(</span>\n                <span class=\"c1\">--remove_nth</span>\n                <span class=\"c1\">--((a.possib))!!b  d</span>\n                <span class=\"c1\">--==</span>\n                <span class=\"c1\">--remove_nth</span>\n                <span class=\"c1\">--( (a.possib))!!c  d</span>\n            <span class=\"c1\">--)</span>\n            <span class=\"c1\">--&lt;-&gt;</span>\n            <span class=\"o\">(</span>\n                <span class=\"o\">(((</span><span class=\"n\">a.possib</span><span class=\"o\">))</span><span class=\"bp\">!!</span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">!!</span><span class=\"n\">d</span>\n                <span class=\"bp\">==</span>\n                <span class=\"o\">((</span><span class=\"n\">a.possib</span><span class=\"o\">))</span><span class=\"bp\">!!</span><span class=\"n\">c</span><span class=\"o\">)</span><span class=\"bp\">!!</span><span class=\"n\">d</span>\n            <span class=\"o\">)</span>\n      <span class=\"o\">)</span>\n\n    <span class=\"o\">)</span>\n   <span class=\"o\">)</span>\n  <span class=\"o\">)</span>\n<span class=\"c1\">--the types of gates: not, and 3-unique, which is complete</span>\n<span class=\"c1\">----an AND gate can be constructed as follows:</span>\n            <span class=\"c1\">-- bits 1-8. inputs to bit 3,7. output bit 5. 3unique(1,2,3), 3unique(4,5,6), NOT(7,8), 3unique(1,4,7), 3unique(2,5,8), NOT(3,6)</span>\n            <span class=\"c1\">-- the OR gate can be constructed the same way, with the output put through a NOT, and the inputs at 6,8.</span>\n            <span class=\"c1\">--therefore 3-unique is functionally complete.</span>\n<span class=\"kd\">def</span> <span class=\"n\">mknot</span> <span class=\"o\">(</span><span class=\"n\">c</span><span class=\"o\">:</span> <span class=\"n\">vector</span> <span class=\"n\">ℕ</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">gatenode</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span><span class=\"n\">valence</span> <span class=\"o\">:=</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"n\">possib</span> <span class=\"o\">:=</span> <span class=\"o\">[</span><span class=\"n\">vector.cons</span> <span class=\"n\">ff</span> <span class=\"o\">(</span><span class=\"n\">vector.cons</span> <span class=\"n\">tt</span> <span class=\"n\">vector.nil</span><span class=\"o\">),</span><span class=\"n\">vector.cons</span> <span class=\"n\">tt</span> <span class=\"o\">(</span><span class=\"n\">vector.cons</span> <span class=\"n\">ff</span> <span class=\"n\">vector.nil</span><span class=\"o\">)],</span>\n  <span class=\"n\">state</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">ff</span><span class=\"o\">,</span><span class=\"n\">vector.cons</span> <span class=\"n\">ff</span> <span class=\"o\">(</span><span class=\"n\">vector.cons</span> <span class=\"n\">tt</span> <span class=\"n\">vector.nil</span><span class=\"o\">)),</span> <span class=\"n\">indices</span> <span class=\"o\">:=</span> <span class=\"n\">c</span><span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">mk3unique</span> <span class=\"o\">(</span><span class=\"n\">c</span><span class=\"o\">:</span> <span class=\"n\">vector</span> <span class=\"n\">ℕ</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">gatenode</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span><span class=\"n\">valence</span> <span class=\"o\">:=</span> <span class=\"mi\">3</span><span class=\"o\">,</span> <span class=\"n\">possib</span> <span class=\"o\">:=</span> <span class=\"o\">[</span><span class=\"n\">vector.cons</span> <span class=\"n\">ff</span><span class=\"o\">(</span><span class=\"n\">vector.cons</span> <span class=\"n\">ff</span> <span class=\"o\">(</span><span class=\"n\">vector.cons</span> <span class=\"n\">tt</span> <span class=\"n\">vector.nil</span><span class=\"o\">)),</span>\n<span class=\"n\">vector.cons</span> <span class=\"n\">ff</span><span class=\"o\">(</span><span class=\"n\">vector.cons</span> <span class=\"n\">tt</span><span class=\"o\">(</span><span class=\"n\">vector.cons</span> <span class=\"n\">ff</span> <span class=\"n\">vector.nil</span><span class=\"o\">)),</span>\n<span class=\"n\">vector.cons</span> <span class=\"n\">tt</span><span class=\"o\">(</span><span class=\"n\">vector.cons</span> <span class=\"n\">ff</span><span class=\"o\">(</span><span class=\"n\">vector.cons</span> <span class=\"n\">ff</span> <span class=\"n\">vector.nil</span><span class=\"o\">))],</span>\n  <span class=\"n\">state</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">ff</span><span class=\"o\">,(</span><span class=\"n\">vector.cons</span> <span class=\"n\">ff</span><span class=\"o\">(</span><span class=\"n\">vector.cons</span> <span class=\"n\">ff</span><span class=\"o\">(</span><span class=\"n\">vector.cons</span> <span class=\"n\">tt</span> <span class=\"n\">vector.nil</span><span class=\"o\">)))),</span> <span class=\"n\">indices</span> <span class=\"o\">:=</span> <span class=\"n\">c</span><span class=\"o\">}</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">satnet</span> <span class=\"o\">:=</span>  <span class=\"c1\">--i use an undirected graph representation of a sat instance,</span>\n                     <span class=\"c1\">--implemented as lists with indices as pointers</span>\n<span class=\"n\">mk</span><span class=\"o\">::</span> <span class=\"o\">(</span><span class=\"n\">bts</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">bitnode</span><span class=\"o\">)(</span><span class=\"n\">gts</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">gatenode</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">nextbits</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">ℕ</span><span class=\"o\">)(</span><span class=\"n\">nextgates</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">ℕ</span><span class=\"o\">)(</span><span class=\"n\">table</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">ℕ</span> <span class=\"bp\">×</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"n\">bool</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">tablesequence</span><span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"n\">ℕ</span> <span class=\"bp\">×</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"n\">bool</span><span class=\"o\">)))</span>\n\n<span class=\"c1\">--all indices must be within range.</span>\n<span class=\"c1\">--the corresponding function is implemented in haskell like so:</span>\n\n<span class=\"c1\">--vetnet :: satnet -&gt; bool</span>\n<span class=\"c1\">--vetnet a =</span>\n    <span class=\"c1\">--fold &amp;&amp; map (\\x-&gt;(fold &amp;&amp; map (\\y-&gt;(bts a !!(indices((gts a) !! (fst y))!! (snd y))== y))(indices x))) (bts a)</span>\n    <span class=\"c1\">--&amp;&amp;</span>\n    <span class=\"c1\">--fold &amp;&amp; map (\\x-&gt;(fold &amp;&amp; map (\\y-&gt;(fold || map (\\z-&gt;(((gts a)!! (fst z)) == x &amp;&amp; (indices((gts b)!! (fst z))!!</span>\n  <span class=\"c1\">--(snd z))== y)) (indices y)!! y )) indices x))(gts a)</span>\n\n\n<span class=\"kd\">def</span> <span class=\"n\">solv1</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">satnet</span><span class=\"o\">)</span> <span class=\"o\">:</span><span class=\"n\">satnet</span> <span class=\"o\">:=</span> <span class=\"c1\">--start by, if possible, considering the bits that are constant</span>\n<span class=\"k\">let</span> <span class=\"n\">cond</span><span class=\"o\">:</span><span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"o\">(</span>\n    <span class=\"n\">list.length</span>\n    <span class=\"o\">(</span>\n      <span class=\"n\">list.filter</span>\n      <span class=\"o\">(</span><span class=\"bp\">λ</span><span class=\"n\">x</span><span class=\"o\">,(</span>\n         <span class=\"o\">((</span><span class=\"n\">bitnode.isconstant</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">tt</span><span class=\"o\">)</span>\n      <span class=\"o\">))</span>\n      <span class=\"n\">s.bts</span>\n    <span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span>\n  <span class=\"o\">)</span> <span class=\"o\">,</span>\n  <span class=\"n\">set</span><span class=\"o\">:</span><span class=\"n\">list</span> <span class=\"n\">ℕ</span>  <span class=\"o\">:=</span> <span class=\"n\">list.map</span> <span class=\"n\">prod.fst</span>\n  <span class=\"o\">(</span><span class=\"n\">list.filter</span>\n  <span class=\"o\">(</span>\n    <span class=\"o\">(</span><span class=\"bp\">λ</span><span class=\"n\">x</span><span class=\"o\">,(</span>\n       <span class=\"o\">((</span><span class=\"n\">bitnode.isconstant</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">tt</span><span class=\"o\">)</span>\n    <span class=\"o\">))</span> <span class=\"bp\">∘</span> <span class=\"n\">prod.snd</span>\n  <span class=\"o\">)</span>\n  <span class=\"o\">(</span>\n    <span class=\"n\">list.zip</span>\n    <span class=\"o\">(</span>\n      <span class=\"n\">list.range</span>\n      <span class=\"o\">(</span>\n        <span class=\"n\">list.length</span> <span class=\"n\">s.bts</span>\n      <span class=\"o\">)</span>\n    <span class=\"o\">)</span>\n    <span class=\"n\">s.bts</span>\n  <span class=\"o\">))</span> <span class=\"k\">in</span>\n<span class=\"o\">{</span><span class=\"n\">bts</span> <span class=\"o\">:=</span> <span class=\"n\">s.bts</span><span class=\"o\">,</span>\n<span class=\"n\">gts</span> <span class=\"o\">:=</span> <span class=\"n\">s.gts</span><span class=\"o\">,</span>\n  <span class=\"n\">nextbits</span> <span class=\"o\">:=</span>\n  <span class=\"k\">if</span> <span class=\"n\">cond</span>\n  <span class=\"k\">then</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span>\n  <span class=\"k\">else</span> <span class=\"n\">set</span><span class=\"o\">,</span>\n  <span class=\"n\">nextgates</span> <span class=\"o\">:=</span> <span class=\"n\">s.nextgates</span><span class=\"o\">,</span>\n  <span class=\"n\">table</span> <span class=\"o\">:=</span> <span class=\"n\">s.table</span><span class=\"o\">,</span>\n  <span class=\"n\">tablesequence</span><span class=\"o\">:=</span> <span class=\"o\">[]</span>\n  <span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">solv2</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">:</span> <span class=\"n\">satnet</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">satnet</span> <span class=\"o\">:=</span> <span class=\"c1\">--get the first gate and table on the list</span>\n<span class=\"k\">let</span> <span class=\"n\">set</span><span class=\"o\">:</span><span class=\"n\">list</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"n\">list.erase_dup</span>  <span class=\"c1\">--actually leaves in the last copy of the set of duplicates, but is nonetheless consistent</span>\n  <span class=\"o\">(</span> <span class=\"n\">list.map</span>\n    <span class=\"o\">(</span>\n      <span class=\"n\">list.foldr</span>\n      <span class=\"o\">(</span>\n        <span class=\"n\">list.append</span>\n        <span class=\"o\">(</span>\n          <span class=\"n\">list.map</span> <span class=\"n\">prod.fst</span> <span class=\"bp\">∘</span> <span class=\"n\">bitnode.indices</span>\n          <span class=\"o\">(</span>\n            <span class=\"n\">list.filter</span> <span class=\"o\">(</span><span class=\"bp\">λ</span><span class=\"n\">x</span><span class=\"o\">,(</span> <span class=\"bp\">¬</span> <span class=\"o\">(</span><span class=\"n\">bitnode.considered</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">tt</span><span class=\"o\">))</span>\n            <span class=\"o\">(</span>\n              <span class=\"n\">list.map</span>\n              <span class=\"o\">(</span><span class=\"bp\">λ</span><span class=\"n\">x</span><span class=\"o\">,(</span>\n                <span class=\"n\">list.nth_le</span> <span class=\"n\">s.bts</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">dec_trivial</span><span class=\"o\">)</span>\n              <span class=\"o\">))</span>\n              <span class=\"n\">s.nextbits</span>\n            <span class=\"o\">)</span>\n          <span class=\"o\">)</span>\n        <span class=\"o\">)</span>\n      <span class=\"o\">)</span>\n    <span class=\"o\">)</span>\n  <span class=\"o\">)</span>\n  <span class=\"k\">in</span>\n<span class=\"o\">{</span> <span class=\"n\">bts</span> <span class=\"o\">:=</span> <span class=\"n\">s.bts</span><span class=\"o\">,</span>\n<span class=\"n\">gts</span> <span class=\"o\">:=</span> <span class=\"n\">s.gts</span><span class=\"o\">,</span>\n<span class=\"n\">nextbits</span> <span class=\"o\">:=</span> <span class=\"n\">s.nextbits</span><span class=\"o\">,</span>\n<span class=\"n\">nextgates</span><span class=\"o\">:=</span>\n  <span class=\"k\">if</span> <span class=\"n\">list.length</span> <span class=\"n\">s.nextgates</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"k\">then</span> <span class=\"k\">if</span> <span class=\"n\">list.length</span> <span class=\"n\">set</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"k\">then</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span> <span class=\"k\">else</span> <span class=\"o\">[</span><span class=\"n\">list.head</span> <span class=\"n\">set</span><span class=\"o\">]</span> <span class=\"k\">else</span> <span class=\"n\">s.nextgates</span><span class=\"o\">,</span>\n  <span class=\"n\">table</span> <span class=\"o\">:=</span> <span class=\"k\">if</span> <span class=\"n\">list.length</span> <span class=\"n\">s.nextgates</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"k\">then</span> <span class=\"k\">if</span> <span class=\"n\">list.length</span> <span class=\"n\">set</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"k\">then</span>\n   <span class=\"o\">(</span><span class=\"n\">vec.l</span> <span class=\"n\">gatenode.indices</span> <span class=\"o\">(</span><span class=\"n\">list.nth_le</span>  <span class=\"n\">s.gts</span> <span class=\"o\">(</span><span class=\"n\">list.head</span> <span class=\"n\">set</span><span class=\"o\">)</span> <span class=\"n\">dec_trivial</span> <span class=\"o\">),</span>\n  <span class=\"n\">list.map</span> <span class=\"n\">vec.l</span> <span class=\"o\">(</span><span class=\"n\">gatenode.possib</span> <span class=\"o\">(</span><span class=\"n\">list.nth_le</span> <span class=\"n\">s.gts</span> <span class=\"o\">(</span><span class=\"n\">list.head</span> <span class=\"n\">set</span><span class=\"o\">)</span> <span class=\"n\">dec_trivial</span><span class=\"o\">)</span> <span class=\"o\">))</span>\n  <span class=\"k\">else</span> <span class=\"o\">(</span><span class=\"n\">vec.l</span> <span class=\"n\">gatenode.indices</span> <span class=\"o\">(</span><span class=\"n\">list.nth_le</span> <span class=\"n\">s.gts</span> <span class=\"o\">(</span><span class=\"n\">list.head</span> <span class=\"n\">set</span><span class=\"o\">)</span> <span class=\"n\">dec_trivial</span><span class=\"o\">),</span>\n  <span class=\"n\">list.map</span> <span class=\"n\">vec.l</span> <span class=\"o\">(</span><span class=\"n\">gatenode.possib</span> <span class=\"o\">(</span><span class=\"n\">list.nth_le</span> <span class=\"n\">s.gts</span> <span class=\"o\">(</span><span class=\"n\">list.head</span> <span class=\"n\">set</span><span class=\"o\">)</span> <span class=\"n\">dec_trivial</span><span class=\"o\">)))</span> <span class=\"k\">else</span> <span class=\"n\">s.table</span><span class=\"o\">,</span>\n\n  <span class=\"n\">tablesequence</span> <span class=\"o\">:=</span> <span class=\"k\">if</span> <span class=\"n\">list.length</span> <span class=\"n\">s.nextgates</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span>\n  <span class=\"k\">then</span> <span class=\"k\">if</span> <span class=\"n\">list.length</span> <span class=\"n\">set</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span>\n  <span class=\"k\">then</span> <span class=\"o\">[(</span><span class=\"n\">vec.l</span> <span class=\"o\">(</span><span class=\"n\">gatenode.indices</span> <span class=\"o\">(</span><span class=\"n\">list.head</span> <span class=\"n\">s.gts</span><span class=\"o\">)),</span> <span class=\"n\">list.map</span> <span class=\"n\">vec.l</span> <span class=\"o\">(</span><span class=\"n\">gatenode.possib</span> <span class=\"o\">(</span><span class=\"n\">list.head</span> <span class=\"n\">s.gts</span><span class=\"o\">)))]</span>\n  <span class=\"k\">else</span> <span class=\"o\">[(</span><span class=\"n\">vec.l</span> <span class=\"o\">(</span><span class=\"n\">gatenode.indices</span> <span class=\"o\">(</span><span class=\"n\">list.nth_le</span> <span class=\"n\">s.gts</span> <span class=\"o\">(</span><span class=\"n\">list.head</span> <span class=\"n\">set</span><span class=\"o\">)</span> <span class=\"n\">dec_trivial</span><span class=\"o\">)),</span>\n  <span class=\"n\">list.map</span> <span class=\"n\">vec.l</span> <span class=\"o\">(</span><span class=\"n\">gatenode.possib</span> <span class=\"o\">(</span><span class=\"n\">list.nth_le</span> <span class=\"n\">s.gts</span> <span class=\"o\">(</span><span class=\"n\">list.head</span> <span class=\"n\">set</span><span class=\"o\">)</span> <span class=\"n\">dec_trivial</span><span class=\"o\">)))]</span>\n  <span class=\"k\">else</span> <span class=\"n\">s.tablesequence</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">solv3</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">:</span><span class=\"n\">satnet</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">satnet</span> <span class=\"o\">:=</span>  <span class=\"c1\">--remove those bits that the front of consideration has passed from nextbits</span>\n<span class=\"o\">{</span>\n  <span class=\"n\">bts</span> <span class=\"o\">:=</span> <span class=\"n\">s.bts</span><span class=\"o\">,</span> <span class=\"n\">gts</span> <span class=\"o\">:=</span> <span class=\"n\">s.gts</span><span class=\"o\">,</span> <span class=\"n\">nextbits</span> <span class=\"o\">:=</span>\n  <span class=\"n\">list.filter</span>\n  <span class=\"o\">(</span><span class=\"bp\">λ</span><span class=\"n\">y</span><span class=\"o\">,(</span>\n     <span class=\"o\">((</span>\n      <span class=\"n\">list.foldr</span>\n      <span class=\"o\">(</span><span class=\"bp\">λ</span><span class=\"n\">z</span><span class=\"o\">,</span><span class=\"bp\">λ</span><span class=\"n\">w</span><span class=\"o\">,(</span><span class=\"n\">z</span> <span class=\"bp\">&amp;&amp;</span> <span class=\"n\">w</span><span class=\"o\">))</span>\n      <span class=\"o\">(</span><span class=\"n\">list.map</span>\n        <span class=\"o\">(</span><span class=\"bp\">λ</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ℕ</span><span class=\"o\">,(</span>\n          <span class=\"n\">pair.1</span>\n          <span class=\"n\">gatenode.state</span>\n          <span class=\"o\">(</span><span class=\"n\">list.nth</span>\n          <span class=\"n\">s.gts</span>\n          <span class=\"n\">x</span>\n        <span class=\"o\">))</span>\n          <span class=\"o\">(</span>\n            <span class=\"n\">list.map</span>\n            <span class=\"n\">prod.fst</span>\n            <span class=\"o\">(</span>\n              <span class=\"n\">bitnode.indices</span>\n              <span class=\"n\">y</span>\n            <span class=\"o\">)</span>\n          <span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">tt</span>\n        <span class=\"o\">)</span>\n      <span class=\"o\">)</span>\n    <span class=\"o\">))</span>\n  <span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">list.erase_dup</span>\n  <span class=\"o\">(</span>\n    <span class=\"n\">list.foldr</span>\n    <span class=\"o\">(</span>\n      <span class=\"n\">list.append</span>\n      <span class=\"o\">(</span>\n        <span class=\"n\">list.map</span> <span class=\"o\">(</span><span class=\"bp\">λ</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">gatenode</span><span class=\"o\">,(</span><span class=\"n\">vec.l</span> <span class=\"n\">gatenode.indices</span> <span class=\"n\">x</span><span class=\"o\">))</span>\n        <span class=\"o\">(</span>\n          <span class=\"n\">list.filter</span>\n          <span class=\"o\">(</span><span class=\"bp\">λ</span><span class=\"n\">x</span><span class=\"o\">,(</span> <span class=\"bp\">¬</span> <span class=\"o\">(</span>\n            <span class=\"n\">prod.fst</span> <span class=\"o\">(</span><span class=\"n\">gatenode.state</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n          <span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">tt</span><span class=\"o\">))</span>\n          <span class=\"o\">(</span>\n            <span class=\"n\">list.map</span>\n            <span class=\"o\">(</span><span class=\"bp\">λ</span><span class=\"n\">x</span><span class=\"o\">,(</span>\n              <span class=\"n\">list.nth_le</span> <span class=\"n\">s.gts</span> <span class=\"n\">x</span> <span class=\"n\">dec_trivial</span>\n            <span class=\"o\">))</span>\n            <span class=\"n\">s.nextbits</span>\n          <span class=\"o\">)</span>\n        <span class=\"o\">)</span>\n      <span class=\"o\">)</span>\n    <span class=\"o\">)</span>\n  <span class=\"o\">))</span>\n  <span class=\"o\">,</span> <span class=\"n\">nextgates</span> <span class=\"o\">:=</span> <span class=\"n\">s.nextgates</span><span class=\"o\">,</span>\n  <span class=\"n\">table</span> <span class=\"o\">:=</span> <span class=\"n\">s.table</span><span class=\"o\">,</span>\n  <span class=\"n\">tablesequence</span> <span class=\"o\">:=</span> <span class=\"n\">s.tablesequence</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">size</span> <span class=\"o\">(</span><span class=\"n\">l</span><span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"n\">a</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span>\n <span class=\"o\">(</span><span class=\"n\">list.foldr</span> <span class=\"o\">(</span><span class=\"bp\">λ</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"bp\">λ</span><span class=\"n\">y</span><span class=\"o\">,(</span><span class=\"n\">nat.add</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">list.map</span> <span class=\"n\">list.length</span> <span class=\"n\">l</span><span class=\"o\">))</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">tables</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">:</span><span class=\"n\">satnet</span><span class=\"o\">)(</span><span class=\"n\">g</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">ℕ</span> <span class=\"bp\">×</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"n\">bool</span><span class=\"o\">)</span> <span class=\"o\">:=</span>  <span class=\"c1\">--make a table listing all the ways that nextbits could be,</span>\n                                                              <span class=\"c1\">--given the last table in s.tablesequence and the gate at index g</span>\n<span class=\"k\">let</span> <span class=\"n\">set</span><span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">ℕ</span>  <span class=\"o\">:=</span>\n<span class=\"n\">list.erase_dup</span> <span class=\"o\">(</span><span class=\"n\">list.append</span> <span class=\"n\">s.nextbits</span> <span class=\"o\">(</span><span class=\"n\">vec.l</span> <span class=\"n\">gatenode.indices</span> <span class=\"o\">(</span><span class=\"n\">list.nth_le</span> <span class=\"n\">s.gts</span> <span class=\"n\">g</span> <span class=\"n\">dec_trivial</span><span class=\"o\">))</span>\n<span class=\"k\">in</span>\n  <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"o\">,(</span>\n    <span class=\"c1\">--implement like so:</span>\n    <span class=\"c1\">--intersect set with that of nth tablesequence length - 1</span>\n    <span class=\"k\">let</span>\n    <span class=\"c1\">--the states that are compatible</span>\n    <span class=\"n\">subset</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">list</span> <span class=\"n\">bool</span> <span class=\"o\">:=</span>\n    <span class=\"n\">list.filter</span> <span class=\"o\">(</span><span class=\"bp\">λ</span><span class=\"n\">x</span><span class=\"o\">,(</span>        <span class=\"c1\">--why is d unknown?</span>\n      <span class=\"bp\">∀</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"o\">(</span><span class=\"n\">list.length</span> <span class=\"n\">s.bts</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"bp\">&lt;</span> <span class=\"n\">gatenode.valence</span> <span class=\"o\">(</span><span class=\"n\">list.nth_le</span> <span class=\"n\">s.gts</span> <span class=\"n\">g</span> <span class=\"n\">dec_trivial</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">c</span> <span class=\"bp\">&lt;</span> <span class=\"n\">list.length</span> <span class=\"n\">prod.fst</span>\n        <span class=\"o\">(</span><span class=\"n\">list.nth</span> <span class=\"n\">s.tablesequence</span> <span class=\"o\">(</span><span class=\"n\">nat.sub</span> <span class=\"o\">(</span><span class=\"n\">list.length</span> <span class=\"n\">s.tablesequence</span><span class=\"o\">)</span> <span class=\"mi\">1</span><span class=\"o\">))</span>\n         <span class=\"bp\">→</span> <span class=\"n\">list.nth_le</span> <span class=\"o\">(</span><span class=\"n\">gatenode.indices</span> <span class=\"n\">list.nth</span> <span class=\"n\">s.gts</span><span class=\"o\">)</span> <span class=\"n\">b</span> <span class=\"n\">dec_trivial</span> <span class=\"bp\">=</span>  <span class=\"n\">list.nth_le</span> <span class=\"o\">(</span><span class=\"n\">prod.fst</span>\n         <span class=\"o\">(</span><span class=\"n\">list.nth_le</span> <span class=\"n\">s.tablesequence</span> <span class=\"o\">(</span><span class=\"n\">nat.sub</span> <span class=\"o\">(</span><span class=\"n\">list.length</span> <span class=\"n\">s.tablesequence</span><span class=\"o\">)</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">dec_trivial</span><span class=\"o\">))</span> <span class=\"n\">c</span> <span class=\"n\">dec_trivial</span>\n         <span class=\"bp\">→</span> <span class=\"n\">d</span> <span class=\"bp\">&lt;</span> <span class=\"n\">list.length</span> <span class=\"o\">(</span><span class=\"n\">prod.snd</span>\n         <span class=\"o\">(</span><span class=\"n\">list.nth_le</span> <span class=\"n\">s.tablesequence</span> <span class=\"o\">(</span><span class=\"n\">nat.sub</span> <span class=\"o\">(</span><span class=\"n\">list.length</span> <span class=\"n\">s.tablesequence</span><span class=\"o\">)</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">dec_trivial</span><span class=\"o\">))</span>\n         <span class=\"bp\">→</span> <span class=\"bp\">¬</span> <span class=\"n\">list.nth_le</span> <span class=\"o\">(</span><span class=\"n\">list.nth_le</span> <span class=\"o\">(</span><span class=\"n\">prod.snd</span>\n         <span class=\"o\">(</span><span class=\"n\">list.nth</span> <span class=\"n\">s.tablesequence</span> <span class=\"o\">(</span><span class=\"n\">nat.sub</span> <span class=\"o\">(</span><span class=\"n\">list.length</span> <span class=\"n\">s.tablesequence</span><span class=\"o\">)</span> <span class=\"mi\">1</span><span class=\"o\">)))</span> <span class=\"n\">c</span> <span class=\"n\">dec_trivial</span><span class=\"o\">)</span> <span class=\"n\">d</span> <span class=\"n\">dec_trivial</span> <span class=\"bp\">=</span> <span class=\"n\">vector.nth_le</span> <span class=\"n\">x</span> <span class=\"n\">b</span> <span class=\"n\">dec_trivial</span>\n        <span class=\"o\">)</span>\n\n    <span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">gatenode.possib</span> <span class=\"o\">(</span><span class=\"n\">list.nth</span> <span class=\"n\">s.gts</span> <span class=\"n\">g</span><span class=\"o\">)),</span>\n    <span class=\"n\">expset</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">list</span> <span class=\"n\">bool</span> <span class=\"o\">:=</span> <span class=\"n\">list.foldr</span> <span class=\"bp\">λ</span><span class=\"n\">z</span><span class=\"o\">,(</span><span class=\"n\">list.concat</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">list.map</span> <span class=\"bp\">λ</span><span class=\"n\">x</span><span class=\"o\">,(</span> <span class=\"n\">list.map</span> <span class=\"bp\">λ</span><span class=\"n\">y</span><span class=\"o\">,(</span><span class=\"n\">list.append</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">))</span>\n    <span class=\"o\">(</span><span class=\"n\">prod.snd</span> <span class=\"o\">(</span><span class=\"n\">list.nth</span> <span class=\"n\">s.tablesequence</span> <span class=\"o\">(</span><span class=\"n\">nat.sub</span> <span class=\"o\">(</span><span class=\"n\">list.length</span> <span class=\"n\">s.tablesequence</span><span class=\"o\">)</span> <span class=\"mi\">1</span><span class=\"o\">)))</span> <span class=\"o\">(</span><span class=\"n\">subset</span><span class=\"o\">))</span>\n    <span class=\"k\">in</span> <span class=\"n\">list.erase_dup</span> <span class=\"o\">(</span>\n      <span class=\"n\">list.transpose</span>\n      <span class=\"o\">(</span>\n        <span class=\"n\">list.map</span> <span class=\"n\">prod.snd</span>\n        <span class=\"o\">(</span>\n          <span class=\"n\">list.erase_dup</span>\n          <span class=\"o\">(</span> <span class=\"n\">list.filter</span> <span class=\"o\">(</span><span class=\"bp\">λ</span><span class=\"n\">x</span><span class=\"o\">,(</span> <span class=\"o\">(</span><span class=\"n\">list.fst</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"o\">))))</span>\n            <span class=\"n\">list.zip</span>\n            <span class=\"o\">(</span> <span class=\"n\">list.append</span>\n              <span class=\"n\">prod.fst</span>\n              <span class=\"o\">(</span>\n                <span class=\"n\">list.nth</span> <span class=\"n\">s.tablesequence</span>\n                <span class=\"o\">(</span>\n                  <span class=\"n\">nat.sub</span>\n                  <span class=\"o\">(</span>\n                    <span class=\"n\">list.length</span> <span class=\"n\">s.tablesequence</span>\n                  <span class=\"o\">)</span>\n                  <span class=\"mi\">1</span>\n                <span class=\"o\">)</span>\n              <span class=\"o\">)</span>\n              <span class=\"o\">(</span><span class=\"n\">gatenode.indices</span> <span class=\"o\">(</span><span class=\"n\">list.nth</span> <span class=\"n\">s.gts</span> <span class=\"n\">g</span><span class=\"o\">))</span>\n            <span class=\"o\">)</span>\n            <span class=\"n\">list.transpose</span>\n            <span class=\"o\">(</span>\n              <span class=\"n\">list.erase_dup</span> <span class=\"n\">expset</span>\n            <span class=\"o\">)</span>\n          <span class=\"o\">)</span>\n        <span class=\"o\">)</span>\n      <span class=\"o\">)</span>\n    <span class=\"o\">)</span>\n  <span class=\"o\">))</span>\n</code></pre></div>",
        "id": 257232857,
        "sender_full_name": "Jared green",
        "timestamp": 1634056571
    },
    {
        "content": "<p>respond to this comment please.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">solv4</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">:</span><span class=\"n\">satnet</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">satnet</span> <span class=\"o\">:=</span> <span class=\"c1\">--construct the smallest table for any choice in how the front of consideration is to advance</span>\n<span class=\"o\">{</span><span class=\"n\">bts</span> <span class=\"o\">:=</span> <span class=\"n\">s.bts</span><span class=\"o\">,</span>\n <span class=\"n\">gts</span> <span class=\"o\">:=</span> <span class=\"n\">s.gts</span><span class=\"o\">,</span>\n <span class=\"n\">nextbits</span> <span class=\"o\">:=</span> <span class=\"n\">s.nextbits</span><span class=\"o\">,</span>\n  <span class=\"n\">nextgates</span> <span class=\"o\">:=</span> <span class=\"n\">list.concat</span>\n  <span class=\"n\">s.nextgates</span>\n  <span class=\"o\">(</span>\n    <span class=\"n\">list.argmin</span>\n    <span class=\"o\">(</span>\n     <span class=\"n\">size</span> <span class=\"o\">(</span><span class=\"n\">prod.snd</span>\n      <span class=\"o\">(</span><span class=\"bp\">λ</span><span class=\"n\">x</span><span class=\"o\">,(</span><span class=\"n\">tables</span> <span class=\"n\">s</span> <span class=\"n\">x</span><span class=\"o\">)))</span>\n    <span class=\"o\">)</span>\n    <span class=\"o\">(</span>\n      <span class=\"n\">list.filter</span>\n      <span class=\"o\">(</span><span class=\"bp\">λ</span><span class=\"n\">x</span><span class=\"o\">,(</span><span class=\"bp\">¬</span> <span class=\"o\">((</span><span class=\"n\">prod.fst</span> <span class=\"o\">(</span><span class=\"n\">gatenode.state</span> <span class=\"o\">(</span><span class=\"n\">list.nth_le</span> <span class=\"n\">s.gts</span> <span class=\"n\">x</span> <span class=\"n\">dec_trivial</span><span class=\"o\">))</span><span class=\"bp\">=</span> <span class=\"n\">tt</span><span class=\"o\">)</span> <span class=\"bp\">∨</span>  <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s.nextgates</span><span class=\"o\">)))</span>\n      <span class=\"o\">(</span><span class=\"n\">list.range</span> <span class=\"o\">(</span><span class=\"n\">list.length</span> <span class=\"n\">s.gts</span><span class=\"o\">))</span>\n    <span class=\"o\">)</span>\n  <span class=\"o\">),</span>\n   <span class=\"n\">table</span> <span class=\"o\">:=</span> <span class=\"n\">list.argmin</span> <span class=\"bp\">λ</span><span class=\"n\">x</span><span class=\"o\">,(</span><span class=\"n\">size</span> <span class=\"o\">(</span><span class=\"n\">prod.snd</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">list.map</span> <span class=\"o\">(</span><span class=\"bp\">λ</span><span class=\"n\">x</span><span class=\"o\">,(</span><span class=\"n\">tables</span> <span class=\"n\">s</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">list.range</span> <span class=\"o\">(</span><span class=\"n\">list.length</span> <span class=\"n\">s.gts</span><span class=\"o\">))),</span>\n  <span class=\"c1\">--the one thing i'm not sure on,</span>\n  <span class=\"c1\">--the maximum number of entries in this table, if im correct,</span>\n  <span class=\"c1\">-- grows no faster than the number of gates</span>\n  <span class=\"c1\">--sketch:</span>\n  <span class=\"c1\">--initially, the front of consideration is fully determined until it reaches the edge of a bubble</span>\n  <span class=\"c1\">-- a bubble is here defined as a subset of the satnet s where determination on the outside has no bearing on the inside, though not necessarily vice versa</span>\n  <span class=\"c1\">--the edge of a bubble is formed by one ore more cycles of gates connected to bits on the inside, and each one has a single line outwards</span>\n  <span class=\"c1\">--for each cycle, there are at most two distinct states the whole cycle can be in</span>\n  <span class=\"c1\">-- the most efficient traversal through that is to consider the consequences of one cycle at a time,</span>\n  <span class=\"c1\">--as that keeps the number of entries below some constant</span>\n  <span class=\"c1\">--it will take an automated proof search to prove that this is always possible</span>\n\n  <span class=\"c1\">--though i do know that it is definitely subexponential,</span>\n  <span class=\"c1\">-- at most 2^(sqrt(n))</span>\n  <span class=\"c1\">--sketch:</span>\n  <span class=\"c1\">--the width of the front of consideration grows linearly and then shrinks linearly</span>\n  <span class=\"c1\">-- from one gate to its maximum than back down to just one again</span>\n  <span class=\"c1\">--for the maximum to be the absolute worst case, the system must approximate a square with the disjoint subsets that the front passes through in layers</span>\n  <span class=\"c1\">--the maximum width then is sqrt(2n)</span>\n  <span class=\"c1\">--the maximum number of states that can take on is O(2^(sqrt(2n)))</span>\n  <span class=\"c1\">--qed, therefore the exponential time hypothesis is false</span>\n  <span class=\"n\">tablesequence</span> <span class=\"o\">:=</span> <span class=\"n\">s.tablesequence</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">solv5</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">:</span><span class=\"n\">satnet</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">satnet</span> <span class=\"o\">:=</span>   <span class=\"c1\">--place the new table in the squence</span>\n<span class=\"o\">{</span><span class=\"n\">bts</span> <span class=\"o\">:=</span> <span class=\"n\">s.bts</span><span class=\"o\">,</span>\n<span class=\"n\">gts</span> <span class=\"o\">:=</span> <span class=\"n\">s.gts</span><span class=\"o\">,</span>\n<span class=\"n\">nextbits</span> <span class=\"o\">:=</span> <span class=\"n\">s.nextbits</span><span class=\"o\">,</span>\n<span class=\"n\">nextgates</span> <span class=\"o\">:=</span> <span class=\"n\">s.nextgates</span><span class=\"o\">,</span>\n<span class=\"n\">table</span> <span class=\"o\">:=</span> <span class=\"n\">s.table</span><span class=\"o\">,</span>\n<span class=\"n\">tablesequence</span> <span class=\"o\">:=</span> <span class=\"n\">list.concat</span> <span class=\"n\">s.tablesequence</span> <span class=\"n\">s.table</span>\n<span class=\"o\">}</span>\n\n<span class=\"c1\">--say that the bitnodes and gatenodes that the front of consideration has passed are considered</span>\n<span class=\"kd\">def</span> <span class=\"n\">reconsider</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">:</span><span class=\"n\">satnet</span><span class=\"o\">)(</span><span class=\"n\">b</span><span class=\"o\">:</span><span class=\"n\">ℕ</span> <span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">bitnode</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span>\n    <span class=\"n\">value</span> <span class=\"o\">:=</span> <span class=\"n\">bitnode.value</span> <span class=\"o\">(</span><span class=\"n\">list.nth_le</span> <span class=\"n\">s.bts</span> <span class=\"n\">b</span> <span class=\"n\">dec_trivial</span><span class=\"o\">),</span>\n    <span class=\"n\">indices</span> <span class=\"o\">:=</span> <span class=\"n\">bitnode.indices</span> <span class=\"o\">(</span><span class=\"n\">list.nth_le</span> <span class=\"n\">s.bts</span> <span class=\"n\">b</span> <span class=\"n\">dec_trivial</span><span class=\"o\">),</span>\n    <span class=\"n\">isconstant</span> <span class=\"o\">:=</span> <span class=\"n\">bitnode.isconstant</span> <span class=\"o\">(</span><span class=\"n\">list.nth_le</span> <span class=\"n\">s.bts</span> <span class=\"n\">b</span> <span class=\"n\">dec_trivial</span><span class=\"o\">),</span>\n    <span class=\"n\">considered</span> <span class=\"o\">:=</span>\n    <span class=\"k\">if</span>\n    <span class=\"n\">list.foldr</span>\n    <span class=\"o\">(</span><span class=\"bp\">λ</span><span class=\"n\">z</span><span class=\"o\">,</span><span class=\"bp\">λ</span><span class=\"n\">w</span><span class=\"o\">,(</span><span class=\"n\">z</span> <span class=\"bp\">&amp;&amp;</span> <span class=\"n\">w</span><span class=\"o\">))</span>\n    <span class=\"o\">(</span><span class=\"n\">list.map</span>\n    <span class=\"o\">(</span><span class=\"bp\">λ</span><span class=\"n\">x</span><span class=\"o\">,(</span>\n     <span class=\"n\">prod.fst</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s.nextgates</span>\n    <span class=\"o\">))</span>\n    <span class=\"o\">(</span>\n      <span class=\"n\">bitnode.indices</span>\n      <span class=\"o\">(</span><span class=\"n\">list.nth_le</span> <span class=\"n\">s.bts</span> <span class=\"n\">b</span> <span class=\"n\">dec_trivial</span><span class=\"o\">)</span>\n    <span class=\"o\">)</span> <span class=\"o\">)</span>\n    <span class=\"k\">then</span>\n    <span class=\"n\">tt</span>\n    <span class=\"k\">else</span>\n    <span class=\"n\">bitnode.considered</span>\n    <span class=\"o\">(</span><span class=\"n\">list.nth_le</span> <span class=\"n\">s.bts</span> <span class=\"n\">b</span> <span class=\"n\">dec_trivial</span><span class=\"o\">)</span>\n  <span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">solv6</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">:</span><span class=\"n\">satnet</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">satnet</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span><span class=\"n\">bts</span> <span class=\"o\">:=</span> <span class=\"n\">list.map</span> <span class=\"o\">(</span><span class=\"bp\">λ</span><span class=\"n\">x</span><span class=\"o\">,(</span><span class=\"n\">reconsider</span> <span class=\"n\">s</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">list.range</span> <span class=\"o\">(</span><span class=\"n\">list.length</span> <span class=\"n\">s.bts</span><span class=\"o\">)),</span>\n<span class=\"n\">gts</span> <span class=\"o\">:=</span> <span class=\"n\">s.gts</span><span class=\"o\">,</span>\n<span class=\"n\">nextbits</span> <span class=\"o\">:=</span> <span class=\"n\">s.nextbits</span><span class=\"o\">,</span>\n<span class=\"n\">nextgates</span> <span class=\"o\">:=</span> <span class=\"n\">s.nextgates</span><span class=\"o\">,</span>\n<span class=\"n\">table</span> <span class=\"o\">:=</span> <span class=\"n\">s.table</span><span class=\"o\">,</span>\n<span class=\"n\">tablesequence</span> <span class=\"o\">:=</span> <span class=\"n\">s.tablesequence</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">greconsider</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">:</span><span class=\"n\">satnet</span><span class=\"o\">)(</span><span class=\"n\">g</span><span class=\"o\">:</span><span class=\"n\">ℕ</span> <span class=\"o\">)(</span><span class=\"n\">c</span><span class=\"o\">:</span><span class=\"n\">bool</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">gatenode</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span><span class=\"n\">valence</span> <span class=\"o\">:=</span> <span class=\"n\">gatenode.valence</span> <span class=\"o\">(</span><span class=\"n\">list.nth_le</span> <span class=\"n\">s.gts</span> <span class=\"n\">g</span> <span class=\"n\">dec_trivial</span><span class=\"o\">),</span>\n<span class=\"n\">possib</span> <span class=\"o\">:=</span> <span class=\"n\">gatenode.possib</span> <span class=\"o\">(</span><span class=\"n\">list.nth_le</span> <span class=\"n\">s.gts</span> <span class=\"n\">g</span> <span class=\"n\">dec_trivial</span><span class=\"o\">),</span>\n<span class=\"n\">indices</span> <span class=\"o\">:=</span> <span class=\"n\">gatenode.indices</span> <span class=\"o\">(</span><span class=\"n\">list.nth_le</span> <span class=\"n\">s.gts</span> <span class=\"n\">g</span> <span class=\"n\">dec_trivial</span><span class=\"o\">),</span>\n<span class=\"n\">state</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span>\n  <span class=\"o\">(</span>\n    <span class=\"k\">if</span>\n    <span class=\"n\">c</span>\n    <span class=\"k\">then</span>\n    <span class=\"n\">tt</span>\n    <span class=\"k\">else</span>\n    <span class=\"o\">(</span>\n      <span class=\"n\">prod.fst</span>\n      <span class=\"o\">(</span><span class=\"n\">gatenode.state</span> <span class=\"o\">(</span><span class=\"n\">list.nth_le</span> <span class=\"n\">s.gts</span> <span class=\"n\">g</span> <span class=\"n\">dec_trivial</span><span class=\"o\">))</span>\n    <span class=\"o\">)</span>\n  <span class=\"o\">),</span>\n  <span class=\"o\">(</span>\n    <span class=\"n\">prod.snd</span>\n    <span class=\"o\">(</span><span class=\"n\">gatenode.state</span> <span class=\"o\">(</span><span class=\"n\">list.nth_le</span> <span class=\"n\">s.gts</span> <span class=\"n\">g</span> <span class=\"n\">dec_trivial</span><span class=\"o\">))</span>\n  <span class=\"o\">)</span>\n<span class=\"o\">)</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">solv7</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">:</span><span class=\"n\">satnet</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">satnet</span> <span class=\"o\">:=</span>\n<span class=\"k\">let</span> <span class=\"n\">set</span><span class=\"o\">:</span><span class=\"n\">list</span> <span class=\"n\">ℕ</span>  <span class=\"o\">:=</span> <span class=\"n\">list.filter</span>\n<span class=\"o\">(</span><span class=\"bp\">λ</span><span class=\"n\">y</span><span class=\"o\">,(</span>\n  <span class=\"o\">((</span>\n    <span class=\"n\">list.foldr</span>\n    <span class=\"o\">(</span><span class=\"bp\">λ</span><span class=\"n\">z</span><span class=\"o\">,</span><span class=\"bp\">λ</span><span class=\"n\">w</span><span class=\"o\">,(</span><span class=\"n\">z</span> <span class=\"bp\">&amp;&amp;</span> <span class=\"n\">w</span><span class=\"o\">))</span>\n    <span class=\"o\">(</span><span class=\"n\">list.map</span>\n      <span class=\"o\">(</span><span class=\"bp\">λ</span><span class=\"n\">x</span><span class=\"o\">,(</span>\n        <span class=\"n\">bitnode.considered</span> <span class=\"n\">x</span>\n      <span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">tt</span><span class=\"o\">)</span>\n      <span class=\"o\">(</span><span class=\"n\">vec.l</span> <span class=\"o\">(</span><span class=\"n\">gatenode.indices</span> <span class=\"o\">(</span><span class=\"n\">list.nth_le</span> <span class=\"n\">s.gts</span> <span class=\"n\">y</span> <span class=\"n\">dec_trivial</span><span class=\"o\">)))</span>\n    <span class=\"o\">)</span>\n  <span class=\"o\">)</span> <span class=\"o\">)</span>\n<span class=\"o\">))</span>\n<span class=\"o\">(</span>\n  <span class=\"n\">list.range</span>\n  <span class=\"o\">(</span><span class=\"n\">list.length</span> <span class=\"n\">s.gts</span><span class=\"o\">)</span>\n<span class=\"o\">)</span>\n<span class=\"k\">in</span>\n<span class=\"o\">{</span><span class=\"n\">bts</span> <span class=\"o\">:=</span> <span class=\"n\">s.bts</span><span class=\"o\">,</span>\n<span class=\"n\">gts</span> <span class=\"o\">:=</span> <span class=\"n\">list.map</span> <span class=\"o\">(</span><span class=\"bp\">λ</span><span class=\"n\">x</span><span class=\"o\">,(</span><span class=\"n\">greconsider</span> <span class=\"n\">s</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">set</span><span class=\"o\">)))</span> <span class=\"o\">(</span><span class=\"n\">list.range</span> <span class=\"o\">(</span><span class=\"n\">list.length</span> <span class=\"n\">s.gts</span><span class=\"o\">))</span>\n<span class=\"o\">,</span><span class=\"n\">nextbits</span> <span class=\"o\">:=</span> <span class=\"n\">s.nextbits</span><span class=\"o\">,</span>\n<span class=\"n\">nextgates</span> <span class=\"o\">:=</span> <span class=\"n\">list.filter</span> <span class=\"o\">(</span><span class=\"bp\">λ</span><span class=\"n\">x</span><span class=\"o\">,(</span><span class=\"bp\">¬</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">set</span><span class=\"o\">)))</span> <span class=\"n\">s.nextgates</span><span class=\"o\">,</span>\n<span class=\"n\">table</span> <span class=\"o\">:=</span> <span class=\"n\">s.table</span><span class=\"o\">,</span>\n<span class=\"n\">tablesequence</span> <span class=\"o\">:=</span> <span class=\"n\">s.tablesequence</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">solvcycle</span> <span class=\"o\">:</span> <span class=\"n\">satnet</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">satnet</span> <span class=\"o\">:=</span> <span class=\"c1\">--the cycle starts in solv3.</span>\n <span class=\"n\">solv7</span> <span class=\"bp\">∘</span> <span class=\"n\">solv6</span> <span class=\"bp\">∘</span> <span class=\"n\">solv5</span> <span class=\"bp\">∘</span> <span class=\"n\">solv4</span> <span class=\"bp\">∘</span> <span class=\"n\">solv3</span>\n\n\n<span class=\"kd\">def</span> <span class=\"n\">solvcert</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">:</span><span class=\"n\">satnet</span> <span class=\"o\">):</span> <span class=\"n\">satnet</span> <span class=\"o\">:=</span> <span class=\"c1\">--this is the information required to 'certify' satisfiability without a witness</span>\n<span class=\"o\">(</span><span class=\"n\">nat.iterate</span>  <span class=\"n\">solvcycle</span> <span class=\"o\">(</span><span class=\"n\">nat.sub</span> <span class=\"o\">(</span><span class=\"n\">list.length</span> <span class=\"n\">s.gts</span><span class=\"o\">)</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">((</span><span class=\"n\">solv2</span> <span class=\"bp\">∘</span> <span class=\"n\">solv1</span><span class=\"o\">)</span> <span class=\"n\">s</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">solvdecide</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">:</span><span class=\"n\">satnet</span><span class=\"o\">):</span> <span class=\"n\">bool</span> <span class=\"o\">:=</span> <span class=\"n\">list.length</span> <span class=\"o\">(</span><span class=\"n\">prod.snd</span> <span class=\"o\">(</span><span class=\"n\">satnet.table</span> <span class=\"o\">(</span><span class=\"n\">solvcert</span> <span class=\"n\">s</span><span class=\"o\">)))</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span>  <span class=\"c1\">--this 'solves the decision problem'</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">solvretract1</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">:</span><span class=\"n\">satnet</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">satnet</span> <span class=\"o\">:=</span>    <span class=\"c1\">--pick an entry, possibly random, in the last table and commit to it</span>\n<span class=\"c1\">-- choose a nat in 0..length (snd (last table), maybe randomly</span>\n<span class=\"k\">let</span> <span class=\"n\">choicen</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span>\n<span class=\"n\">random</span>  <span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">list.length</span> <span class=\"n\">prod.snd</span> <span class=\"n\">s.table</span><span class=\"o\">)</span>\n<span class=\"k\">in</span>\n<span class=\"o\">{</span><span class=\"n\">bts</span> <span class=\"o\">:=</span>\n<span class=\"c1\">--set the value of each bitnode to that in the entry corresponding to the number previously chosen</span>\n<span class=\"n\">list.map</span>\n<span class=\"o\">(</span><span class=\"bp\">λ</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ℕ</span><span class=\"o\">,</span>\n<span class=\"o\">{</span><span class=\"n\">value</span> <span class=\"o\">:=</span> <span class=\"k\">if</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">prod.fst</span> <span class=\"n\">s.table</span>\n<span class=\"k\">then</span> <span class=\"n\">list.nth_le</span> <span class=\"o\">(</span><span class=\"n\">list.nth_le</span> <span class=\"o\">(</span><span class=\"n\">prod.snd</span> <span class=\"n\">s.table</span><span class=\"o\">)</span> <span class=\"n\">choicen</span> <span class=\"n\">dec_trivial</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">list.indexof</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">prod.fst</span> <span class=\"n\">s.table</span><span class=\"o\">))</span> <span class=\"n\">dec_trivial</span> <span class=\"c1\">--surely there is a function that does this</span>\n<span class=\"k\">else</span> <span class=\"n\">bitnode.value</span> <span class=\"o\">(</span><span class=\"n\">list.nth_le</span> <span class=\"n\">s.bts</span> <span class=\"n\">x</span> <span class=\"n\">dec_trivial</span><span class=\"o\">),</span>\n<span class=\"n\">indices</span> <span class=\"o\">:=</span> <span class=\"n\">bitnode.indices</span> <span class=\"o\">(</span><span class=\"n\">list.nth_le</span> <span class=\"n\">s.bts</span> <span class=\"n\">x</span> <span class=\"n\">dec_trivial</span><span class=\"o\">),</span>\n<span class=\"n\">isconstant</span><span class=\"o\">:=</span> <span class=\"n\">bitnode.isconstant</span> <span class=\"o\">(</span><span class=\"n\">list.nth_le</span> <span class=\"n\">s.bts</span> <span class=\"n\">x</span> <span class=\"n\">dec_trivial</span><span class=\"o\">),</span>\n<span class=\"n\">considered</span> <span class=\"o\">:=</span> <span class=\"n\">bitnode.considered</span> <span class=\"o\">(</span><span class=\"n\">list.nth_le</span> <span class=\"n\">s.bts</span> <span class=\"n\">x</span> <span class=\"n\">dec_trivial</span><span class=\"o\">)})</span>\n<span class=\"o\">(</span><span class=\"n\">list.range</span> <span class=\"o\">(</span><span class=\"n\">list.length</span> <span class=\"n\">s.bts</span><span class=\"o\">)),</span>\n\n <span class=\"n\">gts</span> <span class=\"o\">:=</span> <span class=\"c1\">--same here</span>\n <span class=\"c1\">--placeholder</span>\n <span class=\"n\">s.gts</span>\n<span class=\"c1\">-- if all the bits connected to a gate are in the last table then set the state to the values in the table entry</span>\n\n<span class=\"o\">,</span>\n<span class=\"n\">nextbits</span> <span class=\"o\">:=</span> <span class=\"n\">s.nextbits</span><span class=\"o\">,</span> <span class=\"n\">nextgates</span> <span class=\"o\">:=</span> <span class=\"n\">s.nextgates</span><span class=\"o\">,</span>\n<span class=\"n\">table</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">prod.fst</span> <span class=\"n\">s.table</span><span class=\"o\">,</span> <span class=\"n\">list.nth_le</span> <span class=\"o\">(</span><span class=\"n\">pair.2</span> <span class=\"n\">s.table</span><span class=\"o\">)</span> <span class=\"n\">choicen</span> <span class=\"n\">dec_trivial</span><span class=\"o\">),</span>\n<span class=\"n\">tablesequence</span> <span class=\"o\">:=</span> <span class=\"n\">s.tablesequence</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">solvretract2</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">:</span><span class=\"n\">satnet</span> <span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">satnet</span> <span class=\"o\">:=</span>  <span class=\"c1\">-- remove the entries incompatible with the table from which we are puuling back</span>\n<span class=\"o\">{</span><span class=\"n\">bts</span> <span class=\"o\">:=</span> <span class=\"n\">s.bts</span><span class=\"o\">,</span>\n<span class=\"n\">gts</span> <span class=\"o\">:=</span> <span class=\"n\">s.gts</span><span class=\"o\">,</span>\n<span class=\"n\">nextbits</span> <span class=\"o\">:=</span> <span class=\"n\">s.nextbits</span><span class=\"o\">,</span>\n<span class=\"n\">nextgates</span> <span class=\"o\">:=</span> <span class=\"n\">s.nextgates</span><span class=\"o\">,</span>\n<span class=\"n\">table</span> <span class=\"o\">:=</span> <span class=\"n\">s.table</span><span class=\"o\">,</span>\n<span class=\"n\">tablesequence</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span>\n    <span class=\"n\">list.concat</span>\n    <span class=\"o\">(</span><span class=\"n\">list.remove_nth</span> <span class=\"o\">(</span><span class=\"n\">s.tablesequence</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span> <span class=\"n\">nat.sub</span> <span class=\"o\">(</span><span class=\"n\">list.length</span> <span class=\"o\">(</span><span class=\"n\">s.tablesequence</span><span class=\"o\">))</span> <span class=\"mi\">1</span><span class=\"o\">)),</span>\n    <span class=\"n\">list.filter</span>\n    <span class=\"o\">(</span>\n      <span class=\"bp\">λ</span><span class=\"n\">x</span><span class=\"o\">,(</span>\n         <span class=\"o\">(</span>\n          <span class=\"bp\">∀</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">,</span>\n          <span class=\"n\">b</span> <span class=\"bp\">&lt;</span> <span class=\"n\">list.length</span> <span class=\"o\">(</span><span class=\"n\">prod.fst</span> <span class=\"n\">s.table</span><span class=\"o\">)</span>\n          <span class=\"bp\">→</span> <span class=\"n\">c</span> <span class=\"bp\">&lt;</span> <span class=\"n\">list.length</span> <span class=\"n\">x</span>\n          <span class=\"bp\">→</span>  <span class=\"n\">list.nth</span> <span class=\"n\">x</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"n\">d</span>\n          <span class=\"bp\">→</span> <span class=\"n\">list.nth_le</span> <span class=\"o\">(</span><span class=\"n\">prod.fst</span> <span class=\"n\">s.table</span><span class=\"o\">)</span> <span class=\"n\">b</span> <span class=\"n\">dec_trivial</span> <span class=\"bp\">=</span> <span class=\"n\">d</span>\n          <span class=\"bp\">→</span> <span class=\"n\">list.nth_le</span> <span class=\"o\">(</span><span class=\"n\">prod.snd</span> <span class=\"n\">s.table</span><span class=\"o\">)</span> <span class=\"n\">b</span> <span class=\"n\">dec_trivial</span> <span class=\"bp\">=</span> <span class=\"n\">list.nth_le</span> <span class=\"n\">x</span> <span class=\"n\">c</span> <span class=\"n\">dec_trivial</span>\n        <span class=\"o\">)</span>\n      <span class=\"o\">)</span>\n    <span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">list.nth_le</span> <span class=\"n\">s.tablesequence</span> <span class=\"o\">(</span><span class=\"n\">nat.sub</span> <span class=\"o\">(</span><span class=\"n\">list.length</span> <span class=\"n\">s.tablesequence</span><span class=\"o\">)</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">dec_trivial</span><span class=\"o\">)</span>\n  <span class=\"o\">)</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">solvretract3</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">:</span><span class=\"n\">satnet</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">satnet</span> <span class=\"o\">:=</span> <span class=\"c1\">--pop the last table in the sequence off</span>\n<span class=\"o\">{</span><span class=\"n\">bts</span> <span class=\"o\">:=</span> <span class=\"n\">s.bts</span><span class=\"o\">,</span>\n<span class=\"n\">gts</span> <span class=\"o\">:=</span> <span class=\"n\">s.gts</span><span class=\"o\">,</span>\n<span class=\"n\">nextbits</span> <span class=\"o\">:=</span> <span class=\"n\">s.nextbits</span><span class=\"o\">,</span>\n<span class=\"n\">nextgates</span> <span class=\"o\">:=</span> <span class=\"n\">s.nextgates</span><span class=\"o\">,</span>\n<span class=\"n\">table</span> <span class=\"o\">:=</span> <span class=\"n\">list.nth_le</span> <span class=\"n\">s.tablesequence</span> <span class=\"o\">(</span> <span class=\"n\">nat.sub</span> <span class=\"o\">(</span><span class=\"n\">list.length</span> <span class=\"n\">s.tablesequence</span><span class=\"o\">)</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">dec_trivial</span><span class=\"o\">,</span>\n<span class=\"n\">tablesequence</span> <span class=\"o\">:=</span> <span class=\"n\">list.remove_nth</span> <span class=\"n\">s.tablesequence</span> <span class=\"o\">(</span><span class=\"n\">nat.sub</span> <span class=\"o\">(</span><span class=\"n\">list.length</span> <span class=\"n\">s.tablesequence</span><span class=\"o\">)</span> <span class=\"mi\">1</span><span class=\"o\">)}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">solvwitness</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">:</span><span class=\"n\">satnet</span><span class=\"o\">):</span> <span class=\"n\">satnet</span> <span class=\"o\">:=</span> <span class=\"c1\">--this solves the 'function problem'</span>\n<span class=\"o\">(</span><span class=\"n\">nat.iterate</span> <span class=\"o\">(</span><span class=\"bp\">λ</span><span class=\"n\">x</span><span class=\"o\">,(</span><span class=\"n\">solvretract3</span> <span class=\"o\">(</span><span class=\"n\">solvretract2</span> <span class=\"o\">(</span> <span class=\"n\">solvretract1</span> <span class=\"n\">x</span><span class=\"o\">))))(</span><span class=\"n\">list.length</span> <span class=\"n\">s.gts</span><span class=\"o\">)</span> <span class=\"o\">)</span> <span class=\"o\">((</span><span class=\"n\">solvcert</span><span class=\"o\">)</span> <span class=\"n\">s</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 257233060,
        "sender_full_name": "Jared green",
        "timestamp": 1634056664
    },
    {
        "content": "<p>This is not a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>. The interpretation of \"working\" here is \"it demonstrates the issue you are having trouble with\", i.e. it fails in the expected way. But \"minimal\" is also important. Remove all definitions that are not relevant to the error, by stubbing things out (put <code>sorry</code> anywhere you can). And if you comment your code, make sure the comments are relevant to the error, especially if there are multiple lean errors in the document</p>",
        "id": 257238402,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1634058775
    },
    {
        "content": "<p>I said <code>vec.1</code> not <code>vec.l</code> by the way</p>",
        "id": 257240853,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1634059718
    },
    {
        "content": "<p>and <code>vec</code> is supposed to be the variable of type <code>vector</code> that you have</p>",
        "id": 257240930,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1634059745
    },
    {
        "content": "<p>the underlying function is <code>subtype.val</code></p>",
        "id": 257240971,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1634059762
    },
    {
        "content": "<p>I should also note that in lean we generally avoid point-free programming; things like dot-notation don't work in point-free style and the composition operator can interfere with proofs</p>",
        "id": 257241144,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1634059820
    },
    {
        "content": "<p>Here's a leanified version of your file through <code>solv1</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.list</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.vector.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.prod</span>\n<span class=\"kn\">open</span> <span class=\"n\">classical</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">bitnode</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">value</span> <span class=\"o\">:</span> <span class=\"n\">bool</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">indices</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">ℕ</span> <span class=\"bp\">×</span> <span class=\"n\">ℕ</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">isconstant</span> <span class=\"o\">:</span> <span class=\"n\">bool</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">considered</span> <span class=\"o\">:</span> <span class=\"n\">bool</span><span class=\"o\">)</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">gatenode</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">valence</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">possib</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">vector</span> <span class=\"n\">bool</span> <span class=\"n\">valence</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">state</span> <span class=\"o\">:</span> <span class=\"n\">bool</span> <span class=\"bp\">×</span> <span class=\"n\">vector</span> <span class=\"n\">bool</span> <span class=\"n\">valence</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">indices</span> <span class=\"o\">:</span> <span class=\"n\">vector</span> <span class=\"n\">ℕ</span> <span class=\"n\">valence</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">reversible</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">gatenode</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"bp\">∀</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"bp\">∈</span> <span class=\"n\">a.possib</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a.valence</span><span class=\"o\">,</span>\n  <span class=\"o\">(</span><span class=\"n\">v</span><span class=\"o\">:</span><span class=\"n\">vector</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"bp\">.</span><span class=\"n\">remove_nth</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">w</span><span class=\"o\">:</span><span class=\"n\">vector</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"bp\">.</span><span class=\"n\">remove_nth</span> <span class=\"n\">i</span> <span class=\"bp\">→</span> <span class=\"n\">v</span> <span class=\"bp\">=</span> <span class=\"n\">w</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">mknot</span> <span class=\"o\">(</span><span class=\"n\">c</span><span class=\"o\">:</span> <span class=\"n\">vector</span> <span class=\"n\">ℕ</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">gatenode</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">valence</span> <span class=\"o\">:=</span> <span class=\"mi\">2</span><span class=\"o\">,</span>\n  <span class=\"n\">possib</span> <span class=\"o\">:=</span> <span class=\"o\">[</span><span class=\"n\">ff</span> <span class=\"o\">::</span><span class=\"bp\">ᵥ</span> <span class=\"n\">ff</span> <span class=\"o\">::</span><span class=\"bp\">ᵥ</span> <span class=\"n\">vector.nil</span><span class=\"o\">,</span> <span class=\"n\">tt</span> <span class=\"o\">::</span><span class=\"bp\">ᵥ</span> <span class=\"n\">ff</span> <span class=\"o\">::</span><span class=\"bp\">ᵥ</span> <span class=\"n\">vector.nil</span><span class=\"o\">],</span>\n  <span class=\"n\">state</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">ff</span><span class=\"o\">,</span> <span class=\"n\">ff</span> <span class=\"o\">::</span><span class=\"bp\">ᵥ</span> <span class=\"n\">tt</span> <span class=\"o\">::</span><span class=\"bp\">ᵥ</span> <span class=\"n\">vector.nil</span><span class=\"o\">),</span>\n  <span class=\"n\">indices</span> <span class=\"o\">:=</span> <span class=\"n\">c</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">mk3unique</span> <span class=\"o\">(</span><span class=\"n\">c</span><span class=\"o\">:</span> <span class=\"n\">vector</span> <span class=\"n\">ℕ</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">gatenode</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">valence</span> <span class=\"o\">:=</span> <span class=\"mi\">3</span><span class=\"o\">,</span>\n  <span class=\"n\">possib</span> <span class=\"o\">:=</span> <span class=\"o\">[</span>\n    <span class=\"n\">ff</span> <span class=\"o\">::</span><span class=\"bp\">ᵥ</span> <span class=\"n\">ff</span> <span class=\"o\">::</span><span class=\"bp\">ᵥ</span> <span class=\"n\">tt</span> <span class=\"o\">::</span><span class=\"bp\">ᵥ</span> <span class=\"n\">vector.nil</span><span class=\"o\">,</span>\n    <span class=\"n\">ff</span> <span class=\"o\">::</span><span class=\"bp\">ᵥ</span> <span class=\"n\">tt</span> <span class=\"o\">::</span><span class=\"bp\">ᵥ</span> <span class=\"n\">ff</span> <span class=\"o\">::</span><span class=\"bp\">ᵥ</span> <span class=\"n\">vector.nil</span><span class=\"o\">,</span>\n    <span class=\"n\">tt</span> <span class=\"o\">::</span><span class=\"bp\">ᵥ</span> <span class=\"n\">ff</span> <span class=\"o\">::</span><span class=\"bp\">ᵥ</span> <span class=\"n\">ff</span> <span class=\"o\">::</span><span class=\"bp\">ᵥ</span> <span class=\"n\">vector.nil</span>\n  <span class=\"o\">],</span>\n  <span class=\"n\">state</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">ff</span><span class=\"o\">,</span> <span class=\"n\">ff</span> <span class=\"o\">::</span><span class=\"bp\">ᵥ</span>  <span class=\"n\">ff</span> <span class=\"o\">::</span><span class=\"bp\">ᵥ</span>  <span class=\"n\">tt</span> <span class=\"o\">::</span><span class=\"bp\">ᵥ</span> <span class=\"n\">vector.nil</span><span class=\"o\">),</span>\n  <span class=\"n\">indices</span> <span class=\"o\">:=</span> <span class=\"n\">c</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">satnet</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">bts</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">bitnode</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">gts</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">gatenode</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">nextbits</span> <span class=\"n\">nextgates</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">table</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">ℕ</span> <span class=\"bp\">×</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"n\">bool</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">tablesequence</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"n\">ℕ</span> <span class=\"bp\">×</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"n\">bool</span><span class=\"o\">)))</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">solv1</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">satnet</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">satnet</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">bts</span> <span class=\"o\">:=</span> <span class=\"n\">s.bts</span><span class=\"o\">,</span>\n  <span class=\"n\">gts</span> <span class=\"o\">:=</span> <span class=\"n\">s.gts</span><span class=\"o\">,</span>\n  <span class=\"n\">nextbits</span> <span class=\"o\">:=</span>\n    <span class=\"k\">if</span> <span class=\"n\">s.bts.any</span> <span class=\"n\">bitnode.isconstant</span> <span class=\"k\">then</span>\n      <span class=\"o\">(</span><span class=\"n\">s.bts.enum.filter</span> <span class=\"o\">(</span><span class=\"bp\">λ</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">_</span><span class=\"bp\">×</span><span class=\"n\">bitnode</span><span class=\"o\">,</span> <span class=\"n\">x.2.isconstant</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">prod.fst</span>\n    <span class=\"k\">else</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">],</span>\n  <span class=\"n\">nextgates</span> <span class=\"o\">:=</span> <span class=\"n\">s.nextgates</span><span class=\"o\">,</span>\n  <span class=\"n\">table</span> <span class=\"o\">:=</span> <span class=\"n\">s.table</span><span class=\"o\">,</span>\n  <span class=\"n\">tablesequence</span> <span class=\"o\">:=</span> <span class=\"o\">[]</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 257242526,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1634060364
    },
    {
        "content": "<p>I don't know how to make sense of the definition of <code>set</code> in <code>solv2</code>; the <code>list.map</code> and <code>list.foldr</code> calls don't have enough arguments</p>",
        "id": 257243456,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1634060758
    },
    {
        "content": "<p>you should definitely break this down into bite sized pieces and ask questions one at a time</p>",
        "id": 257243724,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1634060871
    },
    {
        "content": "<p>i changed the set to this</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">let</span> <span class=\"n\">set</span><span class=\"o\">:</span><span class=\"n\">list</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"n\">list.erase_dup</span>\n  <span class=\"o\">(</span> <span class=\"n\">list.foldr</span> <span class=\"n\">list.append</span> <span class=\"o\">(</span>\n          <span class=\"n\">list.map</span> <span class=\"n\">prod.fst</span> <span class=\"bp\">∘</span> <span class=\"n\">bitnode.indices</span>\n          <span class=\"o\">(</span>\n            <span class=\"n\">list.filter</span> <span class=\"o\">(</span><span class=\"bp\">λ</span><span class=\"n\">x</span><span class=\"o\">,(</span> <span class=\"bp\">¬</span> <span class=\"o\">(</span><span class=\"n\">bitnode.considered</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">tt</span><span class=\"o\">))</span>\n            <span class=\"o\">(</span>\n              <span class=\"n\">list.map</span>\n              <span class=\"o\">(</span><span class=\"bp\">λ</span><span class=\"n\">x</span><span class=\"o\">,(</span>\n                <span class=\"n\">list.nth_le</span> <span class=\"n\">s.bts</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">dec_trivial</span><span class=\"o\">)</span>\n              <span class=\"o\">))</span>\n              <span class=\"n\">s.nextbits</span>\n            <span class=\"o\">)</span>\n          <span class=\"o\">)</span>\n        <span class=\"o\">)</span>\n    <span class=\"o\">)</span>\n</code></pre></div>",
        "id": 257244905,
        "sender_full_name": "Jared green",
        "timestamp": 1634061328
    },
    {
        "content": "<p>subtype.val is the underlying function of what?</p>",
        "id": 257245075,
        "sender_full_name": "Jared green",
        "timestamp": 1634061394
    },
    {
        "content": "<p>If I replace the <code>dec_trivial</code> with <code>sorry</code> it still does not type check, <code>bitnode.indices</code> doesn't have the right type</p>",
        "id": 257245112,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1634061413
    },
    {
        "content": "<p>do you want it to be <code>list.map (prod.fst ∘ bitnode.indices) ...</code>?</p>",
        "id": 257245209,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1634061454
    },
    {
        "content": "<p>that also doesn't work</p>",
        "id": 257245228,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1634061462
    },
    {
        "content": "<p>Can you say in words what you are trying to express?</p>",
        "id": 257245325,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1634061492
    },
    {
        "content": "<p>the pointers to the gatenodes that are connected to the bitnodes that nextbits points to.</p>",
        "id": 257245584,
        "sender_full_name": "Jared green",
        "timestamp": 1634061595
    },
    {
        "content": "<p>and the <code>foldr</code> is still missing an argument; it takes 3 arguments, the function to fold, the initial value and the list. You have no initial value</p>",
        "id": 257245587,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1634061596
    },
    {
        "content": "<p>what does points to mean here?</p>",
        "id": 257245805,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1634061651
    },
    {
        "content": "<p>what should happen if <code>s.nextbits</code> contains an index out of range of <code>s.bts</code>?</p>",
        "id": 257245914,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1634061704
    },
    {
        "content": "<p>one easy thing to do is filter those indices out, so you get <code>s.nextbits.filter_map (list.nth s.bts)</code></p>",
        "id": 257246042,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1634061742
    },
    {
        "content": "<p>the starting value is []</p>",
        "id": 257246056,
        "sender_full_name": "Jared green",
        "timestamp": 1634061748
    },
    {
        "content": "<p>the pointers are the indexes in the corresponding list where the connected node is at</p>",
        "id": 257246229,
        "sender_full_name": "Jared green",
        "timestamp": 1634061821
    },
    {
        "content": "<p>still not sure where you want to go with that <code>list.map prod.fst ∘ bitnode.indices</code> part</p>",
        "id": 257246279,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1634061840
    },
    {
        "content": "<p>if a function like vetnet is used as a refinement to satnet, the indices should not be out of range.</p>",
        "id": 257246458,
        "sender_full_name": "Jared green",
        "timestamp": 1634061898
    },
    {
        "content": "<p>So <code>s.nextbits.filter_map (list.nth s.bts)</code> is the collection of bitnodes pointed to by nextbits. where do <code>considered</code> and <code>indices</code> come up?</p>",
        "id": 257246497,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1634061914
    },
    {
        "content": "<p>Sure, but the types don't say that so you have to decide what to do anyway</p>",
        "id": 257246558,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1634061943
    },
    {
        "content": "<p><code>filter_map</code> is an easy way to dodge the issue with <code>nth_le</code></p>",
        "id": 257246674,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1634061976
    },
    {
        "content": "<p>Alternatively, you can give an instance of <code>inhabited bitset</code> and then you can use <code>list.inth</code></p>",
        "id": 257246737,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1634062004
    },
    {
        "content": "<p>the second of the ordered pairs that bitnode.indices uses connects to a particular line of a gatenode</p>",
        "id": 257246989,
        "sender_full_name": "Jared green",
        "timestamp": 1634062092
    },
    {
        "content": "<p>aha, I think you want this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">let</span> <span class=\"n\">set</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(((</span><span class=\"n\">s.nextbits.filter_map</span> <span class=\"o\">(</span><span class=\"n\">list.nth</span> <span class=\"n\">s.bts</span><span class=\"o\">))</span>\n    <span class=\"bp\">.</span><span class=\"n\">filter</span> <span class=\"o\">(</span><span class=\"bp\">λ</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"bp\">¬</span> <span class=\"n\">bitnode.considered</span> <span class=\"n\">x</span><span class=\"o\">))</span>\n    <span class=\"bp\">.</span><span class=\"n\">bind</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">bitnode</span><span class=\"o\">,</span> <span class=\"n\">x.indices.map</span> <span class=\"n\">prod.fst</span><span class=\"o\">))</span>\n    <span class=\"bp\">.</span><span class=\"n\">erase_dup</span>\n</code></pre></div>",
        "id": 257247314,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1634062220
    },
    {
        "content": "<p>i prefer to use filter_map</p>",
        "id": 257247366,
        "sender_full_name": "Jared green",
        "timestamp": 1634062252
    },
    {
        "content": "<p>Here's a way to write it monadically:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">let</span> <span class=\"n\">set</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"n\">list.erase_dup</span> <span class=\"bp\">$</span> <span class=\"k\">do</span>\n  <span class=\"n\">n</span> <span class=\"bp\">←</span> <span class=\"n\">s.nextbits</span><span class=\"o\">,</span>\n  <span class=\"n\">x</span> <span class=\"bp\">←</span> <span class=\"o\">(</span><span class=\"n\">list.nth</span> <span class=\"n\">s.bts</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_list</span><span class=\"o\">,</span>\n  <span class=\"n\">guard</span> <span class=\"o\">(</span><span class=\"bp\">¬</span> <span class=\"n\">bitnode.considered</span> <span class=\"n\">x</span><span class=\"o\">),</span>\n  <span class=\"n\">i</span> <span class=\"bp\">←</span> <span class=\"n\">x.indices</span><span class=\"o\">,</span>\n  <span class=\"n\">pure</span> <span class=\"n\">i.1</span>\n</code></pre></div>",
        "id": 257247627,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1634062369
    },
    {
        "content": "<p>does it matter?</p>",
        "id": 257247658,
        "sender_full_name": "Jared green",
        "timestamp": 1634062387
    },
    {
        "content": "<p>what do you mean?</p>",
        "id": 257247680,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1634062398
    },
    {
        "content": "<p>It's a matter of taste</p>",
        "id": 257247703,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1634062411
    },
    {
        "content": "<p>what would inform the choice to instead use the monadic version?</p>",
        "id": 257247805,
        "sender_full_name": "Jared green",
        "timestamp": 1634062452
    },
    {
        "content": "<p>it's a bit easier to write and maintain</p>",
        "id": 257247844,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1634062472
    },
    {
        "content": "<p>easier to understand?</p>",
        "id": 257247888,
        "sender_full_name": "Jared green",
        "timestamp": 1634062496
    },
    {
        "content": "<p>Both of the last two versions I wrote are okay for understanding, but normally you wouldn't be writing all these lists explicitly and instead you would describe things more declaratively, by describing the property that should hold about the values and letting lean figure out how to compute it</p>",
        "id": 257248126,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1634062589
    },
    {
        "content": "<p>it still looks too much like haskell code atm</p>",
        "id": 257248245,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1634062648
    },
    {
        "content": "<p>anyway i used the former</p>",
        "id": 257248291,
        "sender_full_name": "Jared green",
        "timestamp": 1634062668
    },
    {
        "content": "<p>what looks too much like haskell?</p>",
        "id": 257248513,
        "sender_full_name": "Jared green",
        "timestamp": 1634062746
    },
    {
        "content": "<p>Maybe it might help to start at the beginning, with the problem modeling. What are <code>bitnode</code> and <code>gatenode</code>, and how do the fields accomplish what they need to do?</p>",
        "id": 257248631,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1634062801
    },
    {
        "content": "<p>I suspect there are a number of missing propositional fields</p>",
        "id": 257248745,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1634062834
    },
    {
        "content": "<p>Where does this idea of having all those lines with only parentheses come from?</p>",
        "id": 257249342,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1634063059
    },
    {
        "content": "<p>the entire network is composed of nodes representing bits and logic gates. a bit can be connected to the lines of any number of gates, while each line of a gate can only be connected to one bit. possib is an exhaustive enumeration of the ways the bits a gate is connected to can take on values.  the algorithm that i was going for moves a front of consideration across the network, and bitnode.considered and gatenode.state.fst indicate that the node has been passed by.</p>",
        "id": 257249705,
        "sender_full_name": "Jared green",
        "timestamp": 1634063213
    },
    {
        "content": "<p>that sounds like <code>bitnode.considered</code> should not be a part of <code>bitnode</code> then</p>",
        "id": 257249817,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1634063275
    },
    {
        "content": "<p>What is the data required to define a network?</p>",
        "id": 257249891,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1634063301
    },
    {
        "content": "<p>What is the input and output of the algorithm?</p>",
        "id": 257249963,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1634063331
    },
    {
        "content": "<p>all the perentheses are necessary to tell what branch of the function graph you are looking at. it also help lean call on the antire value rather than the function that produced it.</p>",
        "id": 257249982,
        "sender_full_name": "Jared green",
        "timestamp": 1634063340
    },
    {
        "content": "<p>I think patrick is referring to the formatting of the parentheses, not their presence</p>",
        "id": 257250087,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1634063386
    },
    {
        "content": "<p>bitnode.considered is required for efficiency.</p>",
        "id": 257250108,
        "sender_full_name": "Jared green",
        "timestamp": 1634063398
    },
    {
        "content": "<p>efficiency in what sense?</p>",
        "id": 257250169,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1634063408
    },
    {
        "content": "<p>the formatting helps me personally to read what is there.</p>",
        "id": 257250240,
        "sender_full_name": "Jared green",
        "timestamp": 1634063440
    },
    {
        "content": "<p>I mean to say that your <code>considered</code> data should be separate from the network, since it's not part of the input</p>",
        "id": 257250267,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1634063456
    },
    {
        "content": "<p>it is linked to the bitnode by necessity.</p>",
        "id": 257250339,
        "sender_full_name": "Jared green",
        "timestamp": 1634063491
    },
    {
        "content": "<p>it can be layered over the bitnode just as well, thanks to dependent types</p>",
        "id": 257250372,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1634063510
    },
    {
        "content": "<p>but maybe that's getting ahead of ourselves. What are the other fields in <code>bitnode</code>? What do you mean by a \"bit\"? Is this like an internal wire in a logic gate diagram, or an external wire?</p>",
        "id": 257250600,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1634063618
    },
    {
        "content": "<p>the former.</p>",
        "id": 257250666,
        "sender_full_name": "Jared green",
        "timestamp": 1634063642
    },
    {
        "content": "<p>It seems like the network (the graph) should be separate from the space of states of the network (assignments of {0, 1} to the wires), but the current form doesn't seem to make a distinction</p>",
        "id": 257250869,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1634063732
    },
    {
        "content": "<p>why?</p>",
        "id": 257250982,
        "sender_full_name": "Jared green",
        "timestamp": 1634063778
    },
    {
        "content": "<p>Otherwise you can't talk about properties of networks, only properties of states. For example an unstable network (i.e. one with no valid assignment) can't be expressed</p>",
        "id": 257251320,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1634063919
    },
    {
        "content": "<p>Same as how formulas and assignments are distinguished in SAT</p>",
        "id": 257251400,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1634063958
    },
    {
        "content": "<p>an example, please.</p>",
        "id": 257251898,
        "sender_full_name": "Jared green",
        "timestamp": 1634064154
    },
    {
        "content": "<p>the way satnet is formulated, one does not necessarily have an output.</p>",
        "id": 257252238,
        "sender_full_name": "Jared green",
        "timestamp": 1634064293
    },
    {
        "content": "<p>I'm thinking of something like this for defining a network:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">network</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">bits</span> <span class=\"n\">gates</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">valence</span> <span class=\"o\">:</span> <span class=\"n\">gates</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">valuation</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">gates</span><span class=\"o\">,</span> <span class=\"n\">vector</span> <span class=\"n\">bool</span> <span class=\"o\">(</span><span class=\"n\">valence</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">bool</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">input</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">gates</span><span class=\"o\">,</span> <span class=\"n\">vector</span> <span class=\"n\">bits</span> <span class=\"o\">(</span><span class=\"n\">valence</span> <span class=\"n\">g</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">output</span> <span class=\"o\">:</span> <span class=\"n\">gates</span> <span class=\"bp\">→</span> <span class=\"n\">bits</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">mknot</span> <span class=\"o\">:</span> <span class=\"n\">network</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">bits</span> <span class=\"o\">:=</span> <span class=\"n\">bool</span><span class=\"o\">,</span>\n  <span class=\"n\">gates</span> <span class=\"o\">:=</span> <span class=\"n\">unit</span><span class=\"o\">,</span>\n  <span class=\"n\">valence</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">,</span>\n  <span class=\"n\">valuation</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">bnot</span> <span class=\"o\">(</span><span class=\"n\">v.get</span> <span class=\"mi\">0</span><span class=\"o\">),</span>\n  <span class=\"n\">input</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">ff</span> <span class=\"o\">::</span><span class=\"bp\">ᵥ</span> <span class=\"n\">vector.nil</span><span class=\"o\">,</span>\n  <span class=\"n\">output</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">tt</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 257252895,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1634064561
    },
    {
        "content": "<p>if there were equivalent functions (to all the ones being used) that can operate on those fields, then that would work.</p>",
        "id": 257253418,
        "sender_full_name": "Jared green",
        "timestamp": 1634064785
    },
    {
        "content": "<p>And an assignment would look like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">assignment</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">network</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">value</span> <span class=\"o\">:</span> <span class=\"n\">n.bits</span> <span class=\"bp\">→</span> <span class=\"n\">bool</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">valid</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">g</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">n.output</span> <span class=\"n\">g</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">n.valuation</span> <span class=\"n\">g</span> <span class=\"o\">((</span><span class=\"n\">n.input</span> <span class=\"n\">g</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">value</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">value</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 257253545,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1634064837
    },
    {
        "content": "<p>but the reason i use lists is that such an implementation lends itself to optimization.</p>",
        "id": 257253713,
        "sender_full_name": "Jared green",
        "timestamp": 1634064904
    },
    {
        "content": "<p>This is for the abstract theory, where the lists get in the way. Once you have proofs about the abstract theory, the algorithm can be a refinement of it using lists and working in a special case where everything is finite and decidable</p>",
        "id": 257253964,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1634064999
    },
    {
        "content": "<p>fine.</p>",
        "id": 257254092,
        "sender_full_name": "Jared green",
        "timestamp": 1634065063
    },
    {
        "content": "<p>In fact, you will find that <code>vector</code> is not used much in mathlib, and there is some syntax sugar for <code>fin n -&gt; A</code> style lists</p>",
        "id": 257254103,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1634065067
    },
    {
        "content": "<p>I think it is in <code>data.matrix.notation</code>, you can write <code>![a, b, c]</code> to get a <code>fin 3 -&gt; A</code></p>",
        "id": 257254202,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1634065096
    },
    {
        "content": "<p>the reason i used vector was so that certain lists would have the same length.</p>",
        "id": 257254368,
        "sender_full_name": "Jared green",
        "timestamp": 1634065172
    },
    {
        "content": "<p>It looks like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.matrix.notation</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">network</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">bits</span> <span class=\"n\">gates</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">valence</span> <span class=\"o\">:</span> <span class=\"n\">gates</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">valuation</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">gates</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"o\">(</span><span class=\"n\">valence</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">bool</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">bool</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">input</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">gates</span><span class=\"o\">,</span> <span class=\"n\">fin</span> <span class=\"o\">(</span><span class=\"n\">valence</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">bits</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">output</span> <span class=\"o\">:</span> <span class=\"n\">gates</span> <span class=\"bp\">→</span> <span class=\"n\">bits</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">mknot</span> <span class=\"o\">:</span> <span class=\"n\">network</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">bits</span> <span class=\"o\">:=</span> <span class=\"n\">bool</span><span class=\"o\">,</span>\n  <span class=\"n\">gates</span> <span class=\"o\">:=</span> <span class=\"n\">unit</span><span class=\"o\">,</span>\n  <span class=\"n\">valence</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">,</span>\n  <span class=\"n\">valuation</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">bnot</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"mi\">0</span><span class=\"o\">),</span>\n  <span class=\"n\">input</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"n\">ff</span><span class=\"o\">],</span>\n  <span class=\"n\">output</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">tt</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">assignment</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">network</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">value</span> <span class=\"o\">:</span> <span class=\"n\">n.bits</span> <span class=\"bp\">→</span> <span class=\"n\">bool</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">valid</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">g</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">n.output</span> <span class=\"n\">g</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">n.valuation</span> <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">value</span> <span class=\"o\">(</span><span class=\"n\">n.input</span> <span class=\"n\">g</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"n\">value</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 257254555,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1634065226
    },
    {
        "content": "<p><code>fin n -&gt; A</code> is also fixed length lists, but you can compose them easier than lists, just using function composition</p>",
        "id": 257254617,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1634065249
    },
    {
        "content": "<p>what is fin n?</p>",
        "id": 257254762,
        "sender_full_name": "Jared green",
        "timestamp": 1634065312
    },
    {
        "content": "<p>it is the set of natural numbers less than <code>n</code></p>",
        "id": 257254849,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1634065331
    },
    {
        "content": "<p>it's the canonical type with <code>n</code> elements</p>",
        "id": 257254912,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1634065358
    },
    {
        "content": "<p>ok</p>",
        "id": 257255016,
        "sender_full_name": "Jared green",
        "timestamp": 1634065397
    },
    {
        "content": "<p>What is <code>satnet</code> supposed to be?</p>",
        "id": 257255076,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1634065415
    },
    {
        "content": "<p>'satnet' is the type of a network of bitnodes and gatenodes. the name is due to the fact that any SAT instance can be used to build one.</p>",
        "id": 257255412,
        "sender_full_name": "Jared green",
        "timestamp": 1634065560
    },
    {
        "content": "<p>*and vice versa</p>",
        "id": 257255565,
        "sender_full_name": "Jared green",
        "timestamp": 1634065614
    },
    {
        "content": "<p>Here's a network which contains every SAT network as a sub-DAG:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">namespace</span> <span class=\"n\">SAT</span>\n<span class=\"kn\">section</span>\n<span class=\"kd\">parameters</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">formula</span>\n<span class=\"bp\">|</span> <span class=\"n\">var</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">formula</span>\n<span class=\"bp\">|</span> <span class=\"n\">true</span> <span class=\"o\">:</span> <span class=\"n\">formula</span>\n<span class=\"bp\">|</span> <span class=\"n\">and</span> <span class=\"o\">:</span> <span class=\"n\">formula</span> <span class=\"bp\">→</span> <span class=\"n\">formula</span> <span class=\"bp\">→</span> <span class=\"n\">formula</span>\n<span class=\"bp\">|</span> <span class=\"n\">not</span> <span class=\"o\">:</span> <span class=\"n\">formula</span> <span class=\"bp\">→</span> <span class=\"n\">formula</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">gate</span>\n<span class=\"bp\">|</span> <span class=\"n\">true</span> <span class=\"o\">:</span> <span class=\"n\">gate</span>\n<span class=\"bp\">|</span> <span class=\"n\">and</span> <span class=\"o\">:</span> <span class=\"n\">formula</span> <span class=\"bp\">→</span> <span class=\"n\">formula</span> <span class=\"bp\">→</span> <span class=\"n\">gate</span>\n<span class=\"bp\">|</span> <span class=\"n\">not</span> <span class=\"o\">:</span> <span class=\"n\">formula</span> <span class=\"bp\">→</span> <span class=\"n\">gate</span>\n\n<span class=\"kn\">protected</span> <span class=\"kd\">def</span> <span class=\"n\">valence</span> <span class=\"o\">:</span> <span class=\"n\">gate</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span>\n<span class=\"bp\">|</span> <span class=\"n\">gate.true</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">gate.and</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"mi\">2</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">gate.not</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span>\n\n<span class=\"kn\">protected</span> <span class=\"kd\">def</span> <span class=\"n\">valuation</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">gate</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"o\">(</span><span class=\"n\">valence</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">bool</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">bool</span>\n<span class=\"bp\">|</span> <span class=\"n\">gate.true</span> <span class=\"n\">v</span> <span class=\"o\">:=</span> <span class=\"n\">tt</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">gate.and</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span><span class=\"o\">:</span><span class=\"n\">fin</span> <span class=\"mi\">2</span> <span class=\"bp\">→</span> <span class=\"n\">bool</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">v</span> <span class=\"mi\">0</span> <span class=\"bp\">&amp;&amp;</span> <span class=\"n\">v</span> <span class=\"mi\">1</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">gate.not</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span><span class=\"o\">:</span><span class=\"n\">fin</span> <span class=\"mi\">1</span> <span class=\"bp\">→</span> <span class=\"n\">bool</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">bnot</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n\n<span class=\"kn\">protected</span> <span class=\"kd\">def</span> <span class=\"n\">input</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">gate</span><span class=\"o\">,</span> <span class=\"n\">fin</span> <span class=\"o\">(</span><span class=\"n\">valence</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">formula</span>\n<span class=\"bp\">|</span> <span class=\"n\">gate.true</span> <span class=\"o\">:=</span> <span class=\"bp\">!</span><span class=\"o\">[]</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">gate.and</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">]</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">gate.not</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">]</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">output</span> <span class=\"o\">:</span> <span class=\"n\">gate</span> <span class=\"bp\">→</span> <span class=\"n\">formula</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"n\">true</span> <span class=\"o\">:</span> <span class=\"n\">output</span> <span class=\"n\">gate.true</span> <span class=\"n\">formula.true</span>\n<span class=\"bp\">|</span> <span class=\"n\">and</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">output</span> <span class=\"o\">(</span><span class=\"n\">gate.and</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">formula.and</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">not</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">output</span> <span class=\"o\">(</span><span class=\"n\">gate.not</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">formula.not</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n\n<span class=\"kn\">protected</span> <span class=\"kd\">def</span> <span class=\"n\">network</span> <span class=\"o\">:</span> <span class=\"n\">network</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">bits</span> <span class=\"o\">:=</span> <span class=\"n\">formula</span><span class=\"o\">,</span>\n  <span class=\"n\">gates</span> <span class=\"o\">:=</span> <span class=\"n\">gate</span><span class=\"o\">,</span>\n  <span class=\"n\">valence</span> <span class=\"o\">:=</span> <span class=\"n\">valence</span><span class=\"o\">,</span>\n  <span class=\"n\">valuation</span> <span class=\"o\">:=</span> <span class=\"n\">valuation</span><span class=\"o\">,</span>\n  <span class=\"n\">input</span> <span class=\"o\">:=</span> <span class=\"n\">input</span><span class=\"o\">,</span>\n  <span class=\"n\">output</span> <span class=\"o\">:=</span> <span class=\"n\">output</span> <span class=\"o\">}</span>\n\n<span class=\"kn\">protected</span> <span class=\"kd\">def</span> <span class=\"n\">eval</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">bool</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">formula</span> <span class=\"bp\">→</span> <span class=\"n\">bool</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">formula.var</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">f</span> <span class=\"n\">v</span>\n<span class=\"bp\">|</span> <span class=\"n\">formula.true</span> <span class=\"o\">:=</span> <span class=\"n\">tt</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">formula.and</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">eval</span> <span class=\"n\">a</span> <span class=\"bp\">&amp;&amp;</span> <span class=\"n\">eval</span> <span class=\"n\">b</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">formula.not</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">bnot</span> <span class=\"o\">(</span><span class=\"n\">eval</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n\n<span class=\"kn\">protected</span> <span class=\"kd\">def</span> <span class=\"n\">assignment</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">bool</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">assignment</span> <span class=\"n\">network</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">value</span> <span class=\"o\">:=</span> <span class=\"n\">eval</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n  <span class=\"n\">valid</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">g</span> <span class=\"n\">b</span> <span class=\"n\">out</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">cases</span> <span class=\"n\">out</span><span class=\"bp\">;</span> <span class=\"n\">refl</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">end</span>\n<span class=\"kd\">end</span> <span class=\"n\">SAT</span>\n</code></pre></div>",
        "id": 257258348,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1634066776
    },
    {
        "content": "<p>what purpose does this serve?</p>",
        "id": 257259472,
        "sender_full_name": "Jared green",
        "timestamp": 1634067263
    },
    {
        "content": "<p>it might help to know what the algorithm does. <br>\nwhat is does is construct a sequence of truth tables,  related to subsets of the gates, such that<br>\neach subset and the next intersects<br>\neach subset contains one gate that all the previous ones did not<br>\neach table is maximal for the set it represents and compatible with the previous one, while the choice of which gate is used minimizes the size of the table <br>\nand all the subsets together cover the entire network. <br>\nthis process generates the information to certify satisfiability<br>\nthen an entry in the last table is chosen, then in each previous one an entry compatible with the successive table is also chosen.<br>\nthis is how a particular solution is generated.</p>",
        "id": 257263261,
        "sender_full_name": "Jared green",
        "timestamp": 1634068878
    },
    {
        "content": "<p>the lack of directionality specifically allows for information to traverse the network in all directions, so each gate is like 'if the lines are not in an allowed state then the network's valuations are invalid'</p>",
        "id": 257270633,
        "sender_full_name": "Jared green",
        "timestamp": 1634072057
    }
]
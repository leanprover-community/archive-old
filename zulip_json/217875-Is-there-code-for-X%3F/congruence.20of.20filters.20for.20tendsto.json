[
    {
        "content": "<p>I don't think this is possible, but I wanted to check. I'm trying to show that if a function tends to the same value along two different filters, then those filters are the same. Of course, under the requirement, the function only hits that value once. I'm not sure how to state that last part in Lean, though so its missing from the mwe. So, for instance, for the function <code>f x =1/x</code>, if f approaches positive infinity along filter 1 and it approaches positive infinity along filter 2, then filter 1 and filter 2 must be the same. I have a feeling that this doesn't work, for a similar reason as to why we have to say an unbounded function has  a local minimum, instead of calling it a global minimum. </p>\n<p>mwe: </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span>\n<span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñù</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">‚Ñù</span><span class=\"o\">}</span>\n<span class=\"o\">{</span><span class=\"n\">l‚ÇÅ</span> <span class=\"n\">l‚ÇÇ</span> <span class=\"o\">:</span> <span class=\"n\">filter</span> <span class=\"n\">‚Ñù</span><span class=\"o\">}</span>\n<span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">filter.tendsto</span> <span class=\"n\">f</span> <span class=\"n\">l‚ÇÅ</span> <span class=\"n\">filter.at_top</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"n\">filter.tendsto</span> <span class=\"n\">f</span> <span class=\"n\">l‚ÇÇ</span> <span class=\"n\">filter.at_top</span><span class=\"o\">)</span>\n<span class=\"c1\">--a premise that f only appraoches filter.at_top once</span>\n<span class=\"o\">:</span> <span class=\"n\">l‚ÇÅ</span> <span class=\"bp\">=</span> <span class=\"n\">l‚ÇÇ</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 294942688,
        "sender_full_name": "Max Bobbin",
        "timestamp": 1661287054
    },
    {
        "content": "<p>This isn't true.</p>",
        "id": 294942954,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1661287193
    },
    {
        "content": "<p>The function <code>f x := 1 / x</code> approaches <code>at_top</code> along many filters.</p>",
        "id": 294943106,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1661287251
    },
    {
        "content": "<p>And I don't see any true statement that would look like this. Under assumption <code>tendsto f l‚ÇÅ at_top</code>, any filter <code>l‚ÇÇ</code> such that <code>l‚ÇÇ ‚â§ l‚ÇÅ</code> will satisfy <code>tendsto f l‚ÇÇ at_top</code>.</p>",
        "id": 294943168,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1661287284
    },
    {
        "content": "<p>e.g., <code>ùìù[s] 0</code> where <code>s</code> is any set of positive numbers whose only limit point is <code>0</code>.</p>",
        "id": 294943283,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1661287335
    },
    {
        "content": "<p>Max I think your intuition of filters isn't sufficiently good. Shameless self-advertisement: I think you should try to watch the beginning of <a href=\"https://icerm.brown.edu/video_archive/?play=2899\">https://icerm.brown.edu/video_archive/?play=2899</a></p>",
        "id": 294943364,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1661287387
    },
    {
        "content": "<p>Ok, this is what I thought. I'm trying to replicate a derivation from a scientific paper, and they do something similar to this with limits. They want to say that since the function approaches infinity when you approach this,  and, since we want the function to approach infinity when we approach this specific constant, these two constants are equal</p>",
        "id": 294943382,
        "sender_full_name": "Max Bobbin",
        "timestamp": 1661287396
    },
    {
        "content": "<p>It most definitely isn't. I'm just trying to convert filters to my knowledge of limits</p>",
        "id": 294943437,
        "sender_full_name": "Max Bobbin",
        "timestamp": 1661287421
    },
    {
        "content": "<p>that might be possible, just replace arbitrary filters with neighborhood filters.</p>",
        "id": 294943480,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1661287438
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span>\n<span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñù</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">‚Ñù</span><span class=\"o\">}</span>\n<span class=\"o\">{</span><span class=\"n\">l‚ÇÅ</span> <span class=\"n\">l‚ÇÇ</span> <span class=\"o\">:</span> <span class=\"n\">filter</span> <span class=\"n\">‚Ñù</span><span class=\"o\">}</span>\n<span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">filter.tendsto</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"bp\">ùìù</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">filter.at_top</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"n\">filter.tendsto</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"bp\">ùìù</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">filter.at_top</span><span class=\"o\">)</span>\n<span class=\"c1\">--a premise that f only appraoches filter.at_top once</span>\n<span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 294943614,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1661287491
    },
    {
        "content": "<p>I think thats what I mean. As pointed out above, my knowledge of filters is not good, so I just used general filter. However, yes that may be what I mean</p>",
        "id": 294943712,
        "sender_full_name": "Max Bobbin",
        "timestamp": 1661287531
    },
    {
        "content": "<p>That theorem sounds false as well: what about something like <code>sec x</code>? This approaches infinity at lots of different points</p>",
        "id": 294943821,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1661287580
    },
    {
        "content": "<p>My assumption is that the premise I have in the comments would have to bound the function to require it approach the value only once. So for <code>sec x</code>, it would have to be bounded</p>",
        "id": 294943908,
        "sender_full_name": "Max Bobbin",
        "timestamp": 1661287630
    },
    {
        "content": "<p>it's bounded, and approaches infinity?</p>",
        "id": 294943921,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1661287646
    },
    {
        "content": "<p>Would <code>1/x</code> bounded from (-1,1) still approach infinity at zero?</p>",
        "id": 294944068,
        "sender_full_name": "Max Bobbin",
        "timestamp": 1661287703
    },
    {
        "content": "<p>Mario, there is a premise missing in the code I wrote, it's in a comment.</p>",
        "id": 294944099,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1661287719
    },
    {
        "content": "<p>only from above</p>",
        "id": 294944100,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1661287719
    },
    {
        "content": "<p>I'm not sure how you would express that premise in a way that makes your theorem non-trivial (i.e., not just applying the hypotheses to each other)</p>",
        "id": 294944216,
        "sender_full_name": "Reid Barton",
        "timestamp": 1661287773
    },
    {
        "content": "<p>I think Max want's something like: \"this function has a limit of ‚àû at a, and is bounded on a complement of a neighborhood of a\"</p>",
        "id": 294944334,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1661287812
    },
    {
        "content": "<p><code>sec x</code> is also bounded on a complement of a neighborhood of any of its poles</p>",
        "id": 294944430,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1661287871
    },
    {
        "content": "<p>the neighborhood would just encompass both poles</p>",
        "id": 294944568,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1661287924
    },
    {
        "content": "<p>oh wait, <code>sec x</code> isn't a good example, <code>(sec x)^2</code> is better</p>",
        "id": 294944680,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1661287973
    },
    {
        "content": "<p>Sorry, I should have said, \"bounded on the complement of anything in a filter basis for ùìù a\"</p>",
        "id": 294944686,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1661287975
    },
    {
        "content": "<p>I think that makes it work (but I agree it's really messy and there are probably better ways to go about it).</p>",
        "id": 294944738,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1661287999
    },
    {
        "content": "<p>I think that has the same issue, you can just choose a weird filter base with a member that happens to span the other poles</p>",
        "id": 294944788,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1661288027
    },
    {
        "content": "<p>not every element of that filter basis can contain the other pole if the filter in question is ùìù a</p>",
        "id": 294944928,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1661288083
    },
    {
        "content": "<p>or am I being silly?</p>",
        "id": 294944949,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1661288096
    },
    {
        "content": "<p>sure, but you just said there exists one</p>",
        "id": 294944957,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1661288101
    },
    {
        "content": "<p>No, I'm saying this: \"there exists a filter basis for <code>ùìù a</code> such that for every element in this basis <code>f</code> is bounded on the complement of that set\"</p>",
        "id": 294945099,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1661288163
    },
    {
        "content": "<p>oh I see, that's more plausible</p>",
        "id": 294945161,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1661288192
    },
    {
        "content": "<p>The filter basis isn't really necessary I guess, you just want bounded on the complement of any neighborhood.</p>",
        "id": 294945406,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1661288294
    },
    {
        "content": "<p>That sounds like it should be a general filter definition, some kind of co-tendsto</p>",
        "id": 294945602,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1661288384
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">co_tendsto</span> <span class=\"o\">{</span><span class=\"n\">Œ±</span> <span class=\"n\">Œ≤</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">Œ≤</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l‚ÇÅ</span> <span class=\"o\">:</span> <span class=\"n\">filter</span> <span class=\"n\">Œ±</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l‚ÇÇ</span> <span class=\"o\">:</span> <span class=\"n\">filter</span> <span class=\"n\">Œ≤</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">‚àÄ</span> <span class=\"n\">s</span> <span class=\"bp\">‚àà</span> <span class=\"n\">l‚ÇÅ</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">''</span> <span class=\"n\">s</span><span class=\"bp\">·∂ú</span><span class=\"o\">)</span><span class=\"bp\">·∂ú</span> <span class=\"bp\">‚àà</span> <span class=\"n\">l‚ÇÇ</span>\n</code></pre></div>",
        "id": 294946175,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1661288599
    },
    {
        "content": "<p>maybe it's that the comap of the cobounded filter along <code>f</code> is contained in <code>ùìù a</code>?</p>",
        "id": 294946435,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1661288704
    },
    {
        "content": "<p>oh nice, <code>mem_comap_iff_compl</code> says exactly that <code>s ‚àà comap f l ‚Üî (f '' s·∂ú)·∂ú ‚àà l</code></p>",
        "id": 294947132,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1661289055
    },
    {
        "content": "<p>so this really is co-tendsto</p>",
        "id": 294947167,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1661289074
    },
    {
        "content": "<p>Yeah, I think saying that <code>f : Œ± ‚Üí Œ≤</code> is bounded on complements of neighborhoods of <code>a</code> is equivalent to <code>filter.comap f (cobounded Œ≤) ‚â§ ùìù a</code>.</p>",
        "id": 294947398,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1661289214
    },
    {
        "content": "<p>This isn't the cobounded filter though</p>",
        "id": 294947430,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1661289239
    },
    {
        "content": "<p>I think</p>",
        "id": 294947432,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1661289241
    },
    {
        "content": "<p><em>what</em> isn't the cobounded filter?</p>",
        "id": 294947539,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1661289275
    },
    {
        "content": "<p>the definition I gave is equivalent to <code>l‚ÇÇ.comap f ‚â§ l‚ÇÅ</code></p>",
        "id": 294947796,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1661289403
    },
    {
        "content": "<p>oh okay, we're talking about different things I think. You're talking about a \"co-tendsto\" and I'm still talking about the specific thing.</p>",
        "id": 294947979,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1661289483
    },
    {
        "content": "<p>To apply to the specific thing you would use <code>co_tendsto f (N a) at_top</code></p>",
        "id": 294948026,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1661289513
    },
    {
        "content": "<p>I'm not sure exactly what cobounded means here, I found <code>is_cobounded</code> which isn't what we want and <code>cobounded</code> is a typeclass (I have no idea what bornology is)</p>",
        "id": 294948122,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1661289558
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/bornology.cobounded\">docs#bornology.cobounded</a> supposedly?</p>",
        "id": 294948250,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1661289627
    },
    {
        "content": "<p>yes, but that's a typeclass like I said, I don't know what the filter actually is</p>",
        "id": 294948271,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1661289649
    },
    {
        "content": "<p>but the reals have the bornology from the metric.</p>",
        "id": 294948286,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1661289662
    },
    {
        "content": "<p>in a metric space, the cobounded filter consists of exactly the complements of bounded sets.</p>",
        "id": 294948327,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1661289684
    },
    {
        "content": "<p>So these are not exactly the same thing, I'm interpreting it as co-bounded above (<code>at_top</code>)  and not just metrically co-bounded</p>",
        "id": 294948590,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1661289839
    },
    {
        "content": "<p>Mario, a bornology is just an abstraction of boundedness. It's a collection of sets which is closed under finite unions, subsets and contains all singletons. But in mathlib we dualize it so that it's just a filter smaller than the cofinite filter.</p>",
        "id": 294948661,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1661289859
    },
    {
        "content": "<p>No, I agree, they are not exactly the same thing.</p>",
        "id": 294948669,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1661289868
    },
    {
        "content": "<p>My condition (bounded away from <code>a</code>) seemed like what the OP as getting at (which implies your condition since the <code>at_top</code> filter is smaller than the <code>cobounded</code> filter), and I was just trying to formalize that.</p>",
        "id": 294948880,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1661289978
    },
    {
        "content": "<p>So the interesting theorem here is that <code>co_tendsto f l‚ÇÅ l‚ÇÇ</code> and <code>tendsto f l‚ÇÅ' l‚ÇÇ</code> implies <code>l‚ÇÅ ‚â§ l‚ÇÅ'</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">order.filter.basic</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">co_tendsto</span> <span class=\"o\">{</span><span class=\"n\">Œ±</span> <span class=\"n\">Œ≤</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">Œ≤</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l‚ÇÅ</span> <span class=\"o\">:</span> <span class=\"n\">filter</span> <span class=\"n\">Œ±</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l‚ÇÇ</span> <span class=\"o\">:</span> <span class=\"n\">filter</span> <span class=\"n\">Œ≤</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">l‚ÇÇ.comap</span> <span class=\"n\">f</span> <span class=\"bp\">‚â§</span> <span class=\"n\">l‚ÇÅ</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">filter</span>\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">Œ±</span> <span class=\"n\">Œ≤</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">Œ≤</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l‚ÇÅ</span> <span class=\"n\">l‚ÇÅ'</span> <span class=\"o\">:</span> <span class=\"n\">filter</span> <span class=\"n\">Œ±</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l‚ÇÇ</span> <span class=\"o\">:</span> <span class=\"n\">filter</span> <span class=\"n\">Œ≤</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">tendsto</span> <span class=\"n\">f</span> <span class=\"n\">l‚ÇÅ</span> <span class=\"n\">l‚ÇÇ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"n\">co_tendsto</span> <span class=\"n\">f</span> <span class=\"n\">l‚ÇÅ'</span> <span class=\"n\">l‚ÇÇ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">l‚ÇÅ</span> <span class=\"bp\">‚â§</span> <span class=\"n\">l‚ÇÅ'</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">map_le_iff_le_comap.1</span> <span class=\"n\">h1</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"n\">h2</span>\n</code></pre></div>",
        "id": 294949395,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1661290242
    },
    {
        "content": "<p>I mean, isn't this just something to do with the fact that map and comap are a Galois connection?</p>",
        "id": 294949481,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1661290303
    },
    {
        "content": "<p>yes, it's a quite trivial proof as you can see</p>",
        "id": 294949527,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1661290322
    },
    {
        "content": "<p>but it means that if <code>co_tendsto f (ùìù a) at_top</code> and <code>tendsto f (ùìù b) at_top</code> then <code>ùìù a &lt;= ùìù b</code> so <code>a = b</code> if the top space is hausdorff</p>",
        "id": 294949600,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1661290356
    },
    {
        "content": "<p>Right, but I mean, it's just a lemma about Galois connections that's already in the library, presumably.</p>",
        "id": 294949601,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1661290357
    },
    {
        "content": "<p>I don't think <code>co_tendsto</code> is</p>",
        "id": 294949620,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1661290368
    },
    {
        "content": "<p>I mean I just made it up</p>",
        "id": 294949637,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1661290375
    },
    {
        "content": "<p>note that <code>map_le_iff_le_comap</code> <em>is</em> the galois connection lemma</p>",
        "id": 294949682,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1661290409
    },
    {
        "content": "<p>sorry, I didn't actually read the proof <span aria-label=\"sheep\" class=\"emoji emoji-1f411\" role=\"img\" title=\"sheep\">:sheep:</span></p>",
        "id": 294949781,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1661290448
    },
    {
        "content": "<p>Thank you. This is really helpful. I will have to watch those videos linked and learn more so I can understand whats happening</p>",
        "id": 294950405,
        "sender_full_name": "Max Bobbin",
        "timestamp": 1661290818
    },
    {
        "content": "<p>So are you saying we should actually have a definition for <code>co_tendsto</code>, as opposed to the expanded version? I thought we have <code>tendsto</code> primarily because limits occur everywhere. Do we have a lot of use cases for <code>co_tendsto</code> outside of the above lemma?</p>",
        "id": 294950441,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1661290850
    },
    {
        "content": "<p>it seems to be similarly \"foundational\" to <code>tendsto</code>, but it's possible we don't have a lot of applications just like we don't have many uses for coinductive types</p>",
        "id": 294950516,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1661290911
    },
    {
        "content": "<p>I would defer to someone else who works with the topology / filter library more for whether this is actually a good idea for a library definition. <span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> , any thoughts?</p>",
        "id": 294950658,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1661290988
    },
    {
        "content": "<p>I haven't read this conversation, I'm playing with semantic highlighting. I want to finish writing doc about that and then I'll come back here if I don't forget.</p>",
        "id": 294950783,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1661291083
    },
    {
        "content": "<p>The question is whether it would make sense to have a definition for \"co-tendsto\" (name TBD), which says something like \"it is consistent that f converges to l2 at l1\". It has a nice duality with tendsto:</p>\n<ul>\n<li><code>tendsto f l‚ÇÅ l‚ÇÇ ‚Üî l‚ÇÅ ‚â§ l‚ÇÇ.comap f</code></li>\n<li><code>co_tendsto f l‚ÇÅ l‚ÇÇ ‚Üî l‚ÇÇ.comap f ‚â§ l‚ÇÅ</code></li>\n</ul>",
        "id": 294950993,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1661291204
    },
    {
        "content": "<p>it will have a ton of monotonicity and galois connection style theorems, so it would actually be some work to add</p>",
        "id": 294951039,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1661291235
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/congruence.20of.20filters.20for.20tendsto/near/294950993\">said</a>:</p>\n<blockquote>\n<p>... \"it is consistent that f converges to l2 at l1\".</p>\n</blockquote>\n<p>That doesn't seem like the right description in English to me, but maybe I'm wrong.</p>",
        "id": 294951376,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1661291422
    },
    {
        "content": "<p>It's a bit abstract, not sure how best to gloss it. \"<code>f</code> definitely doesn't converge to l2 anywhere other than l1\"</p>",
        "id": 294951817,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1661291751
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/congruence.20of.20filters.20for.20tendsto/near/294943364\">said</a>:</p>\n<blockquote>\n<p>Max I think your intuition of filters isn't sufficiently good. Shameless self-advertisement: I think you should try to watch the beginning of <a href=\"https://icerm.brown.edu/video_archive/?play=2899\">https://icerm.brown.edu/video_archive/?play=2899</a></p>\n</blockquote>\n<p>thanks for this talk, this was very interesting! just to check the exercises: they are the stuff in <a href=\"https://leanprover-community.github.io/mathematics_in_lean/01_Introduction.html#getting-started\">https://leanprover-community.github.io/mathematics_in_lean/01_Introduction.html#getting-started</a>, right?</p>",
        "id": 294952127,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1661291910
    },
    {
        "content": "<p>Mario, that reads more correct to me.</p>",
        "id": 294952187,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1661291945
    },
    {
        "content": "<p>The only case I can think of is in the hypothesis of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/cauchy.comap\">docs#cauchy.comap</a>. I will read this conversation again tomorrow because I‚Äôm half sleeping right now</p>",
        "id": 294953301,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1661292597
    },
    {
        "content": "<p>Now that I posted my semantic highlighting stuff I read that discussion. I'm not convinced the \"cotendsto\" definition is useful in mathlib.</p>",
        "id": 294954306,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1661293207
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/congruence.20of.20filters.20for.20tendsto/near/294950516\">said</a>:</p>\n<blockquote>\n<p>it seems to be similarly \"foundational\" to <code>tendsto</code></p>\n</blockquote>\n<p>I disagree. The definition of <code>tendsto f F G</code> is much nicer because you can phrase it both as <code>map f F ‚â§ G</code> and <code>F ‚â§ comap f G</code>. Your definition doesn't have this symmetry.</p>",
        "id": 294954455,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1661293322
    },
    {
        "content": "<p>That's true. You can make it higher order, like <code>\\forall l', l' &lt;= l‚ÇÇ.comap f -&gt; l' &lt;= l‚ÇÅ</code> and this latter thing can be rewritten in terms of <code>map</code> (since it's just a <code>tendsto</code>)</p>",
        "id": 294954626,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1661293416
    },
    {
        "content": "<p>I suspect there is some name for this operation with adjunctions but I don't know</p>",
        "id": 294954731,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1661293469
    },
    {
        "content": "<p>there should also be a version of this on the other side: <code>l‚ÇÇ ‚â§ l‚ÇÅ.map f</code></p>",
        "id": 294954912,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1661293569
    },
    {
        "content": "<p>so perhaps it's not a \"co-\" thing exactly but more like a left adjunction or something like that</p>",
        "id": 294954950,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1661293606
    },
    {
        "content": "<p>I don't understand what you're trying to say, but it's getting late here.</p>",
        "id": 294955309,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1661293814
    },
    {
        "content": "<p>I looked into <a href=\"https://ncatlab.org/nlab/show/adjoint+string\">https://ncatlab.org/nlab/show/adjoint+string</a> and <a href=\"https://mathoverflow.net/questions/46877/natural-examples-of-sequences-of-adjoint-functors\">https://mathoverflow.net/questions/46877/natural-examples-of-sequences-of-adjoint-functors</a> but found no examples about filters.</p>",
        "id": 294955537,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1661293939
    },
    {
        "content": "<p>Do you mean you hoped that <code>map f</code> could be right adjoint or <code>comap f</code> could be a left adjoint? This is simply wrong.</p>",
        "id": 294955647,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1661294030
    },
    {
        "content": "<p>Remember that for maps between complete lattices the adjoint functor theorem is extremely simple to state (and prove): a map is a left (resp. right) adjoint iff it commutes with sup (resp. inf).</p>",
        "id": 294955767,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1661294095
    },
    {
        "content": "<p>Fair enough. I think the most I want to claim at this point is that for an arbitrary galois connection <code>u b &lt;= a</code> is a relation you can say, and it sometimes has uses</p>",
        "id": 294955996,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1661294228
    },
    {
        "content": "<p>I will certainly agree it's not nearly as well behaved as <code>a &lt;= u b</code></p>",
        "id": 294956021,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1661294254
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/congruence.20of.20filters.20for.20tendsto/near/294955767\">said</a>:</p>\n<blockquote>\n<p>Remember that for maps between complete lattices the adjoint functor theorem is extremely simple to state (and prove): a map is a left (resp. right) adjoint iff it commutes with sup (resp. inf).</p>\n</blockquote>\n<p>That's a nice theorem to know! But it seems we have both <a href=\"https://leanprover-community.github.io/mathlib_docs/find/filter.comap_infi\">docs#filter.comap_infi</a> and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/filter.comap_supr\">docs#filter.comap_supr</a> ?</p>",
        "id": 294956213,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1661294390
    },
    {
        "content": "<p>Oh yes, I wrote too fast for <code>comap f</code>.</p>",
        "id": 294956344,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1661294478
    },
    {
        "content": "<p>I never noticed that.</p>",
        "id": 294956357,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1661294494
    },
    {
        "content": "<p>We only have <a href=\"https://leanprover-community.github.io/mathlib_docs/find/filter.map_infi_le\">docs#filter.map_infi_le</a> so the adjunction chain can't be extended that way (at least for general <code>m : Œ± ‚Üí Œ≤</code>).</p>",
        "id": 294956444,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1661294533
    },
    {
        "content": "<p>Now we have a nice exercise to do: figure out a concrete description of the right-adjoint to <code>comap f</code></p>",
        "id": 294956453,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1661294544
    },
    {
        "content": "<p>I'm really tired because I should have remember that <code>set.preimage f</code> is also a left adjoint.</p>",
        "id": 294956544,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1661294613
    },
    {
        "content": "<p>So it's not surprising that its extension to filters is both a right and a left adjoint.</p>",
        "id": 294956571,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1661294636
    },
    {
        "content": "<p>IIRC we actually have the definition for sets</p>",
        "id": 294956635,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1661294665
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/set.kern_image\">docs#set.kern_image</a></p>",
        "id": 294956811,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1661294765
    },
    {
        "content": "<p>I have difficulties switching at high frequency between Lean 4 meta-programming and adjunctions at 1am.</p>",
        "id": 294956820,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1661294774
    },
    {
        "content": "<p>Maybe I just disproved the theory claiming that programming monads belong to category theory.</p>",
        "id": 294956887,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1661294834
    },
    {
        "content": "<p>So <code>set.image f</code> doesn't admit a left adjoint unless <code>f</code> is a bijection, because it doesn't preserve intersections unless <code>f</code> is injective and doesn't preserve nullary intersection unless <code>f</code> is surjective, and similarly <code>set.kern_image f</code> doesn't admit a right adjoint because it's just <code>(f '' s·∂ú)·∂ú</code>.</p>\n<p>I've worked out the right adjoint to <a href=\"https://leanprover-community.github.io/mathlib_docs/find/filter.comap\">docs#filter.comap</a>, which I call <code>filter.kern_map</code>, and it also admits a simple description: for <code>m : Œ± ‚Üí Œ≤</code> and <code>f : filter Œ±</code>, <code>(f.kern_map m).sets</code> is exactly the image of <code>f.sets</code> under <code>set.kern_image m</code>. Compare this to <code>(f.map m).sets</code>, which is exactly the preimage of <code>f.sets</code> under <code>set.preimage m</code>. The appearance of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/set.kern_image\">docs#set.kern_image</a> is because <a href=\"https://leanprover-community.github.io/mathlib_docs/find/filter.mem_comap'\">docs#filter.mem_comap'</a> says exactly (is defeq to) <code>s ‚àà g.comap m ‚Üî s.kern_image m ‚àà g</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">order.filter.basic</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">Œ±</span> <span class=\"n\">Œ≤</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">Œ≤</span><span class=\"o\">)</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">set</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">kern_image_eq_compl</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">Œ±</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">s.kern_image</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">''</span> <span class=\"n\">s</span><span class=\"bp\">·∂ú</span><span class=\"o\">)</span><span class=\"bp\">·∂ú</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">ext1</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">kern_image</span><span class=\"o\">,</span> <span class=\"n\">mem_set_of_eq</span><span class=\"o\">,</span> <span class=\"n\">mem_compl_eq</span><span class=\"o\">,</span> <span class=\"n\">mem_image</span><span class=\"o\">,</span> <span class=\"n\">not_exists</span><span class=\"o\">,</span> <span class=\"n\">not_and</span><span class=\"o\">],</span>\n  <span class=\"n\">exact</span> <span class=\"n\">forall_congr</span> <span class=\"o\">(</span><span class=\"bp\">Œª</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">not_imp_not.symm</span><span class=\"o\">),</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">Œ±</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">Œ≤</span><span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">image_downward_closed</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">t</span> <span class=\"bp\">‚äÜ</span> <span class=\"n\">m</span> <span class=\"bp\">''</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"bp\">''</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">‚à©</span> <span class=\"n\">m</span> <span class=\"bp\">‚Åª¬π'</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">t</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">rwa</span> <span class=\"o\">[</span><span class=\"n\">image_inter_preimage</span><span class=\"o\">,</span> <span class=\"n\">inter_eq_right_iff_subset</span><span class=\"o\">]</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">kern_image_upward_closed</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">s.kern_image</span> <span class=\"n\">m</span> <span class=\"bp\">‚äÜ</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">‚à™</span> <span class=\"n\">m</span> <span class=\"bp\">‚Åª¬π'</span> <span class=\"n\">t</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">kern_image</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">t</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">kern_image_eq_compl</span><span class=\"o\">,</span> <span class=\"n\">compl_subset_comm</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">kern_image_eq_compl</span><span class=\"o\">,</span> <span class=\"n\">compl_union</span><span class=\"o\">,</span> <span class=\"bp\">‚Üê</span> <span class=\"n\">preimage_compl</span><span class=\"o\">,</span> <span class=\"n\">image_downward_closed</span> <span class=\"n\">m</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">compl_compl</span><span class=\"o\">],</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">set</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">filter</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">set</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">mem_comap''</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">Œ±</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">filter</span> <span class=\"n\">Œ≤</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">‚àà</span> <span class=\"n\">g.comap</span> <span class=\"n\">m</span> <span class=\"bp\">‚Üî</span> <span class=\"n\">s.kern_image</span> <span class=\"n\">m</span> <span class=\"bp\">‚àà</span> <span class=\"n\">g</span> <span class=\"o\">:=</span> <span class=\"n\">mem_comap'</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">kern_map</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">filter</span> <span class=\"n\">Œ±</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">filter</span> <span class=\"n\">Œ≤</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">sets</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">kern_image</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"bp\">''</span> <span class=\"n\">f.sets</span><span class=\"o\">,</span>\n  <span class=\"n\">univ_sets</span> <span class=\"o\">:=</span> <span class=\"o\">‚ü®</span><span class=\"n\">univ</span><span class=\"o\">,</span> <span class=\"n\">f.univ_sets</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">kern_image_eq_compl</span><span class=\"o\">]‚ü©,</span>\n  <span class=\"n\">sets_of_superset</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">rintro</span> <span class=\"n\">_</span> <span class=\"n\">t</span> <span class=\"o\">‚ü®</span><span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">hm</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">‚ü©</span> <span class=\"n\">hi</span><span class=\"o\">,</span>\n    <span class=\"n\">use</span> <span class=\"o\">[</span><span class=\"n\">s</span> <span class=\"bp\">‚à™</span> <span class=\"n\">m</span> <span class=\"bp\">‚Åª¬π'</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">f.sets_of_superset</span> <span class=\"n\">hm</span> <span class=\"o\">(</span><span class=\"n\">subset_union_left</span> <span class=\"n\">s</span> <span class=\"n\">_</span><span class=\"o\">)],</span>\n    <span class=\"n\">exact</span> <span class=\"n\">kern_image_upward_closed</span> <span class=\"n\">m</span> <span class=\"n\">hi</span><span class=\"o\">,</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">inter_sets</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">rintro</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">‚ü®</span><span class=\"n\">s‚ÇÅ</span><span class=\"o\">,</span> <span class=\"n\">h‚ÇÅ</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">‚ü©</span> <span class=\"o\">‚ü®</span><span class=\"n\">s‚ÇÇ</span><span class=\"o\">,</span> <span class=\"n\">h‚ÇÇ</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">‚ü©,</span>\n    <span class=\"n\">use</span> <span class=\"o\">[</span><span class=\"n\">s‚ÇÅ</span> <span class=\"bp\">‚à©</span> <span class=\"n\">s‚ÇÇ</span><span class=\"o\">,</span> <span class=\"n\">f.inter_sets</span> <span class=\"n\">h‚ÇÅ</span> <span class=\"n\">h‚ÇÇ</span><span class=\"o\">],</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">kern_image_eq_compl</span><span class=\"o\">,</span> <span class=\"n\">compl_inter</span><span class=\"o\">,</span> <span class=\"n\">image_union</span><span class=\"o\">,</span> <span class=\"n\">compl_union</span><span class=\"o\">],</span>\n  <span class=\"kd\">end</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">comap_kern_map</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">Œ≤</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">galois_connection</span> <span class=\"o\">(</span><span class=\"n\">comap</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">kern_map</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"bp\">Œª</span> <span class=\"n\">g</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"kd\">begin</span>\n  <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"n\">le_def</span><span class=\"o\">,</span> <span class=\"n\">mem_comap''</span><span class=\"o\">],</span> <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"n\">h</span> <span class=\"n\">_</span> <span class=\"o\">‚ü®</span><span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">hs</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">‚ü©,</span> <span class=\"n\">exact</span> <span class=\"n\">h</span> <span class=\"n\">s</span> <span class=\"n\">hs</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">h</span> <span class=\"n\">s</span> <span class=\"n\">hs</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">h</span> <span class=\"n\">_</span> <span class=\"o\">‚ü®</span><span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">hs</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">‚ü©</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">filter</span>\n\n\n<span class=\"c1\">-- miscellaneous lemmas unnecessary for the Galois connection</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">set</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">Œ±</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">Œ≤</span><span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">image_downward_closed'</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">t</span> <span class=\"bp\">‚äÜ</span> <span class=\"n\">m</span> <span class=\"bp\">''</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">t</span> <span class=\"bp\">‚àà</span> <span class=\"n\">set.range</span> <span class=\"o\">(</span><span class=\"n\">set.image</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">‚Üê</span> <span class=\"n\">inter_eq_right_iff_subset</span><span class=\"o\">,</span> <span class=\"bp\">‚Üê</span> <span class=\"n\">image_inter_preimage</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"o\">‚ü®</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">‚ü©</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">image_downward_closed''</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">t</span> <span class=\"bp\">‚äÜ</span> <span class=\"n\">m</span> <span class=\"bp\">''</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"bp\">''</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">‚Åª¬π'</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">t</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">‚Üê</span> <span class=\"n\">inter_eq_right_iff_subset</span><span class=\"o\">,</span> <span class=\"bp\">‚Üê</span> <span class=\"n\">image_inter_preimage</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">subset_antisymm</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"n\">image_preimage_subset</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">conv_lhs</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"bp\">‚Üê</span> <span class=\"n\">h</span> <span class=\"o\">},</span> <span class=\"n\">apply</span> <span class=\"n\">image_subset</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">inter_subset_right</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">kern_image_upward_closed'</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">s.kern_image</span> <span class=\"n\">m</span> <span class=\"bp\">‚äÜ</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">t</span> <span class=\"bp\">‚àà</span> <span class=\"n\">set.range</span> <span class=\"o\">(</span><span class=\"n\">set.kern_image</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">kern_image_eq_compl</span><span class=\"o\">,</span> <span class=\"n\">compl_subset_comm</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">‚ü®</span><span class=\"n\">s'</span><span class=\"o\">,</span> <span class=\"n\">h'</span><span class=\"o\">‚ü©</span> <span class=\"o\">:=</span> <span class=\"n\">image_downward_closed'</span> <span class=\"n\">m</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">use</span> <span class=\"n\">s'</span><span class=\"bp\">·∂ú</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">kern_image_eq_compl</span><span class=\"o\">,</span> <span class=\"n\">compl_compl</span><span class=\"o\">,</span> <span class=\"n\">h'</span><span class=\"o\">],</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">kern_image_upward_closed''</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">s.kern_image</span> <span class=\"n\">m</span> <span class=\"bp\">‚äÜ</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">‚Åª¬π'</span> <span class=\"n\">t</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">kern_image</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">t</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">kern_image_eq_compl</span><span class=\"o\">,</span> <span class=\"n\">compl_subset_comm</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">kern_image_eq_compl</span><span class=\"o\">,</span> <span class=\"bp\">‚Üê</span> <span class=\"n\">preimage_compl</span><span class=\"o\">,</span> <span class=\"n\">image_downward_closed''</span> <span class=\"n\">m</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">compl_compl</span><span class=\"o\">],</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">kern_image_mono</span> <span class=\"o\">{</span><span class=\"n\">s‚ÇÅ</span> <span class=\"n\">s‚ÇÇ</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">Œ±</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">s‚ÇÅ</span> <span class=\"bp\">‚äÜ</span> <span class=\"n\">s‚ÇÇ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">s‚ÇÅ.kern_image</span> <span class=\"n\">m</span> <span class=\"bp\">‚äÜ</span> <span class=\"n\">s‚ÇÇ.kern_image</span> <span class=\"n\">m</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">kern_image_eq_compl</span><span class=\"o\">,</span> <span class=\"n\">compl_subset_compl</span><span class=\"o\">],</span>\n  <span class=\"n\">apply</span> <span class=\"n\">image_subset</span> <span class=\"n\">m</span> <span class=\"o\">(</span><span class=\"n\">compl_subset_compl.2</span> <span class=\"n\">h</span><span class=\"o\">),</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">set</span>\n</code></pre></div>",
        "id": 294976522,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1661313293
    },
    {
        "content": "<p>Let me also mention<br>\n<code>extension of scalars ‚ä£ restriction of scalars ‚ä£ coextension of scalars</code><br>\n(<a href=\"https://github.com/leanprover-community/mathlib/pull/15529\">#15529</a>, functors between module categories induced by a ring hom)<br>\nwhich is apparently analogous the example<br>\n<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>f</mi><mo>‚àó</mo></msup><mo>‚ä£</mo><msub><mi>f</mi><mo>‚àó</mo></msub><mo>‚ä£</mo><msup><mi>f</mi><mo stretchy=\"false\">!</mo></msup></mrow><annotation encoding=\"application/x-tex\">f^*\\dashv f_*\\dashv f^!</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6887em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">‚àó</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">‚ä£</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1757em;\"><span style=\"top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">‚àó</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">‚ä£</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0435em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8491em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mclose mtight\">!</span></span></span></span></span></span></span></span></span></span></span> (functors between derived categories of sheaves induced by a proper morphism between algebraic varieties, see <a href=\"https://mathoverflow.net/a/46928/3332\">https://mathoverflow.net/a/46928/3332</a>)</p>",
        "id": 294977528,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1661314413
    },
    {
        "content": "<p>Nice! It can be used at least to simplify the proof of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/filter.comap_supr\">docs#filter.comap_supr</a></p>",
        "id": 294990814,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1661324871
    },
    {
        "content": "<p>But please stop using dot notation for the only purpose of reversing the order you would write things on paper. Once you open the relevant namespaces it's not longer to write <code>map f F</code> than <code>F.map f</code> and it makes it <em>much</em> clear that you are applying the function <code>map f</code> to <code>F</code>, and the same with <code>kern_image m s</code>.</p>",
        "id": 294990991,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1661324984
    },
    {
        "content": "<p>Haha, I think dot notation allows me to use the declaration name as an infix operator, just like in <code>m '' s</code>; I don't care so much about the order. I used the same notations '', ^-1 and ^k for filters on the scratch paper.</p>",
        "id": 294995582,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1661327442
    },
    {
        "content": "<p>also, there's 50 different <code>map</code>s and now opening namespaces means you can get clashes with <code>map_{xyz}</code> lemmas.</p>",
        "id": 294996405,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1661327844
    },
    {
        "content": "<p>There are no serious name clashes. I always start Lean 3 files with <code>open set function filter</code> before thinking.</p>",
        "id": 295007653,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1661332681
    },
    {
        "content": "<p>Junyan, what you do is not the analogue of writing <code>m '' s</code> with an infix <code>''</code>, it is the analogue of writing <code>s '' m</code> to mean <code>m '' s</code>.</p>",
        "id": 295007801,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1661332734
    },
    {
        "content": "<p>It seems there's special support in pretty printer/doc-gen for this purpose? For example in <a href=\"https://leanprover-community.github.io/mathlib_docs/find/multiset.sum_map_mul_left\">docs#multiset.sum_map_mul_left</a>, multiset.sum uses dot notation but <a href=\"http://multiset.map\">multiset.map</a> doesn't, even though in the source code dot notation is used everywhere. Or maybe the pretty printer doesn't use dot notation whenever it's not associated to the first argument?</p>",
        "id": 295069249,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1661354731
    },
    {
        "content": "<p>Is it <code>pp nodot</code> by any chance?</p>",
        "id": 295070080,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1661354959
    },
    {
        "content": "<p>The <code>pp_nodot</code> attribute is not added to <a href=\"https://leanprover-community.github.io/mathlib_docs/find/multiset.map/src\">src#multiset.map</a> at its definition or locally.</p>",
        "id": 295074055,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1661356213
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224323\">Junyan Xu</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/congruence.20of.20filters.20for.20tendsto/near/294976522\">said</a>:</p>\n<blockquote>\n<p>So <code>set.image f</code> doesn't admit a left adjoint unless <code>f</code> is a bijection, because it doesn't preserve intersections unless <code>f</code> is injective and doesn't preserve nullary intersection unless <code>f</code> is surjective, and similarly <code>set.kern_image f</code> doesn't admit a right adjoint because it's just <code>(f '' s·∂ú)·∂ú</code>.</p>\n<p>I've worked out the right adjoint to <a href=\"https://leanprover-community.github.io/mathlib_docs/find/filter.comap\">docs#filter.comap</a>, which I call <code>filter.kern_map</code>, and it also admits a simple description: for <code>m : Œ± ‚Üí Œ≤</code> and <code>f : filter Œ±</code>, <code>(f.kern_map m).sets</code> is exactly the image of <code>f.sets</code> under <code>set.kern_image m</code>. Compare this to <code>(f.map m).sets</code>, which is exactly the preimage of <code>f.sets</code> under <code>set.preimage m</code>. The appearance of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/set.kern_image\">docs#set.kern_image</a> is because <a href=\"https://leanprover-community.github.io/mathlib_docs/find/filter.mem_comap'\">docs#filter.mem_comap'</a> says exactly (is defeq to) <code>s ‚àà g.comap m ‚Üî s.kern_image m ‚àà g</code>.</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">order.filter.basic</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">Œ±</span> <span class=\"n\">Œ≤</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">Œ≤</span><span class=\"o\">)</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">set</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">kern_image_eq_compl</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">Œ±</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">s.kern_image</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">''</span> <span class=\"n\">s</span><span class=\"bp\">·∂ú</span><span class=\"o\">)</span><span class=\"bp\">·∂ú</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">ext1</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">kern_image</span><span class=\"o\">,</span> <span class=\"n\">mem_set_of_eq</span><span class=\"o\">,</span> <span class=\"n\">mem_compl_eq</span><span class=\"o\">,</span> <span class=\"n\">mem_image</span><span class=\"o\">,</span> <span class=\"n\">not_exists</span><span class=\"o\">,</span> <span class=\"n\">not_and</span><span class=\"o\">],</span>\n  <span class=\"n\">exact</span> <span class=\"n\">forall_congr</span> <span class=\"o\">(</span><span class=\"bp\">Œª</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">not_imp_not.symm</span><span class=\"o\">),</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">Œ±</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">Œ≤</span><span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">image_downward_closed</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">t</span> <span class=\"bp\">‚äÜ</span> <span class=\"n\">m</span> <span class=\"bp\">''</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"bp\">''</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">‚à©</span> <span class=\"n\">m</span> <span class=\"bp\">‚Åª¬π'</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">t</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">rwa</span> <span class=\"o\">[</span><span class=\"n\">image_inter_preimage</span><span class=\"o\">,</span> <span class=\"n\">inter_eq_right_iff_subset</span><span class=\"o\">]</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">kern_image_upward_closed</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">s.kern_image</span> <span class=\"n\">m</span> <span class=\"bp\">‚äÜ</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">‚à™</span> <span class=\"n\">m</span> <span class=\"bp\">‚Åª¬π'</span> <span class=\"n\">t</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">kern_image</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">t</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">kern_image_eq_compl</span><span class=\"o\">,</span> <span class=\"n\">compl_subset_comm</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">kern_image_eq_compl</span><span class=\"o\">,</span> <span class=\"n\">compl_union</span><span class=\"o\">,</span> <span class=\"bp\">‚Üê</span> <span class=\"n\">preimage_compl</span><span class=\"o\">,</span> <span class=\"n\">image_downward_closed</span> <span class=\"n\">m</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">compl_compl</span><span class=\"o\">],</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">set</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">filter</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">set</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">mem_comap''</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">Œ±</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">filter</span> <span class=\"n\">Œ≤</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">‚àà</span> <span class=\"n\">g.comap</span> <span class=\"n\">m</span> <span class=\"bp\">‚Üî</span> <span class=\"n\">s.kern_image</span> <span class=\"n\">m</span> <span class=\"bp\">‚àà</span> <span class=\"n\">g</span> <span class=\"o\">:=</span> <span class=\"n\">mem_comap'</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">kern_map</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">filter</span> <span class=\"n\">Œ±</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">filter</span> <span class=\"n\">Œ≤</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">sets</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">kern_image</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"bp\">''</span> <span class=\"n\">f.sets</span><span class=\"o\">,</span>\n  <span class=\"n\">univ_sets</span> <span class=\"o\">:=</span> <span class=\"o\">‚ü®</span><span class=\"n\">univ</span><span class=\"o\">,</span> <span class=\"n\">f.univ_sets</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">kern_image_eq_compl</span><span class=\"o\">]‚ü©,</span>\n  <span class=\"n\">sets_of_superset</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">rintro</span> <span class=\"n\">_</span> <span class=\"n\">t</span> <span class=\"o\">‚ü®</span><span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">hm</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">‚ü©</span> <span class=\"n\">hi</span><span class=\"o\">,</span>\n    <span class=\"n\">use</span> <span class=\"o\">[</span><span class=\"n\">s</span> <span class=\"bp\">‚à™</span> <span class=\"n\">m</span> <span class=\"bp\">‚Åª¬π'</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">f.sets_of_superset</span> <span class=\"n\">hm</span> <span class=\"o\">(</span><span class=\"n\">subset_union_left</span> <span class=\"n\">s</span> <span class=\"n\">_</span><span class=\"o\">)],</span>\n    <span class=\"n\">exact</span> <span class=\"n\">kern_image_upward_closed</span> <span class=\"n\">m</span> <span class=\"n\">hi</span><span class=\"o\">,</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">inter_sets</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">rintro</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">‚ü®</span><span class=\"n\">s‚ÇÅ</span><span class=\"o\">,</span> <span class=\"n\">h‚ÇÅ</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">‚ü©</span> <span class=\"o\">‚ü®</span><span class=\"n\">s‚ÇÇ</span><span class=\"o\">,</span> <span class=\"n\">h‚ÇÇ</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">‚ü©,</span>\n    <span class=\"n\">use</span> <span class=\"o\">[</span><span class=\"n\">s‚ÇÅ</span> <span class=\"bp\">‚à©</span> <span class=\"n\">s‚ÇÇ</span><span class=\"o\">,</span> <span class=\"n\">f.inter_sets</span> <span class=\"n\">h‚ÇÅ</span> <span class=\"n\">h‚ÇÇ</span><span class=\"o\">],</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">kern_image_eq_compl</span><span class=\"o\">,</span> <span class=\"n\">compl_inter</span><span class=\"o\">,</span> <span class=\"n\">image_union</span><span class=\"o\">,</span> <span class=\"n\">compl_union</span><span class=\"o\">],</span>\n  <span class=\"kd\">end</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">comap_kern_map</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">Œ≤</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">galois_connection</span> <span class=\"o\">(</span><span class=\"n\">comap</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">kern_map</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"bp\">Œª</span> <span class=\"n\">g</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"kd\">begin</span>\n  <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"n\">le_def</span><span class=\"o\">,</span> <span class=\"n\">mem_comap''</span><span class=\"o\">],</span> <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"n\">h</span> <span class=\"n\">_</span> <span class=\"o\">‚ü®</span><span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">hs</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">‚ü©,</span> <span class=\"n\">exact</span> <span class=\"n\">h</span> <span class=\"n\">s</span> <span class=\"n\">hs</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">h</span> <span class=\"n\">s</span> <span class=\"n\">hs</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">h</span> <span class=\"n\">_</span> <span class=\"o\">‚ü®</span><span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">hs</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">‚ü©</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">filter</span>\n\n\n<span class=\"c1\">-- miscellaneous lemmas unnecessary for the Galois connection</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">set</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">Œ±</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">Œ≤</span><span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">image_downward_closed'</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">t</span> <span class=\"bp\">‚äÜ</span> <span class=\"n\">m</span> <span class=\"bp\">''</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">t</span> <span class=\"bp\">‚àà</span> <span class=\"n\">set.range</span> <span class=\"o\">(</span><span class=\"n\">set.image</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">‚Üê</span> <span class=\"n\">inter_eq_right_iff_subset</span><span class=\"o\">,</span> <span class=\"bp\">‚Üê</span> <span class=\"n\">image_inter_preimage</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"o\">‚ü®</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">‚ü©</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">image_downward_closed''</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">t</span> <span class=\"bp\">‚äÜ</span> <span class=\"n\">m</span> <span class=\"bp\">''</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"bp\">''</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">‚Åª¬π'</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">t</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">‚Üê</span> <span class=\"n\">inter_eq_right_iff_subset</span><span class=\"o\">,</span> <span class=\"bp\">‚Üê</span> <span class=\"n\">image_inter_preimage</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">subset_antisymm</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"n\">image_preimage_subset</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">conv_lhs</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"bp\">‚Üê</span> <span class=\"n\">h</span> <span class=\"o\">},</span> <span class=\"n\">apply</span> <span class=\"n\">image_subset</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">inter_subset_right</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">kern_image_upward_closed'</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">s.kern_image</span> <span class=\"n\">m</span> <span class=\"bp\">‚äÜ</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">t</span> <span class=\"bp\">‚àà</span> <span class=\"n\">set.range</span> <span class=\"o\">(</span><span class=\"n\">set.kern_image</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">kern_image_eq_compl</span><span class=\"o\">,</span> <span class=\"n\">compl_subset_comm</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">‚ü®</span><span class=\"n\">s'</span><span class=\"o\">,</span> <span class=\"n\">h'</span><span class=\"o\">‚ü©</span> <span class=\"o\">:=</span> <span class=\"n\">image_downward_closed'</span> <span class=\"n\">m</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">use</span> <span class=\"n\">s'</span><span class=\"bp\">·∂ú</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">kern_image_eq_compl</span><span class=\"o\">,</span> <span class=\"n\">compl_compl</span><span class=\"o\">,</span> <span class=\"n\">h'</span><span class=\"o\">],</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">kern_image_upward_closed''</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">s.kern_image</span> <span class=\"n\">m</span> <span class=\"bp\">‚äÜ</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">‚Åª¬π'</span> <span class=\"n\">t</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">kern_image</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">t</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">kern_image_eq_compl</span><span class=\"o\">,</span> <span class=\"n\">compl_subset_comm</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">kern_image_eq_compl</span><span class=\"o\">,</span> <span class=\"bp\">‚Üê</span> <span class=\"n\">preimage_compl</span><span class=\"o\">,</span> <span class=\"n\">image_downward_closed''</span> <span class=\"n\">m</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">compl_compl</span><span class=\"o\">],</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">kern_image_mono</span> <span class=\"o\">{</span><span class=\"n\">s‚ÇÅ</span> <span class=\"n\">s‚ÇÇ</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">Œ±</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">s‚ÇÅ</span> <span class=\"bp\">‚äÜ</span> <span class=\"n\">s‚ÇÇ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">s‚ÇÅ.kern_image</span> <span class=\"n\">m</span> <span class=\"bp\">‚äÜ</span> <span class=\"n\">s‚ÇÇ.kern_image</span> <span class=\"n\">m</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">kern_image_eq_compl</span><span class=\"o\">,</span> <span class=\"n\">compl_subset_compl</span><span class=\"o\">],</span>\n  <span class=\"n\">apply</span> <span class=\"n\">image_subset</span> <span class=\"n\">m</span> <span class=\"o\">(</span><span class=\"n\">compl_subset_compl.2</span> <span class=\"n\">h</span><span class=\"o\">),</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">set</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Has any of this been PR-ed? I know it sounds crazy, but I need this for defining the space of test functions on an open set <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Œ©</mi></mrow><annotation encoding=\"application/x-tex\">\\Omega</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\">Œ©</span></span></span></span> of a finite dimensional vector space <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>E</mi></mrow><annotation encoding=\"application/x-tex\">E</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span></span></span></span> in a convenient way! </p>\n<p>Because I don't want to have \"extensions by zero\" all the time, I want <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">D</mi><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">Œ©</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\mathcal{D}(\\Omega)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathcal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mopen\">(</span><span class=\"mord\">Œ©</span><span class=\"mclose\">)</span></span></span></span> to be the type of smooth functions <em>defined on all of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>E</mi></mrow><annotation encoding=\"application/x-tex\">E</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span></span></span></span></em> and whose <a href=\"https://leanprover-community.github.io/mathlib_docs/find/tsupport\">docs#tsupport</a> is a compact subset <em>of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Œ©</mi></mrow><annotation encoding=\"application/x-tex\">\\Omega</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\">Œ©</span></span></span></span></em>. The problem is to encode the last condition in a convenient way that doesn't involve duplicating the API of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/has_compact_support\">docs#has_compact_support</a> for this relative case (for example, a naive combination of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/has_compact_support\">docs#has_compact_support</a> and \"support <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>‚äÜ</mo><mi mathvariant=\"normal\">Œ©</mi></mrow><annotation encoding=\"application/x-tex\">\\subseteq\\Omega</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719em;vertical-align:-0.136em;\"></span><span class=\"mrel\">‚äÜ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\">Œ©</span></span></span></span>\" makes proving the sum of two test functions is a test function annoying).</p>\n<p>So I want to apply the same trick as <a href=\"https://leanprover-community.github.io/mathlib_docs/find/has_compact_support_iff_eventually_eq\">docs#has_compact_support_iff_eventually_eq</a> but with a different filter, namely <code>‚®Ö (s : set S) (h : is_compact s), ùìü (coe '' s : set Œ±)·∂ú</code> (I am in a normed space so <a href=\"https://leanprover-community.github.io/mathlib_docs/find/cocompact\">docs#cocompact</a> = <a href=\"https://leanprover-community.github.io/mathlib_docs/find/coclosed_compact\">docs#coclosed_compact</a>). I've long been wondering if this could be defined from <a href=\"https://leanprover-community.github.io/mathlib_docs/find/cocompact\">docs#cocompact</a> by pure filter-theoretic nonsense, and I just realized that this is exactly <code>kern_map coe cocompact</code>, which is way more satisfying!</p>",
        "id": 302238889,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1664882584
    },
    {
        "content": "<p>No I haven't PR'd. Glad that the definition finds some actual use! I doubt I have time for the PR, and I think it's better that someone more familiar with the filter library PRs it, especially since you are probably adding more APIs to it. As shown in the proof above, the Galois connection is essentially known, as <a href=\"https://leanprover-community.github.io/mathlib_docs/find/filter.mem_comap''\">docs#filter.mem_comap''</a> in mathlib, and the main content of my work was to show <code>(kern_image m) '' f.sets</code> forms a filter. I also worked out some more relationships back then:<br>\n<a href=\"/user_uploads/3121/JXqogsJea8CtnmtaboxyxVyk/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/JXqogsJea8CtnmtaboxyxVyk/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/JXqogsJea8CtnmtaboxyxVyk/image.png\"></a></div>",
        "id": 302323253,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1664908530
    },
    {
        "content": "<p>The diagonal inclusion/generation are essneitally known in mathlib, and the middle top two are used in induced/coinduced topology, but I can't think of what the bottom row is good for.</p>",
        "id": 302323513,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1664908634
    }
]